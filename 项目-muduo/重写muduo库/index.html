<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="内容          muduo库的主要板块  base - 公共的代码文件 net - 网络相关的，如TcpServer、EventLoop、poller、protobuf、protorpc等等 我们主要写网络模块    cmake                        编写目标        主要编写muduo库的网络模块代码，以及改进mud">
<meta property="og:type" content="article">
<meta property="og:title" content="重写muduo库">
<meta property="og:url" content="https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE-muduo/%E9%87%8D%E5%86%99muduo%E5%BA%93/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:description" content="内容          muduo库的主要板块  base - 公共的代码文件 net - 网络相关的，如TcpServer、EventLoop、poller、protobuf、protorpc等等 我们主要写网络模块    cmake                        编写目标        主要编写muduo库的网络模块代码，以及改进mud">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-28T00:00:00.000Z">
<meta property="article:modified_time" content="2025-07-20T15:03:22.864Z">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>重写muduo库 | 罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE-muduo/%E9%87%8D%E5%86%99muduo%E5%BA%93/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">重写muduo库</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-20</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE-muduo/%E9%87%8D%E5%86%99muduo%E5%BA%93/" data-flag-title="重写muduo库"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>
<p>muduo库的主要板块</p>
<ol>
<li>base - 公共的代码文件</li>
<li>net - 网络相关的，如TcpServer、EventLoop、poller、protobuf、protorpc等等</li>
<li>我们主要写网络模块</li>
</ol>
</li>
<li>
<p>cmake</p>
</li>
</ol>

        <h1 id="编写目标"   >
          <a href="#编写目标" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#编写目标"></a> 编写目标</h1>
      
<p>主要编写muduo库的网络模块代码，以及改进muduo库在使用上的不便。</p>
<p>muduo库原本属于静态库，且需要依赖boost库。我们改进它，使他与原生C++标准库结合，并把它生成为<code>.so</code>动态库。</p>

        <h1 id="cmake"   >
          <a href="#cmake" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cmake"></a> cmake</h1>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.5</span>)</span><br><span class="line"><span class="keyword">project</span>(mymuduo)</span><br><span class="line"></span><br><span class="line"><span class="comment">#mymuduo 最终编译成so动态库，设置动态库的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<span class="comment">#注意不是OUTPUT_DIRECTORY.这两者有区别</span></span><br><span class="line"><span class="comment">#设置为调试模式 以及 声明C++11语言标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -std=c++11 -fPIC&quot;</span>)<span class="comment">#在较新的编译器后需要加-fPIC，以示生成的是动态库</span></span><br><span class="line"><span class="comment">#定义参与编译的源文件 起一个别名</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment">#编译生成动态库mymuduo</span></span><br><span class="line"><span class="keyword">add_library</span>(mymuduo SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></div></figure>

        <h1 id="辅助类"   >
          <a href="#辅助类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#辅助类"></a> 辅助类</h1>
      

        <h2 id="noncopyable"   >
          <a href="#noncopyable" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#noncopyable"></a> noncopyable</h2>
      
<p>noncopyable.h</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * noncopyable 被继承以后，</span></span><br><span class="line"><span class="comment"> * 派生类对象无法拷贝构造、相互赋值。</span></span><br><span class="line"><span class="comment"> * 无参构造、析构是默认处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noncopyable &amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="copyable"   >
          <a href="#copyable" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#copyable"></a> copyable</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">copyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">copyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">copyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="tcpserver概览"   >
          <a href="#tcpserver概览" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcpserver概览"></a> TcpServer概览</h1>
      
<p>需要封装以下属性：</p>
<ol>
<li>EventLoop对象指针 - 多路分发器，相当于epoll</li>
<li>InetAddress - 打包IP地址和端口号</li>
</ol>

        <h2 id="inetaddress"   >
          <a href="#inetaddress" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#inetaddress"></a> InetAddress</h2>
      
<ol>
<li>
<p>允许拷贝</p>
</li>
<li>
<p>成员变量是<code>sockaddr_in m_addr</code>，也可选择支持IPv6的<code>sockaddr_in6 m_addr6</code>。可用联合体表示。在本项目中，只使用IPv4的<code>m_addr</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span>		<span class="comment">//sockaddr_in / sockaddr_in6都在此文件下定义</span></span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>  m_addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> m_addr6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="eventloop概览"   >
          <a href="#eventloop概览" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#eventloop概览"></a> EventLoop概览</h2>
      
<ol>
<li>不允许拷贝</li>
<li>主要包含的成员之一：poller（相当于epoll），属性有sockfd及其上面绑定的事件</li>
<li>另一个主要的成员是channel，属性有fd、events、revents等等</li>
</ol>
<p>EventLoop就是要完成事件循环，事件循环最重要的几个动作：epoll（<strong>由poller负责</strong>）、epoll监听的fd及感兴趣的事件、实际<code>epoll_wait</code>后发生的事件。这些sockfd、感兴趣的事件、发生的事件都<strong>记录在channel中</strong>。</p>
<p>要写EventLoop就要理清楚EventLoop、Channel、Poller之间的关系。Reactor模型中，这三个组件整体对应着Demultiplex。</p>

        <h2 id="channel"   >
          <a href="#channel" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#channel"></a> Channel</h2>
      
<p>通道，封装了sockfd和其感兴趣的event，如EPOLLIN、EPOLLOUT事件。还绑定了poller返回的具体事件。</p>

        <h3 id="公有别名"   >
          <a href="#公有别名" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#公有别名"></a> 公有别名</h3>
      
<p>定义通用事件回调函数、只读事件回调函数的函数对象类型别名。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> EventCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="keyword">using</span> ReadEventCallback = std::function&lt;<span class="built_in">void</span>(Timestamp)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数"   >
          <a href="#成员函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h3>
      
<ol>
<li>
<p>构造/析构函数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Channel</span>(EventLoop * loop, <span class="type">int</span> fd);</span><br><span class="line">    ~<span class="built_in">Channel</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>handleEvent</code>：fd得到poller的通知后，处理事件</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>setXxxCallback(EventCallback cb)</code>：对外提供的设置回调函数对象的接口</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_readCallback = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(EventCallback cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_writeCallback = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_closeCallback = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_errorCallback = std::<span class="built_in">move</span>(cb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>void tie(const std::shared_ptr&lt;void&gt;&amp;)</code>：防止channel被手动remove后，还在执行回调操作</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tie</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;<span class="type">void</span>&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>fd</code>、<code>events</code>、<code>revents</code>相关：</p>
<ol>
<li>
<p><code>int fd() const &#123;return m_fd;&#125;</code></p>
</li>
<li>
<p><code>int events() const &#123;return m_events;&#125;</code></p>
</li>
<li>
<p><code>void set_revents(int revt)</code>：向poller提供的设置revents的接口</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">set_revents</span><span class="params">(<span class="type">int</span> revt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_revents = revt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>判断函数：判断有没有注册事件等等</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_events == kNoneEvent;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isWriting</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_events &amp; kWriteEvent;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isReading</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_events &amp; kReadEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>使能、使不能函数：设置fd相应的事件状态。对<code>m_events</code>进行位操作之后调用<code>update()</code>，即<code>epoll_ctl</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_events |= kReadEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableReading</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_events &amp;= ~kReadEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_events |= kWriteEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_events &amp;= ~kWriteEvent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_events = kNoneEvent;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>
</li>
<li>
<p>与EventLoop相关 - 获取所属的Loop</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EventLoop * <span class="title">ownerLoop</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_loop;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>删除 - remove()</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>update() - 相当于调用<code>epoll_ctl</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleEventWithGuard - 受保护地处理事件</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>for poller的index</p>
</li>
</ol>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_index;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_index</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;m_index = idx;&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量"></a> 成员变量</h3>
      
<ol>
<li>
<p><code>kXxxEvent</code>：以下三个变量描述当前fd的状态，没有感兴趣的事件or对读事件感兴趣or对写事件感兴趣？</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>m_xxxCallback</code>：四个函数对象，可以绑定外部传入的相关操作。因为channel知道发生了哪些事情（revents记录），所以channel负责调用具体事件的回调函数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ReadEventCallback m_readCallback;</span><br><span class="line">    EventCallback	  m_writeCallback;</span><br><span class="line">    EventCallback	  m_closeCallback;</span><br><span class="line">    EventCallback	  m_errorCallback;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>EventLoop *m_loop</code>：事件循环</p>
</li>
<li>
<p><code>m_fd</code>：fd，即Poller监听的对象</p>
</li>
<li>
<p><code>m_events</code>：fd感兴趣的事件注册信息</p>
</li>
<li>
<p><code>m_revents</code>：Poller操作的fd上具体发生的事件</p>
</li>
<li>
<p><code>m_index</code>：？</p>
</li>
<li>
<p><code>std::weak_ptr&lt;void&gt; m_tie</code>：防止手动调用remove channel后仍使用此channel，用于监听跨线程的对象生存状态。</p>
<blockquote>
<p><code>shared_ptr</code>和<code>weak_ptr</code>配合使用可以发挥两个能力：</p>
<ol>
<li>解决shread_ptr循环引用问题</li>
<li>weak_ptr在多线程程序中可监听资源的生存状态，方法是尝试提升为强指针，若提升成功，则可以访问；若提升失败说明则资源被释放掉了。</li>
</ol>
</blockquote>
<blockquote>
<p>tie的意思是绑定，那么m_tie要和谁绑定呢？——自己。</p>
<p>绑定自己的工具还可以用另一个工具，<code>shared_from_this</code>，可以尝试得到当前对象的强智能指针。</p>
</blockquote>
</li>
<li>
<p><code>bool m_tied</code>：配合<code>m_tie</code>使用</p>
</li>
</ol>

        <h2 id="poller"   >
          <a href="#poller" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#poller"></a> Poller</h2>
      

        <h3 id="成员变量-2"   >
          <a href="#成员变量-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-2"></a> 成员变量</h3>
      
<p>成员变量中包含一个存储<code>&lt;int, Channel*&gt;</code>的map。</p>
<blockquote>
<p>poller监听的channel从何而来？EventLoop中有ChannelList以及Poller，则poller监听的肯定是EventLoop中所保存的channel。即这些channel在poller中也被保存了。</p>
</blockquote>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="type">int</span>, Channel*&gt;;</span><br><span class="line">    ChannelMap m_channels;</span><br></pre></td></tr></table></div></figure>
<p>还有一个成员变量，<code>m_ownerLoop</code>，指明了从属于哪个loop。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop * m_ownerLoop;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数-2"   >
          <a href="#成员函数-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-2"></a> 成员函数</h3>
      
<ol>
<li>
<p>构造/析构函数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Poller</span>(EventLoop *loop);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Poller</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>poll</code> - 提供给系统的统一的一个IO复用接口</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList * activeChannels)</span> </span>= <span class="number">0</span>;</span><br><span class="line">参数：</span><br><span class="line">    timeoutMs       - 超时时间，毫秒为单位</span><br><span class="line">    activeChannels  - 当前激活的、对事件注册好的channel列表</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>与事件的注册、注销有过的</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 当fd注册的事件有变更时, channel调用update, 函数内包含updateChannel(this) */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel * channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 当fd注册的事件要注销时，channel调用remove，函数内包含removeChannel(this) */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel * channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">参数 channel 均为 [外部channel传入的<span class="keyword">this</span>指针]</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>newDefaultPoller(EventLoop * loop)</code> - 提供给EventLoop的接口，以获取默认的IO复用具体实现。</p>
<blockquote>
<p>注意：我们最好不要实现到<code>poller.cc</code>文件中，不大妥当。因为<code>Poller</code>类是基类，而把获取具体实现写到抽象类文件实现中是不好的。可以单独把实现代码写到<code>defaultpoller.cc</code>中。</p>
</blockquote>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Poller* <span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>hasChannel</code> - 判断poller是否拥有某一channel</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel * channel)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="epollpoller"   >
          <a href="#epollpoller" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#epollpoller"></a> EpollPoller</h2>
      
<p>是Poller抽象基类的一个具体实现类。</p>

        <h3 id="成员函数-3"   >
          <a href="#成员函数-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-3"></a> 成员函数</h3>
      
<ol>
<li>
<p>构造/析构 - 构造相当于<code>epoll_create</code>，记录在<code>m_epollfd</code>成员变量中。析构时close该fd。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EpollPoller</span>(EventLoop *loop);</span><br><span class="line">    ~<span class="built_in">EpollPoller</span>() <span class="keyword">override</span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>poll</code> - 重写Poller基类方法 - 相当于<code>epoll_wait</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>update/removeChannel</code> - 重写Poller基类方法 - 相当于<code>epoll_ctl add/mod/del</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>fillActiveChannels</code> - 填写活跃的channels连接</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>update</code> - 更新channel通道</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> operation, Channel * channel)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="成员属性"   >
          <a href="#成员属性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员属性"></a> 成员属性</h3>
      
<ol>
<li>
<p><code>m_epollfd</code> - epoll相关的方法都需要用到fd，通过epoll_create来创建。映射的是epoll底层的文件系统红黑树。</p>
</li>
<li>
<p><code>m_events</code> - 是一个<code>vector&lt;struct epoll_event</code>容器。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_epollfd;</span><br><span class="line">    <span class="keyword">using</span> std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; EventList;</span><br><span class="line">    EventList m_events;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>kInitEventListSize</code> - <code>EventList</code>初始的长度。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kInitEventListSize = <span class="number">16</span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>从Poller继承而来，拥有poller包含的<code>ChannelMap m_channels</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Poller</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="type">int</span>, Channel*&gt;;</span><br><span class="line">    ChannelMap m_channels;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="实现代码"   >
          <a href="#实现代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h3>
      
<p>首先声明了三个全局常量，表示channel的状态</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kNew      = <span class="number">-1</span>;    <span class="comment">//从未添加到epoll的channel</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kAdded    = <span class="number">1</span>;     <span class="comment">//已经添加到epoll的channel</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kDeleted  = <span class="number">2</span>;     <span class="comment">//已把该channel从epoll中删除</span></span><br></pre></td></tr></table></div></figure>
<ol>
<li>
<p>构造函数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;logger.h&quot;</span>      <span class="comment">//LOG_FATAL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span>       <span class="comment">//errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EpollPoller::<span class="built_in">EpollPoller</span>(EventLoop * loop)</span><br><span class="line">    : <span class="built_in">Poller</span>(loop),</span><br><span class="line">      <span class="built_in">m_epollfd</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC)),	<span class="comment">// epoll_create</span></span><br><span class="line">      <span class="built_in">m_events</span>(kInitEventListSize)  <span class="comment">// vector&lt;epoll_event&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_epollfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;epoll_create error: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>      <span class="comment">//close</span></span></span><br><span class="line"></span><br><span class="line">EpollPoller::~<span class="built_in">EpollPoller</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_epollfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="currentthread-主要用于获取tid"   >
          <a href="#currentthread-主要用于获取tid" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#currentthread-主要用于获取tid"></a> CurrentThread - 主要用于获取tid</h2>
      
<p><code>__thread</code>相当于C++11标准中的<code>thread_local</code>修饰符。用于修饰全局变量。</p>
<p>修饰之前，全局变量只能被若干线程共享。修饰之后，此全局变量变成每个线程专有的属性。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>          <span class="comment">//pid_t  syscall</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/syscall.h&gt;</span>     <span class="comment">//SYS_gettid</span></span></span><br><span class="line"><span class="keyword">namespace</span> CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 此变量被__thread修饰, 相当于C++11标准中的thread_local修饰符, </span></span><br><span class="line"><span class="comment">     * 用于修饰全局变量。修饰之前, 全局变量只能被若干线程共享; </span></span><br><span class="line"><span class="comment">     * 修饰之后, 此全局变量变成每个线程专有的属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">extern</span> __thread <span class="type">int</span> t_cachedTid;</span><br><span class="line">    <span class="comment">/* 通过Linux系统调用SYS_gettid, 加载当前线程的tid值到t_cachedTid */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cacheTid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t_cachedTid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t_cachedTid = <span class="built_in">static_cast</span>&lt;<span class="type">pid_t</span>&gt;(<span class="built_in">syscall</span>(SYS_gettid));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 返回当前线程的tid, 若加载过则直接返回存储过的值 */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">tid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 若t_cachedTid为0说明是第一次加载, 需要调用cacheTid */</span></span><br><span class="line">        <span class="keyword">if</span>(__builtin_expect(t_cachedTid == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cacheTid</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t_cachedTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="eventloop"   >
          <a href="#eventloop" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#eventloop"></a> EventLoop</h1>
      
<blockquote>
<p>前面的EventLoop概览中提到：</p>
<ol>
<li>不允许拷贝</li>
<li>主要包含的成员之一：poller（相当于epoll），属性有sockfd及其上面绑定的事件</li>
<li>另一个主要的成员是channel，属性有fd、events、revents等等</li>
</ol>
<p>EventLoop就是要完成事件循环，事件循环最重要的几个动作：epoll（<strong>由poller负责</strong>）、epoll监听的fd及感兴趣的事件、实际<code>epoll_wait</code>后发生的事件。这些sockfd、感兴趣的事件、发生的事件都<strong>记录在channel中</strong>。</p>
<p>要写EventLoop就要理清楚EventLoop、Channel、Poller之间的关系。Reactor模型中，这三个组件整体对应着Demultiplex。</p>
</blockquote>
<p>由上述约束，在<code>.h</code>文件中，我们可以首先写出：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poller</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>要用到函数对象。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Functor = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="成员变量-3"   >
          <a href="#成员变量-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-3"></a> 成员变量</h2>
      
<ol>
<li>
<p><code>ChannelList m_activeChannels</code> - EventLoop管理的所有的Channel的List；<br />
<code>Channel * m_currentActiveChannel</code> - 主要用于断言</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> ChannelList = std::vector&lt;Channel*&gt;;</span><br><span class="line">    ChannelList m_activeChannels;</span><br><span class="line"></span><br><span class="line">    Channel * m_currentActiveChannel;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>标志(最好为atomic)</p>
<ol>
<li>
<p><code>m_looping</code> - 事件循环状态标志 - 真则正在循环，假则将要退出循环</p>
</li>
<li>
<p><code>m_quit</code> - 标识退出loop循环</p>
</li>
<li>
<p><code>m_eventHandling</code> -</p>
</li>
<li>
<p><code>m_callingPendingFunctors</code> - 标识当前loop当前是否有需要执行的回调操作</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic_bool m_looping;</span><br><span class="line">    std::atomic_bool m_quit;</span><br><span class="line">    std::atomic_bool m_callingPendingFunctors;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>
</li>
<li>
<p><code>m_threadId</code> - 记录当前Loop所在线程的ID</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">pid_t</span> m_threadId;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>std::unique&lt;Poller&gt; m_poller</code> - EventLoop所管理的poller，去轮询监听channels上发生的事件。用<code>std::unique_ptr</code>管理</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Poller&gt; m_poller;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>Timestamp m_pollReturnTime</code> - poller返回发生事件的channels的时间点</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Timestamp m_pollReturnTime;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>int m_wakeupFd</code> - mainLoop获取到一个新用户的channel后，搭配轮询算法选择一个等待任务的subLoop，通过wakeupFd对其进行唤醒来处理channel。用<code>eventfd</code>创建。<code>eventfd</code>使用线程间的<code>wait/notify</code>事件通知机制，直接在内核唤醒，效率较高。与此处理相似的是，<code>libevent</code>使用的是<code>socketpair</code>的双向通信机制，相当于网络通信层面的机制，效率较低。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_wakeupFd;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>std::unique_ptr&lt;Channel&gt; m_wakeupChannel</code> - 把wakeupFd封装起来和其Channel关联，因为操作的往往不是fd而是其channel</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Channel&gt; m_wakeupChannel;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>std::vector&lt;Functor&gt; m_pendingFunctors</code> - 存储loop需要执行的所有的回调操作。与<code>callingPendingFunctors</code>标识结合使用，如果此标识显示当前loop有需要执行的回调操作，则这些回调操作将在此vector容器中存放。<strong>需要用mutex保护其线程安全</strong>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Functor&gt; m_pendingFunctors;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m_mutex;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="成员函数-4"   >
          <a href="#成员函数-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-4"></a> 成员函数</h2>
      
<ol>
<li>
<p>构造/析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoop</span>();</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>loop</code>/<code>quit</code> - 开始/结束事件循环</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>Timestamp pollReturnTime() const</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Timestamp <span class="title">pollReturnTime</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pollReturnTime;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>runInLoop</code> - 在当前loop中执行cb</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runInLoop</span><span class="params">(Functor cb)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>queueInLoop</code> - 把cb放入队列中，唤醒loop所在的线程，执行cb</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">queueInLoop</span><span class="params">(Functor cb)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>wakeup</code> - mainLoop唤醒subLoop所在的线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>更新Channel相关 - EventLoop的方法调用Poller的方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>isInLoopThread</code> - 判断EventLoop对象是否在自己的线程里面</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;currentthread.h&quot;</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInLoopThread</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_threadId == CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleRead - 处理wakeup唤醒相关的逻辑</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>doPendingFunctors - 执行回调</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doPendingFunctors</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="实现代码-2"   >
          <a href="#实现代码-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实现代码-2"></a> 实现代码</h2>
      

        <h3 id="全局变量"   >
          <a href="#全局变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3>
      
<ol>
<li>
<p>防止一个线程创建多个loop</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__thread修饰表示这个全局变量转为了每个线程私有的属性</span></span><br><span class="line">__thread EventLoop *t_loopInThisThread = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>默认的超时时间</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="全局函数"   >
          <a href="#全局函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#全局函数"></a> 全局函数</h3>
      
<ol>
<li>
<p>createEventfd() - 创建wakeupfd，用来通知等待任务的subLoop，处理新的Channel事件。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createEventfd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> evtfd = <span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span>(evtfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;Failed in eventfd: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evtfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="eventloopthread"   >
          <a href="#eventloopthread" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#eventloopthread"></a> EventLoopThread</h1>
      
<p>EventLoop组件及其内部的Chennel、Poller已经在上文讨论。要和thread结合达成最终的&quot;one loop per thread&quot;模型，较好的办法就是将EventLoop与thread组合封装。</p>

        <h2 id="thread"   >
          <a href="#thread" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread"></a> Thread</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> : noncopyable</span><br></pre></td></tr></table></div></figure>

        <h3 id="线程函数"   >
          <a href="#线程函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程函数"></a> 线程函数</h3>
      
<p>线程最主要的组成部分就是线程函数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>使用无返回值+无参数是为了便于统一线程函数的形式，具体绑定回调则使用函数对象绑定器。</p>
</blockquote>

        <h3 id="成员变量-4"   >
          <a href="#成员变量-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-4"></a> 成员变量</h3>
      
<p>用C++线程库、智能指针。</p>
<p>Thread对象刚创建不会执行线程函数，而是在成员函数<code>start()</code>被调用时，用智能指针创建C++ 11的thread线程才开始真正执行。</p>
<ol>
<li><code>m_started</code> - 表示</li>
<li><code>m_joined</code></li>
<li><code>std::shared_ptr&lt;std::thread&gt; m_thread</code></li>
<li><code>pid_t m_tid</code></li>
<li><code>ThreadFunc m_func</code> - 存储线程函数</li>
<li><code>std::string m_name</code></li>
<li><code>static std::atomic_int m_numCreated</code> - 目前产生了线程对象的计数值</li>
</ol>

        <h3 id="成员方法"   >
          <a href="#成员方法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员方法"></a> 成员方法</h3>
      
<ol>
<li>
<p>setDefaultName - 构造函数中如果没有传入name则赋&quot;Thread %d &quot;，%d为已创建的线程对象数目。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDefaultName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>构造/析构函数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Thread</span><span class="params">(ThreadFunc, <span class="type">const</span> std::string &amp; name = std::string())</span></span>;</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>start</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>join</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>获取线程状态相关的标志、信息</p>
<ol>
<li>started</li>
<li>tid</li>
<li>name</li>
<li>numCreated</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_started;&#125;</span><br><span class="line">    <span class="function"><span class="type">pid_t</span> <span class="title">tid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_tid;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_numCreated;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="代码实现"   >
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;currentthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function">std::atomic_int <span class="title">Thread::m_numCreated</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::setDefaultName</span><span class="params">(<span class="type">int</span> numCreated)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;Thread%d&quot;</span>, numCreated);</span><br><span class="line">    m_name = buf;</span><br><span class="line">&#125;</span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func, <span class="type">const</span> std::string &amp; name)</span><br><span class="line">    : <span class="built_in">m_started</span>(<span class="literal">false</span>), <span class="built_in">m_joined</span>(<span class="literal">false</span>), <span class="built_in">m_tid</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">m_func</span>(std::<span class="built_in">move</span>(func)), <span class="built_in">m_name</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = ++m_numCreated;</span><br><span class="line">    <span class="keyword">if</span>(m_name.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setDefaultName</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread::~<span class="built_in">Thread</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 线程要么join, 要么detach */</span></span><br><span class="line">    <span class="keyword">if</span>(m_started &amp;&amp; !m_joined)</span><br><span class="line">    &#123;</span><br><span class="line">        m_thread-&gt;<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_started = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 为了tid初始化时期的线程安全, 保证tid有效 */</span></span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sem, <span class="literal">false</span>, <span class="number">0</span>);   <span class="comment">//地址, 是否进程间共享, 初始值0</span></span><br><span class="line">    <span class="comment">//下面这句才是真正去创建一个立即执行的子线程。而且下面这个语句是子线程的生命周期。</span></span><br><span class="line">    <span class="comment">//从创建完m_thread后主线程、子线程分离, 主线程需要等待子线程执行完毕, 可以用信号量来控制。</span></span><br><span class="line">    m_thread = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;([&amp;]()&#123;</span><br><span class="line">        m_tid = CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">m_func</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">//这里是主线程的代码，只有sem的值变为&gt;0时才能往下走。</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_joined = <span class="literal">true</span>;</span><br><span class="line">    m_thread-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="eventloopthread-2"   >
          <a href="#eventloopthread-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#eventloopthread-2"></a> EventLoopThread</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThread</span> : noncopyable</span><br></pre></td></tr></table></div></figure>
<p>封装的目标：在thread线程对象上运行一个loop。</p>

        <h3 id="线程初始化时回调函数"   >
          <a href="#线程初始化时回调函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程初始化时回调函数"></a> 线程初始化时回调函数</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员变量-5"   >
          <a href="#成员变量-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-5"></a> 成员变量</h3>
      
<ol>
<li>
<p><code>m_loop</code> - 存储Eventloop对象指针</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop * m_loop;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>m_thread</code> - 存储线程对象</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thread m_thread;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>bool m_exiting</code> - 线程正在退出的标志</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> m_exiting;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>ThreadInitCallback m_callback</code> - 线程初始化调用的回调操作，在EventLoopThread构造时在第1个参数传入，默认是一个空操作。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadInitCallback m_callback;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="成员函数-5"   >
          <a href="#成员函数-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-5"></a> 成员函数</h3>
      
<ol>
<li>
<p>构造/析构函数</p>
<ol>
<li>构造函数参数：可以传入一个线程初始化回调函数对象；还有name。其中，回调函数对象默认构造为空操作。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallback &amp;cb = <span class="built_in">ThreadInitCallback</span>(),</span><br><span class="line">                    <span class="type">const</span> std::string &amp; name = std::<span class="built_in">string</span>());</span><br><span class="line">    ~<span class="built_in">EventLoopThread</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>startLoop - 开启循环</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EventLoop * <span class="title">startLoop</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>threadFunc - 线程函数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="代码实现-2"   >
          <a href="#代码实现-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h3>
      
<ol>
<li>
<p>构造函数</p>
<ol>
<li>主要的工作就是构造EventLoopThread中的Thread对象即<code>m_thread</code>成员。Thread对象<code>m_thread</code>绑定的线程函数是用<code>std::bind</code>绑定的函数，用的是EventLoopThread类中的threadFunc函数，并且绑定了其this指针。EventLoopThread构造函数的第2个参数name将作为<code>m_thread</code>的名字。</li>
<li>第1个参数指定的是<code>线程初始化时的回调函数</code>，<strong>与线程start后执行的线程函数无关</strong>。第1个参数的默认值和第2个参数的默认值在<code>.h</code>文件中已指出。<code>ThreadInitCallback()</code>是指创建一个默认函数对象，函数执行空操作。</li>
<li>Thread对象构造完成后，不会立即执行<code>线程函数threadFunc</code>，因为Thread构造并不意味着C++11标准库的thread创建完毕。只有调用<code>m_thread.start()</code>才会真正执行<code>线程函数threadFunc</code>。</li>
<li>构造函数还把传入的<code>线程初始化时回调函数cb</code>保存到了<code>m_callback</code>成员。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;eventloopthread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;eventloop.h&quot;</span></span></span><br><span class="line">EventLoopThread::<span class="built_in">EventLoopThread</span>(<span class="type">const</span> ThreadInitCallback &amp;cb,</span><br><span class="line">                                 <span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">m_loop</span>(<span class="literal">nullptr</span>), <span class="built_in">m_exiting</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">m_thread</span>(std::<span class="built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>), name),</span><br><span class="line">      <span class="built_in">m_mutex</span>(), <span class="built_in">m_cond</span>(), <span class="built_in">m_callback</span>(cb)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EventLoopThread::~<span class="built_in">EventLoopThread</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_exiting = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(m_loop != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_loop-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        m_thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EventLoop * <span class="title">EventLoopThread::startLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_thread.<span class="built_in">start</span>();   <span class="comment">//启动底层新线程，执行回调函数，</span></span><br><span class="line"></span><br><span class="line">    EventLoop * loop = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;<span class="comment">/* 临界区m_loop */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(m_loop == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cond.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    loop = m_loop;</span><br><span class="line">    &#125;<span class="comment">/* 临界区m_loop */</span></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Thread对象实际执行的线程函数，在单独的子线程中执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop loop; <span class="comment">//构造一个独立的eventloop, 和m_thread一对一, one loop per thread的证据</span></span><br><span class="line">    <span class="keyword">if</span>(m_callback)	<span class="comment">//如果m_callback(即ThreadInitCallback)不为空则执行此函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">m_callback</span>(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">/* 临界区m_loop */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_loop = &amp;loop;</span><br><span class="line">    m_cond.<span class="built_in">notify_one</span>();	<span class="comment">//通知主线程的startLoop(), loop已经在子线程创建好了。</span></span><br><span class="line">    &#125;<span class="comment">/* 临界区m_loop */</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();    <span class="comment">//EventLoop loop =&gt; Poller.poll</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 执行到此处说明loop已经结束 退出循环 */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_loop = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="eventloopthreadpool"   >
          <a href="#eventloopthreadpool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#eventloopthreadpool"></a> EventLoopThreadPool</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoopThreadPool</span> : noncopyable</span><br></pre></td></tr></table></div></figure>

        <h2 id="线程初始化时回调函数-2"   >
          <a href="#线程初始化时回调函数-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程初始化时回调函数-2"></a> 线程初始化时回调函数</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="成员变量-6"   >
          <a href="#成员变量-6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-6"></a> 成员变量</h2>
      
<ol>
<li><code>m_baseLoop</code> - 用户最开始创建的loop</li>
<li>标志相关
<ol>
<li><code>std::string m_name</code></li>
<li><code>bool m_started</code></li>
<li><code>int m_numThreads</code></li>
<li><code>int m_next</code></li>
</ol>
</li>
<li><code>std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; m_threads</code> - 包含了所有创建的线程</li>
<li><code>std::vector&lt;EventLoop*&gt; m_loops</code> - 包含了所有管理着的loop的指针，通过<code>m_threads</code>中的某个thread进行<code>startLoop()</code>返回loop的指针。</li>
</ol>

        <h2 id="成员函数-6"   >
          <a href="#成员函数-6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-6"></a> 成员函数</h2>
      
<ol>
<li>
<p>构造/析构函数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoopThreadPool</span>(EventLoop * baseLoop, <span class="type">const</span> std::string &amp;nameArg);</span><br><span class="line">    ~<span class="built_in">EventLoopThreadPool</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>setThreadNum(int)</code> - 供TcpServer调用</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_numThreads = numThreads;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>start</code> - 开启事件循环线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>getNextLoop</code> - 如果工作在多线程中，baseLoop默认以轮询的方式分配channel给subLoop</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EventLoop * <span class="title">getNextLoop</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>getAllLoops</code> - 获取所有管理着的loop，存到vector中，相当于拷贝了<code>m_loops</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;EventLoop*&gt; <span class="title">getAllLoops</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>获取各种状态、信息</p>
<ol>
<li>started</li>
<li>name</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">started</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_started;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="代码实现-3"   >
          <a href="#代码实现-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-3"></a> 代码实现</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;eventloopthreadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;eventloopthread.h&quot;</span></span></span><br><span class="line">EventLoopThreadPool::<span class="built_in">EventLoopThreadPool</span>(EventLoop *baseLoop, <span class="type">const</span> std::string &amp;nameArg)</span><br><span class="line">    : <span class="built_in">m_baseLoop</span>(baseLoop),</span><br><span class="line">      <span class="built_in">m_name</span>(nameArg),</span><br><span class="line">      <span class="built_in">m_started</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">m_numThreads</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">m_next</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EventLoopThreadPool::~<span class="built_in">EventLoopThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nothing to do, bacause evey loop is on the thread stack,</span></span><br><span class="line"><span class="comment">     * that will destruct automatically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_started = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[m_name.<span class="built_in">size</span>() + <span class="number">32</span>];</span><br><span class="line">        <span class="comment">/* 以线程池name + 下标序列号 作为thread线程的名字 */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;%s%d&quot;</span>, m_name.<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="function">std::string <span class="title">threadName</span><span class="params">(buf)</span></span>;</span><br><span class="line">        m_threads.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;EventLoopThread&gt;(cb, threadName));</span><br><span class="line">        m_loops.<span class="built_in">push_back</span>(m_threads.<span class="built_in">back</span>()-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* m_numThreads == 0时, 上面for循环不会执行, 执行下面的操作 */</span></span><br><span class="line">    <span class="keyword">if</span>(m_numThreads == <span class="number">0</span> &amp;&amp; cb != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(m_baseLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 体现了对subLoop的轮询算法 */</span></span><br><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThreadPool::getNextLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop * loop = m_baseLoop;</span><br><span class="line">    <span class="keyword">if</span>(!m_loops.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        loop = m_loops[m_next];</span><br><span class="line">        ++m_next;</span><br><span class="line">        <span class="keyword">if</span>(m_next &gt;= m_loops.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_next = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::vector&lt;EventLoop*&gt; <span class="title">EventLoopThreadPool::getAllLoops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_loops.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;EventLoop*&gt;(<span class="number">1</span>, m_baseLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_loops;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="acceptor"   >
          <a href="#acceptor" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#acceptor"></a> Acceptor</h1>
      
<p>mainReactor主要的工作是处理客户端的连接请求，然后把sockfd轮询分配给subReactors。</p>
<p>这个工作由mainReactor中的acceptor处理。处理的流程和TCP socket编程流程基本一致。需要有一个listenfd，即监听套接字，去其中的监听队列取可用的连接。即Acceptor主要就是对若干sockfd的封装。</p>

        <h2 id="socket"   >
          <a href="#socket" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#socket"></a> socket</h2>
      

        <h3 id="h文件"   >
          <a href="#h文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#h文件"></a> .h文件</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InetAddress</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Socket</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">        : m_sockfd(sockfd)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Socket</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_sockfd;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bindAddress</span><span class="params">(<span class="type">const</span> InetAddress &amp;localAddr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(InetAddress *peerAddr)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdownWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 更改TCP选项, 直接交付, 不进行缓存 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="comment">/* 更改TCP选项 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReuseAddr</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="comment">/* 更改TCP选项 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReusePort</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line">    <span class="comment">/* 更改TCP选项 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m_sockfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="cc文件"   >
          <a href="#cc文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cc文件"></a> .cc文件</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;inetaddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>  <span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span>  <span class="comment">//bind</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;strings.h&gt;</span> <span class="comment">//bzero</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/tcp.h&gt;</span> <span class="comment">//TCP_NODELAY</span></span></span><br><span class="line">Socket::~<span class="built_in">Socket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::bindAddress</span><span class="params">(<span class="type">const</span> InetAddress &amp;localAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* bind return 0 when success */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ::<span class="built_in">bind</span>(m_sockfd, (sockaddr*)localAddr.<span class="built_in">getSockAddr</span>(), <span class="built_in">sizeof</span>(sockaddr_in)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;bind sockfd: %d fail, createNonblocking or Die\n&quot;</span>, m_sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ::<span class="built_in">listen</span>(m_sockfd, <span class="number">1024</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;listen sockfd: %d fail\n&quot;</span>, m_sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Socket::accept</span><span class="params">(InetAddress * peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="type">socklen_t</span> len;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line">    <span class="type">int</span> connfd = ::<span class="built_in">accept</span>(m_sockfd, (sockaddr*)&amp;addr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        peerAddr-&gt;<span class="built_in">setSockAddr</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::shutdownWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">shutdown</span>(m_sockfd, SHUT_WR) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shutdown Write error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(m_sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setReuseAddr</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(m_sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Socket::setKeepAlive</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ::<span class="built_in">setsockopt</span>(m_sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, <span class="keyword">sizeof</span> optval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="acceptor-2"   >
          <a href="#acceptor-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#acceptor-2"></a> Acceptor</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Acceptor</span> : noncopyable</span><br></pre></td></tr></table></div></figure>

        <h3 id="收到新连接时的回调"   >
          <a href="#收到新连接时的回调" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#收到新连接时的回调"></a> 收到新连接时的回调</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> NewConnectionCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span> fd, <span class="type">const</span> InetAddress&amp;)&gt;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员变量-7"   >
          <a href="#成员变量-7" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-7"></a> 成员变量</h3>
      
<ol>
<li><code>m_loop</code></li>
<li><code>m_acceptSocket</code></li>
<li><code>m_acceptChannel</code></li>
<li><code>m_newConnectionCallback</code> - 把fd打包为channel，getNextLoop唤醒一个subLoop，把channel分发给subLoop。</li>
<li><code>m_listening</code></li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop * m_loop;</span><br><span class="line">    Socket m_acceptSocket;</span><br><span class="line">    Channel m_acceptChannel;</span><br><span class="line">    NewConnectionCallback m_newConnectionCallback;</span><br><span class="line">    <span class="type">bool</span> m_listenning;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数-7"   >
          <a href="#成员函数-7" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-7"></a> 成员函数</h3>
      
<ol>
<li>
<p>构造/析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 此构造的三个参数本身也是TcpServer的三个参数 */</span></span><br><span class="line">    <span class="built_in">Acceptor</span>(EventLoop * loop, <span class="type">const</span> InetAddress &amp; listenAddr, <span class="type">bool</span> reusePort);</span><br><span class="line">    ~<span class="built_in">Acceptor</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>listen</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>get/set</p>
<ol>
<li>setNewConnectionCallback</li>
<li>listening</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="type">const</span> NewConnectionCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_newConnectionCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">listenning</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_listenning;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleRead</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="代码实现-4"   >
          <a href="#代码实现-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-4"></a> 代码实现</h3>
      
<ol>
<li>
<p>构造</p>
<ol>
<li>由传入的<code>loop</code>对<code>m_loop</code>初始化；创建一个NonBlock的Tcp socketfd并用于构造<code>m_acceptSocket</code>；把loop和刚才创建好的socketfd打包构造<code>m_acceptChannel</code>；设置各种标志。</li>
<li>根据传入的第2个参数<code>listenAddr</code>，<code>bindAddress</code>绑定地址到socket上。</li>
<li>TcpServer调用start()后，意味着acceptor要对listen sockfd进行listen。如果接收到了新用户的连接，需要执行一个回调（具体操作是把connfd-&gt;channel-&gt;subloop）。所以还要设置一个ReadCallback。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">createNonblockingSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d listen socketfd create err: %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr, <span class="type">bool</span> reusePort)</span><br><span class="line">    : <span class="built_in">m_loop</span>(loop),</span><br><span class="line">      <span class="built_in">m_acceptSocket</span>(<span class="built_in">createNonblockingSocket</span>()),    <span class="comment">//create socket</span></span><br><span class="line">      <span class="built_in">m_acceptChannel</span>(loop, m_acceptSocket.<span class="built_in">fd</span>()),</span><br><span class="line">      <span class="built_in">m_listenning</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_acceptSocket.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    m_acceptSocket.<span class="built_in">setReusePort</span>(<span class="literal">true</span>);</span><br><span class="line">    m_acceptSocket.<span class="built_in">bindAddress</span>(listenAddr);         <span class="comment">//bind addr to socket</span></span><br><span class="line">    <span class="comment">// TcpServer::start() Acceptor::listen(), 如果有新连接需要执行回调 connfd-&gt;channel-&gt;subloop</span></span><br><span class="line">    <span class="comment">//baseLoop -&gt; m_acceptChannel(listenfd) -&gt; </span></span><br><span class="line">    m_acceptChannel.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleRead - listenfd有事件发生, 即有新用户链接时的回调操作</p>
<ol>
<li>accept一个connfd，把fd和peerAddr交给newConnectionCallback处理。newConnectionCallback是TcpServer中编写的。主要工作是<strong>轮询找到subLoop, 唤醒, 分配当前新客户端的channel</strong>。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* listenfd有事件发生, 即有新连接 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="type">int</span> connfd = m_acceptSocket.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span>(connfd &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_newConnectionCallback)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 轮询找到subLoop, 唤醒, 分配当前新客户端的channel */</span></span><br><span class="line">            <span class="built_in">m_newConnectionCallback</span>(connfd, peerAddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:%s:%d accept err: %d&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">        <span class="keyword">if</span>(errno == EMFILE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;(sockfd reached max limit)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::~<span class="built_in">Acceptor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_acceptChannel.<span class="built_in">disableAll</span>();</span><br><span class="line">    m_acceptChannel.<span class="built_in">remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>listen</p>
<ol>
<li>设置listenning标志</li>
<li>调用<code>m_acceptSocket</code>的listen</li>
<li>调用<code>m_acceptChannel</code>的enableReading，即把<code>m_acceptChannel</code>注册到Poller中。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_listenning = <span class="literal">true</span>;</span><br><span class="line">    m_acceptSocket.<span class="built_in">listen</span>();                        <span class="comment">//listen</span></span><br><span class="line">    m_acceptChannel.<span class="built_in">enableReading</span>();                <span class="comment">//m_acceptChannel -&gt; poller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="tcpserver"   >
          <a href="#tcpserver" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcpserver"></a> TcpServer</h1>
      
<p>考虑一个问题：用户使用muduo库编写服务器程序时，为了避免用户再去困惑引入哪些头文件，我们在tcpserver.h中把该引入的头文件全引入进去，而不再只是对类前置声明了。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;eventloop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;acceptor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;inetaddress.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;noncopyable.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpServer</span> : noncopyable</span><br></pre></td></tr></table></div></figure>

        <h2 id="回调"   >
          <a href="#回调" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#回调"></a> 回调</h2>
      
<p>所有的回调，都是用户设置到TcpServer后，TcpServer再自己设置到EventLoop中的。</p>
<p>以下是TcpServer类中包含的回调操作属性。（成员变量）</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadInitCallback	    m_threadInitCallback;</span><br><span class="line">    ConnectionCallback 	    m_connectionCallback;</span><br><span class="line">    MessageCallback	        m_messageCallback;</span><br><span class="line">    WriteCompleteCallback   m_writeCompleteCallback;</span><br><span class="line">    HighWaterMarkCallback   m_highWaterMarkCallback;</span><br></pre></td></tr></table></div></figure>

        <h3 id="线程初始化时的回调"   >
          <a href="#线程初始化时的回调" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程初始化时的回调"></a> 线程初始化时的回调</h3>
      
<p>直接声明在TcpServer class中。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadInitCallback = std::function&lt;<span class="built_in">void</span>(EventLoop*)&gt;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="连接-读写事件的回调-单独写到callbacksh文件中"   >
          <a href="#连接-读写事件的回调-单独写到callbacksh文件中" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#连接-读写事件的回调-单独写到callbacksh文件中"></a> 连接、读写事件的回调 - 单独写到callbacks.h文件中</h3>
      
<blockquote>
<p>为了对各种回调函数进行管理，写到单独的头文件<code>callbacks.h</code>中。</p>
</blockquote>
<ol>
<li>ConnectionCallback - 有关连接的回调。</li>
<li>CloseCallback - 关闭连接的回调</li>
<li>WriteCompleteCallback - 消息发送完成后的回调</li>
<li>MessageCallback - 已连接用户有读写事件发生时的回调</li>
<li>HighWaterMarkCallback - 高水位回调，为了控制收发流量稳定</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TcpConnection</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> TcpConnectionPtr = std::shared_ptr&lt;TcpConnection&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ConnectionCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr&amp;)&gt;;</span><br><span class="line"><span class="keyword">using</span> CloseCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr&amp;)&gt;;</span><br><span class="line"><span class="keyword">using</span> WriteCompleteCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr&amp;)&gt;;</span><br><span class="line"><span class="keyword">using</span> HighWaterMarkCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr&amp;, <span class="type">size_t</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> MessageCallback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr &amp;,</span><br><span class="line">                                           Buffer *, Timestamp)&gt;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="枚举声明"   >
          <a href="#枚举声明" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#枚举声明"></a> 枚举声明</h2>
      
<p>Option枚举类，直接声明在TcpServer类中。</p>
<p><code>Option.kReusePort</code>/<code>Option.kNoReusePort</code>表示端口是否可重用。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Option</span></span><br><span class="line">    &#123;</span><br><span class="line">        kNoReusePort,</span><br><span class="line">        kReusePort</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="成员变量-8"   >
          <a href="#成员变量-8" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-8"></a> 成员变量</h2>
      
<p>其中，回调函数属性已经在上面给出。</p>
<ol>
<li>
<p><code>ConnectionMap m_connections</code> - 保存所有的连接</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> ConnectionMap = std::unoredered_map&lt;std::string, TcpConnectionPtr&gt;;</span><br><span class="line">    ConnectionMap m_connections;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>EventLoop *m_loop</code> - 用户实现定义的baseLoop</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop * m_loop;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>m_IPport</code> - 存储IP和端口的字符串</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> std::string m_IPport;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>std::unique_ptr&lt;Acceptor m_acceptor</code> - 运行在mainLoop，任务是监听新连接事件。</p>
</li>
<li>
<p><code>std::unique_ptr&lt;EventLoopThreadPool&gt; m_threadPool</code> -</p>
</li>
<li>
<p>标识</p>
<ol>
<li><code>std::string m_name</code> - TcpServer的易记忆名字</li>
<li><code>atomic_bool started</code> - 是否已启动</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    atomic_bool started;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>m_nextConnId</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_connId;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="成员函数-8"   >
          <a href="#成员函数-8" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-8"></a> 成员函数</h2>
      
<ol>
<li>
<p>构造/析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpServer</span>(EventLoop * loop, <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">              <span class="type">const</span> std::string &amp;nameArg, Option option = kNoReusePort);</span><br><span class="line">    ~<span class="built_in">TcpServer</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>设置回调</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadInitCallback</span><span class="params">(<span class="type">const</span> ThreadInitCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_threadInitCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_connectionCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_messageCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_writeCompleteCallback = cb;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>start - 开启服务器监听，即mainLoop的acceptor的listen</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>关于Connection</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp; peerAddr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="代码实现-5"   >
          <a href="#代码实现-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-5"></a> 代码实现</h2>
      
<ol>
<li>
<p>构造，有三个参数，loop指针，InetAddress，标识名称name，端口是否重用Option</p>
<ol>
<li>
<p>对<code>m_loop</code>进行赋值，需要做非空检查</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d mainLoop is null\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>对<code>m_IPport</code>进行赋值，值是调用参数<code>listenAddr</code>中的函数<code>toIPport()</code>获得的</p>
</li>
<li>
<p>对<code>m_name</code>赋值</p>
</li>
<li>
<p>对<code>m_acceptor</code>进行构造(unique_ptr)。传入参数<code>loop</code>，<code>listenAddr</code>，<code>option</code></p>
<ol>
<li>创建socket</li>
<li>socket的fd和loop指针封装为Channel - <code>m_acceptChannel(loop, m_acceptSocket.fd())</code></li>
<li>设置channel的ReadCallback回调</li>
<li>当TcpServer调用start时，acceptor将会调用listen，将调用<code>m_acceptChannel</code>的<code>enableReading()</code>函数，往其相应的loop中进而在poller中注册事件。</li>
<li>loop等待事件，如果发生事件，调用channel的handleEvent，进而执行readCallBack。acceptor的readCallBack在构造时绑定为handleRead，工作是对channel的socket进行accept。</li>
</ol>
</li>
<li>
<p>对<code>m_threadPool</code>进行构造(shared_ptr)。传入参数<code>loop</code>，<code>m_name</code></p>
</li>
<li>
<p>设置回调</p>
<ol>
<li><code>m_connectionCallBack</code></li>
<li><code>m_messageCallBack</code></li>
</ol>
</li>
<li>
<p><code>m_nextConnId</code></p>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                     <span class="type">const</span> std::string &amp;nameArg, Option option = kNoReusePort)</span><br><span class="line">    : <span class="built_in">m_loop</span>(<span class="built_in">CheckLoopNotNull</span>(loop)),</span><br><span class="line">      <span class="built_in">m_IPport</span>(listenAddr.<span class="built_in">toIPport</span>()),</span><br><span class="line">      <span class="built_in">m_name</span>(nameArg),</span><br><span class="line">      <span class="built_in">m_acceptor</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr, option == kReusePort)),</span><br><span class="line">      <span class="built_in">m_threadPool</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop, m_name)),</span><br><span class="line">      <span class="built_in">m_connectionCallback</span>(),</span><br><span class="line">      <span class="built_in">m_messageCallback</span>(),</span><br><span class="line">      <span class="built_in">m_nextConnId</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_acceptor-&gt;<span class="built_in">setNewConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::newConnection,</span><br><span class="line">                                                   <span class="keyword">this</span>, _1, _2));<span class="comment">//connfd, peerAddr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>newConnection - 运行在主线程当中，主线程的mainLoop调用此函数，选择了一个ioLoop，<strong>在非子loop的线程中（即当前是在mainThread）执行cb，就需要唤醒子loop所在线程（subThread），执行cb</strong>，即调用subLoop的<code>queueInLoop(cb)</code>。</p>
<ol>
<li>根据轮询算法选择一个subLoop，即调用<code>m_threadPool-&gt;getNextLoop()</code></li>
<li>唤醒subLoop</li>
<li>把当前connfd封装成channel分发给subloop</li>
</ol>
</li>
<li>
<p>setThreadNum - 设置底层subLoop的个数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_threadPool-&gt;<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>start - 开启服务器监听</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//防止一个TcpServer对象被start多次;</span></span><br><span class="line">    <span class="keyword">if</span>(m_started++ == <span class="number">0</span>)<span class="comment">//即使bool为1，bool++后的值也还是1</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_threadPool-&gt;<span class="built_in">start</span>(m_threadInitCallback);</span><br><span class="line">        m_loop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::listen, m_acceptor.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="tcpconnection"   >
          <a href="#tcpconnection" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcpconnection"></a> TcpConnection</h1>
      
<p>顾名思义，此类对象表示的是tcp通信中，客户端和服务器之间成功建立的一条连接。主要封装用户在服务端的数据。</p>
<ol>
<li>mainLoop通过acceptor接收到新的连接时，将会把fd和loop封装到channel，继而封装到TcpConnection中，再通过轮询算法交给subLoop。</li>
<li>更重要的是，TcpConnection中存储了一些连接事件、读写事件发生时的回调。</li>
<li>最后，TcpConnection还还封装了Buffer。</li>
</ol>

        <h2 id="buffer"   >
          <a href="#buffer" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h2>
      
<p>基于非阻塞IO的服务端编程，Buffer是必不可少的。比如解决TCP粘包问题。</p>

        <h3 id="成员变量-9"   >
          <a href="#成员变量-9" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-9"></a> 成员变量</h3>
      
<ol>
<li><code>std::vector&lt;char&gt; m_buffer</code> - 数据数组。</li>
<li><code>size_t m_readerIndex</code> - 数据可读的位置下标</li>
<li><code>size_t m_writerIndex</code> - 数据可写的位置下标</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; m_buffer;</span><br><span class="line">    <span class="type">size_t</span> m_readerIndex;</span><br><span class="line">	<span class="type">size_t</span> m_writerIndex;</span><br></pre></td></tr></table></div></figure>
<p>除此之外，还有两个静态常量。</p>
<ol>
<li><code>kCheapPrepend</code> - 记录数据包的长度</li>
<li><code>kInitialSize</code> - 数据包的初始大小值。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kCheapPrepend = <span class="number">8</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kInitialSize = <span class="number">1024</span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数-9"   >
          <a href="#成员函数-9" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-9"></a> 成员函数</h3>
      
<ol>
<li>
<p>构造/析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="type">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class="line"><span class="function">        : m_buffer(kCheapPrepend + initialSize),</span></span><br><span class="line"><span class="function">          m_readerIndex(kCheapPrepend),</span></span><br><span class="line"><span class="function">          m_writerIndex(kCheapPrepend)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>readableBytes、writableBytes、prependableBytes</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">readableBytes</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_writerIndex - m_readerIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">writableBytes</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_buffer.<span class="built_in">size</span>() - m_writerIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">prependableBytes</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_readerIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>返回指针</p>
<ol>
<li>begin - 获取buffer实际首部指针</li>
<li>peek - 返回缓冲区数据包中可读数据起始位置</li>
<li>beginWrite - 返回可写的数据起始位置</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> * <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;*m_buffer.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;*m_buffer.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + m_readerIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> * <span class="title">beginWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + m_writerIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">beginWrite</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() + m_writerIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>retrieve</code>/<code>retrieveAll</code>/<code>retrieveAsString</code>/<code>retrieveAllAsString</code> - 后两个是把buffer中的数据转为string类型，多与onMessage配合使用；前两个是将<code>m_readerIndex</code>和<code>m_writerIndex</code>调整位置。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="built_in">readableBytes</span>())<span class="comment">//只读取了可读缓冲区数据的一部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_readerIndex += len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">retrieveAll</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retrieveAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_readerIndex = m_writerIndex = kCheapPrepend;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAsString</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">result</span><span class="params">(peek(), len)</span></span>;</span><br><span class="line">        <span class="built_in">retrieve</span>(len);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">retrieveAllAsString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">retrieveAsString</span>(<span class="built_in">readableBytes</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>ensureWritableByte - 确保buffer可写空间大小足够len，不足则扩容</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ensureWritableBytes</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">writableBytes</span>() &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">makeSpace</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>makeSpace - 扩容</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">writableBytes</span>()+<span class="built_in">prependableBytes</span>()-kCheapPrepend &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            m_buffer.<span class="built_in">resize</span>(m_writerIndex + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//move readable data to the front to make space</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> readable = <span class="built_in">readableBytes</span>();</span><br><span class="line">            <span class="comment">//将m_readerIndex到m_writerIndex的内容复制到kCheapPrepend处</span></span><br><span class="line">            std::<span class="built_in">copy</span>(<span class="built_in">begin</span>() + m_readerIndex, <span class="built_in">begin</span>() + m_writerIndex, <span class="built_in">begin</span>() + kCheapPrepend);</span><br><span class="line">            m_readerIndex = kCheapPrepend;</span><br><span class="line">            m_writerIndex = m_readerIndex + readable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>append</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ensureWritableBytes</span>(len);</span><br><span class="line">        std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">        m_writerIndex += len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>readFd - 从fd上读取数据</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> * saveErrno)</span></span>;	<span class="comment">//在.cc文件中实现</span></span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="代码实现-6"   >
          <a href="#代码实现-6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-6"></a> 代码实现</h3>
      
<ol>
<li>
<p>readFd - 从fd上读取数据</p>
<ol>
<li>
<p>Poller默认工作在LT模式</p>
</li>
<li>
<p>Buffer缓冲区是有大小的，但从fd上读数据却不清楚数据有多少。</p>
</li>
<li>
<p>此函数使用了系统调用<code>readv</code>。</p>
</li>
<li>
<p>struct iovec结构 - <code>iov_base</code>指向缓冲区首址；<code>iov_len</code>是缓冲区的长度。网络编程中可以使用此工具，创建一个<code>struct iovec iov[2]</code>，第一个的<code>iov_base</code>指向tcp连接底层的缓冲区，第二个的<code>iov_base</code>指向额外的缓冲区，以备使用。如果使用到额外的缓冲区，在readv完毕后，把额外缓冲区内容拼接到tcp底层缓冲区尾部即可。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * iov_base;</span><br><span class="line">    <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> * savedErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;;	<span class="comment">//栈上内存空间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">writableBytes</span>();<span class="comment">//buffer底层缓冲区剩余的可写空间大小</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + m_writerIndex;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果可写空间大小少于64kb则可以按需写到vec[0]/vec[1];</span></span><br><span class="line">    <span class="comment">//如果可写空间大小大于等于64kb则只能写到vec[0]。</span></span><br><span class="line">    <span class="comment">//说明, 可收到的数据大小限制至少为64kb。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> n = ::<span class="built_in">readv</span>(fd, iov, iovcnt);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *savedErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= writable)</span><br><span class="line">    &#123;</span><br><span class="line">        m_writerIndex += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// n &gt; writable, 需要拼接extrabuf</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_writerIndex = m_buffer.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">append</span>(extrabuf, n-writable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="tcpconnection-2"   >
          <a href="#tcpconnection-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcpconnection-2"></a> TcpConnection</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TcpConnection</span> : noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员变量-10"   >
          <a href="#成员变量-10" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-10"></a> 成员变量</h3>
      
<ol>
<li>
<p><code>m_loop</code> - subLoop</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *m_loop;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>m_socket</code>/<code>m_channel</code> - <code>unique_ptr</code>管理</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Socket&gt;  m_socket;</span><br><span class="line">    std::unique_ptr&lt;Channel&gt; m_channel;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>m_localAddr</code>/<code>m_peerAddr</code> - 本地/对端地址信息</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> InetAddress m_localAddr;</span><br><span class="line">    <span class="type">const</span> InetAddress m_peerAddr;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p><code>m_inputBuffer</code>/<code>m_outputBuffer</code> - 读写缓冲区</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Buffer m_inputBuffer;</span><br><span class="line">    Buffer m_outputBuffer;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>各种标志</p>
<ol>
<li><code>m_name</code></li>
<li><code>m_state</code> - atomic，用枚举类变量赋值</li>
<li><code>m_reading</code></li>
<li><code>m_highWaterMark</code> - 高水位阈值</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> std::string m_name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">StateE</span> &#123;kDisconnected, kConnecting, kConnected, kDisconnecting&#125;;</span><br><span class="line">    std::atomic_int m_state;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> m_reading;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> m_highWaterMark;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>各种回调</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ConnectionCallback	    m_connectionCallback;</span><br><span class="line">    MessageCallback	        m_messageCallback;</span><br><span class="line">    WriteCompleteCallback   m_writeCompleteCallback;</span><br><span class="line">    HighWaterMarkCallback   m_highWaterMarkCallback;</span><br><span class="line">    CloseCallback           m_closeCallback;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="成员函数-10"   >
          <a href="#成员函数-10" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-10"></a> 成员函数</h3>
      
<ol>
<li>
<p>构造/析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpConnection</span>(EventLoop *loop, <span class="type">const</span> std::string&amp; name, <span class="type">int</span> sockfd,</span><br><span class="line">                  <span class="type">const</span> InetAddress&amp; localAddr, <span class="type">const</span> InetAddress&amp; peerAddr);</span><br><span class="line">    ~<span class="built_in">TcpConnection</span>();</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>建立/销毁连接</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectEstablished</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectDestoryed</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>send - 发送数据</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * data, <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>shutdown - 关闭连接</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdownInLoop</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>设置回调</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_connectionCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_messageCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp; cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_writeCompleteCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="type">const</span> CloseCallback &amp;cb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_closeCallback = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHighWaterMarkCallback</span><span class="params">(<span class="type">const</span> HighWaterMarkCallback &amp; cb, <span class="type">size_t</span> highWaterMark)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_highWaterMarkCallback = cb;</span><br><span class="line">        m_highWaterMark = highWaterMark;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>设置、判断标志</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_state == kConnected;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(StateE state)</span> </span>&#123;m_state = state;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>获取属性</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EventLoop * <span class="title">getLoop</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_loop;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_name;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> InetAddress&amp; <span class="title">localAddress</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_localAddr;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> InetAddress&amp; <span class="title">peerAddress</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_peerAddr;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleRead/handleWrite/handleClose/handleError</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h3 id="代码实现-7"   >
          <a href="#代码实现-7" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-7"></a> 代码实现</h3>
      
<ol>
<li>
<p>构造：重要参数 - loop、sockfd、localAddr、peerAddr</p>
<ol>
<li>给loop赋值，name起名字</li>
<li>赋state为<code>kConnecting</code>、reading为<code>true</code></li>
<li>以sockfd为参数构造socket，new后赋给智能指针<code>m_socket</code></li>
<li>以loop、sockfd为参数构造channel，new后赋给智能指针<code>m_channel</code></li>
<li>赋值localAddr、peerAddr</li>
<li>赋高水位阈值<code>m_highWaterMark</code>为<code>64*1024*1024</code>(64M)</li>
<li>给<code>m_channel</code>设置相应的回调，当poller给channel通知感兴趣的事件发生，则channel会回调相应的操作函数</li>
<li>对<code>m_socket</code>调用<code>setKeepAlive</code>，使TCP启动保活机制</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写为static，防止函数名字冲突 */</span></span><br><span class="line"><span class="function"><span class="type">static</span> EventLoop* <span class="title">CheckLoopNotNull</span><span class="params">(EventLoop* loop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loop == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FATAL</span>(<span class="string">&quot;%s:%s:%d mainLoop is null\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop* loop, <span class="type">const</span> std::string &amp;nameArg, <span class="type">int</span> sockfd,</span><br><span class="line">                             <span class="type">const</span> InetAddress &amp;localAddr, <span class="type">const</span> InetAddress &amp;peerAddr)</span><br><span class="line">    : <span class="built_in">m_loop</span>(<span class="built_in">CheckLoopNotNull</span>(loop)), <span class="built_in">m_name</span>(nameArg),</span><br><span class="line">      <span class="built_in">m_state</span>(kConnecting), <span class="built_in">m_reading</span>(<span class="literal">true</span>),</span><br><span class="line">      <span class="built_in">m_socket</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),</span><br><span class="line">      <span class="built_in">m_channel</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">      <span class="built_in">m_localAddr</span>(localAddr), <span class="built_in">m_peerAddr</span>(peerAddr),</span><br><span class="line">      <span class="built_in">m_highWaterMark</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">//64M</span></span><br><span class="line">&#123;</span><br><span class="line">    m_channel-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1));</span><br><span class="line">    m_channel-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">    m_channel-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    m_channel-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s [%s] at fd = %d\n&quot;</span>, __FUNCTION__, m_name.<span class="built_in">c_str</span>(), sockfd);</span><br><span class="line">    m_socket-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);   <span class="comment">//启动TCP保活机制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::~<span class="built_in">TcpConnection</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s [%s] at fd = %d, state = %d\n&quot;</span>,</span><br><span class="line">              __FUNCTION__, m_name.<span class="built_in">c_str</span>(), m_channel-&gt;<span class="built_in">fd</span>(), m_state.<span class="built_in">load</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleRead - 调用<code>m_inputBuffer</code>的<code>readFd</code>, 读取channel上的消息; 如果有数据则调用<code>m_messageCallback</code>; 如果返回值为0说明客户端断开, 调用<code>handleClose</code>; 如果出错则<code>handleError</code>;</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = m_inputBuffer.<span class="built_in">readFd</span>(m_channel-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage</span></span><br><span class="line">        <span class="built_in">m_messageCallback</span>(<span class="built_in">shared_from_this</span>(), &amp;m_inputBuffer, receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="comment">//客户端断开</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleWrite - 调用<code>m_outputBuffer</code>的<code>writeFd</code>, 写到channel上对应fd的缓冲区(调用<code>peek</code>, 找到缓冲区数据包中可读数据起始位置, 把从此位置起共<code>readableBytes()</code>数据写到fd); 如果成功则调用<code>m_loop-&gt;queueInLoop(std::bind(m_writeCompleteCallback, shared_from_this()))</code>; 最后, 判断连接的状态如果是<code>Disconnecting</code>则<code>shutdownInLoop</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_channel-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = m_outputBuffer.<span class="built_in">writeFd</span>(m_channel-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_outputBuffer.<span class="built_in">retrieve</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(m_outputBuffer.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_channel-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="keyword">if</span>(m_writeCompleteCallback)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 唤醒loop对应的thread线程, 执行回调 */</span></span><br><span class="line">                    m_loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(m_writeCompleteCallback,</span><br><span class="line">                                                  <span class="built_in">shared_from_this</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(m_state == kDisconnecting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s: connection fd = %d is down, no more writing.\n&quot;</span>,</span><br><span class="line">                   __FUNCTION__, m_channel-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleClose - 调用<code>setState(kDisconnected)</code>, <code>m_channel-&gt;disableAll()</code>, <code>m_connectionCallback</code>, <code>m_closeCallback</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s: fd = %d, state: %d\n&quot;</span>, __FUNCTION__, m_channel-&gt;<span class="built_in">fd</span>(), m_state.<span class="built_in">load</span>());</span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    m_channel-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connPtr</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="built_in">m_connectionCallback</span>(connPtr);</span><br><span class="line">    <span class="built_in">m_closeCallback</span>(connPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>handleError - 调用<code>getsockopt</code>, 调查fd的错误, 如果连getsockopt也失败则存储全局errno</p>
<ul>
<li><code>int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen)</code>: 操作套接字选项时，必须指定选项所在的级别和选项的名称, <code>SOL_SOCKET</code>表示在套接字API级别, 参见<code>getprotoent(3)</code>; 参数<code>optval</code>和<code>optlen</code>对于getsockopt(), 标识一个缓冲区，请求选项的值将在其中返回。<code>optlen</code>是一个值结果参数，最初包含<code>optval</code>指向的缓冲区的大小，并在返回时修改以指示返回值的实际大小。 如果不提供或返回选项值，则<code>optval</code>可能为NULL。</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> optval;</span><br><span class="line">    <span class="type">socklen_t</span> optlen = <span class="keyword">sizeof</span> optval;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(::<span class="built_in">getsockopt</span>(m_channel-&gt;<span class="built_in">fd</span>(), SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err = optval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s name: %s - SO_ERROR: %d\n&quot;</span>, __FUNCTION__, m_name.<span class="built_in">c_str</span>(), err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>send - 用户会给TcpServer注册onMessageCallback, 已建立连接的用户有读写事件时, 尤其是读事件, onMessage会响应; 处理完客户端发来的事件后(onMessageCallback), 服务端会send给客户端回发消息;</p>
<blockquote>
<p>在TcpConnection的成员中, 有两个Buffer成员;</p>
<ol>
<li>inputBuffer - 接收数据的缓冲区 - 即recv操作需要暂存的区域</li>
<li>outputBuffer - 发送数据的缓冲区 - 即send操作需要暂存的区域</li>
</ol>
<p>其中, outputBuffer存在的意义?</p>
<ol>
<li>应用层可能需要处理很多数据, 数据从传输层到网络层到数据链路层的传输往往比应用层发送得快; 需要用缓冲区暂存;</li>
<li>为了防止应用层与底层传输的数据量差距悬殊导致数据丢失, 设置了一个高水位阈值;</li>
</ol>
</blockquote>
<blockquote>
<p>收发数据的方式: 本项目的数据收发统一使用json或protobuf格式化的字符串进行, 所以此send函数的参数为了方便起见, 直接规定为string类型;</p>
</blockquote>
<ol>
<li>判断当前连接的状态是否为connected;</li>
<li>判断此loop是否在本thread中, 如果是则调用sendInLoop; 否则runInLoop, 绑定的函数也是sendInLoop;</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> std::string &amp;buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_state == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_loop-&gt;<span class="built_in">isInLoopThread</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_loop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,</span><br><span class="line">                              <span class="keyword">this</span>, buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">size</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>sendInLoop - 写数据操作, 结合了sendInLoop和handleWrite</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> remaining = len;</span><br><span class="line">    <span class="type">bool</span> faultError = <span class="literal">false</span>;	<span class="comment">//记录是否产生错误</span></span><br><span class="line">    <span class="keyword">if</span>(m_state == kDisconnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Disconnected, give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * m_channel-&gt;isWriting()为false表示channel第一次开始写数据, </span></span><br><span class="line"><span class="comment">     * readableBytes()为0说明缓冲区没有待发送数据; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(!m_channel-&gt;<span class="built_in">isWriting</span>() &amp;&amp; m_outputBuffer.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(m_channel-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span>(remaining == <span class="number">0</span> &amp;&amp; m_writeCompleteCallback)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果此时数据全部发送完毕, 不用再给channel设置epollout事件</span></span><br><span class="line">                m_loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(m_writeCompleteCallback, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__);</span><br><span class="line">                <span class="keyword">if</span>(errno == EPIPE || errno == ECONNRESET)<span class="comment">// SIGPIPE or RESET</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)<span class="comment">//没有出错, 没有发送完毕, 剩余数据需要存到缓冲区, 然后给channel注册epollout事件, LT模式, poller发现tcp的发送缓冲区有空间, 会通知相应的sock-&gt;channel, 调用writeCallback方法, 即调用handleWrite, 直到把发送缓冲区中数据全部发送</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> oldlen = m_outputBuffer.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="keyword">if</span>(oldlen + remaining &gt;= m_highWaterMark &amp;&amp; oldlen &lt; m_highWaterMark &amp;&amp; m_highWaterMarkCallback)</span><br><span class="line">        &#123;</span><br><span class="line">            m_loop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(m_highWaterMarkCallback, <span class="built_in">shared_from_this</span>(), oldlen+remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        m_outputBuffer.<span class="built_in">append</span>((<span class="type">char</span>*)data+nwrote, remaining);<span class="comment">//data+nworte即剩余的位置</span></span><br><span class="line">        <span class="keyword">if</span>(!m_channel-&gt;<span class="built_in">isWriting</span>())<span class="comment">//m_channel-&gt;isWriting()为false表示channel第一次开始写数据, 之前没有注册epollout, 现在需要注册</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_channel-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>connectEstablished</p>
<ol>
<li>setState为kConnected;</li>
<li>调用<code>m_channel-&gt;tie</code>, 让<code>m_channel</code>绑定一个TcpConnection, 方便后期观察TcpConnection是否还有效, 若已失效将不进行相应的操作, 已然无意义;</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    m_channel-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    m_channel-&gt;<span class="built_in">enableReading</span>();	<span class="comment">//向poller注册channel的epollin事件</span></span><br><span class="line">    <span class="comment">//有新连接建立, 调用connectionCallback</span></span><br><span class="line">    <span class="built_in">m_connectionCallback</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>connectDestroyed</p>
<ol>
<li>判断state是否为connected, 若是则setState为kDisconnected, 并调用<code>m_channel-&gt;disableAll()</code>, 调用<code>connectionCallback</code></li>
<li>最后<code>m_channel-&gt;remove()</code>, 把channel从poller中删除掉</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestoryed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_state == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        m_channel-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">        <span class="built_in">m_connectionCallback</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    m_channel-&gt;<span class="built_in">remove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>shutdown/shutdownInLoop</p>
<ul>
<li>关闭写端, 将会触发epollhup, 调用closeCallback, 即TcpConnection中的handleClose方法,
<ol>
<li>setState(kDisconnected)</li>
<li>m_channel-&gt;disableAll()</li>
<li>connectionCallback, closeCallback</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_state == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        m_loop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭写端, 将会触发epollhup, </span></span><br><span class="line"><span class="comment"> * 会调用closeCallback, </span></span><br><span class="line"><span class="comment"> * 即TcpConnection中的handleClose方法,</span></span><br><span class="line"><span class="comment"> * handleClose将会: </span></span><br><span class="line"><span class="comment"> *  1. setState(kDisconnected);</span></span><br><span class="line"><span class="comment"> *  2. m_channel-&gt;disableAll();</span></span><br><span class="line"><span class="comment"> *  3. connectionCallback, closeCallback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_channel-&gt;<span class="built_in">isWriting</span>())<span class="comment">//说明outputBuffer中的数据已经全部发送完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_socket-&gt;<span class="built_in">shutdownWrite</span>();<span class="comment">//关闭写端, 将会触发epollhup, 会调用closeCallback, 即TcpConnection中的handleClose方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="tcpserver收尾"   >
          <a href="#tcpserver收尾" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcpserver收尾"></a> TcpServer收尾</h1>
      
<ol>
<li>
<p>newConnection - 运行在主线程当中，主线程的mainLoop调用此函数，选择了一个ioLoop，<strong>在非子loop的线程中（即当前是在mainThread）执行cb，就需要唤醒子loop所在线程（subThread），执行cb</strong>，即调用subLoop的<code>queueInLoop(cb)</code>。</p>
<ol>
<li>根据轮询算法选择一个subLoop，即调用<code>m_threadPool-&gt;getNextLoop()</code></li>
<li>唤醒subLoop</li>
<li>把当前connfd封装成channel分发给subloop</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop *ioLoop = m_threadPool-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, m_IPport.<span class="built_in">c_str</span>(), m_nextConnId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>removeConnection/removeConnectionInLoop</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_loop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s [%s] - connection %s\n&quot;</span>,</span><br><span class="line">             __FUNCTION__, m_name.<span class="built_in">c_str</span>(), conn-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    m_connections.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());</span><br><span class="line">    EventLoop *ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestoryed, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="流程"   >
          <a href="#流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#流程"></a> 流程</h1>
      
<ol>
<li>TcpServer -&gt; Acceptor -&gt; 有一个新用户连接，通过accept函数得到connfd</li>
<li>用户给TcpServer设置回调 -&gt; TcpServer给TcpConnection设置回调 -&gt; TcpConnection把回调传给Channel -&gt; Channel注册到Poller中 -&gt; Poller通知Channel调用回调</li>
<li>mainLoop中的acceptor是一个特殊的socketfd, 它只有一个回调<code>ReadCallback</code>, 负责监听新用户的连接, 返回socket, 将这个socket打包成TcpConnection, 再注册相应的回调;</li>
</ol>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://xing-cg.github.io">Mr.Can</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE-muduo/%E9%87%8D%E5%86%99muduo%E5%BA%93/">https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE-muduo/%E9%87%8D%E5%86%99muduo%E5%BA%93/</a></span></div></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/%E9%A1%B9%E7%9B%AE/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">MySQL数据库连接池</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/%E5%A4%9A%E7%BA%BF%E7%A8%8B/CAS_%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"><span class="paginator-prev__text">CAS_原子操作</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-number">1.</span> <span class="toc-text">
           内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">
           编写目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmake"><span class="toc-number">3.</span> <span class="toc-text">
           cmake</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">
           辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#noncopyable"><span class="toc-number">4.1.</span> <span class="toc-text">
           noncopyable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyable"><span class="toc-number">4.2.</span> <span class="toc-text">
           copyable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpserver%E6%A6%82%E8%A7%88"><span class="toc-number">5.</span> <span class="toc-text">
           TcpServer概览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#inetaddress"><span class="toc-number">5.1.</span> <span class="toc-text">
           InetAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eventloop%E6%A6%82%E8%A7%88"><span class="toc-number">5.2.</span> <span class="toc-text">
           EventLoop概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel"><span class="toc-number">5.3.</span> <span class="toc-text">
           Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E5%88%AB%E5%90%8D"><span class="toc-number">5.3.1.</span> <span class="toc-text">
           公有别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.2.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">
           成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poller"><span class="toc-number">5.4.</span> <span class="toc-text">
           Poller</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-2"><span class="toc-number">5.4.1.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-2"><span class="toc-number">5.4.2.</span> <span class="toc-text">
           成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epollpoller"><span class="toc-number">5.5.</span> <span class="toc-text">
           EpollPoller</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-3"><span class="toc-number">5.5.1.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">5.5.2.</span> <span class="toc-text">
           成员属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">5.5.3.</span> <span class="toc-text">
           实现代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#currentthread-%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E8%8E%B7%E5%8F%96tid"><span class="toc-number">5.6.</span> <span class="toc-text">
           CurrentThread - 主要用于获取tid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eventloop"><span class="toc-number">6.</span> <span class="toc-text">
           EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-3"><span class="toc-number">6.1.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-4"><span class="toc-number">6.2.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-2"><span class="toc-number">6.3.</span> <span class="toc-text">
           实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.3.1.</span> <span class="toc-text">
           全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">
           全局函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eventloopthread"><span class="toc-number">7.</span> <span class="toc-text">
           EventLoopThread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#thread"><span class="toc-number">7.1.</span> <span class="toc-text">
           Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">
           线程函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-4"><span class="toc-number">7.1.2.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">
           成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.4.</span> <span class="toc-text">
           代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eventloopthread-2"><span class="toc-number">7.2.</span> <span class="toc-text">
           EventLoopThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">
           线程初始化时回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-5"><span class="toc-number">7.2.2.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-5"><span class="toc-number">7.2.3.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">7.2.4.</span> <span class="toc-text">
           代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eventloopthreadpool"><span class="toc-number">8.</span> <span class="toc-text">
           EventLoopThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-2"><span class="toc-number">8.1.</span> <span class="toc-text">
           线程初始化时回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-6"><span class="toc-number">8.2.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-6"><span class="toc-number">8.3.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">8.4.</span> <span class="toc-text">
           代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#acceptor"><span class="toc-number">9.</span> <span class="toc-text">
           Acceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket"><span class="toc-number">9.1.</span> <span class="toc-text">
           socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#h%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.1.</span> <span class="toc-text">
           .h文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cc%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.2.</span> <span class="toc-text">
           .cc文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acceptor-2"><span class="toc-number">9.2.</span> <span class="toc-text">
           Acceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%88%B0%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="toc-number">9.2.1.</span> <span class="toc-text">
           收到新连接时的回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-7"><span class="toc-number">9.2.2.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-7"><span class="toc-number">9.2.3.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">9.2.4.</span> <span class="toc-text">
           代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpserver"><span class="toc-number">10.</span> <span class="toc-text">
           TcpServer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83"><span class="toc-number">10.1.</span> <span class="toc-text">
           回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="toc-number">10.1.1.</span> <span class="toc-text">
           线程初始化时的回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-%E8%AF%BB%E5%86%99%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9B%9E%E8%B0%83-%E5%8D%95%E7%8B%AC%E5%86%99%E5%88%B0callbacksh%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">10.1.2.</span> <span class="toc-text">
           连接、读写事件的回调 - 单独写到callbacks.h文件中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%A3%B0%E6%98%8E"><span class="toc-number">10.2.</span> <span class="toc-text">
           枚举声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-8"><span class="toc-number">10.3.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-8"><span class="toc-number">10.4.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">10.5.</span> <span class="toc-text">
           代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpconnection"><span class="toc-number">11.</span> <span class="toc-text">
           TcpConnection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer"><span class="toc-number">11.1.</span> <span class="toc-text">
           Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-9"><span class="toc-number">11.1.1.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-9"><span class="toc-number">11.1.2.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">11.1.3.</span> <span class="toc-text">
           代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpconnection-2"><span class="toc-number">11.2.</span> <span class="toc-text">
           TcpConnection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-10"><span class="toc-number">11.2.1.</span> <span class="toc-text">
           成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-10"><span class="toc-number">11.2.2.</span> <span class="toc-text">
           成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">11.2.3.</span> <span class="toc-text">
           代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpserver%E6%94%B6%E5%B0%BE"><span class="toc-number">12.</span> <span class="toc-text">
           TcpServer收尾</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">
           流程</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">295</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">54</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>