<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="内容         线程安全的定义 对象的创建 对象的销毁 线程安全的Observer 解决方案 陷阱                       线程安全的定义        依据[JCP]，一个线程安全的class应当满足以下三个条件：  多个线程同时访问时，其表现出正确的行为。 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。 调用端">
<meta property="og:type" content="article">
<meta property="og:title" content="读muduo有感_线程安全的对象生命期管理">
<meta property="og:url" content="https://xing-cg.github.io/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:description" content="内容         线程安全的定义 对象的创建 对象的销毁 线程安全的Observer 解决方案 陷阱                       线程安全的定义        依据[JCP]，一个线程安全的class应当满足以下三个条件：  多个线程同时访问时，其表现出正确的行为。 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。 调用端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xing-cg.github.io/images/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/image-20220425141301184.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/image-20220425141415894.png">
<meta property="article:published_time" content="2022-04-25T00:00:00.000Z">
<meta property="article:modified_time" content="2025-09-09T10:11:44.327Z">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xing-cg.github.io/images/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/image-20220425141301184.png"><title>读muduo有感_线程安全的对象生命期管理 | 罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">读muduo有感_线程安全的对象生命期管理</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-09</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/" data-flag-title="读muduo有感_线程安全的对象生命期管理"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>线程安全的定义</li>
<li>对象的创建</li>
<li>对象的销毁</li>
<li>线程安全的Observer</li>
<li>解决方案</li>
<li>陷阱</li>
</ol>

        <h1 id="线程安全的定义"   >
          <a href="#线程安全的定义" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程安全的定义"></a> 线程安全的定义</h1>
      
<p>依据<code>[JCP]</code>，一个线程安全的class应当满足以下三个条件：</p>
<ul>
<li>多个线程同时访问时，其表现出正确的行为。</li>
<li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。</li>
<li>调用端代码无须额外的同步或其他协调动作。</li>
</ul>
<p>依据这个定义，C++标准库里的大多数class都不是线程安全的，包括<code>std::string</code>、<code>std::vector</code>、<code>std::map</code>等。这些class通常需要在外部加锁才能供多个线程同时访问。</p>

        <h2 id="以counter为例说明问题"   >
          <a href="#以counter为例说明问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#以counter为例说明问题"></a> 以Counter为例说明问题</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> : boost::nocopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">value_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">getAndIncrease</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int64_t</span> value_;</span><br><span class="line">    <span class="keyword">mutable</span> MutexLock mutex_;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">Counter::value</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="type">int64_t</span> ret = value_++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这个class很直白，一看就明白，也容易验证它是线程安全的。每个Counter对象有自己的<code>mutex_</code>，因此不同对象之间不构成<strong>锁争用(lock contention)</strong>。如果是同一个Counter对象则不可同时访问<code>value_++</code>。</p>
<p>注意到，其<code>mutex_</code>成员是<code>mutable</code>的，意味着<code>const</code>成员函数如<code>Counter::value()</code>也能直接使用<code>non-const</code>的<code>mutex_</code>。</p>
<p>尽管这个<code>Counter</code>毫无疑问是线程安全的，但是如果<code>Counter</code>是动态创建的，并通过指针来访问，则对象销毁的**竞态条件(race condition)**仍然存在。</p>

        <h3 id="当析构函数遇到多线程"   >
          <a href="#当析构函数遇到多线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#当析构函数遇到多线程"></a> 当析构函数遇到多线程</h3>
      
<p>与其他面向对象语言不同，Cpp要求程序员自己管理对象的生命期，这在多线程环境下显得尤为困难。</p>
<p><strong>当一个对象能被多个线程同时看到时，那么对象的销毁时机就变得模糊不清，可能出现多种竞态条件</strong>。</p>
<ul>
<li>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？</li>
<li>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</li>
<li>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</li>
</ul>
<p>这些竞态条件问题是C++多线程编程面临的基本问题。</p>

        <h1 id="对象的创建"   >
          <a href="#对象的创建" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对象的创建"></a> 对象的创建</h1>
      
<p>对象构造要做到线程安全，唯一的要求是在构造期间不要给其他对象泄露this指针（其自身创建的子对象除外）。即：</p>
<ul>
<li>不要在构造函数中注册任何回调；</li>
<li>不要在构造函数中把this传给跨线程的对象；</li>
<li>即便在构造函数的最后一行也不行。</li>
</ul>
<p>之所以这样规定，是因为在构造函数执行期间，对象还没有完成初始化工作，如果这时this泄露给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Observable* s)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  Observable* subject_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">register_</span><span class="params">(Observer* x)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unregister</span><span class="params">(Observer* x)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; observers_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      Observer* x = observers_[i];</span><br><span class="line">      <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        x-&gt;<span class="built_in">update</span>(); <span class="comment">// (3)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;Observer*&gt; observers_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Observer::~<span class="built_in">Observer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  subject_-&gt;<span class="built_in">unregister</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observer::observe</span><span class="params">(Observable* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  s-&gt;<span class="built_in">register_</span>(<span class="keyword">this</span>);</span><br><span class="line">  subject_ = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observable::register_</span><span class="params">(Observer* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  observers_.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observable::unregister</span><span class="params">(Observer* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;Observer*&gt;::iterator it = std::<span class="built_in">find</span>(observers_.<span class="built_in">begin</span>(), observers_.<span class="built_in">end</span>(), x);</span><br><span class="line">  <span class="keyword">if</span> (it != observers_.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(*it, observers_.<span class="built_in">back</span>());</span><br><span class="line">    observers_.<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 错误 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(Observer * s)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;<span class="built_in">register_</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 正确 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Observer * s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s-&gt;<span class="built_in">register_</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo* pFoo = <span class="keyword">new</span> Foo;</span><br><span class="line">Observer * s = <span class="built_in">getSubject</span>();</span><br><span class="line">pFoo-&gt;<span class="built_in">observer</span>(s);	<span class="comment">//二段式构造，或者直接写s-&gt;register_(pFoo);</span></span><br></pre></td></tr></table></div></figure>
<p>二段式构造——即构造函数+initialize()——有时会是好办法，这虽然不符合C++教条，但是多线程下别无选择。</p>
<p>另外，既然允许二段式构造，那么构造函数不必主动抛异常，调用方靠initialize()的返回值来判断对象是否构造成功，这能简化错误处理。</p>
<p>即使是构造函数的最后一行，也不要泄露this指针，因为Foo有可能是个基类，基类先于派生类构造，执行完<code>Foo::Foo()</code>的最后一行代码还会继续执行派生类的构造函数，这时<code>most-derived class</code>的对象还处于构造中，仍然不安全。</p>

        <h1 id="对象的销毁"   >
          <a href="#对象的销毁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对象的销毁"></a> 对象的销毁</h1>
      
<p>对象的析构，在单线程里不构成问题，最多需要注意避免空悬指针和野指针。</p>
<p>而在多线程程序中，存在了太多的竞态条件。对<strong>一般成员函数</strong>而言，做到线程安全的办法是让它们顺次执行，而不要并发执行（关键是不要同时读写共享状态），也就是让每个成员函数的临界区不重叠。这是显而易见的，不过有一个隐含条件或许不是每个人都能立刻想到：成员函数用来保护临界区的<strong>互斥器本身必须是有效的。而析构函数破坏了这一假设，它会把mutex成员变量销毁掉</strong>。悲剧啊！</p>
<ul>
<li>mutex不是办法。</li>
</ul>
<p>mutex只能保证函数一个接一个地执行，考虑下面两个代码（并行），它试图用互斥锁来保护析构函数：</p>
<p><img src="../../images/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/image-20220425141301184.png" alt="image-20220425141301184" /></p>
<p>此时，有A、B两个线程都能看到Foo对象x，线程A即将销毁x，而线程B正准备调用<code>x-&gt;update()</code>。</p>
<p><img src="../../images/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/image-20220425141415894.png" alt="image-20220425141415894" /></p>
<p>尽管线程A在销毁对象之后把指针置为了<code>NULL</code>，尽管线程B在调用x的成员函数之前检查了指针x的值，但还是无法避免一种竞态条件：</p>
<ol>
<li>线程A执行到了析构函数的<code>(1)</code>处，已经持有了互斥锁，即将继续往下执行。</li>
<li>线程B通过了<code>if(x)</code>检测，阻塞在<code>(2)</code>处。</li>
</ol>
<p>接下来会发生什么，只有天晓得。因为析构函数会把<code>mutex_</code>销毁，那么<code>(2)</code>处有可能永远阻塞下去，有可能进入“临界区”，然后<code>core dump</code>，或者发生其他更糟糕的情况。</p>
<p>这个例子至少说明<code>delete</code>对象之后把指针置为<code>NULL</code>根本没用，如果一个程序要靠这个来防止二次释放，说明代码逻辑出了问题。</p>
<ul>
<li>作为数据成员的mutex不能保护析构</li>
</ul>
<p>前面的例子说明，作为class数据成员的<code>MutexLock</code>只能用于同步本class的其他数据成员的读和写，它不能保护安全地析构。因为<code>MutexLock</code>成员的生命期最多与对象一样长，而析构动作可说是发生在对象死亡之后（或者说死亡之时）。另外，对于基类对象，调用到基类析构函数的时候，派生类对象的那部分已经析构完毕了，那么基类对象拥有的<code>MutexLock</code>不能保护整个析构过程。</p>
<p>其实，析构过程本来也不需要保护，因为只有别的线程都访问不到这个对象时，析构才是安全的，否则会有竞态条件发生。</p>

        <h2 id="死锁"   >
          <a href="#死锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2>
      
<p>如果要同时读写一个class的两个对象，有潜在的死锁可能。比方说有<code>swap()</code>这个函数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Counter &amp; a, Counter &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">aLock</span><span class="params">(a.mutex_)</span></span>;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">bLock</span><span class="params">(b.mutex_)</span></span>;</span><br><span class="line">    <span class="type">int64_t</span> value = a.value_;</span><br><span class="line">    a.value_ = b.value_;</span><br><span class="line">    b.value_ = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果线程A执行<code>swap(a, b);</code>而同时线程B执行<code>swap(b, a);</code>，就有可能死锁。<code>operator=()</code>也是类似的道理。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Counter&amp; Counter::<span class="keyword">operator</span>=(<span class="type">const</span> Counter&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">myLock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">itsLock</span><span class="params">(rhs.mutex_)</span></span>;</span><br><span class="line">    <span class="comment">/* 不要写成 value_ = rhs.value()，会死锁； </span></span><br><span class="line"><span class="comment">     * rhs.value() --&gt; </span></span><br><span class="line"><span class="comment">     *		MutexLockGuard lock(mutex_);</span></span><br><span class="line"><span class="comment">     *		int64_t ret = value_++;</span></span><br><span class="line"><span class="comment">     *		return ret;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    value_ = rhs.value_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较mutex对象的地址，始终先加锁地址较小的mutex。？？？</p>

        <h1 id="线程安全的observer"   >
          <a href="#线程安全的observer" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程安全的observer"></a> 线程安全的Observer</h1>
      
<p>一个动态创建的对象是否还活着，光看指针（或引用）看不出来。指针就是指向了一块内存，这块内存上的对象如果已经销毁，那么根本就不能访问（就像<code>free(3)</code>之后的地址不能访问一样），既然不能访问又如何知道对象的状态？换句话说，<strong>没有高效的办法判断一个指针是否是合法指针，这是C/C++指针问题的根源</strong>。（万一原址又创建了一个新的对象呢？再万一这个新的对象的类型异于老的对象呢？）</p>

        <h2 id="对象之间关系的三种主要类型"   >
          <a href="#对象之间关系的三种主要类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对象之间关系的三种主要类型"></a> 对象之间关系的三种主要类型</h2>
      
<p><code>composition</code>（组合/复合）、<code>aggregation</code>（聚合）、<code>association</code>（关联）。</p>
<ul>
<li>组合关系</li>
</ul>
<p>组合关系在多线程里不会遇到什么麻烦，因为对象x的生命期由其唯一的拥有者owner控制，owner析构的时候会把x也析构掉。从形式上看，x是owner的直接数据成员，或者<code>scoped_ptr/unique_ptr</code>成员，抑或owner持有的容器的元素。</p>
<p>后两种关系在C++里比较难办，处理不好就会造成内存泄露或者重复释放。</p>
<ul>
<li>关联关系</li>
</ul>
<p>关联是一种很宽泛的关系，它表示一个对象a用到了另一个对象b，调用了后者的成员函数。从代码形式上看，<strong>a持有b的指针或引用，但是b的生命期不由a单独控制</strong>。</p>
<ul>
<li>聚合关系</li>
</ul>
<p>聚合关系从形式上看与关联关系相同，除了a和b有逻辑上的整体与部分的关系。如果b是动态创建的并在整个程序结束前有可能被释放，那么就会出现前文提到的竞态条件。</p>

        <h2 id="如何避免访问失效对象"   >
          <a href="#如何避免访问失效对象" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何避免访问失效对象"></a> 如何避免访问失效对象</h2>
      
<p>似乎有一个简单的解决方法：只创建不销毁。程序使用一个对象池来暂存用过的对象，下次申请新对象时，如果对象池里有存货就拿一个利用，否则就新建一个；对象用完之后不是直接释放掉而是放回池子里。这个办法虽然有很多缺点，但是却能避免访问失效对象的情况发生。</p>
<p>缺点和问题：</p>
<ul>
<li>对象池的线程安全，如何安全地、完整地把对象放回池子里，防止出现“部分放回”的竞态？（线程A任务对象x已经放回了，而线程B以为对象x还活着。）</li>
<li>全局共享数据引发的lock contention，这个集中化的对象池可能会把多线程并发操作退化为串行。</li>
<li>如果共享对象的类型不止一种，那么是重复实现对象池还是使用类模板呢？</li>
<li>会不会造成内存泄漏与分片？因为对象池占用的内存只增不减，而且多个对象池不能共享内存。</li>
</ul>

        <h2 id="observer模式"   >
          <a href="#observer模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#observer模式"></a> Observer模式</h2>
      
<p>回到正题上来，如果对象x注册了任何非静态成员函数回调，那么必然在某处持有了指向x的指针，这就暴露在了竞态条件下。</p>
<p>一个典型的场景是Observer模式。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 观察者 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> <span class="comment">//: boost::noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 观察目标 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span> <span class="comment">//: boost::noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_</span><span class="params">(Observer * x)</span></span>;	<span class="comment">//因为和关键字冲突了，所以加个_</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unregister</span><span class="params">(Observer * x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer * x : observers_)</span><br><span class="line">        &#123;</span><br><span class="line">            x-&gt;<span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>当Observable通知每一个Observer时（<code>x-&gt;update();</code>），它从何得知Observer对象x还活着？要不试试在Observer的析构函数里调用<code>unregister()</code>来解注册？恐难奏效。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> <span class="comment">//: boost::noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 同前</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Observable * s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s-&gt;<span class="built_in">register_</span>(<span class="keyword">this</span>);</span><br><span class="line">        subject_ = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        subject_-&gt;<span class="built_in">unregister</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Observable* subject_;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>我们试着让Observer的析构函数去调用<code>unregister(this)</code>，这里有两个竞态条件。其一：<code>subject_-&gt;unregister(this)</code>中如何得知<code>subject_</code>还活着？其二：就算<code>subject_</code>指向某个永久存在的对象，那么还是险象环生：</p>
<ol>
<li>线程A执行到<code>subject_-&gt;unregister(this)</code>之前，还没有来得及<code>unregister</code>本对象。</li>
<li>线程B执行到<code>x-&gt;update();</code>，x正好指向是<code>subject_-&gt;unregister(this)</code>正在析构的对象。</li>
</ol>
<p>这时悲剧又发生了，既然x所指的Observer对象正在析构，调用它的任何非静态成员函数都是不安全的，何况是虚函数（C++标准对在构造函数和析构函数中调用虚函数的行为有明确规定，但是没有考虑并发调用的情况。）。更糟糕的是，Observer是个基类，执行到<code>subject_-&gt;unregister(this)</code>时，派生类对象已经析构掉了，这时候整个对象处于将死未死的状态，<code>core dump</code>恐怕是最幸运的结果。</p>
<p>这些竞态条件似乎可以通过加锁来解决，但在哪儿加锁？谁持有这些互斥锁？似乎不是那么显而易见。要是有一个活着的对象能帮帮我们就好了，这个对象需要提供一个<code>isAlive()</code>之类的程序函数，告诉我们某个对象还在不在。可惜指针和引用都不是对象，它们是内建类型。（这时候就要引出来智能指针了）</p>

        <h2 id="不要使用原始指针"   >
          <a href="#不要使用原始指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#不要使用原始指针"></a> 不要使用原始指针</h2>
      
<p>指向对象的原始指针(raw pointer)是坏的，尤其当暴露给别的线程时。Observable应当保存的不是原始的<code>Observer*</code>，而是一个能够分辨Observer对象是否存活的东西。类似地，如果Observer要在析构函数里解注册（这虽然不能解决前面提到的竞态条件，但是在析构函数中打扫战场还是应该的），那么<code>subject_</code>的类型也不能是原始的<code>Observable*</code>（因为解注册用到了<code>Obervable</code>，它的<code>unregister</code>成员函数）。</p>
<p>可以<strong>使用引用计数型智能指针</strong>，即<code>shared_ptr</code>。用一层间接性（二级指针）保证了避免释放空悬指针，也通过引用计数解决了释放对象期间的竞态条件问题。</p>

        <h2 id="一个万能的解决方案"   >
          <a href="#一个万能的解决方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一个万能的解决方案"></a> 一个万能的解决方案</h2>
      
<p>引如另外一层间接性，用对象来管理共享资源，亦即<code>handle/body</code>惯用技法。用标准库中的一对“神兵利器”可助我们完美解决原始指针的问题。</p>
<p>即<code>share_ptr</code>+<code>weak_ptr</code>。</p>
<ul>
<li><code>shared_ptr</code>控制对象的生命期。
<ul>
<li><code>shared_ptr</code>是强引用(想象成用铁丝绑住堆上的对象)，只要有一个指向x对象的<code>shared_ptr</code>存在，该x对象就不会析构。</li>
<li>当指向对象x的最后一个<code>shared_ptr</code>析构或<code>reset()</code>的时候，x保证会被销毁。</li>
</ul>
</li>
<li><code>weak_ptr</code>不控制对象的生命期，但是它知道对象是否还活着(想象成用棉线轻轻拴住堆上的对象)。
<ul>
<li>如果对象还活着,那么它可以提升为有效的<code>shared_ptr</code>；</li>
<li>如果对象已经死了，提升会失败，返回一个空的<code>shared_ptr</code>。提升<code>lock()</code>行为是线程安全的。</li>
</ul>
</li>
<li><code>shared_ptr</code>/<code>weak_ptr</code>的“计数”在主流平台上是原子操作，没有用锁，性能不俗。</li>
<li><code>shared_ptr</code>/<code>weak_ptr</code>的线程安全级别与<code>std::string</code>和STL容器一样。</li>
</ul>
<p>孟岩在《垃圾收集机制批判》中一针见血地点出智能指针的优势：“C++利用智能指针达成的效果是：一旦某对象不再被引用，系统刻不容缓，立刻回收内存。这通常发生在关键任务完成后的清理时期，不会影响关键任务的实时性，同时，内存里所有的对象都是有用的，绝对没有垃圾空占内存。”</p>

        <h1 id="c的内存问题很容易解决"   >
          <a href="#c的内存问题很容易解决" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c的内存问题很容易解决"></a> C++的内存问题很容易解决</h1>
      
<p>C++里可能出现的内存问题大致有这么几个方面：</p>
<ol>
<li>缓冲区溢出(buffer overrun)</li>
<li>空悬指针/野指针</li>
<li>重复释放(double delete)</li>
<li>内存泄漏(memory leak)</li>
<li>不配对的<code>new[]/delete</code></li>
<li>内存碎片(memory fragmentation)</li>
</ol>
<p>在这几种错误里边，内存泄漏的危害相对较小，因为它只是借了东西不还，程序功能在一段时间内还算正常；而其他如缓冲区溢出或重复释放等致命错误可能会造成安全性(security和data safety)方面的严重后果。</p>
<p>正确使用智能指针能很轻易地解决前面5个问题。解决第6个问题——内存碎片需要别的思路。</p>
<ul>
<li>缓冲区溢出
<ul>
<li>用<code>std::vector&lt;char&gt;/std::string</code>或自己编写<code>Buffer class</code>来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。</li>
</ul>
</li>
<li>空悬指针/野指针
<ul>
<li>用<code>shared_ptr/weak_ptr</code></li>
</ul>
</li>
<li>重复释放
<ul>
<li>用<code>scoped_ptr</code>，只在对象析构的时候释放一次。</li>
</ul>
</li>
<li>内存泄漏
<ul>
<li>用<code>scoped_ptr</code>，对象析构的时候自动释放内存。</li>
</ul>
</li>
<li>不配对的<code>new[]/delete</code>
<ul>
<li>把<code>new[]</code>统统替换为<code>std::vector/scoped_array</code>。</li>
</ul>
</li>
</ul>
<p>注意：<code>scoped_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>都是值语义。要么是栈上对象，或是其他对象的直接数据成员，或是标准库容器里的元素，即不会出现下面这种形式：<code>shared_ptr&lt;Foo&gt;* pFoo = new shared_ptr&lt;Foo&gt;(new Foo);</code></p>
<p>现代的C++程序中一般不要出现delete语句，资源（包括复杂对象本身）都要通过对象（智能指针或容器）来管理，不要让程序员还要为此操心。</p>

        <h1 id="应用到observer上"   >
          <a href="#应用到observer上" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用到observer上"></a> 应用到Observer上</h1>
      
<p>Observer模式的竞态条件的核心问题是被观察者如何探查观察者的生死，可以通过<code>weak_ptr</code>解决，只要让<code>Observable</code>保存<code>weak_ptr&lt;Observer&gt;</code>即可。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">register_</span><span class="params">(weak_ptr&lt;Observer x)</span></span>;	<span class="comment">//参数类型可用const weak_ptr&lt;Observer&gt;&amp;</span></span><br><span class="line">    <span class="comment">// void unregister(weak_ptr&lt;Observer&gt; x);	//不需要了，已经有下边的代码帮我们解决把失效观察者从observers_中删除了。相应地，Observer的析构函数也不用调用Observable的unregister了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> MutexLock mutex_;</span><br><span class="line">    std::vector&lt;weak_ptr&lt;Observer&gt;&gt; observers_;</span><br><span class="line">    <span class="keyword">using</span> Iterator = std::vector&lt;weak_ptr&lt;Observer&gt;&gt;::iterator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observable::notifyObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    Iterator it = observers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != observers_.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Observer&gt; <span class="title">obj</span><span class="params">(it-&gt;lock())</span></span>;	<span class="comment">//weak_ptr的lock函数，尝试提升为shared_ptr，这一步是线程安全的。</span></span><br><span class="line">        <span class="keyword">if</span>(obj)</span><br><span class="line">        &#123;</span><br><span class="line">            obj-&gt;<span class="built_in">update</span>();	<span class="comment">//没有竞态条件，因为obj在栈上，对象不可能在本作用域内销毁。</span></span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 观察者对象已经销毁，从容器中删除weak_ptr，即做了unregister的工作。</span></span><br><span class="line">            it = observers_.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>经过把<code>Observer*</code>替换为<code>weak_ptr&lt;Observer&gt;</code>，部分解决了<code>Observer</code>模式的线程安全问题，但还有以下疑点。</p>
<ul>
<li>侵入性
<ul>
<li>强制要求<code>Observer</code>必须以<code>shared_ptr</code>来管理</li>
</ul>
</li>
<li>不是完全线程安全</li>
<li>锁争用(lock contention)
<ul>
<li>即<code>Observable</code>的三个成员函数都用了互斥器来同步，这会造成<code>register_</code></li>
</ul>
</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://xing-cg.github.io">Mr.Can</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://xing-cg.github.io/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/">https://xing-cg.github.io/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%AF%BBmuduo%E6%9C%89%E6%84%9F_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E6%9C%9F%E7%AE%A1%E7%90%86/</a></span></div></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">抽象工厂模式</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"><span class="paginator-prev__text">观察者模式</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-number">1.</span> <span class="toc-text">
           内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">
           线程安全的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5counter%E4%B8%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">
           以Counter为例说明问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%81%87%E5%88%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">
           当析构函数遇到多线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text">
           对象的创建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">4.</span> <span class="toc-text">
           对象的销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">4.1.</span> <span class="toc-text">
           死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84observer"><span class="toc-number">5.</span> <span class="toc-text">
           线程安全的Observer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">
           对象之间关系的三种主要类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%AE%BF%E9%97%AE%E5%A4%B1%E6%95%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">
           如何避免访问失效对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#observer%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">
           Observer模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="toc-number">5.4.</span> <span class="toc-text">
           不要使用原始指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.5.</span> <span class="toc-text">
           一个万能的解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%BE%88%E5%AE%B9%E6%98%93%E8%A7%A3%E5%86%B3"><span class="toc-number">6.</span> <span class="toc-text">
           C++的内存问题很容易解决</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%88%B0observer%E4%B8%8A"><span class="toc-number">7.</span> <span class="toc-text">
           应用到Observer上</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">302</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>