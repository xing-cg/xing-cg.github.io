<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="内容         知识储备 线程池                       知识储备                             并发和并行         并发 单核上，CPU时间片轮转，多个线程轮流执行。物理上是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），宏观上看就像是多个线程在共同执行，这样的场景称作并发">
<meta property="og:type" content="article">
<meta property="og:title" content="项目_设计并实现线程池框架库">
<meta property="og:url" content="https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE_%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%BA%93/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:description" content="内容         知识储备 线程池                       知识储备                             并发和并行         并发 单核上，CPU时间片轮转，多个线程轮流执行。物理上是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），宏观上看就像是多个线程在共同执行，这样的场景称作并发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xing-cg.github.io/images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407095057418.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172417250.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172451064.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172642102.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407204205403.png">
<meta property="article:published_time" content="2022-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-12T05:38:11.877Z">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xing-cg.github.io/images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407095057418.png"><title>项目_设计并实现线程池框架库 | 罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE_%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%BA%93/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">项目_设计并实现线程池框架库</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-12</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE_%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%BA%93/" data-flag-title="项目_设计并实现线程池框架库"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>知识储备</li>
<li>线程池</li>
</ol>

        <h1 id="知识储备"   >
          <a href="#知识储备" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#知识储备"></a> 知识储备</h1>
      

        <h2 id="并发和并行"   >
          <a href="#并发和并行" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#并发和并行"></a> 并发和并行</h2>
      
<ul>
<li>并发<br />
单核上，CPU时间片轮转，多个线程轮流执行。物理上是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），宏观上看就像是多个线程在共同执行，这样的场景称作并发(concurrent)。</li>
<li>并行<br />
在多核或者多CPU上，多个线程在同一时刻执行，这样的场景才是真正的并行(parallel)。</li>
</ul>

        <h2 id="两种密集型程序"   >
          <a href="#两种密集型程序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#两种密集型程序"></a> 两种密集型程序</h2>
      
<p>多线程程序一定好吗？不一定，要看具体的应用场景。</p>
<ul>
<li>IO密集型：程序里面指令的执行，涉及IO操作较多，比如设备、文件、网络操作（等待客户端的连接），可能会把程序阻塞。如果CPU时间片再分配给这种线程，相当于浪费了CPU资源。</li>
<li>CPU密集型：程序里面的指令都是做计算用的，不会阻塞。</li>
</ul>
<hr />
<ul>
<li>多核情况下<br />
IO密集型和CPU密集型虽然对并行计算有不同的需求，IO密集型更适合设计成多线程程序。但是在多核情况下两种密集型程序都是有必要用多线程来处理的。<br />
线程进行调度时，内核中有这样两个队列：runnable，就绪的或正在调度的队列。如果因IO操作有线程阻塞了，则将会进入阻塞队列，blocking queue。</li>
<li>单核情况下<br />
IO密集型的程序依然适合设计为多线程程序。<br />
CPU密集型程序不再适合！这就相当于只有一个计算器，却让多个人分段算。线程的调度有额外的花费：线程的上下文切换。CPU寄存器信息会保存在线程栈上，下次还要再恢复到CPU中，实属麻烦。</li>
</ul>

        <h2 id="线程的代价"   >
          <a href="#线程的代价" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程的代价"></a> 线程的代价</h2>
      
<p>为了完成任务，创建很多线程可以吗？线程越多越好吗？</p>
<ul>
<li>线程的创建和销毁都是非常“重”的操作，需要进入内核态。在执行任务的过程中，没有集中资源去干正事，而是去花费很大力度创建/销毁？
<ul>
<li>需要给线程创建<code>PCB(task_struct)</code>、线程的内核栈、页目录、页表</li>
<li>描述地址空间相应的数据结构：<code>vm_area_struct</code></li>
<li>内核创建完后，还要返回用户态</li>
<li>线程执行完业务，还要销毁线程，又要切换一次</li>
</ul>
</li>
<li>线程栈本身占用大量内存，每一个线程都需要线程栈，栈几乎都被占用完了，还怎么做事情？
<ul>
<li>32位地址空间，共4G，用户空间有3G。</li>
<li>线程共享进程的地址空间。</li>
<li>可在linux下执行<code>ulimt -a</code>命令观察stack size默认栈大小，为8192字节即8M。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>∗</mo><mn>1024</mn><mi>M</mi><mo>=</mo><mn>3072</mn><mi>M</mi><mo separator="true">,</mo><mn>3072</mn><mi>M</mi><mi mathvariant="normal">/</mi><mn>8</mn><mi>M</mi><mo>=</mo><mn>384</mn></mrow><annotation encoding="application/x-tex">3*1024M=3072M, 3072M/8M=384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">7</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">7</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord">4</span></span></span></span>个。这说明32位环境下，最多创建384个线程。</li>
</ul>
</li>
<li>线程的上下文切换要占用大量时间
<ul>
<li>线程过多，线程的调度是需要进行上下文切换的，上下文切换花费CPU时间也特别多，CPU的利用率就不高了。</li>
</ul>
</li>
<li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机
<ul>
<li>如果在某一时刻，大量的IO操作准备好了，那么一时间线程是来不及处理的。</li>
</ul>
</li>
</ul>

        <h1 id="线程同步"   >
          <a href="#线程同步" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h1>
      

        <h2 id="线程互斥"   >
          <a href="#线程互斥" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程互斥"></a> 线程互斥</h2>
      
<p>某段代码能不能多线程环境下执行？看这段代码是否存在<strong>竞态条件</strong>，即有无临界区代码段。（代码片段在多线程环境下执行，随着线程的调度顺序不同而得到不同的执行结果）。如果有，则要通过线程同步来保证它的原子操作。</p>
<p>如果在多线程环境下不存在竞态条件，则称之为<strong>可重入的</strong>。</p>

        <h3 id="互斥锁"   >
          <a href="#互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h3>
      
<ul>
<li>lock</li>
<li><code>try_lock</code></li>
<li><code>lock_guard</code></li>
<li><code>unique_lock</code></li>
</ul>

        <h3 id="atomic原子类型"   >
          <a href="#atomic原子类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic原子类型"></a> atomic原子类型</h3>
      
<ul>
<li>CAS操作（无锁机制）
<ul>
<li>无锁队列、无锁链表、无锁数组</li>
<li>实际上使用的是轻量级、效率高的锁，不是没用锁。</li>
</ul>
</li>
</ul>

        <h2 id="线程通信"   >
          <a href="#线程通信" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h2>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88792621" >GDB调试C++11多线程死锁</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="条件变量"   >
          <a href="#条件变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h3>
      

        <h3 id="信号量"   >
          <a href="#信号量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
      
<p>看作资源计数没有限制的mutex互斥锁。mutex互斥锁的资源计数只能是0或者1。</p>

        <h3 id="区别"   >
          <a href="#区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
      
<ul>
<li>二元信号量和互斥锁的区别
<ul>
<li>mutex只能是哪个线程获取锁，由哪个线程释放锁。</li>
<li><code>sem.wait()</code>和<code>sem.post()</code>则可以处在不同的线程中调用。</li>
</ul>
</li>
</ul>

        <h1 id="线程池"   >
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h1>
      
<ul>
<li>线程池的优势<br />
服务进程启动之初，事先创建好线程池里面的线程，当业务到来需要分配线程时直接从线程池中获取一个空闲线程执行task任务即可，task执行完成之后把线程归还到线程池中继续给后续task提供服务，而不用释放线程。</li>
</ul>

        <h2 id="项目介绍"   >
          <a href="#项目介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#项目介绍"></a> 项目介绍</h2>
      
<p>本项目所实现的线程池和对象池、内存池、STL库的意义一样，只能称作一个库，而不能作为一个独立运行的中间件，必须镶嵌在应用程序中。最终项目表现形式为一种提供给他人的<strong>动态库</strong>，比如用到了<code>mysql.h</code>头文件，<code>libmysqlclient.so</code>动态库。动态库需要编译出来。</p>

        <h3 id="使用方式"   >
          <a href="#使用方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h3>
      
<ul>
<li>启动线程池</li>
</ul>
<p>如果你想在应用程序中或者代码中使用本项目的线程池，你可以</p>
<ol>
<li>直接<code>ThreadPool pool;</code>定义一个<code>pool</code>对象；</li>
<li>而后则可以调用<code>pool.sexMode(fixed(default) | cached);</code>接口设置线程池的运行模式，默认为固定模式。</li>
<li>然后<code>pool.start();</code>启动线程池。start不会阻塞。</li>
</ol>
<p>启动线程池意味着线程池开始创建若干线程，就绪，等待任务过来执行任务。</p>
<ul>
<li>提交任务</li>
</ul>
<p>调用方只要按以下形式调用API即可：<code>Result result = pool.submitTask(concreteTask);</code></p>
<p>调用方无需关心内部操作，包括线程分配、执行过程。</p>
<p>有时调用方需要获取任务执行的结果，可用<code>T res = result.get().Cast&lt;T&gt;();</code>获得任务结果。任务结果的返回值是任意类型，具体类型T由用户指出。（此处用到了C++17中的Any类型）</p>

        <h2 id="线程池的设计"   >
          <a href="#线程池的设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池的设计"></a> 线程池的设计</h2>
      

        <h3 id="类成员"   >
          <a href="#类成员" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类成员"></a> 类成员</h3>
      
<p>首先说一说抽象出的类：线程池类、线程池中的线程类。</p>
<ol>
<li>既然是线程池，就要有一个<strong>存放线程的容器</strong>
<ol>
<li>我们最好能实时监控线程池中线程的数量、以及上限阈值，避免线程数量走向极端从而影响性能（线程数量不是越多越好，坏处：1、线程栈空间冗余；2、上下文切换过程时间多于执行操作）</li>
</ol>
</li>
<li>还要有一个存放待完成任务的容器，即<strong>任务队列</strong>
<ol>
<li>考不考虑线程安全问题？必须考虑，外层用户提交任务要放数据，下层线程执行任务要取数据。</li>
<li>任务不能堆积过多。对于任务队列，也要有一个上限阈值。</li>
</ol>
</li>
</ol>

        <h3 id="通用化的实现-task设计-继承多态思想"   >
          <a href="#通用化的实现-task设计-继承多态思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通用化的实现-task设计-继承多态思想"></a> 通用化的实现 - Task设计 - 继承多态思想</h3>
      
<p>任务类型需要达到通用性，所以要用到继承、多态的思想。用基类指针可以指向各种各样的派生类对象。</p>
<p>所以需要<strong>设计一个抽象类Task。内部提供一个纯虚函数<code>virtual void run() = 0</code></strong>。如果要设计特定的任务，则继承（实现）之，重写run函数即可。</p>

        <h3 id="线程通信的保证-mtxcv"   >
          <a href="#线程通信的保证-mtxcv" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程通信的保证-mtxcv"></a> 线程通信的保证 - mtx+cv</h3>
      
<p>因为涉及到放任务、取任务，所以很明显是个生产者消费者模型。</p>
<p>必然<strong>用到互斥锁+条件变量，从而对任务队列进行互斥保护</strong>、达到正确的线程通信。</p>

        <h2 id="线程池的模式"   >
          <a href="#线程池的模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池的模式"></a> 线程池的模式</h2>
      
<ul>
<li>fixed模式</li>
</ul>
<p>线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。</p>
<ul>
<li>cached模式</li>
</ul>
<p>线程池里面的线程个数是可动态增长的，根据任务的数量动态地增加线程的数量，但是会设置一个线程数量的阈值。任务处理完成后，如果动态增长的线程空闲60s而没有其他任务待处理，那么就关闭线程，保持池中线程的最初数量。</p>
<ul>
<li>代码形式</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">setMode</span>(<span class="built_in">fixed</span>(<span class="keyword">default</span>) | cached);</span><br><span class="line">    pool.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>提交任务API</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result result = pool.<span class="built_in">submitTask</span>(concreteTask);</span><br><span class="line">result.<span class="built_in">get</span>().<span class="built_in">Cast</span>&lt;T&gt;();</span><br></pre></td></tr></table></div></figure>

        <h2 id="线程池类"   >
          <a href="#线程池类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池类"></a> 线程池类</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">/* 设置线程池的工作模式 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span></span>;</span><br><span class="line">    <span class="comment">/* 设置初始的线程数量 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInitThreadSize</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">/* 设置task队列任务数量最大阈值 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshHold)</span></span>;</span><br><span class="line">    <span class="comment">/* 启动线程池 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PoolMode m_poolMode;                <span class="comment">//当前线程池工作模式</span></span><br><span class="line">    std::vector&lt;Thread*&gt; m_threads;     <span class="comment">//线程列表</span></span><br><span class="line">    <span class="type">int</span> m_initThreadSize;               <span class="comment">//初始的线程数量</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列容器。</span></span><br><span class="line"><span class="comment">     * 特别要注意，需要用shared_ptr强引用用户传来的task，</span></span><br><span class="line"><span class="comment">     * 以保证任务对象的生命期。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Task&gt;&gt; m_taskQueue;</span><br><span class="line">    <span class="comment">/* 目前任务队列中的任务数量 */</span></span><br><span class="line">    std::atomic_int m_taskNum;</span><br><span class="line">    <span class="comment">/* 任务队列最大上限阈值 */</span></span><br><span class="line">    <span class="type">int</span> m_taskQueMaxThreshHold;</span><br><span class="line">    <span class="comment">/* 保护安全地操作任务队列 */</span></span><br><span class="line">    std::mutex m_taskQueMtx;</span><br><span class="line">    <span class="comment">/* 表示任务队列不满 */</span></span><br><span class="line">    std::condition_variable m_taskQueNotFull;</span><br><span class="line">    <span class="comment">/* 表示任务队列不空 */</span></span><br><span class="line">    std::condition_variable m_taskQueNotEmpty;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="threadpoolcpp"   >
          <a href="#threadpoolcpp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadpoolcpp"></a> threadpool.cpp</h3>
      
<ol>
<li>
<p>ThreadPool构造、析构</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线程池构造 */</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">    : <span class="built_in">m_initThreadSize</span>(<span class="number">4</span>),</span><br><span class="line">      <span class="built_in">m_taskNum</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">m_taskQueMaxThreshHold</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">      <span class="built_in">m_poolMode</span>(PoolMode::MODE_FIXED)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>设置参数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置线程池的工作模式 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_poolMode = mode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置初始的线程数量 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setInitThreadSize</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_initThreadSize = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置task队列任务数量最大阈值 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshHold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_taskQueMaxThreshHold = threshHold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>启动线程池</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 启动线程池 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>给线程池提交任务</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h2 id="thread类"   >
          <a href="#thread类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread类"></a> Thread类</h2>
      
<ul>
<li>
<p>思考：线程函数定义在哪个位置呢？</p>
<ul>
<li>
<p>如果写在Thread类中，那么定义在ThreadPool的变量则不容易被函数所访问。</p>
</li>
<li>
<p>定义全局函数呢？线程池里的变量都是私有的，也不易访问。</p>
</li>
<li>
<p>结论：OOP的手法，写在ThreadPool中。</p>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.h */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义线程函数 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="comment">/* threadpool.cpp */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义线程函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>线程对象是在线程池里构建的，线程启动执行也是在线程池里做的，那么创建thread线程对象时需要把线程函数给到thread线程对象。怎么把函数扔给对象？怎么解决这个技术问题？</p>
<ul>
<li>引入<code>&lt;functional&gt;</code>，用<code>std::bind()</code>把函数对象绑定。在线程池start时，构造thread时传入</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_initThreadSize = initThreadSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads.<span class="built_in">emplace_back</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ul>
<p>由上述Thread类构造时对函数对象的处理，可以得到Thread类的大致属性需求、构造参数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 线程函数对象类型别名 */</span></span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Thread</span>(ThreadFunc func);</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadFunc m_func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>
<p>start函数 - 启动线程，创建一个线程来执行一个线程函数</p>
<ul>
<li>需要注意：出了start函数作用域之后线程对象会析构，但是线程函数不能消失，他还要去消费任务队列上的任务。<strong>所以线程对象需要设置为分离线程，否则程序会挂掉</strong>。</li>
<li>分离的效果就是：线程对象和它所启动的线程(实质的线程)分离开了，独立存在，互不关心对方的生命期。</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">/* 启动线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(m_func)</span></span>;	<span class="comment">//线程对象t，线程函数m_func</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>简单测试，默认启动4个线程。启动后在不同的线程分别执行threadFunc函数。</p>
<ul>
<li>注意：创建的线程分离之后，执行完毕后会自动回收。但是可能存在主线程启动后看不到打印结果的情况，那是因为主线程结束地太快，导致没能看到（实际中的服务器主线程不会很快结束，而是保持）。为了看到执行结果，可以睡眠一段时间。</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid:&quot;</span> </span><br><span class="line">        &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;end threadFunc&quot;</span> </span><br><span class="line">        &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 线程池项目测试.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
</ul>

        <h2 id="智能指针解决避免手动释放"   >
          <a href="#智能指针解决避免手动释放" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#智能指针解决避免手动释放"></a> 智能指针解决避免手动释放</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_initThreadSize = initThreadSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">        m_threads.<span class="built_in">emplace_back</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>但是这样会出现编译不过的问题，为什么呢？因为报错发现<code>unique_ptr</code>的拷贝构造已经删除，这是唯一性智能指针的语义决定的。而移动构造没有删除，意味可以用右值进行资源转移，所以我们需要在<code>ptr</code>前加<code>std::move</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_threads.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br></pre></td></tr></table></div></figure>

        <h2 id="submittask"   >
          <a href="#submittask" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#submittask"></a> submitTask</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 获取锁 */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_taskQueMtx)</span></span>;</span><br><span class="line">    <span class="comment">/* 线程的通信，等待任务队列有空余 */</span></span><br><span class="line">    <span class="comment">//while(taskQue_.size() == taskQueMaxThreshHold_)&#123; notFull_.wait(); &#125;</span></span><br><span class="line">    m_taskQueNotFull.<span class="built_in">wait</span>(</span><br><span class="line">        lock,</span><br><span class="line">        [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_taskQueue.<span class="built_in">size</span>() &lt; m_taskQueMaxThreshHold;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* 如果有空余，把任务放到任务队列中 */</span></span><br><span class="line">	m_taskQueue.<span class="built_in">emplace</span>(sp);</span><br><span class="line">    ++m_taskNum;</span><br><span class="line">    <span class="comment">/* 因为新放了任务，任务队列肯定不空了，通知notEmpty_上的等待线程 */</span></span><br><span class="line">    m_taskQueNotEmpty.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="服务降级"   >
          <a href="#服务降级" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务降级"></a> 服务降级</h3>
      
<p>为了性能更加优化，我们限制用户提交任务的最长阻塞时间是<code>1s</code>，否则判断为提交任务失败，返回。称为<strong>服务降级</strong>。需要用到<code>wait</code>的两个延伸，<code>wait_for(time)</code>，<code>wait_until(endtime)</code>。返回值为bool值，<code>false</code>表示到时间后条件依然没满足。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!notFull_.<span class="built_in">wait_for</span>(</span><br><span class="line">    lock,</span><br><span class="line">    std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">    [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; (<span class="type">size_t</span>)taskQueMaxThreshHold_;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr&lt;&lt;<span class="string">&quot;task queue is full, submit out of time failed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="threadfunc"   >
          <a href="#threadfunc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadfunc"></a> ThreadFunc</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">    <span class="comment">/* 块作用域 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 先获取锁 */</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_taskQueMtx)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">/* 等待notEmpty条件 */</span></span><br><span class="line">        m_taskQueNotEmpty.<span class="built_in">wait</span>(</span><br><span class="line">            lock,</span><br><span class="line">            [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m_taskQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">/* 从任务队列中取一个任务出来 */</span></span><br><span class="line">        task = m_taskQueue.<span class="built_in">front</span>();</span><br><span class="line">        m_taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">        --m_taskNum;</span><br><span class="line">        <span class="comment">/* 如果有剩余任务，继续通知其他线程来取任务 */</span></span><br><span class="line">        <span class="keyword">if</span>(m_taskQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_taskQueNotEmpty.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 对提交任务方进行通知 */</span></span><br><span class="line">        m_taskQueNotFull.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当前线程负责执行这个任务, 没必要拥有锁, 脱离块作用域, 释放 */</span></span><br><span class="line">    <span class="keyword">if</span>(task!=<span class="literal">nullptr</span>)task-&gt;<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试1"   >
          <a href="#测试1" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试1"></a> 测试1</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">test example:</span><br><span class="line"><span class="comment">/* 以下为提交3个任务，预估结果为3个线程获取任务成功，1个没有获取到，一直阻塞 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">	pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 若4个线程，提交5个任务，则最先完成并抢到锁的线程能再次获得第5个任务 */</span></span><br><span class="line"><span class="comment">/* 若4个线程，提交10个任务，并把队列容量设为4，则可能有2个任务提交失败 */</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="线程执行的返回值"   >
          <a href="#线程执行的返回值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程执行的返回值"></a> 线程执行的返回值</h1>
      
<p>比如，计算1到30000的和。线程1计算1到10000，2计算10001到20000，3计算20001到30000。主线程给每一个线程分配计算的区间，并等待他们算完之后返回结果，合并最终的结果即可。但是，怎么能拿到线程的返回值呢？</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">    	: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin_; i&lt;=end_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>
<p>问题1：怎么设计run函数的返回值，可以表示任意的类型？</p>
</li>
<li>
<p>问题2：如何设计这里的Result机制？</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result res = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">res.<span class="built_in">get</span>();</span><br></pre></td></tr></table></div></figure>
</li>
</ul>

        <h2 id="any类型-按需返回具体类型"   >
          <a href="#any类型-按需返回具体类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#any类型-按需返回具体类型"></a> Any类型 - 按需返回具体类型</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Any</span>(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Any</span>(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这个构造函数可以让Any类型接收任意其他的数据 */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T data)</span> : base_(std::make_unique&lt;Derived&lt;T&gt;&gt;(data))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="comment">/* 这个方法能把Any对象里面存储的data数据提取出来 */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">cast_</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Derive&lt;T&gt;* pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;*&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span>(pd == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;type is unmatch!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;data_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>(T data) : <span class="built_in">data_</span>(data)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义一个基类的指针 */</span></span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    Result res = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">    <span class="type">int</span> sum = res.<span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="自实现信号量类"   >
          <a href="#自实现信号量类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自实现信号量类"></a> 自实现信号量类</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="type">int</span> limit = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">resLimit_</span>(limit)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Semaphore</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/* 获取一个信号量资源 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="comment">/* 等待信号量有资源，没有资源的话，阻塞当前线程 */</span></span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> resLimit_ &gt; <span class="number">0</span>;&#125;);</span><br><span class="line">        --resLimit_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 增加一个信号量资源 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        ++resLimit_;</span><br><span class="line">        cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> resLimit_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="result设计"   >
          <a href="#result设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#result设计"></a> Result设计</h2>
      
<p>submitTask接口返回类型需要让用户能接收到线程任务的返回值，并且要求可以是任意类型，所以改为Result。相应的，我们需要设计这样的Result类型。</p>
<ul>
<li>思考，return时用下面哪种方式？
<ul>
<li>通用的角度来说，两种方式都可以实现。</li>
<li>要执行的task从taskQue_.pop()，接着调用完毕后就会析构，即生命期只存在于threadFuc函数中，所以在submitTask函数中<strong>通过task调用得到result是失效的</strong>。即：随着task被执行完，task对象没了，依赖于task的Result对象也没了。</li>
<li>所以我们要让task对象的生命期延至和Result对等的效果。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Result <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span>;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;;</span><br><span class="line">--------------------------</span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">	<span class="keyword">if</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/*		思考，return时用下面哪种方式？	*/</span></span><br><span class="line"><span class="comment">/*      return task-&gt;getResult();	 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Result</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*	思考，return时用下面哪种方式？	*/</span></span><br><span class="line"><span class="comment">/*  return task-&gt;getResult();	 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>经过上面的讨论，Result类成员里需要绑定一个Task对象。即下面的task_。下面是Result成员和其构造。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实现接收提交到线程池的task任务执行完成后的返回值类型Result */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid = <span class="literal">true</span>);</span><br><span class="line">    ~<span class="built_in">Result</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 存储任务的返回值 */</span></span><br><span class="line">    Any any_;</span><br><span class="line">    <span class="comment">/* 线程通信信号量 */</span></span><br><span class="line">    Semaphore sem_;</span><br><span class="line">    <span class="comment">/* 指向对应获取返回值的任务对象 */</span></span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;</span><br><span class="line">    <span class="comment">/* 任务执行是否有效/成功 */</span></span><br><span class="line">    std::atomic_bool isValid_;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line"><span class="comment">//threadpool.cpp</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid)</span><br><span class="line">    : <span class="built_in">isValid_</span>(isValid), <span class="built_in">task_</span>(task)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<ul>
<li>接下来关注它的成员函数
<ul>
<li>问题1：setVal函数，获取任务执行完的返回值，记录在any成员。</li>
<li>问题2：get函数，用户调用这个方法获取task的返回值（没执行完需要阻塞）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVal</span><span class="params">(Any any)</span></span>;</span><br><span class="line">    <span class="function">Any <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Any any_;</span><br><span class="line">    Semaphore sem_;</span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;</span><br><span class="line">    std::atomic_bool isValid_;</span><br><span class="line">&#125;;</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">/* 	用户调用的 */</span></span><br><span class="line"><span class="function">Any <span class="title">Result::get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isValid_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 阻塞用户的线程直到task通知其执行完毕 */</span></span><br><span class="line">    sem_.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(any_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 谁调用？ */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Result::setVal</span><span class="params">(Any any)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 存储task的返回值 */</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;any_ = std::<span class="built_in">move</span>(any);</span><br><span class="line">    sem_.<span class="built_in">post</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>Task方法实现</li>
</ul>
<p>思想：在threadFun函数中，不仅要靠task对象Task类中的run方法执行具体哪种任务，还要把任务的返回值给到result，可以用exec来封装，exec没有多态，run有多态。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task::exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result_ != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	    result_-&gt;<span class="built_in">setVal</span>(<span class="built_in">run</span>());	<span class="comment">//如此可知，task中需要封装一个result对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>();</span><br><span class="line">    ~<span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setResult</span><span class="params">(Result *res)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*	没必要用shared智能指针，否则就会出现：Result中有shared_ptr&lt;Task&gt;，Task中有shared_ptr&lt;Result&gt;。循环引用，无法释放！*/</span></span><br><span class="line">    Result *result_;	<span class="comment">//result对象的生命周期长于task，不怕。</span></span><br><span class="line">&#125;;</span><br><span class="line">----------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task::setResult</span><span class="params">(Result *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result_ = res;</span><br><span class="line">&#125;</span><br><span class="line">Task::<span class="built_in">Task</span>()</span><br><span class="line">    : <span class="built_in">result_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;       </span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">/* 谁调用setResult？ */</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid)</span><br><span class="line">	: <span class="built_in">isValid_</span>(isValid), <span class="built_in">task_</span>(task)</span><br><span class="line">&#123;</span><br><span class="line">    task_-&gt;<span class="built_in">setResult</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试2"   >
          <a href="#测试2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试2"></a> 测试2</h2>
      
<p>Master - Slave模型，Master线程用来分解任务，然后给各个Slave线程分配任务，等待各个Slave线程执行完任务，返回结果。最后Master线程合并各个任务结果，输出。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">    	: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function">Any <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        uLong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uLong i = begin_; i &lt;= end_; ++i)</span><br><span class="line">            sum += i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> uLong = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>, <span class="number">100000000</span>));</span><br><span class="line">    Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">100000001</span>, <span class="number">200000000</span>));</span><br><span class="line">    Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>, <span class="number">300000000</span>));</span><br><span class="line">    uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    uLong sum2 = res<span class="number">2.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    uLong sum3 = res<span class="number">3.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    cout &lt;&lt; sum1 + sum2 + sum3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试结果：</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407095057418.png" alt="image-20220407095057418" /></p>

        <h1 id="cached模式线程池"   >
          <a href="#cached模式线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cached模式线程池"></a> cached模式线程池</h1>
      
<p>主要的使用点：submitTask函数中，可能需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程。</p>
<ul>
<li>需要处理的问题
<ul>
<li>问题1，用户自己如何设置线程池的工作模式</li>
<li>问题2，submitTask函数中，根据任务数量和空闲线程的数量，判断是否需要创建新的线程</li>
<li>问题3，threadFunc函数中，有可能已经创建了很多的线程，如果空闲时间超过60s，需要结束、回收。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    <span class="comment">/* 用户自己设置线程池的工作模式 */</span></span><br><span class="line">    pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">    <span class="comment">/* 开始启动线程池 */</span></span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="切换工作模式"   >
          <a href="#切换工作模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#切换工作模式"></a> 切换工作模式</h2>
      
<p>为了防止用户在线程池启动后再去切换线程池的工作模式，我们需要给线程池添加一个状态变量，以控制用户能否对线程池的工作模式进行切换。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 检查pool的运行状态 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 表示当前线程池的启动 */</span></span><br><span class="line">    std::atomic_bool isPoolRunning_;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 设置线程池的状态为运行态 */</span></span><br><span class="line">    isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ThreadPool::checkRunningState</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isPoolRunning_;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkRunningState</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    poolMode_ = mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="创建更多线程"   >
          <a href="#创建更多线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#创建更多线程"></a> 创建更多线程</h2>
      
<p>cached模式：任务处理比较紧急，场景是小而快的任务。</p>
<p>ThreadPool需要添加记录一个空闲线程数量的变量。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录空闲线程的数量 */</span></span><br><span class="line">    std::atomic_int idleThreadSize_;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 空闲线程数量需要加1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 每启动一个线程就给idleThreadSize_加1，表示多了一个空闲线程 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 空闲线程数量需要减1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*			...			*/</span></span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            notEmpty_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> taskQue_.<span class="built_in">size</span>()&gt;<span class="number">0</span>;&#125;);</span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*			...			*/</span></span><br><span class="line">    	notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task!=<span class="literal">nullptr</span>)task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">    ++idleThreadSize_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>现在来增加submitTask函数对cached模式处理的细节。有一点要注意，就是尽管任务非常多，但是我们要对线程的数量设一定的上限值。即需要给ThreadPool类增加一个线程数量阈值变量。然后为了比较线程池当前线程的数量状况，也要添加一个记录线程总数量的变量。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 设置线程池cached模式下的线程阈值 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span></span>;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 线程数量上限阈值 */</span></span><br><span class="line">    <span class="type">int</span> threadSizeThreshHold_;</span><br><span class="line">    <span class="comment">/* 记录当前线程池里面线程的总数量 */</span></span><br><span class="line">    std::atomic_int curThreadSize_;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;;</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">curThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">threadSizeThreshHold_</span>(THREAD_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 记录初始线程个数 */</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line">    <span class="comment">/* 创建线程对象 */</span></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 启动所有线程 */</span></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkRunningState</span>() || poolMode_==PoolMode::MODE_FIXED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    threadSizeThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="comment">/* 关注三个状态：</span></span><br><span class="line"><span class="comment"> * 1.线程池的工作模式是否是cached；</span></span><br><span class="line"><span class="comment"> * 2.任务数量是否已经大于空闲线程数量；</span></span><br><span class="line"><span class="comment"> * 3.线程总数量是否没有超过线程数量上限；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建新线程 */</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>));</span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();	<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="任务处理完毕回收多余线程"   >
          <a href="#任务处理完毕回收多余线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#任务处理完毕回收多余线程"></a> 任务处理完毕，回收多余线程</h2>
      
<p>超过initThreadSize_数量的线程要进行回收。</p>
<p>当前时间比上一次线程执行完毕的时间大于60s后回收。</p>
<blockquote>
<p>C11中提供了高精度时间API - high_resolution_clock().now();</p>
</blockquote>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_IDLE_TIME = <span class="number">60</span>;	<span class="comment">//单位s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 上一次线程执行完任务的时间 */</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">    	std::unique_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">			<span class="comment">/* 尝试获取任务 */</span></span><br><span class="line">            <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 每一秒钟返回一次 */</span></span><br><span class="line">                <span class="keyword">while</span>(taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 超时返回 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();<span class="comment">//返回的是time_point类型</span></span><br><span class="line">                        <span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line">                    	<span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 开始回收当前线程 */</span></span><br><span class="line">                            <span class="comment">/* 修改记录线程数量的相关变量 */</span></span><br><span class="line">                            <span class="comment">/* 把线程从线程列表容器中删除 */</span></span><br><span class="line">                            <span class="comment">/* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */</span></span><br><span class="line">                            <span class="comment">/* 我们需要有一个映射关系来记录：threadid =&gt; thread对象 =&gt; 删除 */</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*			...			*/</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task!=<span class="literal">nullptr</span>)task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">    ++idleThreadSize_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 线程执行完任务后更新lastTime */</span></span><br><span class="line">    lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象？</li>
</ul>
<p>我们需要有一个映射关系来记录：threadid - thread对象</p>
<p>所以，Thread对象需要封装一个id值</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Thread</span>(ThreadFunc func);</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 启动线程 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> generateId;</span><br><span class="line">    <span class="type">int</span> threadId_;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="type">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">	: <span class="built_in">func_</span>(func), <span class="built_in">threadId</span>(generateId_++)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread::getId</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadId_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后，最大的变化来了，把原先的线程列表的vector容器变成了unordered_map。</p>

        <h2 id="改为无序哈希表后的代码调整"   >
          <a href="#改为无序哈希表后的代码调整" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#改为无序哈希表后的代码调整"></a> 改为无序哈希表后的代码调整</h2>
      
<ul>
<li>ThreadPool</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>start</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 创建线程对象 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 启动所有线程 */</span></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>submitTask</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thead&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>threadFunc</li>
</ul>
<p>此处要给threadFunc加一个参数threadid，注意，这样的变化会影响到bind时的操作，由于threadFunc函数多了一个参数，需要在bind时给</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义线程函数，加了一个参数threadid */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 要和threadFunc函数参数一致 */</span></span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thead&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,</span><br><span class="line">                      <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();	<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_, threadId_)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">                    	<span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 开始回收当前线程 */</span></span><br><span class="line">                            <span class="comment">/* 修改记录线程数量的相关变量 */</span></span><br><span class="line">                            <span class="comment">/* 把线程从线程列表容器中删除 */</span></span><br><span class="line">                            <span class="comment">/* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */</span></span><br><span class="line">                            <span class="comment">/* 我们需要有一个映射关系来记录：threadid =&gt; thread对象 =&gt; 删除 */</span></span><br><span class="line">                            threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                            --curThreadSize;</span><br><span class="line">                            --idleThreadSize;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                                &lt;&lt; <span class="string">&quot; exit!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试3"   >
          <a href="#测试3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试3"></a> 测试3</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">		: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Any <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">        uLong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uLong i = begin_; i &lt;= end_; ++i)</span><br><span class="line">            sum += i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 在submitTask函数中 加打印线程的相关信息 */</span></span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thead&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,</span><br><span class="line">                      <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();	<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 暂时修改超时时间，方便测试观察 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_IDLE_TIME = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">                    	<span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 默认初始四线程，六任务。</span></span><br><span class="line"><span class="comment"> * 每个任务都至少消耗3秒，</span></span><br><span class="line"><span class="comment"> * 开始时会把四个线程都占住，会创建新的线程来完成后两个任务</span></span><br><span class="line"><span class="comment"> * 全部任务完成后，超过10秒后，会把多余的2个线程回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TASK_MAX_THRESHHOLD = INT32_MAX;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadPool pool;</span><br><span class="line">        pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">        Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>,<span class="number">100000000</span>));			<span class="comment">//1</span></span><br><span class="line">        Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">100000001</span>,<span class="number">200000000</span>));	<span class="comment">//2</span></span><br><span class="line">        Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));	<span class="comment">//3</span></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//5</span></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//6</span></span><br><span class="line">        uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">        uLong sum2 = res<span class="number">2.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">        uLong sum3 = res<span class="number">3.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试结果</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172417250.png" alt="image-20220407172417250" /></p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172451064.png" alt="image-20220407172451064" /></p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172642102.png" alt="image-20220407172642102" /></p>

        <h2 id="问题"   >
          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
      
<p>ThreadPool对象析构以后，怎么样把线程池相关的线程资源全部回收？</p>

        <h3 id="线程池析构工作"   >
          <a href="#线程池析构工作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池析构工作"></a> 线程池析构工作</h3>
      
<p>在析构函数中，用户线程需要等待线程池线程，这是两类不同的线程，需要通过线程间通信来达到等待完成。</p>
<p>线程间通信可以用信号量、条件变量，都可以，我们在ThreadPool类中使用一个条件变量exitCond_。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 等待线程资源全部回收 */</span></span><br><span class="line">    std::condition_variable exitCond_;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">/* 等待线程池中所有的线程返回，有两种状态：阻塞/执行中 */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="built_in">exitCond_wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>threadFunc函数</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span>(isPoolRunning_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">while</span>(taskQue_.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 若为cached模式，且这个线程一直取不到任务时，将撤销这个线程 */</span></span><br><span class="line">                <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(std::cvstatus::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">new</span>();</span><br><span class="line">                        <span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line">                        <span class="comment">/* 满足条件则撤销线程：60s 且 目前线程总数大于初始线程数 */</span></span><br><span class="line">                        <span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                            --curThreadSize_;</span><br><span class="line">                            --idleThreadSize_;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;threadid&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                                &lt;&lt; <span class="string">&quot; exit!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/* 若为“固定”模式，等待有任务后被唤醒 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 如果被唤醒时，发现线程池要结束，回收线程资源 */</span></span><br><span class="line">                <span class="keyword">if</span>(!isPoolRunning_)</span><br><span class="line">                &#123;</span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;threadid&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                        &lt;&lt; <span class="string">&quot; exit!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    exitCond_.<span class="built_in">notify_all</span>();	<span class="comment">//通知析构函数里用到的exitCond_</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* taskQue_.size() &gt; 0的情况 */</span></span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">            taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line">            <span class="comment">/* 如果队列中还有任务，通知其他线程来取任务 */</span></span><br><span class="line">            <span class="keyword">if</span>(taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>)notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            <span class="comment">/* 通知 往队列里放任务 */</span></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;<span class="comment">//end of &#123;&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(task!=<span class="literal">nullptr</span>)task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        <span class="comment">/* 任务执行完了，状态空闲了，重新计算lastTime */</span></span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">    <span class="comment">/* isPoolRunning_ == false的情况，撤销线程 */</span></span><br><span class="line">    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;threadid&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; exit!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    exitCond_.<span class="built_in">notify_all</span>();	<span class="comment">//通知析构函数里用到的exitCond_</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试结果</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407204205403.png" alt="image-20220407204205403" /></p>

        <h1 id="问题描述"   >
          <a href="#问题描述" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h1>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">项目推进时遇到了什么问题？</span><br><span class="line">实现核心功能时的问题：如何通用地获取提交任务后的返回值，即Any，Result的设计。</span><br><span class="line">设计线程池资源回收的，是以...的方式实现的，测试时，有时会出现死锁的现象</span><br><span class="line">调试方法：</span><br><span class="line">gdb调试，attach到正在死锁的进程，把线程栈打印出来，在哪一个函数的哪一句话不动了。</span><br><span class="line">问题要素：</span><br><span class="line">1、线程池要结束，要释放整个池子的资源了。</span><br><span class="line">2、线程池的成员isPoolRunning_状态置为了false。</span><br><span class="line">以上两个要素</span><br><span class="line">1，不受线程池内的线程目前的状态而影响，线程的状态：在等待任务、在执行任务。</span><br><span class="line">2，isPoolRunning_必将影响线程的代码路径。</span><br><span class="line"></span><br><span class="line">isPoolRunning_在线程池start时置为true。</span><br><span class="line">我们设计的ThreadPool不用考虑成员的析构问题，最主要的两个成员容器：</span><br><span class="line">	1、无序map中的线程对象是unique_ptr管理的。</span><br><span class="line">	2、queue中的任务队列是shared_ptr管理的。</span><br><span class="line">	3、其余的变量都是非指针变量。</span><br><span class="line">ThreadPool析构时仅仅只是把isPoolRunning_置false就可以了吗？</span><br><span class="line">当然不可以。线程池要等待线程池里面所有的线程返回。目前线程可能在threadFunc函数中阻塞在notEmpty上，另一种是正在执行任务中。</span><br><span class="line">此时就需要不同线程的通信。即用户线程和线程池中的线程之间进行通信。</span><br><span class="line">用信号量、条件变量都可以。</span><br><span class="line">我们用条件变量。</span><br><span class="line">在ThreadPool中定义一个成员，std::condition_variable exitCond_;等待线程资源全部回收</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="comment">/* 表明：要等待到threads_.size()等于0 */</span></span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在exitCond_.wait之前，有的线程在notEmpty_变量上等待任务到来，需要唤醒所有的。</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* 我们暂且在这个位置 唤醒notEmpty_上的所有线程 */</span>	<span class="comment">//实际上，是留了一个坑</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="comment">/* 表明：要等待到threads_.size()等于0 */</span></span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能会产生死锁的情况：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>,<span class="number">10000000</span>));</span><br><span class="line">    uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    cout &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main over!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment"> * tid: 9624尝试获取任务..</span></span><br><span class="line"><span class="comment"> * tid: 9624获取任务成功...</span></span><br><span class="line"><span class="comment"> * tid:tid: 1664尝试获取任务...</span></span><br><span class="line"><span class="comment"> * 9624begin!</span></span><br><span class="line"><span class="comment"> * tid: 15228尝试获取任务...</span></span><br><span class="line"><span class="comment"> * tid:6796尝试获取任务...</span></span><br><span class="line"><span class="comment"> * tid:9624end!</span></span><br><span class="line"><span class="comment"> * tid:9624尝试获取任务...5000000050000000</span></span><br><span class="line"><span class="comment"> * main over!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * threadid:6796 exit!</span></span><br><span class="line"><span class="comment"> * threadid:s1664 exit!</span></span><br><span class="line"><span class="comment"> * threadid:15228 exit!</span></span><br><span class="line"><span class="comment"> *		//发现，抢到任务的线程回不来了。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="代码分析"   >
          <a href="#代码分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main函数所在的主线程，即用户创建线程池的线程 */</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 线程池中的每个线程的线程函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lastTime = ...;</span><br><span class="line">    <span class="keyword">while</span>(isPoolRunning_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;		<span class="comment">//抢锁动作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务... &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">while</span>(taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* timeout==wait_for的返回值 意味着等待超时了 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//回收长时间空闲的线程</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 否则，说明被唤醒了，有任务了，且抢到锁了，继续往下 */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/* 若不是cached模式，则按部就班老实等待 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">if</span>(!isPoolRunning_)</span><br><span class="line">            &#123;</span><br><span class="line">                threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                    &lt;&lt; <span class="string">&quot; exit:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">/* 每一个线程删除后，都通知exitCond_一下，唤醒用户主线程 */</span></span><br><span class="line">                exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 若被唤醒了，有任务了，且抢到锁了，而且确认了isPoolRunning，则可以取得任务 */</span></span><br><span class="line">        --idleThreadSize_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>第一种情况：线程是固定模式，任务队列空时，等待在notEmpty_上。这种情况我们不怕，因为线程池析构函数已经写了notEmpty_.notify_all();</p>
<p>第二种情况：task-&gt;exec()中，即线程执行任务中。这种也没事，线程执行完任务再次进入while循环判断时发现isPoolRunning_为false了，则删除线程，退出。</p>
<p>第三种情况才是关键，线程task-&gt;exec()<strong>执行完后进入了while(isPoolRunning_)循环，到了获取锁语句之前的位置。这时，线程池关闭了，也就是说在Running状态切换为false</strong>！现在，线程池、子线程的下一个动作都是对taskQueMtx_进行加锁！而最关键的，<strong>如果能够“阴差阳错地”进入第二个while循环，那么就会在notEmpty_上等死</strong>，因为此时线程池在语义上是已经关闭了，没人再去唤醒它。</p>
<p>第三种情况中的第一种情况：线程池抢到锁，又在exitCond_上wait阻塞，而子线程虽然能抢到锁，但是会死在notEmpty_上。</p>
<p>第三种情况中的第二种情况：子线程抢到锁，往下执行，则没有任务时，在notEmpty_上等待会放弃锁，阻塞自己，线程池之后会抢到锁，等待线程结束。<strong>这时没有人去唤醒notEmpty_上的子线程了。死锁。这是问题之关键</strong>。</p>
<p>那么，第三种情况怎么解决死锁问题呢？</p>
<p>我们注意到，第三种情况中第一种情况的问题是因为线程池exitCond_.wait()后，进入了第一个while后争抢lock的线程可能拿到锁后，顺理成章进入第二个while中，若恰逢没有任务，则死在了notEmpty_上。所以为了防止错误的时机进入到第二个while循环中，在条件处首先再判断一次isPoolRunning_。</p>

        <h3 id="31的解决方案锁双重判断"   >
          <a href="#31的解决方案锁双重判断" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#31的解决方案锁双重判断"></a> 3.1的解决方案：锁+双重判断</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lastTime = ...;</span><br><span class="line">    <span class="keyword">while</span>(isPoolRunning_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; ... &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">while</span>(isPoolRunning_ &amp;&amp; taskQue_.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//退出while的两种情况：1.!Running, 2.Running &amp;&amp; taskQue_.size()!=0</span></span><br><span class="line">            <span class="keyword">if</span>(!isPoolRunning_)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取任务成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        lastTime = ...;</span><br><span class="line">    &#125;</span><br><span class="line">    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如此一来，线程池先抢到锁，再在exitCond_上wait阻塞释放锁后，子线程得到锁向下走到了第二个while语句，由于再次判断isPoolRunning_，这时发现改变为false了，就不会走到notEmpty_.wait()了。灰溜溜去做删除动作了。</p>

        <h3 id="32的解决方案调整加锁位置"   >
          <a href="#32的解决方案调整加锁位置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#32的解决方案调整加锁位置"></a> 3.2的解决方案：调整加锁位置</h3>
      
<p>虽然3.1解决了isPoolRunning状态脏读这个漏洞问题，但是依旧不能解决“子线程先抢到锁”从而在notEmpty_上等待这种情况发生。即使子线程释放了锁，但是没有人再去唤醒notEmpty_，因为原来的语序是先唤醒，再抢锁。所以我们要让用户线程的加锁、唤醒放在子线程wait之后，<strong>要让子线程wait释放了锁之后，才让用户线程唤醒notEmpty_</strong>！于是：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>调换了一下第二、第三句，即子线程先抢到锁后wait在notEmpty_上后释放锁，用户线程再抢到锁之后才去notify_all()它，那么阻塞的子线程被唤醒了，往下执行，发现isPoolRunning_变为false了，灰溜溜去做删除动作了。完美解决问题。</p>

        <h1 id="编译为动态库"   >
          <a href="#编译为动态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#编译为动态库"></a> 编译为动态库</h1>
      

        <h2 id="直接在命令行使用g编译"   >
          <a href="#直接在命令行使用g编译" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#直接在命令行使用g编译"></a> 直接在命令行使用<code>g++</code>编译</h2>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o libxcg-threadpool.so -fPIC -shared [源文件如: threadpool.cpp] -std=c++17</span><br></pre></td></tr></table></div></figure>

        <h2 id="用cmake构建编译"   >
          <a href="#用cmake构建编译" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#用cmake构建编译"></a> 用cmake构建编译</h2>
      

        <h3 id="根目录"   >
          <a href="#根目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#根目录"></a> 根目录</h3>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(xcg-threadpool)</span><br><span class="line"><span class="comment">#配置编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -g)</span><br><span class="line"><span class="comment">#配置最终的库文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#配置头文件的搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#加载子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></div></figure>

        <h3 id="src目录"   >
          <a href="#src目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#src目录"></a> src目录</h3>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义了SRC_LIST变量，包含了该目录下所有的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment">#指定生成可执行文件</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment">#指定可执行文件链接时 需要依赖的库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(xcg-threadpool pthread)</span><br></pre></td></tr></table></div></figure>

        <h1 id="使用动态库编译可执行文件"   >
          <a href="#使用动态库编译可执行文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用动态库编译可执行文件"></a> 使用动态库编译可执行文件</h1>
      

        <h2 id="直接使用g编译可执行文件"   >
          <a href="#直接使用g编译可执行文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#直接使用g编译可执行文件"></a> 直接使用<code>g++</code>编译可执行文件</h2>
      
<p>首先需要把动态库<code>libxcg-threadpool.so</code>移动到<code>/usr/lib</code>或<code>/usr/local/lib</code>；把动态库对应的头文件<code>threadpool.h</code>移动到<code>/usr/include</code>或<code>/usr/local/include</code>下。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp -std=c++17 -lxcg-threadpool -lpthread</span><br></pre></td></tr></table></div></figure>

        <h2 id="使用cmake构建编译可执行文件"   >
          <a href="#使用cmake构建编译可执行文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用cmake构建编译可执行文件"></a> 使用cmake构建编译可执行文件</h2>
      
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://xing-cg.github.io">Mr.Can</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE_%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%BA%93/">https://xing-cg.github.io/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE_%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A1%86%E6%9E%B6%E5%BA%93/</a></span></div></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/%E9%A1%B9%E7%9B%AE/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">SGI STL和Nginx内存池剖析</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/%E9%A1%B9%E7%9B%AE/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B/"><span class="paginator-prev__text">半同步半异步线程池模型</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-number">1.</span> <span class="toc-text">
           内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">
           知识储备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">2.1.</span> <span class="toc-text">
           并发和并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%AF%86%E9%9B%86%E5%9E%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">
           两种密集型程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">2.3.</span> <span class="toc-text">
           线程的代价</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.</span> <span class="toc-text">
           线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">3.1.</span> <span class="toc-text">
           线程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">
           互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">
           atomic原子类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.2.</span> <span class="toc-text">
           线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">
           条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">
           信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.3.</span> <span class="toc-text">
           区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">
           线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">
           项目介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">
           使用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.2.</span> <span class="toc-text">
           线程池的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">4.2.1.</span> <span class="toc-text">
           类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0-task%E8%AE%BE%E8%AE%A1-%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81%E6%80%9D%E6%83%B3"><span class="toc-number">4.2.2.</span> <span class="toc-text">
           通用化的实现 - Task设计 - 继承多态思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BF%9D%E8%AF%81-mtxcv"><span class="toc-number">4.2.3.</span> <span class="toc-text">
           线程通信的保证 - mtx+cv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">
           线程池的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">
           线程池类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolcpp"><span class="toc-number">4.4.1.</span> <span class="toc-text">
           threadpool.cpp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">
           Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E9%81%BF%E5%85%8D%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE"><span class="toc-number">4.6.</span> <span class="toc-text">
           智能指针解决避免手动释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#submittask"><span class="toc-number">4.7.</span> <span class="toc-text">
           submitTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">4.7.1.</span> <span class="toc-text">
           服务降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadfunc"><span class="toc-number">4.8.</span> <span class="toc-text">
           ThreadFunc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%951"><span class="toc-number">4.9.</span> <span class="toc-text">
           测试1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">
           线程执行的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#any%E7%B1%BB%E5%9E%8B-%E6%8C%89%E9%9C%80%E8%BF%94%E5%9B%9E%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">
           Any类型 - 按需返回具体类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">
           自实现信号量类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#result%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.3.</span> <span class="toc-text">
           Result设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%952"><span class="toc-number">5.4.</span> <span class="toc-text">
           测试2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cached%E6%A8%A1%E5%BC%8F%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">
           cached模式线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">
           切换工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9B%B4%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">
           创建更多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%AE%8C%E6%AF%95%E5%9B%9E%E6%94%B6%E5%A4%9A%E4%BD%99%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">
           任务处理完毕，回收多余线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E4%B8%BA%E6%97%A0%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B0%83%E6%95%B4"><span class="toc-number">6.4.</span> <span class="toc-text">
           改为无序哈希表后的代码调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%953"><span class="toc-number">6.5.</span> <span class="toc-text">
           测试3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">6.6.</span> <span class="toc-text">
           问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%90%E6%9E%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.6.1.</span> <span class="toc-text">
           线程池析构工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">7.</span> <span class="toc-text">
           问题描述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.1.</span> <span class="toc-text">
           代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%94%81%E5%8F%8C%E9%87%8D%E5%88%A4%E6%96%AD"><span class="toc-number">7.1.1.</span> <span class="toc-text">
           3.1的解决方案：锁+双重判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%B0%83%E6%95%B4%E5%8A%A0%E9%94%81%E4%BD%8D%E7%BD%AE"><span class="toc-number">7.1.2.</span> <span class="toc-text">
           3.2的解决方案：调整加锁位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%BA%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">
           编译为动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8g%E7%BC%96%E8%AF%91"><span class="toc-number">8.1.</span> <span class="toc-text">
           直接在命令行使用g++编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8cmake%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91"><span class="toc-number">8.2.</span> <span class="toc-text">
           用cmake构建编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">
           根目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#src%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">
           src目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">
           使用动态库编译可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8g%E7%BC%96%E8%AF%91%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.</span> <span class="toc-text">
           直接使用g++编译可执行文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cmake%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">9.2.</span> <span class="toc-text">
           使用cmake构建编译可执行文件</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">281</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">54</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>