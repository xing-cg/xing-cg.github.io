<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="二进制转化为十进制        https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42857472&#x2F;article&#x2F;details&#x2F;103966229                      除10取余法        设计程序时候的二进制转化为十进制的算法 二进制转化为十进制（除10取余法） 除10取余法中，对于二进制转化为10进制来讲要除于">
<meta property="og:type" content="article">
<meta property="og:title" content="微机原理">
<meta property="og:url" content="https://xing-cg.github.io/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:description" content="二进制转化为十进制        https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42857472&#x2F;article&#x2F;details&#x2F;103966229                      除10取余法        设计程序时候的二进制转化为十进制的算法 二进制转化为十进制（除10取余法） 除10取余法中，对于二进制转化为10进制来讲要除于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210725001626129.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726185205000.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726144858440.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726150833012.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726151453188.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728155350067.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728160206056.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728161510404.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728161729544.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728162021258.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728172308349.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729135603135.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729142813193.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729143703028.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729144042088.png">
<meta property="og:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729145047000.png">
<meta property="article:published_time" content="2021-07-25T00:00:00.000Z">
<meta property="article:modified_time" content="2025-09-17T10:41:03.812Z">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xing-cg.github.io/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210725001626129.png"><title>微机原理 | 罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">微机原理</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-07-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-17</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/" data-flag-title="微机原理"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body">
        <h1 id="二进制转化为十进制"   >
          <a href="#二进制转化为十进制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二进制转化为十进制"></a> 二进制转化为十进制</h1>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42857472/article/details/103966229" >https://blog.csdn.net/weixin_42857472/article/details/103966229</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="除10取余法"   >
          <a href="#除10取余法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#除10取余法"></a> 除10取余法</h2>
      
<p>设计程序时候的二进制转化为十进制的算法<br />
二进制转化为十进制（除10取余法）</p>
<p>除10取余法中，对于二进制转化为10进制来讲要除于1010，就是把10转化为二进制数，再用二进制数除于1010</p>
<p>例如：二进制11101除于1010，余数1001，转化为十进制数为9，这个是相当于十进制数的个位，再用中间商0010再除于1010，余数为0010，转化为十进制数为2，相当于十进制数的十位。</p>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210725001626129.png" alt="image-20210725001626129" /></p>

        <h2 id="比较法"   >
          <a href="#比较法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#比较法"></a> 比较法</h2>
      
<p>假如一个数393<br />
最高位为百位，所以让393和100比较<br />
如果393&gt;=100<br />
则393减去100，然后统计百位的数＋1，然后用结果差继续和100比较，也就是293和100比较，仍然大于，所以293再减去100，统计一百的数再+1，直到不大于一百了，说明这个数没有百位只有十位和个位了，所以和10比较，类似的减去10，然后统计十位的数+1，再继续比较，知道不大于十，那么剩下的就是个位的数了。</p>
<p>二进制转化为十进制的话比较的对象100就要化成二进制，即1100100<br />
十的二进制就是1010。</p>
<p>比如(11101)2–&gt;(29)10：11101&gt;1010，十位+1；11101-1010=10011&gt;1010，十位+1；10011-1010=1001&lt;1010，十位结束，(1001)2=(9)10。则结果为(29)10。</p>

        <h1 id="8位寄存器"   >
          <a href="#8位寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#8位寄存器"></a> 8位寄存器</h1>
      
<p>以8086为例，虽然8086是16位处理器，但也可以以8位方式存储数据到寄存器中。</p>
<p>8位寄存器有：AH、AL。H代表高八位，L代表低八位，AH与AL一起组成AX寄存器即16位寄存器。相应地，BH、BL；CH、CL；DH、DL，也是8位寄存器。BX、CX、DX是16位寄存器。</p>

        <h1 id="二进制数的运算"   >
          <a href="#二进制数的运算" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二进制数的运算"></a> 二进制数的运算</h1>
      

        <h2 id="算术运算-"   >
          <a href="#算术运算-" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#算术运算-"></a> 算术运算+、-、*、/</h2>
      
<p>比如97+89</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">AL</span>,<span class="number">97</span>	<span class="comment">;汇编后:B0 61	;B0h就表示“把一个字节数传送给AL寄存器中”的机器源代码，61h代表97的十六进制。</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">AL</span>,<span class="number">89</span>	<span class="comment">;(AL)=BAh	;带括号就表示括号中地址的内容，此处表示AL寄存器的内容</span></span><br></pre></td></tr></table></div></figure>
<p>mov AL,97 &lt;—&gt; B0 61    ;B0h就表示“把一个字节数传送给AL寄存器中”的机器源代码，61h代表97的十六进制。</p>

        <h1 id="处理器状态字寄存器psw"   >
          <a href="#处理器状态字寄存器psw" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#处理器状态字寄存器psw"></a> 处理器状态字寄存器PSW</h1>
      
<p>也称为标志寄存器，主要用于CPU运算后根据结果设置各个标志，一个标志一个状态，一个状态用一个bit位表示。</p>

        <h1 id="补码"   >
          <a href="#补码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#补码"></a> 补码</h1>
      
<p>补码的范围有一个疑惑点。假如一个8位补码，可以表示的范围是-128~+127，如果只是按照老师上课讲的“取反加一法”来看，就会不清楚-128这个数是怎么来的。因为带符号位（带符号位这种说法是有误的，下面会提到）的8位二进制码的绝对值最大是127。</p>
<p>这时，我们要深刻地纠正我们对补码概念的误区。</p>
<p>补码的范围<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/20458542/answer/40759880" >https://www.zhihu.com/question/20458542/answer/40759880</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
补码的定义<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/xiang_shao344/article/details/118490004" >https://blog.csdn.net/xiang_shao344/article/details/118490004</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>第一步，就像练北冥神功要先散功一样，先把你心中对原码，反码，补码的一套认识全部忘掉。</p>
<p>第二步，正式开讲</p>
<p>首先灌输一个新的概念叫，<strong>模</strong><br />
什么是“模”，想象日常使用的钟表，它可以显示0～12点的时间，假设现在是2点钟，请用手动拨动时针的方式将时间减4小时，你会怎么做？<br />
有两种方式：</p>
<ol>
<li>逆时针将时针拨4小时</li>
<li>顺时针将时针拨8（12-4）小时</li>
</ol>
<p>这里要讲的是第二种方式，为什么顺时针拨12-4也可以达到和正常思维的第一种方式一样的位置。<br />
12就是模。<br />
同样的，如果是十进制的两位数，80-10 和 80＋90在不考虑百位数的基础上都是70。这里的90就是100-10得来的，这种情况下100就是模<br />
模就好比是一个极限，在它的范围内，两个相加等于模的数互为补数，还是举100的例子<br />
90和10， 55和45，68和32，互为补数<br />
在模的范围内做减法，可以将“X－Y”的减法变更为“X＋Y的补数“的加法，当然前提是不考虑百位数。</p>
<p><strong>思考题</strong>，<em>上面举的例子是大数减小数，那么如果是小数减大数会怎么样呢？</em></p>
<p>如果是10-80，结果应该是－70，但如果按照10+（100-80），结果是30。<br />
而很明显－70和30不是一回事，这里也没有百位数的问题，这种情况应该怎么破？<br />
当初的那些先贤们想出来的办法很简单，就是把这两个数直接划上等号，正好顺便解决了负数的表达方式。再来仔细看看这两个数的关系：－70绝对值的补数就正好是30<br />
所以在计算机中，<strong>负数的表达方式就是它绝对值的补数</strong><br />
但是问题又来了，看起来这个解决方式很完美了，但别忘了，30他已经代表了正数的30了，现在又要用来代表负数的－70，谁知道它出现的时候到底是代表哪个数？<br />
为了解决这个问题，需要给这套规则划定一个范围，原来是0～99的正数，现在既然要用部分正数来代替负数了，那就要规定一个范围来使得一个数只代表一个含义，正好一人一半，0～49这个区间就代表正数，50～99的区间就用来代表各自补数的负值，例：98就代表－2</p>
<p>第三步，现在回到二进制的计算机世界</p>
<p>8位二进制数一共可以表示2的8次方，256个数，即0～255 （别忘了0也要占一位的），他们的极限就是256，即256是8位二进制数的模 ，应该不难理解吧，同上十进制的两位数0～99的模是100。<br />
还是用二进制来说明清楚，8位二进制能表示的数的极限是<br />
1 1 1 1 1 1 1 1， 就是255，在这基础上加0 0 0 0 0 0 0 1，出现了进一位 即 1 0 0 0 0 0 0 0 0<br />
这个1 0 0 0 0 0 0 0 0就是8位二进制数的模，256</p>
<p>同样按照第二步讲的逻辑，一半的数0～127，代表其正数本身，另一半的数 128～255，代表其补数的负值，即“－1～－128”的区间。<br />
而 “X－Y”的减法 就用 “X＋Y的补数” 的加法来表示，完美！ 唯一需要注意的事情是任何计算的输入值和输出结果值都需要严格遵守－128～127的范围，一旦溢出就会报错。<br />
这也就是我们在编程里强调的为什么 byte＋byte还得是byte，int＋int还得是int，数据溢出问题也是每一个程序员都需要注意的问题。</p>
<p>这样一说是不是可以理解－128的补码是怎么来的了吧？ 他就是256 - |-128|＝128<br />
二进制的128是不是就是1 0 0 0 0 0 0 0 ？</p>
<p>最终问题，那书和老师为什么要用原码，反码来讲补码 ？</p>
<p>空穴来风，未必无因<br />
那是因为计算机就是这样求负数的补码的，我们在键盘上敲一个负数的时候，计算机要把它用补码的形式存储下来，还记得上面我们讲的补码是怎么来的吗？<br />
模－绝对值，这是不是个减法公式？但计算机没有减法逻辑，我们费了那么大的劲搞了一套补码的规则就是为了用加法来替代减法，但为了实现这么套规则，却跨不过一个坎，就是把负数计算成补码仍然是需要减法逻辑的。怎么办呢，那些伟大的先贤们 （膜拜）就想出了这么个办法：<br />
首位不变，其余位取反后，再加一</p>
<p>问题：上面说到了，负数计算成补码需要取反加1，但-128在8位数中，没有其原码表示形式，如果要人工手工计算，将-128先看做是9位带符号数，再转换为补码：1 1000 0000首位不变，其余取反加1会变成1 1000 0000，进位溢出舍去，即为1000 0000。</p>
<p>下面是吐槽</p>
<p>不知道是哪个书呆子教书，照搬了机器的逻辑，把取反加一的方法当做补码的计算逻辑就这么教下来了。搞笑的是，还保留了补码这个名字，照理说这种教法应该叫 取反加一码 更合理，你还补什么啊？<br />
不仅如此，还搞出了个首位符号位的说法，弄出了个正0负0，还用负0来充当－128，真是不把人弄疯不罢休啊！！</p>

        <h1 id="寄存器"   >
          <a href="#寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h1>
      

        <h2 id="通用寄存器"   >
          <a href="#通用寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通用寄存器"></a> 通用寄存器</h2>
      

        <h3 id="数据寄存器"   >
          <a href="#数据寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据寄存器"></a> 数据寄存器</h3>
      

        <h4 id="ax"   >
          <a href="#ax" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ax"></a> AX</h4>
      
<p>累加</p>

        <h4 id="bx"   >
          <a href="#bx" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#bx"></a> BX</h4>
      
<p>基址寄存器</p>

        <h4 id="cx"   >
          <a href="#cx" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cx"></a> CX</h4>
      
<p>计数器</p>

        <h4 id="dx"   >
          <a href="#dx" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#dx"></a> DX</h4>
      
<p>数据寄存器。在I/O端口的IN/OUT操作中充当I/O地址寄存器。</p>

        <h3 id="地址指针与变址寄存器"   >
          <a href="#地址指针与变址寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#地址指针与变址寄存器"></a> 地址指针与变址寄存器</h3>
      

        <h4 id="地址指针寄存器"   >
          <a href="#地址指针寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#地址指针寄存器"></a> 地址指针寄存器</h4>
      

        <h5 id="sp"   >
          <a href="#sp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sp"></a> SP</h5>
      
<p>堆栈指针寄存器–用来指示PUSH/POP堆栈操作时所操作单元的段内16位地址的寄存器。</p>

        <h5 id="bp"   >
          <a href="#bp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#bp"></a> BP</h5>
      
<p>地址指针寄存器–作用和BX基址寄存器是一样的，都可以存放16位段内偏移地址，但是是有区别的，存放16位段内偏移地址不在同一个逻辑段，CPU默认BX在DS数据段，BP在SS堆栈段。CPU默认BP指向的是SS段的地址。<br />
当然，想要BP指向数据段也可以，必须在汇编语句中写明前缀，称之为<strong>段超越前缀</strong>，如：</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">56H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">BP</span>,<span class="number">0003H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DS</span>:[<span class="built_in">BP</span>],<span class="built_in">AL</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="变址寄存器"   >
          <a href="#变址寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#变址寄存器"></a> 变址寄存器</h4>
      

        <h5 id="si"   >
          <a href="#si" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#si"></a> SI</h5>
      
<p>源变址寄存器</p>

        <h5 id="di"   >
          <a href="#di" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#di"></a> DI</h5>
      
<p>目的变址寄存器</p>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
      
<p>用BX/SI/DI外加中括号即间接找到的地址都默认在DS段内。只用BP中括号间接找到的地址默认在SS段内。</p>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726185205000.png" alt="image-20210726185205000" /></p>

        <h2 id="段寄存器"   >
          <a href="#段寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#段寄存器"></a> 段寄存器</h2>
      
<p>分别放的是各自逻辑段的段地址</p>

        <h3 id="cs"   >
          <a href="#cs" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cs"></a> CS</h3>
      
<p>代码段寄存器。CS的值指明的是，程序代码所在的那个逻辑段的段地址。</p>
<p>CS初始化的值用户不可设置，由操作系统决定。</p>

        <h3 id="ds"   >
          <a href="#ds" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ds"></a> DS</h3>
      
<p>数据段寄存器</p>

        <h3 id="es"   >
          <a href="#es" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#es"></a> ES</h3>
      
<p>附加数据段寄存器</p>

        <h3 id="ss"   >
          <a href="#ss" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ss"></a> SS</h3>
      
<p>堆栈段寄存器</p>

        <h2 id="控制寄存器"   >
          <a href="#控制寄存器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#控制寄存器"></a> 控制寄存器</h2>
      

        <h3 id="ip"   >
          <a href="#ip" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ip"></a> IP</h3>
      
<p>指令指针寄存器。等效于一般处理器中程序计数器PC的作用。即用于CPU取指令时需要用到的偏移地址寄存器。与CS（代码段）不可分家，CS:IP。</p>

        <h3 id="psw"   >
          <a href="#psw" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#psw"></a> PSW</h3>
      
<p>处理器状态字寄存器。16位寄存器，但有用的只有9位。</p>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726144858440.png" alt="image-20210726144858440" /></p>
<p>9位分为两类标志。</p>

        <h4 id="状态标志6个"   >
          <a href="#状态标志6个" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#状态标志6个"></a> 状态标志（6个）</h4>
      
<p>ZF、CF、PF、OF、SF、AF。反映的是ALU运算后结果的状态。</p>
<p>只有运算指令执行后才会影响这些状态值的改变。</p>

        <h4 id="控制标志3个"   >
          <a href="#控制标志3个" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#控制标志3个"></a> 控制标志（3个）</h4>
      
<p>IF、PF、TF。用来控制CPU的运行状态的。</p>

        <h5 id="df"   >
          <a href="#df" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#df"></a> DF</h5>
      
<p>方向控制标志。用于控制字符串操作中SI和DI变址的方向。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLD</span>	<span class="comment">;DF=0;控制SI/DI加1或2</span></span><br><span class="line"><span class="keyword">STD</span>	<span class="comment">;DF=1;控制SI/DI减1或2</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726150833012.png" alt="image-20210726150833012" /></p>

        <h5 id="if"   >
          <a href="#if" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#if"></a> IF</h5>
      
<p>中断允许标志。</p>
<p>执行用户程序期间，某个特殊事件发生，让CPU暂时停止正在执行的程序，转去为该事件服务，即去执行中断服务子程序。服务完成后，CPU尚可返回到刚才中止的位置继续执行。</p>
<p>CLI会置0，STL会置1。</p>
<p>如果IF为0，则会屏蔽外部中断请求（8086的18脚INTR输入）。但CPU芯片内部中断不可屏蔽。</p>

        <h5 id="tf"   >
          <a href="#tf" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tf"></a> TF</h5>
      
<p>陷阱（单步）标志。Debug专用。</p>
<p>没有清零置一的指令。那该如何设计程序使TF置1？</p>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726151453188.png" alt="image-20210726151453188" /></p>
<p>以上程序：先PUSHF（F即PSW），再POP给AX赋值；再OR把AX中第九位置1；将AX压栈，在POPF给PSW赋值。</p>
<p>TF在PSW寄存器的第九位（如果从0开始，是第8位），我们知道，OR语句可以让数据置1，则让PSW或上0000 0001 0000 0000即可使TF置1。</p>
<p>如果TF标志为1，则程序将进行单步操作。常用于Debug调试。</p>

        <h1 id="8086存储器和io组织"   >
          <a href="#8086存储器和io组织" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#8086存储器和io组织"></a> 8086存储器和I/O组织</h1>
      

        <h2 id="存储器地址空间与数据存放格式"   >
          <a href="#存储器地址空间与数据存放格式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#存储器地址空间与数据存放格式"></a> 存储器地址空间与数据存放格式</h2>
      

        <h3 id="地址空间"   >
          <a href="#地址空间" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#地址空间"></a> 地址空间</h3>
      
<p>A_19~A_16/A_15~A_10/A_9~A_0：均为外部存储器编址。所以能寻址的空间为2^20字节即1MB。</p>
<p>低16位给外部I/O端口编址。I/O地址空间为2^16字节=64KB。</p>
<p>在IBM PC机中只用了低10位给I/O分配地址，地址空间为1KB。前512个I/O地址即000H~1FFH给主板上的I/O分配地址；后512个I/O地址即200H~3FFH给插件版上的I/O分配地址。</p>

        <h3 id="数据存放格式"   >
          <a href="#数据存放格式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据存放格式"></a> 数据存放格式</h3>
      
<p>字节型、字型、双字型。</p>

        <h4 id="字节型数据"   >
          <a href="#字节型数据" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#字节型数据"></a> 字节型数据</h4>
      
<p>字节型数据定义伪指令：DB（Data Byte）</p>
<p>字型数据定义伪指令：DW（Data Word）</p>
<p>双字型数据定义伪指令：DD（Data Double）</p>

        <h2 id="存储器的分段与物理地址的形成"   >
          <a href="#存储器的分段与物理地址的形成" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#存储器的分段与物理地址的形成"></a> 存储器的分段与物理地址的形成</h2>
      

        <h3 id="分段"   >
          <a href="#分段" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分段"></a> 分段</h3>
      

        <h4 id="1-为什么分段"   >
          <a href="#1-为什么分段" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1-为什么分段"></a> 1、为什么分段？</h4>
      
<p>地址线有20根，而寄存器只有16位，无法直接管理2<sup>20位空间。我们可以通过给内存分段使16位寄存器有效管理若干段（最少2</sup>4=16段）的每个逻辑段的2^16位信息。</p>

        <h4 id="2-怎么分"   >
          <a href="#2-怎么分" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2-怎么分"></a> 2、怎么分？</h4>
      
<p>根据需求进行分段，每段最大2^16=64KB。每个逻辑段的起始地址必须能被16整除。</p>

        <h3 id="已知某存储器单元的逻辑地址求物理地址"   >
          <a href="#已知某存储器单元的逻辑地址求物理地址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#已知某存储器单元的逻辑地址求物理地址"></a> 已知某存储器单元的逻辑地址，求物理地址</h3>
      
<p>PA（Physical Address）=段地址*10H + 段内偏移地址（也称段内有效地址EA(Effective Address)）</p>
<p>段地址*10H 就相当于左移一位。</p>
<p>例：逻辑地址0001H: 0010H，PA=0001H*10H + 0010H=00010H+0010H=00020H</p>

        <h1 id="8086cpu的指令系统"   >
          <a href="#8086cpu的指令系统" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#8086cpu的指令系统"></a> 8086CPU的指令系统</h1>
      

        <h2 id="名词解释"   >
          <a href="#名词解释" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#名词解释"></a> 名词解释</h2>
      
<p>指令：</p>
<p>指令系统：CPU能识别的所有指令的集合</p>
<p>机器语言：指令代码语言</p>
<p>机器语言程序：用户用机器语言编写的程序</p>
<p>汇编语言：一种符号化语言，用一组符号和数字替代CPU能认识的指令。如MOV AL,12H替换了B0 12。</p>
<p>汇编语言（源）程序：用户用汇编语言编写的程序，但CPU不能直接执行，必须要翻译为机器语言程序</p>
<p>汇编：将汇编语言（源）程序翻译为机器语言程序的过程。</p>
<p>反汇编：将机器语言程序翻译为汇编语言（源）程序的过程。</p>

        <h1 id="8086汇编语言程序"   >
          <a href="#8086汇编语言程序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#8086汇编语言程序"></a> 8086汇编语言程序</h1>
      

        <h2 id="语句的种类"   >
          <a href="#语句的种类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#语句的种类"></a> 语句的种类</h2>
      

        <h3 id="指令语句"   >
          <a href="#指令语句" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#指令语句"></a> 指令语句</h3>
      
<p>CPU能执行的语句称为指令语句；</p>
<p>能汇编/翻译成二进制指令代码的语句，称为指令语句。</p>

        <h3 id="伪指令语句"   >
          <a href="#伪指令语句" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#伪指令语句"></a> 伪指令语句</h3>
      
<p>CPU不能执行的语句称为指令语句；</p>
<p>汇编时不能汇编/翻译成二进制指令代码的语句，称为伪指令语句。如&quot;DB&quot;，只是告诉汇编程序（masm.exe）开始定义字节型数据，开始分配空间。这条语句是汇编时完成的，并不是执行时完成的。</p>

        <h3 id="宏指令语句"   >
          <a href="#宏指令语句" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#宏指令语句"></a> 宏指令语句</h3>
      
<p>本身是8086指令系统没有的指令，是用户用<strong>宏定义伪指令</strong>定义的一条新的语句。</p>

        <h2 id="汇编语言中语句的组成"   >
          <a href="#汇编语言中语句的组成" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#汇编语言中语句的组成"></a> 汇编语言中语句的组成</h2>
      
<p>名称+助记符+操作数+注释</p>
<p>变量名称、标号名必须以字母打头，操作数必须以0~9打头。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DAT1 <span class="built_in">DB</span> <span class="number">12H</span>,-<span class="number">12</span>,<span class="number">12</span>	<span class="comment">;注释	;DAT1为变量名</span></span><br><span class="line">DAT2 <span class="built_in">DW</span> ?	<span class="comment">;定义时若不赋值，则需标问号;可以MOV DAT2,AX写入数据</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">NEXT:</span> <span class="keyword">MOV</span> <span class="built_in">AX</span>,<span class="built_in">BX</span>		<span class="comment">;NEXT为标号名，将此处语句的地址符号化</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">AX</span>,DAT2			<span class="comment">;</span></span><br><span class="line"><span class="keyword">JZ</span> NEXT				<span class="comment">;判ZF标志是否为1，若为1则说明AX加和为0，则跳转的条件满足，则跳至NEXT</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="汇编语言中的常数及表达式"   >
          <a href="#汇编语言中的常数及表达式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#汇编语言中的常数及表达式"></a> 汇编语言中的常数及表达式</h2>
      

        <h3 id="常数"   >
          <a href="#常数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常数"></a> 常数</h3>
      
<p>十六进制常数，以H结尾；二进制常数，以B结尾；十进制常数，以D结尾，可以缺省</p>
<p>字符常数’A’；字符串常数’THIS IS A …’</p>

        <h3 id="表达式"   >
          <a href="#表达式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h3>
      

        <h4 id="算术表达式"   >
          <a href="#算术表达式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#算术表达式"></a> 算术表达式</h4>
      

        <h4 id="逻辑表达式"   >
          <a href="#逻辑表达式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#逻辑表达式"></a> 逻辑表达式</h4>
      
<p>AND/OR/NOT</p>

        <h4 id="关系表达式"   >
          <a href="#关系表达式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关系表达式"></a> 关系表达式</h4>
      
<p>LT: 小于</p>

        <h4 id="属性表达式"   >
          <a href="#属性表达式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#属性表达式"></a> 属性表达式</h4>
      

        <h5 id="标号"   >
          <a href="#标号" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#标号"></a> 标号</h5>
      
<p>标号一旦定义了，就具有3个属性。</p>
<ol>
<li>
<p>16位段地址。获取属性操作符：SEG</p>
</li>
<li>
<p>16位段内偏移地址。获取属性操作符：<strong>OFFSET（常用）</strong></p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>,OFFSET NEXT	<span class="comment">;NEXT是标号名称</span></span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>类型。获取标号对应的类型：TYPE</p>
<p>有两种类型，一种是跳转目的地和跳转语句在同一个代码段，则为段内NEAR近程型，值为-1；一种是跳转目的地和跳转语句不在同一个代码段，则是段间FAR远程型，值为-2。</p>
</li>
</ol>

        <h5 id="变量及变量定义伪指令"   >
          <a href="#变量及变量定义伪指令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#变量及变量定义伪指令"></a> 变量及变量定义伪指令</h5>
      
<div class="table-container"><table>
<thead>
<tr>
<th>变量定义伪指令</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB</td>
<td>定义字节型变量，8位</td>
</tr>
<tr>
<td>DW</td>
<td>定义字型变量，16位</td>
</tr>
<tr>
<td>DD</td>
<td>定义双字型变量，32位</td>
</tr>
</tbody>
</table></div>
<p>变量一旦定义了，就具有5个属性。</p>
<ol>
<li>
<p>16位段地址。获取属性操作符：SEG</p>
</li>
<li>
<p>16位段内偏移地址。获取属性操作符：<strong>OFFSET（常用）</strong></p>
</li>
<li>
<p>类型。获取标号对应的类型：TYPE</p>
<div class="table-container"><table>
<thead>
<tr>
<th>变量定义伪</th>
<th>类型</th>
<th>类型值（字节数）</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB</td>
<td>字节型变量</td>
<td>1</td>
</tr>
<tr>
<td>DW</td>
<td>字型变量</td>
<td>2</td>
</tr>
<tr>
<td>DD</td>
<td>双字型变量</td>
<td>4</td>
</tr>
</tbody>
</table></div>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,TYPE DAT1	<span class="comment">;等效于MOV AL,1</span></span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>长度。获取属性操作符：LENGTH</p>
<p>变量的长度指在变量名定义语句中，所定义的<strong>变量的个数</strong>。比如在变量定义的语句中出现了DUP重复操作符，那么重复操作符前的数值便是定义的<strong>变量的个数</strong>；如果没有出现DUP重复操作符，则认为只定义了一个变量。</p>
</li>
<li>
<p>大小。获取属性操作符：SIZE</p>
<p>变量的长度指在变量名定义语句中，所定义的<strong>所有变量占用的总的字节数</strong>。那么，SIZE=TYPE*LENGTH</p>
</li>
</ol>

        <h5 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h5>
      
<p>OFFSET获取的段内偏移地址属性最好赋给地址寄存器，BX/BP为基址寄存器，SI/DI为变址寄存器。如果赋给AX没有意义。</p>

        <h5 id="例"   >
          <a href="#例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#例"></a> 例</h5>
      
<p>在DS段有以下变量定义</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAT1 <span class="built_in">DB</span> <span class="number">12</span>,<span class="number">12H</span>,-<span class="number">12</span>,<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728155350067.png" alt="image-20210728155350067" /></p>
<p>在masm.exe编译过程中，有一个&quot;$&quot;符号——位置计数器，记录偏移地址。每定义一个变量，$则会指向下一个将要被使用的存储单元地址。是16位变量。本身的值也是一个常数，既然是常数，那么在程序中也可以引用。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DAT1 <span class="built_in">DB</span> <span class="number">12</span>,<span class="number">12H</span>,-<span class="number">12</span>,<span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">;DAT2 DB $	;DB定义不对，因为$是16位数据。</span></span><br><span class="line">DAT2 <span class="built_in">DW</span> $	<span class="comment">;当执行到这一句时，$已经指向了下一个将要被使用的存储单元地址，即$中的值是0004H，则这条语句的意思是将0004H存入0004H存储单元，其中，低地址存放低位数据04H，高地址存放高位数据00H。</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728160206056.png" alt="image-20210728160206056" /></p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;假设DAT3的段地址是1500H，偏移地址是000AH；DAT6的偏移地址是0016H</span></span><br><span class="line">DAT6 <span class="built_in">DW</span> DAT3	<span class="comment">;此语句的意思不是取DAT3的值给DAT6，而是把DAT3的偏移地址赋给DAT6。即把000AH赋给DAT6存储空间。</span></span><br><span class="line">DAT7 <span class="built_in">DD</span> DAT3	<span class="comment">;此时DAT7对应的偏移地址是0018H，DD变量将占用4个字节存储单元，由于4个字节可以分为2个双字空间，则汇编时会将DAT3的偏移地址和段地址都存放到DAT7中。</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728161510404.png" alt="image-20210728161510404" /></p>

        <h6 id="重复操作符dup"   >
          <a href="#重复操作符dup" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#重复操作符dup"></a> 重复操作符(DUP)</h6>
      
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAT8 <span class="built_in">DB</span> <span class="number">4</span> DUP(?)	<span class="comment">;DUB为重复操作符，左边的4是指要重复的次数，括号内是要重复定义的值，这里的?代表随机值。</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728161729544.png" alt="image-20210728161729544" /></p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAT9 <span class="built_in">DW</span> <span class="number">3</span> DUP(?)</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728162021258.png" alt="image-20210728162021258" /></p>

        <h5 id="注意区分"   >
          <a href="#注意区分" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意区分"></a> 注意区分</h5>
      
<p>要区分变量定义和赋值时的区别。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,DAT1+<span class="number">2</span>	<span class="comment">;指的是把(DAT1+2)存储单元中的“内容”赋给AL寄存器。(DAT1+2)存储单元中的内容目前是“F4H”，则把“F4H”传给了AL。采用的寻址方式是直接寻址。</span></span><br><span class="line">DAT123 <span class="built_in">DW</span> DAT1	<span class="comment">;指的是把DAT1的偏移地址存到DAT123的存储单元中去。 </span></span><br></pre></td></tr></table></div></figure>

        <h5 id="属性临时修改操作符ptr"   >
          <a href="#属性临时修改操作符ptr" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#属性临时修改操作符ptr"></a> 属性临时修改操作符(PTR)</h5>
      
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>,DAT1	<span class="comment">;此句语法错误，因为AX是16位寄存器，而DAT1是DB类型的变量，占8位。类型不匹配，无法完成赋值。</span></span><br></pre></td></tr></table></div></figure>
<p>类型不一致无法赋值时，可以使用PTR</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>,<span class="built_in">WORD</span> <span class="built_in">PTR</span> DAT1	<span class="comment">;将DAT1在这条语句中临时转换为字型数据。脱离这条语句后仍然是字节型变量。</span></span><br></pre></td></tr></table></div></figure>

        <h6 id="应用"   >
          <a href="#应用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用"></a> 应用</h6>
      
<p>BYTE PTR [BX]</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> [<span class="built_in">BX</span>],<span class="number">10H</span>	<span class="comment">;语法错误，因为不知道[BX]找到的地址的那个存储单元是什么类型的，就不知道那个存储单元占几字节，那么就不知道10H该如何处理（是处理为10H还是0010H）。</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">BX</span>],<span class="number">10H</span>	<span class="comment">;运用PTR操作符正确处理</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="数据与转移地址的寻址方式"   >
          <a href="#数据与转移地址的寻址方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据与转移地址的寻址方式"></a> 数据与转移地址的寻址方式</h1>
      
<p>寻址方式就是求操作数的<strong>所在地</strong>或者<strong>所在存储器单元地址</strong>的方式。求得的操作数一是可以用来作为数据用，二是可以用来作为转移地址用。那么寻址方式就分为了两大类，第一大类是取数据的寻址方式，第二大类是关于转移到目的地地址的操作数在哪放着的寻址方式。如果是段内转移，则要求得16位偏移地址给IP，如果是段间转移，还要求得16位段地址给CS。<br />
<img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728172308349.png" alt="image-20210728172308349" /></p>

        <h2 id="关于寻找数据的寻址方式8种"   >
          <a href="#关于寻找数据的寻址方式8种" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关于寻找数据的寻址方式8种"></a> 关于寻找数据的寻址方式（8种）</h2>
      

        <h3 id="立即数寻址"   >
          <a href="#立即数寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#立即数寻址"></a> 立即数寻址</h3>
      
<p>立即数只能做源操作数，不能做目的操作数。</p>
<p>MOV AX,1234H</p>

        <h4 id="注意"   >
          <a href="#注意" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4>
      
<p>立即数只能传送给通用寄存器和存储器单元。</p>
<p>当段寄存器DS/ES/SS作为DST操作数时，SRC操作数不能是立即数寻址。</p>

        <h3 id="寄存器寻址"   >
          <a href="#寄存器寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#寄存器寻址"></a> 寄存器寻址</h3>
      
<p>要寻找的操作数在寄存器当中。则是寄存器寻址。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>,<span class="built_in">BX</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="注意-2"   >
          <a href="#注意-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h4>
      

        <h5 id="mov两个操作数时类型要一致"   >
          <a href="#mov两个操作数时类型要一致" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mov两个操作数时类型要一致"></a> MOV两个操作数时类型要一致</h5>
      
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>,<span class="built_in">CL</span>	<span class="comment">;ERROR</span></span><br></pre></td></tr></table></div></figure>

        <h5 id="类型要明确"   >
          <a href="#类型要明确" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类型要明确"></a> 类型要明确</h5>
      
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> [<span class="number">0200H</span>],<span class="number">56H</span>				<span class="comment">;ERROR</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">WORD</span> <span class="built_in">PTR</span> [<span class="number">0200H</span>],<span class="number">56H</span>	<span class="comment">;指明了该单元是一个字单元</span></span><br></pre></td></tr></table></div></figure>

        <h5 id="当段寄存器dsesss作为dst操作数时src操作数不能是立即数寻址"   >
          <a href="#当段寄存器dsesss作为dst操作数时src操作数不能是立即数寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#当段寄存器dsesss作为dst操作数时src操作数不能是立即数寻址"></a> 当段寄存器DS/ES/SS作为DST操作数时，SRC操作数不能是立即数寻址。</h5>
      
<p>但可以采用寄存器寻址作为中介。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="number">1500H</span>	<span class="comment">;ERROR</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>,<span class="number">1500H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br></pre></td></tr></table></div></figure>

        <h5 id="csip只能作源操作数"   >
          <a href="#csip只能作源操作数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#csip只能作源操作数"></a> CS/IP只能作源操作数</h5>
      
<p>CS代码段寄存器，IP指令指针寄存器，都不可作DST操作数。往往只读不写。用户无权主观更改CS/IP的值，CS/IP的值一是在初始值是程序中的内存启动时由操作系统赋予的。二是执行期间由转移指令CPU执行后改变而赋予的。</p>

        <h3 id="存储器寻址5种"   >
          <a href="#存储器寻址5种" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#存储器寻址5种"></a> 存储器寻址（5种）</h3>
      
<p>要寻找的OPR（操作数）在存储器某单元中，存储操作数单元的EA（段内偏移地址）可以由以下5种寻址方式求得。</p>

        <h4 id="直接寻址"   >
          <a href="#直接寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h4>
      
<p>操作数所在单元的EA指令中直接给出。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,[<span class="number">2000H</span>]	<span class="comment">;实际编程中，2000H将会符号化为变量</span></span><br><span class="line"><span class="comment">;在ds段：</span></span><br><span class="line">		dat1 <span class="built_in">DB</span> <span class="number">12H</span></span><br><span class="line">		dat2 <span class="built_in">DB</span> <span class="number">34H</span></span><br><span class="line">		...</span><br><span class="line"><span class="comment">;在CS段：</span></span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">MOV</span> <span class="built_in">AL</span>,dat1		<span class="comment">;AL是寄存器寻址，dat1是直接寻址。语句执行完成后，AL中的内容则为(AL)=12H</span></span><br></pre></td></tr></table></div></figure>

        <h5 id="注意-3"   >
          <a href="#注意-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-3"></a> 注意</h5>
      
<p>两个存储器单元之间不能直接传送数据</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> DAT2,DAT1	<span class="comment">;错误，两存储器单元之间不能直接进行一切的操作</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,DAT1</span><br><span class="line"><span class="keyword">MOV</span> DAT2,<span class="built_in">AL</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="寄存器间接寻址"   >
          <a href="#寄存器间接寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h4>
      
<p>[BX/SI/DI]</p>
<p>三个寄存器都是默认存放的DS中的地址。</p>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729135603135.png" alt="image-20210729135603135" /></p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>,OFFSET DAT1	<span class="comment">;将dat1的16位偏移地址给了BX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,[<span class="built_in">BX</span>]			<span class="comment">;(DS:(BX))--&gt;AL	;AL默认是字节型数据，则把12H给AL</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> [<span class="built_in">BX</span>],<span class="number">56H</span>	<span class="comment">;ERROR,因为源操作数是立即数寻址而[BX]没有说明类型。</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>,OFFSET DAT1</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">SI</span>,OFFSET DAT2</span><br><span class="line"><span class="keyword">MOV</span> [<span class="built_in">BX</span>],[<span class="built_in">SI</span>]	<span class="comment">;ERROR,两存储器单元之间不能直接传送数据。</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,[<span class="built_in">SI</span>]</span><br><span class="line"><span class="keyword">MOV</span> [<span class="built_in">BX</span>],<span class="built_in">AL</span></span><br></pre></td></tr></table></div></figure>

        <h4 id="寄存器相对寻址"   >
          <a href="#寄存器相对寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#寄存器相对寻址"></a> 寄存器相对寻址</h4>
      
<p>EA=[BX/BP/SI/DI] + 8/16位disp(相对位移量)</p>
<p>例：MOV <strong>[BX]+3</strong>,AL	;也可等效为**[BX+3]或3+[BX]**,<strong>如果相对位移量写在左边，则+号可以缺省。</strong></p>
<p>如果相对位移量为常数：如果寄存器是BX,SI,DI则段地址默认在DS段；如果寄存器是BP则段地址在SS段。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>,OFFSET DAT1</span><br><span class="line"><span class="keyword">MOV</span> [<span class="built_in">BX</span>]+<span class="number">3</span>,<span class="built_in">AL</span>	<span class="comment">;也可等效为[BX+3]或3+[BX],如果相对位移量写在左边，则+号可以缺省。</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729142813193.png" alt="image-20210729142813193" /></p>
<p><strong>如果相对位移量是变量：段地址由变量的段地址决定。</strong></p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">MOV</span> DAT1[<span class="built_in">BX</span>],<span class="built_in">AL</span>	<span class="comment">;完成的功能是：先计算16位偏移地址，即OFFSET DAT1+(BX)作为偏移地址，段地址由DAT1决定，再把AL的内容赋给SEG DAT1:BX+OFFSET DAT1这个存储单元中。</span></span><br></pre></td></tr></table></div></figure>

        <h5 id="通过一个例子体现为何要设计一个默认在ss段的bp"   >
          <a href="#通过一个例子体现为何要设计一个默认在ss段的bp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通过一个例子体现为何要设计一个默认在ss段的bp"></a> 通过一个例子体现为何要设计一个默认在SS段的BP</h5>
      
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729143703028.png" alt="image-20210729143703028" /></p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">BP</span>,<span class="built_in">SP</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DX</span>,[<span class="built_in">BP</span>]+<span class="number">4</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729144042088.png" alt="image-20210729144042088" /></p>
<p>该例说明了，如果不想破坏SP栈顶指针，则可以方便的用BP来替代其指向栈顶，而且默认的段地址在堆栈段，所以操作栈比较方便。</p>

        <h4 id="基址-变址寻址"   >
          <a href="#基址-变址寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基址-变址寻址"></a> 基址、变址寻址</h4>
      
<p>基址：[BX/BP]，变址：[SI/DI]。EA=[BX/BP]+[SI/DI]</p>
<p>段地址的确认以基址寄存器来决定。BX默认为DS，BP默认为SS。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	DAT1 <span class="built_in">DB</span> <span class="number">12H</span></span><br><span class="line">	DAT2 <span class="built_in">DB</span> <span class="number">34H</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">10</span></span><br><span class="line">	<span class="keyword">MOV</span> <span class="built_in">BX</span>,OFFSET DAT1</span><br><span class="line">	<span class="keyword">MOV</span> <span class="built_in">SI</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">NEXT:</span> <span class="keyword">MOV</span> [<span class="built_in">BX</span>][<span class="built_in">SI</span>],<span class="built_in">AL</span></span><br><span class="line">	<span class="keyword">INC</span> <span class="built_in">SI</span>			<span class="comment">;SI的值增1</span></span><br><span class="line">	<span class="keyword">LOOP</span> NEXT		<span class="comment">;CX的值循环减1，若不为0则跳转到NEXT</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729145047000.png" alt="image-20210729145047000" /></p>

        <h4 id="基址-变址且相对寻址"   >
          <a href="#基址-变址且相对寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基址-变址且相对寻址"></a> 基址、变址且相对寻址</h4>
      
<p>基址：[BX/BP]，变址：[SI/DI]。EA=[BX/BP]+[SI/DI]+8/16disp</p>
<p>如果相对位移量是变量，则段地址以变量的段地址为准。</p>

        <h3 id="隐含寻址"   >
          <a href="#隐含寻址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#隐含寻址"></a> 隐含寻址</h3>
      
<p>指令中并未写出操作数，但CPU执行指令时知道操作数在哪里。</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">PUSH</span> <span class="built_in">AX</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">;1.        SP &lt;-- (SP)-2</span></span><br><span class="line"><span class="comment">;2. (SS:(SP)) &lt;-- (AX)</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="关于转移地址的寻址方式"   >
          <a href="#关于转移地址的寻址方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关于转移地址的寻址方式"></a> 关于转移地址的寻址方式</h2>
      
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://xing-cg.github.io">Mr.Can</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://xing-cg.github.io/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/">https://xing-cg.github.io/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</a></span></div></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/Redis/Redis_dict/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Redis_dict</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%BE%AE%E4%BF%A1%E5%8E%9F%E7%90%86_%E5%85%B3%E4%BA%8Ex86%E5%92%8Cx64/"><span class="paginator-prev__text">关于x86和x64</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">
           二进制转化为十进制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%A410%E5%8F%96%E4%BD%99%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">
           除10取余法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">
           比较法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">
           8位寄存器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">
           二进制数的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97-"><span class="toc-number">3.1.</span> <span class="toc-text">
           算术运算+、-、*、&#x2F;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%8A%B6%E6%80%81%E5%AD%97%E5%AF%84%E5%AD%98%E5%99%A8psw"><span class="toc-number">4.</span> <span class="toc-text">
           处理器状态字寄存器PSW</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">
           补码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">
           寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">
           通用寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.1.1.</span> <span class="toc-text">
           数据寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ax"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">
           AX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bx"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">
           BX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cx"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">
           CX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dx"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">
           DX</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">
           地址指针与变址寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">
           地址指针寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sp"><span class="toc-number">6.1.2.1.1.</span> <span class="toc-text">
           SP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bp"><span class="toc-number">6.1.2.1.2.</span> <span class="toc-text">
           BP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">
           变址寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#si"><span class="toc-number">6.1.2.2.1.</span> <span class="toc-text">
           SI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#di"><span class="toc-number">6.1.2.2.2.</span> <span class="toc-text">
           DI</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">
           总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">
           段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cs"><span class="toc-number">6.2.1.</span> <span class="toc-text">
           CS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ds"><span class="toc-number">6.2.2.</span> <span class="toc-text">
           DS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es"><span class="toc-number">6.2.3.</span> <span class="toc-text">
           ES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ss"><span class="toc-number">6.2.4.</span> <span class="toc-text">
           SS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">
           控制寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ip"><span class="toc-number">6.3.1.</span> <span class="toc-text">
           IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#psw"><span class="toc-number">6.3.2.</span> <span class="toc-text">
           PSW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%976%E4%B8%AA"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">
           状态标志（6个）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%973%E4%B8%AA"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">
           控制标志（3个）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#df"><span class="toc-number">6.3.2.2.1.</span> <span class="toc-text">
           DF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#if"><span class="toc-number">6.3.2.2.2.</span> <span class="toc-text">
           IF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tf"><span class="toc-number">6.3.2.2.3.</span> <span class="toc-text">
           TF</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8086%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8Cio%E7%BB%84%E7%BB%87"><span class="toc-number">7.</span> <span class="toc-text">
           8086存储器和I&#x2F;O组织</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">
           存储器地址空间与数据存放格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">7.1.1.</span> <span class="toc-text">
           地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">
           数据存放格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">
           字节型数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E6%AE%B5%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">7.2.</span> <span class="toc-text">
           存储器的分段与物理地址的形成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">7.2.1.</span> <span class="toc-text">
           分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E6%AE%B5"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">
           1、为什么分段？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E5%88%86"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">
           2、怎么分？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9F%90%E5%AD%98%E5%82%A8%E5%99%A8%E5%8D%95%E5%85%83%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E6%B1%82%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">7.2.2.</span> <span class="toc-text">
           已知某存储器单元的逻辑地址，求物理地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8086cpu%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.</span> <span class="toc-text">
           8086CPU的指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">8.1.</span> <span class="toc-text">
           名词解释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">
           8086汇编语言程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">
           语句的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.1.1.</span> <span class="toc-text">
           指令语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.1.2.</span> <span class="toc-text">
           伪指令语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.1.3.</span> <span class="toc-text">
           宏指令语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">9.2.</span> <span class="toc-text">
           汇编语言中语句的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B8%B8%E6%95%B0%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.3.</span> <span class="toc-text">
           汇编语言中的常数及表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0"><span class="toc-number">9.3.1.</span> <span class="toc-text">
           常数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.3.2.</span> <span class="toc-text">
           表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.3.2.1.</span> <span class="toc-text">
           算术表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.3.2.2.</span> <span class="toc-text">
           逻辑表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.3.2.3.</span> <span class="toc-text">
           关系表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.3.2.4.</span> <span class="toc-text">
           属性表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7"><span class="toc-number">9.3.2.4.1.</span> <span class="toc-text">
           标号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%8A%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">9.3.2.4.2.</span> <span class="toc-text">
           变量及变量定义伪指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">9.3.2.4.3.</span> <span class="toc-text">
           总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B"><span class="toc-number">9.3.2.4.4.</span> <span class="toc-text">
           例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%E7%AC%A6dup"><span class="toc-number">9.3.2.4.4.1.</span> <span class="toc-text">
           重复操作符(DUP)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%8C%BA%E5%88%86"><span class="toc-number">9.3.2.4.5.</span> <span class="toc-text">
           注意区分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%B4%E6%97%B6%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%E7%AC%A6ptr"><span class="toc-number">9.3.2.4.6.</span> <span class="toc-text">
           属性临时修改操作符(PTR)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">9.3.2.4.6.1.</span> <span class="toc-text">
           应用</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">
           数据与转移地址的寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%BB%E6%89%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F8%E7%A7%8D"><span class="toc-number">10.1.</span> <span class="toc-text">
           关于寻找数据的寻址方式（8种）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.1.</span> <span class="toc-text">
           立即数寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">
           注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.2.</span> <span class="toc-text">
           寄存器寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">
           注意</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mov%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%A6%81%E4%B8%80%E8%87%B4"><span class="toc-number">10.1.2.1.1.</span> <span class="toc-text">
           MOV两个操作数时类型要一致</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%A6%81%E6%98%8E%E7%A1%AE"><span class="toc-number">10.1.2.1.2.</span> <span class="toc-text">
           类型要明确</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%93%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8dsesss%E4%BD%9C%E4%B8%BAdst%E6%93%8D%E4%BD%9C%E6%95%B0%E6%97%B6src%E6%93%8D%E4%BD%9C%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.2.1.3.</span> <span class="toc-text">
           当段寄存器DS&#x2F;ES&#x2F;SS作为DST操作数时，SRC操作数不能是立即数寻址。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#csip%E5%8F%AA%E8%83%BD%E4%BD%9C%E6%BA%90%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">10.1.2.1.4.</span> <span class="toc-text">
           CS&#x2F;IP只能作源操作数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%805%E7%A7%8D"><span class="toc-number">10.1.3.</span> <span class="toc-text">
           存储器寻址（5种）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">
           直接寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-3"><span class="toc-number">10.1.3.1.1.</span> <span class="toc-text">
           注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.3.2.</span> <span class="toc-text">
           寄存器间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.3.3.</span> <span class="toc-text">
           寄存器相对寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%BD%93%E7%8E%B0%E4%B8%BA%E4%BD%95%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%9C%A8ss%E6%AE%B5%E7%9A%84bp"><span class="toc-number">10.1.3.3.1.</span> <span class="toc-text">
           通过一个例子体现为何要设计一个默认在SS段的BP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80-%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.3.4.</span> <span class="toc-text">
           基址、变址寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80-%E5%8F%98%E5%9D%80%E4%B8%94%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.3.5.</span> <span class="toc-text">
           基址、变址且相对寻址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80"><span class="toc-number">10.1.4.</span> <span class="toc-text">
           隐含寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">
           关于转移地址的寻址方式</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">305</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>