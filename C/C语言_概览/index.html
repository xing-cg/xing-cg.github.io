<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="前言及语录         C语言的最根本的一个特点：一定要会上机编程。这是宗旨。不管学的怎么样，程序要会编。程序不会编的话，记那么多规则也是没有用的。即C语言的编程是第一位的要求。 C语言官网 ；C++参考手册：不会了就可以在这里面查！ 注册博客，要求是：把学习内容按照我们的理解写出来，总结自己学到的内容。博客的好处就是避免遗忘。可以翻出来清楚自己学到了">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言_概览">
<meta property="og:url" content="https://xing-cg.github.io/C/C%E8%AF%AD%E8%A8%80_%E6%A6%82%E8%A7%88/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:description" content="前言及语录         C语言的最根本的一个特点：一定要会上机编程。这是宗旨。不管学的怎么样，程序要会编。程序不会编的话，记那么多规则也是没有用的。即C语言的编程是第一位的要求。 C语言官网 ；C++参考手册：不会了就可以在这里面查！ 注册博客，要求是：把学习内容按照我们的理解写出来，总结自己学到的内容。博客的好处就是避免遗忘。可以翻出来清楚自己学到了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712155031576.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712180942700.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712190620491.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712233203207.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712233841613.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003504549.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003530909.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003601640.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713004400231.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713004708901.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713004753195.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713005317130.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105853322.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105916869.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105929580.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713111900791.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713113436447.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713144419145.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712231142222.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713172544505.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713151216654.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713163156464.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713164713434.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715001423769.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715010003149.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714155735069.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713184548788.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713184644291.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714162919263.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714162932627.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714170927750.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714171543412.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714234134586.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713225323314.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713225726024.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715011105297.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715010757756.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715012709734.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715011908929.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715012233908.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715012838790.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715014252117.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715014516247.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714003229156.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715021922182.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714003659077.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715021416730.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715121438344.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715124558882.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715125037821.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210715125337615.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714175813243.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150544136.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150616048.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150647588.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150735990.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150755672.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150817409.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150827045.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210713192127424.png">
<meta property="og:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210714143758025.png">
<meta property="article:published_time" content="2021-07-12T00:00:00.000Z">
<meta property="article:modified_time" content="2025-08-27T08:02:07.897Z">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xing-cg.github.io/images/C%E8%AF%AD%E8%A8%80_210617/image-20210712155031576.png"><title>C语言_概览 | 罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/C/C%E8%AF%AD%E8%A8%80_%E6%A6%82%E8%A7%88/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">C语言_概览</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-07-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-27</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/C/C%E8%AF%AD%E8%A8%80_%E6%A6%82%E8%A7%88/" data-flag-title="C语言_概览"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body">
        <h1 id="前言及语录"   >
          <a href="#前言及语录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#前言及语录"></a> 前言及语录</h1>
      
<ol>
<li>C语言的最根本的一个特点：一定要会上机编程。这是宗旨。不管学的怎么样，程序要会编。程序不会编的话，记那么多规则也是没有用的。即C语言的编程是第一位的要求。</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.cplusplus.com" >C语言官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ；<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.cppreference.com/w" >C++参考手册</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：不会了就可以在这里面查！</li>
<li>注册博客，要求是：把学习内容按照我们的理解写出来，总结自己学到的内容。博客的好处就是避免遗忘。可以翻出来清楚自己学到了哪些，同时能随时补充。</li>
<li>刷题网站：牛客网、力扣网。学完数组、指针、结构体后即可上此平台刷题。绝大部分的题都是要我们自己去刷的。</li>
<li>看的第一本C语言书籍：《高质量程序设计指南——<code>C++/C</code>语言》。先看到56页，等学到<code>C++</code>再往后看。</li>
</ol>
<p>C语言概述部分内容简单地把基础知识、基本的语法、指针、结构体介绍。有的详尽，有的不太详尽。后期分专题分析重要的内容。</p>

        <h1 id="计算机基础知识"   >
          <a href="#计算机基础知识" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#计算机基础知识"></a> 计算机基础知识</h1>
      

        <h2 id="软件的概念"   >
          <a href="#软件的概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#软件的概念"></a> 软件的概念</h2>
      
<p>一系列按照特的那个顺序组织的计算机<strong>数据</strong>和<strong>指令</strong>的集合。简单地说，软件就是程序加文档的集合。<br />
软件一般被划分为系统软件（如安卓操作系统）、应用软件（如Word、编译器）和介于这两者之间的中间件（如Redis）。</p>

        <h2 id="文件"   >
          <a href="#文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件"></a> 文件</h2>
      
<p>文件由两部分构成：文件名和文件主体。<br />
文件的一种分类是：可执行文件和不可执行文件。</p>

        <h3 id="可执行文件"   >
          <a href="#可执行文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#可执行文件"></a> 可执行文件</h3>
      
<ol>
<li>在Windows操作系统中，扩展名为：<code>*.exe</code>, <code>*.bat</code>, <code>*.com</code>等的文件是可执行文件；</li>
<li>可执行文件由指令和数据构成。</li>
<li>Linux是靠文件属性来判断是否可执行。</li>
</ol>

        <h3 id="不可执行文件"   >
          <a href="#不可执行文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#不可执行文件"></a> 不可执行文件</h3>
      
<p>其内容是由数据构成。</p>

        <h3 id="举例"   >
          <a href="#举例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
      
<p>在<code>C/C++</code>语言中，<code>*.c</code>/<code>*.cpp</code>源文件（文本–<code>ASCII</code>码字符构成的），<code>*.h</code>头文件（文本），<code>*.i</code>预编译文件（文本），<code>*.s</code>汇编文件，<code>*.o/*.obj</code>二进制目标文件，<code>*.exe</code>可执行文件。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712155031576.png" alt="image-20210712155031576" /></p>
<p>在IDE中编译链接后，工程目录下的<code>Debug</code>中形成了<code>obj</code>文件和<code>exe</code>文件。<br />
达到可执行的底层步骤：预编译、编译、链接。</p>
<blockquote>
<p>实际上在编译和链接之间还有汇编这个步骤</p>
</blockquote>

        <h2 id="进制及其转换"   >
          <a href="#进制及其转换" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进制及其转换"></a> 进制及其转换</h2>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712180942700.png" alt="image-20210712180942700" /><br />
我们学习计算机时，如在调试的时候我们看到的底层是以16进制表达的。我们要理解进制。<br />
进制也就是进位计数制，是人为定义的带进位的计数方法。 对于任何一种进制–<code>X进制</code>，就表示每一位置上的数运算时都是逢<code>X</code>进一位。 如：十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，<code>x</code>进制就是逢<code>x</code>进位。我们日常生活中的进制都哪些？<br />
计算机中的进制分为二进制，八进制，十进制，十六进制。<br />
二进制数、八进制数、十六进制数转换为十进制数的规律是相同的。把二进制数（八进制或十六进制数）按位权形式展开多项式和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”。如：<br />
<code>(10100)2</code>➔<code>(1 * 2^4 + 0*2^3 + 1 * 2^2 + 0*2^1 + 0*2^0)10</code>➔<code>(20)10</code></p>
<p><code>(245)8</code>➔<code>(2 * 8^2 + 4 * 8^1 + 5 * 8^0)10</code>➔<code>(165)10</code></p>
<p><code>(1F2)16</code>➔<code>(1 * 16^2 + 15 * 16^1 + 2 * 16^0)10</code>➔<code>(498)10</code></p>
<blockquote>
<p>练习：<code>(103)10</code>➔<code>(    )2➔(    )8</code>➔<code>(    )16</code></p>
</blockquote>

        <h1 id="c语言简介"   >
          <a href="#c语言简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c语言简介"></a> C语言简介</h1>
      
<p>C语言是一种结构化语言，它有着清晰的层次，可按照模块的方式对程序进行编写，十分有利于程序的调试，且C语言的处理和表现能力都非常的强大，依靠非常全面的运算符和多样的数据类型，可以轻易完成各种数据结构的构建，通过指针类型更可对内存直接寻址以及对硬件进行直接操作，因此既能够用于开发系统程序，也可用于开发应用软件。<br />
1982年成立C标准委员会，建立C语言的标准。<br />
1989年，ANSI发布了第一个完整的C语言标准——<code>ANSIX3.159—1989</code>，简称“C89”。<br />
1999年，在做了一些必要的修正和完善后，ISO (International Standards Organization)，发布了新的C语言标准，命名为<code>ISO/IEC 9899: 1999</code>，简称“C99”。<br />
在2011年12月8日，ISO又正式发布了新的标准，称为<code>ISO/IEC9899: 2011</code>，简称为“C11”。</p>

        <h2 id="第一个c语言程序"   >
          <a href="#第一个c语言程序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第一个c语言程序"></a> 第一个C语言程序</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c  		 //注释	// /* 不容许嵌套 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> 	 <span class="comment">//预编译处理</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> 			 <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello word !\n&quot;</span>); <span class="comment">//语句</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="c源程序的结构特点"   >
          <a href="#c源程序的结构特点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c源程序的结构特点"></a> C源程序的结构特点</h2>
      
<ol>
<li>一个Ｃ语言源程序可以由一个或多个源文件组成。</li>
<li>每个源文件可由一个或多个函数组成。</li>
<li>一个源程序不论由多少个文件组成，都有一个且<strong>只能有一个main函数</strong>，即主函数。</li>
<li>源程序中可以有预处理命令(include 命令仅为其中的一种)，预处理命令通常应放在源文件或源程序的最前面。</li>
<li>每一个说明，每一个语句都必须以分号结尾。</li>
<li>标识符，关键字之间必须至少加一个空格以示间隔。若已有明显的间隔符，也可不再加空格来间隔。</li>
</ol>

        <h2 id="c语言的特点"   >
          <a href="#c语言的特点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c语言的特点"></a> C语言的特点</h2>
      
<ol>
<li>与Java和C++一样，C语言是一种<strong>强类型</strong>语言。即<strong>类型不可变</strong>性。在C语言中，变量、函数一旦定义了类型，它的类型就不变。</li>
<li>C语言是函数式编译的。即小函数来套函数，一个一个套接。</li>
</ol>

        <h3 id="一段有启发的代码"   >
          <a href="#一段有启发的代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一段有启发的代码"></a> 一段有启发的代码</h3>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712190620491.png" alt="image-20210712190620491" /><br />
此段代码的运行结果是：<code>“-10 &gt; 10”</code></p>

        <h1 id="数据类型"   >
          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
      

        <h2 id="基本数据类型"   >
          <a href="#基本数据类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h2>
      
<p>必须记住（包括占用字节数），融于血液中。</p>

        <h3 id="整型"   >
          <a href="#整型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#整型"></a> 整型</h3>
      
<ol>
<li><code>char</code>; 存放字符的ASCII码值。占用1字节</li>
<li><code>short</code>; 短整型，占用2字节</li>
<li><code>int</code>; 占用4字节</li>
<li><code>long int</code>; 占用4字节</li>
<li><code>long long</code>; 占用8字节</li>
</ol>

        <h3 id="浮点"   >
          <a href="#浮点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#浮点"></a> 浮点</h3>
      
<ol>
<li><code>float</code>; 单精度，占用4字节</li>
<li><code>double</code>; 双精度，占用8字节</li>
<li><code>long double</code>; 双双精度，当前VS编译器占用8字节，dev编译器占用12字节，将来可能占用16字节</li>
</ol>

        <h3 id="新类型"   >
          <a href="#新类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#新类型"></a> 新类型</h3>
      
<p><code>bool</code>; 占用1字节</p>

        <h3 id="无类型-也属于基本数据类型"   >
          <a href="#无类型-也属于基本数据类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无类型-也属于基本数据类型"></a> 无类型 - 也属于基本数据类型</h3>
      
<p><code>void</code>; 不能定义变量，所以不占用字节</p>

        <h2 id="各数据类型的区别"   >
          <a href="#各数据类型的区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#各数据类型的区别"></a> 各数据类型的区别</h2>
      
<p>最大的区别在于在定义变量时，它们开辟的空间的字节个数不一样。</p>

        <h2 id="关键字sizeof"   >
          <a href="#关键字sizeof" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关键字sizeof"></a> 关键字sizeof</h2>
      
<ol>
<li>计算<strong>变量占用的存储空间</strong>或<strong>一种类型在定义变量时所占的存储空间</strong>。<strong>不是函数</strong>！</li>
<li>计算出来的数值类型为：<code>unsigned int</code></li>
<li>在编译时进行计算，而不是运行时进行计算。</li>
</ol>
<p>示例：<code>int n = sizeof(char);</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> ar[n] = &#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(n);<span class="comment">//4</span></span><br><span class="line"><span class="keyword">sizeof</span>(ar);<span class="comment">//等于sizeof(int)*n 即4*5=20</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="变量-常量-标识符"   >
          <a href="#变量-常量-标识符" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#变量-常量-标识符"></a> 变量、常量、标识符</h1>
      

        <h2 id="变量"   >
          <a href="#变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
      
<p>以某标识符为名字，其数值可以改变，可读可写。共有三个层次。</p>

        <h3 id="全局变量"   >
          <a href="#全局变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3>
      
<p>定义在函数（包括主函数）之外的变量。</p>

        <h4 id="作用域解析符"   >
          <a href="#作用域解析符" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#作用域解析符"></a> 作用域解析符——<code>::</code></h4>
      
<p>两个冒号，代表我要用全局变量。常用于全局、局部变量名冲突时区别出全局变量。</p>

        <h3 id="局部变量"   >
          <a href="#局部变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h3>
      
<p>定义在函数内部的变量。</p>

        <h3 id="块内变量"   >
          <a href="#块内变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#块内变量"></a> 块内变量</h3>
      
<p>块内可见。块外不可见。</p>

        <h3 id="代码示例"   >
          <a href="#代码示例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h3>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712233203207.png" alt="image-20210712233203207" /><br />
这段代码的输出结果为：“b = 0 ”。</p>

        <h4 id="全局与局部冲突时的向上就近原则"   >
          <a href="#全局与局部冲突时的向上就近原则" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#全局与局部冲突时的向上就近原则"></a> 全局与局部冲突时的向上就近原则</h4>
      
<p>说明一个规律、道理：当遇到的变量名字出现全局、局部的冲突时，按<strong>向上就近原则</strong>为主。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712233841613.png" alt="image-20210712233841613" /><br />
这段代码的输出结果为：<code>b = 10</code>。说明了<code>::</code>符的作用。</p>

        <h2 id="常量"   >
          <a href="#常量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2>
      
<p>其值不可改变，只读不写。</p>

        <h3 id="字面常量"   >
          <a href="#字面常量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#字面常量"></a> 字面常量</h3>
      
<p>要注意的是常量不只是有数值，常量也带有类型的意义。比如<code>7/2=3</code>。</p>
<p>编程与数学的区别：一个有穷一个无穷；一个有类型一个无类型。</p>

        <h3 id="宏常量"   >
          <a href="#宏常量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#宏常量"></a> 宏常量</h3>
      
<p>用#define定义的常量，叫做宏常量。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></div></figure>
<p>宏的根本概念是一种替换原则。</p>
<ol>
<li>
<p>无类型，只是暂时用字符串来表示</p>
</li>
<li>
<p>不开辟存储空间</p>
</li>
<li>
<p>结尾一般不加分号，如果加上分号则把分号也一起看作是替换的值。</p>
</li>
<li>
<p>在预编译时遇到宏常量字符串时起作用，替换。可以在预编译后Debug文件夹下生成的*.i文件中看到。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003504549.png" alt="image-20210713003504549" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003530909.png" alt="image-20210713003530909" /><br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003601640.png" alt="image-20210713003601640" /></p>
</li>
</ol>

        <h3 id="常变量"   >
          <a href="#常变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常变量"></a> 常变量</h3>
      
<p>用const关键字修饰的变量，称为常变量。只可读取，不可改变。要开辟空间。</p>

        <h3 id="枚举常量enum"   >
          <a href="#枚举常量enum" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#枚举常量enum"></a> 枚举常量（enum）</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span></span><br><span class="line">    Mon=<span class="number">1</span>,</span><br><span class="line">    Tues=<span class="number">2</span>,</span><br><span class="line">    Wed=<span class="number">3</span>,</span><br><span class="line">    Thurs=<span class="number">4</span>,</span><br><span class="line">    Fri=<span class="number">5</span>,</span><br><span class="line">    Sat=<span class="number">6</span>,</span><br><span class="line">    Sun=<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></div></figure>
<p>枚举常量实际上是一种受到限制的<strong>整型量</strong>。不可以是小数。</p>
<ol>
<li>第一种受限的表现：x不能随便取值，只能从1、2、3、4、5、6、7中赋值。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713004400231.png" alt="image-20210713004400231" /></li>
<li>第二种受限的表现：即使从1、2、3、4、5、6、7中赋值也要用定义枚举类的变量名赋值，不可直接用数字。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713004708901.png" alt="image-20210713004708901" /></li>
<li>正确写法：<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713004753195.png" alt="image-20210713004753195" /></li>
<li>其他约束：运算的约束，比如不可以自增自减。</li>
<li>如果没给第一个变量赋值，则默认第一个变量为0，往后的变量值为依次加1；若没给中间某个变量赋值，则默认为上一个变量值加1。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713005317130.png" alt="image-20210713005317130" /><br />
如上图，值依次为：-1、0、1、-2、-1、0、1</li>
</ol>

        <h3 id="字符常量和字符串常量"   >
          <a href="#字符常量和字符串常量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#字符常量和字符串常量"></a> 字符常量和字符串常量</h3>
      
<p><code>char ch = 'a';</code></p>
<p>给变量ch中存放的不是字符<code>'a'</code>，而是字符<code>'a'</code>对应的ASCII码值。即编译后转换为<code>&quot;char ch = 97;&quot;</code>。</p>
<p>打开内存，查<code>ch</code>处的存储内容。发现存的是<code>97</code>的十六进制形式<code>61</code>。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105853322.png" alt="image-20210713105853322" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105916869.png" alt="image-20210713105916869" /><br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105929580.png" alt="image-20210713105929580" /><br />
<code>char</code>是整型数据类型，<code>ch</code>存储的是ASCII码<code>97</code>，但输出的形式由我们决定，如果是<code>printf(&quot;%d \n&quot;, ch);</code>那么就是<code>97</code>。如果是<code>printf(&quot;%c \n&quot;,ch);</code>那么就是<code>a</code>。</p>
<p>关于字符对应的ASCII码，我们重点记忆几个字符即可，比如字符a是97，则可以推出其他字符的值。</p>

        <h4 id="特殊符号-转义字符及其含义"   >
          <a href="#特殊符号-转义字符及其含义" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#特殊符号-转义字符及其含义"></a> 特殊符号 - 转义字符及其含义</h4>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713111900791.png" alt="image-20210713111900791" /></p>
<p>重点记三个：</p>
<ol>
<li><code>\n</code>是换行符（LF），将当前位置移到下一行开头。ASCII码值是<code>10</code>。</li>
<li><code>\r</code>是回车符（CR），将当前位置移到本行开头。ASCII码值是<code>13</code>。</li>
<li><code>\t</code>是水平制表符（HT），跳到下一个TAB位置。ASCII码值是<code>9</code>。</li>
<li><code>\0</code>是空字符，ASCII码值是<code>0</code>。<strong>所以空字符可以有两种赋值形式:<code>char ch1 = 0;或char ch2 = '\0';</code></strong><br />
如果要表示反斜杠字符，可用<code>\\</code>转义。</li>
</ol>

        <h5 id="定界符"   >
          <a href="#定界符" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#定界符"></a> 定界符</h5>
      
<p>单引号是字符的定界符：<code>'a' -&gt; |97|</code>。如果要表示单引号字符，可用<code>\'</code>转义。<br />
双引号是字符串的定界符：<code>&quot;a&quot; -&gt; |97|\0|</code>。如果要表示双引号字符，可用<code>\&quot;</code>转义。</p>

        <h4 id="关于空字符0-空格字符-和0字符"   >
          <a href="#关于空字符0-空格字符-和0字符" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关于空字符0-空格字符-和0字符"></a> 关于空字符（<code>\0</code>）、空格字符（<code>' '</code>）和<code>'0'</code>字符</h4>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713113436447.png" alt="image-20210713113436447" /><br />
一定要区分。区分的关键是从ASCII码值来理解。</p>
<ol>
<li>空格字符<strong>不是空字符</strong>。<strong>空格字符的ASCII码值是48</strong>。</li>
<li><code>char chb = 0;</code>和<code>char chc = '\0';</code>等效，都是给变量赋ASCII码值0。</li>
<li>单引号中只有0的时候是字符’0’，其ASCII码值是48。</li>
</ol>

        <h4 id="头文件ctypeh"   >
          <a href="#头文件ctypeh" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#头文件ctypeh"></a> 头文件<code>&lt;ctype.h&gt;</code></h4>
      
<p>用来确定包含于字符数据中的类型的函数。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713144419145.png" alt="image-20210713144419145" /></p>

        <h2 id="标识符"   >
          <a href="#标识符" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h2>
      
<p>必须是<strong>以下划线或字母开头</strong>的<strong>下划线、字母、数字的组合体</strong>。</p>
<p><code>_a</code>; <code>a4</code>; <code>_3</code>;均可</p>
<p>变量、函数起名时要见名知义，不要用汉语拼音，因为有同音异词，容易引起歧义。</p>

        <h1 id="定义和声明"   >
          <a href="#定义和声明" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#定义和声明"></a> 定义和声明</h1>
      

        <h2 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2>
      
<p>所谓的定义就是为这个变量分配一块内存并给它取上一个名字，这个名字就是我们经常所说的变量名。但注意，这个名字一旦和这块内存匹配起来，它们就同生共死，终生不离不弃，并且这块内存的位置也不能被改变。<strong>一个变量在一定的区域内（比如函数内，全局等）只能被定义一次</strong>，如果定义多次，编译器会提示你重复定义同一个变量或对象。</p>

        <h2 id="声明"   >
          <a href="#声明" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2>
      
<p>什么是声明：有两重含义，如下：<br />
第一重含义：告诉编译器，这个名字已经匹配到一块内存地址上了。（但是如果只是声明的话，不开辟内存空间）<br />
第二重含义：告诉编译器，我这个名字我先预定了，别的地方再也不能用它来作为变量名。</p>

        <h2 id="示例"   >
          <a href="#示例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712231142222.png" alt="image-20210712231142222" /></p>
<p>示例中<code>float pi = 3.14f;</code>，<code>f</code>表示此数据为单精度类型，若不带<code>f</code>默认为双精度。</p>

        <h1 id="顺序语句-选择语句-循环语句"   >
          <a href="#顺序语句-选择语句-循环语句" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#顺序语句-选择语句-循环语句"></a> 顺序语句、选择语句、循环语句</h1>
      

        <h2 id="顺序结构"   >
          <a href="#顺序结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#顺序结构"></a> 顺序结构</h2>
      
<p>按照语句出现的先后顺序依次执行。</p>

        <h2 id="选择结构"   >
          <a href="#选择结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#选择结构"></a> 选择结构</h2>
      
<p>根据条件判断是否执行相关语句。</p>

        <h2 id="循环结构"   >
          <a href="#循环结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h2>
      
<p>当条件成立时，重复执行某些语句。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计从键盘输入的一行字符的个数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a string\n&quot;</span>);</span><br><span class="line">    <span class="comment">//char ch = &#x27;\0&#x27;;</span></span><br><span class="line">    <span class="comment">//scanf_s(&quot;%c&quot;,&amp;ch);</span></span><br><span class="line">    <span class="comment">//ch=getchar();</span></span><br><span class="line">    <span class="keyword">while</span> (getchar()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>其中，<code>getchar();</code>等效于<code>scanf_s(&quot;%c&quot;,&amp;ch);</code>，前者明显比后者简洁。</p>

        <h1 id="函数"   >
          <a href="#函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
      
<p>通过函数，可以把一个复杂任务分解为若干个易于解决的小任务。充分体现结构化程序设计由粗到精、逐步细化的设计思想。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713172544505.png" alt="image-20210713172544505" /></p>

        <h2 id="函数组成部分"   >
          <a href="#函数组成部分" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数组成部分"></a> 函数组成部分</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 + 函数名称(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">　　函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="进程与程序的关系"   >
          <a href="#进程与程序的关系" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程与程序的关系"></a> 进程与程序的关系</h2>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713151216654.png" alt="image-20210713151216654" /></p>

        <h3 id="进程"   >
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3>
      
<p>进程是程序的一次执行。进程是动态的。</p>
<p>比如，在现实世界中，程序可以看作是乐谱，乐谱不会自己弹奏。有一钢琴，人坐下根据乐谱进行弹奏，弹奏乐谱的过程就是进程。</p>
<p>进程非常重要的概念：以时间为单位进行流失，在经过某几个时间点内要把程序全部执行直至结束。时间点有创建、执行、结束。</p>

        <h3 id="资源"   >
          <a href="#资源" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#资源"></a> 资源</h3>
      
<p>又如，菜谱给了做饭步骤，菜谱自己不能凭空做出饭。按照菜谱的模式买菜，架火按照菜谱做饭。而做饭要有资源，油、水、调料、火等。</p>
<p>计算机中最重要的两个资源：<strong>时间</strong>和<strong>空间</strong>。</p>
<p>时间针对于CPU，空间针对于内存。</p>
<p>程序被执行时，任何一个进程，将会把用到的存储空间分配给四个区域——<strong>代码区</strong>(test area)、<strong>数据区</strong>(data area)、<strong>堆区</strong>(heap area)、<strong>栈区</strong>(stack area)。</p>
<ol>
<li>data区存放程序的全局变量。</li>
<li>heap区对应着malloc和free开辟和释放的存储空间。</li>
<li>stack区存放函数中定义的局部变量。</li>
</ol>

        <h2 id="可见性作用域"   >
          <a href="#可见性作用域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#可见性作用域"></a> 可见性（作用域）</h2>
      
<p>可见性指标识符能够被使用的范围：只有在作用域内的标识符才可以被使用。此阶段特性针对<strong>编译和链接</strong>过程。</p>
<ol>
<li>函数中定义的标识符，包括<strong>形参</strong>和<strong>函数体中定义的局部变量</strong>的作用域都只在该函数内，也称作函数域。</li>
<li>文件作用域也称全局作用域，定义在所有函数之外的标识符，具有文件作用域。作用域为<strong>从定义处到整个源文件结束</strong>。文件中定义的全局变量和函数都具有文件作用域。</li>
</ol>

        <h2 id="生存期"   >
          <a href="#生存期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#生存期"></a> 生存期</h2>
      
<p>生命期指的是标识符从程序开始运行时被创建，具有存储空间，到程序运行结束时消亡时释放存储空间的时间段。此阶段针对的是程序的<strong>执行过程</strong>。</p>
<ol>
<li>局部变量的生存期是：函数被调用，分配存储空间；函数执行结束，释放空间。stack区。</li>
<li>全局变量的生存期是：从程序执行前开始，到执行后结束。data区。</li>
</ol>

        <h3 id="代码示例_生存期"   >
          <a href="#代码示例_生存期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码示例_生存期"></a> 代码示例_生存期</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ar[<span class="number">10</span>] = &#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ar[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = fun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="运行结果_生存期"   >
          <a href="#运行结果_生存期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#运行结果_生存期"></a> 运行结果_生存期</h4>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713163156464.png" alt="image-20210713163156464" /></p>
<p>调用的fun结果正常。而main再遍历ar地址时就失效了，后面的数都是随机数。</p>
<p>此例说明，函数的生存期只有在被调用时才拥有其存储空间，调用结束时，其存储空间将被释放。</p>

        <h4 id="思考"   >
          <a href="#思考" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#思考"></a> 思考</h4>
      
<p>数组ar的头地址中的值为何能一直保存？<code>main</code>函数自己调用时，为何除了<code>12</code>正确，其他都是乱的？</p>
<p>做了以下实验：如果让<code>fun</code>函数<code>return ar+1</code>，再在<code>main</code>函数中遍历，发现运行结果是<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713164713434.png" alt="image-20210713164713434" /></p>
<p>即：第一个数据<code>23</code>正确保留，后面全乱。由此，对程序的生存期又可见一斑。</p>
<p>但在<code>dev-C++</code>环境下不可实现<code>main</code>中<code>for</code>遍历（运行出错）。这又说明，<strong>不同编译器对于生存期的定义也不尽相同</strong>！</p>
<p>还做了另一实验：将<code>ar</code>数组大小调整至<code>10000</code>。还是输出<code>10</code>个数，输出却正常。</p>
<p>这个例子体现了<strong>指针的失效</strong>！</p>

        <h4 id="解释"   >
          <a href="#解释" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解释"></a> 解释</h4>
      
<p>我们在调用函数时，都会开辟若干个栈帧提供函数中变量的存储空间。在main函数中调用fun()函数时，随即开辟了一些空间存放数组。最后虽然返回了原本数组的首地址并赋给了p指针，但调用结束后变量的生存期殆尽，空间被释放。printf()也是一函数，他的调用难免会覆盖刚才fun()函数占用的栈帧，即残留在栈帧中的数据被重写导致输出达不到预期以为的效果。</p>
<p>而把数组大小调至10000使fun()函数占用的栈帧很大，导致printf()函数等函数正好没有覆盖到刚才某些数组数据占用的空间，最后导致侥幸输出正确。但本质上p指针还是一个失效指针。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715001423769.png" alt="image-20210715001423769" /></p>

        <h3 id="动态生命期"   >
          <a href="#动态生命期" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#动态生命期"></a> 动态生命期</h3>
      
<p>动态生命期对应动态内存的分配、管理。</p>

        <h1 id="数组"   >
          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1>
      
<p>数组是包含给定类型的一组数据，即一组相同类型元素的集合。</p>

        <h1 id="运算符"   >
          <a href="#运算符" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1>
      

        <h2 id="操作数operand"   >
          <a href="#操作数operand" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#操作数operand"></a> 操作数（Operand）</h2>
      
<p>操作数（operand）是程序操纵的数据实体，该数据可以是数值、逻辑值或其他类型。该操作数既可以是常量也可以为变量。</p>

        <h2 id="运算符operator"   >
          <a href="#运算符operator" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#运算符operator"></a> 运算符（Operator）</h2>
      
<p>运算符（operator）是可以对数据进行相应操作的符号。如对数据求和操作，用加法运算符<code>'+'</code>，求积操作使用乘法运算符<code>'*'</code>等。</p>
<p>根据运算符可操作操作数的个数可分为一元运算符（单目运算符）、二元运算符（双目运算符）和多元运算符（C语言中只有一个三元运算符<code>&quot; ? : &quot;</code>）。</p>

        <h2 id="运算符优先级"   >
          <a href="#运算符优先级" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h2>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715010003149.png" alt="image-20210715010003149" /></p>

        <h2 id="运算符举例"   >
          <a href="#运算符举例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#运算符举例"></a> 运算符举例</h2>
      

        <h3 id="取模运算符"   >
          <a href="#取模运算符" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#取模运算符"></a> 取模运算符%</h3>
      
<p>在C语言中有很多应用：</p>
<ol>
<li>判断是否能够整除某个数；</li>
<li>判断奇偶数，判别质数；</li>
<li>计算范围。形成循环。</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以下均要求每五个数换一行</span></span><br><span class="line"><span class="comment">//从0输出100个数（0~99）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span> &amp;&amp; i!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重点是条件中加一个边界限制条件i!=0，如果没有的话会在输出前多余一行</span></span><br><span class="line"><span class="comment">//输出效果</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4</span></span><br><span class="line"><span class="comment">//  5  6  7  8  9</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">// 95 96 97 98 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从1输出100个数（1~100）</span></span><br><span class="line"><span class="comment">//如果只改变上述代码中for循环中的int i=1;i&lt;=100会出现以下情况：</span></span><br><span class="line"><span class="comment">//  1  2  3  4</span></span><br><span class="line"><span class="comment">//  5  6  7  8  9</span></span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line"><span class="comment">// 95 96 97 98 99</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//所以我们要转变思路，主要转移点就是：先输出，后换行，并限制尾部边界条件，即100输出后不换行。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span> &amp;&amp;　i!=<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//而先输出数字后换行的模式如果对于0~99来说又失效了，会出现如下情况：</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span> &amp;&amp;　i!=<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  0</span></span><br><span class="line"><span class="comment">//  1  2  3  4  5</span></span><br><span class="line"><span class="comment">//  6  7  8  9 10</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 96 97 98 99</span></span><br><span class="line"><span class="comment">//可进行如下改进</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">5</span>==<span class="number">0</span> &amp;&amp;　(i+<span class="number">1</span>)!=<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714155735069.png" alt="image-20210714155735069" /></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编程输出如上效果</span></span><br><span class="line"><span class="comment">//主要思路：两层for循环，用取余思想</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,k);</span><br><span class="line">            k=(k+<span class="number">1</span>)%n;<span class="comment">//精髓所在</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>求最大公约数的辗转相除法（欧几里得算法）：<code>gcd(a, b) = gcd(b, a mod b)</code></li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line"><span class="comment">//i = a &lt; b ? a : b;</span></span><br><span class="line"><span class="comment">//while(i&gt;1)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    if(a%i==0&amp;&amp;b%i==0)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        break;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    --i;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//printf(&quot;%d \n&quot;,i);</span></span><br><span class="line"><span class="comment">//辗转相除法--35和25：35%25=10;25%10=5;10%5=0</span></span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="取余和取模的区别"   >
          <a href="#取余和取模的区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#取余和取模的区别"></a> 取余和取模的区别</h3>
      
<p>对于整型数a，b来说，取模运算或者求余运算的方法都是求整数商</p>
<ol>
<li><code>c = [a/b];</code></li>
<li>计算模或者余数：<code>r = a - c * b</code></li>
</ol>
<p>求模运算和求余运算在<strong>第一步不同</strong>：取余运算在取商<code>c</code>的值时，向<strong>0方向</strong>舍入(<code>fix()</code>函数)；而取模运算在计算商<code>c</code>的值时，向<strong>负无穷方向</strong>舍入(<code>floor()</code>函数)。<br />
例如计算：<code>-7 Mod 4</code>。那么： <code>a = -7; b = 4;</code><br />
第一步：求整数商<code>c</code>，如进行求模运算<code>c=-2</code>(向负无穷方向舍入)；求余<code>c = -1</code>(向0方向舍入);<br />
第二步：计算模和余数的公式相同，但因<code>c</code>的值不同，求模时<code>r = 1</code>，求余时<code>r = -3</code>。<br />
归纳：当<code>a</code>和<code>b</code>同号时，求模运算和求余运算所得的<code>c</code>的值一致，因此结果一致。当符号异号时，结果不—样。<br />
<strong>另外各个环境下<code>%</code>运算符的含义不同，比如<code>c/c++</code>、java为取余，而python则为取模。</strong></p>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> <code>+=, *=</code></h3>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">5</span>,c=<span class="number">7</span>;</span><br><span class="line">a *= b + c;</span><br><span class="line"><span class="comment">//a = a * (b+c); //36</span></span><br></pre></td></tr></table></div></figure>
<p>说明：别看<code>*=</code>里面虽然带乘号，但是它的优先级是很低的。</p>

        <h3 id="前置-后置"   >
          <a href="#前置-后置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#前置-后置"></a> 前置<code>++</code>、后置<code>++</code></h3>
      
<p>如果没有赋值语句，效果完全一样：先取<code>a</code>、<code>b</code>中原数到临时空间<code>eax</code>（cpu的内部寄存器），临时空间数据<code>+1</code>，再把加<code>1</code>后的数值更新到<code>a</code>、<code>b</code>中。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713184548788.png" alt="image-20210713184548788" /><br />
如果有赋值语句。则后置<ins>是先把值赋给c，再+1回写；而前置</ins>是先更新变量值，再赋值到c。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713184644291.png" alt="image-20210713184644291" /></p>

        <h2 id="其他说明"   >
          <a href="#其他说明" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#其他说明"></a> 其他说明</h2>
      
<ol>
<li>对于C语言程序，<code>++i</code>和<code>i++</code>效率是一样的；</li>
<li>对于GoLang，只有<code>++i</code>，没有<code>i++</code>；</li>
<li>在面向对象语言中如<code>C++</code>、Java、Python，<code>++i</code>效率比较高，<code>i++</code>效率低。至于为何，在C++部分讲述。</li>
</ol>

        <h1 id="左值和右值"   >
          <a href="#左值和右值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#左值和右值"></a> 左值和右值</h1>
      
<p>按字面意思通俗地说。以赋值符号<code>=</code>为界，<code>=</code>左边的就是左值，<code>=</code>右边就是右值。<br />
更深一层，可以将<code>L-value</code>理解成可寻址。A value (computer science) that has an address；<code>R-value</code>表示可读。</p>

        <h1 id="指针"   >
          <a href="#指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1>
      
<p>内存（在程序中称为主存DRAM）是计算机中重要的部件之一，它是外存（硬盘）与CPU进行沟通的桥梁。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714162919263.png" alt="image-20210714162919263" /></p>
<p>计算机中所有程序的运行都是在内存中进行，为了有效的使用内存，就<strong>把内存以8位二进制（bit）划分为存储单元（也就是 1 字节）</strong>。为了有效的访问到内存的每个存储单元，就给内存存储单元进行了编号，这些编号被称为该<strong>内存存储单元的地址</strong>。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714162932627.png" alt="image-20210714162932627" /></p>
<p>存储地址的变量称为指针变量。在C 语言中指针就是地址。</p>

        <h2 id="打印地址的方式"   >
          <a href="#打印地址的方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#打印地址的方式"></a> 打印地址的方式</h2>
      

        <h3 id="x"   >
          <a href="#x" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#x"></a> <code>%x</code></h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>,&amp;a);<span class="comment">//输出了：93fcb4，原本总共是8位，前面的00舍去了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x \n&quot;</span>,&amp;a);<span class="comment">//输出了006ffbc4。%后面补上08，8代表宽度，0代表宽度不够的时候补0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08X \n&quot;</span>,&amp;a);<span class="comment">//输出了：001AFDA8。x由小写改为大写，代表字母以大写形式输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0X%08X \n&quot;</span>,&amp;a);<span class="comment">//输出了：0X0113F944。%前加上了&quot;0X&quot;，完整、完美地表示了这是一个16进制数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="p"   >
          <a href="#p" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#p"></a> <code>%p</code></h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p \n&quot;</span>,&amp;a);<span class="comment">//输出了：012FFBA4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#p \n&quot;</span>,&amp;a);<span class="comment">//输出了：0X00AFF8BC，但在VS2019里不支持，VS2012中可以。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="该死的星号"   >
          <a href="#该死的星号" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#该死的星号"></a> 该死的星号<code>*</code></h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C/C++ *</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = a * b;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> * p = &amp;a;<span class="comment">//*在此表达式中的作用只是声明、标识。a的地址给的是p而不是*p</span></span><br><span class="line">	*p = <span class="number">100</span>;<span class="comment">//与上面一句中的*作用不同，此处*的作用是指向、解引用。如果p是a的地址，那么*p就是a本身。</span></span><br></pre></td></tr></table></div></figure>
<p>上述给了几个表达式。</p>
<p><code>a</code>、<code>b</code>、<code>c</code>、<code>p</code>都是变量。<strong>变量最根本的区别在于：类型</strong>。</p>
<p>要彻底理解星号的不同用处，突破点在于对变量的类型的区分！</p>
<p><code>int * p = &amp;a;</code>此处<code>*</code>在左侧的作用只是一个声明。<strong>声明p是一个int类型的指针变量</strong>。就是说，你只要是整型变量，那么我<code>p</code>就可以存放你的地址。此例，<code>a</code>的地址给的是<code>p</code>而不是<code>*p</code>。所以<code>p</code>和<code>a</code>、<code>b</code>、<code>c</code>不同之处在于，<code>p</code>是一个<code>int</code>型指针，<code>a</code>、<code>b</code>、<code>c</code>只是<code>int</code>型。因此<code>int p = &amp;a;</code>这句话就是错误的：<code>&amp;a</code>是一个指针，而<code>p</code>是<code>int</code>型，类型不匹配，无法存放。</p>
<p><code>*p = 100;</code>与<code>int * p = &amp;a;</code>中的<code>*</code>作用不同，此处<code>*</code>的作用是指向、解引用。也就是说，<strong>如果p是a的地址，那么<code>*p</code>就是<code>a</code>本身</strong>。此处不要拿“间接访问”来解释，在语法上没有这回事。</p>

        <h2 id="指针的两个值"   >
          <a href="#指针的两个值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#指针的两个值"></a> 指针的两个值</h2>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714170927750.png" alt="image-20210714170927750" /></p>
<p>比如：<code>int a = 10;</code> <code>int* p = &amp;a;</code></p>
<p>一个是本身的值，即本身存储的值，即本身存储的某个地址值。即<code>0x0055f864</code>。此值说明了其指向谁。即<code>&amp;a</code>。</p>
<p>另一个是本身存储的地址值的真实内容值，即<code>a</code>。</p>
<p>虽然<code>p</code>是一个指针，但它也是一个变量，所以他也有自己的地址，即<code>0x0055f84c</code>。</p>

        <h2 id="逻辑名称与物理地址"   >
          <a href="#逻辑名称与物理地址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#逻辑名称与物理地址"></a> 逻辑名称与物理地址</h2>
      
<p>比如：我要到邢同学的宿舍去，邢同学的宿舍就是逻辑名称，而12公寓328是其物理地址。那么，邢同学的宿舍和12公寓328实际上就是同一空间。</p>

        <h2 id="对应到内存条上"   >
          <a href="#对应到内存条上" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对应到内存条上"></a> 对应到内存条上</h2>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714171543412.png" alt="image-20210714171543412" /></p>
<blockquote>
<p>可以拓展的知识点：小端存放与大端存放</p>
</blockquote>

        <h2 id="指针类型的sizeof"   >
          <a href="#指针类型的sizeof" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#指针类型的sizeof"></a> 指针类型的sizeof</h2>
      
<p>32位机的指针一概都是4；64位机的指针一概都是8！</p>
<p>因为<strong>不管你是char类型、短整型、整型的变量的地址，都只是存放首地址</strong>，对于64位机，某一类型的首地址就占用64位bit位，8个字节才能存放；同理，对于32位机，某一类型的首地址就占用32位bit位，4个字节才能存放。</p>

        <h2 id="指针的类型"   >
          <a href="#指针的类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#指针的类型"></a> 指针的类型</h2>
      

        <h3 id="野指针"   >
          <a href="#野指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#野指针"></a> 野指针</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>就像a未初始化，不清楚其值是多少一样。未初始化的p也不知道其指向的是哪个地址。此类指针叫做野指针。</p>

        <h3 id="空指针"   >
          <a href="#空指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#空指针"></a> 空指针</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p=<span class="literal">NULL</span>;<span class="comment">//此处将用0代替NULL赋值</span></span><br><span class="line">    <span class="type">int</span>* s=nullptr;<span class="comment">//此处将用(void*)0代替nullptr赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714234134586.png" alt="image-20210714234134586" /></p>

        <h3 id="失效指针"   >
          <a href="#失效指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#失效指针"></a> 失效指针</h3>
      

        <h3 id="代码示例-2"   >
          <a href="#代码示例-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码示例-2"></a> <a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B_%E7%94%9F%E5%AD%98%E6%9C%9F">代码示例</a></h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> * <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ar[<span class="number">10</span>]=&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* p=&amp;ar[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    inr* ip=fun();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*ip);</span><br><span class="line">        ip=ip+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C_%E7%94%9F%E5%AD%98%E6%9C%9F">运行结果</a></p>

        <h2 id="null与nullptr"   >
          <a href="#null与nullptr" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#null与nullptr"></a> NULL与nullptr</h2>
      
<p>实际上还是有一些小的区别。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;<span class="comment">//此处将用0代替NULL赋值</span></span><br><span class="line"><span class="type">int</span>* s = nullptr;<span class="comment">//此处将用(void*)0代替nullptr赋值</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="结构体"   >
          <a href="#结构体" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1>
      
<p>程序开发人员可以使用结构体来封装一些属性，根据原有的类型，设计出新的类型，在C语言中称为结构体类型。<br />
在C语言中，结构体是一种数据类型。</p>

        <h2 id="c语言中的类型"   >
          <a href="#c语言中的类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c语言中的类型"></a> <a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">C语言中的类型</a></h2>
      
<p><code>char; short; int; long int; long long; float; double; long double; bool;</code>都是<strong>基本类型</strong>。</p>
<p><code>char*; short*;</code>这种指针类型和<code>int ar[10]; br[20];</code>这种数组类型都叫做<strong>结构类型</strong>。</p>

        <h2 id="结构体的使用"   >
          <a href="#结构体的使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#结构体的使用"></a> 结构体的使用</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> s_id[<span class="number">10</span>];<span class="comment">//学号</span></span><br><span class="line">    <span class="type">char</span> s_name[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">char</span> s_sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line">    <span class="type">int</span> s_age;<span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义结构体变量并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stud</span>=</span>&#123;<span class="string">&quot;202001&quot;</span>,<span class="string">&quot;tulun&quot;</span>,<span class="string">&quot;man&quot;</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="comment">//sizeof(stud)?</span></span><br><span class="line">    <span class="comment">//使用.（成员选择(对象)运算符）访问结构体变量的成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;id: %s \n&quot;</span>,stud.s_id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s \n&quot;</span>,stud.s_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sex: %s \n&quot;</span>,stud.s_sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age: %d \n&quot;</span>,stud.s_age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="结构体的访问形式"   >
          <a href="#结构体的访问形式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#结构体的访问形式"></a> 结构体的访问形式</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student  sx = &#123;...&#125;;</span><br><span class="line">Student* sp = &amp;sx;</span><br><span class="line"></span><br><span class="line">形式一：(*sx).s_id = <span class="number">202001</span>;<span class="comment">//注意，*（取值运算符）优先级低于.（成员选择(对象)运算符），使用必须给*sx加上括号，否则sx直接先和.结合，导致错误。</span></span><br><span class="line">形式二：sp-&gt;s_id   = <span class="number">202001</span>;<span class="comment">//成员选择(对象指针)运算符</span></span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>掌握如何计算结构体的sizeof。</p>
</blockquote>

        <h1 id="文件-2"   >
          <a href="#文件-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件-2"></a> 文件</h1>
      

        <h2 id="数据流"   >
          <a href="#数据流" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据流"></a> 数据流</h2>
      
<p>指程序与数据的交互是以流的形式进行的。进行C语言文件的存取时，都会先进行“打开文件”操作，这个操作就是在打开数据流，而“关闭文件”操作就是关闭数据流。</p>

        <h2 id="缓冲区buffer"   >
          <a href="#缓冲区buffer" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓冲区buffer"></a> 缓冲区（Buffer）</h2>
      
<p>指在程序执行时，所提供的一块存储空间（在内存中），可用来暂时存放做准备执行的数据。它的设置是为了提高存取效率，因为内存的存取速度比磁盘驱动器快得多。</p>
<p>C语言的文件处理功能依据系统是否设置“缓冲区”分为两种：一种是设置缓冲区，另一种是不设置缓冲区。由于不设置缓冲区的文件处理方式，必须使用较低级别的 I/O 函数(包含在头文件<code>io.h</code>和<code>fcntl.h</code>中)来直接对磁盘存取，这种方式的存取速度慢，并且由于不是C的标准函数，跨平台操作时容易出问题。下面只介绍第一种处理方式，即设置缓冲区的文件处理方式。</p>
<p>当使用标准I/O函数（包含在头文件<code>stdio.h</code>中）时，系统会自动设置缓冲区，并通过数据流来读写文件。当进行文件读取时，不会直接对磁盘进行读取，而是先打开数据流，将磁盘上的文件信息拷贝到缓冲区内，然后程序再从缓冲区中读取所需数据，如下图所示：</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713225323314.png" alt="image-20210713225323314" /></p>

        <h2 id="文件类型"   >
          <a href="#文件类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h2>
      
<p>分为文本文件和二进制文件两种。</p>
<p>文本文件是以字符编码的方式进行保存的。二进制文件将内存中数据原封不至文件中，适用于非字符为主的数据。</p>
<p>如果以记事本打开，只会看到一堆乱码。</p>
<p>其实，除了文本文件外，所有的数据都可以算是二进制文件。二进制文件的优点在于存取速度快，占用空间小，以及可随机存取数据。</p>

        <h2 id="文件存取方式"   >
          <a href="#文件存取方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件存取方式"></a> 文件存取方式</h2>
      
<p>包括顺序存取方式和随机存取方式两种。</p>
<p>顺序读取也就是从上往下，一笔一笔读取文件的内容。保存数据时，将数据附加在文件的末尾。这种存取方式常用于文本文件，而被存取的文件则称为顺序文件。</p>
<p>随机存取方式多半以二进制文件为主。它会以一个完整的单位来进行数据的读取和写入，通常以结构为单位。</p>

        <h2 id="c语言提供的标准文件"   >
          <a href="#c语言提供的标准文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c语言提供的标准文件"></a> C语言提供的标准文件</h2>
      
<p>通常把显示器称为标准输出文件，<code>printf</code>就是向这个文件输出数据；</p>
<p>通常把键盘称为标准输入文件，<code>scanf</code>就是从这个文件读取数据。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713225726024.png" alt="image-20210713225726024" /></p>

        <h1 id="关键字"   >
          <a href="#关键字" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h1>
      

        <h2 id="const"   >
          <a href="#const" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#const"></a> const</h2>
      
<p>const在实际编程中用得比较多，const是constant的缩写，意思是“恒定不变的”！它是定义<strong>只读变量</strong>的关键字，或者说 const 是定义常变量的关键字。（可读，不可写）</p>
<p>const可以修饰变量，数组，指针等；说const定义的是变量，但又相当于常量；说它定义的是常量，但又有变量的属性，所以叫常变量。</p>
<p>用const定义常变量的方法很简单，就在通常定义变量时前面加 const 即可，如：<code>const int a = 10;</code>或<code>int const a = 10;</code>而且<strong>可以修饰任何类型的变量</strong>，包括数组。</p>
<p>那么用const修饰后和未修饰前有什么区别呢？用const定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着<strong>必须在定义的时候就给它赋初值</strong>。无论是全局常变量还是局部常变量都必须初始化赋值。</p>

        <h3 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ip = &amp;a;<span class="comment">//这种写法是错误的，会产生二义性，因为这样写的意义何在？你的a到底能变还是不能变！</span></span><br><span class="line">    <span class="comment">//有一种办法能让此语句成功编译，就是强转类型：int* ip = (int*)&amp;a;但是强转类型会出乱子。详看下文《一家网络公司的某个试题》。</span></span><br><span class="line">    <span class="comment">//还有一种办法能成立，就是把左式声明部分加上const来修饰，即const int* ip = &amp;a;这样做：ip就可以指向a了，但不可以通过ip改变a。而且这样做会导致下面的语句&quot;*ip = 100&quot;报错：“表达式必须是可修改的左值”。因为ip指向的值是拿const修饰的，此处就识别为不可修改了！</span></span><br><span class="line">    *ip = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>总结：const不只能修饰普通类型、数组，还能修饰指针（比如修饰指针的其一种特性——<strong>修饰指针的指向能力</strong>，达到了保护的效果，就如<code>const int* ip = &amp;a</code>，达到了通过ip只能读取a，不可写的效果）。以此类推，C语言还有：<code>int* const is;</code> <code>const int* const ir;</code>其中<code>const int* const ir;</code>的前一个指针是修饰指向不可改变，后一个const是修饰指针自身不可改变。</p>

        <h3 id="一家网络公司的某个试题"   >
          <a href="#一家网络公司的某个试题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一家网络公司的某个试题"></a> 一家网络公司的某个试题</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* ip = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">    *ip = <span class="number">100</span>;</span><br><span class="line">    b = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d \n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d \n&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ip =&gt; %d \n&quot;</span>,*ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><code>*.cpp</code>文件的运行结果如下，此结果是比较符合const这个关键字的功能的。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715011105297.png" alt="image-20210715011105297" /></p>
<p>但是，此运行结果却和调试过程中的显示结果不一致！</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715010757756.png" alt="image-20210715010757756" /></p>
<p>前九行运行是符合普通人（没有深刻理解const）的思路的，<code>a</code>通过指针<code>ip</code>被赋值<code>100</code>。但奇怪的是：第十行运行后<code>b=a;</code>这个语句居然是给<code>b</code>赋值了<code>10</code>。</p>
<p>另外，c文件的输出结果却是：</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715012709734.png" alt="image-20210715012709734" /></p>
<p>这又是怎么一回事？详见下面《解释》的论述。</p>

        <h4 id="解释-2"   >
          <a href="#解释-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解释-2"></a> 解释</h4>
      

        <h5 id="cpp文件下的结果"   >
          <a href="#cpp文件下的结果" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cpp文件下的结果"></a> cpp文件下的结果</h5>
      
<p>在<code>*.cpp</code>文件中，const变量和宏变量都是替换机制来实现的，但const是在编译时期替换的，宏变量是在预编译时期替换的。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715011908929.png" alt="image-20210715011908929" /><br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715012233908.png" alt="image-20210715012233908" /><br />
再来一段汇编代码，发现<code>a=b;</code>这条语句并不是把a取值给b，而是用<code>0Ah</code>（10的十六进制）直接赋给b。</p>
<p>所以，无论输出前对a进行了哪些操作都是徒劳的，因为a早已“偷梁换柱”，所以就会出现了我们单步跟踪结果和最终输出结果不一致的情况。</p>
<p>上例给我们一个启发，不要相信你的眼睛，而要相信你所分析的代码。</p>

        <h5 id="c文件下的结果"   >
          <a href="#c文件下的结果" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c文件下的结果"></a> C文件下的结果</h5>
      
<p>C文件下的结果居然又成了<code>a=100, b=100, *ip=100</code>。接下来我们来分析：<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715012838790.png" alt="image-20210715012838790" /><br />
对于<code>b=a;</code>这个语句，我们可以看出：不像cpp文件那样用<code>0Ah</code>直接赋值，而是先取a的值再赋给b。因为<code>*ip</code>改变了a的值，所以b的值也将受到影响。</p>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
      
<p>对于被const关键字修饰的变量：在cpp文件下是编译时期用具体值替换变量名；而在c文件下，编译时期不替换。于是造成了输出结果的差异。</p>

        <h4 id="拓展汇编与程序的联系"   >
          <a href="#拓展汇编与程序的联系" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#拓展汇编与程序的联系"></a> 拓展–汇编与程序的联系</h4>
      
<p><strong>汇编层面下的赋值</strong>（<code>b=a;</code>）<br />
cpu中包含着4个通用数据寄存器：叫做<code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code>。cpu在进行加减乘除、数据运算时不是在内存中运算的，而是把内存数据拉到寄存器中计算，因为内存的计算速度远比cpu计算速度慢。<br />
所以，就出现了为何<code>b=a;</code>在汇编语言层面上是取出a的值给eax再由eax赋值给b，而不是a直接赋值给b。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715014252117.png" alt="image-20210715014252117" /><br />
DMA方式，也叫做I/O协处理器。当我们内存要移动大块数据时，如果要介入cpu的话太影响运行效率，所以我们大块数据交给DMA（协处理器）进行数据移动，从而把CPU资源腾出来用于计算，提高效率。<br />
<strong>汇编层面下的解引用</strong>（<code>*ip=100;</code>）<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715014516247.png" alt="image-20210715014516247" /><br />
首先把ip的值放入到寄存器eax中，那么eax的值就相当于a的地址，再往下，把<code>64h</code>（100的十六进制）给了<code>[eax]</code>。此时注意：<code>mov eax,10;</code>和<code>mov [eax],10;</code>这两种访问方式不一样。前者是直接访问方式，把10给了eax；后者是间接访问方式，不是把10给了eax，而是把10给了eax所存放的某个地址里。因此，直接访问是一步汇编实现，间接访问是两步汇编实现，所以直接访问效率要高于间接访问。</p>

        <h2 id="sizeof关键字"   >
          <a href="#sizeof关键字" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sizeof关键字"></a> sizeof关键字</h2>
      
<p>已在上面章节论述。</p>
<p>此处再引入几个有启发的例子。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714003229156.png" alt="image-20210714003229156" /><br />
此题运行后的size还是4，a还是10！可从汇编角度观察究竟！<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715021922182.png" alt="image-20210715021922182" /><br />
启示：<strong>sizeof只在编译时期计算</strong>而不是运行时期计算，相当于直接替换为4。因此<code>++a</code>这个<code>++</code>的动作就失去了意义，编译时就直接略去了<code>++</code>这个操作。因此后面a的值没有变化。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714003659077.png" alt="image-20210714003659077" /><br />
此程序运行后的size大小为8，即double类型所占用的空间。因为在编译时期sizeof就识别到了<code>(a+0.9)</code>这个数值为double类型。<br />
<strong>sizeof的本质是只关心你此处的数值最终的类型</strong>。</p>

        <h3 id="sizeof和strlen的差异"   >
          <a href="#sizeof和strlen的差异" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sizeof和strlen的差异"></a> sizeof和strlen的差异</h3>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715021416730.png" alt="image-20210715021416730" /><br />
实际结果为：len为6，size为7。因为字符串实际占用了7个字节。字符串的最后是要有<code>\0</code>结尾的；而len的计算是：一碰到<code>\0</code>就结束计算。</p>

        <h2 id="typedef"   >
          <a href="#typedef" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#typedef"></a> typedef</h2>
      
<p>typedef是在计算机编程语言中用来为复杂的声明定义简单的别名。它本身是一种存储之类的关键字，与<code>auto</code>、<code>extern</code>、<code>mutable</code>、<code>static</code>、<code>register</code>等关键字不能出现在同一个表达式中。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u_int8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> u_int16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u_int32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u_int64;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u_int8 a;<span class="comment">//等效于unsigned char a;</span></span><br><span class="line">    u_int64 x;<span class="comment">//等效于unsigned long long x;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>一定要记住：凡是合法的变量名声明、数据声明、指针声明，加一个typedef后我们就可以把变量名转换为类型名，把变量声明定义转换为类型声明定义。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> UNIT;<span class="comment">//原来的变量名声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UNIT;<span class="comment">//UNIT由一个全局变量转换成了一个类型！</span></span><br><span class="line">UNIT a;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Array[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Array[<span class="number">10</span>];<span class="comment">//Array由全局变量转换成了一个“开辟10个空间的整型数组类型”</span></span><br><span class="line">Array ar,br,cr;</span><br></pre></td></tr></table></div></figure>
<p>有人这么认为：认为typedef是用替换原则来实现的，如把<code>&quot;Array&quot;</code>替换为<code>&quot;int[10]&quot;</code>，即<code>Array ar, br, cr;</code>替换为<code>int[10] ar,br,cr;</code>，这是不对的。它是一种类型的<strong>声明</strong>概念。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* PINT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* PINT;</span><br><span class="line">PINT p,s;<span class="comment">//p,s是什么类型呢？回到typedef int* PINT;，把typedef去掉即可得知——p和s都是int*类型。</span></span><br></pre></td></tr></table></div></figure>
<p>上例中，<code>PINT p,s;</code>和<code>int* x,y;</code>是有区别的！我们在编译器中发现，x是整型指针变量，而y是整型变量。因为声明时，我们的星号<code>*</code>要和标识符结合，而不是和类型名结合。所以当我们涉及到为多个指针声明时，用到typedef的方式就特别好。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715121438344.png" alt="image-20210715121438344" /></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line">ListNode* LinkList;<span class="comment">//原本是一个“某一结构体类型的指针变量”</span></span><br><span class="line"><span class="keyword">typedef</span> ListNode* LinkList;<span class="comment">//由全局结构体指针变量转变为了一个类型</span></span><br><span class="line"><span class="comment">//如此定义，那么以下两句就等效</span></span><br><span class="line">ListNode* p;</span><br><span class="line">LinkList s;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时，LinkList原本是一个“全局结构体类型的指针变量”</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;*LinkList;</span><br><span class="line"><span class="comment">//我们也加上一个typedef，现在，LinkList就不再是一个指针变量了，而是一个类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;*LinkList;</span><br><span class="line"><span class="comment">//实际上，以上这种typedef直接在定义结构体时加在前面的写法和typedef ListNode* LinkList;这种写法也是等价的。</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再来一个奇怪的例子：</span></span><br><span class="line"><span class="comment">//首先，我们知道，int int;是不可能这样声明定义变量名的。因为他拿关键字（基本数据类型名）来起名字。</span></span><br><span class="line"><span class="comment">//但如果没拿关键字起名字的话，变量名和类型名可以一样吗？</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line">ListNode ListNode;<span class="comment">//是可以编译通过的，最多就是警告。</span></span><br><span class="line"><span class="comment">//答案是可以一样！因为此类型名、变量名并非关键字，只要符合标识符的命名规范，是没有任何影响的！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，下例的ListNode原本是一个“结构体类型的变量名”</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;ListNode;</span><br><span class="line"><span class="comment">//如今我们在结构体定义前加一个typedef，他就可以变为了一个类型名！</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;ListNode;</span><br><span class="line"><span class="comment">//那么，</span></span><br><span class="line"><span class="keyword">typedef</span> ListNode ListNode;<span class="comment">//就与之等效。</span></span><br><span class="line"><span class="comment">//这种定义方式常常出现在开源项目中，迷惑调试器，追踪变量时搞混变量名和类型名。为的就是不让你看懂。</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如此，理解了typedef的含义。我们可以如下使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;ListNode,*LinkList;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode a;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可用作对枚举类型的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>OK = <span class="number">0</span>,ERROR = <span class="number">1</span>&#125; Status;</span><br></pre></td></tr></table></div></figure>

        <h2 id="static"   >
          <a href="#static" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#static"></a> static</h2>
      

        <h3 id="修饰局部变量"   >
          <a href="#修饰局部变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#修饰局部变量"></a> 修饰局部变量</h3>
      
<p>静态关键字对于局部变量来说是延长寿命的。也就是说，函数只有被调用时，局部变量才会被初始化，函数调用结束时会释放掉所有局部变量。如果我们给局部变量加上了static修饰，那么函数在第一次被调用时初始化了局部变量，即使调用结束后，局部变量也不会释放，即局部变量的寿命比函数要长。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = x;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    ++a;++b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %d b = %d \n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        fun(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将输出：</span></span><br><span class="line">    <span class="comment">//11 1</span></span><br><span class="line">    <span class="comment">//10 1</span></span><br><span class="line">    <span class="comment">//9  1</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2  1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = x;<span class="comment">//这一步是定义a并对a初始化，只执行一次。</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    ++a;++b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a : %d b = %d \n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        fun(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将输出：</span></span><br><span class="line">    <span class="comment">//11 1</span></span><br><span class="line">    <span class="comment">//12 1</span></span><br><span class="line">    <span class="comment">//13 1</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//20 1</span></span><br><span class="line">    <span class="comment">//此输出结果说明，虽然fun(i)一直在给x传参赋值给a，但是实际上是无效的，因为声明定义语句已经在第一次调用fun函数进行了，“一劳永逸”了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>对于第二段代码：在函数被第一次调用时，我们创建a，并把它存放到数据区（data area）。函数结束后，a也不释放。第二次调用时，<code>static int a = x;</code>这一语句不再执行。这一步是定义a并对a初始化，只执行一次。但是写成<code>a = x;</code>就不一样了。<code>a = x;</code>是一句执行语句，在每次函数调用也还是要执行的！</p>
<p>但，static修饰局部变量不改变其作用域。</p>

        <h3 id="修饰全局变量"   >
          <a href="#修饰全局变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#修饰全局变量"></a> 修饰全局变量</h3>
      
<p>而static修饰全局变量时，不改变其生存期，而改变其可见性（只能在当前cpp文件中可见，即使其他文件中的代码拿extern来修饰这个变量，同一工程的另外cpp文件也不可见）。</p>

        <h2 id="extern"   >
          <a href="#extern" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#extern"></a> extern</h2>
      
<p>extern用在全局变量或函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。</p>
<p>假如我们同一个工程下有两个cpp文件，其中有一cpp文件用到了另一个cpp文件的内容。从理论上讲，两个cpp文件各自编译后形成了各自的obj文件，之后链接到了一个exe文件下（这个exe文件就是以工程为单位生成的），理论上，<code>Test7_10</code>文件中的<code>g_max</code>和<code>fun()</code>可以自然地调用<code>yhp</code>文件中的变量、函数。编译是可以进行的，但是，生成是不通过的。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715124558882.png" alt="image-20210715124558882" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715125037821.png" alt="image-20210715125037821" /></p>
<p>我们这时就需要在<code>Test7_10.cpp</code>中添加代码了：如下才能运行成功。<br />
<img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715125337615.png" alt="image-20210715125337615" /><br />
如果在一个cpp文件中，我们不想让其他文件用extern来调用自己的内容，我们可以在这些内容前加上static修饰（需要是全局变量）。因为，在全局变量前加static会改变其可见性。（只能在当前cpp文件中可见，即使其他文件中的代码拿extern来修饰这个变量，同一工程的另外cpp文件也不可见）。</p>
<p>而如果一个cpp文件已经拿static修饰了变量名，另一个cpp还用extern来引用的话，就会失败，这时出现了下面要论述的技术，也就是让这个引用失败的机制——名字粉碎技术。</p>

        <h3 id="名字粉碎技术"   >
          <a href="#名字粉碎技术" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#名字粉碎技术"></a> 名字粉碎技术</h3>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714175813243.png" alt="image-20210714175813243" /></p>

        <h1 id="vs2019的使用"   >
          <a href="#vs2019的使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#vs2019的使用"></a> VS2019的使用</h1>
      

        <h3 id="创建项目"   >
          <a href="#创建项目" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#创建项目"></a> 创建项目</h3>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150544136.png" alt="image-20210712150544136" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150616048.png" alt="image-20210712150616048" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150647588.png" alt="image-20210712150647588" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150735990.png" alt="image-20210712150735990" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150755672.png" alt="image-20210712150755672" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150817409.png" alt="image-20210712150817409" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150827045.png" alt="image-20210712150827045" /></p>

        <h2 id="scanf的注意事项"   >
          <a href="#scanf的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#scanf的注意事项"></a> scanf的注意事项</h2>
      
<p>S2019中不再使用<code>scanf</code>，而是换为了<code>scanf_s</code>。<br />
输入数据时，要严格按照双引号内的格式来输入。</p>

        <h3 id="为何要用scanf_s替换scanf"   >
          <a href="#为何要用scanf_s替换scanf" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为何要用scanf_s替换scanf"></a> 为何要用<code>scanf_s</code>替换<code>scanf</code>？</h3>
      
<p>scanf不安全。比如我们定义了一个<code>int a = 10;</code> <code>char buff[8];</code><br />
如果用<code>scanf(&quot;%s&quot;,buff);</code>输入字符串超过8位时，比如输入<code>yhpingaaaaaaaa</code>，会把a中的信息“冲掉”。（仅限于<code>VC++ 6.0</code>这种比较古老的编译器中）<br />
最后用<code>printf(&quot;a=%x&quot;,a);</code>查看a时，发现<code>a=61616161</code>。61是十六进制，转为十进制为97，表示字符<code>'a'</code>的ASCII码值。所以此处就体现出了scanf对内存的不安全性。<br />
而<code>scanf_s</code>则避免了这个问题，我们可以在输入时加一个参数：<code>scanf_s(&quot;%s&quot;,buff,8);</code>限制输入字符串的长度。</p>

        <h1 id="有启发意义的代码实验"   >
          <a href="#有启发意义的代码实验" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#有启发意义的代码实验"></a> 有启发意义的代码实验</h1>
      
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713192127424.png" alt="image-20210713192127424" /></p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714143758025.png" alt="image-20210714143758025" /></p>
<p>首先我们要清楚16进制与2进制之间的关系，才能清楚存储空间是如何存储数据的。<strong>存储空间中对数据的存放是以十六进制形式存储的</strong>，接下来是对此的举例解释：</p>
<p>比如int占了4个字节，等于占了32个二进制位，而4个二进制位可以转换为1个16进制位，于是int存储的数据可以由<code>32/4=8位16进制位</code>来表示。比如我们<code>int i = 10;</code>那么在存储空间中就是<code>(0a 00 00 00)16</code>。十进制的10转换成了十六进制的a。</p>
<p>接下来我们再来解释为何输出了<code>&quot;a=61616161&quot;</code>：</p>
<p>函数中的变量是存放在栈区的，因为先定义了<code>a</code>，栈底开辟<code>a</code>的空间，<code>a</code>占用4个字节先存放数值<code>12</code>。而后，<code>char</code>类型的<code>buff[8]</code>数组占用<code>a</code>之上的<code>8</code>个字节；<code>scanf</code>输入<code>%s</code>时，不直接存放字符串，而是存放字符串的ASCII码值，比如字符<code>'a'</code>的ASCII码值是91，再转换为十六进制值<code>61</code>。在存放了一部分字符串<code>&quot;yhpingaa&quot;</code>之后，原本在内存中给<code>buff</code>数组存放的空间不足，剩下的<code>&quot;aaaaaa&quot;</code>就由上到下（小端存放方式–高位地址存高位数据，低位地址存低位数据）覆盖到了内存中给a变量开辟的存储空间的4个字节中去了，并且还有可能占用了a空间以外的未知内存资源中，因为<code>int a</code>只能存放4个字节即4个字符值，而剩余a的数目超过了4个。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://xing-cg.github.io">Mr.Can</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://xing-cg.github.io/C/C%E8%AF%AD%E8%A8%80_%E6%A6%82%E8%A7%88/">https://xing-cg.github.io/C/C%E8%AF%AD%E8%A8%80_%E6%A6%82%E8%A7%88/</a></span></div></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/C/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">C语言_分支语句、循环语句、函数初步</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/Blog_%E6%A8%A1%E6%9D%BF/"><span class="paginator-prev__text">Blog_模板</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="valine-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%E5%8F%8A%E8%AF%AD%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">
           前言及语录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">
           计算机基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">
           软件的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">
           文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">
           可执行文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">
           不可执行文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">
           举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">
           进制及其转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B"><span class="toc-number">3.</span> <span class="toc-text">
           C语言简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">
           第一个C语言程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">
           C源程序的结构特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">
           C语言的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AE%B5%E6%9C%89%E5%90%AF%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">
           一段有启发的代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">
           数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">
           基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">
           整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9"><span class="toc-number">4.1.2.</span> <span class="toc-text">
           浮点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">
           新类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%B1%BB%E5%9E%8B-%E4%B9%9F%E5%B1%9E%E4%BA%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">
           无类型 - 也属于基本数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">
           各数据类型的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97sizeof"><span class="toc-number">4.3.</span> <span class="toc-text">
           关键字sizeof</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">
           变量、常量、标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">
           变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">
           全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E6%9E%90%E7%AC%A6"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">
           作用域解析符——::</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">
           局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E5%86%85%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">
           块内变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.1.4.</span> <span class="toc-text">
           代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%B8%8E%E5%B1%80%E9%83%A8%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%90%91%E4%B8%8A%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">
           全局与局部冲突时的向上就近原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">
           常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">
           字面常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%B8%B8%E9%87%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">
           宏常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">
           常变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8Fenum"><span class="toc-number">5.2.4.</span> <span class="toc-text">
           枚举常量（enum）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">5.2.5.</span> <span class="toc-text">
           字符常量和字符串常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">
           特殊符号 - 转义字符及其含义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E7%95%8C%E7%AC%A6"><span class="toc-number">5.2.5.1.1.</span> <span class="toc-text">
           定界符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%A9%BA%E5%AD%97%E7%AC%A60-%E7%A9%BA%E6%A0%BC%E5%AD%97%E7%AC%A6-%E5%92%8C0%E5%AD%97%E7%AC%A6"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">
           关于空字符（\0）、空格字符（&#39; &#39;）和&#39;0&#39;字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6ctypeh"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">
           头文件&lt;ctype.h&gt;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text">
           标识符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">6.</span> <span class="toc-text">
           定义和声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">
           定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">6.2.</span> <span class="toc-text">
           声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">
           示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AF%AD%E5%8F%A5-%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.</span> <span class="toc-text">
           顺序语句、选择语句、循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">
           顺序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">
           选择结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.</span> <span class="toc-text">
           循环结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">
           函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">8.1.</span> <span class="toc-text">
           函数组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.2.</span> <span class="toc-text">
           进程与程序的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">
           进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90"><span class="toc-number">8.2.2.</span> <span class="toc-text">
           资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.3.</span> <span class="toc-text">
           可见性（作用域）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">8.4.</span> <span class="toc-text">
           生存期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B_%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">8.4.1.</span> <span class="toc-text">
           代码示例_生存期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C_%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">
           运行结果_生存期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">8.4.1.2.</span> <span class="toc-text">
           思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">8.4.1.3.</span> <span class="toc-text">
           解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="toc-number">8.4.2.</span> <span class="toc-text">
           动态生命期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">9.</span> <span class="toc-text">
           数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">
           运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0operand"><span class="toc-number">10.1.</span> <span class="toc-text">
           操作数（Operand）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6operator"><span class="toc-number">10.2.</span> <span class="toc-text">
           运算符（Operator）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.3.</span> <span class="toc-text">
           运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%BE%E4%BE%8B"><span class="toc-number">10.4.</span> <span class="toc-text">
           运算符举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.4.1.</span> <span class="toc-text">
           取模运算符%</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.4.2.</span> <span class="toc-text">
           取余和取模的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">10.4.3.</span> <span class="toc-text"> +&#x3D;, *&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE-%E5%90%8E%E7%BD%AE"><span class="toc-number">10.4.4.</span> <span class="toc-text">
           前置++、后置++</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E"><span class="toc-number">10.5.</span> <span class="toc-text">
           其他说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">11.</span> <span class="toc-text">
           左值和右值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">12.</span> <span class="toc-text">
           指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">12.1.</span> <span class="toc-text">
           打印地址的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x"><span class="toc-number">12.1.1.</span> <span class="toc-text">
           %x</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p"><span class="toc-number">12.1.2.</span> <span class="toc-text">
           %p</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A5%E6%AD%BB%E7%9A%84%E6%98%9F%E5%8F%B7"><span class="toc-number">12.2.</span> <span class="toc-text">
           该死的星号*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%80%BC"><span class="toc-number">12.3.</span> <span class="toc-text">
           指针的两个值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">12.4.</span> <span class="toc-text">
           逻辑名称与物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E5%88%B0%E5%86%85%E5%AD%98%E6%9D%A1%E4%B8%8A"><span class="toc-number">12.5.</span> <span class="toc-text">
           对应到内存条上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84sizeof"><span class="toc-number">12.6.</span> <span class="toc-text">
           指针类型的sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.7.</span> <span class="toc-text">
           指针的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">12.7.1.</span> <span class="toc-text">
           野指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">12.7.2.</span> <span class="toc-text">
           空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E6%8C%87%E9%92%88"><span class="toc-number">12.7.3.</span> <span class="toc-text">
           失效指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">12.7.4.</span> <span class="toc-text">
           代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null%E4%B8%8Enullptr"><span class="toc-number">12.8.</span> <span class="toc-text">
           NULL与nullptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">13.</span> <span class="toc-text">
           结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.1.</span> <span class="toc-text">
           C语言中的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">
           结构体的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%AE%BF%E9%97%AE%E5%BD%A2%E5%BC%8F"><span class="toc-number">13.3.</span> <span class="toc-text">
           结构体的访问形式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-2"><span class="toc-number">14.</span> <span class="toc-text">
           文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">14.1.</span> <span class="toc-text">
           数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BAbuffer"><span class="toc-number">14.2.</span> <span class="toc-text">
           缓冲区（Buffer）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.3.</span> <span class="toc-text">
           文件类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">14.4.</span> <span class="toc-text">
           文件存取方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6"><span class="toc-number">14.5.</span> <span class="toc-text">
           C语言提供的标准文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.</span> <span class="toc-text">
           关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">15.1.</span> <span class="toc-text">
           const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">15.1.1.</span> <span class="toc-text">
           注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AE%B6%E7%BD%91%E7%BB%9C%E5%85%AC%E5%8F%B8%E7%9A%84%E6%9F%90%E4%B8%AA%E8%AF%95%E9%A2%98"><span class="toc-number">15.1.2.</span> <span class="toc-text">
           一家网络公司的某个试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-number">15.1.2.1.</span> <span class="toc-text">
           解释</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cpp%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">15.1.2.1.1.</span> <span class="toc-text">
           cpp文件下的结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">15.1.2.1.2.</span> <span class="toc-text">
           C文件下的结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">15.1.2.2.</span> <span class="toc-text">
           总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%B1%87%E7%BC%96%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">15.1.2.3.</span> <span class="toc-text">
           拓展–汇编与程序的联系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.2.</span> <span class="toc-text">
           sizeof关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof%E5%92%8Cstrlen%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">15.2.1.</span> <span class="toc-text">
           sizeof和strlen的差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef"><span class="toc-number">15.3.</span> <span class="toc-text">
           typedef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">15.4.</span> <span class="toc-text">
           static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">15.4.1.</span> <span class="toc-text">
           修饰局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">15.4.2.</span> <span class="toc-text">
           修饰全局变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern"><span class="toc-number">15.5.</span> <span class="toc-text">
           extern</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E7%B2%89%E7%A2%8E%E6%8A%80%E6%9C%AF"><span class="toc-number">15.5.1.</span> <span class="toc-text">
           名字粉碎技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vs2019%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">
           VS2019的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">16.0.1.</span> <span class="toc-text">
           创建项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scanf%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">16.1.</span> <span class="toc-text">
           scanf的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8scanf_s%E6%9B%BF%E6%8D%A2scanf"><span class="toc-number">16.1.1.</span> <span class="toc-text">
           为何要用scanf_s替换scanf？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%90%AF%E5%8F%91%E6%84%8F%E4%B9%89%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C"><span class="toc-number">17.</span> <span class="toc-text">
           有启发意义的代码实验</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">300</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">57</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>