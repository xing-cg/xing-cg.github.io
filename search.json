[{"title":"网络_虚拟局域网","url":"/网络/网络_虚拟局域网/","content":"# 产品\n## Happyn\n基于 N2N 的安全、易于使用的虚拟专用网络（VPN）解决方案。\n\n开源性：客户端已开源。\n\n## ","categories":["网络"]},{"title":"量化交易_mio库与csv库","url":"/量化交易/量化交易_mio库与csv库/","content":"# 创建一个共享内存映射文件\n```cpp\nenum class access_mode\n{\n    read,\n    write\n};\n/**\n * This is the basis for all read-only mmap objects and should be preferred over\n * directly using `basic_mmap`.\n */\ntemplate<typename ByteT>\nusing basic_mmap_source = basic_mmap<access_mode::read, ByteT>;\n\n/**\n * This is the basis for all read-write mmap objects and should be preferred over\n * directly using `basic_mmap`.\n */\ntemplate<typename ByteT>\nusing basic_mmap_sink = basic_mmap<access_mode::write, ByteT>;\n\n/**\n * These aliases cover the most common use cases, both representing a raw byte stream\n * (either with a char or an unsigned char/uint8_t).\n */\nusing mmap_source = basic_mmap_source<char>;\nusing ummap_source = basic_mmap_source<unsigned char>;\n\nusing mmap_sink = basic_mmap_sink<char>;\nusing ummap_sink = basic_mmap_sink<unsigned char>;\n```\n\n`basic_mmap_source`是`basic_map<access_mode::read, ByteT>`。\n相比于`basic_mmap<access_mode AccessMode, ByteT>`，\n`basic_mmap_source`限制了其`AccessMode`是`read`。\n`mmap_source`是`basic_mmap_source<char>`的别名。\n可见，`mmap_source`就是：只读的`char`类型映射。\n\n```cpp\n/**\n * Convenience factory method that constructs a mapping for any `basic_mmap` or\n * `basic_mmap` type.\n */\ntemplate<\n    typename MMap,\n    typename MappingToken\n> MMap make_mmap(const MappingToken& token,\n        int64_t offset, int64_t length, std::error_code& error)\n{\n    MMap mmap;\n    mmap.map(token, offset, length, error);\n    return mmap;\n}\n\n/**\n * Convenience factory method.\n *\n * MappingToken may be a String (`std::string`, `std::string_view`, `const char*`,\n * `std::filesystem::path`, `std::vector<char>`, or similar), or a\n * `mmap_source::handle_type`.\n */\ntemplate<typename MappingToken>\nmmap_source make_mmap_source(const MappingToken& token, mmap_source::size_type offset,\n        mmap_source::size_type length, std::error_code& error)\n{\n    return make_mmap<mmap_source>(token, offset, length, error);\n}\n```\n\n`make_mmap`是一个抽象工厂方法。\n用于生成`MMap`类型的内存映射。\n\n最终调用到了`MMap`类型内部的`map`方法。\n至于是哪个方法，由`MappingToken`决定。如果`MappingToken`是 String，则调用的是`map(const String& path, ...)`。\n\n`make_mmap_source`是具体工厂。\n用于生成`MMap = mmap_source`的映射，即生成一个：只读的`char`类型映射。\n\n# map方法\n`basic_mmap`最基类的接口。\n```cpp\n    /**\n     * Establishes a memory mapping with AccessMode. If the mapping is unsuccesful, the\n     * reason is reported via `error` and the object remains in a state as if this\n     * function hadn't been called.\n     *\n     * `path`, which must be a path to an existing file, is used to retrieve a file\n     * handle (which is closed when the object destructs or `unmap` is called), which is\n     * then used to memory map the requested region. Upon failure, `error` is set to\n     * indicate the reason and the object remains in an unmapped state.\n     *\n     * `offset` is the number of bytes, relative to the start of the file, where the\n     * mapping should begin. When specifying it, there is no need to worry about\n     * providing a value that is aligned with the operating system's page allocation\n     * granularity. This is adjusted by the implementation such that the first requested\n     * byte (as returned by `data` or `begin`), so long as `offset` is valid, will be at\n     * `offset` from the start of the file.\n     *\n     * `length` is the number of bytes to map. It may be `map_entire_file`, in which\n     * case a mapping of the entire file is created.\n     */\n    template<typename String>\n    void map(const String& path, const size_type offset,\n            const size_type length, std::error_code& error);\n\n    /**\n     * Establishes a memory mapping with AccessMode. If the mapping is unsuccesful, the\n     * reason is reported via `error` and the object remains in a state as if this\n     * function hadn't been called.\n     *\n     * `path`, which must be a path to an existing file, is used to retrieve a file\n     * handle (which is closed when the object destructs or `unmap` is called), which is\n     * then used to memory map the requested region. Upon failure, `error` is set to\n     * indicate the reason and the object remains in an unmapped state.\n     * \n     * The entire file is mapped.\n     */\n    template<typename String>\n    void map(const String& path, std::error_code& error)\n    {\n        map(path, 0, map_entire_file, error);\n    }\n\n    /**\n     * Establishes a memory mapping with AccessMode. If the mapping is\n     * unsuccesful, the reason is reported via `error` and the object remains in\n     * a state as if this function hadn't been called.\n     *\n     * `handle`, which must be a valid file handle, which is used to memory map the\n     * requested region. Upon failure, `error` is set to indicate the reason and the\n     * object remains in an unmapped state.\n     *\n     * `offset` is the number of bytes, relative to the start of the file, where the\n     * mapping should begin. When specifying it, there is no need to worry about\n     * providing a value that is aligned with the operating system's page allocation\n     * granularity. This is adjusted by the implementation such that the first requested\n     * byte (as returned by `data` or `begin`), so long as `offset` is valid, will be at\n     * `offset` from the start of the file.\n     *\n     * `length` is the number of bytes to map. It may be `map_entire_file`, in which\n     * case a mapping of the entire file is created.\n     */\n    void map(const handle_type handle, const size_type offset,\n            const size_type length, std::error_code& error);\n\n    /**\n     * Establishes a memory mapping with AccessMode. If the mapping is\n     * unsuccesful, the reason is reported via `error` and the object remains in\n     * a state as if this function hadn't been called.\n     *\n     * `handle`, which must be a valid file handle, which is used to memory map the\n     * requested region. Upon failure, `error` is set to indicate the reason and the\n     * object remains in an unmapped state.\n     * \n     * The entire file is mapped.\n     */\n    void map(const handle_type handle, std::error_code& error)\n    {\n        map(handle, 0, map_entire_file, error);\n    }\n```\n`basic_mmap<AccessMode, ByteT>`的map方法实现\n1. 一个是针对 file handle type 为 文件路径的。类型为 `String&`\n2. 一个是针对 file handle type 为 通用句柄的。如果是 WIN32 则 file handle type 为 HANDLE，其他为 int 。\n\n`map(const String& path, ...)`实际上就是对 `map(const handle_type handle, ...)` 的一次包装，做的额外操作是 打开文件，获取文件句柄。然后传给后者。\n\n```cpp\ntemplate<access_mode AccessMode, typename ByteT>\ntemplate<typename String>\nvoid basic_mmap<AccessMode, ByteT>::map(const String& path, const size_type offset,\n        const size_type length, std::error_code& error)\n{\n    error.clear();\n    if(detail::empty(path))\n    {\n        error = std::make_error_code(std::errc::invalid_argument);\n        return;\n    }\n    const auto handle = detail::open_file(path, AccessMode, error);\n    if(error)\n    {\n        return;\n    }\n\n    map(handle, offset, length, error);\n    // This MUST be after the call to map, as that sets this to true.\n    if(!error)\n    {\n        is_handle_internal_ = true;\n    }\n}\n```\n## 构造一个mmap：最终的路径\n```cpp\ntemplate<access_mode AccessMode, typename ByteT>\nvoid basic_mmap<AccessMode, ByteT>::map(const handle_type handle,\n        const size_type offset, const size_type length, std::error_code& error)\n{\n    error.clear();\n    if(handle == invalid_handle)\n    {\n        error = std::make_error_code(std::errc::bad_file_descriptor);\n        return;\n    }\n\n    const auto file_size = detail::query_file_size(handle, error);\n    if(error)\n    {\n        return;\n    }\n\n    if(offset + length > file_size)\n    {\n        error = std::make_error_code(std::errc::invalid_argument);\n        return;\n    }\n\n    const auto ctx = detail::memory_map(handle, offset,\n            length == map_entire_file ? (file_size - offset) : length,\n            AccessMode, error);\n    if(!error)\n    {\n        // We must unmap the previous mapping that may have existed prior to this call.\n        // Note that this must only be invoked after a new mapping has been created in\n        // order to provide the strong guarantee that, should the new mapping fail, the\n        // `map` function leaves this instance in a state as though the function had\n        // never been invoked.\n        unmap();\n        file_handle_ = handle;\n        is_handle_internal_ = false;\n        data_ = reinterpret_cast<pointer>(ctx.data);\n        length_ = ctx.length;\n        mapped_length_ = ctx.mapped_length;\n#ifdef _WIN32\n        file_mapping_handle_ = ctx.file_mapping_handle;\n#endif\n    }\n}\n```\n\n## 最最后的实际操作\n```cpp\ninline mmap_context memory_map(const file_handle_type file_handle, const int64_t offset,\n    const int64_t length, const access_mode mode, std::error_code& error)\n{\n    const int64_t aligned_offset = make_offset_page_aligned(offset);\n    const int64_t length_to_map = offset - aligned_offset + length;\n#ifdef _WIN32\n    const int64_t max_file_size = offset + length;\n    const auto file_mapping_handle = ::CreateFileMapping(\n            file_handle,\n            0,\n            mode == access_mode::read ? PAGE_READONLY : PAGE_READWRITE,\n            win::int64_high(max_file_size),\n            win::int64_low(max_file_size),\n            0);\n    if(file_mapping_handle == invalid_handle)\n    {\n        error = detail::last_error();\n        return {};\n    }\n    char* mapping_start = static_cast<char*>(::MapViewOfFile(\n            file_mapping_handle,\n            mode == access_mode::read ? FILE_MAP_READ : FILE_MAP_WRITE,\n            win::int64_high(aligned_offset),\n            win::int64_low(aligned_offset),\n            length_to_map));\n    if(mapping_start == nullptr)\n    {\n        // Close file handle if mapping it failed.\n        ::CloseHandle(file_mapping_handle);\n        error = detail::last_error();\n        return {};\n    }\n#else // POSIX\n    char* mapping_start = static_cast<char*>(::mmap(\n            0, // Don't give hint as to where to map.\n            length_to_map,\n            mode == access_mode::read ? PROT_READ : PROT_WRITE,\n            MAP_SHARED,\n            file_handle,\n            aligned_offset));\n    if(mapping_start == MAP_FAILED)\n    {\n        error = detail::last_error();\n        return {};\n    }\n#endif\n    mmap_context ctx;\n    ctx.data = mapping_start + offset - aligned_offset;\n    ctx.length = length;\n    ctx.mapped_length = length_to_map;\n#ifdef _WIN32\n    ctx.file_mapping_handle = file_mapping_handle;\n#endif\n    return ctx;\n}\n```\n\n## 核心操作：mmap\n\nmmap 返回 `MAP_FAILED` 时，才写入 errno。\n\n# CSV库中的bug\n有时会返回错误码：134。\n\n\n```cpp\n        CSV_INLINE void MmapParser::next(size_t bytes = ITERATION_CHUNK_SIZE) {\n            // Reset parser state\n            this->field_start = UNINITIALIZED_FIELD;\n            this->field_length = 0;\n            this->reset_data_ptr();\n\n            // Create memory map\n            size_t length = std::min(this->source_size - this->mmap_pos, bytes);\n            std::error_code error;\n            this->data_ptr->_data = std::make_shared<mio::basic_mmap_source<char>>(mio::make_mmap_source(this->_filename, this->mmap_pos, length, error));\n            this->mmap_pos += length;\n            if (error) throw error;\n\n            auto mmap_ptr = (mio::basic_mmap_source<char>*)(this->data_ptr->_data.get());\n            // ...\n```\n\n`make_shared`一句，做了以下事情：\n1. 用`make_mmap_source`生成一个：只读的`char`类型映射。把这个映射对象用共享指针包装。\n\n在构造 mmap 时， error 可能 出现的情况只有 3 种：\n1. `handle == invalid_handle`：`error = std::make_error_code(std::errc::bad_file_descriptor)`：错误码 9\n2. `offset + length > file_size`：`error = std::make_error_code(std::errc::invalid_argument)`：错误码 22\n3. mmap 失败。`error = detail::last_error()`。即 返回 上一个（最后一个）errno。实测，错误码 134。\n\n```cpp\n/**\n * Returns the last platform specific system error (errno on POSIX and\n * GetLastError on Win) as a `std::error_code`.\n */\ninline std::error_code last_error() noexcept\n{\n    std::error_code error;\n#ifdef _WIN32\n    error.assign(GetLastError(), std::system_category());\n#else\n    error.assign(errno, std::system_category());\n#endif\n    return error;\n}\n```\n\n# Linux 134 错误码 不是 errno 值 而是 进程退出状态码\n\n在 Linux 系统中，系统调用通常通过 errno 返回错误。但错误码 **134** 不是标准的 errno 值。\n134 更可能是**进程退出状态码**。当进程被信号终止时，退出码是 **128 加上 信号编号**。\n134 减去 128 等于 6，对应的信号是 SIGABRT 信号。\n这意味着进程可能调用了 `abort()`，或者触发了断言失败、内存分配错误等导致 libc 终止进程。\n\n`glibc` 检测到堆内存损坏（如 `double free` 、缓冲区溢出）、调用 `abort()` 、某些安全机制如 `FORTIFY_SOURCE` 检测到缓冲区溢出、或者 `pthread` 线程相关错误。\n\n当程序因调用 `mmap` 或其他原因终止并返回退出状态码 **134** 时，这 **通常不是 `mmap` 系统调用直接设置的 `errno`**，而是表示你的进程收到了一个特定的信号并被该信号终止。\n\n**退出状态码 134 的含义：**\n\n*   在 Unix/Linux 系统中，如果一个进程是被信号 (Signal) 终止的，它的退出状态码是 `128 + <signal_number>`。\n*   `134 = 128 + 6`\n*   **信号编号 6 是 `SIGABRT`。**\n\n**因此，退出码 134 意味着进程收到了 `SIGABRT` 信号并因此终止。**\n## SIGABRT 信号\n**`SIGABRT` 信号的常见原因：**\n\n`SIGABRT` 通常由程序自身主动触发，表明检测到了严重的内部错误，无法安全地继续运行。最常见的原因包括：\n\n1.  **堆损坏 (Heap Corruption)：** 这是最常见的原因之一。标准库 (如 glibc) 在检测到堆内存被破坏时，会调用 `abort()` 发出 `SIGABRT`。具体错误包括：\n    *   **Double Free：** 尝试释放一个已经释放的内存块。\n    *   **Invalid Free：** 尝试释放一个不是通过 `malloc`/`calloc`/`realloc` 分配的内存地址（或已被释放）。\n    *   **Heap Buffer Overflow：** 写入操作超出了动态分配的内存块的边界，破坏了堆的管理结构。\n    *   **Heap Buffer Underflow：** 在动态分配的内存块起始位置之前进行写入。\n    *   **Freeing a Pointer Not at the Start of a Block：** 释放的指针不是指向分配块的确切起始位置（虽然某些分配器允许，但 glibc 的 `malloc` 通常要求精确的起始地址）。\n    *   **内存分配/释放函数内部的严重不一致：** 当 `malloc`, `free`, `realloc`, `calloc` 等函数内部数据结构出现严重问题时。\n\n2.  **显式调用 `abort()` 函数：** 程序代码或库代码中显式调用了 `abort()` 函数。这通常是为了响应无法恢复的严重错误条件。\n\n3.  **断言失败 (`assert` Macro)：** 如果程序使用了 `assert(condition)`，并且 `condition` 在运行时评估为 `false`，`assert` 会打印错误信息并调用 `abort()`。\n\n4.  **C++ 异常未被捕获：** 在 C++ 中，如果抛出的异常没有被任何 `catch` 块捕获，默认情况下会调用 `std::terminate()`，而 `std::terminate()` 的默认行为通常是调用 `abort()`。\n\n5.  **某些安全检查失败：**\n    *   **`_FORTIFY_SOURCE`:** 当使用 `-D_FORTIFY_SOURCE=2` (通常通过 `-O2` 或更高优化级别隐含启用) 编译时，glibc 会对一些标准库函数（如 `memcpy`, `strcpy`, `sprintf`）进行缓冲区溢出检查。如果检测到溢出，会调用 `abort()`。\n    *   **Stack Canary/Stack Smashing Protection (`-fstack-protector`)：** 如果编译器启用了栈保护机制，并在函数返回时检测到栈上的保护值（canary）被修改（表明发生了栈缓冲区溢出），它会调用 `__stack_chk_fail`，后者通常会调用 `abort()`。\n\n6.  **其他库的内部错误：** 第三方库（如加密库、图像处理库等）在遇到无法处理的严重错误时，也可能选择调用 `abort()`。\n\n\n**如何排查退出码 134 (SIGABRT)：**\n\n由于 `SIGABRT` 通常伴随着诊断信息，排查的关键在于捕获和分析这些信息：\n\n1.  **检查程序输出 (`stdout` & `stderr`)：**\n    *   **这是最重要的第一步！** `SIGABRT` 通常会在终止进程前将错误信息打印到标准错误 (`stderr`)。\n    *   **仔细查看程序崩溃时的终端输出。**\n    *   查找包含以下关键词的信息：\n        *   `Aborted (core dumped)`\n        *   `Error in ./your_program: ...`\n        *   `malloc(): corrupted ...`\n        *   `free(): invalid pointer ...`\n        *   `double free or corruption ...`\n        *   `stack smashing detected ...`\n        *   `buffer overflow detected ...`\n        *   `assertion failed: ...`\n    *   这些信息直接指出了错误的类型和位置（文件名和行号）。\n\n2.  **检查核心转储 (Core Dump)：**\n    *   如果系统配置允许生成核心转储（检查 `ulimit -c`，通常默认为 0 即不生成），崩溃时会生成一个 `core` 或 `core.<pid>` 文件。\n    *   使用调试器 (`gdb`) 加载程序和核心转储文件：\n        ```bash\n        gdb ./your_program core\n        ```\n    *   在 `gdb` 中：\n        *   输入 `bt` (backtrace) 查看崩溃时的调用堆栈。这能告诉你 `abort()` 是在哪里被调用的。\n        *   检查堆栈中各层函数的局部变量和参数。\n        *   如果错误信息指向了具体的堆问题（如 `malloc`/`free` 错误），堆栈跟踪有助于定位是哪个分配/释放操作导致了问题。\n    *   **启用核心转储：**\n        *   临时：`ulimit -c unlimited` (在当前 shell 会话中生效)。\n        *   永久：修改 `/etc/security/limits.conf` 或发行版特定的配置文件（如 Ubuntu 的 `/etc/systemd/coredump.conf`）。\n\n3.  **使用内存调试工具：**\n    *   **Valgrind (Memcheck)：** 这是检测内存错误（非法访问、泄漏、非法释放等）的金标准。在程序前加上 `valgrind` 运行：\n        ```bash\n        valgrind --leak-check=full ./your_program\n        ```\n        Valgrind 会详细报告内存错误的位置和原因。\n    *   **AddressSanitizer (ASan)：** 编译时加入 `-fsanitize=address -g` 标志（GCC/Clang）。ASan 在运行时检测内存错误（堆栈缓冲区溢出、全局变量溢出、use-after-free 等），并提供非常精确的错误报告和堆栈跟踪，通常比 Valgrind 更快。\n        ```bash\n        gcc -g -fsanitize=address -o your_program your_program.c\n        ./your_program\n        ```\n    *   **UndefinedBehaviorSanitizer (UBSan)：** 编译时加入 `-fsanitize=undefined -g`，检测未定义行为（如空指针解引用、有符号整数溢出等），这些行为有时也会间接导致内存破坏。\n        ```bash\n        gcc -g -fsanitize=undefined -o your_program your_program.c\n        ./your_program\n        ```\n\n4.  **检查断言 (`assert`)：** 如果错误信息或堆栈跟踪指向了 `assert` 失败，检查失败的条件，理解为什么该条件在运行时未满足。\n\n5.  **审查代码：** 结合错误信息、堆栈跟踪和工具报告，仔细审查相关代码区域。特别注意：\n    *   动态内存的分配 (`malloc`, `calloc`, `realloc`, `new`) 和释放 (`free`, `delete`)。\n    *   数组和指针操作，确保没有越界访问。\n    *   字符串操作函数 (`strcpy`, `sprintf`, `strcat` 等)，优先使用安全版本 (`strncpy`, `snprintf`, `strncat`) 或确保边界安全。\n    *   可能抛出异常的 C++ 代码是否被正确捕获。\n\n**总结与 `mmap` 的关联：**\n\n虽然退出码 134 本身直接指向 `SIGABRT`（通常是内存错误或断言失败），而不是 `mmap` 的 `errno`，但问题**可能**与 `mmap` 的使用间接相关：\n\n1.  **内存覆盖：** 如果 `mmap` 映射的区域（尤其是使用 `MAP_FIXED`）意外覆盖了程序堆管理结构使用的内存区域，后续的 `malloc`/`free` 操作可能会破坏堆，最终导致 `SIGABRT`。\n2.  **访问越界：** 对 `mmap` 映射的内存区域进行越界读写（特别是写操作），可能会破坏：\n    *   堆内存（如果映射区域靠近堆）。\n    *   栈内存（如果映射区域靠近栈）。\n    *   其他映射区域或未映射区域（触发 `SIGSEGV` 或 `SIGBUS`，但严重破坏也可能间接导致后续 `SIGABRT`）。\n3.  **映射区域释放后使用：** 在 `munmap` 一个区域后，如果程序仍然尝试访问该区域，会触发 `SIGSEGV`。如果这种访问发生在堆管理函数内部或破坏了堆结构，也可能最终导致 `SIGABRT`。\n\n**因此，排查步骤应该是：**\n\n1.  **首要关注 `SIGABRT` 的直接原因：** 仔细分析程序崩溃时的输出、核心转储（如果有）和使用内存调试工具（Valgrind/ASan）的结果。这些通常会直接指出错误根源（如 double free, buffer overflow）。\n2.  **审查 `mmap` 的使用：** 在定位到大致问题区域后，检查该区域代码是否涉及 `mmap`。特别关注：\n    *   `mmap` 的参数是否正确？尤其是 `addr` (是否用了 `MAP_FIXED`?)、`length`、`offset`。\n    *   对映射区域的指针操作是否确保在 `[addr, addr + length - 1]` 范围内？\n    *   映射区域的生存期管理是否正确？是否在 `munmap` 后还尝试访问？\n    *   映射区域是否与堆/栈等重要区域重叠（可通过 `/proc/[pid]/maps` 检查）？\n\n通过结合分析 `SIGABRT` 的详细报告和仔细审查 `mmap` 相关的代码逻辑，你应该能够找到导致程序终止的根本原因。\n\n对应的是 **`EOWNERDEAD`**（Owner died）。以下是详细解释：\n\n---\n\n## 错误类型说明\n1. **错误名称**：`EOWNERDEAD`\n2. **含义**：  \n   此错误通常与 **进程间同步机制**（如共享内存中的互斥锁）相关。当一个进程持有锁时异常终止（如崩溃），其他进程尝试获取该锁时会触发此错误。它表示锁的持有者已死亡，锁状态可能处于不一致状态，需要恢复操作。\n\n3. **常见场景**：\n   - 使用 `pthread_mutex_lock` 或共享内存中的互斥锁时。\n   - 进程崩溃后，其他进程尝试获取该进程持有的锁。\n   - 需要调用 `pthread_mutex_consistent` 修复锁状态后才能继续使用。\n\n---\n\n### 如何验证？\n在 Linux 终端运行以下命令查看错误码定义：\n```bash\n$ errno 134\n```\n输出示例：\n```\nEOWNERDEAD 134  /* Owner died */\n```\n\n---\n\n## 解决方法：\n1. **检查锁的使用**：  \n   确保使用锁的进程有健壮的退出处理逻辑（如信号处理、资源释放）。\n2. **锁恢复机制**：  \n   如果使用 `pthread_mutex` 的 `robust` 属性（`PTHREAD_MUTEX_ROBUST`），需在获取锁后检查错误码：\n   ```c\n   int err = pthread_mutex_lock(&mutex);\n   if (err == EOWNERDEAD) {\n       // 1. 使锁恢复一致状态\n       pthread_mutex_consistent(&mutex);\n       // 2. 执行数据恢复逻辑\n   }\n   ```\n3. **避免资源泄漏**：  \n   确保进程崩溃前释放锁（例如通过 `atexit` 注册清理函数）。\n\n---\n\n### 其他可能的高位错误码：\nLinux 错误码通常较小（如 `ENOENT=2`）。若遇到 **大于 133** 的错误码（如 134），通常是：\n- **实时扩展错误**（定义在 `<errno.h>`）：如 `EOWNERDEAD` (134)、`ENOTRECOVERABLE` (135)。\n- **特定于同步机制**：与进程间通信（IPC）、线程或共享内存相关。\n\n---\n\n### 总结：\n| 错误码 | 名称         | 原因与场景                     |\n|--------|--------------|-------------------------------|\n| 134    | `EOWNERDEAD` | 锁的持有者进程已终止，需恢复锁状态。 |\n\n建议检查代码中是否有未处理的进程崩溃或锁恢复逻辑缺失。\n\n# mmap 底层 Linux 内核代码\n\n`/usr/include/sys/mman.h`\n\n找 `MAP_FAILED` 字眼。\n\n```cpp\n/* Return value of `mmap' in case of an error.  */\n#define MAP_FAILED\t((void *) -1)\n\n__BEGIN_DECLS\n/* Map addresses starting near ADDR and extending for LEN bytes.  from\n   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR\n   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is\n   set in FLAGS, the mapping will be at ADDR exactly (which must be\n   page-aligned); otherwise the system chooses a convenient nearby address.\n   The return value is the actual mapping address chosen or MAP_FAILED\n   for errors (in which case `errno' is set).  A successful `mmap' call\n   deallocates any previous mapping for the affected region.  */\n\n#ifndef __USE_FILE_OFFSET64\nextern void *mmap (void *__addr, size_t __len, int __prot,\n\t\t   int __flags, int __fd, __off_t __offset) __THROW;\n#else\n# ifdef __REDIRECT_NTH\nextern void * __REDIRECT_NTH (mmap,\n\t\t\t      (void *__addr, size_t __len, int __prot,\n\t\t\t       int __flags, int __fd, __off64_t __offset),\n\t\t\t      mmap64);\n# else\n#  define mmap mmap64\n# endif\n#endif\n#ifdef __USE_LARGEFILE64\nextern void *mmap64 (void *__addr, size_t __len, int __prot,\n\t\t     int __flags, int __fd, __off64_t __offset) __THROW;\n#endif\n```\n\n# 详解内存映射系统调用 mmap\n```cpp\n#include <sys/mman.h>\nvoid* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);\n\n// 内核文件：/arch/x86/kernel/sys_x86_64.c\nSYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,\n  unsigned long, prot, unsigned long, flags,\n  unsigned long, fd, unsigned long, off)\n```\n\n调用 mmap 进行匿名映射的时候（比如进行堆内存的分配），是将进程虚拟内存空间中的某一段虚拟内存区域与物理内存中的匿名内存页进行映射，\n调用 mmap 进行文件映射的时候，是将进程虚拟内存空间中的某一段虚拟内存区域与磁盘中某个文件中的某段区域进行映射。\n\n![](../../images/量化交易_mio库与csv库/image-20250925191855231.png)\n\n在文件映射与匿名映射这段虚拟内存区域中，包含了一段一段的虚拟映射区，每当我们调用一次 mmap 进行内存映射的时候，内核都会在文件映射与匿名映射区中划分出一段虚拟映射区出来，这段虚拟映射区就是我们申请到的虚拟内存。\n\n## mmap 的 前 2 个参数：addr、 length\naddr ：表示我们要映射的这段虚拟内存区域在进程虚拟内存空间中的起始地址（虚拟内存地址），但是这个参数只是给内核的一个暗示，内核并非一定得从我们指定的 addr 虚拟内存地址上划分虚拟内存区域，内核只不过在划分虚拟内存区域的时候会优先考虑我们指定的 addr，如果这个虚拟地址已经被使用或者是一个无效的地址，那么内核则会自动选取一个合适的地址来划分虚拟内存区域。我们一般会将 addr 设置为 NULL，意思就是完全交由内核来帮我们决定虚拟映射区的起始地址。\n\nlength ：要申请的这段虚拟内存有多大呢 ？如果是匿名映射，length 参数决定了我们要映射的匿名物理内存有多大，如果是文件映射，length 参数决定了我们要映射的文件区域有多大。\n\n> addr，length 必须要按照 PAGE_SIZE（4K） 对齐。\n\n![](../../images/量化交易_mio库与csv库/image-20250925192405212.jpeg)\n\n如果我们通过 mmap 映射的是磁盘上的一个文件，那么就需要通过参数 fd 来指定要映射文件的描述符（file descriptor），通过参数 offset 来指定文件映射区域在文件中偏移。\n\n在内存管理系统中，物理内存是按照内存页为单位组织的；\n在文件系统中，磁盘中的文件是按照磁盘块为单位组织的。\n\n内存页和磁盘块大小一般情况下都是 4K 大小，所以这里的 offset 也必须是按照 4K 对齐的。\n## 虚拟映射对象的结构体\n而在文件映射与匿名映射区中的这一段一段的虚拟映射区，其实本质上也是虚拟内存区域，它们和进程虚拟内存空间中的代码段，数据段，BSS 段，堆，栈没有任何区别，\n在内核中都是 `struct vm_area_struct` 结构来表示的，下面我们把进程空间中的这些虚拟内存区域统称为 VMA。\n\n进程虚拟内存空间中的所有 VMA 在内核中有两种组织形式：一种是双向链表，用于高效的遍历进程 VMA，这个 VMA 双向链表是有顺序的，所有 VMA 节点在双向链表中的排列顺序是按照虚拟内存低地址到高地址进行的。\n\n另一种则是用红黑树进行组织，用于在进程空间中高效的查找 VMA，因为在进程虚拟内存空间中不仅仅是只有代码段，数据段，BSS 段，堆，栈这些虚拟内存区域 VMA，尤其是在数据密集型应用进程中，文件映射与匿名映射区里也会包含有大量的 VMA，进程的各种动态链接库所映射的虚拟内存在这里，进程运行过程中进行的匿名映射，文件映射所需要的虚拟内存也在这里。而内核需要频繁地对进程虚拟内存空间中的这些众多 VMA 进行增，删，改，查。所以需要这么一个红黑树结构，方便内核进行高效的查找。\n\n\n```cpp\n// 进程虚拟内存空间描述符\nstruct mm_struct {\n    // 串联组织进程空间中所有的 VMA  的双向链表 \n    struct vm_area_struct *mmap;  /* list of VMAs */\n    // 管理进程空间中所有 VMA 的红黑树\n    struct rb_root mm_rb;\n}\n\n// 虚拟内存区域描述符\nstruct vm_area_struct {\n    // vma 在 mm_struct->mmap 双向链表中的前驱节点和后继节点\n    struct vm_area_struct *vm_next, *vm_prev;\n    // vma 在 mm_struct->mm_rb 红黑树中的节点\n    struct rb_node vm_rb;\n}\n```\n\n![](../../images/量化交易_mio库与csv库/image-20250925192856271.png)\n\n## 内核代码\n`mmap()` 库调用由 libc 实现，它将字节偏移量转换为页面偏移量，然后调用 `mmap_pgoff()` 系统调用。`mmap_opgoff()` 系统调用获取与文件描述符参数对应的 `struct file *`，并调用 `vm_mmap_pgoff()`。\n\n# gdb 调试\n```\n[INFO] filename: TA2601.csv.xz\n[New Thread 0x7ffff77ff640 (LWP 1376157)]\n[Thread 0x7ffff77ff640 (LWP 1376157) exited]\n[New Thread 0x7ffff77ff640 (LWP 1376167)]\n[Thread 0x7ffff77ff640 (LWP 1376167) exited]\n[New Thread 0x7ffff77ff640 (LWP 1376168)]\n[Thread 0x7ffff77ff640 (LWP 1376168) exited]\n[New Thread 0x7ffff77ff640 (LWP 1376169)]\n[Thread 0x7ffff77ff640 (LWP 1376169) exited]\n[New Thread 0x7ffff77ff640 (LWP 1376177)]\n[Thread 0x7ffff77ff640 (LWP 1376177) exited]\n[New Thread 0x7ffff77ff640 (LWP 1376178)]\nterminate called after throwing an instance of 'std::error_code'\n\nThread 7 \"cmpmd5xz_O0\" received signal SIGABRT, Aborted.\n[Switching to Thread 0x7ffff77ff640 (LWP 1376178)]\n0x00007ffff788bedc in __pthread_kill_implementation () from /lib64/libc.so.6\n```\n\n\n```\n(gdb) thread apply all bt full\n\nThread 7 (Thread 0x7ffff77ff640 (LWP 1376178) \"cmpmd5xz_O0\"):\n#0  0x00007ffff788bedc in __pthread_kill_implementation () from /lib64/libc.so.6\nNo symbol table info available.\n#1  0x00007ffff783eb46 in raise () from /lib64/libc.so.6\nNo symbol table info available.\n#2  0x00007ffff7828833 in abort () from /lib64/libc.so.6\nNo symbol table info available.\n#3  0x00007ffff7cb2e64 in __gnu_cxx::__verbose_terminate_handler () at ../../../../libstdc++-v3/libsupc++/vterminate.cc:95\n        terminating = true\n        t = <optimized out>\n#4  0x00007ffff7cc505a in __cxxabiv1::__terminate (handler=<optimized out>) at ../../../../libstdc++-v3/libsupc++/eh_terminate.cc:48\nNo locals.\n#5  0x00007ffff7cb29ee in std::terminate () at ../../../../libstdc++-v3/libsupc++/eh_terminate.cc:58\nNo locals.\n#6  0x00007ffff7cc52f8 in __cxxabiv1::__cxa_throw (obj=<optimized out>, tinfo=0x5555555c44b0 <typeinfo for std::error_code>, dest=0x0) at ../../../../libstdc++-v3/libsupc++/eh_throw.cc:98\n        globals = <optimized out>\n        header = 0x7ffff296ece0\n#7  0x0000555555563b1c in csv::internals::MmapParser::next(unsigned long) [clone .cold] ()\nNo symbol table info available.\n#8  0x0000555555595976 in csv::CSVReader::read_csv(unsigned long) ()\nNo symbol table info available.\n#9  0x00007ffff7cf2ea4 in std::execute_native_thread_routine (__p=0x55555591ad20) at ../../../../../libstdc++-v3/src/c++11/thread.cc:104\n        __t = <optimized out>\n#10 0x00007ffff788a19a in start_thread () from /lib64/libc.so.6\nNo symbol table info available.\n#11 0x00007ffff790f240 in clone3 () from /lib64/libc.so.6\nNo symbol table info available.\n\nThread 1 (Thread 0x7ffff7e8a740 (LWP 1376141) \"cmpmd5xz_O0\"):\n#0  0x00007ffff78976c9 in _int_free () from /lib64/libc.so.6\nNo symbol table info available.\n#1  0x00007ffff789a2c5 in free () from /lib64/libc.so.6\nNo symbol table info available.\n#2  0x00005555555a1d7a in std::_Sp_counted_ptr_inplace<csv::internals::RawCSVData, std::allocator<void>, (__gnu_cxx::_Lock_policy)2>::_M_dispose() ()\nNo symbol table info available.\n#3  0x0000555555596315 in csv::CSVReader::read_row(csv::CSVRow&) ()\nNo symbol table info available.\n#4  0x000055555559a5b1 in csv::CSVReader::iterator::operator++() ()\nNo symbol table info available.\n#5  0x0000555555565e4c in main (argc=3, argv=0x7fffffffcee8) at cmp_md5_xz.cpp:198\n        row = @0x7fffffffb688: {data = {<std::__shared_ptr<csv::internals::RawCSVData, (__gnu_cxx::_Lock_policy)2>> = {<std::__shared_ptr_access<csv::internals::RawCSVData, (__gnu_cxx::_Lock_policy)2, false, false>> = {<No data fields>}, _M_ptr = 0x7ffff296e240, _M_refcount = {_M_pi = 0x7ffff296e230}}, <No data fields>}, data_start = 9999776, fields_start = 1972448, row_length = 32}\n        __for_range = @0x7fffffffb7f0: {_format = {possible_delimiters = {<std::_Vector_base<char, std::allocator<char> >> = {_M_impl = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, <std::_Vector_base<char, std::allocator<char> >::_Vector_impl_data> = {_M_start = 0x5555555e0ac0 \",|\\t;^U\", _M_finish = 0x5555555e0ac1 \"|\\t;^U\", _M_end_of_storage = 0x5555555e0ac5 \"U\"}, <No data fields>}}, <No data fields>}, trim_chars = {<std::_Vector_base<char, std::allocator<char> >> = {_M_impl = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, <std::_Vector_base<char, std::allocator<char> >::_Vector_impl_data> = {_M_start = 0x0, _M_finish = 0x0, _M_end_of_storage = 0x0}, <No data fields>}}, <No data fields>}, header = 0, no_quote = false, quote_char = 34 '\"', col_names = {<std::_Vector_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {_M_impl = {<std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<std::__new_allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >> = {<No data fields>}, <No data fields>}, <std::_Vector_base<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator\n<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >::_Vector_impl_data> = {_M_start = 0x0, _M_finish = 0x0, _M_end_of_storage = 0x0}, <No data fields>}}, <No data fields>}, variable_column_policy = csv::VariableColumnPolicy::IGNORE_ROW}, col_names = {<std::__shared_ptr<csv::internals::ColNames, (__gnu_cxx::_Lock_policy)2>> = {<std::__shared_ptr_access<csv::internals::ColNames, (__gnu_cxx::_Lock_policy)2, false, false>> = {<No data fields>}, _M_ptr = 0x5555555d87b0, _M_refcount = {_M_pi = 0x5555555d87a0}}, <No data fields>}, parser = {_M_t = {<std::__uniq_ptr_impl<csv::internals::IBasicCSVParser, std::default_delete<csv::internals::IBasicCSVParser> >> = {_M_t = {<std::_Tuple_impl<0, csv::internals::IBasicCSVParser*, std::default_delete<csv::internals::IBasicCSVParser> >> = {<std::_Tuple_impl<1, std::default_delete<csv::internals::IBasicCSVParser> >> = {<std::_Head_base<1, std::default_delete<csv::internals::IBasicCSVParser>, true>> = {_M_head_impl = {<No data fields>}}, <No data fields>}, <std::_Head_base<0, csv::internals::IBasicCSVParser*, false>> = {_M_head_impl = 0x5555564b4e80}, <No data fields>}, <No data fields>}}, <No data fields>}}, records = {_M_t = {<std::__uniq_ptr_impl<csv::internals::ThreadSafeDeque<csv::CSVRow>, std::default_delete<csv::internals::ThreadSafeDeque<csv::CSVRow> > >> = {_M_t = {<std::_Tuple_impl<0, csv::internals::ThreadSafeDeque<csv::CSVRow>*, std::default_delete<csv::internals::ThreadSafeDeque<csv::CSVRow> > >> = {<std::_Tuple_impl<1, std::default_delete<csv::internals::ThreadSafeDeque<csv::CSVRow> > >> = {<std::_Head_base<1, std::default_delete<csv::internals::ThreadSafeDeque<csv::CSVRow> >, true>> = {_M_head_impl = {<No data fields>}}, <No data fields>}, <std::_Head_base<0, csv::internals::ThreadSafeDeque<csv::CSVRow>*, false>> = {_M_head_impl = 0x5555555e00e0}, <No data fields>}, <No data fields>}}, <No data fields>}}, n_cols = 32, _n_rows = 61639, header_trimmed = true, read_csv_worker = {_M_id = {_M_thread = 140737345746496}}}\n        __for_begin = {daddy = 0x7fffffffb7f0, row = {data = {<std::__shared_ptr<csv::internals::RawCSVData, (__gnu_cxx:\n:_Lock_policy)2>> = {<std::__shared_ptr_access<csv::internals::RawCSVData, (__gnu_cxx::_Lock_policy)2, false, false>> = {<No data fields>}, _M_ptr = 0x7ffff296e240, _M_refcount = {_M_pi = 0x7ffff296e230}}, <No data fields>}, data_start = 9999776, fields_start = 1972448, row_length = 32}, i = 0}\n        __for_end = {daddy = 0x0, row = {data = {<std::__shared_ptr<csv::internals::RawCSVData, (__gnu_cxx::_Lock_policy)2>> = {<std::__shared_ptr_access<csv::internals::RawCSVData, (__gnu_cxx::_Lock_policy)2, false, false>> = {<No data fields>}, _M_ptr = 0x0, _M_refcount = {_M_pi = 0x0}}, <No data fields>}, data_start = 0, fields_start = 0, row_length = 0}, i = 0}\n        line_number = 0\n        tmd = {_M_t = {_M_impl = {<std::allocator<std::_Rb_tree_node<std::pair<long const, MarketDataDepth5> > >> = {<std::__new_allocator<std::_Rb_tree_node<std::pair<long const, MarketDataDepth5> > >> = {<No data fields>}, <No data fields>}, <std::_Rb_tree_key_compare<std::less<long> >> = {_M_key_compare = {<std::binary_function<long, long, bool>> = {<No data fields>}, <No data fields>}}, <std::_Rb_tree_header> = {_M_header = {_M_color = std::_S_red, _M_parent = 0x555555769380, _M_left = 0x5555555db2a0, _M_right = 0x555556437c70}, _M_node_count = 78287}, <No data fields>}}}\n        bmd = {_M_t = {_M_impl = {<std::allocator<std::_Rb_tree_node<std::pair<long const, MarketDataDepth5> > >> = {<std::__new_allocator<std::_Rb_tree_node<std::pair<long const, MarketDataDepth5> > >> = {<No data fields>}, <No data fields>}, <std::_Rb_tree_key_compare<std::less<long> >> = {_M_key_compare = {<std::binary_function<long, long, bool>> = {<No data fields>}, <No data fields>}}, <std::_Rb_tree_header> = {_M_header = {_M_color = std::_S_red, _M_parent = 0x55555673b310, _M_left = 0x5555564b5450, _M_right = 0x555556f83590}, _M_node_count = 61614}, <No data fields>}}}\n        bfs = {<std::basic_istream<char, std::char_traits<char> >> = {<std::basic_ios<char, std::char_traits<char> >> = {<std::ios_base> = {_vptr.ios_base = 0x7ffff7e76dc8 <vtable for std::basic_ifstream<char, std::char_traits<char> >+64>, static boolalpha = std::_S_boolalpha, static dec = std::_S_dec, static fixed = std::_S_fixed, static hex = std::_S_hex, static internal = std::_S_internal, static left = std::_S_left, static oct = std::_S_oct, static right = std::_S_right, static scientific = std::_S_scientific, static showbase = std::_S_showbase, static showpoint = std::_S_showpoint, static showpos = std::_S_showpos, static skipws = std::_S_skipws, static unitbuf = std::_S_unitbuf, static uppercase = std::_S_uppercase, static adjustfield = std::_S_adjustfield, static basefield = std::_S_basefield, static floatfield = std::_S_floatfield, static badbit = std::_S_badbit, static eofbit = std::_S_eofbit, static failbit = std::_S_failbit, static goodbit = std::_S_goodbit, static app = std::_S_app, static ate = std::_S_ate, static binary = std::_S_bin, static in = std::_S_in, static out = std::_S_out, static trunc = std::_S_trunc, static __noreplace = std::_S_noreplace, static beg = std::_S_beg, static cur = std::_S_cur, static end = std::_S_end, _M_precision = 6, _M_width = 0, _M_flags = 4098, _M_exception = std::_S_goodbit, _M_streambuf_state = std::_S_goodbit, _M_callbacks = 0x0, _M_word_zero = {_M_pword = 0x0, _M_iword = 0}, _M_local_word = {{_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}}, _M_word_size = 8, _M_word = 0x7fffffffbd10, _M_ios_locale = {static none = 0, static ctype = 1, static numeric = 2, static collate = 4, static time = 8, static monetary = 16, static messages = 32, static all = 63, _M_impl = 0x7ffff7e80080 <(anonymous namespace)::c_locale_impl>}}, _M_tie = 0x0, _M_fill = 32 ' ', _M_fill_init = true, _M_streambuf = 0x7fffffffbbe0, _M_ctype = 0x7ffff7e7faa0 <(anonymous namespace)::ctype_c>, _M_num_put = 0x7ffff7e7fa30 <(anonymous namespace)::num_put_c>, _M_num_get = 0x7ffff7e7fa40 <(anonymous namespace)::num_get_c>}, _vptr.basic_istream = 0x7ffff7e76da0 <vtable for std::basic_ifstream<char, std::char_traits<char> >+24>, _M_gcount = 0}, _M_filebuf = {<std::basic_streambuf<char, std::char_traits<char> >> = {_vptr.basic_streambuf = 0x7ffff7e76ca8 <vtable for std::basic_filebuf<char, std::char_traits<char> >+16>, _M_in_beg = 0x555556437d30 \"θ,\\023V(\\037\\220X\\267m#\\323\\322\\326Z\\317oUJ\\262fٜ\\254>;P*\\267\\263\\003\\303\\322\\030\\226\\226\\276\\005U\\247i\\257)\\230\\001/\\037\\314G8\\314\\342\\201:>\\0275\\357ɐ\\220\\3269\\253\\207ld\\223>\\027\\251s5\\004߰\\001\\355\\342=\\\\\\264S\\026\\350v&\\034\\231<\\243E\\335\\r'^\\266M[\\341\\334O\\242n\\233N\\bF\\3634!\\243J\\3338\\025`\\304ɀ\\260\\314Ĭ\\277.\\343E\\365xI[0\\243\\355ޔ\\375\\021Y\\017\\223\\257\\222\\271\\rf\", _M_in_cur = 0x555556437d30 \"θ,\\023V(\\037\\220X\\267m#\\323\\322\\326Z\\317oUJ\\262fٜ\\254>;P*\\267\\263\\003\\303\\322\\030\\226\\226\\276\\005U\\247i\\257)\\230\\001/\\037\\314G8\\314\\342\\201:>\\0275\\357ɐ\\220\\3269\\253\\207ld\\223>\\027\\251s5\\004߰\\001\\355\\342=\\\\\\264S\\026\\350v&\\034\\231<\\243E\\335\\r'^\\266M[\\341\\334O\\242n\\233N\\bF\\3634!\\243J\\3338\\025`\\304ɀ\\260\\314Ĭ\\277.\\343E\\365xI[0\\243\\355ޔ\\375\\021Y\\017\\223\\257\\222\\271\\rf\", _M_in_end = 0x555556437d30 \"θ,\\023V(\\037\\220X\\267m#\\323\\322\\326Z\\317oUJ\\262fٜ\\254>;P*\\267\\263\\003\\303\\322\\030\\226\\226\\276\\005U\\247i\\257)\\230\\001/\\037\\314G8\\314\\342\\201:>\\0275\\357ɐ\\220\\3269\\253\\207ld\\223>\\027\\251s5\\004߰\\001\\355\\342=\\\\\\264S\\026\\350v&\\034\\231<\\243E\\335\\r'^\\266M[\\341\\334O\\242n\\233N\\bF\\3634!\\243J\\3338\\025`\\304ɀ\\260\\314Ĭ\\277.\\343E\\365xI[0\\243\\355ޔ\\375\\021Y\\017\\223\\257\\222\\271\\rf\", _M_out_beg = 0x0, _M_out_cur = 0x0, _M_out_end = 0x0, _M_buf_locale = {static none = 0, static ctype = 1, static numeric = 2, static collate = 4, static time = 8, static monetary = 16, static messages = 32, static all = 63, _M_impl = 0x7ffff7e80080 <(anonymous namespace)::c_locale_impl>}}, _M_lock = {__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 0, __spins = 0, __elision = 0, __list = {__prev = 0x0, __next = 0x0}}, __size = '\\000' <repeats 39 times>, __align = 0}, _M_file = {_M_cfile = 0x7ffff2fefbc0, _M_cfile_created = true}, _M_mode = 12, _M_state_beg = {__count = 0, __value = {__wch = 0, __wchb = \"\\000\\000\\000\"}}, _M_state_cur = {__count = 0, __value = {__wch = 0, __wchb = \"\\000\\000\\000\"}}, _M_state_last = {__count = 0, __value = {__wch = 0, __wchb = \"\\000\\000\\000\"}}, _M_buf = 0x555556437d30 \"θ,\\023V(\\037\\220X\\267m#\\323\\322\\326Z\\317oUJ\\262fٜ\\254>;P*\\267\\263\\003\\303\\322\\030\\226\\226\\276\\005U\\247i\\257)\\230\\001/\\037\\314G8\\314\\342\\201:>\\0275\\357ɐ\\220\\3269\\253\\207ld\\223>\\027\\251s5\\004߰\\001\\355\\342=\\\\\\264S\\026\\350v&\\034\\231<\\243E\\335\\r'^\\266M[\\341\\334O\\242n\\233N\\bF\\3634!\\243J\\3338\\025`\\304ɀ\\260\\314Ĭ\\277.\\343E\\365xI[0\\243\\355ޔ\\375\\021Y\\017\\223\\257\\222\\271\\rf\", _M_buf_size = 8192, _M_buf_allocated = true, _M_reading = false, _M_writing = false, _M_pback = 0 '\\000', _M_pback_cur_save = 0x0, _M_pback_end_save = 0x0, _M_pback_init = false, _M_codecvt = 0x7ffff7e7fa10 <(anonymous namespace)::codecvt_c>, _M_ext_buf = 0x0, _M_ext_buf_size = 0, _M_ext_next = 0x0, _M_ext_end = 0x0}}\n        bin = {<boost::iostreams::detail::filtering_stream_base<boost::iostreams::chain<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char> >, boost::iostreams::public_>> = {<boost::iostreams::access_control<boost::iostreams::detail::chain_client<boost::iostreams::chain<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char> > >, boost::iostreams::public_, boost::iostreams::detail::pub_<boost::iostreams::detail::chain_client<boost::iostreams::chain<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char> > > > >> = {<boost::iostreams::detail::pub_<boost::iostreams::detail::chain_client<boost::iostreams::chain<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char> > > >> = {<boost::iostreams::detail::chain_client<boost::iostreams::chain<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char> > >> = {_vptr.chain_client = 0x5555555c3760 <vtable for boost::iostreams::filtering_stream<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char>, boost::iostreams::public_>+24>, chain_ = 0x7fffffffb8b0}, <No data fields>}, <No data fields>}, <std::basic_istream<char, std::char_traits<char> >> = {<std::basic_ios<char, std::char_traits<char> >> = {<std::ios_base> = {_vptr.ios_base = 0x5555555c37b8 <vtable for boost::iostreams::filtering_stream<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char>, boost::iostreams::public_>+112>, static boolalpha = std::_S_boolalpha, static dec = std::_S_dec, static fixed = std::_S_fixed, static hex = std::_S_hex, static internal = std::_S_internal, static left = std::_S_left, static oct = std::_S_oct, static right = std::_S_right, static scientific = std::_S_scientific, static showbase = std::_S_showbase, static showpoint = std::_S_showpoint, static showpos = std::_S_showpos, static skipws = std::_S_skipws, static unitbuf = std::_S_unitbuf, static uppercase = std::_S_uppercase, static adjustfield = std::_S_adjustfield, static basefield = std::_S_basefield, static floatfield = std::_S_floatfield, static badbit = std::_S_badbit, static eofbit = std::_S_eofbit, static failbit = std::_S_failbit, static goodbit = std::_S_goodbit, static app = std::_S_app, static ate = std::_S_ate, static binary = std::_S_bin, static in = std::_S_in, static out = std::_S_out, static trunc = std::_S_trunc, static __noreplace = std::_S_noreplace, static beg = std::_S_beg, static cur = std::_S_cur, static end = std::_S_end, _M_precision = 6, _M_width = 0, _M_flags = 4098, _M_exception = std::_S_goodbit, _M_streambuf_state = std::_S_goodbit, _M_callbacks = 0x0, _M_word_zero = {_M_pword = 0x0, _M_iword = 0}, _M_local_word = {{_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}}, _M_word_size = 8, _M_word = 0x7fffffffb900, _M_ios_locale = {static none = 0, static ctype = 1, static numeric = 2, static collate = 4, static time = 8, static monetary = 16, static messages = 32, static all = 63, _M_impl = 0x7ffff7e80080 <(anonymous namespace)::c_locale_impl>}}, _M_tie = 0x0, _M_fill = 32 ' ', _M_fill_init = true, _M_streambuf = 0x5555555db450, _M_ctype = 0x7ffff7e7faa0 <(anonymous namespace)::ctype_c>, _M_num_put = 0x7ffff7e7fa30 <(anonymous namespace)::num_put_c>, _M_num_get = 0x7ffff7e7fa40 <(anonymous namespace)::num_get_c>}, _vptr.basic_istream = 0x5555555c3790 <vtable for boost::iostreams::filtering_stream<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char>, boost::iostreams::public_>+72>, _M_gcount = 0}, chain_ = {<boost::iostreams::detail::chain_base<boost::iostreams::chain<boost::iostreams::input, char, std::char_traits<char>, std::allocator<char> >, char, std::char_traits<char>, std::allocator<char>, boost::iostreams::input>> = {pimpl_ = {px = 0x7ffff00ff8d0, pn = {pi_ = 0x5555555dcbd0}}}, <No data fields>}}, <No data fields>}\n        bof = {<std::basic_ostream<char, std::char_traits<char> >> = {<std::basic_ios<char, std::char_traits<char> >> = {<std::ios_base> = {_vptr.ios_base = 0x7ffff7e76e88 <vtable for std::basic_ofstream<char, std::char_traits<char> >+64>, static boolalpha = std::_S_boolalpha, static dec = std::_S_dec, static fixed = std::_S_fixed, static hex = std::_S_hex, static internal = std::_S_internal, static left = std::_S_left, static oct = std::_S_oct, static right = std::_S_right, static scientific = std::_S_scientific, static showbase = std::_S_showbase, static showpoint = std::_S_showpoint, static showpos = std::_S_showpos, static skipws = std::_S_skipws, static unitbuf = std::_S_unitbuf, static uppercase = std::_S_uppercase, static adjustfield = std::_S_adjustfield, static basefield = std::_S_basefield, static floatfield = std::_S_floatfield, static badbit = std::_S_badbit, static eofbit = std::_S_eofbit, static failbit = std::_S_failbit, static goodbit = std::_S_goodbit, static app = std::_S_app, static ate = std::_S_ate, static binary = std::_S_bin, static in = std::_S_in, static out = std::_S_out, static trunc = std::_S_trunc, static __noreplace = std::_S_noreplace, static beg = std::_S_beg, static cur = std::_S_cur, static end = std::_S_end, _M_precision = 6, _M_width = 0, _M_flags = 4098, _M_exception = std::_S_goodbit, _M_streambuf_state = std::_S_failbit, _M_callbacks = 0x0, _M_word_zero = {_M_pword = 0x0, _M_iword = 0}, _M_local_word = {{_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}, {_M_pword = 0x0, _M_iword = 0}}, _M_word_size = 8, _M_word = 0x7fffffffbb08, _M_ios_locale = {static none = 0, static ctype = 1, static numeric = 2, static collate = 4, static time = 8, static monetary = 16, static messages = 32, static all = 63, _M_impl = 0x7ffff7e80080 <(anonymous namespace)::c_locale_impl>}}, _M_tie = 0x0, _M_fill = 32 ' ', _M_fill_init = true, _M_streambuf = 0x7fffffffb9d8, _M_ctype = 0x7ffff7e7faa0 <(anonymous namespace)::ctype_c>, _M_num_put = 0x7ffff7e7fa30 <(anonymous namespace)::num_put_c>, _M_num_get = 0x7ffff7e7fa40 <(anonymous namespace)::num_get_c>}, _vptr.basic_ostream = 0x7ffff7e76e60 <vtable for std::basic_ofstream<char, std::char_traits<char> >+24>}, _M_filebuf = {<std::basic_streambuf<char, std::char_traits<char> >> = {_vptr.basic_streambuf = 0x7ffff7e76ca8 <vtable for std::basic_filebuf<char, std::char_traits<char> >+16>, _M_in_beg = 0x0, _M_in_cur = 0x0, _M_in_end = 0x0, _M_out_beg = 0x0, _M_out_cur = 0x0, _M_out_end = 0x0, _M_buf_locale = {static none = 0, static ctype = 1, static numeric = 2, static collate = 4, static time = 8, static monetary = 16, static messages = 32, static all = 63, _M_impl = 0x7ffff7e80080 <(anonymous namespace)::c_locale_impl>}}, _M_lock = {__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 0, __spins = 0, __elision = 0, __list = {__prev = 0x0, __next = 0x0}}, __size = '\\000' <repeats 39 times>, __align = 0}, _M_file = {_M_cfile = 0x0, _M_cfile_created = true}, _M_mode = 0, _M_state_beg = {__count = 0, __value = {__wch = 0, __wchb = \"\\000\\000\\000\"}}, _M_state_cur = {__count = 0, __value = {__wch = 0, __wchb = \"\\000\\000\\000\"}}, _M_state_last = {__count = 0, __value = {__wch = 0, __wchb = \"\\000\\000\\000\"}}, _M_buf = 0x0, _M_buf_size = 8192, _M_buf_allocated = false, _M_reading = false, _M_writing = false, _M_pback = 0 '\\000', _M_pback_cur_save = 0x0, _M_pback_end_save = 0x0, _M_pback_init = false, _M_codecvt = 0x7ffff7e7fa10 <(anonymous namespace)::codecvt_c>, _M_ext_buf = 0x0, _M_ext_buf_size = 0, _M_ext_next = 0x0, _M_ext_end = 0x0}}\n        tstpath = {static preferred_separator = 47 '/', _M_pathname = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x5555555e0f90 \"/home/fdata/raw/tick/CZCE/depth5/20250821/TA2601.csv.xz\"}, _M_string_length = 55, {_M_local_buf = \"T\", '\\000' <repeats 14 times>, _M_allocated_capacity = 84}}, _M_cmpts = {_M_impl = {_M_t = {<std::__uniq_ptr_impl<std::filesystem::__cxx11::path::_List::_Impl, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {_M_t = {<std::_Tuple_impl<0, std::filesystem::__cxx11::path::_List::_Impl*, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {<std::_Tuple_impl<1, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {<std::_Head_base<1, std::filesystem::__cxx11::path::_List::_Impl_deleter, true>> = {_M_head_impl = {<No data fields>}}, <No data fields>}, <std::_Head_base<0, std::filesystem::__cxx11::path::_List::_Impl*, false>> = {_M_head_impl = 0x5555555e0ff0}, <No data fields>}, <No data fields>}}, <No data fields>}}}}\n        benpath = {static preferred_separator = 47 '/', _M_pathname = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x5555555d8f10 \"/home/fdata/raw/tick/MDC/depth5/20250821/TA2601.csv.xz\"}, _M_string_length = 54, {_M_local_buf = \"R\", '\\000' <repeats 14 times>, _M_allocated_capacity = 82}}, _M_cmpts = {_M_impl = {_M_t = {<std::__uniq_ptr_impl<std::filesystem::__cxx11::path::_List::_Impl, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {_M_t = {<std::_Tuple_impl<0, std::filesystem::__cxx11::path::_List::_Impl*, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {<std::_Tuple_impl<1, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {<std::_Head_base<1, std::filesystem::__cxx11::path::_List::_Impl_deleter, true>> = {_M_head_impl = {<No data fields>}}, <No data fields>}, <std::_Head_base<0, std::filesystem::__cxx11::path::_List::_Impl*, false>> = {_M_head_impl = 0x5555555d8f70}, <No data fields>}, <No data fields>}}, <No data fields>}}}}\n        f = @0x5555555e4c30: {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x5555555e4c40 \"TA2601.csv.xz\"}, _M_string_length = 13, {_M_local_buf = \"TA2601.csv.xz\\000\\000\", _M_allocated_capacity = 7146703741821010260}}\n        __for_range = @0x7fffffffb5f0: {_M_t = {_M_impl = {<std::allocator<std::_Rb_tree_node<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<std::__new_allocator<std::_Rb_tree_node<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {<No data fields>}, <No data fields>}, <std::_Rb_tree_key_compare<std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >> = {_M_key_compare = {<std::binary_function<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool>> = {<No data fields>}, <No data fields>}}, <std::_Rb_tree_header> = {_M_header = {_M_color = std::_S_red, _M_parent = 0x5555555e1510, _M_left = 0x5555555e5520, _M_right = 0x5555555e4350}, _M_node_count = 241}, <No data fields>}}}\n        __for_begin = {_M_node = 0x5555555e4c10}\n        __for_end = {_M_node = 0x7fffffffb5f8}\n        exchange = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x7fffffffbef0 \"CZCE\"}, _M_string_length = 4, {_M_local_buf = \"CZCE\\000\\000\\000\\000@d\\032\\001\\000\\000\\000\", _M_allocated_capacity = 1162041923}}\n        date = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x7fffffffbed0 \"20250821\"}, _M_string_length = 8, {_M_local_buf = \"20250821\\000\\355\\372\\367\\377\\177\\000\", _M_allocated_capacity = 3544957636396068914}}\n        bendir = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x5555555d8650 \"/home/fdata/raw/tick/MDC/depth5/20250821/\"}, _M_string_length = 41, {_M_local_buf = \"P\", '\\000' <repeats 14 times>, _M_allocated_capacity = 80}}\n        tstdir = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x5555555d86e0 \"/home/fdata/raw/tick/CZCE/depth5/20250821/\"}, _M_string_length = 42, {_M_local_buf = \"<\\000\\000\\000\\000\\000\\000\\000p\\276\\377\\377\\377\\177\\000\", _M_allocated_capacity = 60}}\n        mktopen = 20250821090000000\n        eod = 20250821150000000\n        son = 20250821210000000\n        temp_path = {static preferred_separator = 47 '/', _M_pathname = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x5555555d8810 \"/tmp/tempfile_1759759482756864030\"}, _M_string_length = 33, {_M_local_buf = \"!\\000\\000\\000\\000\\000\\000\\000\\000\\364\\374\\367\\377\\177\\000\", _M_allocated_capacity = 33}}, _M_cmpts = {_M_impl = {_M_t = {<std::__uniq_ptr_impl<std::filesystem::__cxx11::path::_List::_Impl, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {_M_t = {<std::_Tuple_impl<0, std::filesystem::__cxx11::path::_List::_Impl*, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {<std::_Tuple_impl<1, std::filesystem::__cxx11::path::_List::_Impl_deleter>> = {<std::_Head_base<1, std::filesystem::__cxx11::path::_List::_Impl_deleter, true>> = {_M_head_impl = {<No data fields>}}, <No data fields>}, <std::_Head_base<0, std::filesystem::__cxx11::path::_List::_Impl*, false>> = {_M_head_impl = 0x5555555d8840}, <No data fields>}, <No data fields>}}, <No data fields>}}}}\n        tempfile = {_M_dataplus = {<std::allocator<char>> = {<std::__new_allocator<char>> = {<No data fields>}, <No data fields>}, _M_p = 0x5555555d86b0 \"/tmp/tempfile_1759759482756864030\"}, _M_string_length = 33, {_M_local_buf = \"!\\000\\000\\000\\000\\000\\000\\000>)\\375\\367\\377\\177\\000\", _M_allocated_capacity = 33}}\n```","categories":["量化交易"]},{"title":"Cpp_Google代码规范","url":"/Cpp/Cpp_Google代码规范/","content":"文章：https://google.github.io/styleguide/cppguide.html\n源码：https://github.com/google/styleguide/blob/gh-pages/cppguide.html\n\nauthor: Chenggong Xing\ndate: 2025/9/10\n# 头文件、include相关\n## Self-contained Headers\n自包含是什么意思：一个 `.h` 头文件应该​​独立编译​​（即 `#include` 它自身就能编译通过，不会报错）。\n\n### 非自包含头文件\n存在一些​​罕见情况​​，需要创建一些​​设计上就不是自包含​​的文件，它们的目的就是被 `#include` 到其他文件中。\n要包含的非自包含头文件应以`.inc`结尾，并谨慎使用。\n\n特点：\n1. 可能没有`#ifndef #define`守卫：因为它们可能被设计成在同一个文件中多次包含（例如，用于代码生成或宏展开）。\n2. 不包含自身依赖：它们假设包含它们的文件（通常是 .cc或另一个 .h）已经提供了必要的上下文（如包含了所需的头文件、定义了必要的宏等）。\n3. 依赖包含位置：它们通常需要被包含在特定的位置（例如，在另一个文件的中间，而不是顶部）\n## `#ifndef #define`守卫\n符号名称的格式应是`<PROJECT>_<PATH>_<FILE>_H_`。\n为了保证唯一性，应该基于项目源代码树中的完整路径。例如，项目`foo`中的文件`foo/src/bar/baz.h`，应该这么写：\n```cpp\n#ifndef FOO_BAR_BAZ_H_\n#define FOO_BAR_BAZ_H_\n\n...\n\n#endif  // FOO_BAR_BAZ_H_\n```\n## 不要依赖传递`#include`\nbar.h\n```cpp\n// bar.h\n#ifndef BAR_H\n#define BAR_H\nclass Bar {\n    // ... Bar 的成员 ...\n};\n#endif // BAR_H\n```\nfoo.h\n```cpp\n// foo.h\n#ifndef FOO_H\n#define FOO_H\n\n#include \"bar.h\" // 当前 foo.h 需要 Bar 来声明 useBar 的参数\n\nvoid useBar(const Bar& b); // 声明使用 Bar\n\n#endif // FOO_H\n```\nfoo.cc\n```cpp\n// foo.cc (错误写法：依赖 foo.h 包含 bar.h)\n#include \"foo.h\" // 指望 foo.h 已经包含了 bar.h\n\nvoid useBar(const Bar& b) {\n    // ... 使用 b (Bar 对象) ...\n}\n```\n导致的问题：如果将来`foo.h`中删除了`#include \"bar.h\"`，那么还需要在`foo.cc`添加`#include \"bar.h\"`，导致牵一发动全身。\n\n正确写法：\n```cpp\n// foo.cc (正确写法：显式包含 bar.h)\n#include \"foo.h\"\n#include \"bar.h\" // 显式包含，因为直接使用了 Bar\n\nvoid useBar(const Bar& b) {\n    // ... 使用 b (Bar 对象) ...\n}\n```\n这保证了 `foo.h`的修改（清理不必要的 `#include`）不会意外破坏 `foo.cc`的编译。每个文件都清晰地声明了自己的直接依赖。\n## 避免前置声明，最好用include代替\n避免使用前置声明，而是 include 需要的头文件。\n\n​**​核心观点：尽量避免使用前置声明，优先使用 `#include` 包含所需的头文件。​**​\n\n​**​什么是前置声明 (Forward Declaration)?​**​\n- ​**​定义：​**​ 前置声明是指在代码中​**​声明​**​某个实体（如类、函数、变量、模板等）的存在，但​**​不提供其完整定义​**​。\n- ​**​目的：​**​ 告诉编译器这个符号的名字和类型（对于函数和变量），但不需要知道其内部细节（如类的成员、函数的实现、变量的值等）。\n- ​**​示例：​**​\n    \n    ```cpp\n    class MyClass;      // 类的前置声明 (告诉编译器 MyClass 是一个类)\n    void myFunction();  // 函数的前置声明\n    extern int myVar;    // 变量的前置声明 (通常用于全局变量)\n    ```\n    \n\n### ​Pros (优点/好处 - 为什么有人想用前置声明)​​\n规范列举了使用前置声明可能带来的好处，但请注意，规范的整体立场是​**​不推荐​**​使用，所以这些优点更像是解释为什么开发者有时会倾向于使用它：\n1. ​**​节省编译时间：​**​ `#include` 会让编译器打开并处理被包含文件的所有内容（可能又包含更多文件）。使用前置声明可以避免这些开销，特别是当包含的头文件很大或嵌套很深时。\n2. ​**​减少不必要的重新编译：​**​ 如果一个头文件被修改了，所有直接或间接包含它的源文件都需要重新编译。如果一个头文件 `A.h` 包含了 `B.h`，那么修改 `B.h` 会导致包含 `A.h` 的所有文件都重编。如果 `A.h` 只用了 `B.h` 中的某个类指针或引用，并且改用前置声明 `class B;` 而不是 `#include \"B.h\"`，那么修改 `B.h` 的某些细节（比如 `B` 类的私有成员）可能​**​不会​**​触发 `A.h` 及其包含者的重编译。这可以加快增量编译速度。\n### ​Cons (缺点/坏处 - 为什么 Google 规范不推荐使用)​\n\n规范详细列举了前置声明的诸多弊端，这也是其建议避免使用的主要原因：\n1. ​**​隐藏依赖关系：​**​ 这是最核心的问题。前置声明使得代码的依赖关系变得不清晰。源文件 `foo.cc` 使用了 `class Bar`，但只通过前置声明 `class Bar;` 引入，而没有 `#include \"bar.h\"`。当 `bar.h` 发生改变（比如 `Bar` 类的大小、成员函数签名变化）时，编译器可能​**​无法意识到​**​ `foo.cc` 需要重新编译，导致链接错误或更糟糕的运行时错误。这破坏了构建系统的可靠性。\n2. ​**​阻碍自动化工具：​**​ 代码分析工具、重构工具、IDE 的智能提示等，需要知道符号的完整定义才能正常工作。前置声明使得这些工具难以确定符号的实际定义位置。\n3. ​**​限制 API 的兼容性变更：​**​ 库的维护者如果想做一些理论上兼容的修改，可能会因为用户代码使用了前置声明而受阻。例如：\n    - 加宽函数参数类型（如 `int` -> `long`）。\n    - 给模板添加一个有默认值的模板参数。\n    - 将符号移动到新的命名空间。  \n        这些修改对于包含完整头文件的用户代码是兼容的，但对于仅使用前置声明的用户代码，可能导致编译失败或行为改变，因为前置声明没有捕捉到这些变化。\n4. ​**​`std::` 命名空间的前置声明导致未定义行为：​**​ C++ 标准明确规定，不允许用户代码前置声明标准库 (`std::`) 中的模板或其他实体。这样做会导致​**​未定义行为 (Undefined Behavior)​**​，程序可能编译失败、运行崩溃或产生不可预测的结果。必须 `#include` 相应的标准库头文件（如 `<vector>`, `<string>`）。\n5. ​**​可能静默改变代码含义：​**​ 这是一个非常微妙且危险的陷阱。规范中的代码示例清晰地展示了这一点：\n    - 在包含完整头文件 `b.h` 的情况下，`test(D*)` 调用 `f(B*)`，因为 `D*` 可以隐式转换为 `B*`。\n    - 如果 `good_user.cc` 把 `#include \"b.h\"` 换成 `class B; class D;`（前置声明），那么 `test(D*)` 会调用 `f(void*)`！因为编译器只知道 `B` 和 `D` 是类类型，但不知道它们之间的继承关系，所以 `D*` 无法隐式转换为 `B*`，只能匹配 `f(void*)`。这种行为的改变是静默发生的，很难调试。\n6. ​**​语法冗长：​**​ 如果需要前置声明一个头文件中的多个符号，写一堆 `class X; void Y();` 可能比直接写一个 `#include \"that_header.h\"` 更冗长。\n7. ​**​可能导致次优设计：​**​ 为了能够使用前置声明（例如，在头文件中只使用类指针或引用，避免使用对象成员），开发者可能会被迫采用特定的代码结构（如多用指针、使用 Pimpl 惯用法）。这些结构有时会使代码运行速度变慢（额外的间接访问、堆分配）或增加代码的复杂性（需要管理指针生命周期、实现 Pimpl）。\n### ​Decision (决策/结论)​​\n- ​**​核心原则：​**​ ​**​尽可能避免使用前置声明。​**​ 优先使用 `#include` 来包含定义了你所需符号的头文件。\n- ​**​关键限制：​**​ ​**​尤其要避免对另一个项目中定义的实体使用前置声明。​**​ 这里的“项目”可以理解为不同的库、模块或代码仓库。跨项目的前置声明极大地加剧了上述缺点（特别是隐藏依赖和限制 API 变更），因为项目间的协调和同步更困难。\n- ​**​隐含建议：​**​ 在同一个项目内部，如果经过仔细权衡（比如某个头文件改动极其频繁且影响巨大），并且能严格确保依赖清晰、不会引入第 3 点和第 5 点的问题，或许可以​**​极其谨慎地​**​在源文件（`.cc`）中使用前置声明来减少编译依赖。但这需要非常高的警惕性。规范的整体倾向仍然是 `#include` 更安全、更推荐。\n### ​总结​\nGoogle C++ 规范认为，虽然前置声明在理论上可以带来编译速度的提升，但其带来的风险（隐藏依赖、破坏构建可靠性、阻碍工具、限制库演化、潜在未定义行为、静默语义改变）远大于收益。因此，规范强烈建议开发者优先使用 `#include` 来明确表达依赖关系，保证代码的健壮性、可维护性和工具友好性，尤其是在跨项目协作时。\n### 其他注意的点\n不要声明任何一个属于std命名空间的内容，包括标准库类的前置声明。要声明标准库中的实体，请包含适当的头文件。\n## 在头文件中定义函数的注意事项\n​**​核心观点：​**​ 尽量避免在头文件的 ​**​公共 API 声明部分​**​ 直接定义函数体。如果函数定义​**​必须​**​放在头文件中（例如短小的访问器、模板函数、`constexpr` 函数），应将其放在头文件的​**​内部实现部分​**​（如私有区、特定命名空间或注释标记之后），并确保其 ​**​ODR-safe​**​（通常通过 `inline` 关键字、模板或类内定义实现）。\n### ​关键概念解释​\n1. ​**​文本内联 (Textually inline)：​**​ 指函数的定义（实现代码）直接写在它的声明处。\n2. ​**​内联展开 (Inline expansion)：​**​ 编译器优化技术，将函数调用处直接替换为函数体代码，避免函数调用的开销（压栈、跳转、返回）。这通常发生在函数体简单且被频繁调用时。\n3. ​**​ODR (One Definition Rule - 单一定义规则)：​**​ C++ 核心规则，要求在整个程序中，任何变量、函数、类类型、枚举类型或模板，​**​最多只能有一个定义​**​（某些情况如 `inline` 函数/变量、模板、类类型定义等允许在多个翻译单元中存在定义，但必须完全相同）。\n4. ​**​ODR-safe：​**​ 指在头文件中定义的实体（如函数、变量），通过使用 `inline` 关键字（或符合隐式 `inline` 的条件），使其在多个 `.cpp` 文件包含该头文件时，链接器不会因违反 ODR（出现多个相同定义）而报错。\n### ​​Pros (优点/好处 - 为什么有时需要在头文件中定义函数)​​\n规范承认在特定情况下，在头文件中定义函数有其合理性和优势：\n1. ​**​减少样板代码 (Reduce boilerplate)：​**​ 对于非常简单的函数（如类的 `getter/setter`），直接在类声明中定义比在头文件声明、再到 `.cc` 文件定义要简洁得多。\n2. ​**​潜在的优化机会 (Potential optimization)：​**​ 编译器更容易对在头文件中定义的小函数进行内联展开优化，可能生成更高效的代码（省去函数调用开销）。\n3. ​**​技术必要性 (Technical necessity)：​**​ ​**​函数模板​**​和 ​**​`constexpr` 函数​**​ 通常​**​必须​**​在声明它们的头文件中定义（或者至少在同一个翻译单元中可见）。因为编译器在实例化模板或计算 `constexpr` 时需要看到完整的定义。这是语言特性决定的。\n### ​​Cons (缺点/坏处 - 为什么规范限制在公共部分定义函数)​​\n规范强调了在公共 API 部分（即用户一眼就能看到的地方）定义函数的弊端：\n1. ​**​降低 API 可读性 (Reduced API readability)：​**​ API 头文件的主要目的是清晰地展示接口（有哪些函数、参数、返回值）。将函数实现细节混杂其中，会增加阅读和理解 API 的难度和认知负担。函数越复杂，这种干扰越大。\n2. ​**​暴露实现细节 (Exposes implementation details)：​**​ 将函数体放在公共头文件中，相当于把内部实现逻辑公开了。这些细节通常对 API 使用者来说是无关紧要的（“无害但多余”），甚至可能暴露你不想让用户依赖的内部机制。\n### ​​Decision (决策/规则)​​\n基于优缺点分析，规范制定了明确的规则：\n1. ​**​长度限制 (Length restriction)：​**​\n    - 只有​**​非常短​**​的函数（规范建议大约 ​**​10 行或更少​**​），才允许直接在它的​**​公共声明点​**​（如在类定义的 `public:` 部分）定义。\n    - ​**​长函数体​**​应该放在 `.cc` 文件中定义，除非有​**​性能原因​**​（编译器内联优化至关重要）或​**​技术原因​**​（如模板、`constexpr`）。\n2. ​**​位置隔离 (Location isolation)：​**​\n    - 即使函数定义​**​必须​**​放在头文件中（例如，它是一个模板成员函数），也​**​不应该​**​放在公共 API 部分（如 `public:` 或文件顶部）。\n    - 应该将定义放在头文件的​**​内部实现区域​**​：\n        - 类的 `private:` 部分（即使函数本身是 `public` 的）。\n        - 一个包含 `internal` 字样的命名空间内（例如 `namespace myproject_internal { ... }`）。\n        - 在明确的注释标记之后（例如 `// Implementation details follow` 或 `// Implementation details only below here`）。\n    - ​**​目的：​**​ 将实现细节与公共接口​**​物理分离​**​，提高公共头文件的可读性和整洁度。\n3. ​**​ODR 安全 (ODR safety)：​**​\n    - 任何在头文件中定义的函数（或变量），​**​必须​**​确保它是 ​**​ODR-safe​**​ 的。这意味着当多个 `.cpp` 文件包含该头文件时，链接器不会报“多重定义”错误。\n    - 实现 ODR-safe 的常用方法：\n        - 显式使用 `inline` 关键字修饰函数/变量定义。\n        - 函数是​**​函数模板​**​。\n        - 函数是​**​类成员函数​**​，并且是​**​在类定义内部直接定义的​**​（这是隐式 `inline` 的）。\n        - 函数是 `constexpr` (C++11 起，`constexpr` 函数在头文件中定义默认是 `inline` 的)。\n        - 变量是 `inline` 变量 (C++17 起) 或 `constexpr` 变量。\n### ​代码示例解析\n```cpp\ntemplate <typename T>\nclass Foo\n{\npublic:\n  // 短函数 (getter)，直接在公共声明点定义 -> 允许 (短 + 隐式 inline)\n  int bar() { return bar_; }\n\n  // 长函数声明。定义不能放在这里污染公共接口。\n  void MethodWithHugeBody();\n\nprivate:\n  int bar_;\n};\n\n// Implementation details only below here\n// **************** 内部实现区域分隔线 ****************\n\n// 长函数定义放在这里 (头文件内部实现区域)\ntemplate <typename T>\nvoid Foo<T>::MethodWithHugeBody()\n{\n  ... // 可能很长的实现代码\n}\n```\n- `bar()`：是一个简单的 `getter` 函数，非常短（一行）。它直接在类定义的 `public:` 部分定义。这是允许的，因为它短小，并且作为类内定义的成员函数，它是​**​隐式 `inline`​**​ 的（满足 ODR-safe）。\n- `MethodWithHugeBody()`：声明在 `public:` 部分（它是公共接口）。但它的​**​定义​**​被移到了类定义之后、用注释明确标记的​**​内部实现区域​**​。这样保证了公共接口的清晰。因为它是一个​**​模板成员函数​**​，所以它的定义​**​必须​**​在头文件中（技术必要性），并且模板本身保证了 ODR-safe。\n### ​​总结​\nGoogle C++ 规范主张保持头文件（尤其是公共 API 部分）的​**​简洁和声明性​**​。函数实现细节应尽量放在 `.cc` 文件中。如果必须在头文件中定义函数（短函数、模板、`constexpr`），应将其放在专门的内部区域，并确保其 ODR-safe。这样做的主要目的是​**​提高代码的可读性、可维护性，并清晰地分离接口与实现​**​。\n\n## include的名称和顺序\n1. 不要用`./`、`../`，应该列为项目源目录的后代，比如`project/src/base/logging.h`应包含为`#include \"base/logging.h\"`\n### 尖括号\n仅当库要求你这么做时，才去使用尖括号路径包含标头。\n1. C和`C++`标准库头文件。例如`<stdlib.h>`、`<string>`\n2. POSIX、Linux、Windows 系统头文件，例如`<unistd.h>`、`<windows.h>`\n3. 第三方库，在极少数情况下：如`<Python.h>`\n### include顺序\n在 `dir/foo.cc` 或 `dir/foo_test.cc` ，其主要目的是实现或测试 `dir2/foo2.h` ，包含顺序如下：\n1. `dir2/foo2.h`\n2. 一个空白行\n3. C 系统头文件，以及尖括号中的任何其他头文件 `.h` 扩展名，例如 `<unistd.h>` ， `<stdlib.h>` 、 `<Python.h>` 。\n4. 一个空白行\n5. C++ 标准库头文件（不带文件扩展名），例如， `<algorithm>` ， `<cstddef>` 。\n6. 一个空白行\n7. 其他库的`.h`文件。\n8. 一个空白行\n9. 项目自己的 `.h` 文件。\n\n在每个部分内部，包含顺序应按字母顺序排序。\n\n使用这个顺序后，如果相关头文件如 `dir2/foo2.h` 省略了任何必要的includes，那么`dir/foo.cc` 的构建 或 `dir/foo_test.cc` 将中断。因此，此规则确保构建中断首先显示给处理这些文件的人，而不是其他包中的无辜者。\n\n示例\n```cpp\n#include \"foo/server/fooserver.h\"\n\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <string>\n#include <vector>\n\n#include \"base/basictypes.h\"\n#include \"foo/server/bar.h\"\n#include \"third_party/absl/flags/flag.h\"\n```\n#### 例外\n有时，特定于系统的代码需要条件包含。这样的代码可以将条件包含放在其他包含之后。当然，请保持特定于系统的代码较小且本地化（localized）。例：\n```cpp\n#include \"foo/public/fooserver.h\"\n\n#ifdef _WIN32\n#include <windows.h>\n#endif  // _WIN32\n```\n### C头文件和C++头文件可以互换\nC 头文件（例如 `stddef.h）` 基本上可以与 C++ 对应物互换 （`cstddef`）。任何一种风格都是可以接受的，但最好与现有代码保持一致。\n# namespace相关\n除了少数例外，都要把代码放到命名空间中。\n命名空间的名字应该是基于项目名（多为路径）的唯一名称。\n\n\n在 includes、 gflags 定义/声明、前置声明之后，放置命名空间，将整个源文件包装。\n\n在命名空间结尾处，加注释标记。\n```cpp\nnamespace mynamespace {\n\n}  // namespace mynamespace\n```\n\n单行嵌套命名空间声明是新代码中的首选，但不是必需的。\n## using `::foo::Bar`的使用\n```cpp\n#include \"a.h\"\n\nABSL_FLAG(bool, someflag, false, \"a flag\");\n\nnamespace mynamespace {\n\nusing ::foo::Bar;\n\n...code for mynamespace...    // Code goes against the left margin.\n\n}  // namespace mynamespace\n```\n\n`using ::foo::Bar;`\n这条语句的意思是：在 `mynamespace` 这个命名空间内部，允许我直接使用 `Bar` 这个名字来指代 `::foo::Bar`。\n它​​不是​​将整个 `foo` 命名空间引入 `mynamespace`（那是 `using namespace foo;` 的作用），而是​​只引入 `Bar` 这一个特定的名字。\n\n为什么这样写？​​\n1. 代码简洁性：在 `mynamespace` 内部频繁使用 `::foo::Bar` 时，每次都写全名很冗长。`using ::foo::Bar;` 允许直接使用 `Bar` ，使代码更简洁易读。\n2. 明确来源：使用 ::foo::Bar而不是 foo::Bar是一种防御性编程。它明确指定了 foo命名空间位于全局命名空间，避免了可能存在的嵌套命名空间 `mynamespace::foo` 的歧义（如果存在的话）。`::`确保了引用的绝对是全局的 `foo`。\n3. 作用域限制：这个 `using` 声明只在 `mynamespace` 内部有效。它不会污染全局命名空间或其他命名空间。这是一种相对安全的引入方式。\n### using和（不要）using namespace的区别\nusing是引入命名空间下的一个符号。\nusing namespace是引入整个命名空间。\n\n**严禁**：不要用`using namespace xxx;`，这会污染命名空间。\n## 内联namespace（不要）\n不要用内联namespace。\n\n```cpp\nnamespace outer {\ninline namespace inner {\n  void foo();\n}  // namespace inner\n}  // namespace outer\n```\n这样的效果是：表达式 `outer::inner::foo()` 和 `outer::foo()` 是可以互换的。\n\n内联命名空间主要用于跨版本的 ABI 兼容性。\n## 仅在显式标记的内部空间中使用命名空间别名\n命名空间别名：\n```cpp\n// Remove uninteresting parts of some commonly used names in .cc files.\nnamespace sidetable = ::pipeline_diagnostics::sidetable;\n```\n\n```cpp\n// In a .h file, an alias must not be a separate API, or must be hidden in an\n// implementation detail.\nnamespace librarian {\n\nnamespace internal {  // Internal, not part of the API.\nnamespace sidetable = ::pipeline_diagnostics::sidetable;\n}  // namespace internal\n\ninline void my_inline_function() {\n  // Local to a function.\n  namespace baz = ::foo::bar::baz;\n  ...\n}\n\n}  // namespace librarian\n```\n## 使用名称带有internal的命名空间隔离API内部细节\n标记为 internal 的代码是供​​库或模块自身的开发者​​在实现公共 API 功能内部细节时使用的。\n​​库开发者（比如 Absl 维护者）可以在 Abseil 库自己的代码里使用 container_internal里的东西，但外部用户（non-absl code）绝对不应该在他们的代码里使用它。​\n它​​严格禁止​​被库的​​外部用户​​（即使用这个库的程序员）在他们的代码中直接引用或依赖。\n\n>absl指的是Abseil库，是 Google 开源的一套 C++ 核心库组件，提供了许多基础数据结构、工具和设施，旨在构建更健壮、更高效的 C++ 代码。\n\n请注意，嵌套内部命名空间中的库之间仍然存在冲突的风险，因此通过添加库的文件名，为命名空间中的每个库提供唯一的内部命名空间。例如，`gshoe/widget.h` 将使用 `gshoe::internal_widget` 而不是 `gshoe::internal`。\n\n## Internal Linkage（文件内部链接）: 匿名namespace和static\n限制符号（变量、函数、类等）的作用域，使其仅在单个 `.cc` 文件内可见​​。\n1. ​​内部链接 (Internal Linkage)：​​\n    - 指符号的链接属性，使得该符号​**​仅在定义它的翻译单元（通常就是一个 `.cc` 或 `.cpp` 源文件）内可见和可用​**​。\n    - 其他文件（翻译单元）即使知道该符号的名字，也无法访问或链接到它。\n    - 如果另一个文件定义了一个同名符号，它们是完全独立的两个实体，互不影响。\n2. ​​目的：​​\n    - ​**​封装与隔离：​**​ 将只在单个文件内部使用的辅助函数、变量、常量或类型隐藏起来，避免污染全局命名空间。\n    - ​**​避免命名冲突：​**​ 防止不同文件中的辅助符号（如 `helperFunction()`）因同名而发生链接错误或意外覆盖。\n    - ​**​编译优化：​**​ 编译器知道这些符号不会被外部引用，可能进行更好的优化。\n    - ​**​代码清晰：​**​ 明确标识出哪些符号是文件内部的实现细节。\n\n​实现内部链接的两种方式​：匿名 namespace 或 static 修饰\n1. 未命名命名空间 (Unnamed Namespaces / Anonymous Namespaces)：​**​\n    - 语法：`namespace { ... }`\n    - 效果：将定义在 `{ ... }` 内部的​**​所有符号​**​（类、函数、变量、类型别名等）赋予内部链接。这些符号的作用域被限制在​**​当前文件内​**​。\n    - ​**​格式要求：​**​ 像命名空间一样格式化，结尾注释写 `} // namespace`（空名）。\n    - ​**​现代 C++ 首选方式：​**​ 这是 C++ 标准推荐的方式，适用于所有类型的符号。\n\n匿名命名空间结尾也要有注释，`// namespace`\n```cpp\n// myfile.cc\nnamespace { // 开始未命名命名空间\n    int helperVariable = 42; // 内部链接，仅本文件可见\n\n    void helperFunction() { // 内部链接，仅本文件可调用\n        // ... do something ...\n    }\n\n    class InternalClass { // 内部链接，仅本文件可用\n        // ...\n    };\n}  // namespace (结束，无名)\n```\n    \n2. ​`static` 关键字：​​\n    - 语法：在函数或变量的声明前加 `static`。\n    - 效果：将​**​函数或全局变量​**​赋予内部链接。​**​不能用于类定义或类型别名。​**​\n    - ​**​传统方式：​**​ 在 C 和早期 C++ 中常用，但在现代 C++ 中，对于文件作用域的符号，未命名命名空间通常是更好的选择。\n    \n    ```cpp\n    // myfile.cc\n    static int helperVariable = 42; // 内部链接 (static 变量)\n    static void helperFunction() {  // 内部链接 (static 函数)\n        // ... do something ...\n    }\n    // static 不能用于类：static class InternalClass {}; // 错误！\n    ```\n### ​强调​：鼓励在cc文件中使用，禁止在h文件中使用\n1. ​**​在 `.cc` 文件中使用：​**\n    - ​**​强烈鼓励：​**​ 对于 `.cc` 文件中定义的、​**​不需要被其他 `.cc` 或 `.h` 文件引用​**​的任何符号（辅助函数、内部状态变量、实现类等），都应该使用​**​未命名命名空间​**​或 `static` (仅限函数/变量) 来赋予它们​**​内部链接​**​。这是最佳实践。\n2. ​**​禁止在 `.h` 文件中使用：​**​\n    - ​**​绝对不要​**​在头文件 (`.h`) 中使用未命名命名空间或 `static` 声明函数/变量。\n    - ​**​原因：​**​\n        - ​**​违反 ODR (单一定义规则)：​**​ 头文件会被多个 `.cc` 文件包含。如果头文件里有 `static int globalVar;`，那么每个包含该头文件的 `.cc` 文件都会获得一个​**​独立的、名为 `globalVar` 的副本​**​。这通常不是想要的效果，且可能导致内存浪费或逻辑错误。\n        - ​**​未命名命名空间同理：​**​ 每个包含该头文件的 `.cc` 文件都会有一个​**​独立的、内容相同但彼此隔离​**​的未命名命名空间副本。这同样违反 ODR 的意图（期望全局唯一），并可能导致奇怪的链接或运行时行为。\n        - ​**​头文件的目的是声明接口：​**​ 头文件应该声明那些需要被其他文件​**​使用​**​的符号（通常是外部链接）。内部实现细节不应该出现在公共头文件里。\n# 其他Scoping相关\n- [Nonmember, Static Member, and Global Functions](https://google.github.io/styleguide/cppguide.html#Nonmember,_Static_Member,_and_Global_Functions)\n- [Local Variables](https://google.github.io/styleguide/cppguide.html#Local_Variables)\n- [Static and Global Variables](https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables)\n- [thread_local Variables](https://google.github.io/styleguide/cppguide.html#thread_local)\n# 类相关\n- [Doing Work in Constructors](https://google.github.io/styleguide/cppguide.html#Doing_Work_in_Constructors)\n- [Implicit Conversions](https://google.github.io/styleguide/cppguide.html#Implicit_Conversions)\n- [Copyable and Movable Types](https://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types)\n- [Structs vs. Classes](https://google.github.io/styleguide/cppguide.html#Structs_vs._Classes)\n- [Structs vs. Pairs and Tuples](https://google.github.io/styleguide/cppguide.html#Structs_vs._Tuples)\n- [Inheritance](https://google.github.io/styleguide/cppguide.html#Inheritance)\n- [Operator Overloading](https://google.github.io/styleguide/cppguide.html#Operator_Overloading)\n- [Access Control](https://google.github.io/styleguide/cppguide.html#Access_Control)\n- [Declaration Order](https://google.github.io/styleguide/cppguide.html#Declaration_Order)\n# 函数相关\n- [Inputs and Outputs](https://google.github.io/styleguide/cppguide.html#Inputs_and_Outputs)\n- [Write Short Functions](https://google.github.io/styleguide/cppguide.html#Write_Short_Functions)\n- [Function Overloading](https://google.github.io/styleguide/cppguide.html#Function_Overloading)\n- [Default Arguments](https://google.github.io/styleguide/cppguide.html#Default_Arguments)\n- [Trailing Return Type Syntax](https://google.github.io/styleguide/cppguide.html#trailing_return)\n# C++特性相关\n- [Rvalue References](https://google.github.io/styleguide/cppguide.html#Rvalue_references)\n- [Friends](https://google.github.io/styleguide/cppguide.html#Friends)\n- [Exceptions](https://google.github.io/styleguide/cppguide.html#Exceptions)\n- [noexcept](https://google.github.io/styleguide/cppguide.html#noexcept)\n- [Run-Time Type Information (RTTI)](https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_)\n- [Casting](https://google.github.io/styleguide/cppguide.html#Casting)\n- [Streams](https://google.github.io/styleguide/cppguide.html#Streams)\n- [Preincrement and Predecrement](https://google.github.io/styleguide/cppguide.html#Preincrement_and_Predecrement)\n- [Use of const](https://google.github.io/styleguide/cppguide.html#Use_of_const)\n- [Use of constexpr, constinit, and consteval](https://google.github.io/styleguide/cppguide.html#Use_of_constexpr)\n- [Integer Types](https://google.github.io/styleguide/cppguide.html#Integer_Types)\n- [Floating-Point Types](https://google.github.io/styleguide/cppguide.html#Floating-Point_Types)\n- [Architecture Portability](https://google.github.io/styleguide/cppguide.html#Architecture_Portability)\n- [Preprocessor Macros](https://google.github.io/styleguide/cppguide.html#Preprocessor_Macros)\n- [0 and nullptr/NULL](https://google.github.io/styleguide/cppguide.html#0_and_nullptr/NULL)\n- [sizeof](https://google.github.io/styleguide/cppguide.html#sizeof)\n- [Type Deduction (including auto)](https://google.github.io/styleguide/cppguide.html#Type_deduction)\n- [Class Template Argument Deduction](https://google.github.io/styleguide/cppguide.html#CTAD)\n- [Designated Initializers](https://google.github.io/styleguide/cppguide.html#Designated_initializers)\n- [Lambda Expressions](https://google.github.io/styleguide/cppguide.html#Lambda_expressions)\n- [Template Metaprogramming](https://google.github.io/styleguide/cppguide.html#Template_metaprogramming)\n- [Concepts and Constraints](https://google.github.io/styleguide/cppguide.html#Concepts)\n- [C++20 modules](https://google.github.io/styleguide/cppguide.html#modules)\n- [Coroutines](https://google.github.io/styleguide/cppguide.html#coroutines)\n- [Boost](https://google.github.io/styleguide/cppguide.html#Boost)\n- [Disallowed standard library features](https://google.github.io/styleguide/cppguide.html#Disallowed_Stdlib)\n- [Nonstandard Extensions](https://google.github.io/styleguide/cppguide.html#Nonstandard_Extensions)\n- [Aliases](https://google.github.io/styleguide/cppguide.html#Aliases)\n- [Switch Statements](https://google.github.io/styleguide/cppguide.html#Switch_Statements)\n# 命名专题\n## 文件名（my_awesome_class）全小写，单词间可以用下划线连接\n\n可接受的文件名示例：\n```\nmy_useful_class.cc\nmy-useful-class.cc\nmyusefulclass.cc\nmyusefulclass_test.cc // _unittest and _regtest are deprecated.\n```\n首选：全小写，单词间可以用下划线连接\n### 代码文件扩展名\n`C++` 文件应具有 `.cc` 文件扩展名，头文件应具有 `.h` 扩展名。依赖于在特定点以文本方式包含的文件应以 `.inc` 结尾（另请参阅**自包含的标头** (Self-contained Headers)）。\n\n## 类型名（MyAwesomeClass）\n所有类型的名称（类、结构、类型别名、枚举和类型模板参数）都具有相同的命名约定。**类型名称应以大写字母开头，每个新单词都有一个大写字母**。没有下划线：`MyExcitingClass`、`MyExcitingEnum`。\n\n```cpp\n// classes and structs\nclass UrlTable { ...\nclass UrlTableTester { ...\nstruct UrlTableProperties { ...\n\n// typedefs\ntypedef hash_map<UrlTableProperties *, std::string> PropertiesMap;\n\n// using aliases\nusing PropertiesMap = hash_map<UrlTableProperties *, std::string>;\n\n// enums\nenum class UrlTableError { ...\n```\n\n## Concept 名称（同类型名称规则）\n## 变量名称（snake_case）\n1. 变量（包括函数参数）的名称是 `snake_case`（全部小写，单词之间带有下划线）。如：`a_local_variable`。\n2. 类的数据成员 （但不是结构体）还有尾随下划线。例如：`a_class_data_member_`。\n3. 结构体数据成员：`a_struct_data_member`。\n### Common 变量名称（snake_case）\nFor example:  例如：\n```cpp\nstd::string table_name;  // OK - snake_case.\n```\n\n```cpp\nstd::string tableName;   // Bad - mixed case.\n```\n### 类数据成员（`snake_case_`，右端尾随下划线）\n包括静态、非静态。都按照`snake_case_`。\n\n**静态常量**数据成员是例外，遵循“常量命名”规则。\n\n```cpp\nclass TableInfo {\n    public:\n    ...\n    static const int kTableVersion = 3;  // OK - constant naming.\n    ...\n    \n    private:\n    std::string table_name_;             // OK - underscore at end.\n    static Pool<TableInfo>* pool_;       // OK.\n};\n```\n\n### 结构体数据成员（同Common 变量名称，snake_case，右端没有尾随下划线）\n结构体的数据成员，包括静态和非静态，其命名方式与普通非成员变量类似。右端没有类数据成员那样的尾随下划线。\n\n```cpp\nstruct UrlTableProperties {\n    std::string name;\n    int num_entries;\n    static Pool<UrlTableProperties>* pool;\n};\n```\n\n### 拓展：结构体与类如何选择？\n结构体和类关键字在 C++ 中的行为几乎相同。\n#### 何时使用结构体\n何时使用结构体作为抽象：\n1. 仅对于**携带数据的被动对象**，\n2. 并且它可能具有关联的常量。\n3. 所有字段都必须是公共的。\n4. **结构体不得包含暗示不同字段间关系的不变量**。\n5. struct 也可以拥有函数，但这些函数的职责应仅限于​​数据本身的简单操作​​，\n    1. 例如初始化（构造函数）、清理（析构函数）、或打印数据。\n    2. 它们​​不应包含复杂的业务逻辑​​，也不能试图去保护和维持数据之间的隐藏关系（不变量）。\n\n什么是具有关联的常量？\nstruct内部除了数据成员，还可以定义与这些数据成员紧密相关的常量，例如枚举值或静态常量。这些常量用于描述或分类该数据结构，不破坏其**被动数据**的本质。\n示例：\n```cpp\nstruct Configuration {\n    // 数据成员\n    int resolutionWidth;\n    int resolutionHeight;\n    // 关联常量 - 用于描述或分类数据\n    enum Quality { Low, Medium, High };\n    Quality currentQuality;\n};\n```\n\n**结构体不得包含暗示不同字段间关系的不变量**是什么意思？\n**含义​**​：这是最核心的一条限制。“不变量”指的是对象在其生命周期内必须始终保持为真的​**​一种状态或关系​**​。\n例如，在一个 `class`中，`age`字段必须大于 0 就是一个典型的不变量。\n由于`struct`的字段都是公开的，使用者可能直接修改任意字段。如果字段之间存在某种隐含的依赖或关系（即“不变量”），就很容易破坏这种关系，导致数据状态不一致。\n\n反面示例：\n```cpp\n// 一个“账户” struct，其字段间存在强不变性约束：余额不能为负。\nstruct BadBankAccount {\n    double balance; // 余额\n    double overdraftLimit; // 透支额度\n    // 问题：用户可以直接修改 balance 为任意值，例如 -10000，\n    // 这直接破坏了“余额不能低于透支额度”的业务逻辑（不变量）。\n};\n```\n\n​**​STL 中的例外​**​：在标准模板库中，`struct`常被用于​**​无状态的类型​**​，如traits、模板元函数和仿函数，这是因为其默认的公有访问性更为方便。\n\n除了以上描述的 struct 的适用场景，其余情况都用类。\n\n**技术无差别，约定成俗​**​：从编译器角度看，`struct`和 `class`的唯一区别就是默认访问权限。所有其他的区别都是​**​程序员之间形成的约定​**​，旨在让代码更易读、更易维护。\n### 常量名称（kMyConstantVar）\n先说关键点：是否要用 k 前导，关键看对象的**存储期限类型**、以及**是否是常量**，如果两者都满足，才适用于用 k 前导。\n\n一个对象，**其值在程序期限内是固定的（编译期或生命周期内固定）**，以前导小写 `k` 命名，后跟大小写混合，以大写分隔单词，不带下划线。\n```cpp\nconst int kDaysInAWeek = 7;\n```\n如果后面的字是无法区分大小写的，那就用下划线作为分隔。\n```cpp\nconst int kAndroid8_0_0 = 24; // Android 8.0.0\n```\n#### k 代表的含义和 const 修饰无关\nconst 只保证 对象 的值 在一段期间是常量（比如一次函数调用期间），但不保证在整个程序周期内 不变。\n\n如果你确定整个程序周期内这个对象不变，那就可以用 k ，否则不要用。\n```cpp\nvoid ComputeFoo(absl::string_view suffix) {\n    // 两种方式都可以接受 (Either of these is acceptable)\n    const absl::string_view kPrefix = \"prefix\"; // 使用 kPrefix\n    const absl::string_view prefix = \"prefix\";  // 使用 prefix\n    ...\n}\n```\n#### 非常容易出错的点\n试图将一个​**​运行时才能确定的值​**​放入一个按规范应代表“编译期或生命周期内固定”的 `k`常量中。这是错误的，因为 **`k`命名的变量暗示其值是不可变的且每次调用都相同**。\n```cpp\nvoid ComputeFoo(absl::string_view suffix) {\n    // 错误示例 (Bad) - kCombined 的值会随着每次调用 ComputeFoo 时传入的 suffix 不同而不同！\n    const std::string kCombined = absl::StrCat(kPrefix, suffix);\n    ...\n}\n```\n#### 拓展：Storage Duration是什么？\nhttps://en.cppreference.com/w/cpp/language/storage_duration.html#Storage_duration\n存储期限是对象的属性，它定义了包含该对象的存储的最小潜在生存期。存储期限由用于创建对象的构造决定，并且是以下内容之一：\n1. static storage duration：静态存储期限\n    1. static 关键字\n2. thread storage duration (also known as thread-local storage duration)：线程本地存储期限\n    1. thread_local 关键字\n3. automatic storage duration：自动存储期限\n    1. auto 关键字（until `C++11`）\n4. dynamic storage duration：动态存储期限\n    1. 与 new 、 delete 相关\n\n静态 、线程本地、自动存储期限与声明引入的对象和临时对象相关联。\n动态存储期限与 new 表达式创建的对象或隐式创建的对象相关联。\n\n存储说明符：auto、register、static、thread_local、extern、mutable。\n\n## 函数名称（MyFunction）\n遵循大写字母开头，每个新单词都有一个大写字母分隔。\n```cpp\nAddTableEntry()\nDeleteUrl()\nOpenFileOrDie()\n```\n## 命名空间名称（snake_case）\n全部小写，单词之间带有下划线。\n\n## 枚举器（Enumerator）名称（用 kEnumName 而不是 ENUM_NAME）\n2009 年 1 月之前，枚举类用宏的风格命名枚举值。这导致枚举值和宏之间的名称冲突出现问题。因此，更改为首选常量样式命名。新代码应使用常量样式命名。\n```cpp\n// ok!\nenum class UrlTableError {\n  kOk = 0,\n  kOutOfMemory,\n  kMalformedInput,\n};\n```\n\n```cpp\n// no!\nenum class AlternateUrlTableError {\n  OK = 0,\n  OUT_OF_MEMORY = 1,\n  MALFORMED_INPUT = 2,\n};\n```\n## 模板参数名称（类型模板参数按类型名称；非类型模板参数按变量、常量名称）\n1. 类型模板参数 应遵循 类型名称 风格\n2. 非类型模板参数 应遵循 变量或常量的 风格\n## 宏名称（全大写、下划线分隔）\n一般来说，不应使用宏。但是，如果绝对需要它们，则应使用所有大写字母和下划线来命名它们，并带有特定于项目的前缀。\n```cpp\n#define MYPROJECT_ROUND(x) ...\n```\n## 别名（Aliases）\n别名的名称遵循与任何其他新名称相同的原则，应用于定义别名的上下文，而不是在原始名称出现的位置。\n## 命名规则的例外情况\nIf you are naming something that is analogous to an existing C or C++ entity then you can follow the existing naming convention scheme.\n如果您要命名类似于现有 C 或 C++ 实体的内容，则可以遵循现有的命名约定方案。\n1. `bigopen()`\n    1. function name, follows form of open()\n2. uint\n    1. typedef\n3. bigpos\n    1. struct or class, follows form of pos\n4. sparse_hash_map\n    1. STL-like entity; follows STL naming conventions\n5. LONGLONG_MAX\n    1. a constant, as in INT_MAX\n# 注释格式\n使用`//`或 `/* */` 语法，只要你保持和现有代码一致。最好首选`//`。\n## 文件注释\n每个文件都以许可证样板（license boilerplate）开头。\n\n如果一个源文件（例如 `.h` 文件）声明了多个面向用户的外部抽象（常见的函数、相关的类等），应包含一个描述这些抽象集合的注释。注释应包含足够的信息，以便未来的作者知道哪些内容不适合放在这里。然而，关于各个抽象的详细文档应属于这些抽象本身，而不是文件级别。\n\n例如，如果你为 `frobber.h` 编写文件注释，你不需要在 `frobber.cc` 或 `frobber_test.cc` 中包含文件注释。另一方面，如果你在 `registered_objects.cc` 中编写了一组没有相关头文件的类，你必须要在 `registered_objects.cc` 中包含文件注释。\n### 法律声明和作者行\n每个文件都应包含许可证模板。选择适合项目所用许可证的模板（例如，Apache 2.0、BSD、LGPL、GPL）。\n\n如果对带有作者行的文件进行了重大修改，可以考虑删除作者行。新文件通常不应包含版权声明或作者行。\n\n## 结构体和类注释\n每个**非显而易见**的类或结构体声明都应该有一个相应的注释，描述它的用途以及如何使用它。\n\n```cpp\n// Iterates over the contents of a GargantuanTable.\n// Example:\n//    std::unique_ptr<GargantuanTableIterator> iter = table->NewIterator();\n//    for (iter->Seek(\"foo\"); !iter->done(); iter->Next()) {\n//      process(iter->key(), iter->value());\n//    }\nclass GargantuanTableIterator {\n    ...\n};\n```\n### 类注释\n类注释应该向读者提供足够的信息，让他们知道如何以及何时使用该类，以及正确使用该类所需的任何额外注意事项。如果类有任何同步假设，应记录这些假设。如果类的实例可以被多个线程访问，需要特别小心地记录多线程使用相关的规则和不变量。\n\n类注释通常是一个好地方，用来可以放一小段示例代码，展示该类的简单和专注的使用方式。\n\n当函数足够分离（例如， `.h` 和 `.cc` 文件）时，描述类使用的注释应与其接口定义放在一起；关于类操作和实现的注释应伴随类方法的实现。\n## 函数注释\n声明注释描述函数的使用（当使用不明显时）；函数定义处的注释描述其操作。\n### 函数声明\n几乎每个函数声明前都应该有注释，描述函数的作用和使用方法。只有当函数简单且显而易见时（例如，类中简单访问明显属性的方法），才可省略这些注释。\n在 `.cc` 文件中声明的私有方法和函数也不例外。\n\n函数注释应以\"此函数\"（_This function_）为隐含主语，并以动词短语（verb phrase）开头；例如，\"打开文件\"（_Opens the file_），而不是\"打开文件\"（_Open the file_）。\n通常，这些注释不描述函数如何执行任务。相反，这些细节应留给函数定义中的注释。\n\n在函数声明注释中应提及的事项类型：\n1. 输入和输出是什么。如果函数参数名称用反引号括起来，那么代码索引工具可能能够更好地展示文档。\n2. 对于类成员函数：对象是否在方法调用持续时间之外记住引用或指针参数。这对于构造函数的指针/引用参数来说非常常见。\n3. 对于每个指针参数，是否允许其为空，如果为空会发生什么。\n4. 对于每个输出或输入/输出参数，该参数中的任何状态会发生什么（例如，状态是被追加还是被覆盖？）。\n5. 如果一个函数的使用存在性能影响。\n\n例子\n```cpp\n// Returns an iterator for this table, positioned at the first entry\n// lexically greater than or equal to `start_word`. If there is no\n// such entry, returns a null pointer. The client must not use the\n// iterator after the underlying GargantuanTable has been destroyed.\n//\n// This method is equivalent to:\n//    std::unique_ptr<Iterator> iter = table->NewIterator();\n//    iter->Seek(start_word);\n//    return iter;\nstd::unique_ptr<Iterator> GetIterator(absl::string_view start_word) const;\n```\n#### override的注释\n对于函数重写（override）。应关注重写之后的细节，而不是重复原抽象函数的注释。在许多情况下，重写不需要额外的文档说明，因此无需注释。\n\n#### 构造、析构的注释\n在注释构造函数和析构函数时，要让读你代码的人知道构造函数和析构函数的用途，因此仅说明“销毁此对象”之类的注释没有用处。\n应记录构造函数如何使用它们的参数（例如，如果它们接管指针的所有权），\n以及析构函数执行了哪些清理工作。\n\n如果这些很平凡，就可以省略注释。\n析构函数没有头部注释是非常常见的。\n### 函数定义\n如果一个函数的工作方式有任何复杂之处，函数定义应该有一个解释性注释。\n例如，在定义性注释中，你可以描述任何你使用的编程技巧，概述你经过的步骤，或者解释为什么你选择以这种方式实现函数而不是使用一个可行的替代方案。\n例如，你可能会提到为什么函数的前半部分必须获取锁，但后半部分不需要。\n\n请注意，不要仅仅重复函数声明中、 .h 文件或其他地方的注释。简要概括函数的作用是可以的，但注释的重点应该是它如何实现这一点。\n## 变量注释\n一般来说，变量的实际名称应该足够描述性，以便清楚地表明其用途。在某些情况下，需要更多的注释。\n### 类数据成员\n每个类数据成员（也称为实例变量或成员变量）的目的必须明确。如果类型和名称未能清楚地表达任何不变式（特殊值、成员之间的关系、生命周期要求），则必须进行注释。然而，如果类型和名称已经足够（ `int num_events_;`），则不需要注释。\n特别是，当哨兵值（如 nullptr 或-1）的存在和含义不明显时，应添加注释来描述它们。例如：\n```cpp\nprivate:\n    // Used to bounds-check table accesses. -1 means\n    // that we don't yet know how many entries the table has.\n    int num_total_entries_;\n```\n### 全局变量\n所有全局变量都应该有注释说明它们是什么、用途是什么，以及（如果不清楚）为什么需要是全局的。例如：\n```cpp\n// The total number of test cases that we run through in this regression test.\nconst int kNumTestCases = 6;\n```\n## 实现（Implementation）注释\n在你的实现中，你应该在代码中那些棘手、不明显、有趣或重要的部分添加注释。\n### 解释性注释\n复杂的代码块前应有注释。\n## 函数参数注释\n当函数参数的含义不明显时，可以考虑以下补救措施：\n- 如果参数是一个字面常量，并且该常量在多个函数调用中被多次使用，隐含地假设它们是相同的，你应该使用常量名称来明确这种约束，并确保其成立。\n- 考虑将函数签名更改为用 `enum` 参数替换 `bool` 参数。这将使参数值具有自描述性。\n- 对于具有多个配置选项的函数，可以考虑定义一个类或结构体来包含所有选项，并传递该类或结构体的实例。这种方法有几个优点。\n    - 在调用点通过名称来引用选项，这可以明确它们的含义。\n    - 还减少了函数参数的数量，这使得函数调用更容易阅读和编写。\n    - 此外，当你添加另一个选项时，你不必更改调用点\n- 用命名变量替换大型或复杂的嵌套表达式。\n- 作为最后的手段，使用注释来澄清调用点处参数的含义。\n\n错误示例：\n```cpp\n// What are these arguments?\nconst DecimalNumber product = CalculateProduct(values, 7, false, nullptr);\n```\n\n正确示例：\n```cpp\nProductOptions options;\noptions.set_precision_decimals(7);\noptions.set_use_cache(ProductOptions::kDontUseCache);\nconst DecimalNumber product =\n    CalculateProduct(values, options, /*completion_callback=*/nullptr);\n```\n## 标点符号、拼写、语法\n[Punctuation, Spelling, and Grammar](https://google.github.io/styleguide/cppguide.html#Punctuation_Spelling_and_Grammar)\n## TODO注释\n使用 `TODO` 注释来标记临时的代码、短期解决方案或足够好但并非完美的代码。\n\n`TODO` 应包含大写的字符串 `TODO` ，随后是错误 ID、名称、电子邮件地址或其他标识符，这些标识符应能提供关于 `TODO` 所引用问题的最佳背景信息。\n\n```cpp\n// TODO: bug 12345678 - Remove this after the 2047q4 compatibility window expires.\n// TODO: example.com/my-design-doc - Manually fix up this code the next time it's touched.\n// TODO(bug 12345678): Update this list after the Foo service is turned down.\n// TODO(John): Use a \"\\*\" here for concatenation operator.\n```\n\n如果你的 `TODO` 形式为 \"在未来某个日期做某事\"，请确保你包含一个非常具体的日期（\"在 2005 年 11 月前修复\"）或一个非常具体的事件（\"当所有客户端都能处理 XML 响应时移除此代码\"）。\n\n# 文档格式化\ngoogle 给 emacs 创建的设置文件：https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el\n\n## 行长度\n代码中的每一行文本长度不应超过 80 个字符。\n## 编码（关于非 ASCII 字符）\n非 ASCII 字符应当罕见；必须使用 UTF-8 格式。\n\n十六进制编码也是可以的，并且当它增强可读性时被鼓励使用——例如， `\"\\xEF\\xBB\\xBF\"` ，或者更简单的方式， `\"\\uFEFF\"` ，是 Unicode 零宽非断空格字符，如果直接以 UTF-8 形式包含在源代码中将是不可见的。\n\n在可能的情况下，避免使用 `u8` 前缀。它在 C++20 开始与 C++17 中的语义有显著不同，产生 `char8_t` 数组而不是 `char` ，并且将在 C++23 中再次改变。\n\n你不应该使用 `char16_t` 和 `char32_t` 字符类型，因为它们用于非 UTF-8 文本。出于类似的原因，你也应该避免使用 `wchar_t` （除非你正在编写与 Windows API 交互的代码，后者广泛使用 `wchar_t` ）。\n## 缩进（Spaces vs. Tabs）\n仅使用空格，每次缩进 2 个空格。\n使用空格进行缩进。不要在代码中使用制表符。你应该设置你的编辑器在按下制表键时输出空格。\n## 函数声明和定义\n函数名与返回类型放在同一行。\n\n如果参数能适应，参数也放在同一行。\n\n如果参数列表不能适应单行，像在函数调用中换行参数那样换行参数列表。\n\n```cpp\nReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {\n  DoSomething();\n  ...\n}\n```\n如果你有太多文本无法放在一行上：\n```cpp\nReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,\n                                             Type par_name3) {\n  DoSomething();\n  ...\n}\n```\n或者即使第一参数也无法在一行内放下：\n```cpp\nReturnType LongClassName::ReallyReallyReallyLongFunctionName(\n    Type par_name1,  // 4 space indent\n    Type par_name2,\n    Type par_name3) {\n  DoSomething();  // 2 space indent\n  ...\n}\n```\n\n一些需要注意的：\n1. 选择好的参数名\n2. 只有当参数在函数定义中未使用时，才可省略参数名。\n3. 如果无法将返回类型和函数名放在同一行，则在这两者之间断行。\n4. 如果你在函数声明或定义的返回类型后换行，不要缩进。\n5. 左括号始终与函数名位于同一行。\n6. 函数名和左括号之间永远不加空格。\n7. 括号和参数之间永远不加空格。\n8. 花括号始终位于函数声明的最后一行的末尾，而不是下一行的开头。\n9. 闭花括号可以单独位于最后一行，或者与开花括号位于同一行。\n10. 闭括号和开花括号之间应该有一个空格。\n11. 所有参数应该尽可能对齐。\n12. 默认缩进为 2 个空格。\n13. 包装参数的缩进为 4 个空格。\n\n在上下文中显而易见的不用参数可以省略名称：\n```cpp\nclass Foo {\n public:\n  Foo(const Foo&) = delete;\n  Foo& operator=(const Foo&) = delete;\n};\n```\n\n对于可能不太明显的未使用参数，应在函数定义中注释掉变量名：\n```cpp\nclass Shape {\n public:\n  virtual void Rotate(double radians) = 0;\n};\n\nclass Circle : public Shape {\n public:\n  void Rotate(double radians) override;\n};\n\nvoid Circle::Rotate(double /*radians*/) {}\n```\n错误示例：\n```cpp\n// Bad - if someone wants to implement later, it's not clear what the\n// variable means.\nvoid Circle::Rotate(double) {}\n```\n\n属性和扩展为属性的宏出现在函数声明或定义的最开始，在返回类型之前：\n```cpp\n  ABSL_ATTRIBUTE_NOINLINE void ExpensiveFunction();\n  [[nodiscard]] bool IsOk();\n```\n## lambda表达式\n## 浮点字面量\n## 函数调用\n## 花括号初始化列表格式\n## 循环和分支语句\n## 指针和引用表达式和类型\n## 布尔表达式\n## 返回值\n## 变量和数组初始化\n## 预处理指令\n## 类格式\n## 构造函数初始化列表\n## 命名空间格式化\n## 水平空格\n水平空格的使用取决于位置。绝不要在行的末尾放置尾随空格。\n## 垂直空白\n少用垂直空白；不必要的空行会使整体代码结构更难看清。只在有助于读者理解结构的地方使用空行。\n\n不要在已经通过缩进清晰分隔的地方添加空行，例如代码块的开始或结束处。应使用空行将代码分隔成紧密相关的块，类似于散文中的段落分隔。在一个语句或声明中，通常只在需要保持在行长度限制内，或需要将注释附加到部分内容时插入换行。\n# 例外\n- [Existing Non-conformant Code](https://google.github.io/styleguide/cppguide.html#Existing_Non-conformant_Code)\n- [Windows Code](https://google.github.io/styleguide/cppguide.html#Windows_Code)\n# cpplint 检测风格错误\n使用 `cpplint.py` 来检测风格错误。[cpplint.py](https://raw.githubusercontent.com/cpplint/cpplint/HEAD/cpplint.py)\n`cpplint.py` 是一个读取源文件并识别许多风格错误的工具。它并不完美，既有误报也有漏报，但它仍然是一个有价值的工具。","categories":["Cpp"]},{"title":"git_开源协作工作流","url":"/git/git_开源协作工作流/","content":"当在一个 GitHub 组织与他人协作开源项目时。\n\n如果仓库 Owner 没有开放写权限。\n\n就需要先 fork 一份到我们自己的仓库。\n\n然后，在本地 git clone 我们自己的仓库。\n\n当源仓库有更新时，我们的仓库落后了。\n\n此时需要做的事情：\n1. `git remote add upstream 原始仓库地址`：添加原始仓库为远程上游仓库\n2. `git remote -v`：验证是否添加成功（应该能看到origin 和 upstream）\n\n然后，从上游仓库获取最新更改：\n```bash\ngit fetch upstream\n```\n\n\n此时，只是下载了源仓库的最新文件，但没有合并到我们本地仓库中。\n\n确认我们目前处于我们自己的本地主分支。如果不是，需要切换：\n```bash\ngit checkout main\n```\n\n\n然后，就可以合并上游仓库的更改了：\n```bash\ngit merge upstream/main # 将上游仓库的main分支合并到你的当前分支\n```\n\n\n此时可能会遇到冲突，需要手动解决直到没有冲突后才能提交。\n\n合并完成后，并且`git add -A`、`git commit`后，就可以将更新推送到我们的 fork 仓库了：\n\n```bash\ngit push origin main # 现在将同步后的本地仓库推送到你的GitHub Fork (origin)\n```\n\n## 一步流\n\n其实，以上的 git fetch 是分步骤去完成的。如果用 GitHub 比较熟练后，可以一条命令完成获取和合并：\n```bash\ngit pull upstream main\n```\n\n","categories":["git"]},{"title":"高级数据结构_flat结构","url":"/高级数据结构/高级数据结构_flat结构/","content":"author: Chenggong Xing\n\ndate: 2025/9/10\n\n# 内容\n\n1. 分析了已经在C++23引入标准库的`flat_map`结构\n2. 分析了尚未引入标准库的优秀的`unordered_flat_map`实现\n# `flat_map`\nC++23 中引入的 `std::flat_map`、`std::flat_set` 等平坦容器，其核心在于​**​底层使用有序的连续内存结构（如 `std::vector`）来存储元素​**​，并通过​**​二分查找​**​来定位元素，从而维护其有序性。这使得它们在查找和遍历性能上通常优于传统的基于节点的容器（如 `std::map`），但在插入和删除操作上成本较高。\n\n下面是一个对比表格，帮助你快速了解 `std::flat_map` 与 `std::map` 在底层实现上的关键差异：\n\n| 特性维度            | `std::map` (传统关联容器)          | `std::flat_map` (C++23 平坦容器)                                                          |\n| --------------- | ---------------------------- | ------------------------------------------------------------------------------------- |\n| ​**​底层数据结构​**​  | 通常为红黑树（节点式，非连续内存）            | ​**​排序的连续内存​**​（如 `std::vector<std::pair<Key, Value>>` 或​**​两个分离的 `std::vector`​**​ ） |\n| ​**​查找机制​**​    | 遍历树结构（O(log n)）              | ​**​二分查找​**​（O(log n)，​**​常数项更优​**​，缓存友好）                                             |\n| ​**​插入/删除机制​**​ | 调整树节点指针（O(log n)）            | ​**​可能移动大量元素​**​以维持有序（O(n)）                                                           |\n| ​**​迭代器稳定性​**​  | ​**​稳定​**​（插入删除通常不会使其他迭代器失效） | ​**​不稳定​**​（插入删除可能使所有迭代器失效）                                                           |\n| ​**​内存布局​**​    | 元素分散在堆内存中，额外开销包括节点指针等        | ​**​元素紧凑排列​**​，内存开销更小                                                                 |\n\n## 维护有序性的细节\n\n平坦容器所有元素都存储在一个或多个始终保持​**​严格排序​**​状态的底层容器（如 `std::vector`）中。这是其高效查找的基础。\n\n1. **​插入操作​**​：\n    - 当插入新元素时，容器首先使用​**​二分查找​**​（复杂度 O(log n)）在底层有序序列中快速定位到正确的插入位置，以确保排序不变性。\n    - 找到位置后，如果底层容器是 `std::vector`，​**​插入点之后的所有元素可能需要向后移动​**​一位以腾出空间（复杂度 O(n)）。这个过程类似于向有序数组中间插入数据。\n    - 因此，​**​插入操作的总体复杂度是 O(n)​**​。\n2. **​删除操作​**​：\n    - 类似地，删除元素时，首先使用二分查找定位目标元素（O(log n)）。\n    - 移除该元素后，​**​其后所有元素可能需要向前移动​**​一位以填补空隙（O(n)）。\n    - 因此，​**​删除操作的总体复杂度也是 O(n)​**​。\n3. **​查找操作​**​：\n    - 由于元素有序，查找操作直接使用​**​二分查找​**​（O(log n)），且得益于​**​连续内存存储带来的极佳缓存局部性​**​，实际效率通常远高于传统的 `std::map`/`std::set`。\n4. **​底层容器与内存管理​**​：\n    - 平坦容器是​**​容器适配器​**​，可以指定底层使用的容器类型（例如 `std::vector` 或 `std::deque`），默认为 `std::vector`。\n    - `std::flat_map` 的一个特殊之处在于其底层通常由​**​两个单独的数组​**​构成：一个用于存储键（Key），另一个用于存储值（Value）。键数组始终保持有序，值数组中元素的索引与键数组一一对应。这种设计使得键的比较更加高效，但在插入和删除时需要同时维护两个数组的同步和有序性。\n## 核心特点与设计考量\n\n- **​性能权衡​**​：平坦容器通过​**​牺牲插入和删除的效率​**​，换取了​**​极佳的查找性能、遍历速度和更低的内存占用​**​。这是一种典型的以空间换时间（缓存友好性）的设计思路。\n- **​异常安全​**​：由于插入和删除操作可能涉及大量元素的移动，如果在移动过程中（例如元素的移动构造函数）抛出异常，容器的状态可能会变得复杂，其异常安全性通常弱于节点式容器。\n- **​元素类型要求​**​：因为涉及元素的移动，键和值类型必须是​**​可移动构造（Movable）和可复制构造（Copyable）​**​ 的。\n\n## 适用场景\n\n1. **​频繁查找和遍历，少量插入删除​**​：例如配置表、初始化后很少变化的参考数据、游戏中的静态资源表等。\n2. **​对内存占用和缓存友好性极其敏感的场景​**​：嵌入式系统或需要处理海量数据且希望减少缓存未命中的应用。\n3. **​需要频繁对容器进行批量操作或排序的场景​**​：由于数据在内存中连续，可以非常高效地与标准库算法结合使用。\n\n## 注意事项\n\n1. **​迭代器失效​**​：​**​任何可能修改容器内容的操作（如插入、删除）都可能导致所有现有的迭代器和引用失效​**​。这是因为底层存储可能需要重新分配内存或移动大量元素。\n2. **​性能波动​**​：虽然查找速度稳定且快，但插入和删除操作的时间成本取决于插入点的位置。在容器尾部操作比在头部操作更快。\n## 两个分离的数组和单一数组存`pair`的对比\nC++23 中 `std::flat_map` 使用两个分离的数组分别存储键（Key）和值（Value），与使用单一数组存储 `std::pair<Key, Value>` 的设计相比，确实各有优劣。下面这个表格汇总了它们的主要区别：\n\n| 特性维度            | 双数组设计 (键值分离)                       | 单数组设计 (存储 pair)                    |\n| --------------- | ---------------------------------- | ---------------------------------- |\n| ​**​缓存局部性​**​   | ​**​键的局部性极佳​**​，查找时仅键数组入缓存，命中率高    | 每次比较需加载整个 pair，可能包含不必要的数据，缓存效率相对较低 |\n| ​**​查找性能​**​    | ​**​通常更高​**​（二分查找时比较操作更高效）         | 相对较低（需传递整个 pair 进行比较）              |\n| ​**​插入/删除性能​**​ | 需移动​**​两个数组​**​中的元素，​**​开销可能更大​**​ | 只需移动​**​一个数组​**​中的元素，开销相对较小        |\n| ​**​内存布局​**​    | 键和值分别连续存储                          | 键值对连续存储                            |\n| ​**​内存管理​**​    | 更灵活，可为键和值选择不同的分配器或容器               | 相对统一，管理简单                          |\n| ​**​迭代器类型​**​   | 提供随机访问迭代器                          | 提供随机访问迭代器                          |\n| ​**​迭代器稳定性​**​  | ​**​极不稳定​**​，任何修改操作均使所有迭代器失效       | ​**​极不稳定​**​，任何修改操作均使所有迭代器失效       |\n| ​**​代码复杂性​**​   | 内部实现需维护两个序列的同步，更复杂                 | 实现相对简单直接                           |\n### 双数组设计优缺点分析\n优点：\n1. **​卓越的查找性能与缓存效率​**​：这是​**​最显著的优点​**​。进行二分查找时，算法只需在​**​连续紧凑的键数组​**​中进行比较操作。这大大提高了 CPU 缓存命中率，因为缓存线可以被纯粹用于键的比较数据填满，避免了将值数据（可能很大且无关）加载到缓存中。对于键类型较小且比较操作昂贵的场景，性能提升尤为明显。\n2. **​潜在的内存灵活性​**​：理论上，可以为键容器和值容器指定不同的类型（例如，键用 `std::vector`，值用 `std::deque`），甚至不同的分配器。这提供了更精细的内存管理控制。\n\n缺点：\n1. **​插入和删除开销更大​**​：维护有序性需要向底层容器插入或删除元素。在双数组设计中，​**​需要在两个数组的对应位置进行相同的移动操作​**​。这意味着一次插入可能引发两次元素移动（键数组一次，值数组一次），理论上开销比单数组移动 `pair` 更大。\n2. **​实现复杂度更高​**​：容器需要小心翼翼地维护键和值两个序列的同步，确保对应索引的键值始终匹配。这增加了内部实现的复杂性。\n### 单数组设计（存储 `pair`）优缺点分析\n优点：\n1. **​插入删除操作稍快​**​：只需在单个 `pair` 数组中进行元素的移动，操作次数更少。对于频繁需要修改的场景，这可能是一个优势。\n2. **​实现更简单直观​**​：只需要管理一个容器，逻辑相对简单，不易出错。\n3. **​与传统习惯兼容​**​：许多现有算法和代码习惯于处理 `std::pair`，单数组设计在交互上可能更自然。\n\n缺点：\n1. **​缓存局部性相对较差​**​：进行二分查找时，每次比较都需要把整个 `std::pair` 加载到缓存中。如果值数据很大（例如包含字符串），但比较时根本用不到，就会​**​浪费宝贵的缓存空间​**​，导致缓存效率降低，从而影响查找速度。\n2. **​内存使用可能不经济​**​：同上，如果键很小而值很大，每次比较操作却要加载整个大 `pair`，内存带宽的利用效率不高。\n### 设计选择与考量\nC++23 标准委员会最终为 `std::flat_map` 选择了​**​双数组设计​**​，这主要基于其核心应用场景的考量：\n- **​`std::flat_map` 的首要目标是提供极致的查找性能​**​。在大多数关联容器的使用场景中，​**​查找​**​是最频繁的操作，而插入和删除则相对较少。双数组设计完美地优化了查找性能，通过牺牲一些修改操作的效率，换取了更重要的查找速度和缓存效率。\n- **​缓存局部性在现代计算机体系结构中至关重要​**​。处理器速度远快于内存速度，因此减少缓存未命中、提高缓存命中率是提升性能的关键。双数组设计在这方面表现优异。\n- 虽然插入/删除更耗时，但其复杂度仍然是 ​**​O(n)​**​，与单数组设计相同。 Big-O 记号相同，但常数因子可能不同。标准委员会认为查找性能的收益超过了修改操作的开销。\n### 如何选择\n- 如果你的使用场景是​**​频繁查找、遍历，而插入和删除操作很少​**​（例如配置表、初始化后很少变化的数据、只读或重加载不频繁的参考数据），那么 `std::flat_map` 的双数组设计是非常理想的选择，能为你带来显著的性能提升。\n- 如果你的场景需要​**​频繁的插入和删除​**​，那么基于节点的容器（如 `std::map`）可能仍然是更好的选择，因为它们能提供稳定的 O(log n) 插入删除和迭代器稳定性。\n- 需要注意的是，无论哪种底层存储设计，​**​`std::flat_map` 的迭代器在插入和删除操作后都会失效​**​，这是由其底层线性结构决定的。\n\n# `unordered_flat_map`\n高性能哈希表。核心特点是：开放寻址、平坦内存布局。\n\n截止2025年9月10日，`unordered_flat_map`还未引入标准库。\n## Abseil 库实现\nAbseil 库的实现是`absl::flat_hash_map`。采用了一种称为瑞士表格（Swiss Table）的设计。\n### 底层策略\n底层策略是基于**开放寻址**和**线性探测**。所有元素直接存储在一个数组中，而不是像`std::unordered_map`那样使用链地址法（每个桶挂载一个链表）\n### 核心机制\n核心机制是**控制字节**：每个键值对（槽位）都有一个对应的控制字节，用于编码该槽位的状态（空、已删除、满）以及哈系值的一部分信息（通常取哈系值的高 7 位），这使得它可以快速判断一个槽位是否可以匹配目标键，从而加速查找。\n### 内存布局\n内存布局：数据（键值对）和元数据（控制字节）是分离存储的。数据数组和控制字节数组并存。这种布局有利于使用SIMD指令（如 SSE 或 AVX）一次性比较多个控制字节，极大提升扫描速度。\n### 哈系探测\n哈希探测：使用模运算或按位与（桶大小为 2 的幂时）来确定初始索引。发生冲突时，进行线性探测（顺序检查下一个槽位）。探测过程中，首先检查控制字节组，可以快速跳过大量不匹配的槽位。\n### 性能优化\n1. **SIMD 加速​**​：利用 SIMD 指令并行比对多个控制字节，这是其性能卓越的关键之一\n2. **缓存友好​**​：连续的数组存储使得 CPU 缓存利用率更高，减少了缓存未命中\n3. **惰性删除​**​：删除元素时并不立即压缩数组，而是将其标记为“已删除”，后续插入操作可以复用这些槽位\n## Boost 库实现\nBoost 1.81 版本引入了`boost::unordered_flat_map`，它也是一个基于开放寻址的高性能哈希容器。\n### 底层策略\n底层策略同样基于**开放寻址**和**线性探测**。所有元素也是存储在单个数组中。\n### 核心机制\n核心机制也是**控制字节**：也使用了类似于控制字节的​**​元数据​**​来管理槽位状态。其快速路径（fast path）在每次查找时只需​**​一次条件判断​**​和​**​一次指针解引用​**​，效率极高。\n### 内存布局\n内存布局：倾向于将​**​键值对直接存储​**​在主数组中（与 absl 可能分离存储元数据的策略略有不同），但同样保证了数据的连续性。\n### 哈系探测\n哈希探测：与 absl 类似，通过哈希函数映射到初始索引，然后进行线性探测。\n### 性能优化\n官方基准测试显示，其性能与 `absl::flat_hash_map`和 `google::dense_hash_map`处于同一梯队，甚至在许多场景下更具优势。其设计目标之一就是提供异常出色的查找速度。\n## 对比总结：`absl::flat_hash_map` vs. `boost::unordered_flat_map`\n|特性|Abseil (`absl::flat_hash_map`)|Boost (`boost::unordered_flat_map`)|\n|---|---|---|\n|​**​核心策略​**​|开放寻址 + 线性探测|开放寻址 + 线性探测|\n|​**​元数据​**​|​**​控制字节​**​（单独数组），存储状态和部分哈希值|类似的​**​元数据​**​（具体实现未完全公开），集成或与数据交错|\n|​**​关键优化​**​|​**​SIMD 指令​**​批量处理控制字节|极简的​**​快速路径​**​（一次条件判断+一次指针解引用）|\n|​**​内存布局​**​|​**​数据与元数据分离​**​，利于 SIMD|数据连续存储，优化缓存 locality|\n|​**​删除操作​**​|​**​惰性删除​**​（标记为已删除）|类似惰性删除机制|\n|​**​性能表现​**​|极高性能，尤其在查找和迭代方面|极高性能，基准测试中常名列前茅|\n# 思考：不如直接说是vector？\n“直接用vector实现一个flat_map不就好了？” 这确实是 `flat_map`的核心思想之一：​**​利用排序的 `vector`或类似连续容器，通过二分查找进行高效的查询​**​。\n\n了解 `map`、`flat_map`、`unordered_flat_map` 和 `vector` 的区别非常重要，它们各自有不同的设计目的和性能特性。下面解释它们的核心区别，并分析为什么“直接用 `vector` 实现一个 `flat_map`”的想法在实践中并不简单。\n## 四个容器核心区别一览\n\n|特性|`std::vector`|`std::flat_map` (C++23)|`std::unordered_flat_map` (或类似实现)|`std::map` (参考)|\n|---|---|---|---|---|\n|​**​底层数据结构​**​|连续内存数组|​**​两个排序的数组​**​ (键数组+值数组 或 `pair` 数组)|​**​开放寻址哈希表​**​ (连续内存块)|红黑树 (节点式)|\n|​**​元素顺序​**​|插入顺序|​**​按键排序​**​|​**​无序​**​|按键排序|\n|​**​查找复杂度​**​|O(n) (线性)|O(log n) (二分查找)|​**​O(1) 平均​**​ (哈希)|O(log n)|\n|​**​插入/删除复杂度​**​|尾部 O(1)*, 中间 O(n)|O(n) (需移动元素)|O(1) 平均 (摊销)|O(log n)|\n|​**​缓存友好性​**​|​**​极佳​**​ (连续内存)|​**​极佳​**​ (连续内存)|​**​佳​**​ (主要数据连续)|差 (内存碎片)|\n|​**​内存开销​**​|很低|低|中|高 (每个节点含指针)|\n|​**​迭代器稳定性​**​|插入/删除可能失效|​**​任何操作都可能失效​**​|插入/删除可能失效|​**​稳定​**​ (除删除元素)|\n|​**​核心优势​**​|顺序访问、遍历、随机访问|​**​有序且缓存友好​**​的查找|​**​极速查找​**​，不关心顺序|有序且迭代器稳定|\n|​**​典型场景​**​|动态数组、需频繁遍历|​**​需有序且查找频繁​**​的场景|​**​纯键值查询​**​、缓存、字典|需​**​有序且频繁插入删除​**​|\n\n_注：`vector` 尾部插入为摊销常数复杂度，可能触发重新分配。_\n\n## 为何不直接用 Vector 实现 Flat Map？\n然而，标准库（或 Boost/Abseil 等库）提供的 `flat_map` 相比自己用 `vector` 手动实现，有以下​**​关键优势和考量​**​：\n1. **​封装与易用性​**​：\n    - 它​**​封装了所有复杂逻辑​**​：维护排序状态、二分查找、处理插入和删除时的元素移动、迭代器失效管理等。\n    - 提供了一套​**​完整且标准的关联容器接口​**​（如 `insert`, `erase`, `find`, `lower_bound`），让你可以像使用 `std::map` 一样使用它，无需重复造轮子。\n2. **​性能优化​**​：\n    - **​精心设计的底层结构​**​：例如，`std::flat_map` 可能采用​**​两个分离的数组​**​分别存储键和值，而不仅仅是 `std::vector<std::pair<Key, T>>`。这种设计可以​**​进一步提升缓存效率​**​，因为在二分查找比较键时，加载到缓存中的都是键，避免了无关值数据的干扰。\n    - **​算法优化​**​：库实现会使用最合适的二分查找算法，并处理所有边界情况。\n3. **​内存管理​**​：\n    - 它会​**​智能地处理内存分配和重新分配​**​，比如在插入元素前预留空间以避免频繁扩容，就像一个好的 `vector` 用法一样。\n4. **​异常安全​**​：\n    - 库实现会提供​**​更强的异常安全保证​**​，正确处理在插入、移动元素过程中可能发生的异常，确保容器状态不被破坏。\n5. **​与现有生态的兼容性​**​：\n    - 使用标准或广泛认可的库实现，可以​**​更容易地与他人协作​**​，并且能保证未来的维护性。\n\n**​简单来说​**​：你自己当然可以基于 `vector` 和 `std::lower_bound` 等算法实现一个类似的功能，但要把它做得像标准库那样健壮、高效和易用，需要大量的工作和测试。`flat_map` 本质上就是为你提供了这个“轮子”。\n\n# 四个容器如何选择？\n `map`、`flat_map`、`unordered_flat_map` 和 `vector` 如何选择：\n选择哪个容器取决于你的具体需求：\n- **​需要极致的查找速度且不关心顺序​**​：选择 `unordered_flat_map` (或 `absl::flat_hash_map`, `boost::unordered_flat_map`)。它是字典、缓存等场景的最佳选择。\n- **​需要元素有序，且查询频繁但插入删除较少​**​：选择 `std::flat_map`。它在提供有序性的同时，拥有了接近 `vector` 的遍历速度和缓存友好性，非常适合配置表、初始化后几乎不变的数据。\n- **​需要频繁在任意位置插入和删除，且要求迭代器稳定​**​：选择 `std::map` (或 `std::unordered_map`)。虽然查找稍慢，但插入和删除效率更高（对于 `map` 是 O(log n)），且迭代器在插入后通常不会失效（`unordered_map` 在 rehash 时除外）。\n- **​只需要一个简单的动态数组，频繁遍历或随机访问​**​：选择 `std::vector`。它是序列容器的首选。","categories":["高级数据结构"]},{"title":"Cpp_奇异递归模板模式（CRTP）","url":"/Cpp/Cpp_奇异递归模板模式（CRTP）/","content":"# 1\n```cpp\ntemplate <typename Derived>\nclass Base\n{\npublic:\n    void show(void)\n    {\n        static_cast<Derived*>(this)->show();\n    }\nprotected:\n    void show(void)\n    {\n        std::wcout << L\"Base::show()\" << std::endl;\n    }\n};\n\nclass Client : public Base<Client>\n{\npublic:\n\n};\nint main()\n{\n    Client client;\n    client.show();\n    return 0;\n}\n```\n\n输出：\n```\nBase::show()\n```\n# 2\n```cpp\ntemplate <typename Derived>\nclass Base\n{\npublic:\n    void show(void)\n    {\n        static_cast<Derived*>(this)->show();\n    }\nprotected:\n    void show(void)\n    {\n        std::wcout << L\"Base::show()\" << std::endl;\n    }\n};\n\nclass Client : public Base<Client>\n{\npublic:\n    void show(void) // hidden\n    {\n        std::wcout << L\"Client::show()\" << std::endl;\n    }\n};\nint main()\n{\n    Client client;\n    client.show();\n    return 0;\n}\n```\n\n输出：\n```\nClient::show()\n```\n# 静态多态\n```cpp\n#include <iostream>\n\n// 基类模板，依赖派生类提供 impl()\ntemplate<class Derived>\nstruct Algo {\n    void run() {\n        // 共享的流程骨架\n        pre();\n        static_cast<Derived*>(this)->impl(); // 派生类定制点\n        post();\n    }\n    void pre()  { /* 公共准备逻辑 */ }\n    void post() { /* 公共收尾逻辑 */ }\n};\n\n// 派生类 A：提供自己的实现\nstruct AlgoA : Algo<AlgoA> {\n    void impl() { std::cout << \"AlgoA fast path\\n\"; }\n};\n\n// 派生类 B：另一种实现\nstruct AlgoB : Algo<AlgoB> {\n    void impl() { std::cout << \"AlgoB precise path\\n\"; }\n};\n\nint main() {\n    AlgoA a; a.run();   // 无虚表，编译期静态解析，易于内联\n    AlgoB b; b.run();\n}\n\n```\n# 实际场景\nWTL、ATL（活动模板库，90年代的，用于COM）","categories":["Cpp","Modern","模板"]},{"title":"协程_Agave设计原理","url":"/多线程/协程_Agave设计原理/","content":"# 项目介绍\nAgave(TM) `C++20`标准协程库框架\n1. 严格遵循C++20标准，并对其进行了深度设计、封装，性能优良，易用，适用于协程库开发厂商和终端用户使用\n2. 设计了通用协程类型返回对象：`AsyncAction`、`AsyncActionWithProgress`、`AsyncOperation`、`AsyncOperationWithProgress`，开发方式合二为一，无论库厂商还是最终用户，使用方式完全相同，并可再次`co_await`等待，轻松构成协程任务链\n3. 只使用co_await标准关键字几乎可以完成所有操作，如：进行环境切换、功能设置等等。\n    1. `co_await agave::resume_background();`进入后台线程环境\n    2. `co_await agave::resume_foreground();`进入前台线程环境\n    3. `co_await agave::get_cancellation_token();`获取停止token。\n4. 深度整合了`chrono`库，并设计了`BJobScheduler`并行协程调度器，支持便捷语法：`co_await 30ms;`暂停当前协程，并送入调度器待后续唤醒执行。\n5. 高度可扩展设计，所有执行环境均可配置，如前台、后台、时间调度等，均可以配置连接自定义的高效线程池\n6. 协程返回对象中均配置了`condition variable`对象，包含于`get`方法中，既可以使用异步功能又可兼容经典同步模型使用方法。\n7. 支持`progress`自定义进度类型，并通过`co_await`即可获得（内部使用`co_yield`实现，可多次`co_await`）\n8. 现有多个基于此框架的商业项目已运行至少 2 年：`DevilStation`、`TeXsh`等，性能稳定\n# C++协程的样子\n```cpp\nRTN_OBJ MyCoroutine()\n{\n    co_await / co_yield / co_return;\n}\n```\n# 官方示例\n![](../../images/协程_Agave设计原理/image-20250827191845939.png)\n\n# RTN_OBJ中有个promise_type\n```cpp\nclass RTN_OBJ\n{\npublic:\n    class promise_type\n    {\n    public:\n        RTN_OBJ get_return_object(){ return {}; }\n        std::suspend_never initial_suspend() noexcept { return {}; }\n        std::suspend_never final_suspend() noexcept { return {}; }\n        void return_void() {}\n        //int return_value(int v) { return v; }\n        void unhandled_exception() {}\n    };\n};\nRTN_OBJ MyCoroutine()\n{\n    co_return;\n}\nint main()\n{\n    auto promise = new RTN_OBJ::promise_type;\n    RTN_OBJ rtn_obj = promise->get_return_object();\n    return 0;\n}\n```\n经过promise_type创建。RTN_OBJ的内容与promise绑定。promise的接口函数可以直接操作RTN_OBJ。\n\nRTN_OBJ是实例。\npromise_type是在RTN_OBJ中的一个指针。\n\npromise_type是系统控制和协程内部交互的。就像是协程的总经理的地位，可以在`initial_suspend`、`final_suspend`函数体内写明要做的事务。\n除了这两个接口，还要实现`return_void`或`return_value`，和`unhandled_exception`。\n这样，C++才认为你是一个合格的经理。\n\n总的来说，记住，promise_type用于控制协程内部行为。\n```cpp\nclass promise_type\n{\npublic:\n    RTN_OBJ get_return_object()\n    {\n        auto h = std::coroutine_handle<promise_type>::from_promise(*this);\n    }\n};\n```\n比如，可以在promise_type成员函数体中：通过`promise_type`作为模板参数，调用`from_promise(*this)`，获得此协程的内部句柄。\n可以通过这个句柄，调用destroy等等，比如用来控制协程帧。[std::coroutine_handle, std::noop_coroutine_handle - cppreference.com](https://en.cppreference.com/w/cpp/coroutine/coroutine_handle.html)\n# Awaiter\n可以`co_await`的对象。\n里面必须有接口：`bool await_ready`、`void await_suspend(coroutine_handle<>)`、`void await_resume()`（最后一个，返回值不一定是void，可以是其他）。\n\n`await_suspend(std::coroutine_handle<> h)`中的h是外部传入的。用于和外界发送信号。\n当外界`co_await`此`Awaiter`时，外部h传入，则`await_suspend`函数在执行过程中（比如读取文件完成）可以调用`h.resume`，唤醒外部。\n如果`await_suspend`函数中起了一个新线程，那么这个线程可以异步IO（detach）。`await_suspend`可以返回了。\n异步线程函数可以择机调用`h.resume`。则该Awaiter此时就要转向执行`await_resume()`，执行完后，外部的`co_await`就完毕，恢复执行下一步。\n```cpp\nstruct Awaiter\n{\n    constexpr bool await_ready() const noexcept\n    {\n        return false;\n    }\n    /* constexpr */ void await_suspend(std::coroutine_handle<> h) const noexcept\n    {\n        // create a new thread for IO operation...\n        std::thread t([h]() -> void)\n        {\n            // IO operation...\n            // h.resume\n        });\n        t.detach();\n        return;\n    }\n    constexpr int await_resume() const noexcept\n    {\n        return 100;\n    }\n};\nRTN_OBJ MyCoroutine(void)\n{\n    std::println(\"running MyCoroutine...\");\n    int res = co_await Awaiter{}; // 可以接收await_resume()的返回值。\n    co_return;\n}\n```\n实际上，Awaiter，是`ReadFileAsync`这样的异步操作对象的本质。\n\n我们要做的是，怎么包装这样的Awaiter，让用户用起来简单？\n## suspend_always / suspend_never\n```cpp\n_EXPORT_STD struct suspend_never\n{\n    _NODISCARD constexpr bool await_ready() const noexcept\n    {\n        return true;\n    }\n    constexpr void await_suspend(coroutine_handle<>) const noexcept\n    {\n    }\n    constexpr void await_resume() const noexcept\n    {\n    }\n}\n```\n# 测试\n```cpp\n#include <iostream>\n#include <coroutine>\n#include <thread>\n#include <chrono>\n#include <print>\nusing namespace std::chrono_literals;\nclass RTN_OBJ\n{\npublic:\n    class promise_type\n    {\n    public:\n        RTN_OBJ get_return_object()\n        {\n            std::println(\"get_return_object()...\");\n            return {};\n        }\n        std::suspend_never initial_suspend() noexcept\n        {\n            std::println(\"initial_suspend()...\");\n            return {};\n        }\n        std::suspend_never final_suspend() noexcept\n        {\n            std::println(\"final_suspend()...\");\n            return {};\n        }\n        void return_void()\n        {\n            std::println(\"return_void()...\");\n        }\n        void unhandled_exception()\n        {\n            std::println(\"unhandled_exception()...\");\n        }\n    };\n};\nstruct Awaiter\n{\n    /*constexpr*/ bool await_ready() const noexcept\n    {\n        std::println(\"{} {}\", std::this_thread::get_id(), \"await_ready()...\");\n        return false;\n    }\n    // 往往开辟一个新线程，异步进行耗时的IO操作\n    // 操作完毕后，调用h的resume\n    /*constexpr*/ void await_suspend(std::coroutine_handle<> h) noexcept\n    {\n        std::println(\"{} {}\", std::this_thread::get_id(), \"await_suspend()...\");\n\n        std::thread t([h](int &m_res) -> void \n        {\n            // IO operation...\n            std::println(\"{} {}\", std::this_thread::get_id(), \"sleep 5s...\");\n            std::this_thread::sleep_for(5s);\n            m_res = 100;\n            std::println(\"{} {} {}{}\", std::this_thread::get_id(), \"write m_res\", m_res, \"...\");\n        }, std::ref(m_res));\n        t.join();\n        h.resume();\n        return;\n    }\n    /*constexpr*/ int await_resume() const noexcept\n    {\n        std::println(\"{} {}\", std::this_thread::get_id(), \"await_resume()...\");\n        return m_res;\n    }\n    int m_res;\n};\nRTN_OBJ MyCoroutine()\n{\n    std::println(\"{} {}\", std::this_thread::get_id(), \"Running MyCoroutine...\");\n    // 进去先看await_ready()是否为true，是true则不会等待。\n    // 是false则执行await_suspend()，\n    // 执行完await_suspend()后，放弃运行权。交给caller\n    // 直到h.resume()。获得执行权后，co_await结束，接着去执行await_resume()\n    // 可以接收到await_resume()的返回值。\n    auto res = co_await Awaiter{};\n    std::println(\"{} {} {}\", std::this_thread::get_id(), \"After Awaiter get res:\", res);\n    co_return;\n}\n\nint main()\n{\n    std::println(\"{} {}\", std::this_thread::get_id(), \"Create MyCoroutine\");\n    // 返回一个RTN_OBJ对象\n    auto rtn = MyCoroutine();\n    std::println(\"{} {}\", std::this_thread::get_id(), \"Finish MyCoroutine\");\n    return 0;\n}\n```\n我们可以看到，主线程的操作：\n1. 调用协程函数，一旦调用了协程函数，就会触发`promise_type`的成员函数，类似于构造的`await_ready()`。然后主线程继续调用协程函数的每一句。\n2. 直到遇到了`co_await`，则就掉到了Awaiter对象内部的操作，如`await_ready()`、`await_suspend()`。\n3. 新协程（Awaiter）内部，起线程。进行`await_suspend()`的内部操作。\n4. 操作完后，主动`h.resume`，回到了主线程。执行`await_resume()`。\n5. 之后，回到一开始的协程函数。`co_await`这一行结束。主线程继续执行`co_await`的下面的内容。\n6. 主线程执行协程函数中的`co_return`。会触发协程内部`promise_type`的成员函数，`return_void()`，和类似于析构的`final_suspend()`。\n\n```\n100592 Create MyCoroutine\nget_return_object()...\ninitial_suspend()...\n100592 Running MyCoroutine...\n100592 await_ready()...\n100592 await_suspend()...\n101320 sleep 5s...\n101320 write m_res 100...\n100592 await_resume()...\n100592 After Awaiter get res: 100\nreturn_void()...\nfinal_suspend()...\n100592 Finish MyCoroutine\n\n```\n# 如何包装简单易用的`Awaiter`\n奇技淫巧：重载`operator co_await`。\n\n```cpp\n//--------------------------------------------------------------------\n//  overload co_await for async action.\n//--------------------------------------------------------------------\ntemplate <typename P>\ninline\nagave::details::async_action_t<P>\noperator co_await(agave::details::async_action_base_t<P> const& async)\n{\n    return agave::details::async_action_t<P>{ async };\n}\n\n\n//--------------------------------------------------------------------\n//  overload co_await for async operation.\n//--------------------------------------------------------------------\ntemplate <typename T, typename P>\ninline\nagave::details::async_operation_t<T, P>\noperator co_await(agave::details::async_operation_base_t<T, P> const& async)\n{\n    return agave::details::async_operation_t<T, P>{ async };\n}\n```\n## AsyncAction / AsyncOperation\n\n```cpp\n    //--------------------------------------------------------------------\n    //\t*** for asynchronous function with no returned value ***\n    //--------------------------------------------------------------------\n    template <typename Progress = void, typename Action = async_action_t<Progress>>\n    class async_action_base_t : public async_progress_base_t<Progress>\n\n    //--------------------------------------------------------------------\n    //\timplementations for async_action_base_t.\n    //--------------------------------------------------------------------\n    template <typename Progress = void>\n    class async_action_t : public async_action_base_t<Progress, async_action_t<Progress>>\n```\n\n```cpp\n    //--------------------------------------------------------------------\n    //  *** for asynchronous function with returned value of T ***\n    //--------------------------------------------------------------------\n    template <typename T, typename Progress = void, typename Operation = async_operation_t<T, Progress>>\n        requires(!std::is_void_v<T>)\n    class async_operation_base_t : public async_progress_base_t<Progress>\n\n    //--------------------------------------------------------------------\n    //\timplementations for async_operation_base_t.\n    //--------------------------------------------------------------------\n    template <typename T, typename Progress = void>\n    class async_operation_t : \n        public async_operation_base_t<T, Progress, async_operation_t<T, Progress>>\n```\n\n```cpp\n    //--------------------------------------------------------------------\n    //  specializations for async_progress_base_t class.\n    //--------------------------------------------------------------------\n    template <>\n    class async_progress_base_t<void>\n    {\n    public:\n        //\n\n    };\n```\n\n类`async_action_t`与`async_operation_t`。内部都定义了`await_ready()`、`await_suspend()`、`await_resume()`。是个Awaiter对象。\n## 用户接口\n```cpp\n    //--------------------------------------------------------------------\n    //\t*** returned objects for asynchronous functions ***\n\t//--------------------------------------------------------------------\n\tusing AsyncAction = details::async_action_base_t<>;\n\n    //--------------------------------------------------------------------\n    template <typename P>\n    using AsyncActionWithProgress = details::async_action_base_t<P>;\n\n    //--------------------------------------------------------------------\n    template <typename T>\n    using AsyncOperation = details::async_operation_base_t<T>;\n\n    //--------------------------------------------------------------------\n\ttemplate <typename T, typename P>\n\tusing AsyncOperationWithProgress = details::async_operation_base_t<T, P>;\n```\n\n","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"Linux_rg检索","url":"/Linux/Linux_rg检索/","content":"# 介绍\n\nrg，全称ripgrep，文本搜索工具，有grep、Ack、Ag。rg全称RipGrep，是一个按行搜索工具，它根据提供的pattern递归地在指定的目录里搜索。由Rust写成，相较于同类工具的特点是快、省电。\n\n1. 自动递归搜索\n2. 自动忽略.gitignore中的文件以及二进制文件\n3. 可以限制文件类型\n   4. `rg -t py foo`限定python文件\n   5. `rg -T js foo`排除js文件\n6. 支持各种文件编码（UTF-8、UTF-16、GBK）\n7. 支持搜索常见的压缩文件（gzip、xz、bzip2）\n8. 自动高亮匹配的结果\n\n>扩展：强中更有强中手，现在更有rg的加强版ripgrep-all，能搜索pdf, e-book, office documents, zip, tar.gz等\n\n# 小试牛刀\n\n以下面的文件为测试文件, 命名为a.txt\n\n```\ntest\na\nb\nc\nd\ne\nf\ng\ntest1\nTEST2\n```\n\n1. 基础搜索\n\n```bash\nrg 'test' a.txt\n1:test\n9:test1\n```\n\n```bash\ngrep 'test' a.txt\ntest\ntest1\n```\n\n可见，rg和grep的区别有一点在于rg还额外加了行号\n\n2. `-w`有word之意，表示搜索的字符串作为一个独立的单词时才能被匹配到。\n\n```bash\nrg -w 'test' a.txt\n1:test\n```\n\n3. 使用`-i`选项，不区分大小写\n\n```bash\nrg -i 'test' a.txt\n1:test\n9:test1\n10:TEST2\n```\n\n4. `-l`只打印有匹配信息的文件名字\n\n```bash\nrg -l 'test' a.txt\na.txt\n```\n\n5. `-C`输出匹配上下几行的内容\n\n```bash\nrg -C 2 'c' a.txt#意思是，输出'c'所在这一行的上下两行信息\n2-a\n3-b\n4:c\n5-d\n6-e\n```\n\n# 高级搜索\n\n1. 使用`-e REGEX`来指定正则表达式\n\n```bash\nrg -e \"*sql\" -C2\n```\n\n2. 默认rg会忽略`.gitignore`和隐藏文件，可以使用`-uu`来查询所有内容\n\n```bash\nrg -uu \"word\" .\n```\n\n3. 可以使用`-t type`来指定文件类型\n\n```bash\nrg -t markdown \"mysql\" . #在md文件中查找\"mysql\"关键字\n```\n\n# 搜索文件\n\n列出当前文件夹会进行查询的所有文件，该选项其实可以相当于`find . -type f`，查找当前目录所有文件。\n\n```bash\nrg --files .\n```","categories":["Linux"]},{"title":"20250815面试快速复盘","url":"/面试经验/20250815面试快速复盘/","content":"# Modern Cpp\n1. auto\n2. 范围for循环\n3. 函数对象、lambda\n4. 智能指针\n5. 右值引用\n\n## lambda\n按值捕获，在函数体内能变吗？\n按引用捕获，为什么能变？\n\n# OOP的思想\n1. 封装，主要从控制访问权限切入\n2. 继承\n    1. 隐藏\n    2. 多重继承\n        1. 菱形继承\n            1. 虚继承\n3. 多态\n    1. 重载（静多态）：名字相同，参数列表不同。返回值不参与。\n        1. 编译期就确定了。\n        2. 主要面向泛型编程。\n        3. 可以通过重载、函数模板实现。\n    2. 重写（动多态）\n        1. 虚函数（动态联编）\n        2. 在构造函数中可以调用虚函数，但是没有多态性。\n\n## 四个类型转换\n\n# 智能指针\n## unique和裸指针性能比较\n如果未开启优化，unique性能确实比裸指针差。\n但是如果开启优化，比如release时，unique的反汇编代码，和裸指针一样，而且还是安全的。\n\nunique_ptr性能确实比裸指针差。​​\n​​原因：​​ 编译器不会进行内联优化。每次 unique_ptr的构造、析构、移动赋值、`reset()`、`release()`操作，以及通过 `operator->`或 `operator*`访问成员/解引用，都会生成对相应成员函数的调用指令。\n​​代价：​​ 这些函数调用（即使是简单的）会引入额外的指令（压栈、跳转、弹栈等），增加了代码大小和执行时间。构造/析构可能涉及设置/清除内部指针和可能的自定义删除器状态。移动操作虽然不拷贝资源，但函数调用开销依然存在。\n裸指针优势：​​ 裸指针的操作（赋值、解引用、比较）通常直接对应一条或几条非常底层的 CPU 指令（如 mov, lea, cmp），几乎没有额外开销。\n\n## shared的实现原理\n## shared需要避免的问题\n循环引用。导致对象一直驻存在内存中，无法销毁，内存泄漏。\n## weak可以单独使用吗\n不可以自己构造，而是通过shared赋值或构造。\n主要场景是配合shared使用。\n## weak可以直接解引用吗\n需要看强引用计数是否为0。\n需要调用`lock()`，返回一个强shared引用。\nweak怎么知道的？结构中，有一个控制块，存放了强引用和弱引用计数。\n## makeunique和makeshared\n没使用，则对象和控制块分开存放。\n如果使用，则在一起存放。\n\nmake的优点：空间局部性好。\n\n什么时候该释放对象内存了？强引用技术为0就该释放了，对象在这时应该就算是失效了。但是如果弱引用计数不为0，那么make的对象就因为控制块未释放而不能释放。\n\n**弱引用计数的维护：​**​ 如果存在 `std::weak_ptr`，还需要维护额外的弱引用计数(`weak_count`)。当**强引用计数归零时，只销毁对象**；只有**当弱引用计数也归零时，才释放控制块本身**。\n# STL\n## 六大组件\n1. 容器\n2. 迭代器\n3. 算法\n4. 仿函数\n5. 适配器\n6. 分配器\n## 容器\n顺序型：Vector（向量）、List（）、Array\n关系型：map、set。unorderedmap、unorderedset。\n### set、map的底层\n有序的，使用红黑树实现的\n### unorderedset、unorderedmap的底层\n哈希表实现。\n### 如何解决哈希冲突\n哈希冲突是哈希表中无法避免的现象（多个不同键映射到同一个哈希槽位）。以下是解决哈希冲突的主要方法及其特点：\n#### ​**​1. 开放定址法 (Open Addressing)​**​\n​**​核心思想​**​：当发生冲突时，在哈希表中​**​寻找下一个空闲槽位​**​存储数据\n- ​**​常见探测方式​**​：\n    - ​**​线性探测 (Linear Probing)​**​：\n        冲突时顺序检查下一个槽位（`index = (hash(key) + i) % size`, `i=1,2,3...`）。\n        _缺点：易产生“聚集效应”，降低查询效率。_\n    - ​**​二次探测 (Quadratic Probing)​**​：\n        按二次方跳跃探测（`index = (hash(key) + i²) % size`, `i=1,2,3...`）。\n        _缺点：可能无法找到空闲槽位（即使存在）。_\n    - ​**​双重散列 (Double Hashing)​**​：\n        使用第二个哈希函数计算步长（`index = (hash1(key) + i * hash2(key)) % size`）。\n        _优点：分布更均匀，是开放定址法中的最优方案。_\n- ​**​适用场景​**​：数据量较小、内存紧凑的场景（如嵌入式系统）。\n#### ​**​2. 链地址法 (Separate Chaining)​**​\n​**​核心思想​**​：将每个哈希槽位作为​**​链表/树的头节点​**​，冲突的键值对存储在同一槽位的链表中。\n- ​**​实现方式​**​：\n    - 冲突时，将新数据​**​插入槽位对应的链表末尾​**​。\n    - 查询时遍历链表查找目标键。\n- ​**​优化方案​**​：\n    - ​**​链表转红黑树​**​（如Java 8+的HashMap）：当链表长度超过阈值（如8）时，将链表转为红黑树，将查询效率从`O(n)`提升至`O(log n)`。\n- ​**​优势​**​：\n    - 处理冲突简单，无聚集问题。\n    - 支持高效动态扩容。\n- ​**​工业应用​**​：Java `HashMap`、Python `dict`、C++ `unordered_map`均采用此方案。\n#### ​**​3. 公共溢出区法 (Overflow Area)​**​\n​**​核心思想​**​：分配独立空间存储所有冲突数据\n- 哈希表分为​**​主表​**​和​**​溢出区​**​。\n- 冲突时，将数据存入溢出区，主表对应槽位​**​指向溢出区的链表​**​。\n- ​**​适用场景​**​：冲突率较低或数据量固定的场景（较少用）。\n#### ​**​4. 再哈希法 (Rehashing)​**​\n- 冲突时使用​**​另一个哈希函数​**​重新计算位置。\n- 需要预置多个哈希函数（如`hash1(key)`, `hash2(key)`...）。\n- ​**​缺点​**​：计算成本高，通常用于特殊场景（如布隆过滤器）。\n#### ​**​实际工程中的关键考量​**​\n1. ​**​负载因子 (Load Factor)​**​\n    定义：已存储键值对数 / 哈希表总槽位数。\n    ​**​当负载因子超过阈值（如0.75）时触发扩容​**​（如Java HashMap），避免冲突率急剧上升。\n2. ​**​动态扩容 (Resizing)​**​\n    扩容步骤：\n    - 新建更大的哈希表（通常翻倍）。\n    - 将旧表数据​**​重新哈希​**​到新表。\n    - _均摊时间复杂度为O(1)_。\n3. ​**​哈希函数设计​**​\n    目标：尽可能均匀分布（雪崩效应）。\n    常见算法：MurmurHash、CityHash（非加密场景）；SHA-256（安全场景）。\n#### ​**​选择指南​**​\n\n|​**​方法​**​|​**​优势​**​|​**​劣势​**​|\n|---|---|---|\n|​**​链地址法​**​|高效处理高冲突，易实现删除|指针占用额外内存，缓存不友好|\n|​**​开放定址法​**​|内存紧凑，缓存友好|删除复杂，易聚集|\n|​**​公共溢出区​**​|实现简单|溢出区过大时性能下降|\n\n> 📌 ​**​工业实践建议​**​：\n> - 通用场景优先选择​**​链地址法​**​（如Java/Python内置实现）。\n> - 内存敏感场景（如嵌入式）考虑​**​开放定址法​**​。\n> - 务必通过​**​负载因子控制扩容​**​以维持`O(1)`操作复杂度。\n# c程序的编译链接过程\n1. 预编译。\n    1. 宏定义\n    2. 代码开关\n    3. 头文件\n2. 编译。\n    1. 生成汇编代码\n3. 汇编\n    1. 生成二进制的目标文件\n4. 链接\n    1. 生成可执行程序。\n# 浮点数相等怎么判断\n# 数据结构\n\n## B树（B代表Balanced）\n是一个搜索树，而且是平衡的。\nBST（Binary Search Tree，二叉搜索树）只有搜索性质，没有平衡性质。\n\n搜索性能：m阶，指的是1个节点，最多有多少分支。N是数据规模：$log_m N$\n\n## 红黑树的性质（通过什么规范达到平衡）\n1. 根节点是黑色。\n2. 如果左右孩子是NIL, 则把此孩子看作黑色节点; 实际上这个NIL节点是哨兵节点, 可看作一个公共叶子节点; \n3. 从每个叶子到根的所有路径上不能有两个连续的红色节点; 如此, 每个红色节点的两个子节点都是黑色。\n4. **从任一节点到其每个叶子(可以包含NIL公共叶节点)的所有路径都包含相同数目的黑色节点**。\n\n红黑树其实是2-3树的一个变形（不存在4型节点）。\n由于不存在4型节点，所以不能出现2个连续的红色节点。\n\n![](../../images/C语言_树/image-20250225072634225.png)\n\n红黑树最长支的长度 不超过 最短支的长度的2倍。虽然AVL树最大差1，但AVL树插入性能太慢。红黑树就很好地平衡了层数差异和性能。\n\n二叉树的极端形式就是：一支最长、一支最短。\n根据**从任一节点到其每个叶子(可以包含NIL公共叶节点)的所有路径都包含相同数目的黑色节点**，只要黑色节点数一样，就算是红黑树。那么：\n左子树最长情况下是一红线一黑线交替穿插。右子树最短情况下是全黑。这种情况下，左右两支黑节点数一样，而左支和右支的高度差最大是2倍。\n# 算法\n以动态规划和数据结构为主  基础题会出现如重载操作符  回文序列等问题\n贪心算法和洗牌算法大公司一般都会问\nTop k问题\n## 排序算法\n1. 插入型：直接插入、希尔排序\n2. 选择型：选择排序、堆排序\n3. 比较型：冒泡排序、快速排序\n4. 归并排序\n\n## 快速排序的思想\n### 怎么选基准值\n快速排序，越乱序，越快。越有序，越慢\n1. 随机选，达到乱序的效果。\n2. 三位取中。尽量选到靠近中间的值。划分的两支比较均衡。\n\n### 怎么优化\n1. 规模小的时候，用直接插入排序\n2. 递归深度怎么控制。记录一个递归深度的变量，减到零的时候，就使用堆排序进行优化。\n    1. 尾递归的消除\n    2. 内省排序。\n## 分治算法\n## 动态规划\n### 动态规划的思想\n状态重叠？\n\n核心思想：以空间换时间。把原问题拆成几个重叠子问题。通过几个小问题去推导大问题的解。\n# 操作系统\n## 进程和线程的区别\n1. 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 执行调度的单位。\n2. 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程不会涉及这些资源管理信息，而是共享进程的资源。\n3. 线程的终止时间比进程快，因为线程释放的资源相比进程少很多\n4. 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程，页表切换开销是比较大的。\n## 进程的通信方式\n1. 管道\n    1. 匿名管道：`int pipe(int fd[2])`。\n        1. 通信范围是存在父子关系的进程\n        2. 返回时向传入的fd数组写入了两个描述符。这两个描述符同属一个进程。一个是写端，一个是读端。管道只能一端写入，另一端读出。\n        3. fork会复制描述符。为了避免fork后，父子进程读写混乱。父进程关闭读取的 `fd[0]`，只保留写入的 `fd[1]`；子进程关闭写入的 `fd[1]`，只保留读取的 `fd[0]`。\n        4. 如果需要双向通信，则应该创建两个管道。\n    2. 命名管道，也被叫做 `FIFO`。因为数据是先进先出的传输方式\n        1. 在不相关的进程间（非父子）也能相互通信\n        2. 需要通过 `mkfifo` 命令来创建，并且指定管道名字`mkfifo myPipe`\n        3. 以文件的方式存在：\n           `prw-r--r--. 1 root    root 0 Jul 17 02:45 myPipe`\n        4. 向这个文件写入数据时，另一端就可以读取。\n           `echo \"hello\" > myPipe`\n        5. 操作了后，命令就停在这了，因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。\n    3. 效率低，管道不适合进程间频繁地交换数据\n2. 消息队列\n    1. 消息队列是保存在内核中的消息链表。存在用户态与内核态之间的数据拷贝开销\n3. 共享内存\n    1. 虚拟内存映射到同一块物理内存。\n    2. 避免了拷贝内核的开销。\n4. 信号量\n    1. 同步控制共享内存。\n5. 信号\n    1. 异步通信机制。可以为信号定义一个信号处理函数，有信号时，执行回调。\n6. socket\n### 管道图示\n进程中pipe创建匿名管道并fork\n![](../../images/20250815面试快速复盘/image-20250820092506190.png)\n\n命令行`A | B`的原理：Shell进程创建匿名管道，fork出两个子进程。\n![](../../images/20250815面试快速复盘/image-20250820092600867.png)\n\n## 进程调度算法\n1. FIFO（FCFS，First Come First Serve）\n2. 最短作业优先\n3. 高响应比。兼顾了FIFO和最短作业优先。\n    1. 响应比指：(等待时间+需要执行时间) / 需要执行时间。如果等待时间过长，则优先执行。如果等待时间一致，则谁需要执行时间越短，谁优先\n4. 时间片轮转\n    1. 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；\n    2. 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；\n5. 最高优先级调度算法\n    1. 两种处理优先级高的方法：非抢占式和抢占式\n        1. 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程\n        2. 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。\n6. 多级反馈队列调度算法\n    1. 是「时间片轮转算法」和「最高优先级算法」的综合。\n    2. 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短\n    3. 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；\n\n![](../../images/20250815面试快速复盘/image-20250820074634077.png)\n\n\n## 乐观锁、悲观锁？\n乐观锁是什么场景用。默认不会被改，即多读少写的场景。\n## 死锁\n### 产生死锁的条件\n需要同时满足：\n1. 互斥\n2. 持有并等待\n3. 不可抢占\n4. 环路等待\n### 如何避免死锁\n银行家算法。\n\n破除四个条件之一就行：\n主要是破除环路等待。\n\n最常见的并且可行的就是**使用资源有序分配法，来破环环路等待条件**。\n\n即，两个线程都先获取互斥锁 A，然后获取互斥锁 B。顺序一致。\n### 如果发生死锁，怎么判断死锁的位置\nLinux 下的 C 程序，可以使用 `pstack` + `gdb` 工具来定位死锁问题\n\npstack 命令可以显示每个线程的栈跟踪信息（函数调用过程），`pstack <pid>` 就可以了。\n\n![](../../images/20250815面试快速复盘/image-20250820073330063.png)\n\n但是，还不能够确认这两个线程是在互相等待对方的锁的释放，因为我们看不到它们是等在哪个锁对象，\n\n可以使用 gdb 工具进一步确认（`gdb -p <pid>`）。\n`info thread`：打印线程信息。每个线程对应了一个LWP。\n`thread 2`：切换到指定线程\n`bt`：打印函数堆栈\n`frame 3`：打印某个函数帧的信息（函数代码）\n`p mutex_A`：打印互斥量的内容值。`__owner`标示了哪个线程（LWP）持有。\n\n![](../../images/20250815面试快速复盘/image-20250820073440504.png)\n\n\n## 线程崩溃了，进程会崩溃吗？\n不管是子线程还是主线程崩溃，进程都会崩溃。\n比如，子线程非法访问无权限内存。\n\n段错误。（segment fault）\n## 内存泄漏如何排查？\n1. 静态分析工具​​（预防阶段）\n    1. 编译器警告​​：开启 `-Wall -Wextra`（GCC/Clang）或 `/W4`（MSVC）\n    2. Clang-Tidy​​：使用 `clang-tidy -checks=*,-llvm* *.cpp` --检查代码模式\n    3. Cppcheck​​：运行 `cppcheck --enable=all --inconclusive`\n2. 动态分析（运行时检测）\n    1. Linux、Mac首选：Valgrind工具。\n    2. 跨平台高效方案：AddressSanitizer (ASan)​​\n\n也可以重载new、delete，用一个map存储创建、删除对象的记录：程序退出时检查 `allocMap`剩余项\n```cpp\nstatic std::map<void*, std::string> allocMap;\n\nvoid* operator new(size_t size, const char* file, int line) {\n    void* ptr = malloc(size);\n    allocMap[ptr] = fmt::format(\"{}:{}\", file, line);\n    return ptr;\n}\n\nvoid operator delete(void* ptr) noexcept {\n    allocMap.erase(ptr);\n    free(ptr);\n}\n#define new new(__FILE__, __LINE__)  // 关键宏定义\n```\n## 页面置换算法\n1. 最佳页面置换算法。基本思路是，置换在「未来」最长时间不访问的页面。实际无法实现，意义是衡量算法的效率\n2. FIFO：选择在内存驻留时间最长的页面淘汰。有Belady现象。即cache容量越大，缺页率越高。\n3. LRU（Least Recently Used，近来最少使用）\n    1. 选择最长时间没有被访问的页面淘汰。\n    2. 近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。\n    3. 可以用哈希表 + 双链表实现。哈希表存key，双链表是cache。\n        1. 如果我们每次默认从链表头部添加元素，那么显然越靠头部的元素就是**最近使用**的，越靠尾部的元素就是**最久未使用**的\n        2. 如果调用了一个cache中的页面，需要把它移动到头部。\n        3. 为什么要用双链不用单链？\n            1. 因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。\n        4. 为什么要在链表中同时存储 key，而不是只存储 val？\n            1. 当缓存容量已满，我们不仅仅要删除尾部的元素，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键。\n    4. 总的来说：使用 ​**​哈希表 + 严格排序的双链表​**​\n4. 时钟页面置换算法\n    1. 使用 **​哈希表​** + **​循环链表** + 表针，表针指向最老的页面\n    2. 发生缺页中断时，算法首先检查表针指向的页面。\n        1. 如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置\n        2. 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。\n5. 最不常用页面淘汰\n    1. 当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰\n    2. 实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面\n    3. 要增加一个计数器来实现\n    4. 如果要对这个计数器查找哪个页面访问次数最小，需要查找链表本身，如果链表长度很大，是非常耗时的，效率不高\n    5. 还有个缺陷：LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面\n        1. 解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。\n### LRU图示\n![](../../images/20250815面试快速复盘/image-20250820075643281.png)\n### LRU实现\n```cpp\nstruct Node {\n    int key;\n    int value;\n    Node* prev;\n    Node* next;\n\n    Node(int k = 0, int v = 0) : key(k), value(v) {}\n};\n\nclass LRUCache {\nprivate:\n    int capacity;\n    Node* dummy; // 哨兵节点\n    unordered_map<int, Node*> key_to_node;\n\n    // 删除一个节点（抽出一本书）\n    void remove(Node* x) {\n        x->prev->next = x->next;\n        x->next->prev = x->prev;\n    }\n\n    // 在链表头添加一个节点（把一本书放到最上面）\n    void push_front(Node* x) {\n        x->prev = dummy;\n        x->next = dummy->next;\n        x->prev->next = x;\n        x->next->prev = x;\n    }\n\n    // 获取 key 对应的节点，同时把该节点移到链表头部\n    Node* get_node(int key) {\n        auto it = key_to_node.find(key);\n        if (it == key_to_node.end()) { // 没有这本书\n            return nullptr;\n        }\n        Node* node = it->second; // 有这本书\n        remove(node); // 把这本书抽出来\n        push_front(node); // 放到最上面\n        return node;\n    }\n\npublic:\n    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {\n        dummy->prev = dummy;\n        dummy->next = dummy;\n    }\n\n    int get(int key) {\n        Node* node = get_node(key); // get_node 会把对应节点移到链表头部\n        return node ? node->value : -1;\n    }\n\n    void put(int key, int value) {\n        Node* node = get_node(key); // get_node 会把对应节点移到链表头部\n        if (node) { // 有这本书\n            node->value = value; // 更新 value\n            return;\n        }\n        key_to_node[key] = node = new Node(key, value); // 新书\n        push_front(node); // 放到最上面\n        if (key_to_node.size() > capacity) { // 书太多了\n            Node* back_node = dummy->prev;\n            key_to_node.erase(back_node->key);\n            remove(back_node); // 去掉最后一本书\n            delete back_node; // 释放内存\n        }\n    }\n};\n```\n### Clock图示\n![](../../images/20250815面试快速复盘/image-20250820085133517.png)\n\n\n# 网络\n## IO复用？\n## 输入网址，显示网页，都经历了什么过程\n1. 域名解析 - DNS\n2. 协议对应端口。http是80端口，https是443端口。\n    1. https需要额外握手，确认证书\n    2. 浏览器发送http请求。请求内容，是TCP报文的数据部分。\n3. 两个IP + 端口，可以组成一个TCP连接。走传输层。\n4. 交给网络层。走路由器\n5. 再交给数据链路层。\n## 3次握手\n第3次可以携带数据。\n## 4次挥手\n## IP协议分类？\n忘了。五类。\n## 多播地址、广播地址的区别？\n## TCP和UDP分片？\n根据MTU，TCP报文有标识位。在传输层本身就可以分片。\n但UDP没有分片标识位。如果UDP报文很大，用的是IP层报文提供的底层分片服务。\n但是，这可能会导致，一但一个IP包丢失，全部数据就会全丢弃，大大增加丢包概率。\n可以在应用层控制UDP传输的数据不要太大，达到一个分片的效果。这样，即使丢IP包，也只丢失了小部分数据，而不是一丢丢一串。\n### 如果就是想传一个很大的UDP数据包怎么办？\n如果要求UDP报文100%传达，需要模拟实现TCP功能或者QUIC协议。","categories":["面试经验"]},{"title":"Android日志分析系统复盘","url":"/面试经验/Android日志分析系统以及远程诊断、屏蔽接口复盘/","content":"搭建一个HTTP后台服务，（网络库，线程安全）\n根据提供的URL，下载日志压缩包，（下载服务，wget）\n然后进行压缩包的解压操作。（解压服务，tar、7z）\n解压之后，编写脚本程序统计日志文件数目、分类。（脚本编程，Shell）\n使用检索工具，解析日志的关键内容。（检索，rg）\n\n# 目前支持解析的日志类型\n1. anr、tombstone的数目\n2. logdump、kernel log、tombstone的具体事件\n    1. 均已支持检索正则表达式及显示其原句\n3. dropbox panic字眼\n\n# 问题解决 - 报文拆分、超频重发\n响应的消息要发到企业微信API。\n每次的消息都有长度限制为5120个字符，如果超过了限制就需要做一个报文拆分处理\n\n虽然企业微信api发送成功率很高，但是服务器也有必要确认客户端收到了消息，直到收到回发的ok才放心。\n\n按目前项目要处理的内容的体量来说不那么紧要，但是对于可能扩大规模很有必要，\n企业微信接口每分钟只能发20条消息，如果收到超频率应答，需要阻塞1分钟重发。总的来说，需要完善一下系统的确认应答机制。\n## 三种异常处理：分包、循环+重传递归\n```cpp\n    // 查项目目前支持的errcode表\n    if(WorkWXErrCodeErrMsg.find(receivedJson[\"errcode\"]) != WorkWXErrCodeErrMsg.end())\n    {\n        // 接收到ok报文，即客户端确认收到\n        if(receivedJson[\"errcode\"] == 0){\n            return true;\n        }\n        else // 异常处理\n        {\n            LOG_ERROR << \"WorkWX API Return Json ErrMsg: \" << string(receivedJson[\"errmsg\"]);\n            // 超长，分包处理\n            if(receivedJson[\"errcode\"] == WorkWXErrCode::MSG_OUT_OF_LENGTH)\n            {\n                vector<json> splitContentJsonVec;\n                SplitJsonMsgPack(splitContentJsonVec, contentJson, fileName);\n                for(const auto & pack : splitContentJsonVec)\n                {\n                    if(!SendJsonToWX(webhook, fileName, pack, level + 1))\n                    {\n                        LOG_ERROR << \"Failed to send split message pack, contentJson was log to the file.\";\n                        LOG_ERROR << contentJson.dump();\n                        return false;\n                    }\n                }\n                return true;\n            }// 企业微信api规定1分钟只能发20条消息。超频，阻塞1min处理\n            else if(receivedJson[\"errcode\"] == WorkWXErrCode::FREQ_OUT_OF_LIMIT){\n                sleep(60);\n                return SendJsonToWX(webhook, fileName, contentJson, level + 1);\n            }// 微信系统繁忙，超时，阻塞level min重发\n            else if(receivedJson[\"errcode\"] == WorkWXErrCode::BUSY){\n                sleep(level * 60);\n                return SendJsonToWX(webhook, fileName, contentJson, level + 1);\n            }\n        }\n    }\n```\n\n```cpp\nvoid SplitJsonMsgPack(vector<json> & jsonVec, const json &j, const string &fileName)\n{\n    string msgtype = j[\"msgtype\"];\n    string content = j[msgtype][\"content\"];\n    //每个包加 文件名+count(页数)  因为不能超过4096个所以此处抽出72个字节存放包名\n    for(int count = 1, pos = 0; pos <= content.size(); pos += 4024, ++count)\n    {\n        string head = fileName + \" :\" + to_string(count) + \"\\n\";\n        string splitMsg = head + content.substr(pos, 4024);\n        json contentJson = {{\"content\", splitMsg.c_str()}};\n        contentJson = {{\"msgtype\", \"markdown\"}, {\"markdown\", contentJson}};\n        jsonVec.emplace_back(contentJson);\n    }\n}\n```\n# 问题解决 - 本地下载问题\nwget -N 参数：如果本地文件​**​不存在​**​，它会直接下载该文件；如果本地文件​**​已经存在​**​，Wget 会向服务器发出一个 ​**​`HEAD`请求​**​（而非完整的 `GET`请求）来获取该资源的​**​最后修改时间​**​ (`Last-Modified`头部)。\n\n如果一个终端下载了此文件，然后在本地删除掉此文件，再尝试下载时，发现有时不会下载，即误认为存在一样的文件。\n\n需要和后台那边进行沟通，让其提供一个校验码接口，以便可以和本地对比。\n## 先尝试解压，后下载\n优化了一下处理逻辑，先尝试解压再进行下载，对于已经下载好的日志包，效果很明显，直接略去了不必要的下载。\n## 和后台联调 - 压缩包检验码问题\n问了后台那边网址包含不包含压缩包校验码，\n如果不包含，那就把异常情况放在解压缩的环节上，在解压缩脚本上进行异常处理\n# C调用Shell\npopen、system、fork+exec三者的区别、和异常处理，\n\n其中system可以让父进程自动阻塞，避免了下载文件、解压缩的进程安全问题，省去了好多进程控制的代码。但是返回值挺多的，得分好多情况，\n\npopen是封装了fork、pipe、exec，自动关闭了不需要的读写端，由于封装了三个操作，可能代码上很方便，但是可能内部会出现一些异常，需要去避开坑点，\n\n而fork+exec虽然很原始，但是让代码逻辑很明了，主进程可以在等待期间做一些自定义的事。\n\n所以把代码中需要调用脚本的地方各取所需，分情况调用。这也给了一个启发，需要在调用时多看手册、多Google，明确细节和坑点。\n\n# 日志分析系统总体流程\n\n# 远程诊断新的需求\n学习守护平台远程诊断日志上报模块有新的需求，昨天开发的是扫描局域网设备数的代码，需了解安卓多线程和异步编程的知识，学习service有关内容来更好的进行开发远程诊断模块。\n\n前期主要做的是设备端的诊断代码实现，熟悉一下IoT的接口规范，和后台那边对接一下数据格式，熟悉一下传感器的知识，如何获取数据。\n\n熟悉远程诊断现有的代码框架，在此基础上进行扩展，完成获取时间的代码，熟悉麦克风检测和获取传感器的代码。\n\n代码完成后，和后台沟通数据模型，和后台进行联调。\n\n完成网卡信息的获取代码，完成JSON的整合。自测之后，和后台那边进行联调，目前链路是通的，格式正确，但是有些值获取的有点小问题，比如子网掩码。\n\n整理远程诊断的代码，提交到仓库。\n\n调试了一下TC02和DT15的IoT远程诊断功能，解决了一些小问题，提交最新的代码等待合并。\n\n","categories":["面试经验"]},{"title":"Mac_终端配置","url":"/一些工具的使用/Mac_终端配置/","content":"# 选择\nMac的终端有很多选择。\n推荐得比较多的：\n1. iTerm2，是个老牌macOS终端，精巧。并且更新频繁。缺点是不跨平台。\n2. warp。rust写的。GPU渲染，看起来很现代。诟病比较多的是有时太占内存，甚至有时能吃2G。但是集成的无缝AI交互体验很好。\n3. Termius。是专门给多端使用的，主要用于管理SSH。用了用，感觉不太习惯。\n# 终端配置\nwarp默认使用的是zsh配置文件。在`/Users/mrcan/.zshrc`。\n但zsh配置文件在macOS默认是没有的，需要手动创建。\n\n```sh\n# Warp Terminal & Zsh Configuration\n# Colors for different file types in ls command\n\n# Enable colors for ls on macOS\nexport CLICOLOR=1\n\n# macOS BSD ls colors (LSCOLORS format)\n# Format: directory:symlink:socket:pipe:executable:block:character:setuid:setgid:dir_w_sticky:dir_wo_sticky\nexport LSCOLORS=ExGxBxDxCxEgEdxbxgxcxd\n\n# If you have GNU coreutils installed (brew install coreutils), uncomment these:\n# alias ls='gls --color=auto'\n# export LS_COLORS='di=1;34:ln=1;36:so=1;35:pi=1;33:ex=1;32:bd=1;34:cd=1;34:su=0;41:sg=0;46:tw=0;42:ow=0;43:mi=1;37;41:*.tar=1;31:*.tgz=1;31:*.zip=1;31:*.gz=1;31:*.bz2=1;31:*.xz=1;31:*.jpg=1;35:*.jpeg=1;35:*.png=1;35:*.gif=1;35:*.mp3=1;33:*.mp4=1;33:*.avi=1;33:*.mov=1;33:*.pdf=1;31:*.doc=1;31:*.txt=0;37:*.md=1;37:*.json=1;33:*.xml=1;33:*.yml=1;33:*.yaml=1;33:*.js=1;32:*.ts=1;32:*.py=1;32:*.go=1;32:*.rs=1;32:*.cpp=1;32:*.c=1;32:*.h=1;32'\n\n# Useful aliases for colorful output\nalias ll='ls -la'\nalias la='ls -A'\nalias l='ls -CF'\n\n# Enable color support for grep\nalias grep='grep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias egrep='egrep --color=auto'\n\n# Git colors (if you use git)\nalias git='git --no-pager'\n\n# Warp works great with these modern alternatives (install via brew if desired):\n# brew install exa && alias ls='exa --color=always --icons'\n# brew install lsd && alias ls='lsd --color=always'\n# brew install bat && alias cat='bat --style=auto'\n```\n以上配置文件的效果：\nWhat's now working:\n•  Colored directories - Blue folders\n•  Colored file types - Different colors for executables, links, etc.\n•  Useful aliases - ll, la, l for different listing views\n•  Colored grep - Search results will be highlighted\n\n写入配置文件后，还需要`source ~/.zshrc`使这个配置文件立即生效。\n\n# macOS使用brew安装开发工具，以安装git为例\n通常在macOS上有两种常用的安装方式：brew install或者xcode-select --install\nxcode-select and brew, which is better? what are the difference of them\n## 两者的对比\nHere are the key differences between installing Git via `xcode-select` and Homebrew:\n\n### Xcode Command Line Tools (`xcode-select --install`)\n\n**Pros:**\n- **Apple-maintained**: Official Apple distribution, well-integrated with macOS\n- **Comes with essential dev tools**: Includes GCC, make, and other development utilities\n- **System-level installation**: Installed in `/usr/bin/git`\n- **No additional dependencies**: Built into macOS\n- **Required for many dev tasks anyway**: Needed for compiling software from source\n\n**Cons:**\n- **Slower updates**: Git version updates only come with macOS/Xcode updates\n- **Older versions**: Often ships with older Git versions\n- **Less control**: Can't easily switch versions or customize installation\n\n### Homebrew (`brew install git`)\n\n**Pros:**\n- **Latest versions**: Usually has the most recent Git releases\n- **Easy updates**: `brew upgrade git` keeps you current\n- **Version management**: Can install multiple versions if needed\n- **Package ecosystem**: Access to thousands of other developer tools\n- **Customizable**: Various installation options and configurations\n\n**Cons:**\n- **Additional dependency**: Requires Homebrew to be installed first\n- **PATH management**: Need to ensure Homebrew's path comes before system paths\n- **User-space installation**: Installed in `/opt/homebrew/bin/git` (Apple Silicon) or `/usr/local/bin/git` (Intel)\n\n### Which is Better?\n\n**For most developers, Homebrew is better** because:\n1. You get newer Git features and security fixes faster\n2. You'll likely want Homebrew for other development tools anyway\n3. Easy to keep everything updated\n\n**Use Xcode Command Line Tools if:**\n- You prefer minimal system modifications\n- You don't need the latest Git features\n- You're doing iOS/Mac development (you'll need Xcode tools anyway)\n\n**Recommendation**: Install Xcode Command Line Tools first (many things depend on it), then install Git via Homebrew for the best of both worlds.\n## brew的安装\n默认macOS是没有brew的。需要先安装。而安装brew还需要安装xcode command line tools（在安装brew时如果检测到没有这个，会自动帮你装）。\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n安装完之后，它会提示你，加入PATH：\n```bash\n# Run these commands in your terminal to add Homebrew to your PATH:\necho >> /Users/mrcan/.zprofile\necho 'eval \"$(/opt/homebrew/bin/brew shellenv)\"' >> /Users/mrcan/.zprofile\neval \"$(/opt/homebrew/bin/brew shellenv)\"\n```\n之后，就可以`brew help`测试了。\n\n>但是，这里有个坑，就是第二句，实际最后`.zprofile`文件中保存成了`eval \\\"$(/opt/homebrew/bin/brew shellenv)\\\"`。\n>导致下一次打开终端报错：\n\n```\n(eval):1: no such file or directory: export HOMEBREW_PREFIX=/opt/homebrew; export HOMEBREW_CELLAR=/opt/homebrew/Cellar; export HOMEBREW_REPOSITORY=/opt/homebrew; fpath[1,0]=/opt/homebrew/share/zsh/site-functions; PATH=/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin; export PATH; [ -z  ] || export MANPATH=:; export INFOPATH=/opt/homebrew/share/info:;\n```\n\n>应该存成`eval \"$(/opt/homebrew/bin/brew shellenv)\"`才对。\n>修改之后，`source ~/.zprofile`即可生效。\n>The issue was in your .zprofile file where the quotes around the eval command were escaped (with backslashes), which caused the shell to interpret them incorrectly.\n>This command properly sets up your Homebrew environment variables (like HOMEBREW_PREFIX, PATH, etc.) that you saw in the error message. The error occurred because the shell couldn't properly execute the command due to the escaped quotes.\n>Your shell should now work properly without that error. You can restart your terminal or run source `~/.zprofile` to apply the changes.\n## brew安装git\n```bash\nbrew install git\ngit --version\n```\n# git配置\n## 生成公钥\n```bash\nssh-keygen -t ed25519 -C \"your_email@example.com\"\n```\n默认生成到了`~/.ssh/id_rsa`or`~/.ssh/id_ed25519`\n\n实际测试，默认保存到了`/Users/mrcan/.ssh/id_ed25519`，这是私钥，公钥保存到了`/Users/mrcan/.ssh/id_ed25519.pub`\n\n之后，把公钥上传到GitHub即可。\n## 发现不能读取repo\n```bash\nssh -T git@github.com\n```\n这是通用的检测方法。发现不行。\n原因是我们没有把github.com添加到可信名单中。\n```bash\nssh-keyscan -H github.com >> ~/.ssh/known_hosts\n```\n现在，再次\n```bash\nssh -T git@github.com\n```\n回复：\n```\nHi xing-cg! You've successfully authenticated, but GitHub does not provide shell access.\n```\n现在还需要在本地配置自己的user.email\n```bash\ngit config --global user.email \"myemail@xxx.com\"\n```\n现在就可以正常git管理repo了。\n# 安装npm\nmacOS默认没有npm。\n可以用brew安装node.js。\n```bash\nbrew install node\nnode --version\n```\n之后，在有`package.json`的目录中，就可以直接`npm install`安装依赖了。\n## hexo博客依赖安装\nhexo博客目录下只`npm install`还不够，还需要安装`hexo-cli`\n```bash\nnpm install -g hexo-cli\n```\n# 远程连接云服务器\n```\nssh-keyscan -H mrcan.work >> ~/.ssh/known_hosts\n```\n之后才能进行连接请求：\n```\nssh root@mrcan.work\n```","categories":["一些工具的使用"]},{"title":"Mac_登录项与扩展项目管理","url":"/一些工具的使用/Mac_登录项与扩展项目管理/","content":"参考文章：https://www.cnblogs.com/Flat-White/p/18095629\n\n许多软件卸载后在“登陆项 - 允许在后台”会出现残留项目\n\n# 删除卸载残留“允许在后台”项目\n\nTerminal运行以下命令\n```bash\nsudo -- bash -c 'echo \" - $(date) -\"; while IFS= read -r eachPlist; do echo \"-$eachPlist\"; /usr/bin/defaults read \"$eachPlist\"; done <<< \"$(/usr/bin/find /Library/LaunchDaemons /Library/LaunchAgents ~/Library/LaunchAgents /private/var/root/Library/LaunchAgents /private/var/root/Library/LaunchDaemons -name \"*.plist\")\"; /usr/bin/defaults read com.apple.loginWindow LogoutHook; /usr/bin/defaults read com.apple.loginWindow LoginHook' > ~/Desktop/launch.json\n```\n查看桌面生成的JSON文件后寻找需要删除项目\n\n可以通过`WorkingDirectory`项目判断是否该项目为卸载残留\n\n例如下面项目需要删除\n```json\n-/Users/saber/Library/LaunchAgents/com.shoplex.pandaclearproxy.plist\n{\n    EnvironmentVariables =     {\n        \"DYLD_LIBRARY_PATH\" = \"/Applications/Plex/Contents/Frameworks/\";\n    };\n    KeepAlive = 0;\n    Label = \"com.shoplex.pandaclearproxy\";\n    ProgramArguments =     (\n        \"/Applications/Panda.app/Contents/MacOS/CloseProxy\"\n    );\n    RunAtLoad = 1;\n    WorkingDirectory = \"/Applications/Panda.app/Contents/MacOS\";\n    version = \"1.1.1\";\n}\n```\n根据路径执行以下命令即可删除\n```bash\nsudo rm -f ~/Library/LaunchAgents/com.shoplex.pandaclearproxy.plist\n```\n\n# 详细检索“允许在后台”项目\n如果仍然有项目无法搜索到，运行以下命令并且查看生成的`BTM.json`\n```bash\nsfltool dumpbtm > ~/Desktop/BTM.json\n```\n查看后发现部分 “允许在后台” 项目在设置面板显示的是`Developer Name`健值\n\n也有部分显示的是`Assoc. Bundle IDs`健值\n\n具体情况可以自行对比上述命令生成的`BTM.json`与设置面板\n\n例如下图的中的项目在查看了`BTM.json`后发现都是目前仍然在使用的应用程序\n\n如：\n![](../../images/Mac_登录项与扩展项目管理/image-20250813234907743.png)\n\n\nwon fen是Clash Verge的开发者\nzhou huabing是RustDesk的开发者\n![](../../images/Mac_登录项与扩展项目管理/image-20250813235002948.png)\n\nMicrosoft Corporation是Remote Desktop相关的服务\n\n因此不建议删除\n\n如果需要删除\n\n使用如下命令行\n```bash\nsudo find /Library/LaunchDaemons /Library/LaunchAgents ~/Library/LaunchAgents -name \"com.west2online.ClashXPro\" -type f -delete\n```\n\n`com.west2online.ClashXPro`可以替换为其他需要删除的`Assoc. Bundle IDs`对应健值","categories":["一些工具的使用"]},{"title":"tar_常用命令","url":"/一些工具的使用/tar_常用命令/","content":"\n```sh\ntar -czvf xxx.tar.gz source_file (tar -czvf 包名.tar.gz 源文件) #以tar.gz方式打包并gz方式压缩\ntar -xzvf xxx.tar.gz -C path     (tar -xzvf xxx.tar.gz -C 目标路径) #解压缩包\n```\n","categories":["一些工具的使用"]},{"title":"杀虫知识_蛾蠓","url":"/生活/杀虫知识_蛾蠓/","content":"\n# 杀蛾蠓和小飞虫最好用什么成分？\n\n消灭蛾蠓和小飞虫，最有效且相对安全的成分通常是​**​拟除虫菊酯类杀虫剂​**​。以下是详细分析和推荐：\n\n## 🧪 1. 最推荐的核心成分：拟除虫菊酯类\n\n- ​**​常见有效成分：​**​ 氯菊酯、胺菊酯、氯氰菊酯、溴氰菊酯、高效氯氟氰菊酯等。\n- ​**​优点：​**​\n    - ​**​高效广谱：​**​ 对蛾蠓、小飞虫（果蝇、蚤蝇等）、蚊子、苍蝇等多种飞行和爬行昆虫都有很好的触杀和击倒效果。\n    - ​**​低毒（相对）：​**​ 相较于有机磷类等老式杀虫剂，菊酯类对哺乳动物的毒性较低，在正确使用下相对安全。\n    - ​**​作用迅速：​**​ 接触后能快速击倒害虫。\n    - ​**​有一定滞留性：​**​ 喷洒在表面后能维持一段时间的药效，起到预防作用。\n- ​**​产品形式：​**​\n    - ​**​气雾杀虫剂：​**​ 超市常见的罐装喷雾，通常含有多种菊酯复配（如胺菊酯+氯菊酯），并配有推进剂，能快速杀灭空中飞虫。这是对付成虫最直接快速的方法。\n    - ​**​滞留喷洒剂/浓缩液：​**​ 需要用水稀释后用喷壶喷洒在墙面、角落、缝隙、垃圾桶周围、下水道口等害虫栖息和活动区域。药液干后会形成一层药膜，害虫接触后中毒死亡，药效可持续数周。这是长效防治的关键。\n    - ​**​蚊香/电热蚊香液：​**​ 主要成分也是菊酯类（如氯氟醚菊酯），对室内飞虫有一定驱避和杀灭作用，但效果不如直接喷洒。\n\n## 🦠 2. 针对幼虫（源头治理）：生物制剂\n\n- ​**​有效成分：​**​ ​**​苏云金杆菌以色列亚种​**​。\n- ​**​优点：​**​\n    - ​**​高度特异：​**​ 只对蚊、蠓、蚋等双翅目昆虫的幼虫有效，对鱼虾、人畜、益虫基本无害，非常环保安全。\n    - ​**​源头控制：​**​ 直接杀灭在积水（如地漏、下水道、花盆托盘、空调积水盘）中孳生的幼虫，从根源上减少成虫数量。\n- ​**​产品形式：​**​\n    - ​**​BTI颗粒剂/片剂：​**​ 投入积水处（如地漏存水弯、下水道口、花盆底托等），缓慢释放有效成分，持续杀灭幼虫数周。\n\n## 🚫 3. 其他成分（需谨慎使用或不推荐）\n\n- ​**​有机磷类：​**​ 如敌敌畏、毒死蜱等。虽然有效，但毒性较高，残留期长，对人和宠物风险较大，​**​强烈不推荐​**​在家庭室内环境使用。\n- ​**​氨基甲酸酯类：​**​ 如残杀威等。效果也不错，但毒性也相对较高，家用产品中不如菊酯类常见和安全。\n- ​**​吡虫啉等新烟碱类：​**​ 对蚜虫、粉虱等刺吸式口器害虫效果显著，但对蛾蠓、小飞虫等效果通常不如菊酯类直接。\n\n## 📌 总结与建议\n\n1. ​**​对付成虫（空中飞虫）：​**​\n    - ​**​首选：​**​ 含有​**​氯菊酯、胺菊酯、氯氰菊酯​**​等成分的​**​气雾杀虫剂​**​。对准飞虫直接喷射。\n    - ​**​长效预防：​**​ 使用​**​菊酯类浓缩液​**​进行​**​滞留喷洒​**​，重点处理卫生间、厨房、垃圾桶周围、窗框、墙角、下水道口等区域。\n2. ​**​对付幼虫（源头控制）：​**​\n    - ​**​最安全有效：​**​ 使用​**​苏云金杆菌以色列亚种​**​制成的​**​颗粒剂或片剂​**​，定期投放于地漏、下水道、花盆底托等所有可能的积水处。这是治本的关键❗️\n3. ​**​环境治理至关重要：​**​\n    - ​**​清除孳生地：​**​ 这是最根本的方法！保持环境干燥，清除所有不必要的积水（花盆托盘、废弃容器、堵塞的排水沟、空调冷凝水盘等）。\n    - ​**​清洁卫生：​**​ 及时清理厨余垃圾、腐烂水果🍎，保持垃圾桶清洁并盖好盖子。清洁卫生间、厨房的污垢和水渍，特别是地漏周围。\n    - ​**​检查地漏和下水道：​**​ 确保地漏有存水弯且水不干涸，定期用热水或消毒液冲洗下水道。\n    - ​**​物理方法：​**​ 安装纱窗纱门，使用电蚊拍、粘虫纸作为辅助。\n\n## 📌 重要提示\n\n- ​**​安全第一：​**​ 使用任何化学杀虫剂时，务必仔细阅读并遵循产品标签说明。注意通风，避免吸入，喷洒时避开食物、餐具、宠物和儿童。喷洒后离开房间一段时间再进入。\n- ​**​综合治理：​**​ 单一方法效果有限。​**​源头治理（清除积水+BTI杀幼虫）+ 环境清洁 + 成虫杀灭（菊酯喷雾/滞留喷洒）​**​ 才是最有效的组合拳。\n- ​**​识别虫种：​**​ 确认是蛾蠓还是其他小飞虫（如果蝇），因为它们的孳生环境略有不同，但上述方法基本通用。\n\n​**​综上所述，拟除虫菊酯类杀虫剂（如氯菊酯）是杀灭蛾蠓和小飞虫成虫的最佳选择，而苏云金杆菌是消灭其幼虫最安全有效的生物武器。​**​ 配合彻底的环境治理，才能有效控制这些恼人的小飞虫。\n\n# 蛾蠓的羽化原理\n厕所里上一个小时还没有小飞虫，隔一会儿进去突然就出现了3到5只小飞虫，每进去一次我都杀死3、4个，但是每次进去居然都会有新的，洗手池的下水道口我用起泡胶封住了，地漏有盖子，排风扇我不知道会不会因为向外通风的原因会从这里飞进来。到底是因为什么呢？\n\n说明飞虫的​**​孳生源就在厕所内部或极其近的地方​**​！虽然你封住了洗手池下水道口、盖了地漏盖，但虫卵或幼虫很可能隐藏在你忽略的​**​更隐蔽、更潮湿的角落或缝隙里​**​。\n\n## 🔍 飞虫爆发性出现的原因分析\n\n1. ​**​孳生点未被彻底清除（最可能！）：​**​\n    \n    - ​**​地漏隐患最大！​**​ 即使有盖子，问题可能出在：\n        - ​**​盖子的密封性：​**​ 盖子边缘是否变形、有缝隙？虫子（尤其是蛾蠓幼虫/蛹）可能就从这里爬出来羽化。​**​用力按压盖子，检查四周是否有明显缝隙。​**​\n        - ​**​地漏内部存水弯失效/干燥：​**​ 存水弯干涸或设计不佳（有些劣质地漏存水弯很浅），无法阻隔下水道里的虫子或气味（吸引虫子）。​**​往地漏里缓缓倒一杯水，听听是否有“咕咚”声（表示水进入存水弯），观察水流下得快不快（如果立即消失，可能存水弯浅或水封失效）。​**​\n        - ​**​地漏内壁积累污垢：​**​ 盖子下面、地漏篦子下、存水弯内壁积累厚厚的粘滑有机污垢（肥皂垢、毛发、皮屑等），这是蛾蠓幼虫的完美食物来源和藏身处！​**​用筷子裹上布或棉签伸进去擦拭内壁感受是否有滑腻感。​**​\n    - ​**​洗手池封堵可能不彻底：​**​\n        - ​**​起泡胶的渗透性/持久性：​**​ 起泡胶本身是否有微小缝隙？是否被水流或湿气软化、脱落了部分？虫子可能找到薄弱点钻出。​**​用手电筒仔细照射起泡胶边缘和表面，看是否有小孔或裂纹。​**​\n        - ​**​洗手池下方管道：​**​ 洗手盆下方的水管连接处（软管接头、U型弯头背面）是否阴暗潮湿或有渗漏？这里也是孳生地。​**​弯腰检查洗手盆下方的橱柜里（如果有），用手电照角落、看管壁是否有水渍、霉斑。​**​\n    - ​**​其他被忽略的孳生点（常被忽视！）：​**​\n        - ​**​拖把/扫帚/抹布：​**​ 沾满污水、潮湿的拖把、扫帚、抹布（尤其放在厕所角落里或桶里泡着）是产卵和孳生的绝佳场所！​**​闻闻拖把是否有馊味霉味。​**​\n        - ​**​垃圾桶：​**​ 即使有盖，内壁、盖子缝隙也可能残留湿垃圾液、污垢，吸引产卵。​**​擦一下垃圾桶内壁是否有黏液感。​**​\n        - ​**​潮湿墙面/墙角/瓷砖缝隙：​**​ 厕所长期潮湿导致这些地方长霉、积累有机质，也可能成为食物源。​**​仔细看墙面瓷砖缝是否发黑？​**​\n        - ​**​马桶周围/底座后方缝隙：​**​ 马桶底座与地砖之间的玻璃胶密封处老化发黑，滋生霉菌，或者后方隐蔽处有残留污渍。​**​用镜子反射观察马桶背后。​**​\n        - ​**​排风扇内部/管道：​**​ 排风扇的风叶、管道接口处积累灰尘，如果管道有破损或倒灌，可能引入或滋生虫子（但更可能是内部孳生源头羽化后飞近排风扇）。\n2. ​**​外部迁入（可能性较小但需排查）：​**​\n    \n    - ​**​排风扇倒灌：​**​ 虽然排风扇是向外排风，但如果其内部或连接管道的密封不好，在关闭状态下，气压、风向变化、或邻居家也在使用排风扇时，可能出现短暂的倒吸现象，将附近管道或其他区域的虫子或气味吸入。​**​尝试在下次进入厕所前1小时打开排风扇强力排风30分钟，再关闭进去看看是否有改善（如果是倒灌，强力排风能减少入口附近的虫子）。​**​\n3. ​**​成虫羽化&繁殖速度：​**​\n    \n    - 蛾蠓从卵到成虫只需1-3周。隐蔽孳生点中的蛹源源不断地羽化成虫，即使你每次进去都杀死几只成虫，​**​源头未断，新的蛹又源源不断孵化出来​**​，形成“杀之不尽”的局面。\n## 📌 关键总结\n\n- ​**​问题核心：​**​ 厕所里必然存在一个被遗漏的、潮湿富含有机质的​**​隐蔽孳生点​**​（​**​地漏内部​**​嫌疑最大，其次是拖把/墙角霉菌/洗手池下）。\n- ​**​治标无效：​**​ 光杀成虫不解决源头是徒劳的。\n- ​**​治本核心：​**​ ​**​彻底深度清洁所有可能的积污潮湿点（尤其是地漏内部，务必清理干净+恢复水封！），保证环境卫生干燥！​**​\n- ​**​菊酯类杀虫剂​**​是快速高效杀灭成虫的好工具（务必按说明安全使用）。\n- 对排风扇进行简单验证试验（罩纱网）能快速排除或确认其影响。\n\n​**​立即执行地漏深度清洁计划！​**​ 把地漏当成重点嫌疑人深挖彻查，同时清理所有潮湿角落，配合喷杀成虫，坚持几天，源头断掉后你会发现飞虫数量骤减直至消失！💪🏻\n\n## 为什么突然就有成虫了呢？我平时也看不到他们的卵啊，怎么突然这么快的长大的呢？\n “​**突然出现”、“数量不大但持续不断”​**​ 的成虫现象，正是蛾蠓（或类似小飞虫）​**​独特生活史和孳生特点​**​的典型表现！为什么看不见卵、也看不到幼虫？为什么感觉它们“突然长大”？主要原因如下：\n\n🧩 ​**​核心解释：隐秘孳生 + 同步羽化 + 间断补充​**​\n1. ​**​卵和幼虫藏在您看不到的“微观湿地”里：​**​\n    - ​**​孳生点极隐蔽且微小：​**​ 飞虫（尤其蛾蠓）的卵和幼虫​**​不需要大片水域​**​！它们只需要 ​**​一层湿润的有机生物膜（Biofilm）​**​。这种生物膜存在于：\n        - ​**​地漏存水弯内壁、盖板下方凹槽​**​：即使有水封，内壁积累的粘滑污垢薄层就足够！\n        - ​**​下水管道壁（尤其排水慢的管道）：​**​ 附着在水线以上的管壁污垢薄膜，或水位波动留下的湿润带。\n        - ​**​瓷砖填缝剂细微裂缝/发霉处。​**​\n        - ​**​拖把布纤维深处。​**​\n        - ​**​垃圾桶内壁残留的湿垃圾液膜。​**​\n    - ​**​这些区域肉眼难以观察：​**​ 缝隙太窄、光线太暗、污垢颜色与背景融合。您不会刻意去翻看地漏盖子下或管道内壁的​**​微观情况​**​。\n2. ​**​发育过程隐匿性强：​**​\n    - ​**​卵极小且粘附：​**​ 虫卵微小（小于0.5mm），呈半透明或乳白色，​**​紧密粘附在潮湿污垢表面​**​，肉眼极难分辨。\n    - ​**​幼虫（孑孓状）不活跃：​**​ 幼虫生活在那层粘滑的生物膜中，​**​很少大规模移动​**​，只在食物丰富的局部区域活动，不易被发现。\n    - ​**​蛹期是“隐形”的关键！：​**​\n        - ​**​静止不动：​**​ 幼虫成熟后会爬到稍干燥一点的地方（如地漏盖子下沿、管道壁上端、瓷砖缝隙边缘）​**​化蛹​**​。蛹​**​完全不活动​**​。\n        - ​**​伪装色：​**​ 蛹通常呈​**​深褐色或黑色​**​，且体型很小（约2-5mm长），​**​完美融入​**​周围的污垢和阴影中。\n        - ​**​位置刁钻：​**​ 它们粘附在垂直或倒悬的表面（正是您不会刻意检查的地方）。\n3. ​**​“突然出现”的真相：同步羽化！​**​\n    - 同一个孳生点（比如地漏内壁的一小片区域）的蛹，​**​往往在相近时间发育成熟​**​。\n    - ​**​环境刺激触发“集体羽化”：​**​ 当环境条件成熟（如温度湿度适宜，或受到​**​光线变化、震动、气流（如开门、排风扇启动）​**​ 的刺激时），这些成熟的蛹会​**​几乎同时羽化​**​！\n    - ​**​羽化过程极快：​**​ 成虫破蛹壳而出只需几分钟，翅膀展开后​**​立即具有飞行能力​**​。\n    - ​**​这就是为什么：​**​\n        - ​**​您隔一会儿进去就发现新虫：​**​ 就在您离开的这段时间，上一批蛹在您“打扰”（开门、走动、灯光刺激）后羽化成虫了。\n        - ​**​数量不多不少（3-5只）：​**​ 单个微小孳生点一次能产生的蛹数量就这么多。\n        - ​**​杀完又出现：​**​ 源头孳生点持续产出新的蛹，这些新蛹在您离开后发育成熟，等待下一次“刺激”就羽化出来“报道”。\n4. ​**​孳生点有“后备力量”：​**​\n    - 孳生点是​**​持续产生后代​**​的“工厂”。在您杀死成虫时，孳生点里的​**​卵还在孵化，幼虫还在生长，新蛹还在形成​**​。一波成虫被杀掉，下一波幼虫和蛹正在积蓄力量，准备下一轮羽化。\n    - 在温暖（如厕所）的环境中，​**​发育周期可能短至1周左右​**​，感觉就像“杀不完”。\n\n🔍 ​**​总结情况：​**​\n\n- ​**​不是“突然长大”：​**​ 它们一直在您看不见的地方（污垢膜、缝隙中）默默发育（卵→幼虫→蛹）。\n- ​**​“突然出现”=同步羽化：​**​ 隐蔽的蛹受到​**​环境变化（您的进入——光线、气流、震动）刺激​**​，几乎同时羽化成虫。\n- ​**​“源源不断”= 孳生点持续运作：​**​ 孳生点未被清除，不断产生新的卵、幼虫和蛹。\n- ​**​“数量不多但频繁”= 小型隐秘孳生点：​**​ 说明孳生源比较局限（可能就在一个地漏或一小片区域），但非常隐蔽且效率高。\n\n🛠️ ​**​应对关键（破解“隐秘-爆发”循环）：​**​\n\n1. ​**​找到并摧毁那个“微型工厂”（孳生点）：​**​ ​**​必须打破砂锅问到底​**​！\n    - ​**​地漏是头号嫌疑犯！​**​ 按上次建议，​**​深度清洁地漏内壁和盖子​**​。用强光手电+小镜子仔细观察平时看不见的角落。\n    - ​**​检查一切可能形成“湿润薄膜”的地方：​**​ 包括下水管上端、马桶后侧密封胶、潮湿拖把、垃圾桶内壁。\n2. ​**​使用针对幼虫的生物武器：​**​\n    - 在清洁完孳生点后，定期投入 ​**​BTI（苏云金杆菌）​**​ 颗粒/片剂到地漏、下水口。它能​**​杀死水中/污垢膜中的幼虫​**​，从根本上减少蛹和成虫的数量。\n3. ​**​杀灭成虫的同时“围剿”新蛹：​**​\n    - 在怀疑有孳生点的地方（如地漏周围墙面、水池下方墙面），使用 ​**​滞留型菊酯杀虫剂​**​ 喷洒（按说明）。新羽化的成虫在爬行或停落时会接触到药剂死亡。\n    - 在成虫常出现的区域（如墙面底部、角落）贴上 ​**​黄色粘虫板​**​，物理捕获。\n4. ​**​减少环境刺激（稍作妥协的辅助办法）：​**​\n    - 如果您能长时间（比如24-48小时）保持厕所​**​黑暗、安静、不进入（包括不开排风扇）​**​，可能打乱它们的羽化节奏，部分蛹可能在没有刺激时慢慢羽化飞出被困住。但这在实际生活中较难做到，且不能根除源头。\n\n# 有时候，还会有一两个蚊子，蚊子是从哪里来的，也是地漏吗？\n蚊子（主要是库蚊/家蚊）和蛾蠓、果蝇等小飞虫的孳生环境和习性​**​有显著区别​**​。虽然您偶尔在厕所看到的确实​**​可能是蚊子​**​，但它们通常​**​不是从地漏或下水道里直接孳生​**​出来的。\n\n以下是蚊子进入厕所的可能途径和原因分析：\n\n## 🦟 蚊子进入厕所的主要途径\n\n1. ​**​从其他房间/室外飞入（最大可能！）：​**​\n    \n    - ​**​门窗缝隙：​**​ 蚊子非常擅长通过​**​极其微小的缝隙​**​（几毫米甚至更小）钻入室内。即使装了纱窗纱门，如果边缘有破损、密封不严、或者开关门时快速跟进，蚊子就能进入。厕所可能是它们寻找水源或避光的暂时停留点。\n    - ​**​排风扇通道（关键！）：​**​ 这是厕所特有的通道！您担心的排风扇，正是蚊子进入的主要嫌疑之一：\n        - ​**​管道缝隙：​**​ 排风扇通向室外的管道连接处如果密封不严实，蚊子就能从外部直接飞进来。\n        - ​**​止回阀失效/缺失：​**​ 很多排风扇本身或管道里没有有效​**​止回阀​**​（防倒灌风门），或者止回阀被灰尘、油污卡住无法完全关闭。当风扇​**​停止转动时​**​，蚊子就能顺着管道倒飞入室内。​**​外部气压变化​**​（比如楼下排气或大风）也可能将蚊子推入。\n        - ​**​纱网破损/未装：​**​ 排风扇通向室外的出风口外如果没有安装​**​细密的防虫纱网​**​，或者纱网破损，蚊子就能直接从外面飞入。\n    - ​**​其他管道口/通道：​**​ 空调管道孔、抽油烟机排气口等如果与厕所相连或存在间接通道，也可能成为入口。\n2. ​**​厕所有独立的孳生源（不太常见，但有条件发生）：​**​\n    \n    - ​**​隐蔽的少量积水：​**​ 蚊子（库蚊）雌虫需要在​**​相对清洁的静水中​**​产卵（与蛾蠓喜脏污环境不同）。如果您厕所中存在​**​意外的少量积水​**​且​**​超过1周​**​未清理，蚊子可能会在此孳生。可能的积水点：\n        - ​**​花盆托盘：​**​ 放置的绿植水盘积水未及时倒掉。\n        - ​**​废弃容器：​**​ 角落里的空瓶子、罐子、脸盆等积了雨水或空调水。\n        - ​**​堵塞或排水不畅的地面：​**​ 某处地面不平整导致冲洗后形成小水洼未干。\n        - ​**​卫生死角：​**​ 水箱后方边缘、很少移动的瓶瓶罐罐底座下、拖把桶底部残留的水（必须足够“静置”）。\n    - ​**​孳生规模很小：​**​ 由于厕所环境不像大型花瓶、水缸那样理想，即使有孳生，通常一次只能产生​**​少量蚊子（1-5只）​**​。\n\n## 🔍 如何区分厕所里的蚊子是“飞入”还是“孳生”？\n\n- ​**​时间段和活动性：​**​\n    - ​**​飞入的蚊子：​**​ 通常在您​**​开灯后​**​或​**​开门进入时​**​被发现正在飞行，或停落在明亮、较高的地方（墙上、天花板上）。它们相对活跃，容易被发现。\n    - ​**​孳生的蚊子：​**​ 羽化后初期活动性稍弱，可能在靠近孳生源（积水点）的低处、阴暗角落（如洗手盆下、马桶后）停留。但区别不明显，仅供参考。\n- ​**​数量：​**​\n    - ​**​飞入：​**​ 数量不定，可能一次1只或2-3只。\n    - ​**​孳生：​**​ 同一批孳生点发育出来的蚊子数量会集中出现（但也可能是几只）。\n- ​**​最可靠方法 —— 彻底检查可能的孳生点！​**​ 排除掉所有积水来源。\n\n## 🛡️ 应对策略（针对蚊子）\n\n1. ​**​堵住入口（重点攻破排风扇！）：​**​\n    \n    - ​**​检查并密封排风扇：​**​\n        - ​**​外部防护：​**​ 断电后，卸下排风扇外罩（室内侧），仔细检查通向外部管道口的​**​防虫纱网​**​是否有破损？没装纱网？孔径是否太大（必须<1mm）？ ​**​立即安装或更换致密的金属/尼龙防虫网！​**​ 这是阻断外部蚊子最有效的物理方法！\n        - ​**​内部清洁与密封：​**​ 清洁扇叶和内部腔体灰尘油污，查看止回阀是否能自由活动、完全闭合？阀门边缘是否变形？管道接口处是否用​**​铝箔胶带或填缝胶​**​密封严实？ ​**​更换失效的止回阀。​**​\n    - ​**​封堵门窗缝隙：​**​ 检查纱窗纱门是否完好无破洞，边缘是否贴合紧密？及时修复更换。关门时注意。\n    - ​**​下水口/地漏：​**​ 保持盖好或水封正常（主要是隔离气味和小飞虫，对阻止蚊子飞入效果有限）。\n2. ​**​清除潜在孳生点（避免“内患”）：​**​\n    \n    - ​**​翻盆倒罐清积水：​**​ 检查所有可能积水的物品（花盆托、桶、瓶、罐），彻底清空积水并擦干内壁（蚊子卵可以干死）。​**​重点清理不常移动的卫生死角底部。​**​\n    - ​**​保持地面干燥：​**​ 避免冲洗后形成无法流走的积水洼。及时拖干水渍。\n3. ​**​杀灭成虫：​**​\n    \n    - ​**​电蚊拍：​**​ 最直接。\n    - ​**​菊酯类气雾剂：​**​ 对蚊子同样高效。使用时对准蚊子（或空间喷洒）后关门闷杀。注意安全。\n    - ​**​滞留喷洒：​**​ 在蚊子可能停落的墙面（尤其厕所上部空间、靠近排风扇周围、窗框）、天花板角落喷菊酯类滞留药物。\n4. ​**​辅助防护：​**​\n    \n    - ​**​电热蚊香液：​**​ 长期在厕所插着（选择含氟氯氰菊酯、氯氟醚菊酯等有效成分），持续释放有效成分驱赶和杀灭蚊子。效果可能有限。\n    - ​**​放置捕蚊灯（谨慎）：​**​ 放在角落吸引成虫，但要确保其光源对您夜间如厕不造成干扰，效果存在争议。\n\n# 菊酯类杀虫剂（如氯菊酯）能杀虫卵吗？\n菊酯类杀虫剂（如氯菊酯、高效氯氰菊酯、溴氰菊酯等）​**​对虫卵的杀灭效果通常较弱，甚至无效​**​。这是由其作用机理和虫卵结构特点决定的：\n\n### 🧪 核心原因分析\n\n1. ​**​作用机理限制​**​：\n    \n    - 菊酯类杀虫剂主要是​**​神经毒剂​**​，通过破坏昆虫的神经系统（作用于钠离子通道）使其快速瘫痪、死亡。\n    - ​**​虫卵内部的胚胎在发育早期尚未形成完善的神经系统​**​，药物难以发挥神经毒性作用。\n2. ​**​物理屏障保护​**​：\n    \n    - 虫卵（尤其是飞虫如蛾蠓、蚊子、果蝇的卵）通常有一层​**​坚硬或疏水性的卵壳​**​。\n    - 这层外壳能​**​有效阻挡杀虫剂的渗透​**​，使活性成分无法接触到内部正在发育的胚胎。\n3. ​**​代谢差异​**​：\n    \n    - 卵内胚胎的代谢活动状态与幼虫、成虫不同，对这类神经毒剂的敏感性很低。\n\n### 📊 实际效果总结\n\n|对象|效果|\n|---|---|\n|​**​成虫​**​|✅ ​**​极高效果​**​：快速击倒，高效杀灭（接触或吸入后神经麻痹死亡）。|\n|​**​幼虫​**​|✅ ​**​有效​**​：如果菊酯成分能接触到幼虫（如在水中或有保护膜的环境下，效果不如BTI等专用杀幼剂）。|\n|​**​蛹​**​|⚠️ ​**​效果有限​**​：蛹壳也是一层保护屏障，可能需较高浓度或长时间接触。|\n|​**​卵 (Eggs)​**​|❌ ​**​极低/无效​**​：难以穿透卵壳，内部无靶标系统起作用。|\n# 苏云金杆菌必须是以色列亚种吗？其他亚种有区别吗\n### 🧫 为什么必须是以色列亚种（BTI）？\n\n1. ​**​独特的毒素蛋白组合​**​：\n    \n    - BTI 能产生 ​**​4种主要晶体蛋白（Cry4Aa, Cry4Ba, Cry10Aa, Cry11Aa）和 Cyt1Aa 蛋白​**​。\n    - ​**​Cyt1Aa 蛋白是关键​**​！它能破坏幼虫肠道细胞，使其他毒素更容易进入体内，产生强力协同作用。\n    - ​**​专杀双翅目​**​：这些毒素​**​特异性结合​**​蚊、蠓、蚋、摇蚊等双翅目幼虫中肠上皮细胞的受体，导致肠道穿孔死亡。\n2. ​**​其他常见亚种的作用对象完全不同​**​：\n    \n    - ​**​Bt 库斯塔克亚种 (_B.t._ subsp. _kurstaki_, Btk)​**​：\n        - ​**​主要毒素​**​：Cry1 类蛋白（如 Cry1Ab, Cry1Ac）。\n        - ​**​目标害虫​**​：​**​鳞翅目幼虫​**​（蛾类、蝶类的毛毛虫，如菜青虫、棉铃虫、松毛虫）。\n        - ​**​对双翅目无效！​**​\n    - ​**​Bt 拟步行甲亚种 (_B.t._ subsp. _tenebrionis_, Btt)​**​：\n        - ​**​主要毒素​**​：Cry3 类蛋白（如 Cry3Aa）。\n        - ​**​目标害虫​**​：​**​鞘翅目幼虫​**​（甲虫类，如马铃薯甲虫、黄曲条跳甲）。\n        - ​**​对双翅目无效！​**​\n    - ​**​Bt 鲇泽亚种 (_B.t._ subsp. _aizawai_, Bta)​**​：\n        - ​**​主要毒素​**​：Cry1 类蛋白（部分菌株含 Cry2）。\n        - ​**​目标害虫​**​：​**​鳞翅目幼虫​**​（尤其对夜蛾科、小菜蛾等效果较好）。\n        - ​**​对双翅目无效！​**​\n\n---\n\n### 📊 不同苏云金杆菌亚种的作用范围对比表\n\n|​**​亚种名称​**​|​**​缩写​**​|​**​主要目标害虫​**​|​**​能否杀蚊/蠓/蚋？​**​|\n|---|---|---|---|\n|​**​以色列亚种​**​|​**​BTI​**​|​**​双翅目幼虫​**​  <br>（蚊、蠓、蚋、摇蚊）|✅ ​**​高效专杀！​**​|\n|库斯塔克亚种|Btk|鳞翅目幼虫  <br>（蛾、蝶类毛毛虫）|❌ 完全无效|\n|拟步行甲亚种|Btt|鞘翅目幼虫  <br>（甲虫类）|❌ 完全无效|\n|鲇泽亚种|Bta|鳞翅目幼虫  <br>（部分抗性害虫）|❌ 完全无效|\n|圣地亚哥亚种|Btsd|鞘翅目幼虫  <br>（部分甲虫）|❌ 完全无效|\n\n---\n\n### 💡 为什么不能乱用其他亚种？\n\n1. ​**​完全无效​**​：  \n    其他亚种产生的毒素蛋白​**​无法识别和结合​**​双翅目幼虫的肠道受体，因此对蚊、蠓、蚋等​**​毫无杀灭作用​**​。\n2. ​**​浪费资源​**​：  \n    购买或使用错误的亚种（如Btk）来对付厕所飞虫，既无法解决问题，又浪费时间和金钱。\n3. ​**​可能误伤非目标生物​**​：  \n    若将Btk喷洒到植物上防治飞虫（实际无效），可能误杀蝴蝶、蛾类的有益幼虫（如蚕、传粉昆虫）。\n\n---\n\n### ✅ 如何确保买到真正的BTI产品？\n\n1. ​**​认准关键标识​**​：\n    - 包装上必须明确标注 ​**​“苏云金杆菌以色列亚种”​**​、​**​“BTI”​**​ 或 ​**​“_Bacillus thuringiensis_ subsp. _israelensis_”​**​。\n    - 英文商品名常含 ​**​“Mosquito Dunks”​**​、​**​“Mosquito Bits”​**​、​**​“Gnatrol”​**​（园艺用）。\n2. ​**​查看防治对象​**​：  \n    产品说明应写明用于防治 ​**​“蚊子幼虫”、“蠓”、“蚋”、“摇蚊”​**​ 或 ​**​“双翅目水生幼虫”​**​。\n3. ​**​警惕模糊标注​**​：  \n    只写“苏云金杆菌”但未注明亚种，或标注防治对象为“青虫”、“毛虫”、“甲虫”的，一定是其他亚种（Btk/Btt），​**​对飞虫无效！​**​\n\n---\n\n### 🌱 BTI的安全性优势（重申）\n\n- ​**​高度特异​**​：只杀双翅目幼虫，对鱼虾、蛙类、鸟类、哺乳动物（包括人、宠物）、蜜蜂、瓢虫等​**​非目标生物无害​**​。\n- ​**​环境友好​**​：天然微生物制剂，无化学残留。\n- ​**​不易产生抗性​**​：多毒素协同作用，降低抗药性风险。\n# 某产品\n![](../../images/杀虫知识_蛾蠓/image-20250803015125921.png)\n\n![](../../images/杀虫知识_蛾蠓/image-20250803015144555.png)\n\n**这款苏云金杆菌（以色列亚种）可湿性粉剂完全适用于杀灭厕所飞虫（蛾蠓/蚊子）的幼虫！​**​ 以下是关键确认点：\n\n---\n\n### ✅ ​**​明确有效的证据​**​\n\n1. ​**​核心成分标注清晰​**​：\n    \n    - 包装明确标注 ​**​“苏云金杆菌(以色列亚种)”​**​（即BTI），这是专杀双翅目幼虫（蚊、蠓、蚋）的菌种，与您需求完全匹配。\n2. ​**​防治对象正确​**​：\n    \n    - 说明中明确写 ​**​“对蚊幼虫有较好的防治效果”​**​，并针对 ​**​“蚊孳生地中的孑孓（幼虫）”​**​。厕所地漏、下水道正是典型的孳生地。\n3. ​**​作用机理精准​**​：\n    \n    - 毒素蛋白可破坏蚊/蠓幼虫的肠道细胞（与科学原理一致），对蛾蠓同样有效（二者同属双翅目）。\n\n---\n\n### 📝 ​**​使用注意事项（针对厕所场景）​**​\n\n1. ​**​用法调整​**​：\n    \n    - ​**​产品建议​**​：室外喷洒（1-2克/㎡水面）。\n    - ​**​厕所用法​**​：取 ​**​5克（约1勺）+ 500ml水​**​，混合后灌入地漏/洗手池下水道，​**​无需喷洒​**​。\n    - ​**​频率​**​：首次连用3天，后续每周1次（预防）。\n2. ​**​安全重点​**​：\n    \n    - ⚠️ ​**​避开鱼类/蜜蜂​**​：虽厕所无此风险，但勿倒入鱼缸或阳台花盆积水。\n    - 🧤 ​**​操作防护​**​：戴手套，避免药粉接触皮肤（粉剂较悬浮剂更易飞散）。\n    - 💧 ​**​清洁​**​：操作后洗手，工具冲洗干净。\n3. ​**​效果预期​**​：\n    \n    - 幼虫接触药液后 ​**​24-48小时死亡​**​，成虫需配合菊酯喷雾（如雷达）清除。\n\n---\n\n### 🔄 ​**​与其他产品的对比​**​\n\n|​**​产品类型​**​|本次BTI可湿性粉剂|此前问题悬浮剂|\n|---|---|---|\n|​**​亚种​**​|✅ 明确以色列亚种（专杀蚊蠓）|❌ 未标注或错误亚种|\n|​**​适用性​**​|✅ 溶解后灌地漏，完美匹配厕所环境|❌ 需喷洒（不适用下水道）|\n|​**​生产信息​**​|✅ 正规企业（武汉康欣）|❌ 标签矛盾/过期|\n|​**​推荐度​**​|👍 ​**​强烈推荐​**​|🚫 ​**​禁止使用​**​|\n\n---\n\n### 📌 ​**​操作指南（针对厕所）​**​\n\n1. ​**​调配​**​：5克药粉 + 500ml水 → 摇匀静置10分钟。\n2. ​**​灌入​**​：\n    - 地漏：掀盖直接倒入混合液。\n    - 洗手池：移开起泡胶，倒入管道深处。\n3. ​**​强化​**​：连续3天操作，切断繁殖链。\n4. ​**​防护​**​：操作时戴口罩手套，通风30分钟。\n\n---\n\n### 💎 总结\n\n​**​这款产品是根除厕所飞虫幼虫的理想选择！​**​  \n请按上述方法使用，坚持1-2周（配合成虫扑杀），即可显著解决飞虫反复问题。  \n​**​提示​**​：开袋后密封存放，避免受潮失效！\n# 拜尔的特姆得\n拜尔的特姆得：吡虫琳含量：21%，高效氟氯氰菊酯含量：10%。用这个除蛾蠓怎么样？\n\n根据配方成分分析，拜耳「特姆得」（吡虫啉21% + 高效氟氯氰菊酯10%）​**​可高效灭杀蛾蠓成虫​**​，但无法根除幼虫源头，且存在​**​较高安全风险​**​，需谨慎使用。以下是具体分析和操作建议：\n\n---\n\n### ✅ ​**​优势（针对成虫）​**​\n\n1. ​**​双重速效灭杀​**​：\n    \n    - ​**​高效氟氯氰菊酯​**​（10%高浓度）：\n        - 强力神经毒剂，接触后​**​迅速击倒蛾蠓成虫​**​。\n        - 持效期长，喷洒表面后形成药膜，持续杀死新停落的成虫。\n    - ​**​吡虫啉​**​（21%）：\n        - 干扰昆虫神经系统，与菊酯协同增强杀虫效果。\n        - 对蛾蠓成虫有效（但对幼虫效果弱）。\n2. ​**​对蛾蠓成虫高效​**​：\n    \n    - 复配成分对飞行类害虫（蛾蠓、蚊子、苍蝇）​**​击倒率＞95%​**​。\n\n---\n\n### ⚠️ ​**​局限与风险​**​\n\n|​**​问题​**​|​**​原因与后果​**​|\n|---|---|\n|​**​无法灭幼虫/卵​**​|吡虫啉对双翅目幼虫效果差，菊酯不杀卵。​**​源头未断，治标不治本​**​。|\n|​**​浓度过高​**​|家用菊酯喷雾浓度通常仅​**​0.03%-0.1%​**​，本品高达10%！​**​过度接触易引发头痛、皮肤刺激​**​。|\n|​**​毒性风险​**​|对鱼、蜂剧毒，对哺乳动物中等毒性。厕所邻近生活区，​**​误触残留药膜可能危害健康​**​。|\n|​**​剂型不适​**​|设计为户外或农用喷雾，​**​厕所潮湿环境易导致药剂水解失效​**​。|\n\n---\n\n### 📌 ​**​使用建议（如必须使用）​**​\n\n#### 1. ​**​严格防护措施​**​\n\n- ​**​穿戴​**​：N95口罩 + 护目镜 + 橡胶手套 + 长袖衣物（避免皮肤接触）。\n- ​**​通风​**​：喷洒后关闭门窗2小时，再通风30分钟以上才可进入。\n\n#### 2. ​**​精准操作（降低风险）​**​\n\n- ​**​不喷雾！​**​ 改为​**​针对性点喷​**​：\n    - 用针筒抽取药剂，​**​混合清水稀释10倍​**​（即1份药+9份水）。\n    - 仅喷在​**​非接触面​**​：墙面顶部、天花板角落、排风口边缘（避开地漏、洗手台等潮湿区）。\n- ​**​严禁喷洒范围​**​：  \n    ❌ 地漏、洗手池、毛巾架、马桶座圈等可能接触皮肤的区域。\n\n#### 3. ​**​必须配合源头治理​**​\n\n|​**​步骤​**​|​**​操作​**​|\n|---|---|\n|杀幼虫源头|坚持使用​**​BTI颗粒/片剂​**​投入地漏（每周1次）|\n|环境清洁|刷洗地漏内壁黏液 + 保持干燥|\n|物理防成虫|换装​**​密封防虫地漏盖​**​ + 粘虫板辅助|\n\n---\n\n### 💎 ​**​替代方案（更推荐）​**​\n\n1. ​**​安全灭成虫​**​：\n    \n    - ​**​家用菊酯喷雾​**​（如雷达、枪手）：含​**​0.03%-0.1%氯菊酯​**​，安全高效，直接喷雾击杀。\n    - ​**​电蚊拍​**​：物理灭虫零风险。\n2. ​**​根治幼虫​**​：\n    \n    - ​**​BTI以色列亚种​**​（如您已有的「幼清」粉剂）：定期灌入下水道。\n\n---\n\n### 📊 效果与风险对比表\n\n|​**​方案​**​|灭成虫效果|灭幼虫效果|安全性|适用性|\n|---|---|---|---|---|\n|特姆得（稀释点喷）|⭐⭐⭐⭐⭐|❌|⚠️⚠️⚠️|应急短期使用|\n|家用菊酯喷雾（如雷达）|⭐⭐⭐⭐|❌|⭐⭐|日常首选|\n|BTI灌地漏|❌|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|必须长期执行|\n\n---\n\n### 🔚 总结\n\n- ​**​短期应急​**​：可稀释后点喷天花板角落，​**​务必做好防护+通风​**​。\n- ​**​长期根治​**​：\n    1. ​**​成虫​**​ → 家用低毒喷雾/电蚊拍\n    2. ​**​幼虫​**​ → BTI灌地漏\n    3. ​**​环境​**​ → 清洁地漏 + 密封潮湿区\n- ​**​安全警示​**​：本品农用高毒配方，​**​勿用于地面、洗手台等接触面​**​，家有孕妇/宠物则禁用！\n# 老管家杀虫水乳剂有用吗？\n![](../../images/杀虫知识_蛾蠓/image-20250803015310881.png)\n\n\n根据产品信息分析，这款「老管家杀虫水乳剂」​**​倒入下水道对灭杀蛾蠓成虫有一定即时效果，但无法根治幼虫源头，且存在操作风险和副作用​**​。以下是关键结论和使用建议：\n\n---\n\n### ✅ ​**​正面作用（短期治标）​**​\n\n1. ​**​菊酯成分即时灭杀​**​：\n    \n    - ​**​氯菊酯（0.3%）+ 高效氯氰菊酯（0.06%）​**​ 能快速击倒下水道口附近活动的​**​成虫​**​（接触药液后瘫痪死亡）。\n    - 对刚羽化爬出的新成虫有“守株待兔”效果。\n2. ​**​剂型部分适配​**​：\n    \n    - 水乳剂（EW）比普通喷雾更易附着管壁，短暂滞留。\n\n---\n\n### ⚠️ ​**​严重缺陷与风险（无法治本）​**​\n\n|​**​问题​**​|​**​原因分析​**​|\n|---|---|\n|​**​不杀幼虫/卵​**​|菊酯无法穿透虫卵和蛹壳，对藏在下水道深处的幼虫几乎无效。|\n|​**​药效短暂​**​|下水道水流会冲走药剂，残留时间仅几小时，无法持久防护。|\n|​**​污染风险​**​|直接倒药剂会​**​污染水体​**​（对鱼类剧毒），违反环保法规（包装标注“低毒”指接触毒性，非环境毒性）。|\n|​**​腐蚀管道​**​|长期使用乳剂中的溶剂可能腐蚀PVC管道接口或金属部件。|\n|​**​诱导抗药性​**​|反复低剂量暴露会让飞虫产生菊酯抗性，后续更难防治。|\n\n---\n\n### 📉 ​**​效果对比表​**​\n\n|​**​处理方式​**​|灭成虫（即时）|灭幼虫（根源）|持效期|环境影响|\n|---|---|---|---|---|\n|直接倒入下水道|⭐⭐|❌|＜1天|🚫 高污染|\n|BTI颗粒投地漏|❌|✅⭐⭐⭐⭐|1-2周|✅ 安全|\n|滞留喷洒墙面|✅⭐⭐⭐|❌|2周|⚠️ 低风险|\n\n---\n\n### 📌 ​**​科学操作建议​**​\n\n1. ​**​替代方案（推荐组合拳）​**​：\n    \n    - ​**​幼虫源头灭绝​**​：  \n        ✅ 用 ​**​BTI以色列亚种颗粒剂​**​（如「灭孑灵」）投入地漏，每2周1次，杀幼虫断根。\n    - ​**​成虫快速击杀​**​：  \n        ✅ 在墙面 ​**​30cm以下​**​ 喷本品（按说明稀释）作​**​滞留层​**​，成虫停落时触杀。\n2. ​**​若坚持倒入下水道（应急）​**​：\n    \n    - ​**​限频次​**​：每月≤1次，每次≤20ml（避免积累污染）。\n    - ​**​防护​**​：操作时戴手套口罩，通风2小时。\n    - ​**​冲水​**​：倒入后立即用大量清水冲刷，减少药剂残留。\n3. ​**​增效技巧​**​：\n    \n    - 先倒入 ​**​热水+小苏打​**​ 清洁管壁生物膜，再投BTI颗粒（清洁后幼虫更易接触药剂）。\n\n---\n\n### 🌱 ​**​环保提醒​**​\n\n瓶身虽标“低毒”，但​**​“直接倒入下水道”违背农药使用规范​**​（登记证WP​**​​**​为滞留喷洒用途）。  \n❌ ​**​切勿盲目跟随包装图示操作​**​，该设计仅为营销误导消费者！\n\n---\n\n### 💎 终极建议\n\n​**​停用倒入法！​**​  \n👉 按「滞留喷洒」说明使用本品灭成虫（喷墙角）+ ​**​坚持用BTI灭幼虫​**​（如您已有的「幼清」粉剂），同时 ​**​每周开水烫地漏+物理密封缝隙​**​，才是根除飞虫的唯一路径。","categories":["生活"]},{"title":"网络_Boost.Asio库","url":"/网络/网络_Boost.Asio库/","content":"# `Boost::Asio`库\n`Boost::Asio`是一个用于网络和异步编程的`C++`库，它提供了一套**跨平台的网络编程接口**，能够方便地创建客户端和服务器应用程序。`Boost::Asio`支持同步和异步操作，可以处理多种类型的网络协议，包括TCP、UDP、SSL等。\n## 安装\n```sh\nsudo apt-get install libboost-all-dev\n```\n## cmake配置\n在Linux系统上，除了链接boost库以外，还需要链接pthread库。\n```cmake\ncmake_minimum_required(VERSION 3.10.0)\nproject(boost-asio-demo VERSION 0.1.0 LANGUAGES C CXX)\n\nset(CMAKE_CXX_STANDARD 11)\n\nfind_package(Boost REQUIRED COMPONENTS system)\n\ninclude_directories(${Boost_INCLUDE_DIRS})\n\nadd_executable(server server.cpp)\ntarget_link_libraries(server ${Boost_LIBRARIES} pthread)\n\nadd_executable(client client.cpp)\ntarget_link_libraries(client ${Boost_LIBRARIES} pthread)\n\n```\n# demo\n## 服务器\n```cpp\n#include <iostream>\n#include <boost/asio.hpp>\nint main(int argc, char *argv[])\n{\n    boost::asio::io_service service;\n    boost::asio::ip::tcp::acceptor acceptor(service, \n        boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), 8888));\n    std::cout << \"Server started, listening on port 8888\" << std::endl;\n\n    while (1)\n    {\n        boost::asio::ip::tcp::socket socket(service);\n        acceptor.accept(socket);\n        std::cout <<\"Connection\" << std::endl;\n\n        std::string msg = \"Hello From Boost.Asio Server\\n\";\n        boost::system::error_code err;\n        boost::asio::write(socket, boost::asio::buffer(msg), err);\n    }\n}\n```\n## 客户端\n```cpp\n#include <iostream>\n#include <boost/asio.hpp>\nint main(int argc, char *argv[])\n{\n    boost::asio::io_service service;\n    boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::address::from_string(\"127.0.0.1\"), 8888);\n    boost::asio::ip::tcp::socket socket(service);\n    socket.connect(endpoint);\n    \n    boost::asio::streambuf buf;\n    boost::asio::read_until(socket, buf, \"\\n\");\n    \n    std::istream in(&buf);\n    std::string msg;\n    std::getline(in, msg);\n    std::cout << \"Received msg from server: \" << msg << std::endl;\n}\n```\n## 测试\n```\nmrcan@ubuntu:~/boost-asio-demo/build$ ./server \nServer started, listening on port 8888\nConnection\n```\n\n```\nmrcan@ubuntu:~/boost-asio-demo/build$ ./client \nReceived msg from server: Hello From Boost.Asio Server\n```","categories":["Cpp","网络"]},{"title":"网络_HTTP协议","url":"/网络/网络_HTTP协议/","content":"# http协议格式规范\nHTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。\n\nHTTP协议规定了在传输数据时需要遵守的一些约定和规范，以确保数据的正确传输和解释。\n以下是HTTP协议必须包含的几个要素：\n1. 请求行：请求行包含了客户端发起的请求方法、请求的资源地址和HTTP协议的版本号。例如：\n\n```\nGET /index.htm1 HTTP/1.1\n```\n\n这里的请求方法是GET，请求的资源地址是`/index.html`，HTTP协议的版本号是1.1。\n\n2. 请求头部：请求头部包含了客户端发送请求的相关信息，例如客户端的User-Agent、Accept-Language等信息。请求头部以一个空行（CRLF）作为结束标志。例如：\n\n```\nHost: www.example.com\nUser-Agent: Mozi11a/5.0 (Windows NT 10.0; win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\nAccept: text/htm1,app1ication/xhtm1+xm1,app1ication/xm1;q=0.9,image/webp,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nConnection: keep-alive\n```\n\n3. 请求正文（可选）：请求正文是客户端发送请求时携带的数据，例如POST请求中的表单数据。请求正文通常以Content-Type头部指定数据类型，以及Content-Length头部指定数据长度。请求正文与请求头部之间也以一个空行（CRLF）作为分隔符。\n4. 响应行：响应行包含了服务器的响应状态码、状态码对应的原因短语和HTTP协议的版本号。例如：\n\n```\nHTTP/1.1 200 OK\n```\n\n这里的响应状态码是200，状态码对应的原因短语是OK，HTTP协议的版本号是1.1。\n\n5. 响应头部：响应头部包含了服务器发送响应的相关信息，例如服务器的Server、Content-Type、Content-Length等信息。响应头部以一个空行（CRLF）作为结束标志。例如：\n\n```\nServer: Apache/2.4.41 (Ubuntu)\nContent-Type: text/html; charset=UTF-8\nContent-Length: 1234\n<htm1>\n  <body>He11o HTTP</body>\n</html>\n```\n\n6. 响应正文（可选）：响应正文是服务器返回给客户端的数据，例如HTML页面、图片、JSON数据等。响应正文通常以 Content-Type 头部指定数据类型，以及 Content-Length 头部指定数据长度。响应正文与响应头部之间也以一个空行（CRLF）作为分隔符。\n\n总之，HTTP协议要求每个请求和响应都包含一些必要的元素，包括请求行、请求头部、请求正文、响应行、响应头部和响应正文。这些元素包含了客户端和服务器之间传输数据所必需的信息，以确保数据的正确传输和解释。\n# HttpServer\n以下代码，Server可以做到：\n绑定端口，监听连接。\n接受连接，接收请求数据。\n解析请求数据。\n```cpp\n// http_server.cpp\n#include <iostream>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sstream>\nclass HttpServer\n{\npublic:\n    HttpServer(unsigned short port) : m_port(port)\n    {\n\n    }\n    void start()\n    {\n        int error = 0;\n        int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n        if (server_fd < 0)\n        {\n            std::cerr << \"Failed to create socket\" << std::endl;\n            return;\n        }\n        struct sockaddr_in server_addr;\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(m_port);\n        error = inet_pton(AF_INET, \"127.0.0.1\", &(server_addr.sin_addr.s_addr));\n        if (error == -1)\n        {\n            std::cerr << \"Failed to inet_pton\" << std::endl;\n            return;\n        }\n        error = bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n        if (error == -1)\n        {\n            std::cerr << \"Failed to bind\" << std::endl;\n            return;\n        }\n        error = listen(server_fd, 5);\n        if (error == -1)\n        {\n            std::cerr << \"Failed to listen\" << std::endl;\n            return;\n        }\n        std::cout << \"Server started on port: \" << m_port << std::endl;\n        struct sockaddr_in client_addr;\n        while (1)\n        {\n            socklen_t client_addr_len = sizeof(client_addr);\n            int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n            if (client_fd < 0)\n            {\n                std::cerr << \"Failed to accept\" << std::endl;\n                return;\n            }\n            std::cout << \"Accepted connection from \" << inet_ntoa(client_addr.sin_addr) << std::endl;\n            char request[1024] = {0};\n            int len = read(client_fd, request, sizeof(request));\n            if (len < 0)\n            {\n                std::cerr << \"Failed to read\" << std::endl;\n                close(client_fd);\n                return;\n            }\n            std::cout << \"=========================\" << std::endl;\n            printf(\"%s\", request);\n            std::cout << \"=========================\" << std::endl;\n            std::stringstream request_stream(request);\n            std::string method, path, http_version;\n            request_stream >> method >> path >> http_version;\n            std::cout << \"http method:\" << method << std::endl;\n            std::cout << \"http path:\" << path << std::endl;\n            std::cout << \"http version:\" << http_version << std::endl;\n            close(client_fd);\n        }\n        close(server_fd);\n    }\nprivate:\n    unsigned short m_port;\n};\nint main(int argc, char *argv[])\n{\n    if (argc < 2)\n    {\n        std::cerr << \"Usage: HttpServer <port>\\n\";\n        return 1;\n    }\n    HttpServer http_server(std::atoi(argv[1]));\n    http_server.start();\n    return 0;\n}\n```\n运行：\n```sh\n./HttpServer 9999\n```\n当浏览器访问`http://127.0.0.1:9999/index.thml`时，控制台输出：\n```\nAccepted connection from 127.0.0.1\n=========================\nGET /index.html HTTP/1.1\nHost: 127.0.0.1:9999\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br, zstd\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nSec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: none\nSec-Fetch-User: ?1\nPriority: u=0, i\n\n=========================\nhttp method:GET\nhttp path:/index.html\nhttp version:HTTP/1.1\n\n```\n## 响应\n```cpp\n#include <iostream>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <sstream>\n#include <fstream>\nclass HttpServer\n{\npublic:\n    HttpServer(unsigned short port) : m_port(port)\n    {\n\n    }\n    void start()\n    {\n        int error = 0;\n        \n        // ...\n        \n        struct sockaddr_in client_addr;\n        while (1)\n        {\n            socklen_t client_addr_len = sizeof(client_addr);\n            int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n            if (client_fd < 0)\n            {\n                std::cerr << \"Failed to accept\" << std::endl;\n                return;\n            }\n            std::cout << \"Accepted connection from \" << inet_ntoa(client_addr.sin_addr) << std::endl;\n            char request[1024] = {0};\n            int len = read(client_fd, request, sizeof(request));\n            if (len < 0)\n            {\n                std::cerr << \"Failed to read\" << std::endl;\n                close(client_fd);\n                return;\n            }\n            std::cout << \"=========================\" << std::endl;\n            printf(\"%s\", request);\n            std::cout << \"=========================\" << std::endl;\n            std::stringstream request_stream(request);\n            std::string method, path, http_version;\n            request_stream >> method >> path >> http_version;\n            std::cout << \"http method:\" << method << std::endl;\n            std::cout << \"http path:\" << path << std::endl;\n            std::cout << \"http version:\" << http_version << std::endl;\n\n            if (method != \"GET\")\n            {\n                bad_request(client_fd);\n            }\n            else\n            {\n                std::string filename = \".\" + path;\n                if (filename.find(\"..\") != std::string::npos)\n                {\n                    forbidden(client_fd);\n                }\n                else\n                {\n                    std::string content = get_file_content(filename);\n                    if (content.empty())\n                    {\n                        not_found(client_fd);\n                    }\n                    else\n                    {\n                        ok(client_fd, content);\n                    }\n                }\n            }\n            close(client_fd);\n        }\n        close(server_fd);\n    }\nprivate:\n    std::string get_file_content(const std::string& filename)\n    {\n        std::fstream fs(filename);\n        std::stringstream buffer;\n        buffer << fs.rdbuf();   // fs.rebuf()的内容输出给buffer\n        return buffer.str();\n    }\n    void bad_request(int client_fd)\n    {\n        std::string response = \"HTTP/1.1 400 Bad Request\\r\\n\";\n        send(client_fd, response.c_str(), response.length(), 0);\n    }\n    void not_found(int client_fd)\n    {\n        std::string response = \"HTTP/1.1 404 Not Found\\r\\n\";\n        send(client_fd, response.c_str(), response.length(), 0);\n    }\n    void forbidden(int client_fd)\n    {\n        std::string response = \"HTTP/1.1 403 Forbidden\\r\\n\";\n        send(client_fd, response.c_str(), response.length(), 0);\n    }\n    void ok(int client_fd, std::string content)\n    {\n        std::ostringstream response_steam;\n        response_steam  << \"HTTP/1.1 200 OK\\r\\n\"\n                        << \"Content-Type: text/html\\r\\n\"\n                        << \"Content-Length: \" << content.length() << \"\\r\\n\"\n                        << \"\\r\\n\"\n                        << content;\n        std::string response(response_steam.str());\n        send(client_fd, response.c_str(), response.length(), 0);\n    }\nprivate:\n    unsigned short m_port;\n};\nint main(int argc, char *argv[])\n{\n    if (argc < 2)\n    {\n        std::cerr << \"Usage: HttpServer <port>\\n\";\n        return 1;\n    }\n    HttpServer http_server(std::atoi(argv[1]));\n    http_server.start();\n    return 0;\n}\n```\n我们在主程序的当前目录下创建一个`index.html`\n```html\nThis is xcg test HTML\n```\n运行：\n```sh\n./HttpServer 9999\n```\n结果：\n```\nmrcan@ubuntu:~/http_demo/build$ ./HttpServer 9999\nServer started on port: 9999\nAccepted connection from 127.0.0.1\n=========================\nGET /index.html HTTP/1.1\nHost: 127.0.0.1:9999\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br, zstd\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nSec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: none\nSec-Fetch-User: ?1\nPriority: u=0, i\n\n=========================\nhttp method:GET\nhttp path:/index.html\nhttp version:HTTP/1.1\nAccepted connection from 127.0.0.1\n=========================\nGET /favicon.ico HTTP/1.1\nHost: 127.0.0.1:9999\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0\nAccept: image/avif,image/webp,image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br, zstd\nConnection: keep-alive\nReferer: http://127.0.0.1:9999/index.html\nSec-Fetch-Dest: image\nSec-Fetch-Mode: no-cors\nSec-Fetch-Site: same-origin\nPriority: u=6\n\n=========================\nhttp method:GET\nhttp path:/favicon.ico\nhttp version:HTTP/1.1\n\n```\n客户端浏览器显示：\n![](../../images/网络_HTTP协议/image-20250726160319160.png)\n\n","categories":["网络","HTTP"]},{"title":"网络_UDP","url":"/网络/网络_UDP/","content":"# UDP组播的概念\n单播是指将数据包从1个发送方到1个特定的接收方。\n组播是指将数据包从1个发送方到1组特定的接收方。这个组是预先定义的，这些接收方共享同一个组播地址。\n\n在IPv4中，组播地址是有范围和规定的，不能随便写。IPv4的组播地址范围是`224.0.0.0`到`239.255.255.255`。\n其中，`224.0.0.0`到`224.0.0.255`是预留的，用于本地链接的多播地址（Link-Local Multicast Addresses），而其他范围的地址才可以用于全局组播。\n在选择组播地址时，应该遵循规范，避免使用预留的地址或者其他可能会引起冲突的地址。\n通常建议从`239.0.0.0`开始向上选择，确保不会与其他组播组冲突。\n\n# setsockopt()\n`setsockopt()`函数是系统调用，用于设置套接字选项，它允许程序员为打开的套接字设置不同的选项和参数\n```c\nint setsockpt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\n```\n\n参数：\n1. `sockfd`：指定要设置选项的套接字文件描述符。\n2. `level`：指定选项所在的协议层。常用的有`SOL_SOCKET`表示套接字级别的选项，`IPPROTO_IP`表示IP层的选项，`IPPROTO_TCP`表示TCP层的选项，`IPPROTO_IPV6`表示IPV6层的选项等。\n3. `optname`：指定要设置的选项名。\n    1. `IP_ADD_MEMBERSHIP`：加入组播组\n    2. `IP_DROP_MEMBERSHIP`：退出组播组\n4. `optval`：指向包含选项值的缓冲区的指针。\n5. `optlen`：指定选项值的长度。\n\n# 发送端\n```cpp\n// multicast_send.cpp\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <iostream>\n#include <unistd.h>\nconst int PORT = 8888;\nconst char *MULTICAST_ADDR = \"239.0.0.1\";\nconst int MAX_MSG_LEN = 1024;\n\nvoid sender()\n{\n    int sock;\n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(PORT);\n    inet_pton(AF_INET, MULTICAST_ADDR, &(addr.sin_addr.s_addr));\n\n    std::string msg = \"Hello, multicast\";\n\n    sendto(sock, msg.c_str(), msg.length(), 0, (struct sockaddr*)&addr, sizeof(addr));\n\n    std::cout << \"Message sent: \" << msg << std::endl;\n\n}\nint main()\n{\n    sender();\n}\n```\n# 接收端\n1. 与单播不同，sockaddr需要写入IP地址为`0.0.0.0`、端口号为与服务端约定好的组播端口（本例为8888）\n2. 需要绑定创建的sock 和 上面填写好的sockaddr\n3. 还需要写入一个`ip_mreq`结构。\n    1. 指明`imr_multiaddr`，写入与服务端约定好的组播地址（本例为`239.0.0.1`）\n    2. 指明`imr_interface`，写入`0.0.0.0`（本地地址）\n4. setsockopt 设置 sock 加入组播组。\n    1. 在调用`setsockopt`函数时，参数`&mreq, sizeof(mreq)`的作用是传递一个`ip_mreq`结构体及其大小给内核，以便内核根据这个结构体中的信息将套接字加入到指定的组播组。\n5. 用的是recv接收，而不是单播时的recvfrom。（其实recvfrom也行，但是接收方必须绑定sock和组播端口）\n\n## `imr_multiaddr`和`imr_interface`有什么区别\n```c\nstruct ip_mreq\n{\n    struct in_addr imr_multiaddr;  /* 组播组IP地址 */\n    struct in_addr imr_interface;  /* 本地接口IP地址 */\n};\n```\n在组播编程中，`struct ip_mreq` 结构体用于管理组播组成员关系，其中两个关键字段的区别如下：\n\n|特性|`imr_multiaddr`|`imr_interface`|\n|---|---|---|\n|​**​作用​**​|指定要加入/离开的​**​组播组​**​|指定用于组播通信的​**​网络接口​**​|\n|​**​地址类型​**​|D类IP地址（224.0.0.0-239.255.255.255）|本机真实IP地址或`INADDR_ANY`|\n|​**​示例值​**​|239.0.0.1|192.168.1.100 或 `INADDR_ANY`|\n|​**​必要性​**​|必须正确设置|可选（不设置时系统自动选择）|\n|​**​用途​**​|标识通信的目标组|选择收发组播数据的物理/虚拟网卡|\n### `imr_multiaddr`（组播组地址）\n- ​**​定义​**​：表示要加入或离开的组播组\n- ​**​组播地址范围​**​：224.0.0.0 到 239.255.255.255（D类IP）\n- ​**​永久组播地址​**​：224.0.0.1（所有主机）、224.0.0.2（所有路由器）\n- ​**​临时组播地址​**​：239.x.x.x（管理员定义范围）\n### `imr_interface`（本地接口地址）\n- **定义​**​：指定用于组播通信的网络接口\n- ​**​特点​**​：\n    - 可以是本机具体IP（192.168.1.100）\n    - 也可以是特殊值：\n        - `INADDR_ANY` (0.0.0.0)：让​**​系统自动选择​**​默认路由接口\n        - `INADDR_LOOPBACK` (127.0.0.1)：限定为本地环回\n\n```c\n// 自动选择最优网卡（推荐）\nmreq.imr_interface.s_addr = htonl(INADDR_ANY);\n\n// 指定具体接口（有多个网卡时）\ninet_pton(AF_INET, \"192.168.1.100\", &mreq.imr_interface);\n```\n\n不能指定`127.0.0.1`换回接口。当接收外部组播时，即使发送方是在本机上，但指定环回地址会导致接收方不能接收本地的组播数据。\n### 正确示例\n```c\nstruct ip_mreq mreq;\n\n// 1. 设置组播组（固定D类地址）\ninet_pton(AF_INET, \"239.0.0.100\", &mreq.imr_multiaddr);\n\n// 2 以下考虑到了多网卡的场景，三选一：\n// 2.1 监听所有可用网卡上的组播流量（让系统选择最优接口）\nmreq.imr_interface.s_addr = INADDR_ANY;\n// 或者指定特定网卡，需要写本地具体ip地址\n// 2.2 有线网卡\nconst char* iface_ip = \"192.168.1.100\"; \ninet_pton(AF_INET, iface_ip, &mreq.imr_interface);\n// 2.3 无线网卡\nconst char* wifi_ip = \"10.0.0.5\"; \ninet_pton(AF_INET, wifi_ip, &mreq.imr_interface);\n\n// 3. 加入组播组\nsetsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));\n```\n\n## 为什么接收端要绑定？\n在组播接收端，`bind`操作是​**​必须​**​的，因为：\n1. 组播数据包是通过UDP传输的，而UDP是无连接的。\n2. 操作系统需要知道将哪些端口上的数据传递给应用程序。\n\n如果你不调用`bind`，那么你的套接字就没有与本地端口关联，操作系统就不会将收到的数据包递送到该套接字。因此，你无法收到任何组播数据。\n\n`recvfrom`函数是用来接收数据并获取发送者的地址，但是它并不能替代`bind`。实际上，`recvfrom`通常是在已经绑定的套接字上使用的。\n\n因此，正确的步骤是：\n1. 创建套接字。\n2. 绑定到指定的端口（通常还会指定地址为`INADDR_ANY`，即`0.0.0.0`）。\n3. 加入组播组（通过`setsockopt`设置IP_ADD_MEMBERSHIP）。\n4. 使用`recvfrom`（或者`recv`）接收数据。\n\n所以，即使你想使用`recvfrom`来获取发送者的信息，你仍然需要先绑定端口。\n\n如果你尝试不绑定，那么你将会看到`recvfrom`调用会失败，并返回一个错误（例如“Transport endpoint is not connected”或者“Invalid argument”）。\n\n因此，结论是：不能省略`bind`步骤，即使你打算使用`recvfrom`。\n### `bind()`的核心作用 - ​声明端口所有权​\n- 作用：告知内核：\"我负责处理本机所有网卡上指定端口的UDP流量\"\n\n底层原理：\n```c\n// 内核网络栈伪代码\nvoid udp_input(struct sk_buff *skb) {\n    // 查找绑定对应端口的套接字\n    sock = udp_v4_lookup(skb->dport); \n    if (sock) deliver_to_socket(sock, skb);\n    else discard_packet(); // ⚠️ 未绑定则丢弃包\n}\n```\n### `setsockopt()`的作用 - ​订阅组播频道​\n- 作用：告诉网络驱动：\"我对 特定组播地址 的流量感兴趣\"\n- 触发内核进行：\n    - IGMP加入报文发送（通知路由器）\n    - 设置网卡组播过滤器\n## 代码\n```cpp\n// multicast_recv.cpp\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <iostream>\n#include <unistd.h>\nconst int PORT = 8888;\nconst char *MULTICAST_ADDR = \"239.0.0.1\";\nconst int MAX_MSG_LEN = 1024;\nvoid receiver()\n{\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(PORT);\n    inet_pton(AF_INET, \"0.0.0.0\", &(addr.sin_addr.s_addr));\n    // 绑定sock 和 addr\n    bind(sock, (struct sockaddr*)&addr, sizeof(addr));\n\n    // 本地的IP接口加入到组播地址中\n    // IPv4 multicast request.\n    struct ip_mreq mreq;\n    // 指定组播地址\n    inet_pton(AF_INET, MULTICAST_ADDR, &(mreq.imr_multiaddr.s_addr));\n    inet_pton(AF_INET, \"0.0.0.0\", &(mreq.imr_interface.s_addr));\n\n    setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));\n\n    char buffer[MAX_MSG_LEN + 1] = {0};\n    int len = recv(sock, buffer, MAX_MSG_LEN, 0);\n\n    buffer[len] = '\\0';\n\n    std::cout << \"Received message: \" << buffer << std::endl;\n    close(sock);\n}\nint main()\n{\n    receiver();\n}\n```\n# 问题\n## 为什么发送端发给的是8888，接收端也要从本地的8888接收？\n1. ​**​组播地址是逻辑分组​**​（如239.0.0.1）\n    - 只负责标识组播组，不包含端口信息\n    - 相当于\"广播频道\"，但无法单独区分不同应用\n2. ​**​端口号标识具体服务​**​\n    - 接收端通过绑定特定端口（8888）声明：\"我是这个组播组中负责8888端口的应用\"\n    - 发送端必须将数据发送到该组播地址+指定端口的组合\n\n想象一个无线电系统：\n- 组播地址 = 频道（如FM 239.0）\n- 端口号 = 子频道（如\"新闻子频道8888\"）\n- 发送端必须在指定频道(FM 239.0)用指定子频道(8888)发射信号\n- 接收端必须调到相同频道(FM 239.0)+相同子频道(8888)才能接收\n\n## 端口重用问题\n- 同一台机器上的不同程序不能同时绑定相同端口\n- 如需多进程接收，需要设置`SO_REUSEPORT`选项\n## 防火墙配置​​\n- 接收端必须开放对应的UDP端口（示例中是8888）\n- Linux检查：`sudo ufw allow 8888/udp`","categories":["网络"]},{"title":"Linux_cut命令","url":"/Linux/Linux_cut命令/","content":"cut是`/usr/bin/`下的程序。\n\n```sh\ncut  -d.  -f1  -s  IPs.txt\n```\n以上命令说的是：\n1. `-d`：以`.`为分割。\n2. `-f1`：切割下来第1列。\n3. `-s`：以哪个文件的内容切割。\n\n\n```sh\nmrcan@ubuntu:~$ echo 192.168.0.1 > IP.txt\nmrcan@ubuntu:~$ cut -d. -f1 -s IP.txt \n192\nmrcan@ubuntu:~$ cut -d. -f2 -s IP.txt \n168\nmrcan@ubuntu:~$ cut -d. -f3 -s IP.txt \n0\nmrcan@ubuntu:~$ cut -d. -f4 -s IP.txt\n1\nmrcan@ubuntu:~$ cut -d. -f5 -s IP.txt\n（空）\n```\n","categories":["Linux"]},{"title":"Linux_正则表达式","url":"/Linux/Linux_正则表达式_grep_awk/","content":"# 正则表达式\nRegular Expression\n\n主要参考文档：\nhttps://legacy.cplusplus.com/reference/regex/ECMAScript/\n\n[[Linux_Shell编程#结合正则表达式的示例]]：case的示例中\n\n```sh\n[][][]代表三个字符。\n[]代表一个字符。\n[]里可以填正则表达式。\n1.[a-z]表示一个小写的a到z均可\n2.[abcde]表示一个字符的可取范围\n```\n# Quantifiers（`*`、`+`、`?`、`{n}`）\n量词\n\n代表通用的信息的部分。\n1. `*`：可能有（0到无数个）前导字符。`*`只是指示符，本身不参与，指示前面的字符会重复0到无数次。\n2. `+`：最少1个前导字符。\n3. `?`：只有1个前导字符。\n4. `{n}`：有n个前导字符。\n    1. `{n,}`：有大于等于n个的前导字符。\n    2. `{min,max}`：至少有min个，但不超过max个（左闭右开）\n# Special Pattern Characters（`[]`）\n特殊模式字符\n\n1. `.`：匹配任意单个字符\n2. `[...]`：匹配`[]`中包含的任意字符。\n    1. 比如`[1234567890]`或`[0-9]`都表示：字符0到9\n    2. `[A-Z]`表示大写字母\n    3. `[A-Za-z]`表示大小写字母。\n    4. 分类字符，见《[Character classes](#Character%20classes)（字符类）》一节\n3. `\\s`：表示空格字符，空格、制表符都可以。（可替代`[[:space:]]`）\n\n更多特殊字符见手册。\nhttps://legacy.cplusplus.com/reference/regex/ECMAScript/\n\n`.*`表示所有字符。\n## Character classes\n字符类\n1. `[:alpha:]`：表示所有字母\n    1. `grep '[[:alpha:]]' file.txt`\n2. `[:digit:]`：表示数字\n3. `[:alnum:]`：表示字母+数字\n4. `^[:alpha:]`：表示除了字母以外\n    1. `grep '[^[:alpha:]]' file.txt`\n# Assertions（`^`、`$`）\n断言\n\n1. `^`：出现在行首的指定字符串。\n    1. 注意，在`[]`内外，`^`表达的意思是不一样的。\n        1. 在`[]`内，表示“非”\n        2. 在`[]`外，才表示“首”\n        3. 对于分类字符（比如`[:alpha:]`），需要放到两层`[]`之内，分类字符的`[]`之外，即：`[^[:alpha:]]`。\n2. `$`：出现在行尾的指定字符串。\n\n# Alternatives（或关系：`|`）\n![](../../images/Linux_正则表达式/image-20250717211217323.png)\n\n\n![](../../images/Linux_正则表达式/image-20250717025024296.png)\n找出带A或带B的行。\n相当于求了两次grep，结果合在一起。\n\n注意`|`需要转义。\n# Groups\n组\n![](../../images/Linux_正则表达式/image-20250717211508114.png)\n## 核心概念：分组的作用\n\n1. ​**​将量词应用于字符序列：​**​ 这是最基本的作用。想象你要匹配多次出现的单词“hello”而不是单个字母“l”多次。你需要把“hello”当成一个整体来量化。\n    - _错误示例：_ `hel{2,}o`：这个匹配的是 'he' + ​**​至少2个'l'​**​ + 'o'， 可以匹配 \"hello\", \"hellllo\"，但不能匹配 \"hellohello\" (两个hello连在一起)。\n    - _正确示例：_ `(hello){2,}`：这个匹配的是 ​**​\"(hello)\"这个整体​**​ 至少出现2次，可以匹配 \"hellohello\", \"hellohellohello\" 等。\n2. ​**​创建子匹配项（反向引用）：​**​ 这是普通分组 `(subpattern)` 独特且强大的功能。它不仅仅是匹配，还会​**​记住​**​分组内匹配到的​**​具体内容​**​，并分配一个​**​编号​**​（按照左括号 `(` 出现的顺序）。这些被记住的内容称为“子匹配项”或“捕获组”。\n## 普通分组（分组且捕获）：`(subpattern)`\n- 将 `subpattern` 作为一个整体单元进行操作（特别是应用量词）。\n- 捕获 `subpattern` 匹配到的实际文本内容。\n- （重要）创建反向引用（在​**​同一个正则表达式内部​**​，用 `\\1`, `\\2`, `\\3`... 来指代第1、2、3...个分组捕获的内容）。\n- 在​**​正则匹配结果​**​中，可以通过索引（如 C++ 的 `smatch[1]`, `smatch[2]`）获取每个子匹配项的值。\n- 在​**​替换操作​**​中，可以通过类似 `$1`, `$2`, `$3`... 的语法来引用这些子匹配项。\n### 示例1：匹配重复的单词或连续字母\n```\n正则: (\\w+)\\s+\\1\n解释:\n  (\\w+) : 第1个分组，匹配一个或多个字母数字下划线（就是一个单词），并把匹配到的词记住。\n  \\s+   : 匹配一个或多个空白字符（空格、制表符等）。\n  \\1    : 反向引用，匹配的内容必须与第1个分组捕获的内容 完全相同。\n\n目标字符串: \"hello world hello again\"\n匹配结果: 匹配到 \"hello hello\"（第一个 \"hello\" 被捕获为分组1，\\1 要求再次出现 \"hello\"）\n         \"world\"和\"again\" 不会被匹配，因为 \"world\" != \"again\"\n```\n### 示例2：提取日期各部分（年、月、日）\n```\n正则: (\\d{4})-(\\d{2})-(\\d{2})\n解释:\n  (\\d{4}) : 第1个分组，匹配4位数字（年），捕获。\n  -       : 匹配横杠 \"-\"\n  (\\d{2}) : 第2个分组，匹配2位数字（月），捕获。\n  -       : 匹配横杠 \"-\"\n  (\\d{2}) : 第3个分组，匹配2位数字（日），捕获。\n\n目标字符串: \"Today is 2023-10-27.\"\n匹配结果:\n    整个匹配: \"2023-10-27\"\n    子匹配项:\n     smatch[0] 或 $0: \"2023-10-27\" (整个匹配项)\n     smatch[1] 或 $1: \"2023\"        (第1分组捕获的年)\n     smatch[2] 或 $2: \"10\"          (第2分组捕获的月)\n     smatch[3] 或 $3: \"27\"          (第3分组捕获的日)\n编程中访问: match[1], match[2], match[3] (C++的smatch索引通常从1开始表示分组)\n```\n## 被动/非捕获分组：`(?:subpattern)`\n### 作用\n- 将 `subpattern` 作为一个整体单元进行操作（应用量词）。\n- ​**​不会​**​捕获匹配到的文本内容。\n- ​**​不会​**​创建子匹配项。\n- ​**​不分配​**​分组编号（因此不会影响其他普通分组的编号）。\n- ​**​无法​**​在正则表达式内部用 `\\n` 反向引用。\n- ​**​无法​**​在匹配结果或替换操作中单独访问。\n\n为什么需要它？​\n- ​**​性能：​**​ 如果不关心分组内容，避免捕获可以提高效率（尤其是在大量重复匹配时）。\n- ​**​简化编号：​**​ 当你只想分组应用量词，但又不想这个分组计入编号体系、干扰你真正关心的捕获组（普通分组）时。它让后续普通分组的编号更清晰。\n- ​**​避免不必要的内存开销：​**​ 不用存储不关心的匹配文本。\n\n### 示例：匹配文件扩展名（但只关心扩展名本身）\n```\n目标：从 \"report.txt\", \"data.csv.zip\", \"image.png\" 中提取扩展名 (txt, zip, png)\n正则：\\.(?:[a-z]{3,4})$   (不理想，只为演示非捕获)\n理想正则：\\.([a-z]{3,4})$  (一个捕获组就够)\n\n但假设有个更复杂的模式：\n正则：^(?:https?:\\/\\/)?(?:www\\.)?example\\.com\\/(\\w+)\\.html$\n解释:\n  ^            : 字符串开始\n  (?:https?:\\/\\/)? : 非捕获分组，匹配可选的 \"http://\" 或 \"https://\" (?匹配0次或1次)\n  (?:www\\.)?     : 非捕获分组，匹配可选的 \"www.\"\n  example\\.com  : 匹配固定域名\n  \\/            : 匹配斜杠 \"/\"\n  (\\w+)         : **普通捕获分组1!** 匹配并捕获一个或多个字母数字下划线（文件名）\n  \\.html        : 匹配 \".html\"\n  $            : 字符串结束\n\n目标字符串: \"https://www.example.com/news.html\"\n匹配结果:\n    整个匹配: \"https://www.example.com/news.html\"\n    子匹配项:\n        [1]: \"news\" (唯一捕获的分组)\n    所有 `(?:...)` 分组匹配的内容 (http, www) 都不会被捕获或分配编号。我们关心的只是文件名 \"news\"。\n    \n如果没有非捕获分组：\n    正则： ^(https?:\\/\\/)?(www\\.)?example\\.com\\/(\\w+)\\.html$\n    子匹配项:\n        [1]: \"https://\"   (可能不需要)\n        [2]: \"www.\"       (可能不需要)\n        [3]: \"news\"       (我们想要的)\n    此时要访问文件名就需要 [3] 而不是 [1]，非捕获分组让关心的部分编号更清晰。\n```\n### 示例2：应用量词但不捕获（纯粹为了结构）\n```\n匹配连续出现的 \"hello\" 或 \"world\" 两次\n正则: (?:hello|world){2}\n解释:\n    (?:hello|world) : 非捕获分组，匹配整体 \"hello\" 或 \"world\"。\n    {2}             : 要求前面这个非捕获分组整体出现2次。\n\n可以匹配: \"hellohello\", \"helloworld\", \"worldhello\", \"worldworld\"\n匹配结果中找不到哪个分组匹配了 \"hello\" 还是 \"world\"，因为它没有被捕获。\n使用普通分组也可以 `(hello|world){2}` 但会额外捕获了每次的内容（可能用不到）。\n```\n## 总结\n![](../../images/Linux_正则表达式/image-20250717212452387.png)\n# grep\nGet Regular Expression Print\n## `*`\n```sh\necho \"AAAA\" > aa.txt\necho \"BB\"  >> aa.txt\n```\n\n```sh\ngrep B* aa.txt\n```\n结果：\n```\nAAAA\nBB\n```\n如上结果，因为`B*`代表前面的B可能会出现`0`到`n`次。所以，AAAA也匹配上了。\n\n```sh\ngrep BB* aa.txt\n```\n结果：\n```\nBB\n```\n如上结果，这次没出现AAAA，因为我们限制了`BB*`，即第一个字符必须是B后面可能出现0到n个B。可以用`B+`替代上述语义：[`+`](#`+`)。\n\n因此`*`还是要慎用，能代表的范围太大了。\n## `+`\n类似于`*`，区别是1到n次。排除了0次的可能。\n```sh\ngrep 'B\\+' aa.txt\n```\n\n**需要转义，并在单引号中使用**。\n\n结果：\n```\nBB\n```\n### 示例1\n```sh\necho \"123.456\" >> aa.txt\necho \"222.333\" >> aa.txt\necho \"845.143\" >> aa.txt\necho \"a2a.7a3\" >> aa.txt\necho \"a23.833\" >> aa.txt\necho \"a23.83q\" >> aa.txt\n```\n怎么提取出`.`前后全是数字的**行**？\n```sh\ngrep '[0-9]\\+\\.[0-9]\\+' aa.txt\n```\n以上命令表示：\n1. `\\.`是转义，意思是中间有个`.`\n2. `.`前面有最少1个`0到9`的字符\n3. `.`后面有最少1个`0到9`的字符\n\n\n结果：\n![](../../images/Linux_正则表达式/image-20250717022242078.png)\n### 示例2 - 精确指示n个字符\n需要用到`{}`，注意在单引号中，`{`和`}`均需转义。\n\n指示有4个`A到Z`字符。\n```sh\ngrep '[A-Z]\\{4\\}' aa.txt\n```\n结果：AAAA\n\n指示有大于等于2个的`A到Z`字符。在右括号前加`,`\n```sh\ngrep '[A-Z]\\{3,\\}' aa.txt\n```\n结果：\n```\nAAAA\nBB\n```\n### 结合分类字符（如`[:alpha:]`）\n注意外面还需要加一层`[]`\n\n想找到文件中带数字的行：\n```sh\ngrep '[[:digit:]]' aa.txt\n```\n![](../../images/Linux_正则表达式/image-20250717024050328.png)\n想找到文件中带字母的行：\n![](../../images/Linux_正则表达式/image-20250717024105776.png)\n想找到文件中带字母或有0到3字符的行：\n![](../../images/Linux_正则表达式/image-20250717024550755.png)\n想找到文件中**有非字母字符**的行：\n![](../../images/Linux_正则表达式/image-20250717024146037.png)\n想找到文件中**有非字母、非数字字符**的行：\n![](../../images/Linux_正则表达式/image-20250717024255587.png)\n## `?`\n只出现了1次前面的字符。\n## `$`\n以什么字符结尾。\n```sh\ngrep '[C-Z]\\+$' aa.txt\n```\n表示：结尾最少有1个C到Z的字符。\n\n如果`aa.txt`的内容是：\n```\nAAAA\nBB\n123.456\nCABCC\nABCC\nCDEFGHIJKL\nCCCCC\n```\n则执行`grep '[C-Z]\\+$' aa.txt`的结果：\n![](../../images/Linux_正则表达式/image-20250717171927467.png)\n## 既以...为开头，又以它为结尾？\n```sh\ngrep '^[C-Z]\\+$' aa.txt\n```\n我原先想的是，这个命令表示既以至少1个`C到Z的字符`开头，又以至少1个`C到Z的字符`结尾。（错误解释！）\n让Deepseek分析后，不是这样解释的。而是：\n\n正则表达式 `^[C-Z]\\+$` 要求：\n- 整行​**​必须完全由​**​ C-Z 的大写字母组成（字母必须 ≥ C）\n- ​**​A和B字母不被允许​**​\n- ​**​无任何数字/符号/小写字母**\n\n因此，如果`aa.txt`的内容是：\n```\nAAAA\nBB\n123.456\nCABCC\nABCC\nCDEFGHIJKL\nCCCCC\n```\n则执行`grep '^[C-Z]\\+$' aa.txt`的结果：\n![](../../images/Linux_正则表达式/image-20250717171833045.png)\n### 表达式拆解与执行逻辑\n\n1. ​**​`^` 锚点​**​（行首）\n    \n    - 强制匹配​**​必须从行首开始​**​\n2. ​**​`[C-Z]` + `\\+` 组合​**​\n    \n    - `[C-Z]` 只匹配 ​**​单个​**​ C-Z 范围内的大写字母\n    - `\\+` 表示前面的 `[C-Z]` ​**​至少出现一次​**​（可以出现多次）\n    - ​**​关键效果​**​：每一个位置都需匹配 `[C-Z]`  \n        （不能是空格/数字/小写字母/其他字符）\n3. ​**​`$` 锚点​**​（行尾）\n    \n    - 强制匹配​**​必须延伸到行尾结束​**\n\n### 强制约束的逻辑链\n\n当正则引擎执行 `^[C-Z]\\+$` 时，它的匹配规则如下：\n\n1. 从行首 (`^`) 开始检查第一个字符  \n    → 必须是 `C-Z` 的大写字母\n2. 继续检查后续字符  \n    → 因为 `\\+` 要求连续多个匹配，所以​**​第二个字符必须也是​**​ `C-Z` 的大写字母  \n    → 第三个、第四个...所有字符都必须满足\n3. 直到遇见行尾 (`$`)  \n    → 此时整行已被完全匹配\n\n> ✨ ​**​核心机制​**​：`[C-Z]\\+` 作为连续的整体充当了 ​**​“填充内容”​**​ 的角色，它从行首一直延伸到行尾，不允许中间插入任何非 C-Z 字符。\n\n\n这种严格约束主要用于验证​**​格式纯净的字符串​**​，典型场景包括：\n\n- 检测不含空格的英文单词（如 `\"PYTHON\"`）\n- 过滤无数字/符号的纯大写文本（如验证商品代码 `\"SKUXYZ\"`）\n- 也可以有等效的、更简洁的形式：`grep -x '[C-Z]\\+' aa.txt` （`-x` 表示整行匹配）\n# awk\n**A**lfred Aho, Peter **W**einberger, Brian **K**ernighan\n![](../../images/Linux_正则表达式/image-20250717213735273.png)\n![](../../images/Linux_正则表达式/image-20250717213911332.png)\n\n\ngrep是扫描每一整行的，按行为单位。而awk是按一行中的每个字段为单位查询的，类似于excel表格，可以切分各个字段。即可以按列操作。\n## 结合正则表达式\n>在 awk命令中，`/tty/`中的 `​​/`（正斜杠）​​ 是​​正则表达式（Regular Expression）的定界符​​。它表示中间的内容（tty）是一个需要匹配的模式。\n\n```sh\nawk '/tty/{print $0}' ps.txt\n```\n![](../../images/Linux_正则表达式/image-20250717214111511.png)\n假如`ps.txt`文件内容如上，我们想找到字段有`tty`的字段。\n则，在awk命令后面先用`单引号' '`包裹，再在里面写`斜杠/ /`包裹正则表达式。后半部分再用`大括号{ }`包裹要进行的打印操作。\n![](../../images/Linux_正则表达式/image-20250717214628141.png)\n## print可以自定义内容\n![](../../images/Linux_正则表达式/image-20250717214811959.png)\n\n![](../../images/Linux_正则表达式/image-20250717214847197.png)\n### 可以用printf进行格式化输出\nps内容：\n![](../../images/Linux_正则表达式/image-20250717215028874.png)\n![](../../images/Linux_正则表达式/image-20250717215043574.png)\n\n## 单独指定匹配每一行的第n列，其他列跳过\nemployees文件内容：\n![](../../images/Linux_正则表达式/image-20250717215231997.png)\n形式：\n```sh\nawk '$2~/^[A-z][a-z]+/ {print $1}' employees\n```\n即，在`' '`内的前面加一个第几列`$2`和波浪号`~`。\n\n![](../../images/Linux_正则表达式/image-20250717215328968.png)\n第一句awk的意思是搜索**每一行**的**所有列**，查找以大写字母开头，后面至少有一个小写字母。匹配到后，打印该行的第1列。\n第二句awk的意思是只搜索**每一行**的**第2列**，查找以大写字母开头，后面至少有一个小写字母。匹配到后，打印该行的第1列。\n第二句awk的意思是只搜索**每一行**的**第3列**，查找以大写字母开头，后面至少有一个小写字母。匹配到后，打印该行的第1列。由于第三列全是数字，没有匹配到符合条件的行，所以打印空。\n\n## 可以在`{}`中对文件信息进行修改\n![](../../images/Linux_正则表达式/image-20250717220024588.png)\n以上语句的意思：找每一行的第1列中含Billy的，之后，把该行第1列修改为`Gilly`。之后，打印匹配到的所有行。\n## 在单引号中，内置了数字大小比较器\nps内容：\n![](../../images/Linux_正则表达式/image-20250717220401897.png)\n我们想要输出所有PID大于776的：\n可以在awk后的`' '`单引号内写`$1>776`，它内置了把字符串转换为数字之后比较的操作，之后帮我们筛选出符合条件的。\n![](../../images/Linux_正则表达式/image-20250717220429523.png)\n\n甚至还可以在里面写一些简单的运算：（`'$1>776+1'`）\n![](../../images/Linux_正则表达式/image-20250717220555388.png)\n# sed\nStream Editor\n\n用于处理流。把字符串、文件按流的方式处理。流的特点是只能单向，不能后撤。\n","categories":["Linux"]},{"title":"Linux_expr命令","url":"/Linux/Linux_expr命令/","content":"# 先看`var=$var2+$var3`\n```sh\nmrcan@ubuntu:~$ var=1+2\nmrcan@ubuntu:~$ echo $var\n1+2\nmrcan@ubuntu:~$ var2=2\nmrcan@ubuntu:~$ var3=3\nmrcan@ubuntu:~$ var=$var2+$var3\nmrcan@ubuntu:~$ echo $var\n2+3\n```\n我们发现，`var=$var2+$var3`未能让2+3的结果5赋给var，而是以字符串的形式给了var。\n# expr\n用于计算数值类。\n\nwhich发现`expr`是存在`/usr/bin/expr`下的，说明是个常用的命令。\n```sh\nmrcan@ubuntu:~$ expr 1+2\n1+2\n```\n我们发现，以字符串的形式输出了expr的结果。明显不是我们想要的。\n因为要计算数值的话，在运算符前后要加空格分隔开！\n```sh\nmrcan@ubuntu:~$ expr 1 + 2\n3\n```\n\n```sh\nmrcan@ubuntu:~$ expr $var2 + $var3\n5\n```\n# 把expr的结果赋给环境变量\n```sh\nmrcan@ubuntu:~$ var=expr $var2 + $var3\n2: command not found\n```\n\n```sh\nmrcan@ubuntu:~$ var=(expr $var2 + $var3)\nmrcan@ubuntu:~$ echo $var\nexpr\n```\n以上两种都是错误的。\n\n要用“命令代换”。\n\n看：《Linux_重定向#命令代换》![命令代换](Linux_重定向.md#命令代换)\n正确的方式：****\n```sh\nmrcan@ubuntu:~$ var=$(expr $var2 + $var3)\nmrcan@ubuntu:~$ echo $var\n5\n```\n\n\n# 使用expr编写从1加到100的脚本\n```sh\n#! /bin/sh\n\nI=1\nSUM=0\nwhile (test $I -le 100) # 可以简写为 while [ $I -le 100 ]\ndo\n    SUM=$(expr $SUM + $I)\n    I=$(expr $I + 1)\ndone\necho \"sum of 1 ... 50 is \"$SUM\n```\n\n```sh\nmrcan@ubuntu:~$ ./testif.sh \nsum of 1 ... 50 is 505\n```\n# 乘号需要转义\n```sh\nmrcan@ubuntu:~$ expr 56 * 9\nexpr: syntax error: unexpected argument ‘a.c’\nmrcan@ubuntu:~$ echo $?\n2\n```\n在expr命令中，乘号不能直接写，而是要`\\*`转义。\n```sh\nmrcan@ubuntu:~$ expr 56 \\* 9\n504\n```\n\n除号不用转义。\n```sh\nmrcan@ubuntu:~$ expr 56 / 9\n6\n```","categories":["Linux"]},{"title":"Linux_test命令","url":"/Linux/Linux_test命令/","content":"`-e`指定文件是否存在（目录也是文件）\n\n`-d`指定文件是否存在并且是目录\n\n`-f`指定文件是否存在并且是普通文件\n\n`-r`指定文件是否用户可读\n\n`-w`指定文件是否用户可写\n\n`-x`指定文件是否用户可执行\n\n`-O`用户是否是该文件的拥有者\n# 不会直接输出结果\n结果不会直接输出到屏幕上，可以用`$?`查看该命令的执行结果。\n```sh\ntest -e xxx\necho $?\n\n```\n如果输出 0，代表真，表示存在。\n测试，如果文件不存在，会输出 1，表示不存在。（`$?`的结果为非 0 时代表假）\n\n>关于`$?`见《Linux_Shell编程》的《特殊变量》一节。\n\n经测试，管道重定向到echo也没有输出结果。\n```sh\ntest -e xxx | echo\n（无输出）\n```\n# 一般和Shell编程的if判断结合\n```sh\n#!/bin/sh\nif (test -e $1)\nthen\n    echo \"$1 exists!\"\nelse\n    echo \"$1 not exists!\"\nfi\n```\n\n```sh\nchmod u+x c.sh\n./sh xxx\n```\n![](../../images/Linux_test命令/image-20250716014144080.png)\n\n# test结合if - 相当于`[]`\nif后跟的`[ ... ]`相当于：`(test ...)`\n\n见《Linux_Shell编程#if语句》![[Linux_Shell编程#if语句]]\n# test结合比较运算符\n\n```sh\nmrcan@ubuntu:~$ test 2 -gt 3\nmrcan@ubuntu:~$ echo $? # $? 表示上一个命令的返回结果\n1 # 1 表示 假\nmrcan@ubuntu:~$ test 20 -gt 3\nmrcan@ubuntu:~$ echo $?\n0 # 0 表示 真\n```\n\ntest在和`-gt`（或`-lt`、`-le`等等）结合使用的时候，`-gt`前后不是看作字符串的，是内部把20进行了类似于`expr`的操作转换成了数字再进行比较。\n\n","categories":["Linux"]},{"title":"Linux_wc命令(word count)","url":"/Linux/Linux_wc命令(word count)/","content":"```sh\nwc file.txt\n```\n\n```sh\nmrcan@ubuntu:~$ wc testif.sh\n  9  27 131 testif.sh\n 行  词 字符\n```\n\n默认显示行、词、字符数。\n\n可以单独指定：\n```sh\nmrcan@ubuntu:~$ wc -w testif.sh \n27 testif.sh\nmrcan@ubuntu:~$ wc -l testif.sh \n9 testif.sh\nmrcan@ubuntu:~$ wc -c testif.sh \n131 testif.sh\n```\n# word `-w`\n只要中间没有空格、换行符，就是1个word。\n# line `-l`\n# character `-c`\n1个英文字母算1个字符\n# byte","categories":["Linux"]},{"title":"Linux_重定向","url":"/Linux/Linux_重定向/","content":"# 有哪些\n有标准输入、标准输出重定向。\n有命令代换。\n有管道。\n# 标准输出重定向\n```c\n#include <stdio.h>\nint main()\n{\n    printf(\"C Program!\\n\");\n    return 0;\n}\n```\n编译为`a.out`。\n`>`为完全覆盖写。\n```sh\n./a.out > aa.txt\n```\n目前`aa.txt`内容为\n```\nC Program!\n```\n`>>`为追加写。\n```sh\n./a.out >> aa.txt\n```\n目前`aa.txt`内容为\n```\nC Program!\nC Program!\n```\n## 应用🌟\n>我们想在命令行把程序执行后的输出结果输出到文件中时，可以这样：`./cmpxz DCE 20250709 >log.txt 2>&1`\n# 标准输入重定向\n```c\n#include <stdio.h>\nint main()\n{\n    char str[50];\n    scanf(\"%s\", str);\n    printf(\"%s\\n\", str);\n    return 0;\n}\n```\n编译为`b.out`\n```sh\n./b.out < \"hello\"\n```\n提示：\n![](../../images/Linux_重定向/image-20250716002226113.png)\n所以标准输入重定向不能是简单的字符串，而是要重定向到一个文件。\n先用`echo`把一些内容输入到一个文件中：\n```sh\necho \"hello\" > aa.txt\n./b.out < aa.txt\n```\n执行结果：\n```\nhello\n```\n# 管道\n我们上面讲的标准输入、标准输出重定向都是文件和程序之间的交互。\n而管道是进程之间的交互。\n\n用上面的`a.out`和`b.out`示例一下管道：\n```sh\n./a.out | ./b.out\n```\n执行结果：\n```\nC\n```\n（没有显示全`C Program!`，是因为中间有空格，scanf只输入了空格前的C字符。）\n# 命令代换\nCommand Substitution\n\n形如：\n```sh\nvar2=$(./a.out)\nvar3=$(./1st.sh)\n```\n即，可以把**程序、shell脚本运行的结果写入到环境变量**中。\n\n便于脚本编写中涉及到的命令中转，可以先保存到环境变量中。使用命令代换，避免了在代码中编写读写文件的繁琐。\n![](../../images/Linux_重定向/image-20250716004406561.png)\n\n![](../../images/Linux_重定向/image-20250716004422370.png)\n\n","categories":["Linux"]},{"title":"Linux_启动过程","url":"/Linux/Linux_启动过程/","content":"输入以下命令，可以看到全部进程。\n```bash\nps -aux | less\n```\n下面是FreeBSD的 Unix 系统的测试结果：\n\n![](../../images/Linux_启动过程/image-20250715233203947.png)\n\n0 号进程为`[kernel]`。（测试的Ubuntu Linux 系统没有显示 0 号进程）\n\n1号进程为`/sbin/init`。用于初始化。\n\n`[ctypto]`用于加密。\n\n有一个特殊的`[idle]`进程，用于空闲时的调度。某个进程时间片结束，则把权力上交`[idle]`。由`[idle]`决定下一次调用谁。\n\n![](../../images/Linux_启动过程/image-20250715234246004.png)\n\n\nUnix 系统有多个 getty，是终端程序。一旦有哪个人登录，其中一个 getty 就负责调用 login（登陆器），用于登录相关。\n如果用户名、密码匹配，最终就会打开Shell。\n\n![](../../images/Linux_启动过程/image-20250715232614864.png)\n\n\n\n","categories":["操作系统","Linux"]},{"title":"Linux_安装软件","url":"/Linux/Linux_安装软件/","content":"# 解压\n大部分源代码包都以`.tar.gz`形式存储。\n用`tar -xzvf make-4.2.tar.gz (后面可以加参数，指定解压到哪个目录)`解压。\n\n# 源码目录\n```sh\ncd make-4.2\nls\n```\n# configure\n每一个项目源码目录下，基本都有configure文件。这是一个可执行文件，内容是Shell脚本。\n里面会指示要按照这个软件需要系统有什么必要的环境、前置软件。\n```sh\n./configure\n```\n\n![](../../images/Linux_安装软件/image-20250716175803575.png)\n\n如上，configure会给你检查系统环境。\n如果检查无误，则会给你生成`build.sh`以及项目管理文件Makefile。\n# make install\n```sh\nmake install\n```\n会帮你调用系统可用的编译器，进行编译、安装。\n一般默认安装位置是`/usr/local/bin`下\n\n如果只是make，则只编译。\n如果要安装，需要`make install`。相当于把可执行文件移动到系统可执行目录（`/.../bin`）下。\n可以用`make uninstall`卸载。","categories":["Linux"]},{"title":"Linux_编辑器","url":"/Linux/Linux_编辑器/","content":"\n# 有哪些\nvi、vim、Emacs、ee（Unix自带的）\n\nEmacs是最难用的，但是如果掌握了，能获益不少？\n# ee编辑器\n```shell\nee 1st.sh\n```\n进入编辑器后的样子：\n\n上半部分：按Ctrl加相应的符号可以调用一些功能。\n\n![](../../images/Linux_编辑器/image-20250715235658871.png)\n\n## 按Ctrl加`[`或按ESC进入菜单\n![](../../images/Linux_编辑器/image-20250716000216760.png)\n\n在按`a`离开编辑器时，如果没保存文件会提示你保存：\n![](../../images/Linux_编辑器/image-20250716000318642.png)\n\n# Emacs编辑器\n打开文件。\n\n```sh\nemacs 3th.sh\n```\n\n按一下ESC，再按一下x（映射Emacs的M-x命令）。在底行输入linum，表示：Line Num，设置显示行号。\n![](../../images/Linux_编辑器/image-20250716182031711.png)\n\n\n## 退出、保存\nCtrl加x、Ctrl加c是退出。\n之后，底行会问你，是否保存，按y即可保存。\n![](../../images/Linux_编辑器/image-20250716185429960.png)\n\n# 修改映射\n默认配置下，Emacs没有退格键（Backspace）、删除键（Delete）的映射，在我们编辑文件时不方便删字符。我们在用户家目录下的`.emacs`中追加配置以下内容：\n```\n(global-set-key) \"\\C-h\" 'backward-delete-char-untabify)\n(global-set-key) \"\\d\" 'delete-char)\n```\n","categories":["Linux"]},{"title":"Cpp11多线程编程_复习","url":"/多线程/Cpp11多线程编程_复习/","content":"# 进程和线程\n进程是运行中的程序。线程是进程中的进程。\n# C++11 Thread库\n## 创建线程\n创建线程需要一个可调用的函数或函数对象，作为线程的入口点。在C++11中，可以使用函数指针、函数对象或lambda表达式来实现。\n```cpp\n#include <iostream>\n#include <thread>\nvoid printHelloWorld()\n{\n    std::cout << \"Hello World\" << std::endl;\n}\nint main()\n{\n    // 1 create a thread\n    std::thread thread1(printHelloWorld);\n    return 0;\n}\n```\n上面这个程序运行后，可能会报错。\n![](../../images/Cpp11多线程编程_复习/image-20250714141601405.png)\n![](../../images/Cpp11多线程编程_复习/image-20250714141622256.png)\n因为主线程main开启线程后，继续执行自己的内容，不会等待子线程。\n但是一旦主线程结束，控制台窗口就会结束。因此子线程可能打印不全。这会导致运行结果不符预期。\n## join - 主线程等待子线程\n为了让子线程执行完毕，我们需要在主线程中加入`join()`。这样，如果子线程没有结束，则主线程也不会退出。\n```cpp\nint main()\n{\n    // 1 create a thread\n    std::thread thread1(printHelloWorld);\n    \n    thread1.join();\n    return 0;\n}\n```\n![](../../images/Cpp11多线程编程_复习/image-20250714142050094.png)\n### join是阻塞的：等待子线程执行完毕，主线程才会继续执行join后面的内容\n```cpp\n#include <iostream>\n#include <thread>\nvoid printHelloWorld(std::string msg)\n{\n    //std::cout << \"Hello World\" << std::endl;\n    std::cout << msg << std::endl;\n    std::cin >> msg;\n}\nint main()\n{\n    // 1 create a thread\n    std::thread thread1(printHelloWorld, \"Hello Thread\");\n    \n    thread1.join();\n    std::cout << \"Hello World\" << std::endl;\n    return 0;\n}\n```\n执行后发现，由于主线程的打印是在join后面的，当我们在键盘上输入字符串后回车，主线程才会继续打印。\n执行结果：\n```\nHello Thread    # 子线程打印\n123             # 我们自己输入的\nHello World     # 主线程打印\n```\n## 传参\n主线程可以给子线程传入参数。\n```cpp\n#include <iostream>\n#include <thread>\nvoid printHelloWorld(std::string msg)\n{\n    //std::cout << \"Hello World\" << std::endl;\n    std::cout << msg << std::endl;\n}\nint main()\n{\n    // 1 create a thread\n    std::thread thread1(printHelloWorld, \"Hello Thread\");\n    \n    thread1.join();\n    return 0;\n}\n```\n执行结果：\n```\nHello Thread\n```\n## detach\n分离线程。\n这会让子线程在后台运行，脱离主线程的管制。\n```cpp\n#include <iostream>\n#include <thread>\nvoid printHelloWorld(std::string msg)\n{\n    //std::cout << \"Hello World\" << std::endl;\n    std::cout << msg << std::endl;\n}\nint main()\n{\n    // 1 create a thread\n    std::thread thread1(printHelloWorld, \"Hello Thread\");\n\n    thread1.detach();\n    \n    return 0;\n}\n```\n此时执行结果为空：\n```\n（空）\n```\n这是因为子线程还没来得及打印，主线程就已经结束了，但是不会报错。\n## joinable()方法\n```cpp\nint main()\n{\n    // 1 create a thread\n    std::thread thread1(printHelloWorld, \"Hello Thread\");\n\n    bool canJoin = thread1.joinable();\n    if (canJoin)\n    {\n        thread1.join();\n    }\n    \n    return 0;\n```\n会返回一个bool值，为真时，这个线程才能join或者detach。\n如果线程不是joinable的话，去强行join，系统就会报错：`system_error`。\n严谨起见，在项目中应该先判断线程是否joinable。\n# 传参：传递引用类型\n我们知道，函数参数为引用时，不可以传入纯右值。\n```cpp\n#include <iostream>\n#include <thread>\nvoid foo(int& x)\n{\n    x += 1;\n}\nint main()\n{\n    int a = 1;  \n\n    foo(1);     // error\n}// 无法编译\n```\n能不能传入普通变量呢？间接操作源头数据。\n普通函数可以。\n```cpp\n#include <iostream>\n#include <thread>\nvoid foo(int& x)\n{\n    x += 1;\n}\nint main()\n{\n    int a = 1;  \n\n    foo(a);     // a = 2\n}// 可以编译通过、运行\n```\n## 线程函数为引用类型时\n但是当**线程函数**参数为引用时，我们不能传入普通变量类型。\n传入普通变量类型，编译不通过。\n```cpp\n#include <iostream>\n#include <thread>\nvoid foo(int& x)\n{\n    x += 1;\n}\nint main()\n{\n    int a = 1;\n    std::thread t(foo, a); // error\n    t.join();\n    return 0;\n}// 编译不通过\n```\n![](../../images/Cpp11多线程编程_复习/image-20250714144737398.png)\n## `std::ref`\n上面的编译不通过的问题是因为普通变量类型和线程函数参数的左值引用类型不匹配。可以使用`std::ref`包装传入。\n```cpp\n#include <iostream>\n#include <thread>\nvoid foo(int& x)\n{\n    x += 1;\n}\nint main()\n{\n    int a = 1;\n    std::thread t(foo, std::ref(a)); // a = 2\n    t.join();\n\n    return 0;\n}// 编译没问题，运行没问题。\n```\n上面这个程序：编译没问题，运行没问题。\n# 线程执行时的问题\n## 传递引用类型后的未定义行为\n虽然传入`std::ref`让程序编译成功，但是实际上线程函数执行时，可能源头a被析构，从而导致未定义行为。\n```cpp\n#include <iostream>\n#include <thread>\nstd::thread t;\nvoid foo(int& x)\n{\n    x += 1;\n}\nvoid test()\n{\n    int a = 1;       // error\n    t = std::thread(foo, std::ref(a)); // 开始执行线程\n    // test 函数 结束，a销毁。\n}\nint main()\n{\n    test();\n    t.join();\n    return 0;\n}\n```\n![](../../images/Cpp11多线程编程_复习/image-20250714151706860.png)\n上面这个程序，**编译可以通过，但执行时报空指针异常**。\n\n再来看一个程序：\n```cpp\n#include <iostream>\n#include <thread>\nstd::thread t;\nvoid foo(int* x)\n{\n    std::cout << *x << std::endl;\n}\nint main()\n{\n    int* ptr = new int{ 1 };\n    std::thread t(foo, ptr);\n    delete ptr;             // 在子线程操作结束前销毁ptr指向的变量\n    t.join();\n    return 0;\n}\n```\n上面这个程序，**编译可以通过，但输出结果是错误的**。\n输出：-572662307。\n这是明显的未定义行为。\n\n解决方案是将该变量的生命期延长到子线程结束，即先存到一个持久的对象中，再把该对象的引用传递给线程。\n我们把`int a = 1;`挪到全局定义即可。\n```cpp\n#include <iostream>\n#include <thread>\nstd::thread t;\nint a = 1;       // ok\nvoid foo(int& x)\n{\n    x += 1;\n}\nvoid test()\n{\n    t = std::thread(foo, std::ref(a));\n}\nint main()\n{\n    test();     // a = 2\n    t.join();\n    return 0;\n}\n```\n此时，编译成功，运行也正确。\n\n## 线程函数为成员函数时需要注意的\n```cpp\n#include <iostream>\n#include <thread>\n#include <memory>\nclass A\n{\nprivate:\n    friend int main();\n    void foo()\n    {\n        std::cout << value << std::endl;\n    }\n    int value = 1;\n};\nint main()\n{\n    A* a = new A();\n    std::thread t(&A::foo, a);\n    delete a;\n    t.join();\n}\n```\n此时编译通过，输出结果错误：-572662307。\n我们可以通过shared智能指针来解决。\n```cpp\n#include <iostream>\n#include <thread>\n#include <memory>\nclass A\n{\nprivate:\n    friend int main();\n    void foo()\n    {\n        std::cout << value << std::endl;\n    }\n    int value = 1;\n};\nint main()\n{\n    std::shared_ptr<A> a = std::make_shared<A>();\n    std::thread t(&A::foo, a);\n    a.reset();   // 模拟主线程在子线程执行前销毁A对象\n    t.join();\n}\n```\n此时编译通过，输出结果正确：1。\n# 互斥量 `std::mutex`\n对一个共享变量，每个线程都去对其加1，10000次。\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        a = a + 1;\n    }\n}\nint main()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n\n    t1.join();\n    t2.join();\n\n    std::cout << a << std::endl;\n}\n```\n运行结果：11083\n\n我们的预期是20000。\n运行结果不符是因为，两个线程可能同时读到了相同的数据，而后加1返回给a，相当于少加了1次。\n\n可以给互斥量加锁解决：\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::mutex mtx;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        mtx.lock();\n        a += 1;\n        mtx.unlock();\n    }\n}\nint main()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n\n    t1.join();\n    t2.join();\n\n    std::cout << a << std::endl;\n}\n```\n运行结果20000。\n## 线程安全的定义？\n如果多线程程序每一次的运行结果和单线程运行的结果始终是一样的，那么就是线程安全的。\n## 互斥量死锁\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::mutex mtx1;\nstd::mutex mtx2;\nvoid func1()\n{\n    for (int i = 0; i < 50; ++i)\n    {\n        mtx1.lock();\n        mtx2.lock();\n        mtx1.unlock();\n        mtx2.unlock();\n    }\n}\nvoid func2()\n{\n    for (int i = 0; i < 50; ++i)\n    {\n        mtx2.lock();\n        mtx1.lock();\n        mtx2.unlock();\n        mtx1.unlock();\n    }\n}\nint main()\n{\n    std::cout << \"begin\" << std::endl;\n\n    std::thread t1(func1);\n    std::thread t2(func2);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"over\" << std::endl;\n}\n```\n运行结果：\n```\nbegin\n...（死锁）\n```\n## `std::lock_guard`\n`std::lock_guard`是`C++`标准库中的一种互斥量封装类，特点如下：\n* 构造函数被调用时，互斥量会被自动锁定\n* 析构函数被调用时，互斥量会被自动解锁\n* lock_guard对象不能复制或移动。\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::mutex mtx;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        std::lock_guard<std::mutex> lg(mtx);\n        a = a + 1;\n    }\n}\nint main()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n\n    t1.join();\n    t2.join();\n\n    std::cout << a << std::endl;\n}//20000\n```\n### 源码实现\n很简单。就是在构造函数中加锁，在析构函数中解锁。\n![](../../images/Cpp11多线程编程_复习/image-20250714195038734.png)\n### explicit构造\n```cpp\nexplicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx)\n{\n    _MyMutex.lock();\n}\n```\n指示禁止隐式转换进行构造函数传参，必须指明mutex类型。\n### `adopt_lock`\n如果构造时除了传入`std::mutex`，还传入了`adopt_lock`，就只构造，而不对`mutex`进行`lock`。这可以用到在已经掌握了互斥量的情况下使用。\n但是析构是一定会对mutex进行解锁的。\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::mutex mtx;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        std::lock_guard<std::mutex> lg(mtx, std::adopt_lock);\n        mtx.lock();\n        a = a + 1;\n    }\n}\nint main()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n\n    t1.join();\n    t2.join();\n\n    std::cout << a << std::endl;\n}// 20000\n```\n\n## `std::unique_lock`\n`std::unique_lock`是`C++`标准库中的一种互斥量封装类。可以看作`std::lock_guard`的增强版，可以对互斥量进行更加灵活的管理。\n* 延迟加载\n* 条件变量\n* 超时\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::mutex mtx;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        std::unique_lock<std::mutex> ul(mtx);\n        a = a + 1;\n    }\n}\nint main()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n\n    t1.join();\n    t2.join();\n\n    std::cout << a << std::endl;\n}//20000\n```\n### 常见的成员函数\n* `lock()`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则阻塞，直到成功加锁。\n* `unlock()`：对互斥量解锁。\n* `try_lock()`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数**立即**返回false，否则返回true。\n* `try_lock_for(const std::chrono::duration<Rep, Period>&)`：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则阻塞，直到成功加锁，或者**超过了某一时间段**就返回。\n* `try_lock_until(const std::chrono::time_point<Clock, Duration>&)`：和`try_lock_for`的区别在于，**超过了设定的时间点**就返回。\n### 如何做到延迟加锁 - `defer_lock`\n当传入第二个参数：`defer_lock_t`这个常量时，`unique_lock`不加锁，需要手动加锁。但是析构时`unique_lock`还是会自动解锁的。\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::mutex mtx;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        std::unique_lock<std::mutex> ul(mtx, std::defer_lock);\n        ul.lock();\n        a = a + 1;\n    }\n}\nint main()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n\n    t1.join();\n    t2.join();\n\n    std::cout << a << std::endl;\n}//20000\n```\n`defer_lock`是延迟加锁的实现基础。\n### `std::timed_mutex`和`try_lock_for`搭配\n1. 由于涉及到时间，必须使用`std::timed_mutex`。\n2. 如果不传入`std::std::defer_lock`，程序会报错。\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::timed_mutex t_mtx;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        std::unique_lock<std::timed_mutex> ul(t_mtx, std::defer_lock);\n        ul.try_lock_for(std::chrono::seconds(5));\n        a = a + 1;\n    }\n}\nint main()\n{\n    std::thread t1(func);\n    std::thread t2(func);\n\n    t1.join();\n    t2.join();\n\n    std::cout << a << std::endl;\n}// 20000\n```\n# `call_once`\n见《设计模式》之《单例模式》篇的：线程安全的懒汉式 - `call_once`一章节。\n# 生产者消费者\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\n#include<queue>\n\nstd::queue<int> g_queue;\nstd::condition_variable g_cv;\nusing namespace std::chrono_literals;\n\nvoid Producer()\n{\n    int i = 0;\n    while (1)\n    {\n\n        while (g_queue.size() < 10)\n        {\n            std::this_thread::sleep_for(3ms);\n            g_queue.push(i);\n            std::cout << \"push \" << i++ << std::endl;\n        }\n    }\n}\nvoid Consumer()\n{\n    while (1)\n    {\n        while (!g_queue.empty())\n        {\n            std::this_thread::sleep_for(100ms);\n            int value = g_queue.front();\n            g_queue.pop();\n            std::cout << \"pop \" << value << std::endl;\n        }\n        std::this_thread::sleep_for(100ms);\n    }\n}\nint main()\n{\n    std::thread t1(Producer);\n    std::thread t2(Consumer);\n    std::thread t3(Consumer);\n    std::thread t4(Consumer);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}\n```\n输出结果\n```bash\npush 0\npush 1\npush 2\npush 3\npush 4\npush 5\npush 6\npush 7\npush 8\npush 9\npop 0\npop 2\npop 0\npush 10\npush 11\npush 12\npop 3\npop 3\npop 5\npush 13\npush 14\npush 15\npop 6\npop 6\npop 8\npush 16\npush 17\npush 18\npop 9\npop 11pop 9\n...\n```\n出错。数据竞态。\n## 用`unique_lock`配合sleep解决\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\n#include<queue>\n\nstd::queue<int> g_queue;\nstd::condition_variable g_cv;\nusing namespace std::chrono_literals;\nstd::mutex mtx;\nvoid Producer()\n{\n    int i = 0;\n    while (1)\n    {\n        std::unique_lock<std::mutex> ul(mtx);\n        while (g_queue.size() < 10)\n        {\n            std::this_thread::sleep_for(10ms);\n            g_queue.push(i);\n            std::cout << \"push \" << i++ << std::endl;\n        }\n    }\n}\nvoid Consumer()\n{\n    while (1)\n    {\n        std::unique_lock<std::mutex> ul(mtx);\n        while (!g_queue.empty())\n        {\n            std::this_thread::sleep_for(1ms);\n            int value = g_queue.front();\n            g_queue.pop();\n            std::cout << \"pop \" << value << std::endl;\n        }\n    }\n}\nint main()\n{\n    std::thread t1(Producer);\n    std::thread t2(Consumer);\n    std::thread t3(Consumer);\n    std::thread t4(Consumer);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}\n```\n输出结果，正确。\n```bash\npush 0\npush 1\npush 2\npush 3\npush 4\npush 5\npush 6\npush 7\npush 8\npush 9\npop 0\npop 1\npop 2\npop 3\npop 4\npop 5\npop 6\npop 7\npop 8\npop 9\n```\n## 用`unique_lock`配合cv解决\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\n#include<queue>\n\nstd::queue<int> g_queue;\nstd::condition_variable g_cv;\nusing namespace std::chrono_literals;\nstd::mutex mtx;\nvoid Producer()\n{\n    for (int i = 0; i < 10; ++i)\n    {\n        std::unique_lock<std::mutex> lock(mtx);\n        g_queue.push(i);\n        std::cout << \"push \" << i << std::endl;\n        // 通知\n        g_cv.notify_all();\n    }\n}\nvoid Consumer()\n{\n    while (1)\n    {\n        std::unique_lock<std::mutex> ul(mtx);\n        while (g_queue.empty())\n        {\n            g_cv.wait(ul);\n        }\n        int value = g_queue.front();\n        g_queue.pop();\n        std::cout << \"pop \" << value << std::endl;\n    }\n}\nint main()\n{\n    std::thread t1(Producer);\n    std::thread t2(Consumer);\n    std::thread t3(Consumer);\n    std::thread t4(Consumer);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n}\n```\n\n```bash\npush 0\npop 0\npush 1\npop 1\npush 2\npop 2\npush 3\npop 3\npush 4\npop 4\npush 5\npop 5\npush 6\npop 6\npush 7\npush 8\npush 9\npop 7\npop 8\npop 9\n```\n其中，还可以用lambda表达式指示wait的行为。等效于上面的代码。\n```cpp\nvoid Consumer()\n{\n    while (1)\n    {\n        std::unique_lock<std::mutex> ul(mtx);\n        g_cv.wait(ul, []() -> bool {return !g_queue.empty(); });\n        int value = g_queue.front();\n        g_queue.pop();\n        std::cout << \"pop \" << value << std::endl;\n    }\n}\n```\n# 线程池\n需要的组件：\n1. 任务队列，用queue。\n    1. 里面装的是`function`\n2. 互斥量，mutex\n3. 条件变量，cv\n4. 线程数组，vector\n    1. 里面装的是`thread`\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\n#include<queue>\n#include<vector>\n#include<functional>\nclass ThreadPool\n{\npublic:\n    ThreadPool(int threadNum) : stop(false)\n    {\n        for (int i = 0; i < threadNum; ++i)\n        {\n            threads.emplace_back([this]() {\n                while (1)\n                {\n                    std::unique_lock<std::mutex> u_lock(mtx);\n                    condition.wait(u_lock, [this]() {\n                        return !tasks.empty() || stop;\n                        });\n                    if (stop && tasks.empty()) // 如果只是stop但任务队列不空，则需要直到取完任务才能退出\n                    {\n                        return; // 退出本线程\n                    }\n                    std::function<void()> task(std::move(tasks.front()));\n                    tasks.pop();\n                    u_lock.unlock(); // ???\n                    task();  // 执行任务\n                }\n                });\n        }\n    }\n    ~ThreadPool()\n    {\n        {\n            std::unique_lock<std::mutex> u_lock(mtx);\n            stop = true;\n        }\n        condition.notify_all();  // ???\n        for (auto& t : threads)\n        {\n            t.join();  // ???\n        }\n    }\n    template<class F, class ... Args>\n    void enqueue(F&& f, Args&& ...args)\n    {\n        std::function<void()> task =\n            std::bind(std::forward<F>(f), std::forward<Args>(args)...); // ???\n        {\n            std::unique_lock<std::mutex> u_lock(mtx);\n            tasks.emplace(std::move(task)); // ??? // queue 没有emplace_back方法\n        }\n        condition.notify_one(); // ????\n    }\nprivate:\n    std::vector<std::thread> threads;\n    std::queue<std::function<void()>> tasks;\n    std::mutex mtx;\n    std::condition_variable condition;\n    bool stop;\n};\nint main()\n{\n    ThreadPool threadpool(4);\n    for (int i = 0; i < 20; ++i)\n    {\n        threadpool.enqueue([i]() {\n            std::cout << \"consuming task: \" << i << std::endl;\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n            std::cout << \"task \" << i << \" done\" << std::endl;\n            });\n    }\n}\n```\n输出结果：\n```\nconsuming task: consuming task: 1consuming task: 3\n\n0\nconsuming task: 2\ntask 1 donetask 2 done\ntask task 3 done\nconsuming task: 5\n0\nconsuming task: 4\n doneconsuming task: 6\n\nconsuming task: 7\ntask 5 donetask 7 done\n\ntask 4 done\ntask 6 done\nconsuming task: 8\nconsuming task: 11\nconsuming task: 9consuming task: 10\n\ntask 11task 9 done done\ntask 8 done\n\ntask 10 done\nconsuming task: 12consuming task: 14\n\nconsuming task: 15\nconsuming task: 13\ntask 13 donetask task task 15 done12 done14\n\n\n done\nconsuming task: 17consuming task: 16\n\nconsuming task: 19\nconsuming task: 18\ntask 16 donetask 18 done\ntask 19 done\n\ntask 17 done\n\n```\n几个疑点：\n1. 析构函数中，切换状态到stop后，为什么是`notify_all`，而生产者enqueue时，为什么是`notify_one`？能不能也用`notify_all`？\n2. 在线程lambda函数中，`task();`执行任务前，进行`u_lock.unlock()`解锁，而执行任务后，`u_lock`（`unique_lock`）会析构，会导致重复`unlock`，有影响吗？\n\n知识点：\n1. functional，函数对象\n2. `emplace_back`\n3. lambda\n\n关键点：\n1. 线程池状态切换会牵一发而动全身：\n    1. 线程函数在wait被唤醒时要看stop条件决定是否退出\n    2. 析构函数中，切换stop状态，不要忘记给stop加锁。使用到了局部作用域。\n    3. 在取出task时，用move，是为了避免拷贝吗？\n    4. 析构函数中，stop后，需要最后手动唤醒一次，让线程池处理残留的任务\n2. 变参模板，生产者放入任务的enqueue函数，使用到了：\n        1. 可变参模板\n        2. 万能引用（转发引用）\n        3. 引用折叠\n        4. bind函数绑定器\n        5. 可变参填写实参的`<Args>(args)...`写法形式\n        6. `std::move`（取出任务、放入任务时均使用）\n        7. 局部作用域（在unique_lock外加大括号）\n\n# future\nfuture这个东西，主要用于表示异步操作的结果。\n## `std::async`\n类似于`std::thread`，可以理解为异步的线程。用于异步执行一个函数。\n使用它，可以避免手动创建线程和管理线程的麻烦。\n```cpp\n#include<iostream>\n#include<future>\nint func()\n{\n    for (int i = 0; i < 1000; ++i)\n    {\n        ++i;\n    }\n    return i;\n}\nint main()\n{\n    // 子线程异步执行\n    std::future<int> future_result = std::async(std::launch::async, func);\n    // 主线程执行\n    std::cout << func() << std::endl; \n    // 主线程get等待，直到返回结果。\n    std::cout << future_result.get() << std::endl;\n}\n```\n结果：\n```\n1000\n1000\n```\n## `packaged_task`\n是一个类模板，用于将一个可调用对象（比如函数、函数对象、lambda表达式）封装为一个异步操作，并且可以返回一个`std::future`对象，可以用于表示异步操作的结果。\n\n封装好的这个packaged_task可以供其他线程使用。\n\n相当于，可以暂时不用async去执行异步操作，而是先封装起来，便于在想用的时候开箱即用。（个人理解）\n```cpp\n#include<iostream>\n#include<future>\nint func()\n{\n    int i = 0;\n    for (; i < 1000; ++i)\n    {\n        ++i;\n    }\n    return i;\n}\nint main()\n{\n    std::packaged_task<int()> task(func);\n    auto future_task = task.get_future();\n    // 子线程执行一遍task中的func\n    std::thread t1(std::move(task)); // 记得move，不然编译不通过\n    // 主线程执行一遍func\n    std::cout << func() << std::endl;\n\n    t1.join(); // 既然下面有了get等待，还需要去join吗？ // 需要！不然会崩溃\n    // 等待task执行完毕\n    std::cout << future_task.get() << std::endl;\n}\n```\n结果\n```\n1000\n1000\n```\n## promise\n是一个类模板，用于在子线程中设置一个值，并在主线程中获取这个值。值通过promise内部的future读取。\n\n通常于future和async一起使用，用于实现异步编程。\n\n>在A线程有一个值，B线程怎么获得它？\n\n参数传递、共享变量都可以。\npromise提供了新方法。\n```cpp\n#include<iostream>\n#include<future>\nvoid func(std::promise<int> &f)\n{\n    f.set_value(1000);\n    \n}\nint main()\n{\n    std::promise<int> f;\n    auto future_result = f.get_future();\n    std::thread t1(func, std::ref(f));   // 在子线程中设置值\n\n    t1.join();\n    // 在主线程中获得值\n    std::cout << future_result.get() << std::endl;\n    return 0;\n}// 1000\n```\n# atomic - 轻量解决数据竞态\n`std::atomic`是`C++11`标准库中的一个模板类，用于实现多线程环境下的原子操作。\n它提供了一种线程安全的方式来访问和修改共享变量，可以避免多线程环境中的数据竞争问题。\n`std::atomic`的使用方式类似于普通的变量，不同之处是它的操作是原子性的。\n以下是常用的`std::atomic`操作：\n* `load()`，相当于读值。\n* `store(val)`，相当于写值。是原子性的操作。\n* \n\n测试用mutex互斥量，开5个线程，加到50000的时间：\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nint a = 0;\nstd::mutex mtx;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        mtx.lock();\n        a += 1;\n        mtx.unlock();\n    }\n}\nint main()\n{\n    auto cur = std::chrono::duration_cast<std::chrono::microseconds>\n        (std::chrono::system_clock::now().time_since_epoch()).count();\n    std::thread t1(func);\n    std::thread t2(func);\n    std::thread t3(func);\n    std::thread t4(func);\n    std::thread t5(func);\n\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    t5.join();\n\n    std::cout << a << std::endl;\n    auto last = std::chrono::duration_cast<std::chrono::microseconds>\n        (std::chrono::system_clock::now().time_since_epoch()).count();\n    std::cout << last - cur << std::endl;\n\n}\n```\n8000到9000微秒。\n\n测试int原子变量，开5个线程，加到50000的时间：\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\nstd::atomic<int> a = 0;\nvoid func()\n{\n    for (int i = 0; i < 10000; ++i)\n    {\n        a += 1;\n    }\n}\nint main()\n{\n    auto cur = std::chrono::duration_cast<std::chrono::microseconds>\n        (std::chrono::system_clock::now().time_since_epoch()).count();\n    std::thread t1(func);\n    std::thread t2(func);\n    std::thread t3(func);\n    std::thread t4(func);\n    std::thread t5(func);\n\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    t5.join();\n\n    std::cout << a << std::endl;\n    auto last = std::chrono::duration_cast<std::chrono::microseconds>\n        (std::chrono::system_clock::now().time_since_epoch()).count();\n    std::cout << last - cur << std::endl;\n\n}\n```\n6000到7000微秒。\n提升了20%到30%。\n## 知识点\n1. `duration_cast<std::chrono::microseconds>`是把`std::chrono::system_clock::now().time_since_epoch()`转成了设定的时间格式，此例转的是微秒。","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"职业规划2025","url":"/课堂笔记/职业规划2025/","content":"# 语言\n## C++\n了解一些C++新特性，比如concept、Policy、constexpr，对找高薪工作有帮助吗？jthread、ranged_for。\nC++20的协程。\nC++26的反射。\n有没有必要花时间在新标准上？\n## Go？\n有必要转Go吗？\n## Java？\n了解一些，后端是不是最好用Java做？岗位多。发展路径。\n\n## 总结\n\n---\n# 操作系统\n## Linux\n主要学的是Linux，gcc、CMake。\ngdb只会简单的调试。\n## Windows\n只了解很简单的窗口开发，看手册。\n## 多线程\n掌握到什么程度？\n之前学了不少相关知识，但都差不多忘记了。\n如果让现场编、设计多线程程序，不熟练。\n## 总结\n\n---\n\n# 网络\n前段时间刚大概复习了一下4层模型。和TCP协议。\nHTTP了解地不够细致，没有深入学。\n\n\n## 总结\n\n---\n\n# 数据库\n大多数都忘记了。掌握哪些知识？多深入？","categories":["课堂笔记"]},{"title":"01_为什么要用RPC分布式","url":"/RPC/01_为什么要用RPC分布式/","content":"# 提高硬件上限\n受限于硬件条件，服务器所能承受的用户的并发量。\n# 解耦项目架构，便于管理\n如果整个项目代码全部在一起，假设只修改一个单元模块的几行代码，则可能需要把整个项目重新编译、部署，耗时太长。\n# 各模块对硬件要求不一样\n有些模块是CPU密集型，有些模块是I/O密集型。各模块对硬件资源的需求不一样。分模块，分布式，可以充分发挥每个服务器硬件的优势。\nCPU密集型用于数据处理、计算。要求CPU性能。\nI/O密集型用于处理请求、连接。要求网络带宽。\n# 单纯的集群\n1. 优点：集群只能解决提高硬件的上限。\n2. 缺点：如果只做集群，不做分布式，在只修改几行代码后每个服务器都需要重新编译、部署全部代码。更头疼了。\n3. 缺点：不能精细地控制硬件资源和模块的适配。\n# 可以在分布式的基础上集群\n根据节点对应的功能模块的并发要求，可以针对性地对某一模块进行集群部署。\n# 分布式虽好，但要解决的问题\n## 大系统的软件模块怎么划分\n各模块可能会实现大量重复的代码\n## 各模块之间怎么访问\n各模块都运行在不同的进程中。\n（比如可以运行在docker虚拟化环境中，各个模块单独运行在一个环境中）\n比如，用户管理是一个单独的模块，和好友管理模块运行在不同的环境、进程。\n用户管理，可能某个用户需要调用user.GetUserFriendLists(userid)。\n而这个接口/函数可能处于好友管理模块中。\n```cpp\n// 机器1\nuser.GetUserFriendLists(userid);\n// 机器2\nlist<User> GetUserFriendLists(int userid);\n```\n机器1上的模块怎么调用机器2上的模块的一个业务方法呢？？？\n机器1上的一个模块进程1怎么调用机器1上的模块进程2里面的一个业务方法呢？？？\n## 解决方案\n见《RPC通信原理》一篇。","categories":["项目","rpc"]},{"title":"SSH连接","url":"/项目/SSH连接/","content":"想用windows主机ssh连接虚拟机，连不上。\n# 确保 SSH 服务已安装并运行\n虽然Ubuntu系统自带了ssh，但是这是客户端的，服务端的openssh-server没有安装。\n```bash\n# 检查服务状态\nsudo systemctl status ssh    # Ubuntu/Debian\nsudo systemctl status sshd   # CentOS/RHEL\n\n# 若未安装\nsudo apt install openssh-server  # Ubuntu\nsudo yum install openssh-server  # CentOS\n\n# 启动并设置开机自启\nsudo systemctl start ssh\nsudo systemctl enable ssh\n```\n## 检查SSH端口监听\n```bash\nsudo netstat -tuln | grep :22\n```\n- 正常应显示：`tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN`\n- 若未监听，修改配置：`sudo nano /etc/ssh/sshd_config`\n\n确保存在：\n```bash\nPort 22\nListenAddress 0.0.0.0  # 允许所有IP连接\nPermitRootLogin yes    # 临时允许root登录（测试后建议关闭）\n```\n## 重启SSH服务\n```bash\nsudo systemctl restart ssh\n```\n# VSCode远程连接\n在Extensions中搜索Remote，安装Remote Development。\n之后左边就会多出一个选项：\n![](../../images/SSH连接/image-20250712225052906.png)\n\n点击后，在边栏右上角选择Remotes（SSH）\n![](../../images/SSH连接/image-20250712225121541.png)\n\n然后点SSH栏右边的齿轮。\n![](../../images/SSH连接/image-20250712225212657.png)\n\n上边栏就会出现：\n![](../../images/SSH连接/image-20250712225229502.png)\n\n我们选择第一个，也是Windows下当前用户默认的ssh配置文件夹。\n![](../../images/SSH连接/image-20250712225309404.png)\n\n在里面配置远程主机的连接信息\n![](../../images/SSH连接/image-20250712225327413.png)\n\nHost指主机名，Linux中@后面的就是。\n![](../../images/SSH连接/image-20250712225420004.png)\nHostName指ip地址。Linux下ifconfig可以查看。\nUser指@前面的。\n\n保存文件之后，左边栏就会出现：\n![](../../images/SSH连接/image-20250712225556409.png)\n\n# SSH远程连接虚拟机 怎么用公钥免除每次登录输入密码的烦恼\n服务器存放公钥。\n终端存放私钥。\n## 生成密钥对（主机操作）\n\n打开终端（Windows 使用 PowerShell 或 CMD；Mac/Linux 用系统终端）\n生成密钥：\n```sh\nssh-keygen -t ed25519 -C \"your_email@example.com\"  # 推荐 ed25519\n# 或传统 RSA：ssh-keygen -t rsa -b 4096\n```\n\n按提示完成（默认保存位置 `~/.ssh/id_ed25519`）\n\n## 复制公钥到虚拟机\n方法一：自动复制（推荐）（主机操作）\n\n```sh\nssh-copy-id -i ~/.ssh/id_ed25519.pub user@vm_ip\n# 输入虚拟机密码一次\n```\n\n方法二：手动复制\n\n```sh\ncat ~/.ssh/id_ed25519.pub # 查看主机上的公钥内容\nssh user@vm_ip            # 登录虚拟机\n\nmkdir -p ~/.ssh\necho \"粘贴的公钥内容\" >> ~/.ssh/authorized_keys\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n```\n\n## 配置主机的VSCode\n按 `F1` > 选择 ​​`Remote-SSH: Connect to Host...​​`\n选择 ​​`Configure SSH Hosts...`​​ > 添加配置：（其实是帮你打开`~/.ssh/config`）\n\n```\nHost MyVM   # 自定义别名\n  HostName 192.168.1.100          # 虚拟机IP\n  User your_username\n  IdentityFile ~/.ssh/id_ed25519  # 私钥路径\n```\n\n保存配置文件（通常是 `~/.ssh/config`）\n## 常见问题解决\n1. ​**​权限错误​**​：\n    `chmod 600 ~/.ssh/config   # 确保本地 config 文件权限正确`\n2. ​**​服务端配置检查​**​：\n    - 确认虚拟机 `/etc/ssh/sshd_config` 包含：\n        `PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys`\n    - 重启 SSH 服务：\n        `sudo systemctl restart sshd`\n3. ​**​调试连接​**​：\n    `ssh -Tv user@vm_ip   # -v 查看详细日志`\n\n\n> ✅ 成功标志：使用 `ssh user@vm_ip` 或 VSCode 连接时无需输入密码即可登录。\n> 遇到问题建议检查两边日志（本地终端 debug 信息或虚拟机 `/var/log/auth.log`）","categories":["项目"]},{"title":"学习项目中踩的坑和注意点","url":"/项目/学习项目中踩的坑和注意点/","content":"有的项目课程是2020年左右的，当时使用的boost 1.69和gcc 4.6版本，放到现在（2025年）的Ubuntu 24版本下，不能很好地兼容。\n此时为了尽快顺利进入到课程学习的轨道上，而不是为了想办法去兼容新Ubuntu，妥协的做法是安装一个降级的Ubuntu 20版本。\n# 记录安装muduo过程的配套工具的版本\n以下环境能成功安装muduo老版本\n1. Ubuntu 20.04.6\n2. gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0\n3. g++ (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0\n4. cmake version 3.16.3\n5. make: GNU Make 4.2.1 Built for x86_64-pc-linux-gnu\n\n以上，都是Ubuntu此版本apt安装的默认的版本。\n# Ubuntu的跨虚拟机复制粘贴问题\nVMware虚拟机Linux与主机Windows之间不能拖拽、跨端复制粘贴\n## 验证VMware Tools安装状态\n```bash\n# 检查VMware服务状态\nsudo systemctl status vmware-tools\n\n# 确认open-vm-tools已安装\nsudo apt list --installed | grep open-vm-tools  # Debian/Ubuntu\nrpm -qa | grep open-vm-tools                  # CentOS/RHEL\n```\n## 重启关键服务\n```bash\nsudo systemctl restart vmware-tools\nsudo systemctl restart vmtoolsd\n```\n## 如果vmware-tools.service could not be found\n安装/重装 open-vm-tools\n```bash\n# Ubuntu/Debian\nsudo apt update\nsudo apt install --reinstall open-vm-tools open-vm-tools-desktop\n\n# CentOS/RHEL\nsudo yum reinstall open-vm-tools open-vm-tools-desktop\n\n# 启用服务（服务名是 vmtoolsd）\nsudo systemctl enable --now vmtoolsd\n```\n## 检查驱动加载状态\n```bash\nlsmod | grep -E 'vmw_vmci|vmw_vsock_vmci_transport'\n# 应有类似输出：\n# vmw_vmci               98304  1\n# vmw_vsock_vmci_transport    45056  0\n```\n## 强制重装工具\n```bash\nsudo apt purge open-vm-tools && sudo apt autoremove\nsudo apt install open-vm-tools open-vm-tools-desktop\n```\n## 如果不稳定，建议使用挂载点共享文件\n目前确实可以复制粘贴文本、小文件了，但是大文件不行，很不稳定。\n\n虚拟机设置 → 选项 → 共享文件夹 → 添加主机目录\n\n会挂载到Linux的`/mnt/hgfs`下。","categories":["项目"]},{"title":"01_数组_01_二分查找","url":"/算法/01_数组_01_二分查找/","content":"https://leetcode.cn/problems/binary-search/\n# 内容\n\n给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n**示例 1:**\n\n**输入:** `nums` = `[-1,0,3,5,9,12]`, `target` = 9\n**输出:** 4\n**解释:** 9 出现在 `nums` 中并且下标为 4\n\n**示例 2:**\n\n**输入:** `nums` = `[-1,0,3,5,9,12]`, `target` = 2\n**输出:** -1\n**解释:** 2 不存在 `nums` 中因此返回 -1\n\n**提示：**\n\n1. 你可以假设 `nums` 中的所有元素是不重复的。\n2. `n` 将在 `[1, 10000]`之间。\n3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。\n# 代码（线性探测重复值）\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int pos = -1;\n        int left = 0;\n        int right = nums.size() - 1;\n        while (left <= right)\n        {\n            int mid = ((right - left) >> 1) + left;\n            if (target < nums[mid])\n            {\n                right = mid - 1;\n            }\n            else if (target > nums[mid])\n            {\n                left = mid + 1;\n            }\n            else // ==\n            {\n                pos = mid;\n                while (pos > left && nums[pos - 1] == target)\n                {\n                    --pos;\n                }\n                break;\n            }\n        }\n        return pos;\n    }\n};\n```\n## 坑1\n我第一次在线性向前探测重复值的时候写错了 while 的判断条件，不应该是`pos > 0`，而是`pos > left`\n## 坑2\n第一次写的时候，把`>> 2`右移运算符写成了大于号`> 2`，而且，不应该是`>> 2`，应该是`>> 1`右移1位，也就是对应着除以2。这是致命的错误。\n![](../../images/刷题_二分查找/image-20250326101058377.png)\n但是测试用例居然全都通过了！这可能是因为我用到了线性探测，让算法实际以遍历的形式找到了正确答案......\n# 心得\n在做二分查找或者分治思想类的题目，最难、最重要的把握点是物理下标和逻辑下标的关系。\n像这个题目中，`left`、`right`、`mid`都是物理下标。\n物理下标应该实时更新。\n不应该只出现逻辑下标。\n就像线性探测时的 while 条件中判断`pos > 0`就是错误使用了逻辑下标去充当条件。应当是`pos > left + 0`，省略`+ 0`即为`pos > left`。\n# 优化代码（继续二分探测）\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int pos = -1;\n        int left = 0;\n        int right = nums.size() - 1;\n        while (left <= right)\n        {\n            int mid = ((right - left) >> 1) + left;\n            if (target < nums[mid])\n            {\n                right = mid - 1;\n            }\n            else if (target > nums[mid])\n            {\n                left = mid + 1;\n            }\n            else // ==\n            {\n                pos = mid;\n                right = mid - 1;\n            }\n        }\n        return pos;\n    }\n};\n```\n这能让探测行为继续保持二分的$O(\\log {n})$的复杂度进行。\n从 $O(\\log {n} + k)$（k为重复次数）优化至 $O(\\log {n})$，完全消除了线性探测的开销。\n# 总结\n","categories":["算法","二分查找"]},{"title":"01_数组_02_移除重复元素","url":"/算法/01_数组_02_移除重复元素/","content":"https://leetcode.cn/problems/remove-element/\n# 内容\n\n给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。\n\n假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：\n\n- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。\n- 返回 `k`。\n\n**示例 1：**\n\n**输入：** nums = `[3,2,2,3]`, val = 3\n**输出：** 2, nums = `[2,2,_,_]`\n**解释：** 你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。\n\n**示例 2：**\n\n**输入：** nums = `[0,1,2,2,3,0,4,2]`, val = 2\n**输出：** 5, nums = `[0,1,4,0,3,_,_,_]`\n**解释：** 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。\n注意这五个元素可以任意顺序返回。\n你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。\n\n**提示：**\n- `0 <= nums.length <= 100`\n- `0 <= nums[i] <= 50`\n- `0 <= val <= 100`\n# 代码（后边界起遍历）\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int r = nums.size(); // removed flag\n        int t = r - 1;       // travel flag\n        while (t >= 0)\n        {\n            if (val == nums[t])\n            {\n                --r;\n                std::swap(nums[t], nums[r]);\n            }\n            --t;\n        }\n        return r;\n    }\n};\n```\n## 思想\n这是快慢指针的一个解法。测试用例全部通过。\n但是，对于`[0,1,2,2,3,0,4,2]`，结果是`[0,1,0,4,3]`。\n虽然符合了题目中的”这五个元素可以任意顺序返回“。\n但是最好还是不要改变元素原先在数组中的顺序。\n## 可以改进的点\n实际上不需要swap函数，而是直接`nums[t] = nums[r]`即可，因为删除之后，删除区的元素是什么不重要了，不需要保留原先的删除的数据。\n# 代码（左边界起遍历）\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int processed = -1;      // processed flag\n        int travel = 0;       // travel flag\n        while (travel < nums.size())\n        {\n            if (val != nums[travel])\n            {\n                ++processed;\n                nums[processed] = nums[travel];\n            }\n            ++travel;\n        }\n        return processed + 1;\n    }\n};\n```\n# 复杂度分析\n相比于双层for循环的暴力解法，快慢指针的方法可以让时间复杂度降为$O(n)$，这也是STL中vector中erase的时间复杂度。\n空间复杂度$O(1)$。","categories":["算法","双指针"]},{"title":"01_数组_03_非递减数组的平方","url":"/算法/01_数组_03_非递减数组的平方/","content":"https://leetcode.cn/problems/squares-of-a-sorted-array/description/\n# 内容\n\n给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n\n**示例 1：**\n\n**输入：** nums = `[-4,-1,0,3,10]`\n**输出：** `[0,1,9,16,100]`\n**解释：** 平方后，数组变为 `[16,1,0,9,100]`\n排序后，数组变为 `[0,1,9,16,100]`\n\n**示例 2：**\n\n**输入：** nums = `[-7,-3,2,3,11]`\n**输出：** `[4,9,9,49,121]`\n\n**提示：**\n\n- `1 <= nums.length <= 104`\n- `-104 <= nums[i] <= 104`\n- `nums` 已按 **非递减顺序** 排序\n\n**进阶：**\n\n- 请你设计时间复杂度为 `O(n)` 的算法解决本问题\n# 代码（后边界起遍历）\n```cpp\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int left = 0;\n        int right = nums.size() - 1;\n        vector<int> newnums(nums.size());\n        for (int i = newnums.size() - 1; i >= 0; --i)\n        {\n            int a = nums[left]  > 0 ? nums[left]  : -nums[left];\n            int b = nums[right] > 0 ? nums[right] : -nums[right];\n            if (a >= b)\n            {\n                newnums[i] = a * a;\n                ++left;\n            }\n            else\n            {\n                newnums[i] = b * b;\n                --right;\n            }\n        }\n        return newnums;\n    }\n};\n```\n## 思想\n数组其实是有序的， 只不过负数平方之后可能成为最大数了。\n\n那么**数组平方的最大值就在数组的两端**，不是最左边就是最右边，不可能是中间。\n\n此时可以考虑双指针法了，left 指向起始位置，right 指向终止位置。\n\n定义一个新数组newnums，和原数组一样的大小，让 i 指向新数组终止位置。\n\n如果`A[left] * A[left] < A[right] * A[right]` 那么`newnums[i] = A[left] * A[left];` 。反之`= A[right] * A[right]`\n# 复杂度分析\n相比于双层for循环的暴力解法，快慢指针的方法可以让时间复杂度降为$O(n)$。\n空间复杂度$O(n)$。\n![](../../images/01_数组_03_非递减数组的平方/image-20250326232703496.png)\n\n","categories":["算法","双指针"]},{"title":"并查集","url":"/高级数据结构/并查集/","content":"# 并查集\n主要用于解决**元素分组**的问题。主要操作有**集合（或单个元素）的合并**和**查询元素所在的集合**。\n元素以在同一棵树下为标志，认为在同一集合中。多个集合对应着多棵不同的树，组成了森林。\n逻辑上是树形结构，实际上用数组存储元素所在集合的根节点。\n# 合并\n合并 x 和 y 两个元素时，不能直接合并两个元素，而是要合并两个元素所在树的根节点。\n# 查询\n查询 x 和 y 是否在同一个集合，是查询 x 和 y 对应的根节点是否相同。\n# 合并示例\n![](../../images/并查集/image-20250325235047075.png)\n\n![](../../images/并查集/image-20250325235101586.png)\n## 代码\n```cpp\n#include<iostream>\nconst int SIZE = 9;\nint parent[SIZE];\n// 非递归版查询x的根节点\nint find(int x)\n{\n    while(x != parent[x])\n    {\n        x = parent[x];\n    }\n    return x;\n}\n// 递归版查询x的根节点\nint r_find(int x)\n{\n    if(x == parent[x]) return x;\n    return r_find(parent[x]);\n}\n// 合并x和y\nvoid merge(int x, int y)\n{\n    int x_root = find(x);\n    int y_root = find(y);\n    if (x_root != y_root)\n    {\n        parent[y_root] = x_root;\n    }\n}\nint main()\n{\n    for(int i = 1; i < SIZE; ++i)\n    {\n        parent[i] = i;\n    }\n    int x, y;\n    // 输入6组两个整数，全都合并。\n    for(int i = 1; i <= 6; ++i)\n    {\n        std::cin >> x >> y;\n        merge(x, y);\n    }\n    for(int i = 1; i < SIZE; ++i)\n    {\n        std::cout << parent[i] << \" \";\n    }\n    std::cout << std::endl;\n    std::cout << \"输入要查询的2个元素是否在一个集合：\";\n    std::cin >> x >> y;\n    std::cout << (find(x) == find(y) ? \"在\" : \"不在\") << std::endl;\n}\n```\n\n```bash\n输入：\n1 3\n1 2\n5 4\n2 4\n6 8\n8 7\n输出parent数组：\n1 1 1 5 1 6 6 6 \n输入要查询的2个元素是否在一个集合：\n2 4\n输出：\n在\n```\n# 路径压缩\n","categories":["算法","高级数据结构"]},{"title":"大数据查重","url":"/算法/大数据查重/","content":"# 哈希表 - 找重复数字、字符（不限制内存）\n```cpp\n#include<iostream>\n#include<vector>\n#include<ctime>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\nint main()\n{\n    vector<int> vec;\n    srand(time(NULL));\n    for(int i = 0; i < 1000; ++i)\n    {\n        vec.push_back(rand() % 100);\n    }\n    // 问题1：找第一个出现重复的数字 - 需要set来统计\n    unordered_set<int> set1;\n    int count = 0;\n    for(const auto & key : vec)\n    {\n        const auto it = set1.find(key); // O(1)\n        if (it == set1.end())\n        {\n            set1.insert(key);\n        }\n        else\n        {\n            cout << \"重复的数字是\" << key << endl;\n            ++count;\n            // break; // 找所有重复出现的数字时，去掉break\n        }\n    }\n    std::cout << \"总共重复了\" << count << \"个数\" << endl;\n    // 问题2：统计重复的数字以及出现的次数 - 需要map来统计数字及次数\n    unordered_map<int, int> map1;\n    for(const auto & key : vec)\n    {\n        const auto it = map1.find(key);   // O(1)\n        if (it == map1.end()) \n        {\n            // map插入的是pair，这里emplace可以直接构建\n            map1.emplace(key, 1); // O(1)\n        }\n        else\n        {\n            ++it->second;\n        }\n        // 以上for区域中的语句可以被一行代码代替：++map1[key]\n    }\n    for(const auto & pair : map1)\n    {\n        if(pair.second > 1)\n        {\n            cout << \"数字\" << pair.first << \"重复\" << pair.second << \"次\" << endl;\n        }\n    }\n    // 问题3：去重\n    unordered_set<int> set2;\n    for(const auto & key : vec)\n    {\n        set2.emplace(key);\n    }\n    // 问题4：字符串中找第一个没有重复出现过的字符\n    bool haveDuplicate = false;\n    string str = \"fgodgnffinogiofdngps\";\n    unordered_map<char, int> map2;\n    for(const auto & key : str)\n    {\n        ++map2[key];\n    }\n    for(const auto & key : str)\n    {\n        if (map2[key] == 1)\n        {\n            haveDuplicate = true;\n            cout << \"第一个不重复的字符为\" << key << endl;\n            break;\n        }\n    }\n    if (!haveDuplicate)\n    {\n        cout << \"所有字符都重复\" << endl;\n    }\n}\n```\n# 哈希表分桶 - 两个大文件，找重复内容（适当限制内存）\n有两个文件分别是a和b，各自存放了1亿条IP地址，限制内存100MB，找出两个文件中重复的ip地址。\n总体思路是，把一个文件的内容输入到哈希表中，遍历另一个文件中的每一条IP地址，与哈希表中的key比对。因此只需要提供1个文件的内存占用即可。\nIPv4地址的大小是4个字节。1亿是100M，则1亿条IP地址就是400MB。如果再加上unordered_map结构的地址域，那就要再翻倍，把一个文件输入到哈希表中就要占800MB内存。这显然是超出了100MB的要求。\n可以这样：文件a的IP地址依次读取，取模（或者称之为哈希函数），比如`%11`，这样把他们都分散到11个“桶”里。\n把文件b也像这样，挨个IP地址取模，在a的相应的“桶”号下，去寻找。因为如果IP地址一样，用了相同的取模运算（哈希运算），所以是在同一个桶号里。\n这样，就把1亿个IP地址分成了11波。内存压力减少到了80MB。\n# 位数组 - （小内存）\n如果数据集中的最大值很大，那么中间有好多无效的空位被浪费。总体上还是浪费内存的。\n# Bloom Filter 布隆过滤器 - （极限内存）\n结合了哈希+位数组的优势。内存使用效率高。","categories":["算法","场景题"]},{"title":"高级数据结构_B树家庭_索引管理思想","url":"/高级数据结构/高级数据结构_B树家庭_索引管理思想/","content":"# B的含义\nB树是由Rudolf Bayer和Edward M. McCreight在波音研究实验室工作时发明的，目的是有效地**管理大型随机访问文件的索引页面**。\n\n基本假设是索引会非常庞大，以至于只有树的小块可以放入主内存中。\n\nBayer和McCreight从未解释过\"B\"代表什么, 如果可能的话, 可能会是：Boeing、**balanced**、broad、busy和Bayer。\nMcCreight曾说过“你对B树中的'B'的含义思考得越多，你对B树的理解就越好。”\n\n不管\"B\"代表的什么含义, **总之肯定不是\"Binary\", 因为B树不是二叉树**; \n那么, 我们暂且就把B Tree中的\"B\"当做是\"Balanced\"吧!\n# m阶平衡树\n\nm阶, 这个\"阶\"对于树来说怎么解释?\n\n拿例子说话吧!\n\n**AVL树**, 就是一个**2阶平衡树**, 所谓2阶, 指的是, 1个节点有2个指针域指向2个孩子, 和1个数据域;\n\n那么, m阶的意思就是: $1$个节点最多有$m$个指针域指向$m$个孩子, 和最多有$m-1$个数据域;\n\nB树的特点是和AVL如出一辙的, 甚至比AVL还要道高一尺, AVL只能保证左右子树高度差不超过1, \n而**B树的性质保证了所有叶节点同时在同一层**, 由此可以看出, B树是比AVL更平衡的树; \n\n由此可见, B树只不过是一个2阶平衡树(AVL)的一个横向变种罢了! 本质上还是AVL的灵魂; \n\n> 形式上都是平衡的, 但, 与AVL最大的不同是, B树没有节点的旋转操作, 而是涉及到分裂/合并;\n# B树的性质\n\n根据Knuth的定义，$m$阶B树是满足以下性质的树：\n\n1. 每个节点最多有$m$个子节点。\n2. 每个内部节点至少有$\\lceil m/2 \\rceil$个子节点。\n3. 每个非叶节点至少有2个孩子。\n4. 所有叶子都出现在同一层次上并且不携带任何信息。\n5. 具有$k$个子节点的非叶节点包含$k-1$个键。\n\n每个内部节点的键充当分割其子树的分隔值。例如，如果一个内部节点有3个子节点（或子树），那么它必须有2个键：$a_1$和$a_2$。 最左子树中的所有值都小于$a_1$，中间子树中的所有值都在$a_1$和$a_2$之间，最右子树中的所有值都大于$a_2$。\n# B树、AVL、红黑树、BST这些搜索树的对比\n**B树即平衡树，m阶平衡树**。符合搜索树的性质（中序遍历有序）。\n\n**4阶平衡树即2-3-4树**，指树的节点最多有3个关键码，4个分支。2-3-4树实际上就是4阶B树。即: 每个节点, 最多有三个数据, 4个孩子节点\n\n**2阶平衡树即AVL树**。一个节点有2个分支。\n\n但**BST（Binary Search Tree）不是2阶平衡树**，因为BST中的B指的不是Balanced，而是Binary，因此**BST没有平衡性质**。\n\nAVL树节点的左右子树高度差不超过1。\n\nB树相比AVL更平衡，因为所有叶子节点都在同一层。适用于文件索引系统。\n\nB树、AVL树、红黑树、BST本质上**都是一棵搜索树**，\n只不过B树是m阶的。BST、AVL、**红黑树是2阶的**。\nB树完全平衡，AVL树高度平衡，红黑树近乎平衡，BST不平衡。\n# B树的行为\n## 插入\n特点是，如果节点内的关键码达到了m个，将会分裂。把m个关键码中的中间值往上推一层。被上移的节点左右指向剩下的两半。\n## 删除\n有两种常用的删除策略：\n1. 定位并删除元素，然后调整树使它满足约束条件。\n2. 从上到下处理这棵树，在进入一个节点之前，调整树使得之后一旦遇到了要删除的元素，它可以被直接删除而不需要再进行调整。\n    1. 这种策略就类似于，红黑树的删除操作前，先让所有的2-型节点扩张为3-型或4-型节点，再去直接删除。见“C语言_树”\n\n以下讨论的是第1种策略。\n\n1. 有没有孩子\n    1. 如果删除的关键码没有孩子，可以直接删除。\n    2. 如果删除的关键码有孩子，需要从左孩子节点中找最右值或右孩子找最左值，将其上移补位。等于是把孩子中的一个关键码删去了。\n2. 删除后\n    1. 如果删除后，节点的关键码数小于$(m/2)(上取整)-1$。（比如，5阶B树，删除后节点关键码数目小于2（即1个）；4阶B树（2-3-4树）中删除后节点关键码数目小于1（即0个））。这叫做“**不丰满**”。\n    2. 如果节点的关键码数大于$(m/2)(上取整)-1$，叫做“**丰满**”。\n    3. 若等于，则类似于“**刚刚脱贫**”。此时如果删去一个元素，就会“不丰满”。\n    4. 兄弟丰满，**借**：如果删除后“不丰满”，则把父节点元素下移补充，而父节点需要向该删除后的节点相邻的丰满的兄弟节点中借一个元素。\n    5. 兄弟太穷，**并**：如果相邻的兄弟节点都是“刚刚脱贫”的，就要靠父节点下移一个元素，补充到这个删除的位置，然后与相邻的一个兄弟节点进行“合并”成为一个节点。\n\n5阶B树为例，删除：\n![](../../images/高级数据结构_B树家庭/b-tree-2.svg)\n如图所示，接下来要依次删除 8，20，18，5。\n\n首先要删除元素 8。先查找到元素 8 在叶子节点中，删除 8 后叶子节点的元素个数为 2，符合 B 树的规则。然后需要把元素 11 和 12 都向前移动一位。完成后如图所示。\n![](../../images/高级数据结构_B树家庭/b-tree-3.svg)\n下一步，删除 20，因为 20 没有在叶子节点中，而是在中间节点中找到，可以发现 20 的继承者是 23（字母升序的下个元素），然后需要将 23 上移到 20 的位置，之后将孩子节点中的 23 进行删除。\n\n删除后检查一下，该孩子节点中元素个数大于 2，无需进行合并操作。\n\n所以这一步之后，B 树如下图所示。\n![](../../images/高级数据结构_B树家庭/b-tree-4.svg)\n下一步删除 18，18 在叶子节点中，但是该节点中元素数目为 2，删除导致只有 1 个元素，已经小于最小元素数目 2。\n\n而由前面已经知道：如果其某个相邻兄弟节点中比较丰满（元素个数大于 $\\lceil \\dfrac{5}{2} \\rceil - 1$），则可以向父节点借一个元素，然后将最丰满的相邻兄弟节点中上移最后或最前一个元素到父节点中。\n\n在这个实例中，右相邻兄弟节点中比较丰满（3 个元素大于 2），所以先向父节点借一个元素 23 下移到该叶子节点中，代替原来 19 的位置。19 前移。\n\n然后 24 在相邻右兄弟节点中，需要上移到父节点中。最后在相邻右兄弟节点中删除 24，后面的元素前移。\n\n这一步之后，B 树如下图所示。\n![](../../images/高级数据结构_B树家庭/b-tree-5.svg)\n最后一步需要删除元素 5，但是删除后会导致很多问题。因为 5 所在的节点数目刚好达标也就是刚好满足最小元素个数 2。\n\n而相邻的兄弟节点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点先借父节点一个元素，再与某相邻兄弟节点进行合并操作；首先移动父节点中的元素（该元素在两个需要合并的两个节点元素之间）下移到其子节点中。\n\n然后将这两个节点进行合并成一个节点。所以在该实例中，首先将父节点中的元素 4 下移到已经删除 5 而只有 6 的节点中，然后将含有 4 和 6 的节点和含有 1，3 的相邻兄弟节点进行合并成一个节点。\n\n这一步之后，B 树如下图所示。\n![](../../images/高级数据结构_B树家庭/b-tree-6.svg)\n但是这里观察到父节点只包含了一个元素 7，这就没有达标（因为非根节点包括叶子节点的元素数量 ![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 \"K\") 必须满足于 $2\\le K\\le 4$)，而此处的 $K=1$）。\n\n如果这个问题节点的相邻兄弟比较丰满，则可以向父节点借一个元素。而此时兄弟节点元素刚好为 2，刚刚满足，只能进行合并，而根节点中的唯一元素 13 下移到子节点。这样，树的高度减少一层。\n\n所以最终的效果如下图。\n![](../../images/高级数据结构_B树家庭/b-tree-7.svg)\n# B树的应用场景 - 文件索引(数据库索引)\nB树本质上还是一棵搜索树，只不过是m阶的完全平衡树。\n\n如果系统所管理的数据量很大，需要用磁盘、硬盘、外存存储，那么为了提高效率，会给数据创建索引。为了索引查询的高效，需要给索引排序。\n\n如果没有索引，如果数据表有1000w行数据，则需要整表线性搜索。\n如果有索引，则有搜索树结构。则查找效率为$O(log_2 N)$。（这一点在AVL树和B树上查找效率是一样的）\n如果是树节点是m阶。则**传输次数**为$log_m N$。（树的层高，决定了AVL树和B树实际的查找效率不同）\n\n注意区分传输次数和查找效率：\n传输次数指的是，按照大节点划块。\n最终还是得在大节点的内部进行查找，而查找的最快算法只能是二分查找。\n\n所以这个例子很好地说明了，算法和数据结构二者的地位，缺一不可。\n算法效率固然重要，但：\n数据结构将决定是否能很好地适配计算机的整体存储结构，达到实际的较高性能。\n## 操作系统原理\n操作系统中\n1. 内存，按页面(page)为最小单位分配、管理，默认每一页4K。\n    1. 所以代码上看似我们只占用了几字节，但是实际上可能占用了1页。\n    2. 某些场景会使用大页（Huge Pages，如 2MB 或 1GB）以优化性能，但这需要显式配置，并非默认行为。\n2. 磁盘，按块(block)为最小单位分配、管理。大多数文件系统（如 ext4、NTFS）默认使用 ​4KB 的块大小，与内存页对齐以提高效率。\n    1. 所以操作系统在读取文件时，并不是只读取了几个字节，而是整个块大小。\n    2. **可配置性**：块大小可以按需调整（如 1KB、8KB、16KB 等），通常用于特定场景（如处理超大文件或数据库优化）。\n    3. **物理扇区与逻辑块**：磁盘的物理扇区大小可能为 512B 或 4KB，但文件系统的逻辑块（Block）会组合多个扇区，形成更大的逻辑单元，16KB 的块就是由 32 个 512B 扇区组成的。\n### 先用内存管理举例子，类比磁盘读取\n我们malloc或者new一个int，表面上申请了4字节。但是内核的内存管理是按最小一个页面大小（4 KB）来申请的。\n这是由内核中，`libc.so`或`libc++.so`库中ptmalloc或者tcmalloc来管理的内存池实现。\n如果申请了下一个对象的内存空间，内存池管理的这个页面尚有空间，则直接返回预申请好的这个页面中空闲的地址。\n\n那么，硬盘（磁盘）读取数据到内存中，也是同样的道理，按块来读取，磁盘扇区一般是 512B ，文件系统逻辑块组合多个扇区，可能是 16KB ，是页面大小（4KB）的整数倍。\n所以，读取一次硬盘（磁盘）数据，并不只是读取了几个字节，而是把一整块数据读到了内存缓冲区中。\n### 分析和方案 - 假设有1千万份简历 - 设计索引\n如果我们有1千万份简历文件，每份简历文件为10M，则粗略计算其有9000G。\n如何对所有简历文件的内容进行查询？\n我们的内存是有限的，按照数组的方式进行查询，一次只能加载一部分。如果可用的内存大小只有1G，有可能需要加载9000次，太慢了。\n\n如果简历以身份证号为关键码，我们**只需要在内存中加载它们的身份证号**和**其简历对应的文件指针**即可。这就是文件索引。\n\n再结合搜索算法，如果要高效地搜索，如二分查找，则需要对关键码进行排序。\n\n文件在磁盘中可以不按身份证号排序。\n\n如果想要创建新的简历，那么关键码需要插入已有的关键码中。\n\n这时候关键码的数据结构就会影响到效率。\n\n如果是用数组存储，虽然读取上很搞效，但插入、删除时间复杂度为O(n)。\n如果是用链表存储，虽然插入、删除很高效，但读取上就很慢。\n这种静态的存储方式不行。\n\n如果是树形存储，如红黑树存储，虽然可以较好地平衡查询、修改的时间复杂度，但是每一个节点都是malloc申请的堆上内存，根据计算机的存储体系结构，会导致其节点地址在内存结构中呈碎片化，不利于缓存的命中，效率依然不够高。\n**节点在内存中碎片化的影响是会触发内存的缺页中断，需要换页，换页会触发读取磁盘IO，消耗时间**。\n\n可以考虑两种方案：\n1. 哈希表。\n2. 300阶B树。红黑树本质上是一个4阶B树，其每一个节点最多存储3个索引。而300阶B树则可以让节点存储更多连续的数据。尽量让这个数据块的大小正好是内存的页大小（4KB）。提高了内存、缓存命中率。\n## AVL树和B树存储索引的对比（假设索引全部加载到内存中）\n假如, 目前有1千万个索引要从磁盘中进行读取并且进行搜索。\n对于AVL树，每一个节点只能对应 1 个索引元素（关键码）。\n对于B树，每一个节点可以容纳$m-1$个索引元素（关键码）。\n\n假设我们有一个300阶B树。（300阶是综合考虑一个B树节点大小约为4KB的情况，更有效地防止跨磁盘块）\n那么，1千万个索引构建到B树中，只需要3层。而AVL树需要24层。\n相当于，二分查找一个索引，B树只需要访问3个节点，而AVL树可能需要访问24个节点（最差情况）。\n\n| 参数                               | AVL的高度                      | 300阶B树的高度                      |\n| -------------------------------- | --------------------------- | ------------------------------ |\n| 10,000,000个索引元素($n=1\\times10^7$) | $\\lceil\\log_2 n\\rceil = 24$ | $\\lceil\\log_{300} n\\rceil = 3$ |\n### 如果索引可以全部加载到内存中\n1. ​**索引的搜索过程在内存中完成**：\n    无论是AVL树还是B树，查找目标索引的路径（从根节点到叶子节点）全部在内存中进行，**不涉及磁盘IO**。只有最后根据文件指针读取实际文件时才会触发磁盘IO。\n2. ​**文件读取的磁盘IO次数**：1次\n    找到目标索引后，需通过文件指针从磁盘读取对应的实际文件。无论索引结构层数多少，**仅需1次磁盘IO**​（读取目标文件）。\n### 实际数据库中，索引可能远大于内存容量\n- ​大规模数据索引无法完全放入内存\n    - 实际数据库中，索引可能远大于内存容量。B树通过多级节点将热点数据保留在内存（如根节点常驻内存），冷数据存储在磁盘，**减少内存压力**。 \n    - 红黑树/AVL树：若索引无法全放入内存，每次访问深层节点都可能触发磁盘I/O，性能急剧下降。\n- ​写操作的磁盘友好性\n    - 对于读取操作，无所谓。但是对于修改操作，那么如果插入、删除一条数据记录，就会让树结构进行调整。​\n    - B树的节点分裂/合并操作是 ​**局部性修改**​（仅影响相邻节点），适合批量写入磁盘；\n    - 而红黑树/AVL树的旋转操作可能导致 ​**全局结构调整**，产生更多随机I/O。\n# 总结（⭐）\n文件索引管理最主要的 2 个问题：\n1. 更快的搜索算法（索引的关键码）\n    1. 对于搜索算法倒是没什么差异，AVL树和B树同样都是二分查找的分治策略, 时间复杂度都为$O(\\log n)$。\n2. 更少的磁盘IO、更低的内存缺页率\n    1. 对于树的层数来说，AVL树和B树是有很大差异的。\n    2. 若索引太庞大，**最差情况下**必须每次从磁盘中读取：（看路径层数，层低有优势）\n        1. **树的层高**，会直接影响到在**最差情况**下的**磁盘I/O次数**。\n        2. 因为每次访问一个节点时，都需要将磁盘块（Block）加载到内存中。（最差情况下，索引分布在不同磁盘块中）\n        3. 300阶B树刚好把一个最大节点的大小接近4KB即页大小。一个节点对应着1页，若索引相邻，则利用局部性原理提效。\n    3. 若索引可以从磁盘一次性加载到内存中：（看节点一次性能容纳索引的数量，容纳越多越有优势）\n        1. 一个节点能容纳的索引数量，决定了索引在内存中的分散度。\n        2. 如果节点内存地址太分散（像红黑树，只能存3个索引），可能会面临更高的**内存缺页中断**率。**间接影响了磁盘I/O次数**。\n3. 总之，无论索引能不能一次性载入内存，B树都占有优势，**集合了层低、节点容量大**的优势。\n    1. 层数少，避免了磁盘IO次数。\n    2. 节点容量大，避免了内存缺页。\n# B+树，B树的改进\nB+树可以看作是B树的优化，比 B 树更适合实际应用中的索引。目前现代关系型数据库最广泛的支持索引结构就是 B+ 树。\n\n总之：B+树明确分出`leaf`/`internal`节点， 让`internal`只存`key`，只有`leaf`存全部的索引信息。\n（`B∗`树则是节点满的时候先不拆分而是尽可能合并到邻居节点）\n\n![](../../images/高级数据结构_B树家庭/image-20250305071843256.png)\n\nB+树与B树差异的点，主要是以下这几点：\n1. 非叶子节点只会存放关键码，不存储实际数据。\n2. 叶子节点才会存放实际数据。\n3. 全部的信息都会在叶子节点出现。\n4. 非叶子节点存储的关键码是每个子节点中的最小值。\n5. 叶子节点之间构成一个有序链表。\n\n## 相比B树的优势\n1. 数据量相同的情况下，B+树的非叶子节点数据密度更大，存储效率高。B+树的非叶子节点可以存放更多的关键码，因此B+树可以比B树更「矮胖」，查询底层节点的磁盘IO次数会更少。\n2. **查询更稳定**，由于非叶结点并不是最终指向文件内容的结点，任何关键字的查找必须走一条从根结点到叶子结点的路。**所有关键字查询的路径长度相同**，导致每一个数据的查询效率相当。\n3. B+树的叶子节点通过指针形成有序链表，**范围查询（如`WHERE id BETWEEN 100 AND 200`）只需遍历叶子节点**，避免了回溯到上层节点。 \n\n例子：假设磁盘中的一个盘块可容纳 16 B，而一个关键字大小 2 B。一个关键字具体信息指针大小 2 B。\n一棵9阶B树（一个结点最多 8 个关键字）的内部结点需要 2 个盘块。而B+树内部结点只需要 1 个盘块。当需要把内部结点读入内存中的时候，B树就比B+树多一次盘块查找时间（在磁盘中就是盘片旋转的时间）。","categories":["高级数据结构","树","数据库","MySQL"]},{"title":"量化交易","url":"/量化交易/量化交易/","content":"# 衍生产品交易所\n在衍生产品交易所市场中，大家所交易的是经过交易所标准化之后的衍生产品。\n\n衍生产品交易所历史：为了将农场主和商人联系起来，芝加哥期货交易所（CBOT）于 1848 年成立。CBOT主要职能是将交易的谷物进行数量和质量标准化。\n\n几年后，CBOT首先开发了期货类合约，\n# 技术交易\n\n# 量化交易\n量化交易，在学术上指利用现代统计学、数学算法、计算机技术，进行交易的证券投资方式。从庞大的历史数据中筛选可能带来超额收益的，用多种大概率事件的方式来制定策略。用数量模型来检验、固化这些策略，再严格地执行这些策略，从而指导投资。目的是获得可持续的、稳定的、高于平均收益的超额回报。\n量化交易的概念很广，本质上和程序化并无关系，因为它只是在历史中进行分析，分析的结果在程序化交易之前就会完成，换句话说，完全可以依赖纸和笔计算。因此量化交易只是一种思想，不必须是自动化交易。\n# 高频交易\n高频交易是量化投资领域的一个流派。字面上的高频，指每次交易从开仓到平仓只有很短的时间，一般从几分钟到几微秒。有的时候为了试探（反复挂单、撤单），还会更快，到纳秒级别。\n高频交易主要依赖市场的价格波动获利。高频交易以外的，多依赖“趋势”获利。依赖市场的波动，就决定了其需要程序化。\n\n","categories":["量化交易"]},{"title":"存储卡（TF卡或Micro SD卡）","url":"/标准规格笔记/存储卡（TF卡或Micro SD卡）/","content":"# 结构\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221002138663.png)\n主要由主控和NAND闪存颗粒组成。Micro SD卡常用于游戏机、无人机、行车记录仪、Switch等紧凑的电子设备中。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003017314.png)\n除了小卡，还有大号的标准SD卡，常用于数码相机、声卡、采集卡。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003034976.png)\nMicro SD卡可以通过卡套转接为标准SD卡。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221002721445.png)\n但是：1、影响散热；2、可能会接触不良，较不稳定。\n## 行业SD卡\n影视行业中规格更高的卡：\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003110610.png)\n\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003123308.png)\n\nCFe-A卡使用了PCIe总线作为数据传输，读写速度往往可达700 MB/s到800 MB/s。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003416279.png)\n\nCFe-A卡也可以通过卡套转接为CFe-B卡。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003458137.png)\n\n# 性能指标\n主要看读写速度。读写速度又可分为顺序读写、随机读写。\n顺序读写常见于视频录制、编辑；随机读写常见系统和软件（如游戏）的运行过程。\n## 最低顺序写入速度\n很多卡在相机录制过程中会中断，这时与“最低顺序写入速度”有关。存储卡的各个协会将之作为带圈的数字标识在了卡面。有C系列、U系列、V系列。还有CFe卡的VPG标识。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221004333952.png)\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221004455543.png)\n# 卡面标识\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003815716.png)\n\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003823652.png)\n\n如果卡面上只标注了一个数据，一般指顺序读取速度，大概率是理想的峰值速度，实际使用时难以达到。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221003848629.png)\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221004616029.png)\n大多数消费者只需要关注接口的规格和协议能否和设备匹配。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221004801407.png)\nUHS-I一般比UHS-II慢。如果设备只支持UHS-I的卡槽，则使用UHS-II的卡会限制其发挥。\n## A1和A2的区别\n存储卡的A1（App Performance A1）和A2（App Performance A2）是SD卡协会制定的**应用性能等级标准**，主要针对在移动设备（如智能手机、平板电脑）上运行应用程序时的性能需求。两者的核心区别在于**随机读写速度**和**性能优化**。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221010103228.png)\n# 读卡器\n一般只有搭配官方的读卡器才能达到预期速度，使用相机、第三方读卡器会导致速度偏低。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221004006007.png)\n\n# 测速\n多用CDM软件测速。\n# 安全性\n最好在产品详情中关注其工作环境限制。\n![](../../images/存储卡（TF卡或Micro%20SD卡）/image-20250221005056093.png)\n\n","categories":["标准规格"]},{"title":"电影厅放映技术规格","url":"/标准规格笔记/电影厅放映技术规格/","content":"# 对比图\n![](../../images/电影厅放映技术规格/image-20250221160754091.png)\n【全球 IMAX 及其他影厅数据】链接：https://docs.qq.com/sheet/DQ3FEUUZJdklNSWJP?tab=240rc1\n# 总结\n优选IMAX GT（中国只有北京电影博物馆一家商业开放的）。\n次选CINITY、杜比影院。\n次之IMAX CoLa（Commercial Laser）、中国巨幕CGS。\nIMAX XT虽然是激光但是减配。\n没有标注激光的普通IMAX就是数字IMAX Xenon（氙灯）。","categories":["标准规格"]},{"title":"算法_回溯","url":"/算法/算法_回溯/","content":"# 内容\n1. 子集树\n2. 排列树\n# 生成子集树\n子集树可以用来解决从集合中挑选一些元素以达到一定条件的问题。\n```cpp\nvoid func(int arr[], int length, int x[])\n{\n    if (i == length)\n    {\n        for (int j = 0; j < length; ++j)\n        {\n            if (x[j] == 1)\n            {\n                std::cout << arr[j] << \" \";\n            }\n        }\n        std::cout << std::endl;\n    }\n    else\n    {\n        x[i] = 1;\n        func(arr, i + 1, length, x);\n        x[i] = 0;\n        func(arr, i + 1, length, x);\n    }\n}\n```\n另一种形式：\n```cpp\nvoid func(int arr[], int i, int length, int x[])\n{\n    if (i == length)\n    {\n        for (int j = 0; j < length; ++j)\n        {\n            if (x[j] == 1)\n            {\n                std::cout << arr[j] << \" \";\n            }\n        }\n        std::cout << std::endl;\n    }\n    else\n    {\n        // another form\n        for (int k = 1; k >= 0; --k)\n        {\n            x[i] = k;\n            func(arr, i + 1, length, x);\n        }\n    }\n}\n```\n但是这一种形式不太利于直接添加剪支操作。\n![](../../images/算法_回溯/image-20241126164920385.png)\n# 选数字，达到给定和\n剪左支的条件：选择第`i`数时，当前累计和已经超过了`given_sum`，则没必要再往下进行。\n剪右支的条件：选择第`i`数时，剩下的`i + 1`到`n`的累计和（即剩余未处理的数的和，注意，不是”未选择“，而是”未处理“，”处理“是层级别的概念，”选择“是左右子树概念）`rest`加上当前累计和不够`given_sum`，则没必要往下进行。\n```cpp\n// 挑选数字：有一组整数，请挑选出一组数字，使它们的和等于指定的值\n#include<iostream>\n#include<vector>\nint arr[] = { 4,8,12,16,7,9,3 };\nint given_sum = 18;\nint res = 0;\nstd::vector<int> aux;\nbool func(int* arr, int i, int length)\n{\n    bool have = false;\n\n    if (i == length)\n    {\n        if(res == given_sum)\n        {\n            for (int v : aux)\n            {\n                std::cout << v << \" \";\n            }\n            std::cout << std::endl;\n            have = true;\n        }\n    }\n    else\n    {\n        if (res + arr[i] <= given_sum)\n        {\n            res += arr[i];\n            aux.push_back(arr[i]);\n            return func(arr, i + 1, length);\n\n            res -= arr[i];\n            aux.pop_back();\n        }\n        int rest = 0;\n        for (int j = i + 1; j < length; ++j)\n        {\n            rest += arr[j];\n        }\n        if (res + rest >= given_sum)\n        {\n            return func(arr, i + 1, length);\n        }\n    }\n    return have;\n}\nint main()\n{\n    bool have = func(arr, 0, sizeof(arr) / sizeof(arr[0]));\n    if (!have)\n    {\n        std::cout << \"have not resolution.\" << std::endl;\n    }\n}\n```\n更好的写法：在main函数中先给出rest的总值。在处理第`i + 1`层前，减去第`i`个数。处理完第`i + 1`层后，即开始回溯到`i`，则`i`层又活了，需要加回第`i`个数。\n这样的写法，可以避免每次计算剪右支条件都要走一遍循环计算剩余数字（`i + 1`到`n`）的和，而替换成每次只需简单地减、加一个`arr[i]`。\n```cpp\n// 挑选数字：有一组整数，请挑选出一组数字，使它们的和等于指定的值\n#include<iostream>\n#include<vector>\nint arr[] = { 4,8,12,16,7,9,3 };\nint given_sum = 18;\nint res = 0;\nint rest = 0;\n\nstd::vector<int> aux;\nbool func(int* arr, int i, int length)\n{\n    bool have = false;\n\n    if (i == length)\n    {\n        if(res == given_sum)\n        {\n            for (int v : aux)\n            {\n                std::cout << v << \" \";\n            }\n            std::cout << std::endl;\n            have = true;\n        }\n    }\n    else\n    {\n        rest -= arr[i];\n        if (res + arr[i] <= given_sum)\n        {\n            res += arr[i];\n            aux.push_back(arr[i]);\n            return func(arr, i + 1, length);\n\n            res -= arr[i];\n            aux.pop_back();\n        }\n        \n        if (res + rest >= given_sum)\n        {\n            return func(arr, i + 1, length);\n        }\n        rest += arr[i];\n    }\n    return have;\n}\nint main()\n{\n    for (int v : arr)\n    {\n        rest += v;\n    }\n\n\n    bool have = func(arr, 0, sizeof(arr) / sizeof(arr[0]));\n    if (!have)\n    {\n        std::cout << \"have not resolution.\" << std::endl;\n    }\n}\n```\n同时还需要注意，未处理和未选择的概念不要混淆，我第一次写成了如下形式：这是错误的。\n```cpp\n    // ...\n    else\n    {\n        if (res + arr[i] <= given_sum)\n        {\n            res += arr[i];\n            rest -= arr[i];   // 选择\n            aux.push_back(arr[i]);\n            return func(arr, i + 1, length);\n\n            res -= arr[i];\n            rest += arr[i];   // 未选择\n            aux.pop_back();\n        }\n        \n        if (res + rest >= given_sum)\n        {\n            return func(arr, i + 1, length);\n        }\n    }\n    return have;\n}\nint main()\n{\n    for (int v : arr)\n    {\n        rest += v;\n    }\n    // ...\n}\n```\n这与上面的含义完全不一样。我们要做的是”处理“、”未处理“时，rest变量的变化。而不是”选择“、”未选择“时，rest变量的变化。”处理“是层级别的概念，”选择“是左右子树概念。\n即，不管选不选，走不走左右子树，rest都要在之前减去`arr[i]`；不管选不选，走不走左右子树，之后rest都要加上`arr[i]`。\n## 多叉子集树-更高效\n以下程序生成的是如下图的子集树：\n![](../../images/算法_回溯/image-20241126164737080.png)\n\n```cpp\n#include<iostream>\n#include<vector>\nint arr[] = { 4,8,12,16,7,9,3 };\nint given_sum = 18;\nint res = 0;\nint rest = 0;\n\nstd::vector<int> aux;\nvoid func(int i, int length, int number)\n{\n    if (number == 0)\n    {\n        for (int v : aux)\n        {\n            std::cout << v << \" \";\n        }\n        std::cout << std::endl;\n    }\n    else\n    {\n        // 以层的视角看，生成(k, k+1, ..., n)子树并遍历。\n        for (int k = i; k < length; ++k)\n        {\n            if (number >= arr[k]) // 接下来的k元素不能大于number\n            {\n                aux.push_back(arr[k]);\n                // 选择 k + 1，则向深度遍历，number条件改变\n                func(k + 1, length, number - arr[k]);\n\n                // 不选择 k + 1，则回溯到上一层，number条件不改变\n                aux.pop_back();\n            }\n        }\n    }\n}\nint main()\n{\n    func(0, 7, given_sum);\n    return 0;\n}\n```\n输出：8 7 3\n## 变种：可以重复选择元素\n```cpp\n    // ...\n    else\n    {\n        // 以层的视角看，生成(k, k+1, ..., n)子树并遍历。\n        for (int k = i; k < length; ++k)\n        {\n            if (number >= arr[k]) // 接下来的k元素不能大于number\n            {\n                aux.push_back(arr[k]);\n                // 更改：\n                // 选择 k，则向深度遍历，number条件改变\n                func(k, length, number - arr[k]);\n\n                // 不选择 k，则回溯到上一层，number条件不改变\n                aux.pop_back();\n            }\n        }\n    }\n}\nint main()\n{\n    func(0, 7, given_sum);\n    return 0;\n}\n```\n输出\n```\n4 4 4 3 3\n4 4 7 3\n4 8 3 3\n4 7 7\n8 7 3\n12 3 3\n9 9\n9 3 3 3\n3 3 3 3 3 3\n```\n# 排列树\n序列有不同的排列方式，求解原始序列的某一种特定的排列方式以达到一定条件的问题。\n\n排列问题可以表示为以下形式：\n设$R=\\{ r_1, r_2, r_3, \\cdots, r_n \\}$是要进行排列的$n$个元素，$R_i=R-\\{r_i\\}$。\n集合$X$中元素的全排列记为$perm(X)$。$(r_i)perm(X)$表示在全排列$perm(X)$的每一个排列前加上前缀$r_i$得到的排列。\n$R$的全排列可归纳定义如下：\n- 当$n=1$时，$perm(R)=(r)$，其中$r$是集合$R$中唯一的元素\n- 当$n>1$时，$perm(R)$由$(r_1)perm(R_1),(r_2)perm(R_2),\\cdots,(r_n)perm(R_n)$构成。（$R_i=R-\\{r_i\\}$）\n\n比如：$R=\\{1,2,3\\}$，则$perm(R)$由$(1)perm(\\{2,3\\}),(2)perm(\\{1,3\\}),(3)perm(\\{1,2\\})$构成。\n\n在第i层视角上，集合内每个元素都依次与第i个位置进行交换。如下图：元素1到了第1的位置，则出现：`(1)R{2,3}`，元素2到了第1的位置，则出现：`(2)R{1,3}`，元素3到了第1的位置，则出现：`(3)R{1,2}`。\n\n![](../../images/算法_回溯/image-20241128231648914.png)\n\n于是，在代码中，我们可以写出for循环的条件：第i层时，（以下表述均对应实际元素数组的下标，例如：第0层，对应第1个元素的位置，下标为0），就要把从`k`（用`k`作为`i`的副本）到`n-1`的元素循环与第`i`个位置进行交换。\n\n交换后再次进行perm计算，下一次的`i`更新为`i+1`。\n\n从层次视角看，本层的`perm`调用结束后，不要忘记把状态回退，即第`k`个元素换回`i`位置。\n\n当到达第`n`层，达到递归终止条件，这时`arr`数组中记录的各个元素的位置即为此时序列的某种全排列。直接全部输出即可。\n```cpp\n#include<iostream>\nvoid swap(int* arr, int i, int j)\n{\n    int tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\nvoid func(int* arr, int i, int length)\n{\n    if (i == length)\n    {\n        for (int j = 0; j < length; ++j)\n        {\n            std::cout << arr[j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    else\n    {\n        // 生成子树，遍历孩子节点\n        for (int k = i; k < length; ++k)\n        {\n            // 从 i 到 n，每次arr数组元素的该位置 都与 k 位置交换一下\n            swap(arr, i, k);\n            // 注意此处很重要，不再是k + 1，而是i + 1。\n            // 如果我们搞成了k + 1，则变成了上面的多叉子集树（选数字问题）。\n            // 因为给出了i+1，for循环中k在变，i是不变的，所以每次都会是相同数个元素进行遍历。\n            // 因此才能出现排列方式不同的全集（即全排列）。\n            func(arr, i + 1, length);\n            swap(arr, i, k);\n        }\n    }\n}\nint main()\n{\n    int arr[] = { 1, 2, 3, 4 };\n    const int length = sizeof(arr) / sizeof(arr[0]);\n    func(arr, 0, length);\n}\n```\n输出\n```\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 3 2\n1 4 2 3\n2 1 3 4\n2 1 4 3\n2 3 1 4\n2 3 4 1\n2 4 3 1\n2 4 1 3\n3 2 1 4\n3 2 4 1\n3 1 2 4\n3 1 4 2\n3 4 1 2\n3 4 2 1\n4 2 3 1\n4 2 1 3\n4 3 2 1\n4 3 1 2\n4 1 3 2\n4 1 2 3\n\n```\n# n皇后问题（n后、八皇后）\n在$n\\times n$格的国际象棋棋盘上放置彼此不受攻击的$n$个皇后。皇后可以攻击同一行、同一列或同一斜线上的棋子。\n\n## 非递归\n```cpp\nvoid NiceBackTrack()\n{\n    x[1] = 0;\n    int k = 1;\n    while (k >= 1)\n    {\n        x[k] += 1;\n        while ((x[k]) <= n) && !Place(k))\n        {\n            x[k] += 1;\n        }\n        if (x[k] <= n)\n        {\n            if (k == n)\n            {\n                sum += 1;\n                PrintQ();\n            }\n            else\n            {\n                k += 1;\n                x[k] = 0;\n            }\n        }\n        else\n        {\n            --k;\n        }\n    }\n}\n```","categories":["算法","回溯"]},{"title":"网络_自建远程桌面服务器","url":"/网络/网络_自建远程桌面服务器/","content":"# 云服务器选购\n阿里云2C2G3M（2 CPU、2G RAM、3M固定带宽（无限流量）），1年99元。选北京地区的，在国内延迟可能低一些。\n# 软件选择\n远程桌面软件选择RustDesk，开源的。\nserver端：\nhttps://github.com/rustdesk/rustdesk-server/releases\nclient端：\nhttps://github.com/rustdesk/rustdesk/releases\n# RustDesk下载\n根据[RustDesk官方文档](https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/install/)。\n服务端的文件有：两个可执行文件和一个文件夹。\n\n- `hbbs` - RustDesk ID/Rendezvous server\n- `hbbr` - RustDesk Relay server\n\n一般，下载这个：\nhttps://github.com/rustdesk/rustdesk-server/releases/download/1.1.12/rustdesk-server-linux-amd64.zip\n\n使用`wget + url`命令即可下载。\n\n# 代理\n\nLinux服务器要下载好多开源项目或者国际软件。往往需要代理网络。\n\n云服务器只有Linux命令行，因此需要下载mihomo项目（Clash Meta）来用命令行配置。\nhttps://github.com/MetaCubeX/mihomo/releases\n下载其中的：\nhttps://github.com/MetaCubeX/mihomo/releases/download/v1.18.10/mihomo-linux-amd64-v1.18.10.deb\n是deb格式的安装包。可以使用`apt install + 文件名`安装这种离线安装包。\n\n安装后，可以通过`find / -name mihomo`来查找服务器上名字包含mihomo的文件在哪里。\n```\n/root/.config/mihomo\n/etc/mihomo\n/usr/share/licenses/mihomo\n/usr/bin/mihomo\n```\n\n`/root/.config/mihomo/`是mihomo的配置文件目录。\n有以下内容：\n`config.yaml   geoip.metadb`\n\n`/etc/mihomo/`也是mihomo的一个配置文件目录，但是貌似优先用的是root的（即当前用户的配置优于etc目录下的全局配置）\n\n## 守护进程\n安装后，需要把mihomo作为一个守护进程跑在服务器上。\n参考文档：\nhttps://wiki.metacubex.one/en/startup/service/\n如下创建系统配置文件 `/etc/systemd/system/mihomo.service`\n```\n[Unit]\nDescription=mihomo Daemon, Another Clash Kernel.\nAfter=network.target NetworkManager.service systemd-networkd.service iwd.service\n\n[Service]\nType=simple\nLimitNPROC=500\nLimitNOFILE=1000000\nCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE\nAmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE\nRestart=always\nExecStartPre=/usr/bin/sleep 1s\nExecStart=/usr/local/bin/mihomo -d /etc/mihomo\nExecReload=/bin/kill -HUP $MAINPID\n\n[Install]\nWantedBy=multi-user.target\n```\n\n使用以下命令重新加载 systemd：\n`systemctl daemon-reload`\n启用Mihomo服务：\n`systemctl enable mihomo`\n使用以下命令立即启动 Mihomo：\n`systemctl start mihomo`\n使用以下命令重新加载 Mihomo：\n`systemctl reload mihomo`\n使用以下命令检查 Mihomo 的状态：\n`systemctl status mihomo`\n使用以下命令查看Mihomo的运行日志：\n`journalctl -u mihomo -o cat -e`或者`journalctl -u mihomo -o cat -f`\n## 配置文件\n`wget + 代理服务商的clash订阅链接`下载`config.yaml`到Linux服务器上。然后把`config.yaml`拷贝到mihomo配置目录下。\n如果配置目录不对劲，可以通过`mihomo -d [配置目录]`指定、自定义。\n## 终端自动代理\n需要配置`/etc/profile`。\n在内容中加入：\n```bash\nexport http_proxy=127.0.0.1:7890\nexport https_proxy=127.0.0.1:7890\nexport all_proxy=127.0.0.1:7890\n```\n## 测试连通\n`curl www.google.com`，如果输出了内容，则可以了。\n## UI控制\n可以配置`config.yaml`中的：\n```yaml\nexternal-controller: '0.0.0.0:9090'\n# RESTful API 的口令\nsecret: 'YourPassword'\n\n# 您可以将静态网页资源（如 clash-dashboard）放置在一个目录中，clash 将会服务于 `RESTful API/ui`\n# 参数应填写配置目录的相对路径或绝对路径。\nexternal-ui: ./public\n```\n如果要绑定到公网IP，需要把默认的`127.0.0.1`改为`0.0.0.0`。\n如果对外网开放，强烈建议需要secret鉴权。\n我们还需要提供一个UI的web目录。\n以选用yacd为例。\nhttps://github.com/haishanh/yacd/releases\n下载`yacd.tar.xz`。解压操作略。\n然后我们在配置目录下创建一个public，在public里创建yacd。把内容移动到yacd下面。\n然后，就可以通过`http://YourIP:9090/ui/yacd/?hostname=YourIP&port=9090&secret=YourSecret`进入UI界面了。\n# Node.js安装\n\nhttps://pm2.keymetrics.io/docs/usage/quick-start/\n\nrustdesk官方建议我们使用pm2管理服务。\n\n而pm2需要npm安装，即需要安装`Node.js`。\nNode.js的安装又需要用到NVM。\n根据：\nhttps://nodejs.org/en/download/package-manager\n\n```bash\n# installs nvm (Node Version Manager)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash\n# download and install Node.js (you may need to restart the terminal)\nnvm install 22\n# verifies the right Node.js version is in the environment\nnode -v # should print `v22.11.0`\n# verifies the right npm version is in the environment\nnpm -v # should print `10.9.0`\n```\n## sudo npm install命令无效\n但是我们之后发现pm2的安装需要`sudo npm install`权限。\n\n但提示：`sudo npm install command not found`\n\n根据\nhttps://stackoverflow.com/a/73308302/16887299\n\n```bash\nsudo ln -s $(which npm) /usr/local/bin/npm\nsudo ln -s $(which node) /usr/local/bin/node\n```\n即可解决。\n主要原因是按照node.js官方的安装方法，他们给我们安到了：`/root/.nvm/versions/node/v22.11.0/bin/node`、`/root/.nvm/versions/node/v22.11.0/bin/npm`。\n所以sudo命令不识别。\n## npm设置代理\n同时发现需要给npm单独配置代理。终端的代理无效。\n`npm config set proxy http://127.0.0.1:7890`\n设置好后，可以通过`npm config list`查看proxy字段是否正确。\n\n至此，就可以安装pm2了。\n# pm2安装\n```bash\nsudo npm install pm2@latest -g\n```\n安装完成后，则可以按照rustdesk文档中用pm2来启动服务。\n```bash\npm2 start hbbs\npm2 start hbbr\n```\n可以通过`pm2 list`来查看当前pm2管理的服务。\n如果想让`hbbs` / `hbbr`在重启后自动运行，最好再执行一下`pm2 startup`和`pm2 save`。（详细查阅pm2文档）\n\n至此，rustdesk服务就运行在服务器上了。\n# rustdesk的key\n服务一运行，会自动生成一对加密的私钥和公钥（分别位于运行目录下的`id_ed25519`和`id_ed25519.pub`文件中），其主要用途是通信加密。\n\n这个`id_ed25519.pub`文件的内容需要填写到客户端的key中。\n\n如果要更改密钥，请删除`id_ed25519`和`id_ed25519.pub`文件并重新启动`hbbs` / `hbbr` ， `hbbs`将生成新的密钥对。\n# 云服务器防火墙配置\n根据文档，默认情况下， hbbs监听 21114（TCP，用于 Web 控制台，仅在 Pro 版本中可用）、21115 (TCP)、21116 (TCP/UDP) 和 21118 (TCP)， hbbr监听 21117 (TCP) 和 21119 (TCP) 。请务必在防火墙中打开这些端口。请注意，应为 TCP 和 UDP 启用 21116。 21115用于NAT类型测试，21116/UDP用于ID注册和心跳服务，21116/TCP用于TCP打洞和连接服务，21117用于Relay服务，21118和21119用于支持网络客户端。如果不需要Web客户端（21118、21119）支持，可以禁用相应端口。\n\n设置成如下的即可：\n![](../../images/网络_自建远程桌面服务器/image-20241123235654198.png)\n\n22是为了ssh协议（远程shell）。\n## 坑：不要贸然开放所有端口\n不要贸然开放所有端口，经过测试，服务器会莫名遭到DDoS攻击，导致CPU、带宽高占用，服务器连接数峰值达到10K，对于2C2G3M的服务器来说，肯定禁不住。导致ssh经常断联、无响应；远程桌面也很卡顿。\n还好分析了一眼阿里云后台的监控数据，不然我以为是网络带宽太小的问题。其实就是端口全开放导致攻击漏洞太大的问题。（也算是亲自体验过DDoS攻击了，这才知道了防火墙的作用有多么重要，自此不再是累赘）\n# rustdesk客户端配置\n设置-网络中。\n![](../../images/网络_自建远程桌面服务器/image-20241123235810792.png)\n\nID服务器IP+21116端口，中继服务器IP+21117端口。\n\n启动服务，若主页下面图标显示就绪，即可以使用。","categories":["网络"]},{"title":"Windows_网络模型","url":"/Windows/Windows_网络模型/","content":"# 异步选择模型\n这里的异步修饰的是等待、选择，指的不是同时通信，而是同时等待。一个线程可以同时监控多个对象。但是只是监控SOCKET的活动，具体业务还是需要程序员完善（比如某个socket有数据只是返回通知一下，不会主动帮你读）。\n具体的实现方法，根据操作系统的实现，有轮询方法，软中断方法（有数据时发信号），有利于节省系统资源。\nWindows中的异步选择模型有：\n1. Select：在类Unix系统下，几乎都用的这个，Berkeley Socket\n2. WSAAsyncSelect\n3. WSAEventSelect\n## 异步通信模型\n上面讨论的是异步选择模型，此处的功能更强大了，叫做异步通信模型，意思是一个线程不仅可以同时监控多个连接，还可以处理通信业务（比如某个socket有数据，会主动帮你读，通过系统内部的线程或中断，自动填入你之前给它的缓冲区。等到它通知你时，读写已经处理完毕）。\n# WSAAsyncSelect\n[WSAAsyncSelect function (winsock.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsaasyncselect)\n函数原型：\n![](../../images/Windows_网络模型/image-20241011082306440.png)\n1. 参数1：Socket，需要监控哪个socket\n2. 参数2：窗口句柄，用于标识在发生网络事件时将接收消息的窗口。\n3. 参数3：发生网络事件时要接收的消息类型（投送到消息队列的消息类型）。\n4. 参数4：指定对哪个或哪些网络事件感兴趣，用位掩码表示。\n5. 返回值：成功返回0，失败时返回`SOCKET_ERROR`，可以通过调用WSAGetLastError来检索错误号。\n## 创建项目\n由于WSAAsyncSelect需要消息循环，需要创建一个`Windows Desktop Wizard`项目，取名为`WSAAsyncSelectModel`，选择Application Type为Desktop Application (.exe)，Additional Options选择Empty Project。\n新建源文件`wsa_async_select.cpp`。\n代码拷贝Element Studio中的Spawn中Most Used中的Message Loop的代码。\n同时在main函数前部贴入`file_server.cpp`中从初始化到建立`listen_sock`的代码。\n\n需要注意，`#pragma comment(lib, \"Ws2_32.lib\")`别忘了复制过去，否则会报以下的错误：\n（最后，别忘记在wWinMain函数return的前一句`WSACleanup()`）\n```\nBuild started at 8:10 AM...\n1>------ Build started: Project: WSAAsyncSelectModel, Configuration: Debug x64 ------\n1>wsa_async_select.cpp\n1>C:\\Users\\mrcan\\source\\repos\\MetaLearning\\WSAAsyncSelectModel\\wsa_async_select.cpp(68,15): warning C4244: 'return': conversion from 'WPARAM' to 'int', possible loss of data\n1>wsa_async_select.obj : error LNK2019: unresolved external symbol __imp_socket referenced in function wWinMain\n1>wsa_async_select.obj : error LNK2019: unresolved external symbol __imp_WSAStartup referenced in function wWinMain\n1>wsa_async_select.obj : error LNK2019: unresolved external symbol __imp_WSAGetLastError referenced in function wWinMain\n1>wsa_async_select.obj : error LNK2019: unresolved external symbol __imp_WSAAsyncSelect referenced in function wWinMain\n1>C:\\Users\\mrcan\\source\\repos\\MetaLearning\\x64\\Debug\\WSAAsyncSelectModel.exe : fatal error LNK1120: 4 unresolved externals\n1>Done building project \"WSAAsyncSelectModel.vcxproj\" -- FAILED.\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n========== Build completed at 8:10 AM and took 00.582 seconds ==========\n```\n编译失败的原因是链接器无法找到 WinSock 库中的相关函数定义。WinSock 函数如 `socket()`、`WSAStartup()`、`WSAGetLastError()` 和 `WSAAsyncSelect()` 都在 `Ws2_32.lib` 中定义，因此需要在项目中显式地链接该库。\n## 注意（非阻塞模式）\nWSAAsyncSelect函数自动将套接字s设置为非阻塞模式，而不考虑`lEvent`的值。要将套接字s设置回阻塞模式，首先必须通过调用`将lEvent设置为零的WSAAsyncSelect`来清除与套接字s关联的事件记录。然后可以调用`ioctlsocket`或`WSAIoctl`将套接字设置为阻塞模式。\n[ioctlsocket function (winsock.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-ioctlsocket)\n### ioctlsocket示例\n```cpp\n#include <winsock2.h>\n#include <stdio.h>\n#pragma comment(lib, \"Ws2_32.lib\")\nvoid main()\n{\n    //-------------------------\n    // Initialize Winsock\n    WSADATA wsaData;\n    int iResult;\n    u_long iMode = 0;\n\n    iResult = WSAStartup(MAKEWORD(2,2), &wsaData);\n    if (iResult != NO_ERROR)\n          printf(\"Error at WSAStartup()\\n\");\n    //-------------------------\n    // Create a SOCKET object.\n    SOCKET m_socket;\n    m_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (m_socket == INVALID_SOCKET)\n    {\n        printf(\"Error at socket(): %ld\\n\", WSAGetLastError());\n        WSACleanup();\n        return;\n    }\n    //-------------------------\n    // Set the socket I/O mode: In this case FIONBIO\n    // enables or disables the blocking mode for the \n    // socket based on the numerical value of iMode.\n    // If iMode = 0, blocking is enabled; \n    // If iMode != 0, non-blocking mode is enabled.\n\n    iResult = ioctlsocket(m_socket, FIONBIO, &iMode);\n    if (iResult != NO_ERROR)\n          printf(\"ioctlsocket failed with error: %ld\\n\", iResult);\n}\n```\n## 网络事件\nlEvent参数是通过使用下表中列出的任意值的按位OR运算符构造的。\n\n|Value|Meaning|\n|---|---|\n|**FD_READ**|Set to receive notification of readiness for reading.|\n|**FD_WRITE**|Wants to receive notification of readiness for writing.|\n|**FD_OOB**|Wants to receive notification of the arrival of OOB data.|\n|**FD_ACCEPT**|Wants to receive notification of incoming connections.|\n|**FD_CONNECT**|Wants to receive notification of completed connection or multipoint join operation.|\n|**FD_CLOSE**|Wants to receive notification of socket closure.|\n|**FD_QOS**|Wants to receive notification of socket Quality of Service (QoS) changes.|\n|**FD_GROUP_QOS**|Wants to receive notification of socket group Quality of Service (QoS) changes (reserved for future use with socket groups). Reserved.|\n|**FD_ROUTING_INTERFACE_CHANGE**|Wants to receive notification of routing interface changes for the specified destination(s).|\n|**FD_ADDRESS_LIST_CHANGE**|Wants to receive notification of local address list changes for the socket protocol family.|\n为套接字发出WSAAsyncSelect将取消这个套接字的任何先前的WSAAsyncSelect或WSAEventSelect。例如，要接收读写通知，应用程序必须使用FD_READ和FD_WRITE调用WSAAsyncSelect，如下所示\n```cpp\nrc = WSAAsyncSelect(s, hWnd, wMsg, FD_READ|FD_WRITE);\n```\n不能为不同的事件指定不同的消息。下面的代码将不起作用：第二个调用将取消第一个的效果，并且只有FD_WRITE事件将与消息wMsg2一起报告：\n```cpp\nrc = WSAAsyncSelect(s, hWnd, wMsg1, FD_READ);\nrc = WSAAsyncSelect(s, hWnd, wMsg2, FD_WRITE);\n```\n要取消所有通知，指示Windows套接字不应发送与套接字上的网络事件相关的其他消息，请将lEvent设置为零。\n```cpp\nrc = WSAAsyncSelect(s, hWnd, 0, 0);\n```\n## wWinMain代码\n把此函数放到窗口初始化、显示完毕和消息循环开始之间。\n```cpp\n// wsa_async_select.cpp\n#include <windows.h>\n#include <WinSock2.h>\n#include <WS2tcpip.h>\n#define MY_WMACCEPT WM_USER + 0x1\n\n// declarations\nLRESULT __stdcall WndProcdure(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);\n// function defines\nint __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPreInstance, wchar_t* lpCmdLine, int iCmdShow)\n{\n    // socket setting\n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = ::WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0) {\n        // 这是Window Application，不能调用cout或wcout，因为没有控制台。\n        //std::wcout << std::format(L\"WSAStartup failed with error : {}\\n\", err);\n        return 1;\n    }\n\n    SOCKET listen_sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (listen_sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    //service.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");\n    if (1 != ::inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    server_addr.sin_port = htons(9008);\n\n    if (SOCKET_ERROR == ::bind(listen_sock,\n        reinterpret_cast<const sockaddr*>(&server_addr),\n        sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    if (SOCKET_ERROR == ::listen(listen_sock, SOMAXCONN))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    // Window Initialization and Showing\n    wchar_t szAppName[] = L\"WinApp\";\n    WNDCLASSEX wcex = { 0 };\n    wcex.cbSize = sizeof(wcex);\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc = &WndProcdure;\n    wcex.cbClsExtra = 0;\n    wcex.cbWndExtra = 0;\n    wcex.hInstance = hInstance;\n    wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n    wcex.hCursor = LoadCursor(NULL, IDC_ARROW);\n    wcex.hbrBackground = (HBRUSH)(GetStockObject(WHITE_BRUSH));\n    wcex.lpszMenuName = NULL;\n    wcex.lpszClassName = szAppName;\n    wcex.hIconSm = wcex.hIcon;\n    if (!RegisterClassEx(&wcex))\n    {\n        return -1;\n    }\n    HWND hWnd = NULL;\n    hWnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, szAppName, L\"App\", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);\n    ShowWindow(hWnd, iCmdShow);\n    UpdateWindow(hWnd);\n\n    // Select\n    if (SOCKET_ERROR == ::WSAAsyncSelect(listen_sock, hWnd, MY_WMACCEPT, FD_ACCEPT))\n    {\n        err = ::WSAGetLastError();\n    }\n\n    // Message Loop\n    MSG msg;\n    while (GetMessage(&msg, NULL, 0, 0))\n    {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    ::WSACleanup();\n    return msg.wParam;\n}\n```\n先编译运行一下，发现提示：\n```\nBuild started at 8:16 AM...\n1>------ Build started: Project: WSAAsyncSelectModel, Configuration: Debug x64 ------\n1>wsa_async_select.cpp\n1>C:\\Users\\mrcan\\source\\repos\\MetaLearning\\WSAAsyncSelectModel\\wsa_async_select.cpp(68,15): warning C4244: 'return': conversion from 'WPARAM' to 'int', possible loss of data\n1>C:\\Users\\mrcan\\source\\repos\\MetaLearning\\WSAAsyncSelectModel\\wsa_async_select.cpp(57,27): error C4996: 'WSAAsyncSelect': Use WSAEventSelect() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings\n1>Done building project \"WSAAsyncSelectModel.vcxproj\" -- FAILED.\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n========== Build completed at 8:16 AM and took 00.538 seconds ==========\n```\nMS建议我们使用`WSAEventSelect()`作为代替，因为`WSAAsyncSelect`被废弃了，如果要使用，需要`define _WINSOCK_DEPRECATED_NO_WARNINGS`。可以右键项目，属性，`C/C++`，Preprocessor，下拉`Preprocessor Definitions`，选择`<Edit...>`。在输入文本框中已有内容的最下面写一行这串符号上去。\n![](../../images/Windows_网络模型/image-20241011081849722.png)\n![](../../images/Windows_网络模型/image-20241011081956658.png)\n## WndProcdure回调函数\n主要处理消息循环时，不同消息类型的处理，此处我们处理自定义消息类型`MY_WMACCEPT`，即我们在`WSAAsyncSelect`给socket绑定的事件通知的消息类型。\n```cpp\nLRESULT __stdcall WndProcdure(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    HDC hDC = NULL;\n    PAINTSTRUCT ps;\n    switch (message)\n    {\n    case WM_CREATE:\n    {\n        return 0;\n    }\n    case WM_PAINT:\n    {\n        hDC = BeginPaint(hWnd, &ps);\n        EndPaint(hWnd, &ps);\n        return 0;\n    }\n    case MY_WMACCEPT:\n    {\n        return 0;   // break point\n    }\n    case WM_DESTROY:\n    {\n        PostQuitMessage(0);\n        return 0;\n    }\n    }\n    return DefWindowProc(hWnd, message, wParam, lParam);\n}\n```\n## 测试\n断点可以设置在`case MY_WMACCEPT`中的break上。\n运行`wsa_async_select`后，再运行一个SocketClient项目中的`basic_stream_client`。\n可以看到断点落在return语句上。说明接收到了accept事件。\n## 具体写`case MY_WMACCEPT`\n```cpp\n{\n    case MY_WMACCEPT:\n    {\n        sockaddr_in client_addr;\n        int addrlen{ sizeof(client_addr) };\n        SOCKET work_sock = ::accept(\n            listen_sock,\n            reinterpret_cast<sockaddr*>(&client_addr),\n            &addrlen);\n        if (work_sock == INVALID_SOCKET)\n        {\n            err = ::WSAGetLastError();\n            return 1;\n        }\n\n        return 0;\n    }\n}\n```\n如此写，需要调整`listen_sock`和`err`为全局变量。\n```cpp\n// ...\nSOCKET listen_sock = INVALID_SOCKET;\nint err;\n// ...\n```\n### 显示客户端信息、收发数据\n接着，补充上之前服务端、客户端的收发代码。服务端还要显示连接的客户端的信息，由于项目是Windows Application，不能进行cout输出，因此需要用MessageBox替换。\n```cpp\n{\n    case MY_WMACCEPT:\n    {\n        // accept\n        // ...\n\n        wchar_t addr_str[46] = L\"\";\n        InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n        std::wstring info = std::format(L\"client address: {}, port: {}\\n\", addr_str, ntohs(client_addr.sin_port));\n\n        ::MessageBox(hWnd, info.c_str(), L\"info\", MB_OK);\n\n        // send ...\n        std::wstring message{ L\"Welcome to server!\" };\n        ::send(\n            work_sock,\n            reinterpret_cast<const char*>(message.c_str()),\n            sizeof(wchar_t) * message.size(),\n            0);\n        // recv ...\n        wchar_t buf[100] = { 0 };\n        int bytes_received = ::recv(work_sock, reinterpret_cast<char*>(buf), sizeof(wchar_t) * sizeof(buf), 0);\n        if (bytes_received > 0)\n        {\n            ::MessageBox(hWnd, buf, L\"recv\", MB_OK);\n        }\n        else\n        {\n            err = ::WSAGetLastError();\n        }\n        ::closesocket(work_sock);\n        work_sock = INVALID_SOCKET;\n\n        return 0;\n    }\n}\n```\n## 测试1\n刚打开客户端时，服务端窗口会弹出：\n![](../../images/Windows_网络模型/image-20241012130048427.png)\n但是后面，客户端输入内容回车后，服务端窗口有时不会弹出接收到的内容。\n![](../../images/Windows_网络模型/image-20241012130305976.png)\n### 原因\n经过调试，发现服务端的recv返回`-1`。\n查询error码，发现：\n![](../../images/Windows_网络模型/image-20241012130707547.png)\n## 调整select的socket为阻塞\n在accept之后，通过`ioctlsocket`函数设置`work_sock`为阻塞。`FIONBIO`。见[ioctlsocket示例](#ioctlsocket示例)\n```cpp\n// ...\n    case MY_WMACCEPT:\n    {\n        sockaddr_in client_addr;\n        int addrlen{ sizeof(client_addr) };\n        SOCKET work_sock = ::accept(\n            listen_sock,\n            reinterpret_cast<sockaddr*>(&client_addr),\n            &addrlen);\n        if (work_sock == INVALID_SOCKET)\n        {\n            err = ::WSAGetLastError();\n            return 1;\n        }\n\n        // set socket blocking mode\n        u_long iMode = 0;\n        if (SOCKET_ERROR == ::ioctlsocket(work_sock, FIONBIO, &iMode))\n        {\n            err = ::WSAGetLastError();\n        }\n// ...\n```\n但是只这样不行：\n![](../../images/Windows_网络模型/image-20241012131341949.png)\n原因见[注意（非阻塞模式）](#注意（非阻塞模式）)：\n要调整阻塞模式，首先必须通过调用`将lEvent设置为零的WSAAsyncSelect`来清除与套接字s关联的事件记录。然后再调用`ioctlsocket`或`WSAIoctl`将套接字设置为阻塞模式。\n因此需要改`WSAAsyncSelect`的最后一个参数，由`FD_ACCEPT`改为`0`。\n```cpp\n// ...\n\n    if (SOCKET_ERROR == ::WSAAsyncSelect(listen_sock, hWnd, MY_WMACCEPT, 0))\n    {\n        err = ::WSAGetLastError();\n    }\n\n    MSG msg;\n    while (GetMessage(&msg, NULL, 0, 0))\n    {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    ::WSACleanup();\n    return msg.wParam;\n}\n```\n至此，socket成功被设置为阻塞模式了。\n## 测试2\n先运行服务端。\n刚打开客户端时，服务端窗口会弹出：\n![](../../images/Windows_网络模型/image-20241012131828939.png)\n客户端输入内容回车后：\n![](../../images/Windows_网络模型/image-20241012131919359.png)\n服务端弹出窗口：\n![](../../images/Windows_网络模型/image-20241012131907928.png)\n以上版本的服务端只是用select监控了ACCEPT连接事件，而在`work_sock`上的读写事件通知是我们在select有了连接事件后同时向消息队列投出`MY_WMACCEPT`消息，在回调函数中的`switch-case`才去处理读写。\n以上的读写处理是比较僵硬的，仅用于测试。正规程序中的读写事件应该也用Select来监控，见下文。\n## 非阻塞模式下依靠select处理可读事件\n在原有程序的基础上，修改`case WM_ACCEPT`中的操作：不再阻塞式读取数据。而是在其中再一次select。\n需要改两个地方：\n1. 添加select，关注`FD_READ`，发出`WM_READ`\n2. 修改`iMode`为1。见[ioctlsocket示例](#ioctlsocket示例)\n\n```cpp\n// ...\n    case MY_WMACCEPT:\n    {\n        sockaddr_in client_addr;\n        int addrlen{ sizeof(client_addr) };\n        SOCKET work_sock = ::accept(\n            listen_sock,\n            reinterpret_cast<sockaddr*>(&client_addr),\n            &addrlen);\n        if (work_sock == INVALID_SOCKET)\n        {\n            err = ::WSAGetLastError();\n            return 1;\n        }\n\n        // select\n        if (::WSAAsyncSelect(work_sock, hWnd, MY_WMREAD, FD_READ) == SOCKET_ERROR)\n        {\n            err = ::WSAGetLastError();\n        }\n\n        // set socket non-blocking mode\n        u_long iMode = 1; // 1 to non-block\n        if (SOCKET_ERROR == ::ioctlsocket(work_sock, FIONBIO, &iMode))\n        {\n            err = ::WSAGetLastError();\n        }\n        \n        // MessageBox显示客户端信息 ...\n        // send data to client...\n        // recv 移动到 case WM_READ\n    }\n// ...\n```\n见：[显示客户端信息、收发数据](#显示客户端信息、收发数据)\n回调函数中，对应的`case MY_WMREAD`，里面的动作就对应于原先`case MY_WMACCEPT`中的`recv`操作了。即recv操作剪切过来。\n此时发现个问题：`work_sock`在此作用域中不明，需要传入。但是好在select函数为我们处理了：微软官方文档中指出：\n[WSAAsyncSelect function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaasyncselect)\n当指定的套接字`s`上发生指定的网络事件之一时，应用程序窗口`hWnd`接收消息`wMsg`。`wParam`参数标识发生网络事件的套接字。`lParam`的低位字指定已发生的网络事件。`lParam`的高位字包含任何错误代码。错误代码可以是`Winsock2.h`中定义的任何错误。\n因此，我们在用select监控到`FD_READ`事件后，它就会自动向wMain程序的wParam填充`work_sock`，那么我们在用到这个套接字时，从`wParam`取出即可。\n\n还要注意，如果服务端程序到一定阶段后，不需要再关注`FD_READ`事件了，那需要做收尾处理（再次调用`select`，置关注的事件为0）\n```cpp\n// ...\n    case MY_WMREAD:\n    {\n        SOCKET work_sock = wParam;\n        // recv\n        wchar_t buf[100] = { 0 };\n        int bytes_received = ::recv(work_sock, reinterpret_cast<char*>(buf), sizeof(wchar_t) * sizeof(buf), 0);\n        if (bytes_received > 0)\n        {\n            ::MessageBox(hWnd, buf, L\"recv\", MB_OK);\n        }\n        else\n        {\n            err = ::WSAGetLastError();\n        }\n        // clean Select\n        if (::WSAAsyncSelect(work_sock, hWnd, MY_WMREAD, 0) == SOCKET_ERROR)\n        {\n            err = ::WSAGetLastError();\n        }\n        // clean socket\n        ::closesocket(work_sock);\n        work_sock = INVALID_SOCKET;\n        return 0;\n    }\n// ...\n```\n# WSAEventSelect\nWSAAsyncSelect 是轮询模式。微软目前已经不建议使用。\nWSAEventSelect 是事件模式。微软比较推荐。\n两者的主要区别在于，WSAAsyncSelect需要绑定一个消息，而WSAEventSelect需要绑定一个事件。\n## 创建项目\nWSAEventSelect 不需要窗口程序，普通的控制台程序即可。\n因此创建一个新Empty项目：WSAEventSelectModel。创建源文件`wsa_event_select.cpp`\n内容暂时拷贝`basic_stream_server.cpp`的内容。\n## WSACreateEvent 创建Event\n在原先有accept操作的while循环之前，调用 WSACreateEvent 创建Event。无参数，返回类型为`HANDLE`。\n## WSAEventSelect函数\n![](../../images/Windows_网络模型/image-20241110043251046.png)\n[WSAEventSelect function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaeventselect)\n1. 参数1，填入要与event绑定的socket，比如：如果我们要观察一个accept事件，就需要绑定`listen_sock`\n2. 参数2，填入要观察的event事件。这个event用`WSACreateEvent`创建。\n3. 参数3，事件类型，比如：`FD_ACCEPT`。\n\n```cpp\n// ...\n    // 创建Event\n    HANDLE accept_ev = ::WSACreateEvent();\n    // 将listen_sock和accept_ev绑定\n    if(SOCKET_ERROR == ::WSAEventSelect(listen_sock, accept_ev, FD_ACCEPT))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    while (true)\n    {\n        // accept ...\n    }\n```\n## WSAWaitForMultipleEvents\n在select后，就可以用while循环中调用`WSAWaitForMultipleEvents`等待Events了。代替了原先代码简单的accept。\nAPI：[WSAWaitForMultipleEvents function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsawaitformultipleevents)\n![](../../images/Windows_网络模型/image-20241110044646204.png)\n1. 参数1：`lphEvents`指向的数组中事件对象句柄的数量。事件对象句柄的最大数量为`WSA_MAXIMUM_WAIT_EVENTS`。必须指定一个或多个事件。\n2. 参数2：指向事件对象句柄数组的指针。该数组可以包含不同类型的对象的句柄。如果`fWaitAll`参数设置为`TRUE`，则它可能不包含同一句柄的多个副本。如果在等待仍处于挂起状态时关闭这些句柄之一，则`WSAWaitForMultipleEvents`的行为未定义。\n3. 指定等待类型的值。如果为`TRUE`，则​​当`lphEvents`数组中所有对象的状态发出信号时，该函数返回。如果为`FALSE`，则当任何事件对象发出信号时该函数返回。在后一种情况下，返回值减去`WSA_WAIT_EVENT_0`表示其状态导致函数返回的事件对象的索引。如果在调用期间有多个事件对象发出信号，则这是发出信号的事件对象的数组索引，其中索引值是所有发出信号的事件对象中最小的。\n4. 超时间隔，以毫秒为单位。如果超时间隔到期，即使不满足`fWaitAll`参数指定的条件，`WSAWaitForMultipleEvents`也会返回。如果`dwTimeout`参数为`0`，`WSAWaitForMultipleEvents`测试指定事件对象的状态并立即返回。如果`dwTimeout`为`WSA_INFINITE`，则将永远等待。\n5. 指定线程是否处于可警报等待状态，以便系统可以执行 I/O 完成例程。如果为`TRUE \\`，则线程将置于可警报等待状态，并且当系统执行 I/O 完成例程时，`WSAWaitForMultipleEvents`可以返回。在这种情况下，将返回`WSA_WAIT_IO_COMPLETION`，并且尚未发出正在等待的事件的信号。应用程序必须再次调用`WSAWaitForMultipleEvents`函数。如果为`FALSE`，则线程不会置于可警报等待状态，并且不会执行 I/O 完成例程。\n6. 返回值：如果失败，则返回值为`WSA_WAIT_FAILED`。如果成功，则为以下之一。\n    1. `WSA_WAIT_EVENT_0` to `(WSA_WAIT_EVENT_0 + cEvents - 1)`\n    2. `WSA_WAIT_IO_COMPLETION`\n    3. `WSA_WAIT_TIMEOUT`\n\n由参数2，需要把每一个创建的event放到统一的数组中进行管理。需要在全局定义一个vector。\n还需要注意，虽然我们已经用`WSAEventSelect`绑定了socket和event，但是`WSAWaitForMultipleEvents`只能找到event对应的events下标值，不提供socket的追溯。\n\n因此我们还需要map额外记录event和哪个socket绑定。\n```cpp\n#include <vector>\nstd::vector<HANDLE> events;\nstd::map<HANDLE, SOCKET> ev_entries;\n```\n\n```cpp\n// ...\n    // WSAEventSelect ...\n    \n    // 把event添加到容器中\n    events.emplace_back(accept_ev);\n    ev_entries[accept_ev] = listen_sock;\n    \n    while (true)\n    {\n        // 参数3的false表示有1个事件就返回\n        // WSA_INFINITE表示无限等待\n        auto res = ::WSAWaitForMultipleEvents(\n            events.size(),\n            events.data(),\n            false,\n            WSA_INFINITE,\n            false);\n        if (int n = res - WSA_WAIT_EVENT_0; n < events.size())\n        {\n            auto event = events[n];\n            auto sock = ev_entries[event];\n            // ...\n        }\n    }\n```\n## WSAEnumNetworkEvents\n在得到Wait的返回值后（并且计算出了index），还需要使用[WSAEnumNetworkEvents](https://learn.microsoft.com/en-us/windows/desktop/api/winsock2/nf-winsock2-wsaenumnetworkevents)检索内部网络事件记录的内容，从而确定已发生哪些指定的网络事件。（见[WSAEventSelect function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaeventselect)中的Remarks）\n具体代码示例可见：[Enum代码示例](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaenumnetworkevents#example-code)\n需要注意，WSAEnumNetworkEvents的参数需要给出一个`WSANETWORKEVENTS`的结构体指针，函数要填充发生了的事件。具体结构可看：[WSANETWORKEVENTS structure (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/ns-winsock2-wsanetworkevents)\n```cpp\n// ...\n    // WSAEventSelect ...\n    \n    // ...\n    \n    WSANETWORKEVENTS network_events{};\n    while (true)\n    {\n        // 参数3的false表示有1个事件就返回\n        // WSA_INFINITE表示无限等待\n        auto res = ::WSAWaitForMultipleEvents(\n            events.size(),\n            events.data(),\n            false,\n            WSA_INFINITE,\n            false);\n        if (int n = res - WSA_WAIT_EVENT_0; n < events.size())\n        {\n            auto event = events[n];\n            auto sock = ev_entries[event];\n            if(SOCKET_ERROR == ::WSAEnumNetworkEvents(sock, event, &network_events))\n            {\n                continue;\n            }\n            if (network_events.lNetworkEvents & FD_ACCEPT)\n            {\n                // ...\n            }\n        }\n    }\n```\n## 处理事件\n### accept：显示客户端信息、发\n```cpp\n// ...\n    // WSAEventSelect ...\n    while (true)\n    {\n        {\n            // WSAEnumNetworkEvents ...\n            \n            // accept\n            if (network_events.lNetworkEvents & FD_ACCEPT)\n            {\n                sockaddr_in client_addr;\n                int addrlen{ sizeof(client_addr) };\n                SOCKET work_sock = accept(sock, reinterpret_cast<sockaddr*>(&client_addr), &addrlen);\n                if (INVALID_SOCKET == work_sock)\n                {\n                    err = ::WSAGetLastError();\n                    continue; // 继续下一次\n                }\n\n                wchar_t addr_str[46] = L\"\";\n                InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n                std::wstring info = std::format(L\"client address: {}, port: {}\\n\", addr_str, ntohs(client_addr.sin_port));\n                std::wcout << info << std::endl;\n\n                // send ...\n                std::wstring message{ L\"Welcome to server!\" };\n                ::send(\n                    work_sock,\n                    reinterpret_cast<const char*>(message.c_str()),\n                    sizeof(wchar_t) * message.size(),\n                    0);\n```\n在完成显示客户端地址、send消息的处理后，我们还要想方设法完成接收客户端的消息。\n那么就需要再创建一个Event，投递read event，以便于关注read事件。\n现在就需要把`work_sock`和`read_event`绑定，并且把这两个分别放到map和vector容器中。\n等下一次循环时，如果出现了READ事件，则会走到READ的分支，进行处理。\n```cpp\n                // ...\n                \n                // 投递（创建）read event，以便于关注read事件\n                auto read_event = ::WSACreateEvent();\n                if(SOCKET_ERROR == ::WSAEventSelect(work_sock, read_event, FD_READ))\n                {\n                    err = ::WSAGetLastError();\n                    continue;\n                }\n                events.emplace_back(read_event);\n                ev_entries[read_event] = work_sock;\n            }\n            else if (network_events.lNetworkEvents & FD_READ)\n            {\n                // ...\n            }\n        }\n    }\n```\n### read：收\n接收完毕后，记得调用`WSAEventSelect`进行解除绑定，把参数3（即关注的事件）设为0即可。\n```cpp\n#include <algorithm>\n#include <ranges>\n// ...\n    // WSAEventSelect ...\n\n    // ...\n        {\n            // ...\n            else if (network_events.lNetworkEvents & FD_READ)\n            {\n                // recv ...\n                auto work_sock = sock;\n                wchar_t buf[100] = { 0 };\n                int bytes_received = ::recv(work_sock, reinterpret_cast<char*>(buf), sizeof(wchar_t) * sizeof(buf), 0);\n                \n                if (bytes_received > 0)\n                {\n                    std::wcout << buf << std::endl;\n                }\n                else\n                {\n                    err = ::WSAGetLastError();\n                }\n                // 解除绑定\n                ::WSAEventSelect(work_sock, event, 0);\n\n                // clean select ，即vector和map中删去event\n                // vector需要使用迭代器删除\n                auto it = std::ranges::remove_if(\n                    events,\n                    [event](auto&& v) -> bool\n                        { return v == event; });\n                events.erase(it.begin(), it.end());\n                // map直接删除key\n                ev_entries.erase(event);\n\n                ::closesocket(work_sock);\n                work_sock = INVALID_SOCKET;\n            }\n        }\n    }\n\n    ::closesocket(listen_sock);\n    listen_sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n    return 0;\n}\n```\n## 测试\n开启一个服务端，3个客户端：\n![](../../images/Windows_网络模型/image-20241110162058202.png)\n\n![](../../images/Windows_网络模型/image-20241110162108210.png)\n\n可以“同时”按顺序处理。select的异步效果即为此。但是此程序目前并没有用多线程，而是在单线程上的按顺序快速一对多处理，从而看起来像是多线程。\n# Overlapped I/O\n像select一样，这也是异步的。但是，select只会通知你有什么事件，你需要自己处理。而重叠的意思在于，不仅像select一样非阻塞轮询，它还会帮你处理事件，所以假如有可读事件时，在通知你的时候，它已经帮你读完了，内容存到了缓冲区中，后续自己处理缓冲区即可。\n## 创建项目\nOverlapped I/O 不需要窗口程序，普通的控制台程序即可。\n因此创建一个新Empty项目：OverlappedIOModel。创建源文件`overlapped_io.cpp`\n## 预备工作\n仍需要对WSA进行启动（旧方法）。\n然后创建socket（下面将用新的`WSASocket`代替socket创建）。\n然后构建`sockaddr_in`地址，填充ip地址、端口号（旧方法）。\n然后`bind`、`listen`（旧方法）。\n```cpp\n#include<WinSock2.h>\n#include<mswsock.h>\n#include<WS2tcpip.h>\n#include<format>\n#include<iostream>\n#pragma comment(lib,\"Ws2_32.lib\")\n#pragma comment(lib, \"Mswsock.lib\")\nint main()\n{\n\tWSADATA wsaData;\n\tint err;\n\tauto wVersionRequested = MAKEWORD(2, 2);\n\terr = ::WSAStartup(wVersionRequested, &wsaData);\n\tif (err != 0) {\n\t\tstd::wcout << std::format(L\"WSAStartup failed with error : {}\\n\", err);\n\t\treturn 1;\n\t}\n\t\n\t// new function\n\tSOCKET listen_sock = ::WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, nullptr, 0, WSA_FLAG_OVERLAPPED);\n\tif (listen_sock == INVALID_SOCKET)\n\t{\n\t\terr = ::WSAGetLastError();\n\t\treturn 1;\n\t}\n\t// bind and listen, old funtion\n\tsockaddr_in server_addr;\n\tserver_addr.sin_family = AF_INET;\n\tif (1 != ::inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr))\n\t{\n\t\terr = ::WSAGetLastError();\n\t\treturn 1;\n\t}\n\tserver_addr.sin_port = htons(9008);\n\n\tif (SOCKET_ERROR == ::bind(listen_sock,\n\t\treinterpret_cast<const sockaddr*>(&server_addr),\n\t\tsizeof(server_addr)))\n\t{\n\t\terr = ::WSAGetLastError();\n\t\treturn 1;\n\t}\n\n\tif (SOCKET_ERROR == ::listen(listen_sock, SOMAXCONN))\n\t{\n\t\terr = ::WSAGetLastError();\n\t\treturn 1;\n\t}\n\t// ...\n}\n```\n## socket的创建：WSASocket\n不再使用伯克利API，而是使用微软异步模型API：WSASocket。\n在微软官方手册中，有WSASocketA和WSASocketW。在实际代码中我们也可以使用不带后缀的WSASocket。\n[WSASocketA function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa)\n![](../../images/Windows_网络模型/image-20241111115511444.png)\n1. `af`即地址家族，填`AF_INET`\n2. `type`，填`SOCK_STREAM`\n3. `protocol`，填`IPPROTO_TCP`\n4. `lpProtocolInfo`，暂时不用，填nullptr\n5. `g`，暂时不用，填0\n6. `dwFlags`，对应要赋予socket的特性。填`WSA_FLAG_OVERLAPPED`\n7. 返回类型：socket。\n## AcceptEx\nOverlapped I/O 与之前的accept流程不同的是，不需要再手动创建一个Event，也就不需要手动绑定event和socket，而你只需要提供各种参数，然后全部集中到AcceptEx处理。\n\n这个函数在`winsock.h`和`mswsock.h`均有定义。但是实际使用时，若引用的是`winsock.h`编译器不认识该函数名。所以应该引用`mswsock.h`。\n注意，在build时，需要加`#pragma comment(lib, \"Mswsock.lib\")`，否则链接器不认识。\n![](../../images/Windows_网络模型/image-20241112032857824.png)\n![](../../images/Windows_网络模型/image-20241112033045279.png)\n这个函数不仅会帮服务端接收一个新连接，还会向参数填充客户端的地址，以及处理读取客户端发送的第一个数据块。这种一次性就处理了很多工作的函数，就是重叠I/O模式。\n![](../../images/Windows_网络模型/image-20241112033415192.png)\n1. sListenSocket，即第一步创建好的`listen_sock`\n2. sAcceptSocket，还需要单独预创建一个`work_sock`，不能是绑定了的、连接了的，而是由本函数在调用后帮你填充好。\n3. 3\n4. 4\n5. 5\n6. 6\n7. 7\n8. lpOverlapped，这个结构体中包含了event。\n### 最后一个参数：如何与Event结合\n最后一个参数比较重要：lpOverlapped，我们需要创建一个OVERLAPPED结构，再在里面的hEvent成员构建Event，从而进行事件的绑定。\n### 返回值\n如果失败，返回FALSE 。然后可以调用`WSAGetLastError`函数来返回错误信息。如果`WSAGetLastError`返回`ERROR_IO_PENDING` ，则操作已成功启动并且仍在进行中。如果错误是`WSAECONNRESET`，则说明传入了连接，但随后在接受呼叫之前被远程方终止。\n### 程序\n```cpp\n    // ...\n\n\t// create a socket to accept by AcceptEx\n\tSOCKET work_sock = ::WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, nullptr, 0, WSA_FLAG_OVERLAPPED);\n\n\tchar* address_buf = new char[sizeof(sockaddr_in) * 2 + 32];\n\t\n\tDWORD length_received{ 0 };\n\t\n\tOVERLAPPED ovl;\n\tovl.hEvent = ::WSACreateEvent();\n\t\n\tbool res = AcceptEx(\n\t\tlisten_sock,\n\t\twork_sock,\n\t\taddress_buf,\n\t\t0,\n\t\tsizeof(sockaddr_in) + 16,\n\t\tsizeof(sockaddr_in) + 16,\n\t\t&length_received,\n\t\t&ovl);\n\tif (!res)\n\t{\n\t\tif (ERROR_IO_PENDING != ::WSAGetLastError())\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t::closesocket(listen_sock);\n\tlisten_sock = INVALID_SOCKET;\n\t::WSACleanup();\n\treturn 0;\n}\n```\n可以进行测试，断点打在`if (!res)`位置。\n根据手册：[返回值](#返回值)，如果AcceptEx返回false，但错误信息是`ERROR_IO_PENDING`时，也算是启动成功的，只是仍在进行中。\n## 结合event\n根据[最后一个参数：如何与Event结合](#最后一个参数：如何与Event结合)。\n效仿[WSAEventSelect](#WSAEventSelect)，需要提前构建vector容器来管理event。\n```cpp\n#include <vector>\n#include <map>\nstd::vector<HANDLE>      events;\nstd::map<HANDLE, SOCKET> ev_entries;\n```\n\n之后，便可以在AcceptEx成功之后的位置，向容器投入event。\n```cpp\n// ...\n{\n    // ...\n    OVERLAPPED ovl;\n\tovl.hEvent = ::WSACreateEvent();\n\t\n\tbool res = AcceptEx(\n\t\tlisten_sock,\n\t\twork_sock,\n\t\taddress_buf,\n\t\t0,\n\t\tsizeof(sockaddr_in) + 16,\n\t\tsizeof(sockaddr_in) + 16,\n\t\t&length_received,\n\t\t&ovl);\n\tif (!res)\n\t{\n\t\tif (ERROR_IO_PENDING != ::WSAGetLastError())\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\n    events.emplace_back(ovl.hEvent);\n    ev_entries[ovl.hEvent] = listen_sock;\n}\n```\n## 封装Entry结构管理 WSAGetOverlappedResult 所需属性\n以往的`ev_entries`是管理`<HANDLE, SOCKET>`，为了便于管理在OverlappedIO下的事件对应的每一个SOCKET的其他属性，把这些属性都封装在Entry中。则改进为`ev_entries`管理`<HANDLE, Entry>`。\n```cpp\nenum class EventType\n{\n    ET_ACCEPT = 0,\n    ET_READ\n};\nclass Entry\n{\npublic:\n    EventType       _event_type;\n    SOCKET          _listen_sock;\n    SOCKET          _work_sock;\n    char*           _buf{ nullptr };\n    WSAOVERLAPPED   _ovl;\n};\nstd::vector<HANDLE>     events;\nstd::map<HANDLE, Entry> ev_entries;\n```\n则在AcceptEx后的向map容器添加value就要改为\n```cpp\n{\n    // ...\n\tOVERLAPPED ovl;\n\tovl.hEvent = ::WSACreateEvent();\n\tbool res = AcceptEx(\n\t\tlisten_sock,\n\t\twork_sock,\n\t\taddress_buf,\n\t\t0,\n\t\tsizeof(sockaddr_in) + 16,\n\t\tsizeof(sockaddr_in) + 16,\n\t\t&length_received,\n\t\t&ovl);\n\tif (!res)\n\t{\n\t\tif (ERROR_IO_PENDING != ::WSAGetLastError())\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tevents.emplace_back(ovl.hEvent);\n    ev_entries[ovl.hEvent] = { EventType::ET_ACCEPT, listen_sock, work_sock, address_buf, ovl };\n\n    // ...\n}\n```\n\n>这里的程序有错误，会导致后续的WSAGetOverlappedResult错误。见[ovl的引用错误](#ovl的引用错误)\n## while循环 WSAWaitForMultipleEvents\n前期工作准备好了，后面还是while循环中进行`WSAWaitForMultipleEvents`。通过其返回值，找到events下标，找到event。然后通过map查询`ev_entries`之前记录的对应event的`listen_sock`等信息。\n## WSAGetOverlappedResult\n[WSAGetOverlappedResult function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsagetoverlappedresult)\n![](../../images/Windows_网络模型/image-20241114073646147.png)\n1. 参数1，填入event对应的socket\n2. 参数2，填入event对应的lpOverlapped。这个已经在AcceptEx之前就创建好了的，AcceptEx用过。见：[最后一个参数：如何与Event结合](#最后一个参数：如何与Event结合)\n\nWSAWaitForMultipleEvents找到event后，就需要调用`WSAGetOverlappedResult`看是否成功。成功才能进行下一步操作。\n```cpp\n    // AcceptEx ...\n    while (true)\n    {\n        // 参数3的false表示有1个事件就返回\n        // WSA_INFINITE表示无限等待\n        auto res = ::WSAWaitForMultipleEvents(\n            events.size(),\n            events.data(),\n            false,\n            WSA_INFINITE,\n            false);\n        if (int n = res - WSA_WAIT_EVENT_0; n < events.size())\n        {\n            auto event = events[n];\n            // structure bind\n            auto [event_type, listen_sock, work_sock, buf, ovl] = ev_entries[event];\n            DWORD bytes_received{ 0 };\n            DWORD flags{ 0 };\n            if (!::WSAGetOverlappedResult(\n                listen_sock,\n                &ovl,\n                &bytes_received,\n                false,\n                &flags))\n            {\n                err = ::WSAGetLastError();\n                continue;\n            }\n\n            // accept ...\n```\n### ovl的引用错误\n我们后面发现，`WSAGetOverlappedResult(listen_sock, &ovl, ...)`会产生错误。\n这和`ovl`的错误使用相关。因为这里产生了ovl复制，而后续使用的是map容器中value的`_ovl`，因此，应该传实际的map容器中`_ovl`的地址。\n>调用 `AcceptEx` 后，异步操作的完成会关联到你传入的 `OVERLAPPED` 结构（即 `&ovl`）。但是在主循环中，你使用 `WSAGetOverlappedResult` 获取结果时，使用的是 `ev_entries[ovl.hEvent]._ovl` 中的 `OVERLAPPED` 结构。这个不一致会导致 `WSAGetOverlappedResult` 在一个不同的 `OVERLAPPED` 结构上操作，从而引发错误。\n>\n>**传入的 `OVERLAPPED` 结构的作用**：`OVERLAPPED` 结构用于存储异步操作的状态。它不会立即在 `AcceptEx` 调用时被修改，但当操作完成时，Windows 会在 `OVERLAPPED` 结构中写入操作的完成状态。\n>\n\n应该调整为以下顺序：并且要注意AcceptEx最后一个参数应该针对的是`&ev_entries[ovl.hEvent]._ovl`。\n```cpp\n// ...\n{\n    // ...\n    OVERLAPPED ovl;\n\tovl.hEvent = ::WSACreateEvent();\n    events.emplace_back(ovl.hEvent);\n    ev_entries[ovl.hEvent] = { EventType::ET_ACCEPT, listen_sock, work_sock, address_buf, ovl };\n\tbool res = AcceptEx(\n\t\tlisten_sock,\n\t\twork_sock,\n\t\taddress_buf,\n\t\t0,\n\t\tsizeof(sockaddr_in) + 16,\n        sizeof(sockaddr_in) + 16,\n\t\t&length_received,\n\t\t&ev_entries[ovl.hEvent]._ovl);\n\tif (!res)\n\t{\n\t\tif (ERROR_IO_PENDING != ::WSAGetLastError())\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n```\n## 成功之后，可以分支处理事件\n```cpp\n    // ...\n    while (true)\n    {\n        // WSAWaitForMultipleEvents ...\n\n        if (...)\n        {\n            // ...\n            // WSAGetOverlappedResult ...\n\n            if (event_type == EventType::ET_ACCEPT)\n            {\n                // sock from above ev_entries[event]\n                sockaddr_in client_addr = *reinterpret_cast<sockaddr_in const*>(buf + sizeof(sockaddr_in) + 16);\n                \n                if (INVALID_SOCKET == work_sock)\n                {\n                    err = ::WSAGetLastError();\n                    continue; // 继续下一次\n                }\n                \n                // display the info about client\n                wchar_t addr_str[46] = L\"\";\n                InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n                std::wstring info = std::format(L\"client address: {}, port: {}\", addr_str, ntohs(client_addr.sin_port));\n                std::wcout << info << std::endl;\n                \n                // send ...\n                std::wstring message{ L\"Welcome to server!\" };\n                ::send(\n                    work_sock,\n                    reinterpret_cast<const char*>(message.c_str()),\n                    sizeof(wchar_t) * message.size(),\n                    0);\n\n                // 解除绑定\n                ::WSAEventSelect(listen_sock, event, 0);\n                // clean select ，使用迭代器删除event\n                auto it = std::ranges::remove_if(events, [event](auto&& v) -> bool { return v == event; });\n                events.erase(it.begin(), it.end());\n                ev_entries.erase(event);\n                \n                // 为接收消息做准备\n                auto read_event = ::WSACreateEvent();\n                if (SOCKET_ERROR == ::WSAEventSelect(work_sock, read_event, FD_READ))\n                {\n                    err = ::WSAGetLastError();\n                    continue;\n                }\n                events.emplace_back(read_event);\n                ev_entries[read_event] = { EventType::ET_READ, listen_sock, work_sock, address_buf, ovl };\n            }\n            else if (event_type == EventType::ET_READ)\n            {\n                // recv ...\n                wchar_t buf[100] = { 0 };\n                int bytes_received = ::recv(work_sock, reinterpret_cast<char*>(buf), sizeof(wchar_t) * sizeof(buf), 0);\n\n                if (bytes_received > 0)\n                {\n                    std::wcout << buf << std::endl;\n                }\n                else\n                {\n                    err = ::WSAGetLastError();\n                }\n                // 解除绑定\n                ::WSAEventSelect(work_sock, event, 0);\n                // clean select ，使用迭代器删除event\n                auto it = std::ranges::remove_if(events, [event](auto&& v) -> bool { return v == event; });\n                events.erase(it.begin(), it.end());\n                ev_entries.erase(event);\n\n                ::closesocket(work_sock);\n                work_sock = INVALID_SOCKET;\n            }\n        }\n    }\n\t::closesocket(listen_sock);\n\tlisten_sock = INVALID_SOCKET;\n\t::WSACleanup();\n\treturn 0;\n}\n```\n# IOCP（IO Completion Port）\n非阻塞模型、异步IO模型。异步指帮助你传数据。除上面外的特殊点在于，它内部还建立了线程池，让读写数据更加快速。\n而IOCP需要基于Overlapped I/O使用，比如需要用到AccpetEx。\n## 创建项目\nEmpty项目，取名IOCPModel。\n创建源文件`iocp.cpp`。\n## CreateIoCompletionPort 创建新的IOCP\n![](../../images/Windows_网络模型/image-20241113064337406.png)\n1. 参数1，需要给它一个打开了的文件Handle，或者`INVALID_HANDLE_VALUE`。在我们想要预创建一个CP（Completion Port）时，可以先给出`INVALID_HANDLE_VALUE`，可以看作是空的，随后再补上即可。如果给出`INVALID_HANDLE_VALUE`，那么参数2必须给`nullptr`。\n2. 参数2，填一个创建好了的iocp的HANDLE；如果原先没有有效的IOCP，则可以填`nullptr`。\n3. 参数3，Completion Key，中文叫作完成键。每个句柄都对应一个用户定义的完成键（实际上就是每个socket给一个名称），用户定义的完成键实际上就是用户自定义的结构体，内容包含你需要的东西。可以先填`0`。\n4. 参数4，`NumberOfConcurrentThreads`，指示需要开辟多少线程。如果此参数为0，则系统允许并发线程数量与系统中的处理器数量一样多。\n5. 返回值\n    1. 如果`ExistingCompletionPort`参数为`NULL`，则返回值是新句柄。\n    2. 如果`ExistingCompletionPort`参数是有效的 IOCP 句柄，则返回值是同一句柄。\n    3. 如果`FileHandle`参数是有效句柄，则该文件句柄现在与返回的 IOCP 关联。\n    4. 如果失败，返回值为`NULL`。要获取扩展错误信息，调用`GetLastError`函数（不带WSA前缀）。\n\n在程序结束之前，需要`CloseHandle(iocp); iocp = nullptr;`。\n```cpp\nHANDLE iocp{ nullptr };\nint main()\n{\n    iocp = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, nullptr, 0, 0);\n\n    // ...\n    ::CloseHandle(iocp);\n    iocp = nullptr;\n    // ...\n}\n```\n## 线程函数\niocp需要配合线程才能进行工作，那么就需要指定一个线程函数。\n## GetQueuedCompletionStatus\n![](../../images/Windows_网络模型/image-20241113071012878.png)\n1. 参数1，填上面已经创建好的iocp，每个iocp都有一个等待队列，这个参数指示了线程从哪个等待队列中等待。\n2. 参数2，`lpNumberOfBytesTransferred`，意为：有多少个数据传递了？\n3. 参数3，`lpCompletionKey`，完成键的指针类型。本参数是out类，是2级指针。是函数要回写的，因此需要填CompletionKey的2级指针。而lpCompletionKey原本是1级指针，在此基础上参数类型给出了`PULONG_PTR`，这又是一个一级指针类型，因此整体就表示2级指针。\n4. 参数4，`lpOverlapped`，本参数也是out类，也是2级指针，但与上面的表示方法不同，在`LPOVERLAPPED`是1级指针的基础上，又加了个`*`后缀，因此整体表示2级指针。\n5. 参数5，`dwMilliseconds`，等待多少秒。可以填`INFINITE`。\n6. 返回值：成功则返回非0，否则返回0。\n\n```cpp\nvoid worker(void)\n{\n\tDWORD bytes_transferred{ 0 };\n\tULONG_PTR completion_key;\n\tLPOVERLAPPED povl{ nullptr };\n\twhile (true)\n\t{\n\t\tbool succeed = ::GetQueuedCompletionStatus(iocp, &bytes_transferred, &completion_key, &povl, INFINITE);\n\t\tif (!succeed)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n```\n## Entry 完成键\n>这里为什么要设计成一定要多出一个socket的位置呢？因为我们发现在每次最后想要发出下一个AcceptEx时，需要再次填入`listen_sock`。如果我们只有`work_sock`，则会很麻烦。\n\n```cpp\nenum class EventType\n{\n    ET_ACCEPT = 0,\n    ET_READ\n};\nclass Entry\n{\npublic:\n    EventType       _event_type;\n    SOCKET          _listen_sock;\n    SOCKET          _work_sock;\n    char*           _buf{ nullptr };\n    WSAOVERLAPPED   _ovl;\n};\n```\n我们需要在AcceptEx之前创建完成键\n```cpp\n// ...\n    // overlapped pattern\n    SOCKET work_sock = ::WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, nullptr, 0, WSA_FLAG_OVERLAPPED);\n\n    char* address_buf = new char[sizeof(sockaddr_in) * 2 + 32];\n    DWORD length_received{ 0 };\n    OVERLAPPED ovl;\n    ovl.hEvent = ::WSACreateEvent();\n\n    // 创建entry\n    Entry* entry = new Entry{ EventType::ET_ACCEPT, listen_sock, work_sock, address_buf, ovl };\n\n    bool res = AcceptEx(\n        listen_sock,\n        work_sock,\n        address_buf,\n        0,\n        sizeof(sockaddr_in) + 16,\n        sizeof(sockaddr_in) + 16,\n        &length_received,\n        &entry->_ovl);  // 最后一个参数用的是entry中的_ovl\n\n    if (!res)\n    {\n        if (ERROR_IO_PENDING != ::WSAGetLastError())\n        {\n            return 1;\n        }\n    }\n    // ...\n```\n随后，创建IOCP\n## CreateIoCompletionPort 关联已有的IOCP\n参数1填写`listen_sock`，参数2填写一开始创建的空的IOCP，参数3填写刚才创建好的完成键，参数4填0。\n由于参数类型限制，需要用`reinterpret_cast`转换为对应的类型。\n```cpp\n    // AcceptEx...\n    auto old_iocp = ::CreateIoCompletionPort(\n        reinterpret_cast<HANDLE>(listen_sock),\n        iocp,\n        reinterpret_cast<ULONG_PTR>(entry),\n        0);\n    if (nullptr == old_iocp)\n    {\n        err = ::GetLastError();\n    }\n    // ...\n```\n## 投入方和处理方的联系：通过Entry\n`GetQueuedCompletionStatus`函数中第3个参数，要与我们自定义的Entry类型结合起来。\n```cpp\nvoid worker(void)\n{\n    DWORD bytes_transferred{ 0 };\n    //ULONG_PTR completion_key;\n    Entry* entry{ nullptr };\n    LPOVERLAPPED povl{ nullptr };\n    while (true)\n    {\n        // 将会从之前投入的IOCP中读取entry填入到现在的空entry\n        bool succeed = ::GetQueuedCompletionStatus(\n            iocp,\n            &bytes_transferred,\n            //&completion_key,\n            reinterpret_cast<PULONG_PTR>(entry),//等于ULONG_PTR*, ULONG二级指针\n            &povl,\n            INFINITE);\n        if (!succeed)\n        {\n            continue;\n        }\n        if (entry->_event_type == ...)\n        {\n            // ...\n        }\n    }\n}\n```\n然后，就可以在每次循环时判断entry中携带的EventType信息，从而做分支处理。\n但与平时不同，`work_sock`是来自entry中的。`client_addr`原先是accept函数在连接时填充给服务端的，而现在是来自`buf`中的内容。\n```cpp\n    // ...\n        // 之前的entry在创建时，有_event_type的EventType信息，还有_ovl信息\n        // 也有work_sock信息，是在之前AcceptEx中填充的。\n        // 还有buf信息，可以从其中提取客户端地址。\n        if (entry->_event_type == EventType::ET_ACCEPT)\n        {\n            SOCKET work_sock = entry->_work_sock;\n            if (INVALID_SOCKET == work_sock)\n            {\n                int err = ::WSAGetLastError();\n                continue; // 继续下一次\n            }\n            // display the info of client\n            sockaddr_in client_addr = *reinterpret_cast<sockaddr_in const*>(entry->_buf + sizeof(sockaddr_in) + 16);\n            wchar_t addr_str[46] = L\"\";\n            InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n            std::wstring info = std::format(L\"client address: {}, port: {}\", addr_str, ntohs(client_addr.sin_port));\n            std::wcout << info << std::endl;\n            // ...\n        }\n    // ...\n```\n## WSASend\n我们可以通过WSASend异步地向`work_sock`对应的client发送消息。\n```cpp\n            // display the info of client\n            \n            // ...\n            \n            // Send Hello to Client\n            WSABUF wsa_buf;\n            wsa_buf.buf = new char[100];\n            wcscpy_s(reinterpret_cast<wchar_t*>(wsa_buf.buf), 50, L\"Welcome to server!\");\n            ::WSASend(work_sock, &wsa_buf, 1, &bytes_transferred, 0, nullptr, nullptr);\n            // ...\n```\n## 后续的操作\n向往常一样，如果我们想要测试（1）打印客户端地址；（2）向客户端发送信息；（3）接收客户端信息。现在就差接收了。\n\n与WSASend对应的动作是WSARecv。也是异步的，所以不能盲目地调用，而是等对方发送消息时，或者出现可读事件时，再接收。\n\n但是不知道对方什么时候发送消息，因此，我们需要创建新的完成键，在完成键中指示`EventType`为`ET_READ`。\n\n然后，像IOCP之前的模式一样，把对应的`work_sock`和这个新的Entry投入到完成端口。\n然后让下个线程`GetQueuedCompletionStatus`，成功则说明有了事件，此时再去读取，就行了。\n\n读取完了之后，我们想要测试的东西就结束了，这时记得closeHandle，清除这个完成键。\n## 怎么让它转起来？\n目前服务端能接受一个客户端的连接请求，并且可以收发消息，但是后续的第二个客户端不行。\n因为我们只在主线程投递了一次IOCP，并且AccpetEx只进行一次。\n\n可以在处理完accept事件后，`WSASocket`创建新的空的`work_sock`赋给`entry`，entry的其他参数可以复用之前的。随后继续AcceptEx，但要注意，倒数第2个参数需要调整为`&bytes_transferred`。\n\nAcceptEx完成之后，就可以再次投入IOCP了。\n\n但是在尝试的过程中，我们发现，`CreateIoCompletionPort`的第1个参数不可以是`entry->_listen_sock`，这会导致返回值为nullptr，即错误，错误码是87，error lookup后查询到原因是“无效的参数”。\n至于为什么会失败？[查询文档]([CreateIoCompletionPort function (ioapiset.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-createiocompletionport))可知：\n>A handle can be associated with only one I/O completion port, and after the association is made, the handle remains associated with that I/O completion port until it is closed.\n>一个句柄只能与一个 I/O 完成端口关联，关联完成后，该句柄将保持与该 I/O 完成端口的关联，直至其关闭。\n\n因此，不能在同一个socket对应的HANDLE上重复CreateIOCP。\n\n`CreateIoCompletionPort`的第一个参数改为`(reinterpret_cast<HANDLE>(entry->_work_sock)`之后就正常工作了。\n我们刚开始使用`entry->_listen_sock`是错以为完成端口每一次工作后会把HANDLE退出。（比如这次的HANDLE，是由于主线程第一次`CreateIoCompletionPort`投入的`listen_sock`引起的）。实际上完成端口的每一次工作完成后，不会把HANDLE退出，因此无需再次对上面的`listen_sock`对应的HANDLE进行`CreateIoCompletionPort`。\n所以我们改为了对本次生成的`entry->_work_sock`对应的HANDLE进行`CreateIoCompletionPort`，这才是正确的逻辑。\n而完成端口什么时候会把HANDLE退出呢？应该是在`CloseHandle(iocp);`的时候。\n```cpp\n    // ...\n            // make another AcceptEx for next client\n            // 为了马上让worker线程去处理在本次listen_sock上新的用户连接\n            // work_sock需要创建一个新的空的\n            entry->_work_sock = ::WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, nullptr, 0, WSA_FLAG_OVERLAPPED);\n            // work_sock用新的空的\n            // listen sock 和 buf 以及 ovl 复用旧的\n            // 倒数第2个参数由 &length_received 调整为 &bytes_transferred\n            bool res = AcceptEx(\n                entry->_listen_sock,\n                entry->_work_sock,\n                entry->_buf,\n                0,\n                sizeof(sockaddr_in) + 16,\n                sizeof(sockaddr_in) + 16,\n                &bytes_transferred,      // !\n                &entry->_ovl);\n            // 再次投入完成端口中\n            auto old_iocp = ::CreateIoCompletionPort(\n                reinterpret_cast<HANDLE>(entry->_work_sock),\n                iocp,\n                reinterpret_cast<ULONG_PTR>(entry),\n                0);\n            if (nullptr == old_iocp)\n            {\n                int err = ::GetLastError();\n                break;\n            }\n    // ...\n```\n## 如何处理复合的多种事件的socket？\n我们设计的EventType只能指示简单的一种事件的socket。有的socket既有可读事件又有可写事件，此时，就需要依赖Entry中的`_ovl`信息了，它是overlappedIO信息，其中有hEvent变量。`_ovl`是AcceptEx函数填入的。\n如果需要处理多种事件复合的socket，就需要去读取这个信息。\n## 总结\nIOCP看起来复杂，其实无非就几个步骤：\n1. 创建完成键，需要填充`listen_sock`，`work_sock`，`ovl`等变量\n2. 创建IOCP，需要上面创建好的完成键\n3. 子线程从IOCP队列获取任务。分析entry内容。\n4. 子线程再次按需创建新的IOCP，以便让任务队列循环运转。","categories":["网络","Windows"]},{"title":"网络_文件传输","url":"/网络/网络_文件传输/","content":"# 创建项目\n新建项目`FileServer`。\n# FileHeader\n新建头文件`file_header.h`。\n\n需要设计为plain type，即简单结构，不能有虚函数表。\n需要设计：\n1. 偏移量\n2. 大小\n\n名字、标号、文件类型这些属性暂不考虑。\n```cpp\n// file_header.h\n#pragma once\nclass FileHeader\n{\npublic:\n\tunsigned long long offset;\n\tunsigned long long size;\n};\n```\n还需要考虑，问答的机制。\n1. 第一次请求文件时，需要得知文件总大小，\n2. 之后传输时则请求若干个不同的偏移量起始的文件片段。\n3. 传输完毕时，需要FINISH标志来提示结束。\n\n所以，请求的阶段、内容不一样时，就需要用不同类型的文件头来区分。\n```cpp\n#pragma once\nenum class HeaderType\n{\n    FILE_SIZE = 0,\n    SEGMENT,\n    FINISH\n};\nclass FileHeader\n{\npublic:\n    unsigned long long\t\toffset;\n    unsigned long long\t\tsize;\n    enum class HeaderType\ttype;\n};\n```\n# FileServer\n新建源文件`file_server.cpp`，内容拷贝`stream_server_threadpool_coroutine.cpp`。\n为了简洁，暂时不用线程池（仍保留协程）\n\n## 打开文件\n此处的代码位置位于服务端程序打印客户端信息和发送消息之间：\n\n需要使用fstream，构造一个fstream对象。需要传入文件路径、打开方式。\n打开方式见：[fstream::open](https://legacy.cplusplus.com/reference/fstream/fstream/open/)\n在此例我们使用读取+二进制方式打开文件：`std::fstream::in | std::fstream::binary`\n最后别忘了关闭fs。\n```cpp\n// file_server.cpp\n#include <fstream>\nagave::IAsyncAction worker_async(sockaddr_in client_addr, SOCKET work_sock)\n{\n    co_await agave::resume_background();\n    // print client info ...\n    // ...\n\n    // open target file\n    std::fstream fs(L\"d:/test\", std::fstream::in | std::fstream::binary);\n\n    fs.close();\n    ::closesocket(work_sock);\n    work_sock = INVALID_SOCKET;\n}\n```\n## 读取FileHeader\n这个FileHeader是客户端发送给服务端的请求。\n服务端需要查看客户端的请求类型。才能做出下一步的响应。\n写成一个函数。\n1. 需要两个参数：一个FileHeader的引用，供写入提前定义好的空对象。一个`work_sock`，将从此sock上收发FileHeader。\n2. 由于是TCP的流式传输，一次可能接收不完。所以每次接收后都需要计算剩余的大小，即`remainder = 固定的FileHeader大小 - 已接收的大小`，以及记录下一次接收的偏移量`offset += 已接收的大小`。\n3. 如果recv返回值小于等于0则接收结束。\n\n```cpp\nbool read_file_header(FileHeader& file_header, SOCKET work_sock)\n{\n    long long unsigned remainder = sizeof(file_header);\n    long long unsigned offset = 0;\n    while (remainder > 0)\n    {\n        auto bytes_received = ::recv(\n            work_sock,\n            reinterpret_cast<char*>(&file_header) + offset,\n            remainder,\n            0);\n        // 返回值为0时，代表连接已关闭\n        if (bytes_received == SOCKET_ERROR || bytes_received == 0)\n        {\n            return false;\n        }\n        else\n        {\n            remainder -= bytes_received;\n            offset += bytes_received;\n        }\n    }\n}\n```\n在打开文件后，执行读取FileHeader。成功接受FileHeader后，便可以通过switch-case判断HeaderType以进行下一步操作（响应给客户端）。需要循环执行。\n```cpp\n// file_server.cpp\n#include <fstream>\nagave::IAsyncAction worker_async(sockaddr_in client_addr, SOCKET work_sock)\n{\n    co_await agave::resume_background();\n    // print client info ...\n    // ...\n\n    // open target file\n    // ...\n\n    // check headerType\n    FileHeader file_header;\n    while (true)\n    {\n        if (!read_file_header(file_header, work_sock))\n        {\n            break;\n        }\n        switch (file_header.type)\n        {\n        case HeaderType::FILE_SIZE:\n        // ...\n            break;\n        case HeaderType::SEGMENT:\n        // ...\n            break;\n        case HeaderType::FINISH:\n        // ...\n            break;\n        default:\n        // ...\n            break;\n        }\n    }\n    fs.close();\n    ::closesocket(work_sock);\n    work_sock = INVALID_SOCKET;\n}\n```\n## 获取文件大小后响应\n根据fstream给出的方法，可以获取文件大小。\n具体地，要使用的是`istream`中的方法。因为是`读取`（istream中的i代表in，是以内存为视角的，写入到内存中，即为读取）。\n而对于读取，后缀都以`g`来区分。比如`seek`函数有`seekg`和`seekp`（又比如`tellg`、`tellp`），前者则是istream中的，后者是ostream中的，istream和ostream的缓冲区是两个独立的，所以要进行区分。\n函数比较简短，可以考虑设置为inline。\n```cpp\ninline long long unsigned get_file_size(std::fstream& fs)\n{\n    fs.seekg(0, std::fstream::end);\n    long long unsigned length = fs.tellg();\n    fs.seekg(0, std::fstream::beg);\n    return length;\n}\n```\n获取完文件大小后，填入要响应的FileHeader的信息，发送给客户端，需要封装一个`send_file_header`函数。\n```cpp\n// file_server.cpp\n// ...\n        switch (file_header.type)\n        {\n        case HeaderType::FILE_SIZE:\n        {\n            file_header.type = HeaderType::FILE_SIZE;\n            file_header.offset = 0;\n            file_header.size = get_file_size(fs);\n            send_file_header(file_header, work_sock);\n        }\n            break;\n        case HeaderType::SEGMENT:\n        // ...\n            break;\n        case HeaderType::FINISH:\n        // ...\n            break;\n        default:\n        // ...\n            break;\n        }\n    }\n// ...\n}\n```\n### `send_file_header`\n```cpp\nbool send_file_header(FileHeader& file_header, SOCKET work_sock)\n{\n    long long unsigned remainder = sizeof(file_header);\n    long long unsigned offset = 0;\n    while (remainder > 0)\n    {\n        auto bytes_sent = ::send(\n            work_sock,\n            reinterpret_cast<const char*>(&file_header) + offset,\n            remainder,\n            0);\n        if (bytes_sent == SOCKET_ERROR)\n        {\n            return false;\n        }\n        else\n        {\n            remainder -= bytes_sent;\n            offset += bytes_sent;\n        }\n    }\n    return true;\n}\n```\n## 响应片段\n首先需要读取片段，再发送。\n在此之前，定义一个固定的文件片段大小，在`file_header.h`中定义为常量，512字节。\n```cpp\n// file_header.h\n// fixed File Segment Size\nconstexpr unsigned SEGMENT_SIZE{ 512 };\n// ...\n```\n然后，可以以此大小作为缓冲区大小。每次读取一个片段都把内容放到这个缓冲区中，再发送走。最后不要忘记释放缓冲区。\n```cpp\n// file_server.cpp\n// ...\n    // open target file\n    // ...\n\n    // check headerType\n    FileHeader file_header;\n    char* buf = new char(SEGMENT_SIZE);\n    while (true)\n    {\n        // ...\n    }\n\n    delete[]buf;\n    buf = nullptr;\n    fs.close();\n    ::closesocket(work_sock);\n    work_sock = INVALID_SOCKET;\n}\n```\n响应的代码：\n`read_segment_from_file`用于读取一个文件片段，然后写入到一个buf缓冲区中。\n`send_segment`用于把buf缓冲区从SOCKET发送到网络。\n\n`read_segment`或`send_segment`错误时，不能直接break，这回直接退出while循环，可以加一个标志位`is_exit`，在执行完该case后根据此标志来决定是否退出循环。\n```cpp\n// ...\n    bool is_exit{ false };\n    while (true)\n    {\n        if (!read_file_header(file_header, work_sock))\n        {\n            break;\n        }\n        switch (file_header.type)\n        {\n        case HeaderType::FILE_SIZE:\n        {\n            // ...\n        }\n            break;\n        case HeaderType::SEGMENT:\n        {\n            if (!read_segment_from_file(fs, buf, file_header.offset, file_header.size))\n            {\n                is_exit = true;\n            }\n            if (!send_segment(work_sock, buf, file_header.size))\n            {\n                is_exit = true;\n            }\n        }\n            break;\n        case HeaderType::FINISH:\n            is_exit = true;\n            break;\n        default:\n            break;\n        }\n        if (is_exit)\n            break;\n    }\n// ...\n```\n### 读取片段\n```cpp\ninline bool read_segment_from_file(std::fstream& fs, char * buf, long long unsigned offset, long long unsigned length)\n{\n    fs.seekg(offset, std::fstream::beg);\n    fs.read(buf, length);\n    // read不会返回读取的量，需要用gcount来看读取了多少\n    if (fs.gcount() != length)\n        return false;\n    return true;\n}\n```\n### 发送片段\n和`send_file_header`非常相似，只不过把FileHeader换成了buf，且有一个实际的length参数。\n```cpp\nbool send_segment(SOCKET work_sock, const char* buf, long long unsigned length)\n{\n    long long unsigned remainder = length;\n    long long offset = 0;\n    while (remainder > 0)\n    {\n        auto bytes_sent = ::send(\n            work_sock,\n            reinterpret_cast<const char*>(buf) + offset,\n            remainder,\n            0);\n        if (bytes_sent == SOCKET_ERROR)\n        {\n            return false;\n        }\n        else\n        {\n            remainder -= bytes_sent;\n            offset += bytes_sent;\n        }\n    }\n    return true;\n}\n```\n# FileClient\n创建项目`FileClient`，新建源文件`file_client.cpp`，内容拷贝`basic_stream_client.cpp`。\n添加头文件（Add Existing Item）`file_header.h`。\n在原先测试收发消息的代码处更换为：发送FileHeader。\n```cpp\n#include <WinSock2.h>\n#include <iostream>\n#include <format>\n#include <ws2tcpip.h>\n#include \"../FileServer/file_header.h\"\n#pragma comment (lib, \"Ws2_32\")\nint main()\n{\n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = ::WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0)\n    {\n        std::wcout << std::format(L\"WSAStartup failed with error : {}\\n\", err);\n        return 1;\n    }\n\n    SOCKET sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    if (1 != ::inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    server_addr.sin_port = htons(9008);\n\n    if (SOCKET_ERROR == ::connect(sock, reinterpret_cast<const sockaddr*>(&server_addr), sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    \n    // adjust as follow:\n    FileHeader file_header;\n    file_header.type = HeaderType::FILE_SIZE;\n    // send FileHeader\n    // ...\n\n    ::closesocket(sock);\n    sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n    return 0;\n}\n```\n## `file_foundation`\n此处又会用到了FileServer中写过的`send_file_header`函数，可想而知后面同样会用到其他写过的函数。\n所以我们单独在FileServer项目中再新建一个单独的头文件`file_foundation.h`，把之前在`file_server.cpp`单独声明的函数剪切到此处，以便两端都可以引用。\n注意也需要剪切这些函数需要的头文件。相应地`file_server.cpp`可以只引用`file_foundation.h`。\n```cpp\n// file_foundation.h\n#pragma once\n#include <fstream>\n#include \"file_header.h\"\n#include <WinSock2.h>\nbool read_file_header(FileHeader& file_header, SOCKET work_sock);\nbool send_file_header(FileHeader& file_header, SOCKET work_sock);\nbool send_segment(SOCKET work_sock, const char* buf, long long unsigned length);\nlong long unsigned get_file_size(std::fstream& fs);\nbool read_segment_from_file(std::fstream& fs, char* buf, long long unsigned offset, long long unsigned length);\n```\n相应地，需要在FileServer项目中新建`file_foundation.cpp`，剪切实现部分。\n此时编译测试，发现之前在`file_server.cpp`中声明的inline函数在分开的`file_foundation`时就不能通过编译了，需要去掉inline。\n```cpp\n// file_foundation.cpp\n#include \"file_foundation.h\"\nbool read_file_header(FileHeader& file_header, SOCKET work_sock)\n{\n    long long unsigned remainder = sizeof(file_header);\n    long long unsigned offset = 0;\n    while (remainder > 0)\n    {\n        auto bytes_received = ::recv(\n            work_sock,\n            reinterpret_cast<char*>(&file_header) + offset,\n            remainder,\n            0);\n        // 返回值为0时，代表连接已关闭\n        if (bytes_received == SOCKET_ERROR || bytes_received == 0)\n        {\n            return false;\n        }\n        else\n        {\n            remainder -= bytes_received;\n            offset += bytes_received;\n        }\n    }\n}\nbool send_file_header(FileHeader& file_header, SOCKET work_sock)\n{\n    long long unsigned remainder = sizeof(file_header);\n    long long unsigned offset = 0;\n    while (remainder > 0)\n    {\n        auto bytes_sent = ::send(\n            work_sock,\n            reinterpret_cast<const char*>(&file_header) + offset,\n            remainder,\n            0);\n        if (bytes_sent == SOCKET_ERROR)\n        {\n            return false;\n        }\n        else\n        {\n            remainder -= bytes_sent;\n            offset += bytes_sent;\n        }\n    }\n    return true;\n}\nbool send_segment(SOCKET work_sock, const char* buf, long long unsigned length)\n{\n    long long unsigned remainder = length;\n    long long offset = 0;\n    while (remainder > 0)\n    {\n        auto bytes_sent = ::send(\n            work_sock,\n            buf + offset,\n            remainder,\n            0);\n        if (bytes_sent == SOCKET_ERROR)\n        {\n            return false;\n        }\n        else\n        {\n            remainder -= bytes_sent;\n            offset += bytes_sent;\n        }\n    }\n    return true;\n}\nlong long unsigned get_file_size(std::fstream& fs)\n{\n    fs.seekg(0, std::fstream::end);\n    long long unsigned length = fs.tellg();\n    fs.seekg(0, std::fstream::beg);\n    return length;\n}\nbool read_segment_from_file(std::fstream& fs, char* buf, long long unsigned offset, long long unsigned length)\n{\n    fs.seekg(offset, std::fstream::beg);\n    fs.read(buf, length);\n    // read不会返回读取的量，需要用gcount来看读取了多少\n    if (fs.gcount() != length)\n        return false;\n    return true;\n}\n```\n## 继续编写`file_client`\n在FileClient项目下Add Existing Item：`file_foundation.h`和`file_foundation.cpp`。\n此时，`file_client`就可以引用`file_foundation.h`，复用`send_file_header`等函数：\n\n接下来需要处理的就是：\n1. 发送FileHeader，请求获取文件总大小，读取到FileHeader中\n2. `文件总大小 / 缓冲区大小`计算将要下载的片段数，以及计算最后一个片段大小\n3. fstream打开文件（需要指定接收文件到哪个位置），以out、binary、trunc（追加）的方式打开\n4. for循环\n    1. 每次都发一个FileHeader，请求获取一个文件片段\n    2. 读取Segment，先写入到buf。（此处对应的函数为`read_segment`，是客户端从网络读取下载。而`read_segment_from_file`是服务端从本地文件读取片段）\n    3. `fs.write`拷贝buf内容到fs设置好的硬盘位置中。\n    4. 循环完毕后按以上步骤特殊处理结尾片段。\n5. 发送FileHeader，表示FINISH。\n\n```cpp\n// ...\n    FileHeader file_header;\n    file_header.type = HeaderType::FILE_SIZE;\n    send_file_header(file_header, sock);\n    read_file_header(file_header, sock);\n    long long unsigned count = file_header.size / SEGMENT_SIZE;\n    long long unsigned last_size = file_header.size - count * SEGMENT_SIZE;\n    // open a file to write by downloading\n    char* buf = new char[SEGMENT_SIZE];\n    std::fstream fs(L\"./testRecv\", std::fstream::out | std::fstream::binary | std::fstream::trunc);\n\n    if (!fs)\n    {\n        goto __Target;\n    }\n    for (long long unsigned i = 0; i < count; ++i)\n    {\n        // request segment to server\n        file_header.type = HeaderType::SEGMENT;\n        file_header.offset = i * SEGMENT_SIZE;\n        file_header.size = SEGMENT_SIZE;\n        if (!send_file_header(file_header, sock))\n        {\n            break;\n        }\n        // download from server\n        if (!read_segment(sock, buf, SEGMENT_SIZE))\n        {\n            break;\n        }\n        // write to HardDisk\n        fs.write(buf, SEGMENT_SIZE);\n        if (!fs)\n        {\n            break;\n        }\n    }\n    if (last_size > 0)\n    {\n        // request segment to server\n        file_header.type = HeaderType::SEGMENT;\n        file_header.offset = count * SEGMENT_SIZE;\n        file_header.size = last_size;\n        if (send_file_header(file_header, sock))\n        {\n            // download from server\n            if (read_segment(sock, buf, last_size))\n            {\n                // write to HardDisk\n                fs.write(buf, last_size);\n            }\n        }\n    }\n    file_header.type = HeaderType::FINISH;\n    send_file_header(file_header, sock);\n\n__Target:\n    fs.close();\n    delete[]buf;\n    ::closesocket(sock);\n    sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n    return 0;\n}\n```\n# 测试\n启动项目设置为FileServer，直接运行（点击Local Windows Debugger）。\n右键FileClient，选择Debug，Start New Instance，即可运行客户端。\n发现，在缓冲区大小为512字节时（`file_header.h`中`SEGMENT_SIZE`），传输时间稍长，可以设置为`512 * 1024`即512KB，传输速度即可翻倍。","categories":["Linux","网络"]},{"title":"线程池_bubo","url":"/项目/线程池_bubo/","content":"# 创建项目\n在已有或新建的解决方案里，新建项目，取名“ThreadPool”。\n项目配置标准为`C++20`标准。\n# ITask\n新建头文件`ITask.h`。\n```cpp\nnamespace thpool\n{\n\tclass ITask\n\t{\n\tpublic:\n\t\tvirtual void run_task(void) = 0;\n\t};\n}\n```\n# 基于信号量的ThreadPool\n新建头文件“ThreadPool.h”\n```cpp\n// ThreadPool.h\n#include <thread>\n#include <mutex>\n#include <semaphore>\n#include <list>\nnamespace thpool\n{\n\tclass ITask;\n\tclass ThreadPool\n\t{\n\tpublic:\n\t\tThreadPool(int max_num);\n\t\t~ThreadPool();\n\t\tvoid add_task(std::shared_ptr<ITask> task);\n\t\tvoid add_task(std::list<std::shared_ptr<ITask>> task_lst);\n\tprivate:\n\t\t// capacity\n\t\tint\t\t\t\t\t\t\t\t\t_max_num;\n\t\t// current running task threads\n\t\tint\t\t\t\t\t\t\t\t\t_alive_num;\n\t\tstd::counting_semaphore<100>\t\t_semaphore;\n\t\tstd::mutex\t\t\t\t\t\t\t_access_mx;\n\t\tbool\t\t\t\t\t\t\t\t_is_exit{ false };\n\t\tstd::list<std::shared_ptr<ITask>>\t_task_queue;\n\t};\n}\n```\n\n实现：\n1. 初始化`_max_num`，规定线程池最大线程数\n2. 初始化`_alive_num`，线程池刚创建时，正在执行任务的线程为0。\n3. 初始化`_semaphore`为0。\n\n共创建`_max_num`个线程，每个线程基于信号量获取任务，如果成功则`_alive_num`加1，如果此时`_is_exit`标志为真则意味着线程池即将析构，`_alive_num`减1，并退出循环。\n如果`_is_exit`标志不为真，则尝试从任务队列中提取任务，需要用互斥锁同步，在外层先简单判断队列大小是否大于0，然后再用锁去再次获取真实值（这样外层先判断，内层再加锁判断，可以加大条件为真的概率，避免锁太急切地加，降低性能），再去执行提取出的任务。循环，直到任务队列大小为0，退出while循环后`_alive_num`减1。\n退出大的while时（`_is_exit`标志为真时），`_max_num`减1。\n```cpp\n// ThreadPool.cpp\n#include \"ThreadPool.h\"\n#include \"ITask.h\"\n\nthpool::ThreadPool::ThreadPool(int max_num)\n\t: _max_num{ max_num }, _alive_num{ 0 }, _semaphore{ 0 }\n{\n\tfor (int i = 0; i < _max_num; ++i)\n\t{\n\t\tstd::jthread th([this](void)\n\t\t\t{\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t_semaphore.acquire();\n\t\t\t\t\t++_alive_num;\n\t\t\t\t\tif (_is_exit)\n\t\t\t\t\t{\n\t\t\t\t\t\t--_alive_num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (_task_queue.size() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::unique_lock lck{ _access_mx };\n\t\t\t\t\t\tif (_task_queue.size() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tauto task = _task_queue.front();\n\t\t\t\t\t\t\t_task_queue.pop_front();\n\t\t\t\t\t\t\tlck.unlock();\n\t\t\t\t\t\t\ttask->run_task();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t--_alive_num;\n\t\t\t\t}\n\t\t\t\t--_max_num;\n\t\t\t});\n\t\tth.detach();\n\t}\n}\n\nvoid thpool::ThreadPool::add_task(std::shared_ptr<ITask> task)\n{\n\tif (!task)\n\t\treturn;\n\tstd::unique_lock lck{ _access_mx };\n\t_task_queue.push_back(task);\n\tlck.unlock();\n\t// 判断是否有空余的线程，如果有则唤醒一个\n\tif (_max_num - _alive_num > 0)\n\t{\n\t\t_semaphore.release(1);\n\t}\n}\n```\n但是以上程序存在一些问题：\n1. `_semaphore.acquire()`和`++_alive_num`不是同步的。\n2. `_is_exit`的判断和`--_alive_num`也不是同步的。\n3. 在每个线程中都进行while循环反复判断任务队列是否为空，可能会导致一个线程一直独占`_access_mx`互斥量。\n4. 在执行完任务后的`--_alive_num`步骤，是和执行结束是不同步的，有可能`_max_num`个线程同时卡在这一步，导致`add_task`函数中的`_max_num - _alive_num > 0`的条件不成立，导致`_semaphore.release(1)`不会执行。这将导致系统实际增加了任务，却没有增加任务的信号量。有小概率死锁（死锁在`_semaphore.acquire()`）。\n5. 综上所述，最好把`_semaphore`和`_alive_num`融为一体，不要割裂两者。（也就是说，能不能让信号量的量和`_alive_num`无缝保持一致）\n    1. 操作系统的具体实现，如Windows、Linux是可以随时获取信号量的量的，但是我们现在使用的是跨平台`C++`信号量，没有提供获取量大小的方法，因此必须有一个`_alive_num`记录。\n    2. 可以在`_semaphore.acquire()`和`++_alive_num`这两个动作整体加锁吗？不可以，因为`_semaphore`本身就是会阻塞的东西，如果加了锁后，`_semaphore`也阻塞了，那么锁就不能解开了。\n    3. 上面提到的，加了锁后，里面的东西阻塞了，想要把锁解开，有一样东西可以实现：条件变量。但是，条件变量没有像信号量记录数目的功能（要么是`notify_one`，要么是`notify_all`），因此不行。\n6. 最简单的彻底解决4死锁的问题的方法是，`add_task`方法中不再判断`_max_num - _alive_num > 0`的条件，即无论如何，在添加任务时，都要`_semaphore.release(1)`。这样做的副作用就是要把`std::counting_semaphore _semaphore`在声明时，定义其为一个最大值为无限大（最大数）的信号量，可以用`std::counting_semaphore<> _semaphore`表示。\n# 修改后的版本\n```cpp\n// ThreadPool.h\n#include <thread>\n#include <mutex>\n#include <semaphore>\n#include <list>\nnamespace thpool\n{\n\tclass ITask;\n\tclass ThreadPool\n\t{\n\tpublic:\n\t\tThreadPool(int max_num);\n\t\t~ThreadPool();\n\t\tvoid add_task(std::shared_ptr<ITask> task);\n\t\tvoid add_task(std::list<std::shared_ptr<ITask>> task_lst);\n\tprivate:\n\t\t// capacity\n\t\tint\t\t\t\t\t\t\t\t\t_max_num;\n\t\t// current running task threads\n\t\tint\t\t\t\t\t\t\t\t\t_alive_num;\n        std::counting_semaphore<>\t\t    _semaphore;\n\t\tstd::mutex\t\t\t\t\t\t\t_access_mx;\n\t\tbool\t\t\t\t\t\t\t\t_is_exit{ false };\n\t\tstd::list<std::shared_ptr<ITask>>\t_task_queue;\n\t};\n}\n```\n\n```cpp\n// ThreadPool.cpp\n#include \"ThreadPool.h\"\n#include \"ITask.h\"\n\nthpool::ThreadPool::ThreadPool(int max_num)\n\t: _max_num{ max_num }, _alive_num{ 0 }, _semaphore{ 0 }\n{\n\tfor (int i = 0; i < _max_num; ++i)\n\t{\n\t\tstd::jthread th([this](void)\n\t\t\t{\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t_semaphore.acquire();\n\t\t\t\t\t++_alive_num;\n\t\t\t\t\tif (_is_exit)\n\t\t\t\t\t{\n\t\t\t\t\t\t--_alive_num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n                    std::unique_lock lck{ _access_mx };\n                    if (_task_queue.size() > 0)\n                    {\n                        auto task = _task_queue.front();\n                        _task_queue.pop_front();\n                        lck.unlock();\n                        task->run_task();\n                    }\n\t\t\t\t\t--_alive_num;\n\t\t\t\t}\n\t\t\t\t--_max_num;\n\t\t\t});\n\t\tth.detach();\n\t}\n}\n\nvoid thpool::ThreadPool::add_task(std::shared_ptr<ITask> task)\n{\n\tif (!task)\n\t\treturn;\n\tstd::unique_lock lck{ _access_mx };\n\t_task_queue.push_back(task);\n\tlck.unlock();\n\t\n    _semaphore.release(1);\n}\n```\n# 线程池的析构——latch的运用\nlatch是`C++20`引入的标准。\n实际上是对操作系统同步量的操作的封装，比如在Windows下，latch就是对事件的封装，或者是对`WaitFor Single/Mutiple Object`的封装。\n```cpp\n// ThreadPool.h\n#include <thread>\n#include <mutex>\n#include <semaphore>\n#include <list>\n#include <latch>\nnamespace thpool\n{\n\tclass ITask;\n\tclass ThreadPool\n\t{\n\tpublic:\n    \t// ...\n\tprivate:\n    \t// ...\n\t\tstd::latch                          _latch;\n        // ...\n};\n}\n```\n在ThreadPool构造时初始化`_latch`为`max_num`，表示需要等待`max_num`个线程的结束，latch才放行。\n同时，要在退出大的while循环时，`_max_num`减1之后，进行`_latch.count_down()`，参数默认为1，意为对latch值减1。\n```cpp\n// ThreadPool.cpp\n#include \"ThreadPool.h\"\n#include \"ITask.h\"\n\nthpool::ThreadPool::ThreadPool(int max_num)\n\t: _max_num{ max_num }, _alive_num{ 0 }, _semaphore{ 0 }, _latch{ max_num }\n{\n\tfor (int i = 0; i < _max_num; ++i)\n\t{\n\t\tstd::jthread th([this](void)\n\t\t\t{\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t_semaphore.acquire();\n\t\t\t\t\t++_alive_num;\n\t\t\t\t\tif (_is_exit)\n\t\t\t\t\t{\n\t\t\t\t\t\t--_alive_num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n                    // ...\n\t\t\t\t}\n\t\t\t\t--_max_num;\n\t\t\t\t_latch.count_down();\n\t\t\t});\n\t\tth.detach();\n\t}\n}\n```\n析构函数，则可以利用latch，让其在析构函数设置`_is_exit`标志为true且释放`_max_num`信号量后，wait直到latch值为0时，代表所有线程都结束了，就可以返回了。\n```cpp\n// ThreadPool.cpp\nthpool::ThreadPool::~ThreadPool()\n{\n    _is_exit = true;\n    _semaphore.release(_max_num);\n    // 等待线程结束，对应latch其值为0时\n    _latch.wait();\n}\n```\n# 测试\n新建`main_entry.cpp`\n```cpp\n// main_entry.cpp\n#include \"ThreadPool.h\"\n#include \"ITask.h\"\n#include <iostream>\nusing namespace std::chrono_literals;\nclass Task : public thpool::ITask\n{\npublic:\n    virtual void run_task(void) override\n    {\n        std::wcout << L\"task\" << std::endl;\n    }\n};\nint main(void)\n{\n    thpool::ThreadPool thread_pool{ 10 };\n    thread_pool.add_task(std::shared_ptr<thpool::ITask>(new Task));\n    thread_pool.add_task(std::shared_ptr<thpool::ITask>(new Task));\n    std::this_thread::sleep_for(10s);\n    return 0;\n}\n```\n测试结果：\n![](../../images/线程池_bubo/image-20240925070123537.png)\n两个task黏在一起，说明多线程输出的。\n\n在Debug-Windows-Threads中，可以看到目前程序中的线程状况：\n![](../../images/线程池_bubo/image-20240925070928536.png)\n可以看到有10个子线程在其中：\n![](../../images/线程池_bubo/image-20240925071049814.png)\n","categories":["操作系统","多线程","Cpp","项目"]},{"title":"7z_常用命令","url":"/一些工具的使用/7z_常用命令/","content":"# 命令格式\n```sh\nUsage: 7zz <command> [<switches>...] <archive_name> [<file_names>...] [@listfile]\n```\n# 安装\n将7zz文件移动到系统的bin目录\n`sudo cp 7zz /usr/local/bin/7zz`\n并且确保`/usr/local/bin`在系统PATH中\n打开或创建`.zshrc`（如果你使用zsh）或`.bash_profile`（如果你使用bash）文件：\n确认有如下内容（如果没有，请添加）：\n`export PATH=\"/usr/local/bin:$PATH\"`\n保存并关闭文件，然后执行以下命令使更改生效：\n`source ~/.zshrc`或`~/.bash_profile`\n## command（必须）\n\n| Command | Description                                                |\n| ------- | ---------------------------------------------------------- |\n| a       | Add files to archive                                       |\n| b       | Benchmark                                                  |\n| d       | Delete files from archive                                  |\n| e       | Extract files from archive (without using directory names) |\n| h       | Calculate hash values for files                            |\n| i       | Show information about supported formats                   |\n| l       | List contents of archive                                   |\n| rn      | Rename files in archive                                    |\n| t       | Test integrity of archive                                  |\n| u       | Update files to archive                                    |\n| x       | eXtract files with full paths                              |\n1. a是代表压缩文件到压缩包\n2. e中的“without using directory names”表示的是解压缩后的文件将不会有文件夹一级的目录，而是全部为零散的文件。\n3. x代表解压缩文件，解压缩后有压缩包中原来的文件夹。\n\n## switches（可选）\n下面只列出了常用的。\n\n| Switches         | Description                                                    |\n| ---------------- | -------------------------------------------------------------- |\n| `-m{Parameters}` | set compression Method                                         |\n| `  -mmt[N]`      | set number of CPU threads                                      |\n| `  -mx[N]`       | set compression level: -mx1 (fastest) ... -mx9 (ultra)         |\n| `-o{Directory}`  | set Output directory                                           |\n| `-p{Password}`   | set Password                                                   |\n| `-slt`           | show technical information for l (List) command                |\n| `-snh`           | store hard links as links                                      |\n| `-snl`           | store symbolic links as links                                  |\n| `-ssp`           | do not change Last Access Time of source files while archiving |\n| `-stx{Type}`     | exclude archive type                                           |\n| `-t{Type}`       | Set type of archive                                            |\n| `-y`             | assume Yes on all queries                                      |\n注意，它给出的形式是形如这种的：`-o{Directory}`，`-o`和后面的参数名是没有空格间隙的，否则无法识别。\n\n现在比如说，我想要解压缩`QuickGeometryUI.zip`到当前目录下的`dir`文件夹（未创建）：\n```sh\n7zz x QuickGeometryUI.zip -odir\n```\n\n我想要压缩当前目录所有文件（a、b、`.test`）到`my7zip`：\n```sh\n7zz a my7zip *\n```\n结果是：\n1. 只压缩了a、b，隐藏文件没有，因为`*`不会通配隐藏文件。\n2. 压缩包名字自动带上了后缀`my7zip.7z`\n所以，如果想要压缩包含隐藏文件，建议将其作为整个文件夹（放到了Test7zip目录中）压缩。\n```\n7zz a my7zip Test7zip\n```","categories":["一些工具的使用"]},{"title":"协程_Cpp协程","url":"/多线程/协程_Cpp协程/","content":"# 协程框架的解释\n怎么使用框架？\n写了摄像头的驱动，驱动有sdk，用户可以调用sdk，来驱动摄像头。\n摄像头是用什么形式的API写的？就不一定了，可能是C语言，可能是`C++`。`C++`可以按MFC提供，也可以按面向对象提供，也可以按类似于COM组件（接口）的形式提供，也可以按协程库的形式提供。\n此协程库框架，是给API厂商使用的。不是一个已经实现了的库，更像是一个中间件。\n比如我们想要提供一个读文件的函数给用户使用，readFile，从名字来看其一般是阻塞的，读完后才能返回。如果不想阻塞，则开辟一个线程，在新线程中让其readFile。\n非阻塞版本可以称其为`readFile_Async`。用户从名字上就能看到，这是非阻塞的，调用后主线程可以立即抽身去处理其他事情，在子线程执行完毕后，以回调的形式通知主线程。\n而在协程版本下的实现形式则不像传统线程间的回调形式（被割裂在两端），而是直接地写在了一个函数中，用`co_await`连接上下动作，此处的`co_await`的成功后的返回“相当于”回调函数。回调之后，就继续做`co_await`之后的动作即可。\n协程库框架还可以灵活切换协程所在的线程，比如切换到主线程、工作线程等等。也可以配置线程池。\n假如我们是一个厂商，现在使用该协程库框架开发一个readFile API：\n```cpp\n#include \"Agave.hpp\"\n#include <iostream>\nagave::AsyncAction read_file_async(void)\n{\n\n}\nagave::AsyncOperation<int> compute_async(void)\n{\n\n}\n```\n# 协程工作的总体流程\n协程的工作流，在形式上，是包装在一个函数中的。\n在函数中，间断地进行：work状态和`co_await`状态交替。\n假如，协程在t1线程上进行work状态。此时，需要`co_await`。\n`co_await`表示等待着某一个其他工作的结果。比如等待网络中传来的文件，等待下载完毕。在`co_await`时，此函数就会返回，协程暂停运行。`co_await`成功后，才能继续下面的操作。\n下面的操作，可能会在t2线程上进行work（也可能继续在t1，只是举个例子）。\n随后，可能还会进行`co_await`等操作。\n\n>看样子`co_await`表示的是“等待”的意思，但在协程的工作环境中，其实语义更像是\"不等了\"，“我先去处理别的事了，先走了”。有点儿异步的感觉。因为`co_await`语句使用时，会马上退出既有流程，直到被通知，才进行回调，从而返回work状态。\n\n从t1线程到t2线程的转变，相当于调用了一个callback。此callback是被`co_await`间隔的。\n\n由上述例子说明，协程和线程不冲突（或者说没关系），因为每次`co_await`成功后不一定会切换到另一个线程。\n# 创建项目\n先创建一个空项目。（Agave是根据`C++`标准协程库编写的，记得设置为20标准）\n再copy已有的4个文件（`Agave.cpp`、`B_Object.hpp`、`BJobScheduler.cpp`、`BJobScheduler.h`）到该空项目文件目录下。\n之后，右键VS项目中的`Header Files`，Add，Existing Item，选择`.hpp`和`.h`文件。\n右键`Source Files`，Add，Existing Item，选择`.cpp`文件。\n在`Source Files`中新建一个文件`demo.cpp`。在其中编写测试代码。\n## 初试1\n1. demo函数返回值是`agave::IAsyncAction`，则代表此函数是一个协程。\n2. 我们在main主线程中调用demo，即在主线程中创建此协程。\n3. demo协程在其中`co_await`，后面接的`read_file_async`可以看作是厂家的API。这个API的名称带有`async`，意味着它是一个异步的操作，在此`co_await XXX_async`语句后，会立即返回。但是不会进行下一步操作（输出读取完毕），而是暂时结束demo“函数”，直到`co_await`的操作（`read_file_async`）完成后，才继续demo之后的操作，相当于被callback。\n\n```cpp\n#include \"Agave.hpp\"\n#include <iostream>\n\nusing namespace std::chrono_literals;\n\nagave::AsyncAction read_file_async(void)\n{\n    std::cout << \"Read File Coroutine started on thread: \" << std::this_thread::get_id() << '\\n';\n    std::cout << \"Reading...\" << std::endl;\n    // 注意此处不能使用this_thread::sleep_for\n    // std::this_thread::sleep_for(5s); // error\n    co_await 5s; // 等待5秒，模拟文件读取\n    co_return; // 相当于callback\n}\nagave::AsyncAction demo()\n{\n    std::cout << \"demo() on thread: \" << std::this_thread::get_id() << '\\n';\n    co_await read_file_async();\n    std::cout << \"Reading finished on thread: \" << std::this_thread::get_id() << '\\n';\n}\nint main(void)\n{\n    std::cout << \"Main on thread: \" << std::this_thread::get_id() << '\\n';\n    auto action = demo();\n    // 主线程等待协程运行完毕\n    std::this_thread::sleep_for(8s);\n    return 0;\n}\n```\n### 关于为什么不能用`sleep_for`\n经测试，如果用`sleep_for`\n输出是这样：发现没有执行输出demo的第三个语句（Reading finished）\n```\nMain on thread: 25912\ndemo() on thread: 25912\nRead File Coroutine started on thread: 25912\nReading...\n\n(Program End)\n```\n为什么呢？且看下面的正常输出结果中对线程运行的分析。\n### 输出结果\n```\nMain on thread: 6260 \ndemo() on thread: 6260\nRead File Coroutine started on thread: 6260\nReading...\nReading finished on thread: 20516\n\n```\ndemo协程在主线程6260启动，另一个read协程也在主线程6260启动。而读取完毕后，demo协程此时却处于20516线程（内容是通知信息，通知read操作完毕）。\n>因此上面为什么在read协程函数中用`sleep_for`就不能正常打印最后一句话，可能和read协程函数调用`this_thread`睡眠导致主线程睡眠有关系。\n>\n>总之，测试的结果就是read协程睡眠后，再也没回到demo中去。\n\n这样的线程模式是不好的：\n1. demo协程在主线程启动无所谓，没事。\n2. 但是read协程以及read操作在主线程上就不妥了，应该将read操作另起一个线程\n3. 在read完毕callback后，执行demo中的第三句，应该给主线程通知才对，不应该通知给一个无关的线程。我们此例通知给了一个无关的线程，是因为read协程函数中`co_await 5s`会导致它另起一个时间线程。导致返回到demo中时，跑到了这个时间线程中去通知了。\n## 初试2\n更改模式，应该在read协程函数中另起线程，调用的是`co_await agave::resume_background()`。意为唤醒一个后台的线程。默认是即刻构造一个`std::jthread`。我们后期也可以拓展功能，将这个接口连接到一个线程池中，从线程池中拿取线程。\n在这种情况下，就可以使用`sleep_for`了。\n```cpp\n#include \"Agave.hpp\"\n#include <iostream>\n\nusing namespace std::chrono_literals;\n\nagave::AsyncAction read_file_async(void)\n{\n    co_await agave::resume_background(); // 另起线程\n    std::cout << \"Read File Coroutine started on thread: \" << std::this_thread::get_id() << '\\n';\n    std::cout << \"Reading...\" << std::endl;\n    \n    std::this_thread::sleep_for(5s);\n    \n    co_return; // 相当于callback\n}\nagave::AsyncAction demo()\n{\n    std::cout << \"demo() on thread: \" << std::this_thread::get_id() << '\\n';\n    co_await read_file_async();\n    std::cout << \"Reading finished on thread: \" << std::this_thread::get_id() << '\\n';\n}\nint main(void)\n{\n    std::cout << \"Main on thread: \" << std::this_thread::get_id() << '\\n';\n    auto action = demo();\n    // 主线程等待协程运行完毕\n    std::this_thread::sleep_for(8s);\n    return 0;\n}\n```\n输出结果：\n```\nMain on thread: 29580\ndemo() on thread: 29580\nRead File Coroutine started on thread: 15800\nReading...\nReading finished on thread: 15800\n\n```\n但是此时demo的read操作完毕消息还是没有发送给主线程，而是发送给了read另起的线程中。\n如何回到主线程呢？不同的操作系统具体实现不一样，但是我们可以自己写一个统一的接口`resume_mainThread`。在demo中的`co_await read_file_async`语句的下一条写下`co_await resume_mainThread()`。之后的输出操作便的在主线程中操作了。\n## 返回带值\n不返回东西时返回值类型写为`agave::IAsyncAction`。\n返回东西时，返回值类型写为`agave::IAsyncOperation<T>`。模板参数类型是要携带的值类型。\n对应地，`co_await`不能裸着用了，要用一个变量接收。\n```cpp\nagave::AsyncOperation<int> read_file_async(void)\n{\n    co_await agave::resume_background(); // 另起线程\n    std::cout << \"Read File Coroutine started on thread: \" << std::this_thread::get_id() << '\\n';\n    std::cout << \"Reading...\" << std::endl;\n    \n    std::this_thread::sleep_for(5s);\n    \n    co_return 50; // callback + 携带值\n}\n\nagave::AsyncAction demo()\n{\n    std::cout << \"demo() on thread: \" << std::this_thread::get_id() << '\\n';\n    \n    auto result = co_await read_file_async();\n    \n    std::cout << \"Reading finished: \" << result << \", on thread: \" << std::this_thread::get_id() << '\\n';\n}\n```\n# 协程取消\n1. 调用`co_await agave::get_cancellation_token()`获取一个此协程的取消变量。随时可以查看`can.is_canceled()`来判断是否有取消信号。\n2. 在其他线程中，通过`auto async_var = read_file_async()`拿到协程的标识，提供这个标识`async_var.cancel()`，来给该协程发送取消信号。\n\n```cpp\n#include \"Agave.hpp\"\n#include <iostream>\n\nusing namespace std::chrono_literals;\n\nagave::AsyncAction read_file_async(void)\n{\n    co_await agave::resume_background(); // 另起线程\n    auto can = co_await agave::get_cancellation_token();\n    std::cout << \"Read File Coroutine started on thread: \" << std::this_thread::get_id() << '\\n';\n    for (int i = 0; i < 5; ++i)\n    {\n        std::this_thread::sleep_for(1s);\n        if (can.is_canceled())\n        {\n            std::cout << \"Canceled on thread: \" << std::this_thread::get_id() << '\\n';\n            break;\n        }\n        else\n        {\n            std::cout << \"Reading... \" << i << std::endl;\n        }\n    }\n\n    co_return; // 相当于callback\n}\nagave::AsyncAction demo()\n{\n    std::cout << \"demo() on thread: \" << std::this_thread::get_id() << '\\n';\n    auto async_var = read_file_async();\n    std::this_thread::sleep_for(3s);\n    async_var.cancel();\n    co_await async_var;\n\n    std::cout << \"Reading finished on thread: \" << std::this_thread::get_id() << '\\n';\n\n}\nint main(void)\n{\n    std::cout << \"Main on thread: \" << std::this_thread::get_id() << '\\n';\n    auto action = demo();\n    // 主线程等待协程运行完毕\n    std::this_thread::sleep_for(8s);\n    return 0;\n}\n```\n输出：\n```\nMain on thread: 18768\ndemo() on thread: 18768\nRead File Coroutine started on thread: 19036\nReading... 0\nReading... 1\nCanceled on thread: 19036\nReading finished on thread: 19036\n\n```\n# Async的机制怎么实现\nAsync换句话来说是让函数（或任务）的结果在“成功之后”返回（但实际上函数调用后当即返回了）。如果是在C语言下做，是函数返回一个标号，我们在外部轮询一个范围的标号，如果有某个标号上有消息，再去获取它。\n# 场景\n```cpp\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <functional>\nusing namespace std::literals;\nvoid call_back();\nint main()\n{\n    std::wcout << L\"Main Thread Id: \" << std::this_thread::get_id() << std::endl;\n    std::jthread([](std::function<void(void)> cb) -> void\n        {\n            std::wcout << L\"Thread Id: \" << std::this_thread::get_id() << std::endl;\n            std::wcout << L\"doing on worker...\" << std::endl;\n            std::this_thread::sleep_for(5s);\n            cb();\n        }, call_back).join();\n    return 0;\n}\nvoid call_back()\n{\n    std::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n    std::wcout << L\"updating...\" << std::endl;\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"finish update!\" << std::endl;\n}\n```\n\n输出结果：\n```\nMain Thread Id: 39288           // Main Thread 是UI线程\nThread Id: 24632                // Worker 线程\ndoing on worker...\nupdate UI on Thread: 24632      // 更新不在UI线程上，这种的表现不好\nupdating...\nfinish update!\n\n```\n\n## 传统回调模式-工作线程自己执行cb\n```cpp\n// main.cpp\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <functional>\nusing namespace std::literals;\nvoid call_back();\nint main()\n{\n    std::wcout << L\"Main Thread Id: \" << std::this_thread::get_id() << std::endl;\n    std::jthread([](std::function<void(void)> cb) -> void\n    {\n        std::wcout << L\"Thread Id: \" << std::this_thread::get_id() << std::endl;\n        std::wcout << L\"doing on worker...\" << std::endl;\n        std::this_thread::sleep_for(5s);\n        cb();\n    }, call_back).join();\n    return 0;\n}\nvoid call_back()\n{\n    std::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n    std::wcout << L\"updating...\" << std::endl;\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"finish update!\" << std::endl;\n}\n```\n运行结果：\n```\nMain Thread Id: 23092\nThread Id: 11032\ndoing on worker...\nupdate UI on Thread: 11032\nupdating...\nfinish update!\n```\n发现，UI的改变是在工作者线程完成的，而不是UI线程。这是错误的。\n## 传统回调模式改进-消息队列-工作者线程传送cb函数对象到main\n现在，加一个消息任务队列，工作者线程可以添加cb函数对象到此队列。\n然后，主线程（UI线程）可以循环去任务队列拿。拿出一个cb函数对象，由UI线程亲自调用。\n这样就可以达到在UI线程上更改内容。\n```cpp\n// main.cpp\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <functional>\n#include \"TaskQueue.h\"\nusing namespace std::literals;\nvoid call_back();\nTaskQueue queue;\n\nvoid run_on_main(std::function<void(void)> fn);\nint main()\n{\n    std::wcout << L\"Main Thread Id: \" << std::this_thread::get_id() << std::endl;\n    std::jthread([](std::function<void(void)> cb) -> void\n        {\n            std::wcout << L\"Thread Id: \" << std::this_thread::get_id() << std::endl;\n            std::wcout << L\"doing on worker...\" << std::endl;\n            std::this_thread::sleep_for(5s);\n            run_on_main(cb);\n        }, call_back).detach();\n    queue.run();\n    return 0;\n}\nvoid call_back()\n{\n    std::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n    std::wcout << L\"updating...\" << std::endl;\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"finish update!\" << std::endl;\n}\nvoid run_on_main(std::function<void(void)> fn)\n{\n    queue.add_task(fn);\n}\n\n```\n### TaskQueue\n```cpp\n// TaskQueue.h\n#pragma once\n#include <list>\n#include <functional>\n#include <condition_variable>\n#include <mutex>\nusing Task = std::function<void(void)>;\nclass TaskQueue\n{\npublic:\n    void add_task(Task task);\n    void run(void);\nprivate:\n    std::list<Task> _task_queue;\n    std::condition_variable _cv;\n    std::mutex _mx;\n};\n-----------------------------------\n// TaskQueue.cpp\n#include \"TaskQueue.h\"\nvoid TaskQueue::add_task(Task task)\n{\n    std::unique_lock lck{ _mx };\n    _task_queue.push_back(task);\n    _cv.notify_one();\n}\nvoid TaskQueue::run()\n{\n    std::list<Task> queue;\n    std::unique_lock lck{ _mx };\n    while (true)\n    {\n        _cv.wait(lck, [this]()->bool { return _task_queue.size() > 0; });\n        if (!_task_queue.empty())\n        {\n            _task_queue.swap(queue);\n        }\n        lck.unlock();\n        while (queue.size() > 0)\n        {\n            auto task = queue.front();\n            queue.pop_front();\n            task();\n        }\n        lck.lock();\n    }\n}\n```\n### 结果\n```\nMain Thread Id: 41388         // Main Thread 是UI线程\nThread Id: 45076              // Worker线程\ndoing on worker...\nupdate UI on Thread: 41388    // 发现，工作在UI线程，成功。\nupdating...\nfinish update!\n```\n## 使用协程-自动启动新线程\n```cpp\nint main()\n{\n    std::wcout << L\"Main Thread Id: \" << std::this_thread::get_id() << std::endl;\n    DoWorkAsync().get();\n    return 0;\n}\nagave::AsyncAction DoWorkAsync()\n{\n    std::wcout << L\"DoWorkAsync started on thread: \" << std::this_thread::get_id() << std::endl;\n    \n    // 切换到一个新线程，后台执行下面的语句\n    co_await agave::resume_background();\n    \n    std::wcout << L\"doing on worker: \" << std::this_thread::get_id() << std::endl;\n    std::this_thread::sleep_for(5s);\n\n    std::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n    std::wcout << L\"updating...\" << std::endl;\n    std::this_thread::sleep_for(3s);\n\n    std::wcout << L\"finish update!\" << std::endl;\n    \n}\n```\n结果\n```\nMain Thread Id: 1984\ndoing on worker: 12268\nupdate UI on Thread: 12268\nupdating...\nfinish update!\n```\n以上程序由于在协程函数中，worker线程操作完成后，没有切换到前台UI线程。所以UI更新错误地在worker线程中执行。\n应该加一个切换到主线程。\n```cpp\nagave::AsyncAction DoWorkAsync()\n{\n    std::wcout << L\"DoWorkAsync started on thread: \" << std::this_thread::get_id() << std::endl;\n    \n    // 切换到一个新线程，后台执行下面的语句\n    co_await agave::resume_background();\n    \n    std::wcout << L\"doing on worker: \" << std::this_thread::get_id() << std::endl;\n    std::this_thread::sleep_for(5s);\n\n    co_await agave::resume_foreground();\n\n    std::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n    std::wcout << L\"updating...\" << std::endl;\n    std::this_thread::sleep_for(3s);\n\n    std::wcout << L\"finish update!\" << std::endl; \n}\n```\n结果：\n```\nMain Thread Id: 8796\ndoing on worker: 25564\nupdate UI on Thread: 25564\nupdating...\nfinish update!\n```\n现在，加了一句切换到前台，但是最终UI更新还是在worker线程上。\n这是因为，我们是以同步方式完成协程的：`DoWorkAsync().get();`。所以无法切换。\n### 结合消息队列\n去掉`DoWorkAsync()`后面的`get()`。异步形式执行。\n```cpp\nagave::AsyncAction DoWorkAsync();\nint main()\n{\n    agave::set_fg_entry([](std::function<void(void)> procedure)\n    {\n        queue.add_task(procedure);\n    });\n    std::wcout << L\"Main Thread Id: \" << std::this_thread::get_id() << std::endl;\n    \n    DoWorkAsync();\n    queue.run();\n}\nagave::AsyncAction DoWorkAsync()\n{\n    std::wcout << L\"DoWorkAsync started on thread: \" << std::this_thread::get_id() << std::endl;\n    \n    // 切换到一个新线程，后台执行下面的语句\n    co_await agave::resume_background();\n    \n    std::wcout << L\"doing on worker: \" << std::this_thread::get_id() << std::endl;\n    std::this_thread::sleep_for(5s);\n\n    // main函数中，设置了前台fg入口，下面的内容就会打包成一个函数对象，传给前台。\n    co_await agave::resume_foreground();\n\n    std::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n    std::wcout << L\"updating...\" << std::endl;\n    std::this_thread::sleep_for(3s);\n\n    std::wcout << L\"finish update!\" << std::endl; \n}\n```\n\n结果：\n```\nMain Thread Id: 2936\ndoing on worker: 10572\nupdate UI on Thread: 2936\nupdating...\nfinish update!\n```\n\n# UI和worker协同工作示例\n```cpp\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <functional>\n#include \"TaskQueue.h\"\n#include \"../Agave/Agave.hpp\"\n\nusing namespace std::chrono_literals;\n\nvoid call_back(void);\nvoid run_on_main(std::function<void(void)> fn);\nTaskQueue queue;\nagave::AsyncAction DoWorkAsync(void);\n\nint main(void)\n{\n\tagave::set_fg_entry([](std::function<void(void)> procedure)\n\t\t{ queue.add_task(procedure); });\n\n\t/*agave::set_bg_entry([](std::function<void(void)> procedure)\n\t\t{ std::jthread{ procedure }.detach(); });*/\n\n\tstd::wcout << L\"Main Thread Id: \" << std::this_thread::get_id() << std::endl;\n\n\tstd::jthread{ []()\n    {\n        for (int i = 0; i < 20; ++i)\n        {\n            run_on_main([]()\n                {\n                    std::wcout << L\"doing on UI Thread: \" << std::this_thread::get_id() << std::endl;\n                });\n            std::this_thread::sleep_for(350ms);\n        }\n    } }.detach();\n\t\n\n\t/*std::jthread([](std::function<void(void)> cb) -> void\n    {\n        std::wcout << L\"doing on worker: \" << std::this_thread::get_id() << std::endl;\n        std::this_thread::sleep_for(5s);\n        run_on_main(cb);\n    }, call_back).detach();*/\n\tDoWorkAsync();\n\n\tqueue.run();\n\n\treturn 0;\n}\n\nvoid call_back(void)\n{\n\tstd::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n\tstd::wcout << L\"updating...\" << std::endl;\n\tstd::this_thread::sleep_for(3s);\n\tstd::wcout << L\"finish update!\" << std::endl;\n}\n\nvoid run_on_main(std::function<void(void)> fn)\n{\n\tqueue.add_task(fn);\n}\n\nagave::AsyncAction DoWorkAsync(void)\n{\n\tco_await agave::resume_background();\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tstd::wcout << L\"doing on worker: \" << std::this_thread::get_id() << std::endl;\n\t\tstd::this_thread::sleep_for(500ms);\n\t}\n\t//co_await 5s;\n\t//std::wcout << L\"doing on worker2: \" << std::this_thread::get_id() << std::endl;\n\tco_await agave::resume_foreground();\n\tstd::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n\tstd::wcout << L\"updating...\" << std::endl;\n\tstd::this_thread::sleep_for(3s);\n\tstd::wcout << L\"finish update!\" << std::endl;\n\n\tco_return;\n}\n\n```\n# 厂商模拟开发异步SDK示例\n```cpp\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <functional>\n#include \"TaskQueue.h\"\n#include \"../Agave/Agave.hpp\"\n#include \"manufacturer.h\"\n\nusing namespace std::chrono_literals;\n\nvoid run_on_main(std::function<void(void)> fn);\nTaskQueue queue;\nagave::AsyncAction DoWorkAsync(void);\nagave::AsyncAction DoWorkAsync2(void);\n\nint main(void)\n{\n\tagave::set_fg_entry([](std::function<void(void)> procedure)\n\t\t{ queue.add_task(procedure); });\n\n\tstd::wcout << L\"Main Thread Id: \" << std::this_thread::get_id() << std::endl;\n\n\tstd::jthread{ []()\n    {\n        for (int i = 0; i < 20; ++i)\n        {\n            run_on_main([]()\n                {\n                    std::wcout << L\"doing on UI Thread: \" << std::this_thread::get_id() << std::endl;\n                });\n            std::this_thread::sleep_for(350ms);\n        }\n    } }.detach();\n\t\n\tDoWorkAsync2();\n\n\tqueue.run();\n\n\treturn 0;\n}\n\nagave::AsyncAction DoWorkAsync2(void)\n{\n\tint result = co_await ReadFileAsync(L\"aa.txt\");\n\tco_await agave::resume_foreground();\n\tstd::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n\tstd::wcout << L\"got a result: \" << result << std::endl;\n}\n\nvoid run_on_main(std::function<void(void)> fn)\n{\n\tqueue.add_task(fn);\n}\n\nagave::AsyncAction DoWorkAsync(void)\n{\n\tco_await agave::resume_background();\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tstd::wcout << L\"doing on worker: \" << std::this_thread::get_id() << std::endl;\n\t\tstd::this_thread::sleep_for(500ms);\n\t}\n\t//co_await 5s;\n\t//std::wcout << L\"doing on worker2: \" << std::this_thread::get_id() << std::endl;\n\tco_await agave::resume_foreground();\n\tstd::wcout << L\"update UI on Thread: \" << std::this_thread::get_id() << std::endl;\n\tstd::wcout << L\"updating...\" << std::endl;\n\tstd::this_thread::sleep_for(3s);\n\tstd::wcout << L\"finish update!\" << std::endl;\n\n\tco_return;\n}\n```","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"基于消息循环的UI线程与工作线程交互模型","url":"/多线程/基于消息循环的UI线程与工作线程交互模型/","content":"# 以UI线程和工作线程之间的交互为切入点\n有两个线程，UI线程和文件下载线程（下面成为称为工作者线程）。UI线程点“接收文件”按钮后启动工作者线程，之后两线程异步执行。假设工作者线程每下载、传输文件的10%都要通知UI线程，以在UI界面进度条显示进度。\n由于两线程是异步、无关联的，那么就涉及到工作者线程怎么与UI线程交互的问题。工作者线程不能直接操作UI线程，否则会扰乱UI线程中的部件、内容等，而是要通过发送一个消息，指示UI线程自己去调整。\n可以考虑设置一个回调函数。\n![](../../images/基于消息循环的UI线程与工作线程交互模型/image-20240726050511238.png)\n# 简单示例\n```cpp\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <functional>\nusing namespace std::chrono_literals;\nvoid worker(std::function<void(std::wstring const& str)> callback)\n{\n    std::wcout << L\"doing something in \" << std::this_thread::get_id() << std::endl;\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"call callback!\" << std::endl;\n    callback(L\"worker called\");\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"worker finished!\" << std::endl;\n}\nint main()\n{\n    std::wcout << L\"UI: \" << std::this_thread::get_id() << std::endl;\n    // 工作者线程\n    std::jthread t(&worker, [](std::wstring const& str) -> void\n        {\n            std::wcout << str << L\" in \" << std::this_thread::get_id() << std::endl;\n        });\n}\n```\n输出：\n```\nUI: 1452\ndoing something in 8864\ncall callback!\nworker called in 8864\nworker finished!\n```\nUI线程ID号为1452，工作者线程ID号为8864。\n而回调函数是在工作者线程中调用的。\n现在我们的需求就是工作者线程要和UI线程产生关联，所以要想办法如何转移线程，让回调函数被UI线程调用。\n\n以上程序：\n1. UI线程通过向线程构造函数传参，为worker函数绑定一个回调函数，这个回调函数以lambda表达式定义。\n2. worker函数很容易调用参数“callback”。\n3. 问题是，worker线程怎么通过“callback”与UI线程交互？\n4. 答案就是让它们以消息队列为媒介。worker线程择机（比如每下载10%）把callback和一些实时数据信息打包发到消息队列中，UI线程监听消息队列消息，只要有了，就自己亲自调用一遍worker线程踢回来的callback函数。\n5. UI线程为什么不自己早早地亲自调用callback，还要踢皮球？区别是什么呢？是因为worker线程可以夹带实时数据信息。\n# 消息循环队列\n## 自旋锁版本1\n以下是，取一次消息则上一次锁、开一次锁。\n```cpp\nstd::list<std::function<void(void)>> msg_queue;\nstd::mutex mx;\n\nint main()\n{\n    std::wcout << L\"UI: \" << std::this_thread::get_id() << std::endl;\n    std::jthread t(&worker, []() -> void\n        {\n            std::wcout << L\"callback\" << L\" in \" << std::this_thread::get_id() << std::endl;\n        });\n    \n    while (true)\n    {\n        if (mx.try_lock())\n        {\n            if (msg_queue.size() > 0)\n            {\n                auto cb = msg_queue.front();\n                msg_queue.pop_front();\n                cb();  // call back in UI\n            }\n            mx.unlock();\n        }\n    }\n}\n```\n## 自旋锁版本2\n还有一种效率较高的方法：把消息队列和一个空队列交换，即一次性抽空队列中所有的消息，之后及时加锁，然后就可以放心地去处理消息了。这样避免了频繁加锁。\n>以下的机制是自旋锁。\n```cpp\nint main()\n{\n    std::wcout << L\"UI: \" << std::this_thread::get_id() << std::endl;\n    std::jthread t(&worker, []() -> void\n        {\n            std::wcout << L\"callback\" << L\" in \" << std::this_thread::get_id() << std::endl;\n        });\n        \n    while (true)\n    {\n        if (mx.try_lock())\n        {\n            if (msg_queue.size() > 0)\n            {\n                std::list<std::function<void(void)>> tmp_msg_queue;\n                msg_queue.swap(tmp_msg_queue);\n                mx.unlock();\n                std::ranges::for_each(tmp_msg_queue, [](auto && cb) -> void\n                    {\n                        cb();\n                    });\n            }\n            else mx.unlock();\n        }\n        std::this_thread::sleep_for(10ms);\n    }\n}\n```\n怎么让worker踢皮球给UI线程呢？那就是worker线程拿到控制消息队列的锁，然后发送消息和数据到消息队列中。这两个步骤可以集成一个`run_in_main(callback)`函数。\n```cpp\nvoid run_in_main(std::function<void(void)> cb);\nvoid worker(std::function<void(void)> callback)\n{\n    // ...\n    run_in_main(callback);\n    // ...\n}\nvoid run_in_main(std::function<void(void)> cb)\n{\n    std::unique_lock lck(mx);\n    msg_queue.push_back(cb);\n}\n```\n输出：\n```\nUI: 2060\ndoing something in 13436\ncall callback!\ncallback in 2060\nworker finished!\n```\n发现，现在的回调函数调用者成为了UI线程。\n## 条件变量版本\n>条件变量控制版本：比自旋锁节省CPU\n\n```cpp\n// ...\nvoid run_in_main(std::function<void(void)> cb)\n{\n    {\n        std::unique_lock lck(mx);\n        msg_queue.push_back(cb);\n    }   \n    cv.notify_all();\n}\nint main()\n{\n    std::wcout << L\"UI: \" << std::this_thread::get_id() << std::endl;\n    std::jthread t(&worker, []() -> void\n        {\n            std::wcout << L\"callback\" << L\" in \" << std::this_thread::get_id() << std::endl;\n        });\n    while (true)\n    {\n        std::unique_lock lck{ mx };\n        if (msg_queue.size() > 0)\n        {\n            std::list<std::function<void(void)>> tmp_msg_queue;\n            msg_queue.swap(tmp_msg_queue);\n            lck.unlock();\n            std::ranges::for_each(tmp_msg_queue,\n                [](auto && cb) -> void\n                {\n                    cb();\n                });\n        }\n        else\n        {\n            cv.wait(lck);\n        }\n    }\n}\n```\n测试：以下worker线程模拟向消息队列投放了两次消息。\n```cpp\nvoid worker(std::function<void(void)> callback)\n{\n    std::wcout << L\"doing something in \" << std::this_thread::get_id() << std::endl;\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"call callback!\" << std::endl;\n    run_in_main(callback);\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"call callback!\" << std::endl;\n    run_in_main(callback);\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"worker finished!\" << std::endl;\n}\n```\n输出：\n```\nUI: 5888\ndoing something in 18988\ncall callback!\ncallback in 5888\ncall callback!\ncallback in 5888\nworker finished!\n```\n# bind函数绑定\n怎么把`有参数的函数`传给`无参数的函数对象`？\n```cpp\nvoid bar(int v)\n{\n    std::cout << v << std::endl;\n}\nint main()\n{\n    std::function<void(void)> foo = &bar;  // error\n}\n```\n正确：\n```cpp\nvoid bar(int v)\n{\n    std::wcout << L\"bar(int): \" << v << std::endl;\n}\nint main()\n{\n    std::function<void(void)> foo = std::bind(&bar, 5); // ok\n    foo();\n}\n```\n输出：5\n## 结合callback\n```cpp\nvoid run_in_main(std::function<void(void)> cb);\nvoid bar(int v);\n\nvoid worker(std::function<void(void)> callback)\n{\n    // ...\n    run_in_main(std::bind(&bar, 555));\n    // ...\n}\n```\n输出：\n```\nUI: 23520\ndoing something in 4556\ncall callback!\ncallback in 23520\nbar(int): 555\nworker finished!\n```\n那么，我们可以在main线程创建子线程时，直接给子线程传入一个函数绑定器：\n```cpp\nint main()\n{\n    std::jthread t(&worker, std::bind(&bar, 555));\n}\n```\n这样，就不拘泥于worker函数参数callback的`<void(void)>`形式了。\n### 完整测试代码\n```cpp\n#include <functional>\n#include<list>\n#include<iostream>\n#include<mutex>\n#include<condition_variable>\n#include<thread>\n#include<chrono>\n#include<algorithm>\nusing namespace std::chrono_literals;\nstd::list<std::function<void(void)>> msg_queue;\nstd::mutex mx;\nstd::condition_variable cv;\nvoid bar(int v)\n{\n    std::wcout << L\"bar(int): \" << v << std::endl;\n}\nvoid run_in_main(std::function<void(void)> cb)\n{\n    {\n        std::unique_lock lck(mx);\n        msg_queue.push_back(cb);\n    }\n    cv.notify_all();\n}\nvoid worker(std::function<void(void)> callback)\n{\n    std::wcout << L\"doing something in \" << std::this_thread::get_id() << std::endl;\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"call callback!\" << std::endl;\n    run_in_main(callback);\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"call callback!\" << std::endl;\n    run_in_main(callback);\n    std::this_thread::sleep_for(3s);\n    std::wcout << L\"worker finished!\" << std::endl;\n}\nint main()\n{\n    std::wcout << L\"UI: \" << std::this_thread::get_id() << std::endl;\n    std::jthread t(&worker, std::bind(&bar, 555));\n    while (true)\n    {\n        std::unique_lock lck{ mx };\n        if (msg_queue.size() > 0)\n        {\n            std::list<std::function<void(void)>> tmp_msg_queue;\n            msg_queue.swap(tmp_msg_queue);\n            lck.unlock();\n            std::ranges::for_each(tmp_msg_queue,\n                [](auto&& cb) -> void\n                {\n                    cb();\n                });\n        }\n        else\n        {\n            cv.wait(lck);\n        }\n    }\n}\n```\n输出：\n```\nUI: 82576\ndoing something in 84588\ncall callback!\nbar(int): 555\ncall callback!\nbar(int): 555\nworker finished!\n```\n","categories":["操作系统","多线程","设计模式"]},{"title":"Hexo搭建博客","url":"/项目/Hexo搭建博客/","content":"# 安装Hexo\n\n参考：[文档 | Hexo](https://hexo.io/zh-cn/docs/)\n\n1. 安装[Node.js](https://nodejs.org/en)\n2. 命令行npm全局安装hexo-cli：`$ npm install -g hexo-cli`\n## Mac\n```sh\nnode@20 is keg-only, which means it was not symlinked into /opt/homebrew,\nbecause this is an alternate version of another formula.\n\nIf you need to have node@20 first in your PATH, run:\n  echo 'export PATH=\"/opt/homebrew/opt/node@20/bin:$PATH\"' >> ~/.zshrc\n\nFor compilers to find node@20 you may need to set:\n  export LDFLAGS=\"-L/opt/homebrew/opt/node@20/lib\"\n  export CPPFLAGS=\"-I/opt/homebrew/opt/node@20/include\"\n```\n添加PATH后记得重启终端才能生效。\n# 测试hexo init\n\n在空文件夹下`$ hexo init`。\n\n相当于执行了以下几步：\n1. 远程拷贝了：Git clone [hexo-starter](https://github.com/hexojs/hexo-starter) 和 [hexo-theme-landscape](https://github.com/hexojs/hexo-theme-landscape) 主题到当前目录或指定目录。\n2. 使用了： [Yarn 1](https://classic.yarnpkg.com/lang/en/)、[pnpm](https://pnpm.io/zh/) 或 [npm](https://docs.npmjs.com/cli/install) 包管理器下载局部hexo的依赖（如有已安装多个，则列在前面的优先）。npm 默认随 [Node.js](https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85-Node-js) 安装。\n\n# 测试hexo g\n\n生成静态文件。\n\n# 测试hexo s\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项               | 描述              |\n| ---------------- | --------------- |\n| `-p`, `--port`   | 重设端口            |\n| `-s`, `--static` | 只使用静态文件         |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n# 恢复已有环境\n\n以下是精简了的去除了可后期生成的必要的raw文件：\n![](../../images/Hexo搭建博客/image-20240430192607218.png)\n\n由于没有hexo和其他依赖，在重新生成数据时，需要先进行：`npm install`根据`package.json`指定的信息安装依赖包。\n\n然后才可以在此文件夹下`$ hexo g`。\n\n注意，db.json是比较重要的数据文件，里面记录了hexo的操作，生成的数据时间戳、逻辑关系都以此为准。","categories":["一些工具的使用"]},{"title":"操作系统字符集、乱码问题","url":"/一些工具的使用/操作系统字符集、乱码问题/","content":"[解决vscode控制台中文乱码问题 - 无风听海 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wufengtinghai/p/17397829.html)\n# 问题概述\n\n操作系统使用的windows 11，语言是英文版；使用visual studio code的terminal编译程序，输出的中文是乱码；\n# visual studio code的terminal\n\nvisual sutdio code中的terminal可以集成cmd.exe或者power shell等；我这里选择的是cmd.exe，既然输出中文乱码，那么肯定跟cmd.exe的编码有关系；\n\n查看当前控制台程序的编码格式\n```dos\nD:\\learn\\.NET6\\WebAPI\\BookStoreApi>chcp\nActive code page: 437\n```\n以下是几种常用的编码:  \n`936` GBK(一般情况下为默认编码)  \n`437` 美国英语  \n`65001` utf-8\n\n设置CMD窗口编码格式为UTF-8:\n```dos\nD:\\learn\\.NET6\\WebAPI\\BookStoreApi>chcp 65001\nActive code page: 65001\n```\n这个修改只对当前窗口会话有效；\n\n# 全局修改方式\n\n`Win + R`输入`intl.cpl`命令，在弹出的框体中选择`Administrative`标签，然后选择`change system local`，然后选中最下方的复选框 `Beta:Use Unicode UTF-8 for worldwide language support`,然后重启操作系统即可。","categories":["一些工具的使用"]},{"title":"网络_SMB共享文件","url":"/网络/网络_SMB共享文件/","content":"本文是基于OpenWRT下的SMB4共享。\n# Linux系统添加SMB用户、密码\nLinux上SMB的用户和Linux用户是两码事。SMB需要另外单独添加用户。\n```sh\nsmbpasswd -a root\n```\n# OpenWRT设置\n## 磁盘新建分区、格式化、挂载\n\n1. 在`系统 -> 磁盘管理`下查看磁盘，点击“弹出”右边的`修改`按钮，可以看到分区信息。新建分区，并格式化为ext4。\n2. 之后，去`系统 -> 挂载点`下配置添加挂载，基本设置中，启用此挂载点，UUID选择相应选项，挂载点自定义，手写：如`/mnt/shared`。高级设置，文件系统选择ext4。\n3. 记得点`保存&应用`。\n## 配置SMB挂载\n\n在openwrt的`网络存储 -> 网络共享`页面进行设置：\n\n| name   | 目录          | 容许用户 | 只读   | 可浏览 | 创建权限掩码 | 目录权限掩码 |\n| ------ | ----------- | ---- | ---- | --- | ------ | ------ |\n| shared | /mnt/shared | root | 取消勾选 | 勾选  | 默认0666 | 默认0777 |\n上边的“启用macOS兼容共享”经测试，不用勾选。\n\n也可以直接修改配置文件：\n```sh\nvim /etc/config/samba4\n```\n>但是在`/etc/samba/smb.conf`文件中也有非常类似的设置，还不清楚这两个配置文件之间的从属关系。\n## 相关命令\n```sh\n# 启动服务\nservice samba4 start\n# 停止服务\nservice samba4 stop\n# 重启服务\nservice samba4 restart\n# 服务状态\nservice samba4 status\n\n# 配置文件检查\ntestparm -v\n```\n# smb输入root账户和密码后拒绝访问\n\n系统默认不允许root访问samba，需要配置`smb.conf.template`在`invalid users = root`前添加一个#号，将本行注释掉即可，这样root就不会被限制访问samba了。\n查找`smb.conf.template`文件：\n```sh\nfind / -name smb.conf.template\n```\n# 卸载磁盘时device is busy的处理\n\n`lsof` + 挂载目录位置，如：`lsof /mnt/shared`\n出来列表，kill掉相应的PID即可。\n如果是macOS连接过此SMB，kill掉会自动重连，需要在macOS上弹出才行。\n# 挂载目录文件系统问题\n\n共享目录最好使用`Ext4`文件系统， 因为NTFS或ExFAT在macOS系统下会提示错误码100093。主要原因可能为samba4对NTFS或ExFAT文件系统使用Windows权限控制机制（openwrt是基于Linux的，使用的文件系统一般为ext4）导致权限混乱无法正常写入文件。\n","categories":["网络"]},{"title":"Windows_多线程","url":"/Windows/Windows_多线程/","content":"# 进程和线程的关系\n1. 进程是程序的运行实例。包含全局变量。\n2. 一个进程至少包含一个线程\n3. 程序运行的最小单位是函数，线程则是函数的运行实例。\n4. 线程是操作系统的术语，而对于处理器来说线程是任务，每个逻辑处理器（或是处理器核心）都可以对应一个线程，并且可以在一个处理器上同时运行不同进程的线程。\n5. 线程中包含线程栈。\n# 卖票程序\n```cpp\n#include <iostream>\nconstinit int tickets = 100;\nint main()\n{\n    while (true)\n    {\n        std::wcout << L\"Station main: \" << tickets-- << std::endl;\n        if (tickets == 0)\n        {\n            break;\n        }\n    }   \n}\n```\n## CreateThread创建线程\n官方文档：[CreateThread function (processthreadsapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)\n\n通常引入`<Windows.h>`即可使用。\n![](../../images/Windows_多线程/image-20240722053312495.png)\n\n1. 可选，LP即long pointer，看作pointer就行。Security Attributes意为安全描述符。\n    1. 用于ACLs，Access Control Lists。微软常用的手段，哪些东西可以访问，有什么权限等等。可以填NULL得到默认的安全描述符。\n2. 线程栈大小，填 0 意为默认值，Windows下是1M，Linux是4M。\n3. 线程函数的地址，告知线程具体从哪里执行。需要遵循函数签名。[ThreadProc callback function (Windows) | Microsoft Learn](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms686736(v=vs.85))\n    1. `DWORD WINAPI ThreadProc(_In_ LPVOID lpParameter);`\n        1. 以上是线程函数的签名形式。返回值为0代表线程函数执行成功。\n    2. LPVOID指的是`void *`\n    3. `_In_`是一个 SAL（Source Annotation Language）宏， 用于注释 Windows API 函数参数。它提供有关函数参数的额外信息，以帮助编译器进行静态分析和代码检查。我们可以省略。\n    4. WINAPI指`__stdcall`\n    5. 因此可以简化为：`DWORD WINAPI ThreadProc(void * lpParameter);`\n    6. `C++`中传入函数地址时，需要在函数名字之前加一个`&`取地址。\n4. 可选，函数的参数\n5. 线程的控制符。\n    1. 0表示创建后立即执行\n    2. `CREATE_SUSPENDED`表示创建后挂起，直到调用ResumeThread\n6. 可选，输出值，给一个指针可以获得线程ID。此线程ID与Handle不同。可填NULL。\n7. 返回值：如果创建成功，返回此线程的句柄。\n\n创建完线程并执行后，需要关闭Handle，但这不意味着关闭线程，只不过是说此句柄不再绑定这个线程，不对线程进行管理了，那么线程运行结束之后就会自行停止。\n```cpp\n#include <Windows.h>\n#include <iostream>\n#include <format>\n#include <print>\nconstinit int tickets = 10;\nDWORD WINAPI ThreadProc(void* lpParameter);\nint main()\n{\n    // start a new thread\n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    if (hThread) ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    while (true)\n    {\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station main: \" << tickets-- << std::endl;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\nDWORD WINAPI ThreadProc(void* parameter)\n{\n    while (true)\n    {\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station 1: \" << tickets-- << std::endl;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return 0;\n}\n```\n可能在输出结果中看到两个线程抢占式的输出，导致内容杂乱。\n```\nStation main: 10Station 1: 9\n\nStation main: 8\nStation main: 7\nStation main: 6\nStation 1: 5\nStation 1: 4\nStation 1: 3\nStation 1: 2\nStation main: 1\nStation 1: 0\n\n```\n以上输出有两个问题：\n1. 还未换行时，线程被抢占。导致换行延后。多行内容在一行显示\n2. 子线程把0号票卖掉了，这是错误的。\n\n关于输出问题，可以用`C++20<format>`的`std::format`或者`C++23<print>`的`std::print`解决。\n```cpp\nstd::wcout << std::format(L\"Station main: {}\\n\", tickets--);\n```\n或\n```cpp\nstd::println(\"Station main: {}\", tickets--);\n```\n\n## Sleep把时间片放大，观察错误\n通过sleep把时间片放大，可以让多线程中隐患的几率增大。\n>Windows下的Sleep定义于`Windows.h`，参数是毫秒。\n\n```cpp\n#include <Windows.h>\n#include <iostream>\n#include <format>\n#include <print>\nconstinit int tickets = 10;\nDWORD WINAPI ThreadProc(void* lpParameter);\nint main()\n{\n    // start a new thread\n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    if (hThread) ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    while (true)\n    {\n        if (tickets > 0)\n        {\n            ::Sleep(5);\n            std::println(\"Station main: {}\", tickets--);\n        }\n        else\n        {\n            break;\n        }\n    }\n    ::Sleep(500);\n    std::println(\"Finally, tickets remain: {}\", tickets);\n    return 0;\n}\nDWORD WINAPI ThreadProc(void* parameter)\n{\n    while (true)\n    {\n        if (tickets > 0)\n        {\n            ::Sleep(5);\n            std::println(\"Station 1: {}\", tickets--);\n        }\n        else\n        {\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n最后可能输出的情况：main线程把0号票卖了，最后导致票余量为-1。\n```\nStation main: 9\nStation 1: 10\nStation 1: 8\nStation main: 7\nStation main: 6\nStation 1: 6\nStation main: 4\nStation 1: 5\nStation main: 3\nStation 1: 2\nStation 1: 1\nStation main: 0\nFinally, tickets remain: -1\n\n```\n可能的情况：main线程判断tickets为1后准备卖票，睡了5ms期间被1线程卖掉了最后一张票，之后main线程唤醒后是不知道的，依旧减了票量到-1。\n\n>我们发现，如果使用的是`std::println`，0号票卖掉的概率大大下降。大多数情况剩余票数为0（正确行为）。这可能是因为`std::println`/控制台输出内部通常有锁，调用很“重”，会让线程轮换得更慢，进一步降低了极端交错（比如刚好重读为 0 再减）的概率。但这样对 `tickets` 的访问并不会变安全。\n>总结：控制台输出里自带锁，反而会“串行化”一部分时间，**不利**于制造极端交错。\n## CreateMutex创建互斥量\n[CreateMutexW function (synchapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexw)\n\n通常引入`<Windows.h>`即可使用。\n![](../../images/Windows_多线程/image-20240722060820211.png)\n1. 可选，安全描述符，可填NULL获得默认的。\n2. 是否起始就占有互斥量：此时的线程是不是立马持有互斥量而其他线程无法访问。\n3. 可选，名字。\n4. 返回值是句柄。\n\n在此例我们要给这个互斥量一个全局可访问的句柄。\n## WaitForSingleObject - 加锁\n在临界区之前需要`WaitForSingleObject`等待互斥量的信号。相当于加锁\n[WaitForSingleObject function (synchapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)\n通常引入`<Windows.h>`即可使用。\n![](../../images/Windows_多线程/image-20240722061633660.png)\n1. 指明等待的对象的句柄\n2. 等待的时间\n    1. 可填非0的值\n    2. 如果填0，而没有信号，则会立即返回，一直重复试探、空转。\n    3. 可以填INFINITE，无限期等下去。\n## ReleaseMutex - 释放互斥量\n临界区后需要`ReleaseMutex(hMutex)`释放互斥量。而且要注意，在if语句的每个情况下都需要写释放锁语句。\n### 卖票代码\n```cpp\n#include <Windows.h>\n#include <iostream>\n#include <print>\nconstinit int tickets = 10;\nconstinit HANDLE hMutex = nullptr;\nDWORD WINAPI ThreadProc(void* lpParameter);\nint main()\n{\n    hMutex = ::CreateMutex(nullptr, false, nullptr);\n    // start a new thread\n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    if (hThread) ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    while (true)\n    {\n        ::WaitForSingleObject(hMutex, INFINITE);\n        if (tickets > 0)\n        {\n            ::Sleep(5);\n            std::println(\"Station main: {}\", tickets--);\n            ::ReleaseMutex(hMutex);\n        }\n        else\n        {\n            ::ReleaseMutex(hMutex);\n            break;\n        }\n    }\n    ::Sleep(500);\n    ::CloseHandle(hMutex);\n    hMutex = nullptr;\n    std::println(\"Finally, tickets remain: {}\", tickets);\n    return 0;\n}\nDWORD WINAPI ThreadProc(void* parameter)\n{\n    while (true)\n    {\n        ::WaitForSingleObject(hMutex, INFINITE);\n        if (tickets > 0)\n        {\n            ::Sleep(5);\n            std::println(\"Station 1: {}\", tickets--);\n            ::ReleaseMutex(hMutex);\n        }\n        else\n        {\n            ::ReleaseMutex(hMutex);\n            break;\n        }\n    }\n    return 0;\n}\n```\n结果：\n```\nStation main: 10\nStation 1: 9\nStation main: 8\nStation 1: 7\nStation main: 6\nStation 1: 5\nStation main: 4\nStation 1: 3\nStation main: 2\nStation 1: 1\nFinally, tickets remain: 0\n\n```\n不会出现卖0号票的情况。\n## 使用标准线程库创建2个子线程卖票\n```cpp\n#include <Windows.h>\n#include <iostream>\n#include <print>\n#include <thread>\nconstinit int tickets = 10;\nconstinit HANDLE hMutex = nullptr;\nvoid seller(std::string const& name);\nint main()\n{\n    hMutex = ::CreateMutex(nullptr, false, nullptr);\n    // start a new thread\n    std::jthread th1(seller, \"seller 1:\");\n    std::jthread th2(seller, \"seller 2:\");\n    //::Sleep(500); // 不用Sleep了，而是join\n    th1.join();\n    th2.join();\n    \n    ::CloseHandle(hMutex);\n    hMutex = nullptr;\n    std::println(\"Finally, tickets remain: {}\", tickets);\n    return 0;\n}\nvoid seller(std::string const& name)\n{\n    while (true)\n    {\n        ::WaitForSingleObject(hMutex, INFINITE);\n        if (tickets > 0)\n        {\n            ::Sleep(5);\n            std::println(\"{} {}\", name, tickets--);\n            ::ReleaseMutex(hMutex);\n        }\n        else\n        {\n            ::ReleaseMutex(hMutex);\n            break;\n        }\n    }\n}\n```\n由于我们在子线程结束后还有CloseHandle、输出最后票数的操作，使用需要手动控制`th.join()`的位置。\n```cpp\n    th1.join();\n    th2.join();\n    //::Sleep(1000); // 不用Sleep了\n```\n\n或者也可以detach，但是主线程要在末尾主动`Sleep`一段时间。\n```cpp\n    th1.detach();\n    th2.detach();\n    ::Sleep(1000);\n```\n\n结果：\n```\nseller 1: 10\nseller 2: 9\nseller 1: 8\nseller 2: 7\nseller 1: 6\nseller 2: 5\nseller 1: 4\nseller 2: 3\nseller 1: 2\nseller 2: 1\nFinally, tickets remain: 0\n```\n## 命名锁\n比如要想做应用程序的单例模式。\n可以用锁和内核对象进行控制。\n为什么要用名字呢？\n因为每个线程创建完之后内核返回的句柄值时随机的，线程只知道自己的，而不知道其他人的句柄。但当程序员主动在创建线程时给了名字后，系统就有所感知，你之前已经创建过这个东西，就会把之前的句柄返回给你，就可以访问相同的对象了。\n![](../../images/Windows_多线程/image-20240722063708658.png)\n![](../../images/Windows_多线程/image-20240722063754385.png)\n\n\n```cpp\nconstinit HANDLE hMutex = nullptr;\nconstinit HANDLE hSingletonMx = nullptr;\n\nint main()\n{\n    // 起始 主线程 拥有锁\n    hSingletonMx = ::CreateMutex(nullptr, false, L\"AppSingleton\");\n    if (::GetLastError() == ERROR_ALREADY_EXISTS)\n    {\n        ::CloseHandle(hSingletonMx);\n        return 0;  // break point\n    }\n    hMutex = ::CreateMutex(nullptr, false, nullptr);\n    ::ReleaseMutex(hMutex);\n    \n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = ::CreateThread(nullptr, 0, &ThreadProc2, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    ::Sleep(10000);\n    ::CloseHandle(hSingletonMx);\n    return 0;\n}\n```\n### VS下多线程调试\n1. 下断点。\n2. 先运行一个程序。\n3. 在Sleep 10s结束之前。右击项目名，Debug，Start New Instance。\n4. 会发现，第二个程序会直接到达`closeHandle(hSingletonMx)`。\n5. 这就是跨应用程序的singleton\n# CreateEvent创建事件（信号、条件变量） - Windows下的独特锁\n事件提供了比Mutex更多的功能。\n用`CreateEvent`创建。\n[CreateEventW function (synchapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventw)\n![](../../images/Windows_多线程/image-20240722184421346.png)\n1. 可选，安全描述符，填NULL表示获取默认描述符。\n2. 是否手动重置，意思是如果是手动重置则需要在`WaitForSingleObject`之后`ResetEvent(hEvent)`手动上锁，在此期间可能会被其他人抢占该信号。如果是自动重置则是Wait后自动上锁。\n3. 初始状态，true为有信号（signaled），false为无信号（nonsignaled）。有信号意为没有上锁，无信号时需要自己把锁打开。\n4. 可选，命名或匿名。\n## SetEvent：释放信号\n对于Event来说，退出临界区的方法为`SetEvent(hEvent)`\n## 卖票代码修改\n使用Event时需要做以下修改：\n1. main函数中`CreateEvent`\n2. main函数最后`CloseHandle`参数改为hEvent\n3. 线程函数中\n    1. WaitForSingleObject参数改为hEvent\n    2. 退出临界区的开锁对于Event来说方法为`SetEvent(hEvent)`\n\n以下，创建2个子线程。\n```cpp\nconstinit HANDLE hEvent = nullptr;\nint main()\n{\n    hEvent = CreateEvent(nullptr, false, true, nullptr);\n    \n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    \n    hThread = ::CreateThread(nullptr, 0, &ThreadProc2, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    ::Sleep(10000);\n    ::CloseHandle(hEvent);\n    return 0;\n}\nDWORD WINAPI ThreadProc(void* parameter)\n{\n    while (true)\n    {\n        ::WaitForSingleObject(hEvent, INFINITE);\n        if (tickets > 0)\n        {\n            ::Sleep(5); // 5ms\n            std::wcout << L\"Station #main: \" << tickets-- << std::endl;\n            ::SetEvent(hEvent);\n        }\n        else\n        {\n            ::SetEvent(hEvent);\n            break;\n        }\n    }\n}\n```\n## 不同\n1. Mutex与拥有者绑定，只能听从拥有者支配。\n2. Event没有绑定拥有者，任何人只要拿到它的句柄就可以支配。\n3. Event更像是一个信号的概念，给别人通知。Linux下的对标物：条件变量\n\n## WaitForMultipleObjects\n使用`WaitForMultipleObjects`。常常用于：当作主线程的信号接收器，当两个子线程**全部**发出结尾的SetEvent信号时，主线程就可以停止阻塞，继续执行，从而取代了死板的Sleep。\n[WaitForMultipleObjects function (synchapi.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects)\n![](../../images/Windows_多线程/image-20240722201812515.png)\n1. 事件对象的个数\n2. 事件对象句柄数组的首元素指针\n3. 是否等待所有事件对象全部到位再退出\n4. 0是空转，INFINITE是无限期，非0是最多等多久后退出。\n\n两个子线程的完成事件信号，初始状态必须是无信号，即在创建时，`CreateEvent`的第三个参数为false。\n两个子线程在结束时，需要`SetEvent(hEventExits[0 or 1]);`进行开锁。\n```cpp\nconstinit int tickets = 100;\nDWORD WINAPI ThreadProc(void * lpParameter);\nDWORD WINAPI ThreadProc2(void * lpParameter);\n\nconstinit HANDLE hEvent = nullptr;\nconstinit HANDLE hEventExits[2] = {nullptr, nullptr};\nint main()\n{\n    hEvent = CreateEvent(nullptr, false, true, nullptr);\n    hEventExits[0] = CreateEvent(nullptr, false, false, nullptr);\n    hEventExits[1] = CreateEvent(nullptr, false, false, nullptr);\n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = ::CreateThread(nullptr, 0, &ThreadProc2, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    ::WaitForMultipleObjects(2, hEventExits, true, INFINITE);\n    ::CloseHandle(hEvent);\n    ::CloseHandle(hEventExits[0]);\n    ::CloseHandle(hEventExits[1]);\n    ::DeleteCriticalSection(&cs);\n    return 0;\n}\nDWORD WINAPI ThreadProc(void* parameter)\n{\n    while (true)\n    {\n        ::WaitForSingleObject(hEvent, INFINITE);\n        if (tickets > 0)\n        {\n            ::Sleep(5); // 5ms\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n            ::SetEvent(hEvent);\n        }\n        else\n        {\n            ::SetEvent(hEvent);\n            break;\n        }\n    }\n    SetEvent(hEventExits[0]);\n    return 0;\n}\nDWORD WINAPI ThreadProc2(void* parameter)\n{\n    while (true)\n    {\n        ::WaitForSingleObject(hEvent, INFINITE);\n        if (tickets > 0)\n        {\n            ::Sleep(5); // 5ms\n            std::wcout << L\"Station #2: \" << tickets-- << std::endl;\n            ::SetEvent(hEvent);\n        }\n        else\n        {\n            ::SetEvent(hEvent);\n            break;\n        }\n    }\n    SetEvent(hEventExits[1]);\n    return 0;\n}\n```\n输出：\n```\n ...\nStation #1: 20\nStation #2: 19\nStation #1: 18\nStation #2: 17\nStation #1: 16\nStation #2: 15\nStation #1: 14\nStation #2: 13\nStation #1: 12\nStation #2: 11\nStation #1: 10\nStation #2: 9\nStation #1: 8\nStation #2: 7\nStation #1: 6\nStation #2: 5\nStation #1: 4\nStation #2: 3\nStation #1: 2\nStation #2: 1\n```\n# Windows临界区\n![](../../images/Windows_多线程/image-20240722205124201.png)\n![](../../images/Windows_多线程/image-20240722205149008.png)\n1. 不是Windows内核对象，只是C语言下用户态的结构体。\n2. 用`CRITICAL_SECTION`声明、定义。\n3. 用`InitializeCriticalSection`初始化\n4. 用临界区就不用Mutex或Event了\n5. 保护临界区用`EnterCriticalSection`\n6. 离开临界区用`LeaveCriticalSection`\n7. 进程的最后要销毁，`DeleteCriticalSection`\n\n```cpp\nconstinit int tickets = 100;\nDWORD WINAPI ThreadProc(void * lpParameter);\nDWORD WINAPI ThreadProc2(void * lpParameter);\n\nconstinit HANDLE hEventExits[2] = {nullptr, nullptr};\n\nCRITICAL_SECTION cs;\nint main()\n{\n    hEventExits[0] = CreateEvent(nullptr, false, false, nullptr);\n    hEventExits[1] = CreateEvent(nullptr, false, false, nullptr);\n\n    ::InitializeCriticalSection(&cs);\n\n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = ::CreateThread(nullptr, 0, &ThreadProc2, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    ::WaitForMultipleObjects(2, hEventExits, true, INFINITE);\n    ::CloseHandle(hEventExits[0]);\n    ::CloseHandle(hEventExits[1]);\n    ::DeleteCriticalSection(&cs);\n    return 0;\n}\nDWORD WINAPI ThreadProc(void* parameter)\n{\n    while (true)\n    {\n        ::EnterCriticalSection(&cs);\n        if (tickets > 0)\n        {\n            // ::Sleep(5); // 5ms\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n            ::LeaveCriticalSection(&cs);\n        }\n        else\n        {\n            ::LeaveCriticalSection(&cs);\n            break;\n        }\n    }\n    SetEvent(hEventExits[0]);\n    return 0;\n}\nDWORD WINAPI ThreadProc2(void* parameter)\n{\n    while (true)\n    {\n        ::EnterCriticalSection(&cs);\n        if (tickets > 0)\n        {\n            // ::Sleep(5); // 5ms\n            std::wcout << L\"Station #2: \" << tickets-- << std::endl;\n            ::LeaveCriticalSection(&cs);\n        }\n        else\n        {\n            ::LeaveCriticalSection(&cs);\n            break;\n        }\n    }\n    SetEvent(hEventExits[1]);\n    return 0;\n}\n```\n## 输出\n```\nStation #1: 1000\nStation #1: 999\n...\nStation #1: ...\n...\nStation #1: 704\nStation #1: 703\nStation #1: 702\nStation #2: 701\nStation #2: 700\n...\nStation #2: ...\n...\nStation #2: 260\nStation #2: 259\nStation #2: 258\nStation #1: 257\nStation #1: 256\n...\nStation #1: ...\n...\nStation #1: 229\nStation #1: 228\nStation #1: 227\nStation #2: 226\nStation #2: 225\n...\nStation #2: ...\n...\nStation #2: 213\nStation #2: 212\nStation #1: 211\nStation #1: 210\n...\nStation #1: ...\n...\nStation #1: 4\nStation #1: 3\nStation #1: 2\nStation #1: 1\n```\n## 特点总结\n1. 在用户态下，速度比内核态的Event、Mutex快\n2. 也能实现同步保护，但是调配度没有那么细致，某一线程一直独占临界区的概率较大。\n# 死锁\n1. 加一个临界区对象\n2. 线程1先进入临界区1再进入临界区2，退出时先退出2再退出1\n2. 线程2先进入临界区2再进入临界区1，退出时先退出1再退出2\n\n```cpp\nCRITICAL_SECTION cs;\nCRITICAL_SECTION cs2;\nint main()\n{\n    hEventExits[0] = CreateEvent(nullptr, false, false, nullptr);\n    hEventExits[1] = CreateEvent(nullptr, false, false, nullptr);\n\n    ::InitializeCriticalSection(&cs);\n    ::InitializeCriticalSection(&cs2);\n\n    HANDLE hThread = ::CreateThread(nullptr, 0, &ThreadProc, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = ::CreateThread(nullptr, 0, &ThreadProc2, nullptr, 0, nullptr);\n    ::CloseHandle(hThread);\n    hThread = nullptr;\n\n    ::WaitForMultipleObjects(2, hEventExits, true, INFINITE);\n    ::CloseHandle(hEventExits[0]);\n    ::CloseHandle(hEventExits[1]);\n    ::DeleteCriticalSection(&cs);\n    ::DeleteCriticalSection(&cs2);\n    return 0;\n}\nDWORD WINAPI ThreadProc(void* parameter)\n{\n    while (true)\n    {\n        ::EnterCriticalSection(&cs);\n        ::EnterCriticalSection(&cs2);\n        if (tickets > 0)\n        {\n            ::Sleep(5); // 5ms\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n            ::LeaveCriticalSection(&cs2);\n            ::LeaveCriticalSection(&cs);\n        }\n        else\n        {\n            ::LeaveCriticalSection(&cs2);\n            ::LeaveCriticalSection(&cs);\n            break;\n        }\n    }\n    SetEvent(hEventExits[0]);\n    return 0;\n}\nDWORD WINAPI ThreadProc2(void* parameter)\n{\n    while (true)\n    {\n        ::EnterCriticalSection(&cs2);\n        ::EnterCriticalSection(&cs);\n        if (tickets > 0)\n        {\n            ::Sleep(5); // 5ms\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n            ::LeaveCriticalSection(&cs);\n            ::LeaveCriticalSection(&cs2);\n        }\n        else\n        {\n            ::LeaveCriticalSection(&cs);\n            ::LeaveCriticalSection(&cs2);\n            break;\n        }\n    }\n    SetEvent(hEventExits[0]);\n    return 0;\n}\n```\n## 输出\n```\nStation #1: 1000\nStation #1: 999\nStation #1: 998\nStation #1: 997\nStation #1: 996\nStation #1: 995\nStation #1: 994\nStation #1: 993\nStation #1: 992\nStation #1: 991\nStation #1: 990\nStation #1: 989\nStation #1: 988\nStation #1: 987\nStation #1: 986\nStation #1: 985\nStation #1: 984\nStation #1: 983\nStation #1: 982\nStation #1: 981\nStation #1: 980\nStation #1: 979\nStation #1: 978\nStation #1: 977\nStation #1: 976\nStation #1: 975\nStation #1: 974\nStation #1: 973\nStation #1: 972\nStation #1: 971\nStation #1: 970\nStation #1: 969\nStation #1: 968\nStation #1: 967\nStation #1: 966\nStation #1: 965\nStation #1: 964\nStation #1: 963\nStation #1: 962\nStation #1: 961\nStation #1: 960\nStation #1: 959\nStation #1: 958\nStation #1: 957\nStation #1: 956\nStation #1: 955\nStation #1: 954\nStation #1: 953\nStation #1: 952\nStation #1: 951\nStation #1: 950\nStation #1: 949\nStation #1: 948\nStation #1: 947\nStation #1: 946\nStation #1: 945\nStation #1: 944\n|               ---> block\n```\n这种情况是因为双方各自都需要两种锁，但是各自只持有一种锁，都在等待另一种锁释放。\n# 多线程UI\nVS新建项目，Windows Desktop Wizard，下一步，改名为`Multi-Threading-WithUI`，Create。弹出Windows Desktop Project，Application Type选择Desktop Application (.exe)，Additional options选择Empty project，OK。\n手写创建控件。手册查阅：\n[Progress Bar - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/controls/progress-bar-control-reference)\n[About Progress Bar Controls - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/controls/progress-bar-control)\n![](../../images/Windows_多线程/image-20240725064818400.png)\n可以通过使用`CreateWindowEx`函数并指定`PROGRESS_CLASS`窗口类（定义于`CommCtrl.h`）来创建进度条。这个窗口类是公共控件DLL被加载后注册的。\n即需要在ShowWindow显示主窗口后再`CreateWindowEx`创建一个子窗口。参数如下：\n1. dwExStyle为叠放式\n2. 类名为PROGRESS_CLASS\n3. 窗口对象名字\n4. dwStyle为子窗口WS_CHILDWINDOW\n5. X、Y，宽度、高度\n6. 父窗口hWndParent\n7. hMenu\n8. hInstance\n9. lpParam\n\n>Windows遵循“一切皆窗口”原则，进度条也是一个窗口，因此需要通过创建子窗口来创建进度条。\n\n在WndProcedure的`case WM_CREATE`中创建。\n自定义消息，创建进度条完成：\n```cpp\n#define CONTROL_FIN WM_USER + 1\n```\n在`case CONTROL_FIN`中，可以发送进度条的消息：\n![](../../images/Windows_多线程/image-20240725070738779.png)\n1. [PBM_SETRANGE message](https://learn.microsoft.com/en-us/windows/win32/controls/pbm-setrange)用于设置进度条的最小值和最大值，并重绘进度条以反映新的范围。\n2. [PBM_SETPOS message](https://learn.microsoft.com/en-us/windows/win32/controls/pbm-setpos)用于设置进度条的当前位置并重绘进度条以反映新位置。\n\n```cpp\nHWND hProgressBar = nullptr;\nint __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPreInstance, wchar_t* lpCmdLine, int )\n{\n    // wcex ...\n    if (!RegisterClassEx(&wcex))\n    {\n        return -1;\n    }\n    HWND hWnd = NULL;\n    hWnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, szAppName, L\"App\", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hIntance, NULL);\n    ShowWindow(hWnd, iCmdShow);\n    UpdateWindow(hWnd);\n\n    // 创建控件：\n    hProgressBar = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, PROGRESS_CLASS, L\"Bar\",\n        WS_CHILDWINDOW, 100, 100, 200, 20,\n        hWnd, nullptr, hInstance, nullptr);\n    ::PostMessage(hWnd, CONTROL_FIN, 0, 0);\n    ShowWindow(hProgressBar, iCmdShow);\n    UpdateWindow(hProgressBar);\n\n    MSG msg;\n    while (GetMessage(&msg, NULL, 0, 0))\n    {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n    return msg.wParam;\n}\nLRESULT CALLBACK WndProcedure(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    HDC hDC = NULL;\n    PAINTSTRUCT ps;\n    switch (message)\n    {\n    case WM_CREATE:\n    {\n        return 0;\n    }\n    case CONTROL_FIN: // 自定义消息：创建进度条完成\n    {\n        // 用于设置进度条的最小值和最大值，并重绘进度条以反映新的范围\n        ::PostMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100));\n        // 用于设置进度条的当前位置并重绘进度条以反映新位置。\n        ::PostMessage(hProgressBar, PBM_SETPOS, 50, 0);\n        return 0;\n    }\n    case WM_PAINT:\n    {\n        hDC = BeginPaint(hWnd, &ps);\n        EndPaint(hWnd, &ps);\n        return 0;\n    }\n    case WM_DESTROY:\n    {\n        PostQuitMessage(0);\n        return 0;\n    }\n    }\n    return DefWindowProc(hWnd, message, wParam, lParam);\n}\nint  __stdcall DlgProcedure(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n    case WM_INITDIALOG:\n    {\n        return false;\n    }\n    case WM_CLOSE:\n    {\n        EndDialog(hDlg, 0);\n        return true;\n    }\n    case WM_COMMAND:\n    {\n        switch (LOWORD(wParam))\n        {\n        case IDCANCEL:\n        {\n            return true;\n        }\n        case IDOK:\n        {\n            return true;\n        }\n        }\n        return false;\n    }\n    }\n    return false;\n}\n```\n以上UI程序的效果：\n![](../../images/Windows_多线程/image-20240725071216773.png)\n一个主窗口，包含一个进度条，50%。\n## 单线程消息循环实现进度条动画\n1. 想要通过按某个键，触发、通知进度条上涨至100%。\n2. 并能同时显示多个进度条，每个进度条按不同速度走。\n3. 同一时刻要让最多两个进度条能动。\n\n[PBM_STEPIT message](https://learn.microsoft.com/en-us/windows/win32/controls/pbm-stepit)用于将进度条的当前位置向前推进步长增量，并重绘进度条以反映新位置。应用程序通过发送PBM_SETSTEP消息来设置步长增量。\n```cpp\n    case CONTROL_FIN: // 自定义消息：创建进度条完成\n    {\n        // 用于设置进度条的最小值和最大值，并重绘进度条以反映新的范围\n        ::PostMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100));\n        // 用于设置进度条的当前位置并重绘进度条以反映新位置。\n        ::PostMessage(hProgressBar, PBM_SETPOS, 0, 0);\n        // 设置步长，每次走1\n        ::PostMessage(hProgressBar, PBM_SETPOS, 1, 0);\n        return 0;\n    }\n    case WM_KEYDOWN:\n    {\n        if (wParam == 'A')\n        {\n            for (int i = 0; i < 100; ++i)\n            {\n                ::PostMessage(hProgressBar, PBM_STEPIT, 0, 0);\n                std::this_thread::sleep_for(100ms);\n            }\n        }\n        return 0\n    }\n```\n以上程序的问题是，一直没有进度条的动画，必须得等for循环完毕，进度条才能动，但是是一下子到头。\n因为：\n我们现在是PostMessage发送进度条消息，导致其他消息不能同时处理。\n因此要用SendMessage，不进消息队列，直接操作控件，控件就可以立即响应了。\n但是仍然存在问题：进度条结束前不能移动主窗口（移动主窗口是发送MOVE消息）。\nUI消息驱动工作的原理是什么？\nwWinMain函数中有一个消息循环。\n![](../../images/Windows_多线程/image-20240725073122710.png)\n我们需要在`case WM_KEYDOWN`中也加入这样一个消息循环。\n\n但是，GetMessage是以阻塞方式获取消息的，需要切换为PeekMessage。[PeekMessageW function (winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew)\n```cpp\n    case WM_KEYDOWN:\n    {\n        if (wParam == 'A')\n        {\n            for (int i = 0; i < 100; ++i)\n            {\n                ::SendMessage(hProgressBar, PBM_STEPIT, 0, 0);\n                std::this_thread::sleep_for(100ms);\n                                \n                MSG msg;\n                while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\n                {\n                    TranslateMessage(&msg);\n                    DispatchMessage(&msg);\n                }\n            }\n        }\n        return 0;\n    }\n```\n## 多线程消息处理\n按下S键后，创建一个子线程，在子线程中进行发送消息。\n子线程发送消息时，就没必要使用SendMessage了，使用PostMessage就可以，PostMessage是往主线程中的消息队列里投放消息。\n但是要注意，由于创建的是jthread线程，最后会自动join，导致主线程会等待其操作完毕，那么主窗口就不能处理其他消息，因此子线程需要detach。\n```cpp\n    case WM_KEYDOWN:\n    {\n        if (wParam == 'A')\n        {\n            // ...\n        }\n        else if (wParam == 'S')\n        {\n            std::jthread t([]() -> void\n                {\n                    for (int i = 0; i < 100; ++i)\n                    {\n                        ::PostMessage(hProgressBar, PBM_STEPIT, 0, 0);\n                        std::this_thread::sleep_for(100ms);\n                    }\n                });\n            t.detach();\n        }\n        else if (wParam == 'F')\n        {\n            \n        }\n        return 0;\n        \n    }\n```\n### 通过条件变量控制子线程\n我们把原本按下S键的内容直接让其在`case CONTROL_FIN`中完成，意味着创建进度条完成后，并且设置好进度条的属性后，立即创建子线程，但是要用条件变量控制：\n#### 用Event控制\n1. 在全局定义一个`h_start_event`\n2. 在`case CONTROL_FIN`中CreateEvent与`h_start_event`绑定\n3. 在jthread t函数体中，WaitForSingleObject等待`h_start_event`\n4. 在`case WM_KEYDOWN`的F键中，SetEvent\n\n```cpp\nHANDLE h_start_event{ nullptr };\n\nLRESULT CALLBACK WndProcedure(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    HDC hDC = NULL;\n    PAINTSTRUCT ps;\n    switch (message)\n    {\n    case WM_CREATE:\n    {\n        return 0;\n    }\n    case CONTROL_FIN: // 自定义消息：创建进度条完成\n    {\n        h_start_event = ::CreateEvent(nullptr, false, false, nullptr);\n        // 用于设置进度条的最小值和最大值，并重绘进度条以反映新的范围\n        ::PostMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100));\n        // 用于设置进度条的当前位置并重绘进度条以反映新位置。\n        ::PostMessage(hProgressBar, PBM_SETPOS, 0, 0);\n        // 设置步长，每次走1\n        ::PostMessage(hProgressBar, PBM_SETPOS, 1, 0);\n\n        std::jthread t([]() -> void\n            {\n                ::WaitForSingleObject(h_start_event, INFINITE);\n                \n                for (int i = 0; i < 100; ++i)\n                {\n                    ::PostMessage(hProgressBar, PBM_STEPIT, 0, 0);\n                    std::this_thread::sleep_for(100ms);\n                }\n            });\n        t.detach();\n        return 0;\n    }\n    case WM_KEYDOWN:\n    {\n        // ...\n        else if (wParam == 'F')\n        {\n            ::SetEvent(h_start_event);\n        }\n        return 0;\n    }\n    // ...\n    \n}\n```\n#### 跨平台条件变量控制\n1. 在全局定义一个`std::mutex start_mx`和`std::condition_variable start_cv`。\n2. 在jthread t函数体中，定义`unique_lock lck{start_mx}`获取锁，之后`start_cv.wait(lck)`\n3. 在`case WM_KEYDOWN`的F键中，`start_cv.notify_one()`\n\n```cpp\nstd::mutex start_mx;\nstd::condition_variable start_cv;\n\nLRESULT CALLBACK WndProcedure(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    HDC hDC = NULL;\n    PAINTSTRUCT ps;\n    switch (message)\n    {\n    case WM_CREATE:\n    {\n        return 0;\n    }\n    case CONTROL_FIN: // 自定义消息：创建进度条完成\n    {\n        // 用于设置进度条的最小值和最大值，并重绘进度条以反映新的范围\n        ::PostMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100));\n        // 用于设置进度条的当前位置并重绘进度条以反映新位置。\n        ::PostMessage(hProgressBar, PBM_SETPOS, 0, 0);\n        // 设置步长，每次走1\n        ::PostMessage(hProgressBar, PBM_SETPOS, 1, 0);\n\n        std::jthread t([]() -> void\n            {\n                std::unique_lock lck{ start_mx };\n                start_cv.wait(lck);\n                \n                for (int i = 0; i < 100; ++i)\n                {\n                    ::PostMessage(hProgressBar, PBM_STEPIT, 0, 0);\n                    std::this_thread::sleep_for(100ms);\n                }\n            });\n        t.detach();\n        return 0;\n    }\n    case WM_KEYDOWN:\n    {\n        // ...\n        else if (wParam == 'F')\n        {\n            start_cv.notify_one();\n        }\n        return 0;\n    }\n    // ...\n    \n}\n```\n### 多个进度条\n1. 全局定义3个`hProgressBar`。\n2. 在wWinMain中CreateWindowEx创建这3个进度条，可以赋予不同初始属性。并且要三个全部show、Update\n3. `case CONTROL_FIN`中PostMessage配置每个ProgressBar的属性。\n\n```cpp\nHWND hProgressBar{ nullptr }, hProgressBar2{ nullptr }, hProgress3{ nullptr };\nint __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPreInstance, wchar_t* lpCmdLine, )\n{\n    // ..,\n    hProgressBar = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, PROGRESS_CLASS, L\"Bar\",\n        WS_CHILDWINDOW, 100, 100, 300, 20,\n        hWnd, nullptr, hInstance, nullptr);\n    hProgressBar2 = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, PROGRESS_CLASS, L\"Bar2\",\n        WS_CHILDWINDOW, 100, 150, 300, 20,\n        hWnd, nullptr, hInstance, nullptr);\n    hProgressBar3 = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, PROGRESS_CLASS, L\"Bar3\",\n        WS_CHILDWINDOW, 100, 200, 300, 20,\n        hWnd, nullptr, hInstance, nullptr);\n    ::PostMessage(hWnd, CONTROL_FIN, 0, 0);\n\n    ShowWindow(hProgressBar, iCmdShow);\n    ShowWindow(hProgressBar2, iCmdShow);\n    ShowWindow(hProgressBar3, iCmdShow);\n    UpdateWindow(hProgressBar);\n    UpdateWindow(hProgressBar2);\n    UpdateWindow(hProgressBar3);\n    // ...\n}\n// ...\n{\n    case CONTROL_FIN:\n    {\n        ::PostMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100));\n        ::PostMessage(hProgressBar, PBM_SETPOS, 0, 0);\n        ::PostMessage(hProgressBar, PBM_SETSTEP, 1, 0);\n\n        ::PostMessage(hProgressBar2, PBM_SETRANGE, 0, MAKELPARAM(0, 100));\n        ::PostMessage(hProgressBar2, PBM_SETPOS, 34, 0);\n        ::PostMessage(hProgressBar2, PBM_SETSTEP, 1, 0);\n\n        ::PostMessage(hProgressBar3, PBM_SETRANGE, 0, MAKELPARAM(0, 100));\n        ::PostMessage(hProgressBar3, PBM_SETPOS, 67, 0);\n        ::PostMessage(hProgressBar3, PBM_SETSTEP, 1, 0);\n        // ...\n    }\n}\n```\n效果如下：\n![](../../images/Windows_多线程/image-20240725233919380.png)\n# Windows信号量\n## CreateSemaphore创建信号量\n创建的API为`CreateSemaphore`\n![](../../images/Windows_多线程/image-20240725002045341.png)\n1. 可选，安全描述符，如果是NULL则获得默认的安全描述符。如果是NULL则该句柄不能被子进程继承。\n2. 信号量的初始值。必须大于等于0。\n3. 信号量的最大值。必须大于0。\n4. 可选，信号量内核对象的名字。如果是NULL则没有名称。\n## WaitForSingleObject信号量减\n```cpp\n::WaitForSingleObject(h_semaphore, INFINITE);\n```\n## ReleaseSemaphore信号量加\n![](../../images/Windows_多线程/image-20240725004021152.png)\n1. 信号量对象的句柄\n2. 要增加的量，必须大于0。但是如果该值大于信号量的最大值，则无效，不做更改，返回FALSE。\n3. 一个指针，用于接收信号量先前的数值，可以为NULL。\n## 示例：多个进度条同时动画\n1. 以下程序的效果是，按下F键后，同时可以有两个条进行加载，两个条中如果有一个加载完后，第三个条开始加载。\n2. 三个线程需要有条件变量来等待F键按下，而条件变量需要锁，而后wait。\n3. case F需要给他们notify_all\n4. wait成功后进行获取信号量，信号量初始值、最大值为2。\n5. 但是要求要有两个同时加载，所以某一个线程不能一直拿着一把锁，因此需要wait成功后unlock。\n6. 结束for循环后释放信号量，即加1。\n\n在上一节《[多个进度条](#多个进度条)》的基础上，需要做的是：\n1. 在`case CONTROL_FIN`中创建3个线程，对应3个进度条。\n2. 在`case CONTROL_FIN`中创建信号量`h_semaphore`。\n3. 每个线程需要wait按下F键的通知，所以需要先获取锁。\n4. wait成功后需要unlock。\n5. 获取信号量。\n6. for循环结束后，释放信号量。\n7. 3个jthread线程在最后detach。\n\n```cpp\n{\n    case CONTROL_FIN:\n    {\n        h_semaphore = ::CreateSemaphore(nullptr, 2, 2, nullptr);\n        std::jthread t([]() -> void\n        {\n            std::unique_lock lck{ start_mx };\n            start_cv.wait(lck);\n            lck.unlock();\n            ::WaitForSingleObject(h_semaphore, INFINITE);\n            for (int i = 0; i < 33; ++i)\n            {\n                ::PostMessage(hProgress, PBM_SETPIT, 0, 0);\n                std::this_thread::sleep_for(100ms);\n            }\n            ::ReleaseSemaphore(h_semaphore, 1, nullptr);\n        });\n        std::jthread t2([]() -> void\n        {\n            std::unique_lock lck{ start_mx };\n            start_cv.wait(lck);\n            lck.unlock();\n            ::WaitForSingleObject(h_semaphore, INFINITE);\n            for (int i = 33; i < 66; ++i)\n            {\n                ::PostMessage(hProgress, PBM_SETPIT, 0, 0);\n                std::this_thread::sleep_for(100ms);\n            }\n            ::ReleaseSemaphore(h_semaphore, 1, nullptr);\n        });\n        std::jthread t3([]() -> void\n        {\n            std::unique_lock lck{ start_mx };\n            start_cv.wait(lck);\n            lck.unlock();\n            ::WaitForSingleObject(h_semaphore, INFINITE);\n            for (int i = 66; i < 100; ++i)\n            {\n                ::PostMessage(hProgress, PBM_SETPIT, 0, 0);\n                std::this_thread::sleep_for(100ms);\n            }\n            ::ReleaseSemaphore(h_semaphore, 1, nullptr);\n        });\n        t.detach();\n        t2.detach();\n        t3.detach();\n    }\n    case WM_KETDOWN:\n    {\n        // ...\n        else if (wParam == 'F')\n        {\n            start_cv.notify_all();\n        }\n        return 0;\n    }\n    // ...\n}\n```","categories":["操作系统","多线程","Windows"]},{"title":"Windows_基于模板设计","url":"/Windows/Windows_基于模板设计/","content":"# 准备项目\n\n用VS向导创建项目。新建一个项目，选择\"Windows Desktop Wizard\"，取名为\"TemplatedFramework\"。点击创建按钮后，弹出配置窗口，Application type选择：\"Desktop Application (.exe)\"，Additional options中勾选\"Empty project\"。\n\n配置VS项目的属性，右键项目选择Properties，左边栏选择Linker，然后选择System。右边详细条目\"SubSystem\"暂时下拉选择Console，后续需要窗口程序时再调整为Windows。\n\n目前的工作是编写一个模板文件。模板不是编译单位，因此取后缀名为`.hpp`，如果写为`.cpp`后缀则无法通过默认一键编译。因此，`.hpp`的文件通常被理解为无需再去寻找相应的`.cpp`实现文件，而是在自身文件中已实现。所以基于模板开发的代码，最基础的模板代码文件是必须提供开源的。\n\n因此，新建一个`.hpp`头文件，名为`TWindow.hpp`。\n```cpp\n// TWindow.hpp\n\n#pragma once\n\nnamespace tfk\n{\n    template <typename T>\n    class TWindow\n    {\n        // ...\n    };\n}\n```\n# TWindow类设计\n\n和面向对象设计的Window类很相似。\n之前的`Window.h`文件：\n```cpp\n// Window.h\nclass Window\n{\npublic:\n    friend int ::wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int);\npublic:\n    Window(std::wstring const& app_name);\n    bool create_window(void);\n    void show_window(bool show = true);\n    int run(void);\n\n    static LRESULT CALLBACK window_procedure(\n        HWND wnd, UINT message, WPARAM wparam, LPARAM lparam);\nprotected:\n    virtual void pre_create(WNDCLASSEX& wcex);\n    virtual bool on_lbtndown(POINT& pt);\n    virtual bool on_lbtnup(POINT& pt);\n    virtual bool on_rbtndown(POINT& pt);\n    virtual bool on_paint(HDC dc, PAINTSTRUCT& ps);\nprotected:\n    HWND              _wnd{ nullptr };\n    static HINSTANCE  _instance;\n    static Window*    _window;\n    std::wstring      _app_name;\n};\n```\n现在我们是模板类（没有具体类，因此不存在静态变量），而且不依赖于动态多态，因此，不会用到virtual属性和static属性。\n1. 改类名为`TWindow`\n2. 改成员变量`_window`的类型为`TWindow<T>*`\n3. 删去`create_window`函数。\n   `pre_create`可以集成在构造函数中了。当时设计Window类将创建窗口的工作从构造函数中剥离的原因是`pre_create`无法在构造函数中调用，而`pre_create`又必须和`create_window`的其他动作绑定（wcex的赋初值工作），因此需要单独抽出来作为`create_window`。现在，没有虚函数特性了，因此，`pre_create`可以直接写在构造函数中。因此，也无需再剥离出`create_window`函数，即原先`create_window`函数的工作全在构造函数中铺开。\n2. 删去成员变量`_app_name`，因为可以直接通过参数在构造函数中赋予wcex属性。\n3. `pre_create`删去virtual。\n4. 四个`on_...`消息处理函数删去virtual。\n```cpp\ntemplate <typename T>\nclass TWindow\n{\npublic:\n    friend int ::wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int);\npublic:\n    TWindow(std::wstring const& app_name);\n    bool create_window(void);\n    void show_window(bool show = true);\n    int run(void);\n\n    static LRESULT CALLBACK window_procedure(\n        HWND wnd, UINT message, WPARAM wparam, LPARAM lparam);\nprotected:\n    void pre_create(WNDCLASSEX& wcex);\n    bool on_lbtndown(POINT& pt);\n    bool on_lbtnup(POINT& pt);\n    bool on_rbtndown(POINT& pt);\n    bool on_paint(HDC dc, PAINTSTRUCT& ps);\nprotected:\n    HWND                 _wnd{ nullptr };\n    static HINSTANCE     _instance;\n    static TWindow<T>*   _window;\n};\n```\n# TWindow类模板的函数实现\n直接在`TWindow.hpp`文件中的类模板定义的尾部编写函数实现。\n```cpp\n// TWindow.hpp\nnamespace tfk\n{\n    template <typename T>\n    class TWindow\n    {\n        // ...\n    };\n\n    // 在这里写 implementation\n}\n```\n\n```cpp\n\n// TWindow<T> implementation\n\n// TWindow.hpp\n\n// ...\n\n#include <string>\n#include <Windows.h>\n\ntemplate <typename T>\nTWindow<T>::TWindow(std::wstring const& app_name)\n{\n    _window = this;\n\n    WNDCLASSEX wcex = { 0 };\n    wcex.cbSize = sizeof(wcex);\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc = &window_procedure;\n    wcex.cbClsExtra = 0;\n    wcex.cbWndExtra = 0;\n    wcex.hInstance = _instance;\n    wcex.hIcon = LoadIcon(nullptr, IDI_SHIELD);\n    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    wcex.hbrBackground = (HBRUSH)(GetStockObject(LTGRAY_BRUSH));\n    wcex.lpszMenuName = NULL;\n    wcex.lpszClassName = app_name.c_str();\n    wcex.hIconSm = wcex.hIcon;\n    \n    pre_create(wcex);  // 此处有隐患：见下文CALLBACK实现\n\n    if (!::RegisterClassEx(&wcex))\n        return;\n    // 定义一个窗口对象的句柄\n    // HWND: 窗口类型的句柄，也叫内核对象\n    _wnd = ::CreateWindowEx(\n        WS_EX_OVERLAPPEDWINDOW,\n        app_name.c_str(),\n        L\"App\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,\n        nullptr,\n        nullptr,\n        hInstance,\n        nullptr);\n    if (!_wnd)\n    {\n        int i = ::GetLastError();\n        return;\n    }\n}\n\ntemplate <typename T>\nvoid TWindow<T>::show_window(bool show)\n{\n    if(_wnd)\n    {\n        int nShowCmd = show ? SW_NORMAL : SW_HIDE;\n        // 显示窗口，nShowCmd可以指定窗口以最小/最大/正常状态显示\n        ::ShowWindow(_wnd, nShowCmd);\n        // 更新窗口，绘制窗口。刚显示出来可能是无效的，需要在显示后绘制。\n        ::UpdateWindow(_wnd);\n    }\n}\n\ntemplate <typename T>\nint TWindow<T>::run(void)\n{\n    MSG msg;\n    while (::GetMessage(&msg, nullptr, 0, 0))\n    {\n        // 翻译消息，比如输入法通过‘wo’生成‘我’\n        ::TranslateMessage(&msg);\n        // 发送消息，调用刚才注册的callback窗口处理函数\n        ::DispatchMessage(&msg);\n    }\n    return 0;\n}\n\ntemplate <typename T>\nvoid TWindow<T>::pre_create(WNDCLASSEX& wcex)\n{\n    // 空操作\n}\n```\n## CALLBACK实现\n主要分析一下类模板下的CALLBACK如何实现。\n由于此模式的多态是静态多态，所以需要把`_window`（值为this指针）从`TWindow<T>*`强转为`T*`，赋给window变量。\n把原先面向对象模式下用`_window`调用方法全部替换为`window`调用。\n```cpp\ntemplate <typename T>\nLRESULT TWindow<T>::window_procedure(\n    HWND wnd, UINT message,\n    WPARAM wparam, LPARAM lparam)\n{\n\n    T* window = static_cast<T*>(_window);\n\n    if(!window)\n        return ::DefWindowProc(wnd, message, wparam, lparam);\n\n    PAINTSTRUCT ps;\n\n    switch (message)\n    {\n    case WM_CREATE:\n        break;\n    case WM_LBUTTONDOWN:\n    {\n        // GET_X/Y_LPARAM From <windowsx.h> \n        int x_coord = GET_X_LPARAM(lparam);\n        int y_coord = GET_Y_LPARAM(lparam);\n        POINT pt{ x_coord, y_coord };\n        // true代表用户处理完毕\n        if (window->on_lbtndown(pt))\n            return 1;\n    }\n        break;\n    case WM_LBUTTONUP:\n    {\n        // GET_X/Y_LPARAM From <windowsx.h> \n        int x_coord = GET_X_LPARAM(lparam);\n        int y_coord = GET_Y_LPARAM(lparam);\n        POINT pt{ x_coord, y_coord };\n        // true代表用户处理完毕\n        if (window->on_lbtnup(pt))\n            return 1;\n    }\n        break;\n    case WM_RBUTTONDOWN:\n    {\n        int x_coord = GET_X_LPARAM(lparam);\n        int y_coord = GET_Y_LPARAM(lparam);\n        POINT pt{ x_coord, y_coord };\n        if (window->on_rbtndown(pt))\n            return 1;\n    }\n        break;\n    case WM_PAINT:\n    {\n        HDC dc = ::BeginPaint(wnd, &ps);\n        bool result = window->on_paint(dc, ps);\n        ::EndPaint(wnd, &ps);\n        if (result)\n            return 1;\n    }\n        break;\n    case WM_DESTROY:\n        ::PostQuitMessage(0);\n        break;\n    //default:\n    //    ;\n    }\n    return ::DefWindowProc(wnd, message, wparam, lparam);\n}\n```\n>此时有一个隐患，由于静态多态，所以构造函数中的`pre_create`不能使用默认类型this调用，需要强转为`T*`才能成功调用用户自定义的方法。\n```cpp\ntemplate <typename T>\nTWindow<T>::TWindow(std::wstring const& app_name)\n{\n    _window = this;\n\n    // ...\n    \n    static_cast<T*>(_window)->pre_create(wcex);  // 此处有隐患：见下文CALLBACK实现\n\n    // ...\n}\n```\n# wWinMain放到哪\n写到`TWindow.cpp`里面。\n```cpp\n#include \"TWindow.hpp\"\n\nextern int main(std::wstring const& args);\n\nint wWinMain(\n    HINSTANCE hInstance,\n    HINSTANCE hPrevInstance,\n    LPWSTR lpCmdLine,\n    int nShowCmd)\n{\n    // error\n    tfk::TWindow<?>::_instance = hInstance;\n    return main(lpCmdLine);\n}\n```\n但是，又遇到一个模板编程中的问题：此时`TWindow`缺少一个模板参数。而这个类模板的具体定义却又是在main函数后完成定义的。所以这个模板参数无法填写。\n因此，这里的`_instance`就不能作为类的属性了，而是作为类之外的全局属性。\n\n改写：把`_instance`剥离类外，定义为extern。\n```cpp\n// TWindow.hpp\nnamespace tfk\n{\n    extern HINSTANCE gInstance;\n\n    template <typename T>\n    class TWindow\n    {\n        // ...\n    }\n}\n```\n然后在`TWindow.cpp`里面定义它。在这个文件中也开一个tfk名字空间。\n```cpp\n// TWindow.cpp\n\n#include \"TWindow.hpp\"\n\nnamespace tfk\n{\n    constinit HINSTANCE ginstance{ nullptr };\n}\n\n// ...\n```\n至此，就可以在wWinMain中把hInstance值赋给`TWindow<T>`要使用的gInstace变量了。完整、正确的`TWindow.cpp`内容：\n```cpp\n#include \"TWindow.hpp\"\n\nnamespace tfk\n{\n    constinit HINSTANCE ginstance{ nullptr };\n}\n\nextern int main(std::wstring const& args);\n\nint wWinMain(\n    HINSTANCE hInstance,\n    HINSTANCE hPrevInstance,\n    LPWSTR lpCmdLine,\n    int nShowCmd)\n{\n    tfk::gInstance = hInstance;\n    return main(lpCmdLine);\n}\n```\n最后，改写一下TWindow构造函数中涉及到`_instance`的地方，替换为`gInstance`。还有，之前因为类外的wWinMain要用到成员变量`_instance`，我们设置了一个友元，现在也可以删去了。\n```cpp\n// TWindow.hpp\n\nclass TWindow\n{\n/* public:\n    friend int ::wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int); */\n\n// ...\n};\n```\n\n```cpp\n// TWindow.hpp implementaion\n\nTWindow<T>::TWindow(std::wstring const& app_name)\n{\n    // ...\n\n    wcex.hInstance = gInstance;\n\n    // ...\n\n    _wnd = ::CreateWindowEx(\n        WS_EX_OVERLAPPEDWINDOW,\n        app_name.c_str(),\n        L\"App\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,\n        nullptr, nullptr, gInstance, nullptr);\n}\n\n```\n# `_window`怎么初始化\n`_window`是静态变量。在类模版下的静态变量，在类外不能直接填参数。因此类似于gInstace的初始化写法，写在`TWindow.cpp`中的另一个tfk名字空间中。\n先用泛化的方式写一下试试：\n```cpp\n#include \"TWindow.hpp\"\n\nnamespace tfk\n{\n    // ...\n    \n    template<typename T> TWindow<T>* TWindow<T>::_window{ nullptr };\n}\n```\n小小测试一下：\n```cpp\n// MyTApp.h\n#pragma once\n#include \"TWindow.hpp\"\nclass MyTApp : public tfk::TWindow<MyTApp>\n{\npublic:\n    MyTApp(std::wstring const & name) : TWindow{name}\n    {\n        //\n    }\n};\n```\n\n```cpp\n// Source.app\n#include \"MyTApp.h\"\nint main(void)\n{\n    MyTApp my_app;\n    my_app.show_window();\n    return my_app.run();\n}\n```\n测试，以上写法编译不通过：\n```\nerror: LNK2001: unresolved symbol \"protected: static class tfk::TWindow<class MyTApp> * tfk::TWindow<class MyTApp>::_window\" (?_window@?$TWindow@VMyTApp@@@tfk@@1PEAV12@EA)\n```\n链接器失败，证明类模板下静态变量的初始化不能这么写。\n那么，就需要让用户在其main函数所在的文件外部进行初始化了：\n```cpp\n// main.cpp\n#include \"MyTApp.h\"\n\ntfk::TWindow<MyTApp>* tfk::TWindow<MyTApp>::_window{ nullptr };\n\nint main(void)\n{\n    // ...\n}\n```\n也有更简化的写法，利用宏定义：\n```cpp\n#define Tinit(app)   tfk::TWindow<app>* tfk::TWindow<app>::_window{ nullptr }\n\nTinit(MyTApp);\n```\n可以把宏定义写在`TWindow.hpp`尾部：\n```cpp\n// TWindow.hpp\n//...\n\n#define Tinit(app)   tfk::TWindow<app>* tfk::TWindow<app>::_window{ nullptr }\n```\n除了把这个问题抛给用户处理，还有一个方案，即类似于`gInstance`的处理，就是把`_window`提升为模板类外的全局变量。\n# 基于模板框架开发\n\n```cpp\n// MyTApp.h\n#pragma once\n#include \"TWindow.hpp\"\nclass MyTApp : public tfk::TWindow<MyTApp>\n{\npublic:\n    MyTApp(std::wstring const & name) : TWindow{name}\n    {\n        //\n    }\n\n    void pre_create(WNDCLASSEX& wcex)\n    {\n        wcex.hbrBackground = reinterpret_cast<HBRUSH>(::GetStockObject(BLACK_BRUSH));\n    }\n};\n```\n\n```cpp\n// Source.app\n#include \"MyTApp.h\"\nint main(void)\n{\n    MyTApp my_app;\n    my_app.show_window();\n    return my_app.run();\n}\n```\n\n# 基于GeometryUI开发打字游戏\n## 整体布局\n一个大窗口包含两个子窗口，左右分布。左窗口记录实时分数Score，右窗口为游戏画面，显示一些从上方落下的圆圈字母，玩家按下看到的字母可以将其消除，当有字母接触到底部边框时，游戏结束。\n## 项目配置\n新建项目，同样选择Windows Desktop Wizard。起名`Typist`，Application Type选择Desktop Application，Addition options选择Empty project。\n新建Source Files，`main.cpp`。\n\n打开`Typist`的Open Containing Folder，和QuickGeometryUI的Open Containing Folder。把所有相关的代码文件（`.h`、`.hpp`、`.inl`、`.cpp`（除了测试文件））拷贝到Typist目录。\n\n引入外部文件后，右键Header Files，Add Existing Files，选择`.h`、`.hpp`、`.inl`文件（`inl`表示inline）；右键Source Files，Add Existing Files，选择`.cpp`文件。\n\n下面新建并编写文件`TypistWindow.h`（建在Filter `Typist Box`中）：\n右键项目名`Typist`，Add，New Filter，取名为`Typist Box`。再在这个建好的Filter名字上右键，Add New Item，取名`TypistWindow.h`。\n该文件声明3个类：\n1. TypistFrame\n2. TypistLeftBox\n3. TypistCentralBox\n需要引入`QuickGeometryUI.hpp`\n```cpp\n// TypistWindow.h\n\n#pragma once\n\n#include \"QuickGeometryUI.hpp\"\nnamespace typist\n{\n    // Window Frame\n    class TypistFrame : public harbin::GeometryFrameBox<TypistFrame>\n    {\n        // ...\n    };\n\n    // Left window\n    // 模板参数1: ParentBox\n    // 模版参数2: InheritedT（当前窗口）\n    class TypistLeftBox : public harbin::GeometryBox<TypistFrame, TypistLeftBox>\n    {\n        // ...\n    };\n\n    class TypistCentralBox : public harbin::GeometryBox<TypistFrame, TypistCentralBox>\n    {\n        // ...\n    };\n}\n```\n## 构造\n```cpp\n// TypistWindow.h\n\n// ...\n#include <string>\n#include \"QuickGeometryUI.hpp\"\nnamespace typist\n{\nclass TypistFrame : public harbin::GeometryFrameBox<TypistFrame>\n{\npublic:\n    TypistFrame(std::wstring const& name);\n};\n\nclass TypistLeftBox : public harbin::GeometryBox<TypistFrame, TypistLeftBox>\n{\npublic:\n    TypistLeftBox(TypistFrame * frame, std::wstring const& name);\n};\n\nclass TypistCentralBox : public harbin::GeometryBox<TypistFrame, TypistCentralBox>\n{\npublic:\n    TypistCentralBox(TypistFrame * frame, std::wstring const& name);\n};\n}\n```\n### 实现\n`TypistWindow.cpp`建在Filter `Typist Box`中。\n```cpp\n// TypistWindow.cpp\n#include \"TypistWindow.h\"\ntypist::TypistFrame::TypistFrame(std::wstring const& name) : \n    GeometryFrameBox{ name.c_str() }\n{\n\n}\n\ntypist::TypistLeftBox::TypistLeftBox(TypistFrame* frame, std::wstring const& name) : \n    GeometryFrameBox{ frame, name.c_str() }\n{\n\n}\n\ntypist::TypistCentralBox::TypistCentralBox(TypistFrame* frame, std::wstring const& name) : \n    GeometryFrameBox{ frame, name.c_str() }\n{\n\n}\n```\n## main函数\n1. 入口函数规定为GeometryMain，需要改main函数名字\n2. 定义窗口Frame，再定义中央窗口、左窗口。\n3. AddSubBox，向父窗口中添加两个子窗口。\n    1. 第1个参数指定哪个作为子窗口\n    2. 第2个参数指定位置布局到哪里\n    3. 第3个参数是iDockModes\n        1. 这个是做什么的呢？假设同时有左盒子、下盒子，这个参数就是指定谁占用左下角的位置。则参数选项中谁名字在前面谁占，如`DM_LEFT_BOTTOM`是左盒子占用。\n        2. 我们此例没有下盒子，可以省略。\n4. show，3个盒子\n5. run，消息循环放到了frame_box中。\n`main.cpp`建在Source Files中。\n```cpp\n// main.cpp\n\n#include \"TypistWindow.h\"\nint GeometryMain(void)\n{\n    typist::TypistFrame frame_box{ L\"frame\" };\n    typist::TypistCentralBox central_box{ &frame_box, L\"central\" };\n    typist::TypistLeftBox left_box{ &frame_box, L\"left\" };\n\n    frame_box.AddSubBox(&central_box, BP_CENTRAL);\n    frame_box.AddSubBox(&left_box, BP_LEFT);\n\n    frame_box.ShowBox();\n    central_box.ShowBox();\n    left_box.ShowBox();\n\n    frame_box.Run();\n    \n    return 0;\n}\n```\n运行效果如下：\n![](../../images/Windows_基于模板设计/image-20240729013537130.png)\n## 换子窗口背景颜色\n可以重写`template<typename ParentBox, typename InheritedT> class GeometryBox`中的方法`void PreCreateBox(WNDCLASSEX&)`。\n我们更换的是CentralBox的颜色。\n```cpp\n// TypistWindow.h\n\n// ...\n\nclass TypistCentralBox : public harbin::GeometryBox<TypistFrame, TypistCentralBox>\n{\npublic:\n    // ...\n    void PreCreateBox(WNDCLASSEX&);\n}\n```\n实现：\n```cpp\n// TypistWindow.cpp\nvoid typist::TypistCentralBox::PreCreateBox(WNDCLASSEX& wcex)\n{\n    wcex.hbrBackground = reinterpret_cast<HBRUSH>(::GetStockObject(WHITE_BRUSH));\n}\n```\n运行效果如下：\n![](../../images/Windows_基于模板设计/image-20240729014226553.png)\n## OnPaint绘制图形\n可以重写`template<typename ParentBox, typename InheritedT> class GeometryBox`中的方法`void OnPaint(Graphics&, HDC, PAINTSTRUCT*, bool)`。\n```cpp\n// TypistWindow.h\n// ...\nclass TypistCentralBox : public harbin::GeometryBox<TypistFrame, TypistCentralBox>\n{\npublic:\n    // ...\n    void typist::TypistCentralBox::OnPaint(\n        Graphics& graphics,\n        HDC hDC,\n        PAINTSTRUCT* pPS,\n        bool bDragRepaint = false);\n}\n```\n其中Graphics指定的是绘制图形的接口，有GDI和GDI+。\n因为我们在`TypistWindow.h`中引入了`QuickGeometry.hpp`，而`QuickGeometry.cpp`中引入了`<gdiplus.h>`，因此无需再次引入。\n```cpp\n// TypistWindow.cpp\n// ...\nvoid typist::TypistCentralBox::OnPaint(\n    Graphics& graphics,\n    HDC hDC,\n    PAINTSTRUCT* pPS,\n    bool bDragRepaint /* = false */)\n{\n    Gdiplus::Color color(200, 255, 255, 0);\n    Gdiplus::Pen pen(color, 3.0f);\n    Gdiplus::PointF pt{ 100.0f, 100.0f };\n    Gdiplus::PointF pt2{ 300.0f, 300.0f };\n    graphics.DrawLine(&pen, pt, pt2);\n}\n```\n效果如下：\n![](../../images/Windows_基于模板设计/image-20240729054744344.png)\n### 关于GDI\nGDI（Graphics Device Interface）是Windows的子系统，意为图形设备接口，是策略模式的一种。\nGDI用于在DC（Device Context）上绘画。\n\nGDI 主要用于绘制图形和文本，以及管理显示设备（如显示器和打印机）。它提供了基本的绘图功能，包括线条、矩形、椭圆、位图、字体等。\n\nGDI 是一个成熟但相对低级的接口，提供的图形功能比较基础，性能较高，但不支持复杂的图形效果和抗锯齿等现代图形技术。\n### GDI+\nGDI+ 是 GDI 的增强版，他们都是Windows操作系统中的图形编程接口。GDI+提供了更现代化和丰富的图形功能，有更多高级功能和更高的抽象层次。包括矢量图形、浮点坐标、颜色渐变、复杂区域填充、透明度和抗锯齿等。它简化了许多图形编程任务，并且能更好地处理复杂的图形效果。但相对而言，性能可能不如 GDI 高。\n## 左窗口画文字\nTypistLeftBox 类重写`template<typename ParentBox, typename InheritedT> class GeometryBox`中的方法`void OnPaint(Graphics&, HDC, PAINTSTRUCT*, bool)`。\n```cpp\n// TypistWindow.h\n// ...\nclass TypistLeftBox : public harbin::GeometryBox<TypistFrame, TypistCentralBox>\n{\npublic:\n    // ...\n    void typist::TypistLeftBox::OnPaint(\n        Graphics& graphics,\n        HDC hDC,\n        PAINTSTRUCT* pPS,\n        bool bDragRepaint = false);\n}\n```\n实现\n```cpp\n// TypistWindow.cpp\n// ...\nvoid typist::TypistLeftBox::OnPaint(\n    Graphics& graphics,\n    HDC hDC,\n    PAINTSTRUCT* pPS,\n    bool bDragRepaint /* = false */)\n{\n    Gdiplus::FontFamily fontFamily(L\"Times New Roman\");\n    Gdiplus::Font font(&fontFamily, 24, Gdiplus::FontStyle::FontStyleBold, Gdiplus::UnitPoint);\n    Gdiplus::PointF pf(10.0f, 100.0f);\n    Gdiplus::SolidBrush br(Color(200, 255, 200, 255));\n    graphics.DrawString(L\"Hello\", -1, &font, pt, &br);\n}\n```\n效果如下：\n![](../../images/Windows_基于模板设计/image-20240729055923683.png)\n\n## 类设计\n\n1. ScoreManager：积分管理\n2. SceneManager：游戏主场景管理，主要管理画面中的Character\n3. Character：屏幕上显示的一个个字符\n4. InputManager：输入管理，包括键盘输入、手柄输入、网络事件\nn个Character受1个SceneManager管理，而ScoreManager、SceneManager、InputManager三者均有可能相互通信，如果直接面向具体的对象进行编程，是不符合依赖倒转原则、迪米特原则的。应该设计抽象的接口，使这三者通过接口进行联系。\n![](../../images/Windows_基于模板设计/image-20240713062352836.png)\n\n总体的流程：\n1. ScoreManager、SceneManager在Publisher处订阅消息。publisher将其加入记录。\n2. InputManager是Publisher。InputManager依赖Character，管理、生成着CharacterArg。\n3. 当Windows系统监听到按键后，调用InputManager的`key_down`，即被触发激活，InputManager包装消息、内容（键字母）打包给对应的监听者并notify，即调用其update。\n4. 各自处理消息。\n\n消息类型：\n1. 按下字符消息\n2. 加分消息\n3. 字符死亡消息（字符落到底线）\n4. 更新画面消息\n5. 新的字符生成消息\n## 观察者模式\n\n右键项目名称，Add New Filter，取名`Typist Game`。在此Filter下新建`IListener.h`等文件。\n### IArgument\nIArgument接口类规范：每个Argument类都要实现对外实现一个`publisher`接口，该接口主要用于外部获取当前Argument的消息来源。\n\nArgument 类的作用：用于IListener中update接口中参数2包装消息。\n\n该文件还定义了消息类型，以枚举类实现。\n```cpp\n// IArgument.h\n// ...\nnamespace typist\n{\nclass IPublisher;\nclass IArgument\n{\npublic:\n    // 消息来源\n    virtual IPublisher* publisher(void) const = 0;\n};\n\nenum class TPMSG\n{\n    Character,\n    IncreaseScore,\n    Stop,\n    Update,\n    Generate\n};\n}\n```\n### IListener\n总览\n```cpp\n// IListener.h\n#pragma once\nnamespace typist\n{\n    // Typist Messages\n    enum TPMSG\n    {\n        // ...\n    };\n\n    // incomplete type claim\n    class IPublisher;\n\n    class Argument\n    {\n        // ...\n    };\n    \n    class IListener\n    {\n        // ...\n    };\n}\n```\n#### update接口\n```cpp\n// IListener.h\n// ...\n#include <memory>\n#include \"IArgument.h\"\nclass IListener\n{\npublic:\n    // 响应事件\n    // 参数1: 事件类型  参数2: 事件所携带的内容\n    virtual bool update(TPMSG msg, std::shared_ptr<IArgument> arg) = 0;\n};\n```\n### IPublisher\n在Typist Game下创建`IPubilisher.h`\n总览：\n```cpp\n// IPublisher.h\n#pragma once\n\nnamespace typist\n{\n    class IPublisher\n    {\n        // ...\n    };\n}\n```\n#### 接口\n```cpp\n// IPublisher.h\n// ...\n\n#include \"IListener.h\"\nclass IPublisher\n{\npublic:\n    // 参数1: 关注哪个消息\n    virtual void add_listener(TPMSG msg, std::shared_ptr<IListener> listener) = 0;\n    virtual void remove_listener(TPMSG msg, std::shared_ptr<IListener> listener) = 0;\n    virtual void notify(TPMSG msg) = 0;\n};\n```\n### InputManager\nInputManager是一个信息发布者。所以需要引入`IPublisher.h`并且继承（实现接口）。\n```cpp\n// InputMgr.h\n#pragma once\n\n#include \"IPublisher.h\"\nnamespace typist\n{\n    class InputMgr : IPublisher\n    {\n        // ...\n    };\n}\n```\n#### 单例模式\nInputMgr整个系统只需一个，应用单例模式。\n```cpp\n// InputMgr.h\n// ...\nclass InputMgr : IPublisher\n{\npublic:\n    static std::shared_ptr<InputMgr> instance_ptr(void);\n    static InputMgr& instance(void);\n    static void destroy_instance(void);\nprivate:\n    InputMgr();\n    InputMgr(InputMgr const&) = delete;\n    InputMgr(InputMgr&&) noexcept = delete;\n    ~InputMgr();\n    static void delete_self(InputMgr* p);\nprivate:\n    static std::shared_ptr<InputMgr> _input_mgr;\n};\n```\n#### 实现IPublisher接口\n\n解决完单例的特性，来看InputMgr作为一个Publisher的本职工作：首先需要实现IPublisher的抽象方法。\n```cpp\n// InputMgr.h\n// ...\nclass InputMgr : IPublisher\n{\npublic:\n    // ...\n\n    // implementation of IPublisher\n    void add_listener(TPMSG msg, std::shared_ptr<IListener> listener) override;\n    void remove_listener(TPMSG msg, std::shared_ptr<IListener> listener) override;\n    void notify(TPMSG msg) override;\nprivate:\n    // ...\n};\n```\n<span id=\"jump\"></span>\n其次，一个Publisher需要提供让其他人订阅的功能，因此要提供一个容器，保存Listener的信息。\n以消息为Key，对应多个Listener。\n##### 为什么需要weak_ptr\n1. 总体用map来封装，其中键用TPMSG枚举类，值用list容器装，不要使用`shared_ptr`而是使用`weak_ptr`，因为Listener的生命不能由Publisher做主，Publisher只是一个通知方。这个list容器是对内部提供的。 \n2. 对外部，需要提供一个激活函数。比如外部感知到按下键盘后，外部调用`key_down`函数，等于通知InputMgr，然后，InputMgr就调用自己的notify通知对应的Listener。\n3. `_current_key`用于记录监听到`key_down`时的信息，之后用于`notify`。[为什么需要_current_key](#notify实现)\n```cpp\n// InputMgr.h\n// ...\n#include <map>\nclass InputMgr : IPublisher\n{\npublic:\n    // ...\n    void key_down(unsigned int key);\nprivate:\n    // ...\n    std::map<TPMSG, std::list<std::weak_ptr<IListener>>> _listeners;\n    unsigned int   _current_key;\n}\n```\n### InputManager实现\n`InputMgr.cpp`建在 Filter `Typist Game`中。\n\n单例模式的创建、销毁的实现略。\n#### add、remove listener\n`add_listener`虽然参数2是强共享指针，但经过隐式转换后，到了Publisher的`_listeners[msg]`容器中，就成了弱指针。[为什么需要weak_ptr](#为什么需要weak_ptr)\n```cpp\n// InputMgr.cpp\n\n#include <algorithm>. // remove_if\n\nvoid typist::InputMgr::add_listener(\n    TPMSG msg, std::shared_ptr<IListener> listener)\n{\n    _listeners[msg].emplace_back(listener);\n}\n\nvoid typist::InputMgr::remove_listener(\n    TPMSG msg, std::shared_ptr<IListener> listener)\n{\n    auto it = _listeners.find(msg);\n    if (it != _listeners.end())\n    {\n        auto it2 = std::remove_if(\n            it->second.begin(),\n            it->second.end(),\n            [&listener](auto&& v) -> bool\n            {\n                return v.lock() == listener;\n            });\n\n        while (it2 != it->second.end())\n        {\n            it2 = it->second.erase(it2);\n        }\n    }\n}\n// 第2种写法：\n    if (it != _listeners.end())\n    {\n        auto it2 = std::remove_if(\n            it->second.begin(),\n            it->second.end(),\n            [&listener](auto&& v) -> bool\n            {\n                return v.lock() == listener;\n            });\n\n        it->second.erase(it2, it->second.end());\n    }\n// 第3种写法：（C++20标准，用到了ranges）\n    if (it != _listeners.end())\n    {\n        auto it2 = std::ranges::remove_if(\n            it->second,\n            [&listener](auto&& v) -> bool\n            {\n                return v.lock() == listener;\n            });\n        // error，不行，下去得看看为啥\n        it->second.erase(it2, it->second.end());\n    }\n```\n#### notify实现\n```cpp\nvoid typist::InputMgr::notify(TPMSG msg)\n{\n    auto it = _listeners.find(msg);\n    if (it == _listeners.end())\n        return;\n\n    std::shared_ptr<IArgument> arg;\n    if (msg == TPMSG::Character)\n    {\n        // 此处的_current_key在key_down后存储到成员变量中\n        arg.reset(new CharacterArg{ this, _current_key });\n    }\n    std::ranges::for_each(\n        it->second,\n        [&msg, arg](auto&& v) -> void\n        {\n            if (auto&& listener = v.lock())\n            {\n                listener->update(msg, arg);\n            }\n        });\n}\n```\n#### key_down\n本方法由外部的窗口类调用。当窗口监听到键盘按下的系统消息(OnKeyDown)时，通过InputMgr的单例对象来调用`key_down`，具体操作是设置`_current_key`。\n然后窗口类再调用InputMgr的notify。\n```cpp\nvoid typist::InputMgr::key_down(unsigned int key)\n{\n    _current_key = key;\n}\n```\n#### update_time\n成员方法。处理Update消息。Update消息对应于：每隔2秒钟，游戏主场景中的字母要下落。\n```cpp\n// InputMgr.h\n// ...\nclass InputMgr : IPublisher\n{\npublic:\n    // ...\n    void update_time(void);\nprivate:\n    // ...\n}\n```\n实现\n```cpp\nvoid typist::InputMgr::update_time(void)\n{\n    notify(TPMSG::Update);\n}\n```\n增设notify中消息的if判断条件：\n```cpp\nvoid typist::InputMgr::notify(TPMSG msg)\n{\n    // ...\n    if (/* ... */)\n    {\n        // ...\n    }\n    else if (msg == TPMSG::Update)\n    {\n        arg.reset(new UpdateArg{ this });\n    }\n    // ...\n}\n```\n#### generate_time\n成员方法。用于处理Generate消息，对应于每隔几秒，产生新的字符的需求。\n```cpp\n// InputMgr.h\n// ...\nclass InputMgr : IPublisher\n{\npublic:\n    // ...\n    void generate_time(void);\nprivate:\n    // ...\n}\n```\n实现\n```cpp\nvoid typist::InputMgr::generate_time(void)\n{\n    notify(TPMSG::Generate);\n}\n```\n增设notify中消息的if判断条件：\n```cpp\nvoid typist::InputMgr::notify(TPMSG msg)\n{\n    // ...\n    if (/* ... */)\n    {\n        // ...\n    }\n    // ...\n    else if (msg == TPMSG::Generate)\n    {\n        arg.reset(new GenerateArg{ this });\n    }\n    // ...\n}\n```\n### CharacterArg\n```cpp\n// CharacterArg.h\n#pragma once\n#include \"IArgument.h\"\nnamespace typist\n{\n    class CharacterArg : public IArgument\n    {\n        // ...\n    };\n}\n```\n自己的东西：一个publisher指针，一个key\n```cpp\n// CharacterArg.h\n\n// ...\n\nclass CharacterArg : public IArgument\n{\npublic:\n    CharacterArg(IPublisher* publisher, unsigned int key)\n        : _publisher{ publisher }, _key{ key }\n    {\n        \n    }\n    unsigned int key(void) const\n    {\n        return _key;\n    }\nprivate:\n    IPublisher*  _publisher;\n    unsigned int _key;\n};\n```\n\n还需实现IArgument的接口：publisher，用于外部获取Arg的私有变量`_publisher`，即该消息的发布者。[为什么？IArgument](#IArgument)\n```cpp\n// CharacterArg.h\n\n// ...\n\nclass CharacterArg : public Argument\n{\npublic:\n    // ...\n    IPublisher* publisher(void) const\n    {\n        return _publisher;\n    }\nprivate:\n    // ...\n};\n```\n至此，CharacterArg可以被包含在InputMgr中了\n### UpdateArg\n对应Update消息。主要作用是生成一个当前的时间戳。\n```cpp\n#include \"IArgument.h\"\nnamespace typist\n{\nclass UpdateArg : public IArgument\n{\npublic:\n    UpdateArg(IPublisher* publisher)\n        : _publisher{ publisher },\n          _tp{ std::chrono::high_resolution_clock::now() }\n    {\n    }\n    virtual IPublisher* publisher(void) const\n    {\n        return _publisher;\n    }\n    std::chrono::time_point<std::chrono::high_resolution_clock> time(void) const\n    {\n        return _tp;\n    }\nprivate:\n    IPublisher*     _publisher;\n    std::chrono::time_point<std::chrono::high_resolution_clock> _tp;\n};\n}\n```\n#### Modern Cpp表达时间的方式\n由`<chrono>`库提供。\n主要有3个概念：\n1. Durations（持续时间）：时间段\n2. Time points（时间点）：时刻，两个时刻相减是时间段\n3. Clocks（时钟）：用于把时间点和物理意义上的时间相关联的框架。提供了3个时钟，可以将当前时间表示为`time_point`\n    1. system_clock（以系统的时间为准，但是如果系统时钟被改了会导致程序错乱）\n    2. steady_clock（以程序自身的时间为准，不易混乱）\n    3. high_resolution_clock（推荐用）\n\n### GenerateArg\n对应 Generate 消息。主要作用是生成一个当前的时间戳。\n```cpp\n#include \"IArgument.h\"\nnamespace typist\n{\nclass GenerateArg : public IArgument\n{\npublic:\n    GenerateArg(IPublisher* publisher)\n        : _publisher{ publisher }\n    {\n    }\n    virtual IPublisher* publisher(void) const\n    {\n        return _publisher;\n    }\nprivate:\n    IPublisher*     _publisher;\n};\n}\n```\n### Character 类、ChPoint 类\nCharacter做字符的渲染工作。\nChPoint是字符的坐标的封装。\n```cpp\n// Character.h\n#include <gdiplus.h>\nnamespace typist\n{\nclass ChPoint\nclass Character\n{\npublic:\n    Character(wchar_t ch, int x, int y);\n    ChPoint xy(void) const;\n    void xy(ChPoint pt);\n    void render(Gdiplus::Graphics& graphics) const;\nprivate:\n    wchar_t _ch;\n    int     _x, _y; // pos\n};\n}\n```\n实现\n```cpp\n// Character.cpp\ntypist::Character::Character(wchar_t ch, int x, int y)\n    : _x{ x }, _y{ y }, _ch{ ch }\n{\n}\ntypist::ChPoint typist::Character::xy(void) const\n{\n    return { _x, _y };\n}\nvoid typist::Character::xy(ChPoint pt)\n{\n    _x = pt._x;\n    _y = pt._y;\n}\n```\n渲染实现：\nDrawString参数：\n1. 内容\n2. 画多少内容（-1代表一直画到字符串的`\\0`）\n3. 字体的指针\n4. 坐标\n5. 画刷的指针\n```cpp\nvoid typist::Character::render(Gdiplus::Graphics& graphics) const\n{\n    Gdiplus::FontFamily fontFamily(L\"Times New Roman\");\n    Gdiplus::Font font(&fontFamily, 18, Gdiplus::FontStyle::FontStyleBold, Gdiplus::UnitPoint);\n    Gdiplus::PointF pf(static_cast<float>(_x), static_cast<float>(_y));\n    Gdiplus::SolidBrush br(Color(200, 55, 100, 255));\n    graphics.DrawString(&_ch, 1, &font, pt, &br);\n}\n```\n### SceneManager 场景类\n场景管理类用于重绘窗口、相应事件、画图形。\n\n`SceneMgr.h`建在Filter `Typist Game`中。\n```cpp\n#include<gdiplus.h>\n#include \"IListener.h\"\nnamespace typist\n{\nclass Character;\nclass UpdateArg;\nclass GenerateArg;\nclass SceneMgr : public IListener\n{\npublic:\n    SceneMgr();\n    ~SceneMgr();\n    void render(Graphics& graphics) const;\n    // implementation for IListener\n    bool update(TPMSG msg, std::shared_ptr<IArgument> arg) override;\n\nprivate:\n    void on_update(std::shared_ptr<UpdateArg> arg);\n    void on_generate(std::shared_ptr<UpdateArg> arg);\n\nprivate:\n    std::list<std::shared_ptr<Character>> _chs;\n};\n}\n```\n实现\n`SceneMgr.cpp`建在Filter `Typist Game`中。\n```cpp\n#include \"SceneMgr.h\"\n#include \"Character.h\"\n#include \"UpdateArg.h\"\n#include \"GenerateArg.h\"\n#include <algorithm>\n#include <ranges> \ntypist::SceneMgr::SceneMgr()\n{\n    srand(time(NULL));\n}\ntypist::SceneMgr::~SceneMgr()\n{\n}\nvoid typist::SceneMgr::render(Graphics& graphics) const\n{\n    std::ranges::for_each(_chs, [&graphics](auto&& ch) -> void\n        {\n            ch->render(graphics);\n        });\n}\n\nbool ypist::SceneMgr::update(TPMSG msg, std::shared_ptr<IArgument> arg)\n{\n    if (msg == TPMSG::Update)\n    {\n        on_update(std::dynamic_pointer_cast<UpdateArg>(arg));\n        return true;\n    }\n    else if (msg == TPMSG::Generate)\n    {\n        on_generate(std::dynamic_pointer_cast<GenerateArg>(arg));\n    }\n    return false;\n}\n// private内部调用的方法可以写为inline的\ninline void typist::SceneMgr::on_update(std::shared_ptr<UpdateArg> arg)\n{\n    std::ranges::for_each(_chs, [](auto&& ch) -> void\n        {\n            // structured binding\n            auto && [x, y] = ch->xy();\n            ch->xy({ x, y + 5 });\n        });\n}\n// 使用到随机数，随机种子在构造函数中初始化。\ninline void typist::SceneMgr::on_generate(std::shared_ptr<UpdateArg> arg)\n{\n    _chs.emplace_back(\n        std::shared_ptr<Character>(\n            new Character('A' + rand() % 26, rand() % 500, -20)));\n}\n```\n#### 技术点\n1. private内部调用的方法可以写为inline的\n2. 一般用`dynamic_cast`转换多态指针。但是如果涉及到了智能指针，如上述代码中的`update`方法中`shared_ptr<IArgument> arg`，则我们的目的是转换智能指针包含的内容。此时有对应的`std::dynamic_pointer_cast<T>`。模板参数填写要转换的子类型。\n```cpp\nstd::dynamic_pointer_cast<UpdateArg>(arg)\n```\n3. 结构化绑定：能把key和value分开提取：叫做结构化绑定（structured binding）[Cpp_STL_关联容器](../Cpp/Cpp_STL_关联容器.md)\n### TypistWindow编写\n#### 对SceneMgr的处理\n```cpp\n// TypistWindow.h\n\n#include <memory>\n#include <string>\n#include \"QuickGeometryUI.hpp\"\nnamespace typist\n{\nclass SceneMgr;\n\n// ...\n\nclass TypistCentralBox : public harbin::GeometryBox<TypistFrame, TypistCentralBox>\n{\npublic:\n    // ...\nprivate:\n    std::shared_ptr<SceneMgr> _scene_mgr;\n}\n}\n```\n构造函数初始化`_scene_mgr`：\n```cpp\n// TypistWindow.cpp\ntypist::TypistCentralBox::TypistCentralBox(TypistFrame* frame, std::wstring const& name)\n    : GeometryBox{ frame, name.c_str() }\n{\n    _scene_mgr = std::shared_ptr<SceneMgr>(new SceneMgr);\n}   \n```\nOnPaint实现：\n```cpp\ntypist::TypistCentralBox::OnPaint(Graphics& graphics, HDC hDC, PAINTSTRUCT* pPS, bool bDragRepaint/* = false */)\n{\n    if (_scene_mgr)\n    {\n        _scene_mgr->render(graphics);\n    }\n}\n```\n#### 对InputMgr的处理\n构造函数中订阅InputMgr：\n```cpp\n// TypistWindow.cpp\ntypist::TypistCentralBox::TypistCentralBox(TypistFrame* frame, std::wstring const& name)\n    : GeometryBox{ frame, name.c_str() }\n{\n    // ...\n        \n    InputMgr::instance_ptr()->add_listener(TPMSG::Generate, _scene_mgr);\n    InputMgr::instance_ptr()->add_listener(TPMSG::Update, _scene_mgr);\n    \n}   \n```\n析构函数中注销订阅InputMgr：\n```cpp\ntypist::TypistCentralBox::~TypistCentralBox()\n{\n    if (_scene_mgr)\n    {\n        InputMgr::instance_ptr()->remove_listener(TPMSG::Generate, _scene_mgr);\n        InputMgr::instance_ptr()->remove_listener(TPMSG::Update, _scene_mgr);\n    }\n}\n```\n#### 定时器\n定时器的功能继承于基类`GeometryBox`\n```cpp\n// TypistWindow.h\nclass TypistCentralBox : public harbin::GeometryBox<TypistFrame, TypistCentralBox>\n{\npublic:\n    // ...\n    void OnTimer(int iIdentifier);\nprivate:\n    // ...\n}\n```\n构造函数中SetTimer：\n1. 参数1是ID号，宏定义给出\n2. 参数2是interval，间隔多久更新一次，单位为ms\n```cpp\n// TypistWindow.cpp\n\n#define UPDATE_TIMER_ID   10\n#define GENERATE_TIMER_ID 11\n\ntypist::TypistCentralBox::TypistCentralBox(TypistFrame* frame, std::wstring const& name)\n    : GeometryBox{ frame, name.c_str() }\n{\n    // ...\n        \n    SetTimer(UPDATE_TIMER_ID, 500);   // 500ms刷新一次\n    SetTimer(GENERATE_TIMER_ID, 3000);// 3s 产生一个字符\n    \n}   \n```\n析构函数中 KillTimer：\n```cpp\ntypist::TypistCentralBox::~TypistCentralBox()\n{\n    KillTimer(UPDATE_TIMER_ID);\n    KillTimer(GENERATE_TIMER_ID);\n    // ...\n}\n```\n实现OnTimer：\n1. 处理TIMER，进行notify相应的消息\n2. ReDrawBox重绘，是基类的方法\n```cpp\nvoid typist::TypistCentralBox::OnTimer(int iIdentifier)\n{\n    switch (iIdentifier)\n    {\n    case UPDATE_TIMER_ID:\n        InputMgr::instance_ptr()->notify(TPMSG::Update);\n        ReDrawBox();\n        break;\n    case GENERATE_TIMER_ID:\n        InputMgr::instance_ptr()->notify(TPMSG::Generate);\n        ReDrawBox();\n        break;\n    default:\n        break;\n    }\n}\n```","categories":["设计模式","Windows"]},{"title":"Cpp_拼接字符串的几种方法（format）","url":"/Cpp/Cpp_拼接字符串的几种方法（format）/","content":"\n```cpp\n{\n    case WM_LBUTTONDOWN:\n    {\n        int x_coord = lparam & 0xffff;\n        int y_coord = lparam >> 16;\n        // 拼接x、y，最后效果：\"x, y\"\n    }\n}\n```\n# C风格：swprintf\n使用C语言的`wchar_t`宽字符数组，加上swprintf\n```cpp\n{\n    {\n        // ...\n        wchar_t text[50] = L\"\";\n        swprintf(text, 50, L\"%i, %i\", x_coord, y_coord);\n    }\n}\n```\n# string风格\n使用`C++`的string库\n```cpp\n{\n    {\n        // ...\n        std::wstring text;\n        text += std::to_wstring(x_coord);\n        text += L\", \";\n        text += std::to_wstring(y_coord);\n    }\n}\n```\n# 流式风格\n使用`C++`的流式IO\n```cpp\n{\n    {\n        // ...\n        std::wstringstream wss;\n        wss << x_coord << L\", \" << y_coord;\n    }\n}\n```\n# format库\n使用`C++`的format库，format是`C++20`标准库引入的。类似于C语言的标准格式化输出。[std::format - cppreference.com](https://en.cppreference.com/w/cpp/utility/format/format)。相应地，给出了标准格式化规格：[Standard format specification - cppreference.com](https://en.cppreference.com/w/cpp/utility/format/spec)\n```cpp\n{\n    {\n        // ...\n        std::wstring text = std::format(L\"{0}, {1}\", x_coord, y_coord);\n    }\n}\n```\n相当于用大括号替代了C语言格式化输出中的`%?`。\n```cpp\n#include <format>\n#include <iostream>\nint main()\n{\n    std::cout << std::format(\"{} {}!\", \"Hello\", \"world\", \"something\");\n}\n```\n如果需要控制格式化输出（即后面有一些可变参数），大括号是必须要写。它是占位的，而大括号里面的内容有可选的内容，具体参考[std::format](https://en.cppreference.com/w/cpp/utility/format/format)中fmt参数的replacement fields：\n1. `{ arg-id (optional) }`\n    1. replacement field without a format specification\n2. `{ arg-id (optional) : format-specification }`\n    1. replacement field with a format specification\n\n`arg-id`: specifies the index of the argument in `args` whose value is to be used for formatting; if it is omitted, the arguments are used in order. The arg-id ﻿s in a format string must all be present or all be omitted. Mixing manual and automatic indexing is an error.\n\n`format-spec`: the format specification defined by the `std::formatter` specialization for the corresponding argument. Cannot start with `}`.\n\n有很多format specification：\n![](../../images/Cpp_拼接字符串的几种方法（format）/image-20240827042103155.png)\n这里重点看一下[standard format specification](https://en.cppreference.com/w/cpp/utility/format/spec \"cpp/utility/format/spec\")：\n值得注意的是，cppreference承认了Standard format specification基于Python中的格式规范，供基本类型和字符串类型使用。\n## 格式规范\n格式规范的语法是：（不同控制项以空格为间隔；每一项都是optional）\n```\nfill-and-align ﻿ sign # 0 width precision L type\n```\n其中`sign`、 `#`和 `0` 选项仅在使用整数或浮点表示类型时有效。\n### fill-and-align\n填充和对齐\n\n可以填可选的`fill（填充）字符`（`'{'` 或 `'}'` 以外的任何字符），后跟一个`align（对齐）`选项 `<` ， `>` ， `^` 。\n* 填充字符需要注意：\n    1. 如果未指定填充字符，则默认为空格字符。\n    2. 填充字符必须对应于单个Unicode标量值。\n* 对齐选项需要注意：\n    1. `<` : 通过在格式化参数后插入n个填充字符，强制格式化参数与可用空间的开头对齐。如果使用非整数非浮点表示类型时，此为默认选项（`<`）。\n        1. 一句话说：填充字符填充到右边\n    2. `>` : 通过在格式化参数之前插入n个填充字符，强制格式化参数与可用空间的末尾对齐。使用整数或浮点表示类型时，此为默认选项。\n        1. 一句话说：填充字符填充到左边\n    3. `^`：通过在格式化参数前面插入`⌊ n/2 ⌋`（向下取整）个字符，在格式化参数后面插入` ⌈ n / 2 ⌉`（向上取整）个字符来强制格式化参数在可用空间内居中。\n        1. 一句话说：填充字符填充到两边，填充奇数份时，左比右少1个。\n\n示例：\n```cpp\nchar c = 120;\nstd::format(\"{:6}\", 42);    // value of s0 is \"    42\"\nstd::format(\"{:>6}\", 42);   // value of s0 is \"    42\"\nstd::format(\"{:6}\", 'x');   // value of s1 is \"x     \"\nstd::format(\"{:<6}\", 'x');  // value of s1 is \"x     \"\nstd::format(\"{:*<6}\", 'x'); // value of s2 is \"x*****\"\nstd::format(\"{:*>6}\", 'x'); // value of s3 is \"*****x\"\nstd::format(\"{:*^6}\", 'x'); // value of s4 is \"**x***\"\nstd::format(\"{:6d}\", c);    // value of s5 is \"   120\"\nstd::format(\"{:6}\", true);  // value of s6 is \"true  \"\n```\n### `sign`, `#`, `0`\n\n`sign`选项可以是以下选项之一：\n- `+` : 表示对于非负数和负数都显示符号。对于非负数，在输出值之前插入 `+` 符号。\n- `-` : 仅负数显示符号 (这是默认的sign值)。\n- `空格`: 非负数前面显示前导空格位，负数显示负号。\n\n要注意：\n1. 负零被视为负数。\n2. sign选项也适用于浮点无穷大和NaN。\n\n`#`和`0`暂略。\n### width and precision\n宽度和精度\n\nwidth是正十进制数或嵌套替换字段 ( `{}` 或 `{ n }` )。如果存在，则它指定最小字段宽度。\n\nprecision是一个点 ( `.` )后跟一个非负的十进制数或嵌套的替换字段。此字段指示精度或最大字段大小。它只能用于浮点和字符串类型。\n* 对于浮点类型，此字段指定格式精度。\n* 对于字符串类型，它为要复制到输出的字符串的前缀的估计宽度 (见下文) 提供了上限。对于Unicode编码的字符串，要复制到输出的文本是整个扩展字形簇（extended grapheme clusters）的最长前缀，其估计宽度不大于精度。\n\n注意：\n1. 如果嵌套替换字段用于宽度或精度，而相应的参数不是整数类型（直到`C++23`）、标准有符号或无符号整数类型（从`C++23`开始），或者它是负数，则会抛出`std::format_error`类型的异常。\n2. 字符串的宽度被定义为适于在终端中显示它的列位置的估计数量。\n![](../../images/Cpp_拼接字符串的几种方法（format）/image-20240827053920009.png)\n\n示例：\n```cpp\nfloat pi = 3.14f;\ns1 = std::format(\"{:10f}\", pi);           // s1 = \"  3.140000\" (width = 10)\ns2 = std::format(\"{:{}f}\", pi, 10);       // s2 = \"  3.140000\" (width = 10)\ns3 = std::format(\"{:.5f}\", pi);           // s3 = \"3.14000\" (precision = 5)\ns4 = std::format(\"{:.{}f}\", pi, 5);       // s4 = \"3.14000\" (precision = 5)\ns5 = std::format(\"{:10.5f}\", pi);         // s5 = \"   3.14000\"\n                                               // (width = 10, precision = 5)\ns6 = std::format(\"{:{}.{}f}\", pi, 10, 5); // s6 = \"   3.14000\"\n                                               // (width = 10, precision = 5)\n \nb1 = std::format(\"{:{}f}\", pi, 10.0);     // throws: width is not of integral type \nb2 = std::format(\"{:{}f}\", pi, -10);      // throws: width is negative\nb3 = std::format(\"{:.{}f}\", pi, 5.0);     // throws: precision is not of integral type\n```\n# print println\n这是`C++23`引入的。\n不带流参数的，在`<print>`库中定义。\n带流参数的，在`<ostream>`库中定义。\n\n```cpp\nprint(\"Hello, {}!\\n\", \"world\");\n// 等价于\nprintln(\"Hello, {}!\", \"world\");\nprint(stdout, \"Hello, {}!\\n\", \"world\");\nprintln(stdout, \"Hello, {}!\", \"world\");\n```\n但是，截止2025年8月27日，print还不支持输出宽字符。","categories":["Cpp","Modern"]},{"title":"Windows_Handle_调用方式","url":"/Windows/Windows_Handle_调用方式/","content":"# 句柄的实现\n\n以HWND为例。\n\n```cpp\nDECLARE_HANDLE      (HWND);\n```\n\n```cpp\n#define DECLARE_HANDLE(name)\nstruct name##__{\n    int unused;\n};\ntypedef struct name##__ *name\n```\n以上是带参数的宏定义，意味着，后面所有的“name”将被替换。\n`##`是粘连符号，以区分`\"name__\"`和`name + __`，即如果不用粘连符号，假如在程序中写`DECLARE_HANDLE(HWND)`时就无法替换name了，而是生成了`name__`。如果正确用粘连符号，那么就生成`HWND__`。\n即：\n```cpp\nDECLARE_HANDLE(HWND);\n\n==等效于\n\nstruct HWND__{ int unused; };\ntypedef struct HWND__ * HWND;\n```\n\n其中，`int unused;`仅作为占位符，即垫片。实际是不使用的，内容值无意义。主要来定义一个类型，使用其类型的指针，以防止与其他类型的HANDLE指针误互相赋值。\n\n相似地，HDC（Handle of Device Context）也是用这个宏定义的，只是类型名不同。\n\n# CALLBACK\n\n```cpp\n#define CALLBACK __stdcall\n```\n\n调用方式是在C语言层面上的话题，和操作系统是无关的，是给编译器的提示。\n\n`__stdcall`和`__cdecl`是有主要区别的。在其他编译器下，可能有不同的设置方法。从`C++17`标准后，可设置attributes，逐渐变统一了。\n在MAC系统上，常用的是`__pascal`调用方式。\n\n1. 压栈方向上，\n    1. CDECL是从右向左压栈\n    2. PASCAL是从左向右压栈\n    3. STDCALL是从右向左压栈\n2. CDECL的含义是C语言的调用方式，为了支持可变参数，由于被调用者不清楚参数数目，因此需要调用者来清理栈。\n3. PASCAL和STDCALL也称为快速调用。因为在被调用者返回时，顺便也会清理栈，效率稍高。\n    1. STDCALL不支持可变参数。\n    2. CDECL支持可变参数（如printf）。\n4. Windows刚面世时，在286的计算机年代，主频可能才60～80 MHz，效率很宝贵。而CALLBACK涉及到多次调用，而且参数数目是固定的4个（见window_procedure），因此STDCALL作为Windows特意的默认调用方式。\n5. 效果是：定义函数时，不主动写调用方式时默认为`CDECL`。显式写CALLBACK时就变成了STDCALL调用方式。\n    1. cdecl 是 C 语言的默认调用约定，广泛用于 C 语言编写的程序中。由于调用者负责清理堆栈，这种调用约定允许可变参数函数（如 printf）。\n    2. stdcall 主要用于 Windows API 函数调用，是 Windows 平台上的标准调用约定之一。由于被调用者负责清理堆栈，这种调用约定在某些情况下可以提高函数调用的效率。\n    3. pascal 调用约定则是历史上在 Pascal 语言中使用的调用约定，现在使用较少。","categories":["操作系统","Windows"]},{"title":"Windows_面向对象程序设计","url":"/Windows/Windows_面向对象程序设计/","content":"# 目的\n把原先集中在`wWinMain`函数的繁重流程拆分为面向对象模式。\n`wWinMain`的任务：[Windows_wchar和wmain](Windows_wchar和wmain.md)\n1. 初始化窗口类对象`WNDCLASSEX wcex`的各种成员值。最重要的一步是lpfnWndProc绑定回调函数。\n2. 注册该窗口类对象。\n3. 创建窗口，返回HWND。\n4. 显示窗口\n5. 更新窗口\n6. 消息循环\n\n以上是窗口类的启动职责。\n除此之外就是消息处理职责了。\n总体上，[使用模板方法设计模式进行相应的消息处理的方法封装](#使用模板方法设计模式进行相应的消息处理的方法封装)。\n# 准备项目\n\n编译之前，要配置好VS项目的属性，右键项目选择Properties，左边栏选择Linker，然后选择System。右边详细条目\"SubSystem\"需下拉选择Windows。\n\n在Header Files中创建Window.h，代表一个窗口。因为本文编写的应用程序是简化的项目，只包含一个进程，代表整个应用程序，所以生命周期和这个窗口是绑定的。目的是为了学习如何封装一个窗口程序的技术。\n\n```cpp\n// Window.h\n\n#include <Windows.h>\n#include <string>\n\n#pragma once\n\nnamespace afk\n{\n    class Window\n    {\n        // ...\n    };\n}\n```\n# Window类设计\n\n需要封装什么属性？\n1. `app_name`\n2. HWND窗口对象\n\n需要封装什么行为？\n1. 窗口的创建（构造函数）\n2. 显示窗口\n3. 消息循环\n\nWindow类初步定义\n```cpp\nclass Window\n{\npublic:\n    Window(std::wstring const & app_name);\n    void show_window(bool show = true);\n    int run(void);\nprotected:\n    HWND        _wnd{ nullptr };\n};\n```\nWindow类初步实现：\n```cpp\n// Window.cpp\n#include \"Window.h\"\nafk::Window::Window(std::wstring const & app_name)\n{\n    WNDCLASSEX wcex = { 0 };\n    wcex.cbSize = sizeof(wcex);\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\n    // 绑定CALLBACK，见后面解释\n    wcex.lpfnWndProc = &window_procedure;\n    // wcex.... = ...;\n    wcex.lpszClassName = app_name.c_str();\n    // wcex.... = ...;\n\n    if (!::RegisterClassEx(&wcex))\n        return;\n    \n    // 定义一个窗口对象的句柄\n    // HWND: 窗口类型的句柄，也叫内核对象\n    _wnd = ::CreateWindowEx(\n        WS_EX_OVERLAPPEDWINDOW,\n        app_name.c_str(),\n        L\"App\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,\n        nullptr,\n        nullptr,\n        hInstance,\n        nullptr);\n    if (!_wnd)\n    {\n        int i = ::GetLastError();\n        return;\n    }\n}\n```\nshow_window实现\n```cpp\nvoid afk::Window::show_window(bool show /*= true*/)\n{\n    if(_wnd)\n    {\n        int nShowCmd = show ? SW_NORMAL : SW_HIDE;\n        // 显示窗口，nShowCmd可以指定窗口以最小/最大/正常状态显示\n        ::ShowWindow(_wnd, nShowCmd);\n        // 更新窗口，绘制窗口。刚显示出来可能是无效的，需要在显示后绘制。\n        ::UpdateWindow(_wnd);\n    }\n}\n```\nrun实现\n```cpp\nint afk::Window::run(void)\n{\n    MSG msg;\n    while (::GetMessage(&msg, nullptr, 0, 0))\n    {\n        // 翻译消息，比如输入法通过‘wo’生成‘我’\n        ::TranslateMessage(&msg);\n        // 发送消息，调用刚才注册的callback窗口处理函数\n        ::DispatchMessage(&msg);\n    }\n    return 0;\n}\n```\n还有一些问题需要解决：\nhInstance暂无；回调函数需要自定义；注册时，需要进行异常处理。\n## CALLBACK写到哪？\n可以写到类中，但是，CALLBACK必须符合Windows的范式，即函数签名一致。则不能有this指针，因此需要设置为static。\n```cpp\nclass Window\n{\npublic:\n    // ...\n    static LRESULT CALLBACK window_procedure(HWND wnd, UINT message, WPARAM wparam, LPARAM lparam);\nprotected:\n    HWND        _wnd{ nullptr };\n};\n```\n实现：\n```cpp\nLRESULT afk::Window::window_procedure(HWND wnd, UINT message, WPARAM wparam, LPARAM lparam)\n{\n    return LRESULT();\n}\n```\n## hInstance怎么处理\nhInstance需要被`window_procedure`访问，因此也需要设置为static的。\n```cpp\nclass Window\n{\npublic:\n    // ...\nprotected:\n    static HINSTANCE  _instance;\n};\n```\n静态变量，需要在`.cpp`文件中，全局初始化。\n最好标记为constinit，以保证其在静态编译时就初始化。\n```cpp\n// Window.cpp\nconstinit HINSTANCE afk::Window::_instance{ nullptr };\n```\n# 如何封装消息处理方法？如何实现CALLBACK具体逻辑？\n## 使用模板方法设计模式进行相应的消息处理的方法封装\n\n比如，处理`WM_LBUTTONDOWN`消息，就为Window类增加一个`on_lbtndown`的成员方法，在CALLBACK中相应的case中调用该方法。  \n注意，考虑继承性，需要设置其为virtual。  \n还需要考虑，要显示出有没有经过用户重写？所以需要返回bool，false代表默认的空操作。\n\n此项目我们需要封装的消息处理方法有：\n1. 左键按下\n2. 左键抬起\n3. 画\n\n```cpp\nclass Window\n{\npublic:\n    // ...\nprotected:\n    virtual bool on_lbtndown(POINT& pt);\n    virtual bool on_lbtnup(POINT& pt);\n    // HDC本身就是指针，没必要传递引用\n    virtual bool on_paint(HDC dc, PAINTSTRUCT& ps);\nprotected:\n    // ...\n};\n```\n此处默认返回false表示用户没有处理此消息。\n>on_paint的参数：\n>1. HDC是BeginPaint的返回值。见：[Windows_wchar和wmain](Windows_wchar和wmain.md)中的[BeginPaint](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint)。\n>2. PAINTSTRUCT是BeginPaint的第2个参数，本项目中实际上暂未使用ps。\n```cpp\nbool afk::Window::on_lbtndown(POINT& pt)\n{\n    return false;\n}\n\nbool afk::Window::on_lbtnup(POINT& pt)\n{\n    return false;\n}\n\nbool afk::Window::on_paint(HDC dc, PAINTSTRUCT& ps)\n{\n    return false;\n}\n```\n需要考虑，CALLBACK是静态方法，不能直接调用**非静态的成员方法**（即各种消息处理函数）。就需要定义一个静态成员变量`Window* _window`来间接调用，相当于自创this指针。\n```cpp\nclass Window\n{\npublic:\n    // ...\nprotected:\n    // ...\n    static Window*    _window;\n};\n```\n编译时的初始化先填一个nullptr值。\n```cpp\n// Window.cpp\nconstinit afk::Window* afk::Window::_window{ nullptr };\n```\n在Window构造时，创建窗口前，使用this指针进行真正的初始化。\n```cpp\nafk::Window::Window(std::wstring const & app_name)\n{\n    _window = this;\n    // ...\n}\n```\n## CALLBACK具体实现\n```cpp\nLRESULT afk::Window::window_procedure(HWND wnd, UINT message, WPARAM wparam, LPARAM lparam)\n{\n    if(!_window)\n        return ::DefWindowProc(wnd, message, wparam, lparam);\n\n    PAINTSTRUCT ps;\n\n    switch (message)\n    {\n    case WM_CREATE:\n        break;\n    case WM_LBUTTONDOWN:\n    {\n        // GET_X/Y_LPARAM From <windowsx.h> \n        int x_coord = GET_X_LPARAM(lparam);\n        int y_coord = GET_Y_LPARAM(lparam);\n        POINT pt{ x_coord, y_coord };\n        // true代表用户处理完毕\n        if (_window->on_lbtndown(pt))\n            return 1;\n    }\n        break;\n    case WM_LBUTTONUP:\n    {\n        // GET_X/Y_LPARAM From <windowsx.h> \n        int x_coord = GET_X_LPARAM(lparam);\n        int y_coord = GET_Y_LPARAM(lparam);\n        POINT pt{ x_coord, y_coord };\n        // true代表用户处理完毕\n        if (_window->on_lbtnup(pt))\n            return 1;\n    }\n        break;\n    case WM_PAINT:\n    {\n        HDC dc = ::BeginPaint(wnd, &ps);\n        bool result = _window->on_paint(dc, ps);\n        ::EndPaint(wnd, &ps);\n        if (result)\n            return 1;\n    }\n        break;\n    case WM_DESTROY:\n        ::PostQuitMessage(0);\n        break;\n    //default:\n    //    ;\n    }\n    return ::DefWindowProc(wnd, message, wparam, lparam);\n}\n```\n# wWinMain放到哪里？\n\n用户不可见，所以可以放到`.cpp`文件中。\n\n涉及到一个问题：`_instance`即使是静态的，但其是非public成员变量，可以用友元来解决类外部函数的访问问题。\n```cpp\nclass Window\n{\n    friend int ::wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int);\npublic:\n    // ...\nprotected:\n    // ...\n};\n```\n其次，wWinMain函数比较复杂，为了便于用户操作，再封装一层main，是供用户使用的接口，即这个函数相对于Window类来讲是用户提供的外部函数，因此标注extern。[用户main](#用户main)\n```cpp\n// Window.cpp\n\n// ...\n\nextern int main(std::wstring const & args);\n\n// ...\nint wWinMain(\n    HINSTANCE hInstance,\n    HINSTANCE hPrevInstance,\n    LPWSTR lpCmdLine,\n    int nShowCmd)\n{\n    afk::Window::_instance = hInstance;\n\n    return main(lpCmdLine);\n}\n```\n\n以上即为一个Window程序的框架。用户可以使用此框架开发自己的程序。\n# 基于框架开发\n定义MyApp类继承Window类。\n```cpp\n// MyApp.h\n#pragma once\n#include \"Window.h\"\nclass MyApp : public afk::Window\n{\npublic:\n    MyApp(std::wstring const & name) : Window{name}\n    {\n        //\n    }\n    bool on_paint(HDC dc, PAINTSTRUCT & ps)\n    {\n        // 测试：画一个矩形\n        //Rectangle(dc, 100, 100, 200, 200);\n        return true;\n    }\n    bool on_lbtndown(POINT& pt)\n    {\n        _pt = pt;\n        return true;\n    }\n    bool on_lbtnup(POINT& pt)\n    {\n        HDC dc = ::GetDC(_wnd);\n        // 从左键按下鼠标点 画直线到 左键弹起的点\n        ::MoveToEx(dc, _pt.x, _pt.y, nullptr);\n        ::LineTo(dc, pt.x, pt.y);\n        \n        ::ReleaseDC(_wnd, dc);\n        return true;\n    }\nprivate:\n    POINT          _pt;\n};\n```\n## 技术点：GetDC\n由于绘制需要得到HDC才可以，而dc只传给了on_paint函数，on_lbtnup中没有dc。\n可以通过`HWND`找到当前窗口的HDC，需要调用`GetDC(HWND)`方法。\n但是要记得，用完之后要ReleaseDC，需要2个参数，1是窗口句柄，2是HDC。\n## 测试\n```cpp\n// main.cpp\n#include \"MyApp.h\"\nint main(std::wstring const & args)\n{\n    MyApp app{L\"app\"};\n    app.show_window();\n    return app.run();\n}\n```\n至此，可以实现左键按下、抬起画直线了。但是一旦改变窗口就导致系统`WM_PAINT`消息重绘窗口，因为暂时没有处理`on_paint`函数，所以已经画上的线条会消失。需要把线条重绘操作集成在`on_paint`方法中，这些线条使用数据结构进行存储。\n## 总结：模板方法模式\n以上方法是模板方法设计模式。主要思想就是围绕一个Framework引擎，本身是可以直接使用的，行为是默认的配置。可以继承以重写一些的方法来完成特定的功能。多用于游戏引擎、应用框架，在底层隐藏了很多细节、可重用的部分。\n## 完善细节：创建窗口前用户自定义配置\n我们想给用户提供一个方法，就是改变窗口的属性。\n需要在wcex注册前对wcex进行更改。\n\n在Window类中封装`pre_create`方法：用于在`WNDCLASSEX`注册之前，用户修改配置。\n```cpp\nclass Window\n{\n    // ...\npublic:\n    // ...\nprotected:\n    // ...\n    virtual void pre_create(WNDCLASSEX& wcex);\n}\n```\n默认的pre_create实现：\n```cpp\n// Window.cpp\n\n// ...\nvoid afk::Window::pre_create(WNDCLASSEX& wcex)\n{\n    // 默认不操作\n    return;\n}\n// ...\n```\nWindow构造函数在注册wcex窗口前加入pre_create\n```cpp\nafk::Window::Window(std::wstring const & app_name)\n{\n    _window = this;\n\n    WNDCLASSEX wcex = { 0 };\n    wcex.cbSize = sizeof(wcex);\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc = &window_procedure;\n    wcex.cbClsExtra = 0;\n    wcex.cbWndExtra = 0;\n    wcex.hInstance = _instance;\n    wcex.hIcon = LoadIcon(nullptr, IDI_SHIELD);\n    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    wcex.hbrBackground = (HBRUSH)(GetStockObject(LTGRAY_BRUSH));\n    wcex.lpszMenuName = NULL;\n    wcex.lpszClassName = app_name.c_str();\n    wcex.hIconSm = wcex.hIcon;\n\n    pre_create(wcex);\n\n    if (!::RegisterClassEx(&wcex))\n        return;\n\n    // ...\n}\n```\n用户自定义`pre_create`：此例中我们修改浅灰色背景为黑色背景。\n```cpp\nclass MyApp : public afk:Window\n{\npublic:\n    // ...\nprotected:\n    void pre_create(WNDCLASSEX& wcex)\n    {\n        // 改变背景色\n        wcex.hbrBackground = (HBRUSH)(GetStockObject(BLACK_BRUSH));\n    }\n\n    // ...\n}\n```\n## 问题解决：不能在构造函数中调用虚方法\n此时测试，发现并没有更改成功。因为我们的设计出现了一个结构性问题：我们在构造Window函数中调用了虚函数`pre_create`，由于虚表是在构造对象的过程中还没被定义，所以会出现失效。所以我们要长个教训，不能在构造函数中赋予太多任务，尤其不能调用虚函数。\n因此需要分解Window构造函数的任务。把其中的`创建窗口`和此处要做的`预创建`剥离出来。实际上，凡是和成员变量无关的，都要剥离。\n\nWindow构造函数剥离出create_window：\n```cpp\n// Window.h\nclass Window\n{\n    // ...\npublic:\n    // ...\n    bool create_window(void);\n    // ...\nprotected:\n    // ...\n}\n```\n被剥离后的Window构造函数：\n```cpp\n// Window.cpp\n\n// ...\nafk::Window::Window(std::wstring const & app_name)\n{\n    _window = this;\n    // app_name ??? 见下文\n}\n```\ncreate_window实现，在注册窗口前调用pre_create，此时this指针、虚表已经构造完毕，虚函数行为得到纠正：\n```cpp\nbool afk::Window::create_window(void)\n{\n    WNDCLASSEX wcex = { 0 };\n    wcex.cbSize = sizeof(wcex);\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\n    wcex.lpfnWndProc = &window_procedure;\n    wcex.cbClsExtra = 0;\n    wcex.cbWndExtra = 0;\n    wcex.hInstance = _instance;\n    wcex.hIcon = LoadIcon(nullptr, IDI_SHIELD);\n    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    wcex.hbrBackground = (HBRUSH)(GetStockObject(LTGRAY_BRUSH));\n    wcex.lpszMenuName = NULL;\n    wcex.lpszClassName = _app_name.c_str();\n    wcex.hIconSm = wcex.hIcon;\n\n    // 用户自定义配置\n    pre_create(wcex);\n\n    // 注册\n    if (!::RegisterClassEx(&wcex))\n        return false;\n\n    // 创建窗口\n    _wnd = ::CreateWindowEx(\n        WS_EX_OVERLAPPEDWINDOW,\n        _app_name.c_str(), L\"App\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,\n        nullptr, nullptr, _instance, nullptr);\n    if (!_wnd)\n    {\n        int i = ::GetLastError();\n        return false;\n    }\n    return true;\n}\n\n// ...\n```\n此时发现，`create_window`函数中不认识`app_name`。这个变量我们目前只在构造函数中作为参数传入，没有设计为成员变量，需要增加。\n```cpp\n// Window.h\nclass Window\n{\npublic:\n    // ...\nprotected:\n    // ...\n    std::wstring     _app_name;\n}\n```\n最终的Window构造函数\n```cpp\n// Window.cpp\n// ...\nafk::Window::Window(std::wstring const & app_name)\n{\n    _window = this;\n    _app_name = app_name;\n}\n// ...\n```\n## 用户main\n用户自己编写的main如下：[wWinMain放到哪里？](#wWinMain放到哪里？)\n```cpp\n// MyApp.cpp\n#include \"MyApp.h\"\nint main()\n{\n    MyApp app{ L\"app\" };\n    app.create_window(); // add\n    app.show_window();\n    return app.run();\n}\n```\n## 处理重绘\n\n至此，可以实现左键按下、抬起画直线了，并且可以在创建窗口前让用户自定义配置。\n\n现在我们着眼于解决：改变窗口（如改变大小）后导致重绘窗口。\n\n因为没有处理重绘，所以已经画上的线条会消失。俗称：脏矩形，指窗口被污染或被其他窗口覆盖。\n\nWindows操作系统其实也是保留了一些东西的：鼠标箭头样式、菜单条区域。其他的图形不予保留，需要程序员自行处理。\n\n每当改变窗口时，相当于发送了`PAINT`消息，我们需要把操作集成在`on_paint`方法中，并使用数据结构对图形进行暂存。\n### LineManager：单例模式\nLineManager类设计：（除了和单例有关的）\n1. 成员：list容器，存放Line\n2. add_line：存储Line\n3. render：渲染Line\n4. clear_all：析构所有Line\n```cpp\n// LineManager.h\n#include <list>\n#include <Windows.h>\n\n// 不完全类型定义\nclass Line;\n\nclass LineManager\n{\npublic:\n    static LineManager* instance_ptr(void);\n    static LineManager& instance(void);\n    static void destroy_instance(void);\n\n    void add_line(Line* line);\n    void clear_all(void);\n    // 渲染\n    void render(HDC dc);\nprivate:\n    LineManager(void) = delete;\n    LineManager(LineManager const&) = delete;\n    LineManager(LineManager&&) noexcept = delete;\n    ~LineManager();\nprivate:\n    static LineManager*       _manager;\n    std::list<Line*>          _line_container;\n}\n```\n#### LineManager单例实现\n以下是懒汉式单例模式，即对象的指针一开始是空的，只有在第一次获取单例对象时，才开始构造单例对象。（线程不安全，因为new是分3个步骤的，可能导致`_manager`是否为空判断有误）\n```cpp\n// LineManager.cpp\n#include \"LineManager.cpp\"\n#include <algorithm>\n#include <ranges>\n#include \"Line.h\"\n\nconstinit LineManager* LineManager::_manager{ nullptr };\n\nLineManager::LineManager(void)\n{\n}\nLineManager::~LineManager()\n{\n    clear_all();\n}\n\n/* inline */ LineManager* LineManager::instance_ptr(void)\n{\n    if(!_manager)\n        _manager = new LineManager;\n    return _manager;\n}\n\nLineManager& LineManager::instance(void)\n{\n    if(!_manager)\n        _manager = new LineManager;\n    return *_manager;\n}\n\nvoid LineManager::destroy_instance(void)\n{\n    if(_manager)\n    {\n        delete _manager;\n        _manager = nullptr;\n    }\n}\n```\n问题：内联函数不能访问private成员。把`LineManager::instance_ptr`前的inline标记去掉即可编译成功。\n#### LineManager的add_line、clear_all实现\n```cpp\nvoid LineManager::add_line(Line* line)\n{\n    if(!line)\n        return;\n    _line_container.emplace_back(line);\n}\n\nvoid LineManager::clear_all(void)\n{\n    std::for_each(\n        _line_container.begin(),\n        _line_container.end(),\n        [](auto&& line) -> void\n        {\n            delete line;\n        });\n    _line_container.clear();\n}\n```\n#### LineManager的render实现\n需要HDC参数，即Device Context的句柄。\n然后传给每一个line，让他们在该DC上各自render。\n```cpp\nvoid LineManager::render(HDC dc)\n{\n    if(!dc)\n        return;\n    std::ranges::for_each(\n        _line_container,\n        [&dc](auto&& line) -> void /* dc是临时变量，需要在[]中捕获 */\n        {\n            line->render(dc);\n        });\n}\n```\n### Line\nLine类设计：\n1. 2个POINT成员，即两个点的坐标\n2. render渲染\n```cpp\n// Line.h\n#pragma once\n#include <Windows.h>\nclass Line\n{\npublic:\n    Line(POINT const& pt1, POINT const& pt2);\n    ~Line();\n    void render(HDC dc);\nprivate:\n    POINT         _pt1, _pt2;\n}\n```\nLine实现：\n```cpp\n// Line.cpp\n#include \"Line.h\"\nLine::Line(POINT const& pt1, POINT const& pt2) :\n    _pt1{ pt1 }, _pt2{ pt2 }\n{\n\n}\nLine::~Line()\n{\n\n}\n```\n#### Line的render实现\n需要HDC参数，即Device Context的句柄。\n是由LineManager传入的，调用MoveToEx，LineTo，在该DC上进行绘制直线。\n```Cpp\nvoid Line::render(HDC dc)\n{\n    ::MoveToEx(dc, _pt1.x, _pt1.y, nullptr);\n    ::LineTo(dc, _pt2.x, _pt2.y);\n}\n```\n### MyApp支持重绘的版本\n1. 在`on_paint`使用LineManager进行render。\n2. 每次抬起左键，就存一个Line对象。\n3. \n```cpp\n// MyApp.h\n\n#include \"Window.h\"\n#include \"LineManager.h\"\n#include \"Line.h\"\n\nclass MyApp\n{\npublic:\n    // ...\n    \n    bool on_paint(HDC dc, PAINTSTRUCT& ps)\n    {\n        LineManager::instance().render(dc);\n        return true;\n    }\n    \n    // ...\n\n    bool on_lbtnup(POINT& pt)\n    {\n        HDC dc = ::GetDC(_wnd);\n        LineManager::instance_ptr()->add_line(new Line{ _pt, pt });\n        ::ReleaseDC(_wnd, dc);\n        ::InvalidateRect(_wnd, nullptr, true);\n        return true;\n    }\nprivate:\n    // ...\n}\n```\n>[技术点：GetDC](#技术点：GetDC)\n#### 技术点：InvalidateRect\n[InvalidateRect函数 - InvalidateRect function](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-invalidaterect)\n函数的作用：在指定窗口的更新区域中添加一个矩形。更新区域代表窗口的工作区中必须重绘的部分。\n![](../../images/Windows_面向对象程序设计/image-20240731023701088.png)\n1. 参数1：已更改的窗口的句柄。如果此参数为**NULL**，则系统将使所有窗口无效并重新绘制，而不仅仅是此应用程序的窗口。\n2. 参数2：指向[RECT](https://learn.microsoft.com/en-us/windows/desktop/api/windef/ns-windef-rect)结构的指针，该结构包含要添加到更新区域的矩形的工作区坐标。如果此参数为**NULL**，则将整个客户区添加到更新区域。\n3. 参数3：指定在处理更新区域时是否要擦除更新区域内的背景。如果此参数为**TRUE**，则在调用[BeginPaint](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-beginpaint)函数时擦除背景。如果此参数为**FALSE**，则背景保持不变。\n\n这个是主动让窗口失效的函数，从而刺激系统发出`WM_PAINT`的消息，然后就调用`on_paint`，让窗口重绘。如果不加这一句的话，我们只是画完线后，窗口上不会出现东西，因为我们现在画线的逻辑只是往容器中储存了Line，真正画出来是on_paint导致LineManager调用render，从而每个Line最后render。\n# 精细化管理：智能指针\n## 容器内容对象的智能指针管理\n\n目前的程序只能做成图形的`clear_all`，但如果当我们有精确删除某个、某些图形的需求时，甚至有撤销删除的需求，就容易忘记、遗漏delete，因此需要智能指针来做管理。\n\n修改 LineManager 中的 list 成员的模板参数，以及add_line中参数由裸指针改为智能指针。\n>见旧实现：[LineManager的add_line、clear_all实现](#LineManager的add_line、clear_all实现)\n```cpp\n// LineManager.h\n\n#pragma once\n\n// ...\n\n#include <memory>\n\nclass LineManager\n{\npublic:\n    // ...\n\n    void add_line(std::shared_ptr<Line> line);\n\n    // ...\nprivate:\n    // ...\n    std::list<std::shared_ptr<Line>> _line_container;\n}\n```\n修改 LineManager 中的`add_line`的参数类型为智能指针，函数体内容不变。\n```cpp\n// LineManager.cpp\nvoid LineManager::add_line(std::shared_ptr<Line> line)\n{\n    if(!line)\n        return;\n    _line_container.emplace_back(line);\n}\n```\n修改 LineManager 中的`clear_all`的函数体，不用进行遍历delete了，一键 clear 即可以完成 Line 的自动析构。\n```cpp\n// LineManager.cpp\nvoid LineManager::clear_all(void)\n{\n    _line_container.clear();\n}\n```\n修改 MyApp 中的`on_lbtnup`，传入智能指针。\n```cpp\n// MyApp.h\n\n// ...\n\nclass MyApp\n{\npublic:\n    \n    // ...\n\n    bool on_lbtnup(POINT& pt)\n    {\n        // ...\n        LineManager::instance_ptr()->add_line(std::shared_ptr<Line>(new Line{ _pt, pt }));\n        // ...\n    }\nprivate:\n    // ...\n}\n```\n## 单例对象的智能指针管理：自定义deleter\n\n```cpp\n// LineManager.h\n// ...\nclass LineManager\n{\npublic:\n    static std::shared_ptr<LineManager> instance_ptr(void);\n    // ...\nprivate:\n    // ...\nprivate:\n    static std::shared_ptr<LineManager>  _manager;\n    std::list<std::shared_ptr<Line>>     _line_container;\n};\n```\n因为改用智能指针来管理此单例对象了，所以之前其涉及到单例对象的new、delete的函数都需要修改。\n```cpp\n// LineManager.cpp\nconstinit std::shared_ptr<LineManager> LineManager::_manager{ nullptr };\n\nstd::shared_ptr<LineManager> LineManager::instance_ptr(void)\n{\n    if(!_manager)\n        // error\n        _manager = std::shared_ptr<LineManager>(new LineManager /* 需要一个deleter */);\n    return _manager;\n}\nLineManager& LineManager::instance(void)\n{\n    if(!_manager)\n        // error\n        _manager = std::shared_ptr<LineManager>(new LineManager /* 需要一个deleter */);\n    return *_manager;\n}\nvoid LineManager::destroy_instance(void)\n{\n    if(_manager)\n    {\n        // 无需delete\n        _manager = nullptr;\n    }\n}\n```\n由于`shared_ptr`在销毁时，默认绑定的deleter需要访问`LineManager`的析构函数，而单例的析构函数是私有的，因此需要加一个自定义deleter。\n```cpp\n// LineManager.cpp\nstd::shared_ptr<LineManager> LineManager::instance_ptr(void)\n{\n    if(!_manager)\n        _manager = std::shared_ptr<LineManager>(new LineManager, [](LineManager* p) { delete p; });\n    return _manager;\n}\nLineManager& LineManager::instance(void)\n{\n    if(!_manager)\n        _manager = std::shared_ptr<LineManager>(new LineManager, [](LineManager* p) { delete p; });\n    return *_manager;\n}\n```\n### 更简洁的deleter\n单独定义一个类中private的deleter函数。\n>如果不写成静态的，传deleter时还需要binder此对象的this指针，失去了简洁性。\n```cpp\n// LineManager.h\n// ...\nclass LineManager\n{\npublic:\n    // ...\nprivate:\n    // ...\n    static void manager_deleter(LineManager* p);\nprivate:\n    // ...\n};\n```\n实现\n```cpp\n// LineManager.cpp\nvoid LineManager::manager_deleter(LineManager* p)\n{\n    if (p)\n    {\n        delete p;\n    }\n}\nstd::shared_ptr<LineManager> LineManager::instance_ptr(void)\n{\n    if(!_manager)\n        _manager = std::shared_ptr<LineManager>(new LineManager, &LineManager::manager_deleter);\n    return _manager;\n}\nLineManager& LineManager::instance(void)\n{\n    if(!_manager)\n        _manager = std::shared_ptr<LineManager>(new LineManager, &LineManager::manager_deleter);\n    return *_manager;\n}\n```\n### destroy_instance 和 deleter 的关系是什么？\n我们发现，单例类自己也有一个 destroy_instance ，这个是用户自己调用的。\n\ndeleter是智能指针管理的，在new的时候，就要同时绑定此deleter，当时deleter已经记录下来new返回的裸指针p了，在没有任何一个智能指针引用此对象的情况下，就会通过delete p来进行对象的析构。\n在智能指针接管之前，`delete _manager`的操作是我们用户自己在destroy_instance中进行的，而后还要置空`_manager = nullptr`。\n\n现在智能指针接管之后，是否可以把destroy_instance 方法删除呢？\n不可以。\n虽然我们无需自己`delete _manager`，但仍需要`_manager = nullptr`，因此 destroy_instance 还是有用的，即指针置空操作。","categories":["设计模式","Windows"]},{"title":"Windows_wchar和wmain","url":"/Windows/Windows_wchar和wmain/","content":"# 字符集\nCharacter Set\n\nchar - 1 Byte - 8 bit - ASCII\n\n参考：ASCII和ANSI [Ascii Codes - C++ Tutorials (cplusplus.com)](https://legacy.cplusplus.com/doc/ascii/)\n## ANSI码\n\nANSI码仅在前128（0-127）个与ASCII码相同，之后的字符全是某个国家语言的所有字符。值得注意的是，两个字节最多可以存储的字符数目是2的16次方，即65536个字符，这对于一个语言的字符来说，绝对够了。还有ANSI编码其实包括很多编码：中国制定了GB2312编码，用来把中文编进去另外，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准。受制于当时的条件，不同语言之间的ANSI码之间不能互相转换，这就会导致在多语言混合的文本中会有乱码。\n## Unicode编码\n\n为了解决不同国家ANSI编码的冲突问题，Unicode应运而生：如果全世界每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。\n\nUnicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。\n\n但是问题在于，原本可以用一个字节存储的英文字母在Unicode里面必须存两个字节（规则就是在原来英文字母对应ASCII码前面补0），这就产生了浪费。那么有没有一种既能消除乱码，又能避免浪费的编码方式呢？答案就是UTF-8！\n## UTF-8编码\n\n这是一种变长的编码方式：它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，如此一来UTF-8编码也可以是为视为一种对ASCII码的拓展。值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。\n\n在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。\n\n用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。\n# Unicode对应的字符类型 - wchar\n\nUnicode对应的字符类型为`wchar_t`。打印sizeof为2，即占大小为2字节、16位。\n```cpp\n#include<iostream>\nint main()\n{\n    std::cout << sizeof(wchar_t);\n    return 0;\n}\n```\n1. 初始化一个Unicode字符串。需要在\"双引号\"前加`L`，表示使用Unicode字符集串。\n2. 如果要正常打印Unicode字符串，需要使用`std::wcout`。\n3. Cpp中也有Unicode字符串对应的类，是`std::wstring`。\n```cpp\n#include<iostream>\nint main()\n{\n    // wchar_t str[] = \"Hello\";  // 错误，\"Hello\"默认为ANSI字符集串\n    wchar_t str[] = L\"Hello\";\n    std::cout  << sizeof str << std::endl; // 输出 12. Hello 5个 加 1个哨兵位，乘以2\n    std::wcout << str;                     // 输出 Hello\n    \n    // Cpp中的Unicode字符串\n    std::wstring test = str;\n    std::wcout << test;\n}\n```\n## C中的wchar库\n新标准写法为cwchar\n[cwchar (wchar.h) - C++ Reference (cplusplus.com)](https://legacy.cplusplus.com/reference/cwchar/)\n\nC语言标准库中也提供了对wchar的支持，输出用`wprintf`。区别为\"双引号\"前要加`L`。\n相应于普通的strcat、strcmp、strcpy、strlen等，都可用wcs开头的wcscat等代替。\n>Cpp中的宽字符输出流为：`std::wcout`\n```c\n#include<cwchar>\nint main()\n{\n    wchar_t str[] = L\"Hello\";\n    wprintf(L\"%s\\n\", str);      // 记得加L.  输出Hello\n}\n```\n# wmain\n\n```cpp\nint main(int ac, char * av[]) // main入口 + 普通的char * []\n{\n    for(int i = 0; i < ac; ++i)\n    {\n        std::cout << av[i] << std::endl; // cout\n    }\n}\n```\n\n```cpp\nint wmain(int ac, wchar_t * av[]) // wmain入口 + wchar_t * []\n{\n    for(int i = 0; i < ac; ++i)\n    {\n        std::wcout << av[i] << std::endl;// wcout\n    }\n}\n```\n# 第一个Windows程序\n\n不遵循ANSI、ISO标准，是Windows平台下程序的入口。\n使用Windows.h库，是Windows系统自带的SDK。\n\n```cpp\n#include <iostream>\n#include <Windows.h>\n\nint wWinMain(\n        HINSTANCE hInstance,\n        HINSTANCE hPrevInstance,\n        LPWSTR lpCmdLine,\n        int nShowCmd)\n{\n    return 0;\n}\n```\n\n>编译之前，要配置好VS项目的属性，右键项目选择Properties，左边栏选择Linker，然后选择System。右边详细条目\"SubSystem\"需下拉选择Windows。\n\n如果直接return 0，不会出现窗口，程序直接退出。\n如果想要出现窗口，则需要加语句：\n```cpp\n{\n    ::MessageBox(nullptr, L\"First App\", L\"cap\", MB_OK);\n}\n```\n>MessageBox API: \n>`int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)`\n>hWnd表示窗口句柄。\n>lpText表示显示文本。\n>lpCaption表示窗口标题。\n>uType表示显示的按钮是什么类型。我们在此例中使用`MB_OK`这个值。有关于此的参考文档，可以进入[learn.microsoft.com](https://learn.microsoft.com)，在输入框搜索\"messagebox\"。搜索结果查看`MessageBox function (winuser.h) - Win32 apps`\n>\n>LPCWSTR表示Long Pointer Const Wide String。\n>关于LP：Windows 3.2版本以前由于内存分段的原因，要区分长短指针。但是现在内存不分段了，是平坦模式，因此长短指针不区分了。\n>因此只需要关注CWSTR：比如`L\"Hello First Windows Program\"`\n\n运行效果：出现一个如下的窗口，程序会阻塞于此，当点击OK按钮时，程序才会继续执行。\n![](../../images/Windows_wchar和wmain/image-20240623234329264.png)\n# 窗口程序\n\n多个程序共享一个窗口。\n\n## 弱化流程——基于消息驱动\n\n解决抢资源的问题，以前是锁，是资源抢占形式，不太好。现在，让多个人共享同一种资源，最好的办法说白了就是排队。排队需要优先级，比如时间先后顺序。那就需要一个消息队列（消息循环）。\n这些消息可能是并行的，需要串行化后进入消息队列，从队列中不断取消息，把消息一个一个地投放到目标窗口。\n## Windows下的面向对象\n\nWindows编程，Windows SDK或Win32，是一个面向对象的程序设计方法。虽然1985年`C++`面向对象语言才出来，在这之前大多数是用C语言开发，但这不是说用不了面向对象的思想。\n\n假设整个应用程序抽象为一个对象，应用程序可能有多个窗口，每个窗口是一个窗口对象，此窗口对象的数据结构存在于操作系统的内部（因此也叫内核对象 (Kernel Object)），每个窗口对象有一个对应的Handle，即句柄，字面意义上是把手，形容可以用此把手提起一个箱子。\n\n与Linux思想不同，Linux是一切皆文件，而Windows是一切皆窗口，在其中，窗口也视为一种内核对象。\n\n权威教材描述：\n1. Programming Windows - Charles Petzold\n2. Windows核心编程（Windows via `C/C++`）\n## wWinMain解析\n\n1. HINSTANCE：应用程序的句柄类型，H代表句柄。\n2. nShowCmd：预设的值以及含义见[ShowWindow function (winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow)中的Parameters。可以用于控制窗口的显示、隐藏等。\n\n应用程序创建窗口首先需要一个对象。\n\nWNDCLASSEX是一个结构体，用于定义窗口类。因为当时没有面向对象语言，需要把该类注册给操作系统，让操作系统在内部生成内核对象。\n[About Window Classes - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winmsg/about-window-classes)\n\n[WNDCLASSEXA (winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassexa)\n\n1. 第一步先初始化窗口类对象的成员值。\n    1. lpfnWndProc：是WNDPROC类型，需要指定一个函数指针。[WNDPROC - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nc-winuser-wndproc)。\n2. 注册该窗口类对象。之后操作系统就知道了该窗口类的存在。\n    1. [RegisterClassExW function (winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassexw)\n    2. 如果注册成功，返回一个非零的类原子值，唯一标识该类。If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the [CreateWindow](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-createwindowa), [CreateWindowEx](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-createwindowexa), [GetClassInfo](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getclassinfoa), [GetClassInfoEx](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getclassinfoexa), [FindWindow](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-findwindowa), [FindWindowEx](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-findwindowexa), and [UnregisterClass](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-unregisterclassa) functions and the `IActiveIMMap::FilterClientWindows` method.\n    3. If the function fails, the return value is zero. To get extended error information, call [GetLastError](https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).\n3. 操作系统以名字——`lpszClassName`访问，如果没有定义该变量，就不认识了。\n4. 用注册成功的类来创建窗口，调用CreateWindowEx，返回窗口句柄。\n    1. CreateWindowEx的参数来定义创建的窗口的属性。\n        1. [CreateWindowExW function (winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw)\n        2. 第一个参数dwExStyle：[Extended Window Styles (Winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles)。表示样式。我们暂用`WS_EX_OVERLAPPEDWINDOW`。\n        3. 第二个参数lpClassName：窗口类名。指定用哪个窗口类来创建窗口的实例，用窗口类注册的名字索引。\n        4. 第三个参数lpWindowName：窗口的标题。\n        5. 第四个参数dwStyle：和第一个参数dwExStyle相比是基础的，Ex表示拓展。我们暂用`WS_OVERLAPPEDWINDOW`。具体值为：`WS_OVERLAPPED | WS_CAPTION（标题栏） | WS_SYSMENU（菜单） | WS_THICKFRAME | WS_MINIMIZEBOX（最小化按钮） | WS_MAXIMIZEBOX（最大化按钮）`。\n        6. 第5、6个参数X、Y：表示窗口的起始坐标。\n        7. 第7、8个参数nWidth、nHeight：分别表示宽度、高度。\n        8. 第9个参数hWndParent：表示父窗口句柄，若无则填NULL或nullptr。\n        9. 第10个参数hMenu：Menu栏句柄，若无则填NULL或nullptr。\n        10. 第11个参数hInstance：整个应用程序的句柄。\n        11. 第12个参数lpParam：特殊、额外的参数。若无则填NULL或nullptr。\n5. 显示窗口、更新窗口。创建完窗口后，就交由Windows系统管理了。\n6. 开始消息循环。调用GetMessage从当前的应用程序队列中获得消息，队列是操作系统内部提供的。[GetMessage function (winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage)\n    1. 第一个参数lpMsg，放入一个MSG类型的指针，用于获取消息后填充给它。MSG是个结构体。\n        1. MSG结构体成员：hwnd、message、wParam、lParam、time、pt\n    2. 第二个参数hWnd，指定应用程序的某个窗口。如果填nullptr表示指定所有窗口。\n    3. 第三、四参数wMsgFilterMin、wMsgFilterMax，指定关注消息的号段。如果全填0，表示关注所有消息。\n    4. 返回BOOL。正常则返回非零，继续循环；如果收到的消息是`WM_QUIT（0x0012）`，则返回0退出循环。\n7. 循环退出则程序结束。\n```cpp\nint wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)\n{\n    std::wstring app_name{ L\"First App\" };\n\n    WNDCLASSEX wcex = { 0 };\n    wcex.cbSize = sizeof(wcex);\n    wcex.style = CS_HREDRAW | CS_VREDRAW;\n    // 绑定CALLBACK，见后面解释\n    wcex.lpfnWndProc = &window_procedure;\n    // wcex.... = ...;\n    wcex.lpszClassName = app_name.c_str();\n    // wcex.... = ...;\n    \n\n    if (!::RegisterClassEx(&wcex))\n    {\n        return -1;\n    }\n    // 定义一个窗口对象的句柄\n    // HWND: 窗口类型的句柄，也叫内核对象\n    HWND hWnd = ::CreateWindowEx(\n        WS_EX_OVERLAPPEDWINDOW,\n        app_name.c_str(),\n        L\"App\",\n        WS_OVERLAPPEDWINDOW,\n        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,\n        nullptr,\n        nullptr,\n        hInstance,\n        nullptr);\n    if (!hWnd)\n    {\n        int i = ::GetLastError();\n        return -1;\n    }\n    // 显示窗口，nShowCmd可以指定窗口以最小/最大/正常状态显示\n    ShowWindow(hWnd, nShowCmd);\n    // 更新窗口，绘制窗口。刚显示出来可能是无效的，需要在显示后绘制。\n    UpdateWindow(hWnd);\n\n    MSG msg;\n    while (::GetMessage(&msg, nullptr, 0, 0))\n    {\n        // 翻译消息，比如输入法通过‘wo’生成‘我’\n        ::TranslateMessage(&msg);\n        // 发送消息，调用刚才注册的callback窗口处理函数\n        ::DispatchMessage(&msg);\n    }\n\n    return 0;\n}\n```\n其中，CALLBACK函数如下：message是消息类型，为unsigned \n```cpp\n// 按照WNDPROC的原型定义，返回默认的DefWindowProc\nLRESULT CALLBACK window_procedure(HWND wnd, UINT message, WPARAM wparam, LPARAM lparam)\n{\n    return ::DefWindowProc(wnd, message, wparam, lparam);\n}\n```\n以上这个是什么也不处理，直接返回一个默认的操作。\n以下使用switch进行处理：\n```cpp\nLRESULT CALLBACK window_procedure(HWND wnd, UINT message, WPARAM wparam, LPARAM lparam)\n{\n    PAINTSTRUCT ps;\n    switch (message)\n    {\n    case WM_CREATE:           // 相当于constructor，往往先于消息循环。\n        break;\n    case WM_PAINT:\n        // Handle of Device Context\n        // case语句中不能直接声明、定义变量，因为case中的语句会影响程序编译的行为，而程序不确定会运行到定义变量语句，case是没有对应的栈的，没有了确定性，因此需要在此段语句外加大括号，形成局部的栈，就可以存放临时变量了。相当于把这几条语句用函数包装了。\n    {    \n        HDC hdc = ::BeginPaint(wnd, &ps);\n        ::Rectangle(hdc, 100, 100, 200, 200);  // 四个数字是坐标参数\n        ::EndPaint(wnd, &ps);\n    }\n        break;\n    case WM_CLOSE:\n        ::DestroyWindow(wnd);\n        return 0;  // 返回的LRESULT，表示WM_CLOSE消息已处理\n        break;\n    case WM_DESTORY:          // 相当于destructor\n        ::PostQuitMessage(0); // 执行后会向消息队列投入WM_QUIT消息，下次GetMessage得到WM_QUIT将返回0，while循环退出。\n        break;\n    default:\n        break;\n    }\n    return ::DefWindowProc(wnd, message, wparam, lparam);\n}\n```\n### BeginPaint\nBeginPaint 函数准备指定的窗口进行绘画，并使用有关绘画的信息填充[PAINTSTRUCT](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-paintstruct)结构。\n![](../../images/Windows_wchar和wmain/image-20240731013725180.png)\n参数：\n1. hWnd，`HWND`类，要重绘的窗口的句柄。\n2. lpPaint，`LPPAINTSTRUCT`类，指向将接收绘画信息的`PAINTSTRUCT`结构的Long指针。\n\n返回值：\n1. 如果成功，返回值是指定窗口的DC的句柄。\n2. 如果失败，返回NULL，表示没有可用的显示设备上下文（Display Device Context）。\n# 总结\n\n以上虽然是对Windows系统中的窗口程序进行了解析，但是其实其他的操作系统中的窗口UI程序也是同样的流程和道理。\n\n总之，不同的应用程序抢相同的资源时，程序范式有两种：\n1. 红绿灯，等别人做完再做。锁机制，在多任务系统，尤其是带UI的系统会有卡顿感。\n2. 基于消息循环，从消息发送到消息处理也就是100ms之内，本质上也是一种同步，但粒度更小，就可以等效于一段时间内大家都在同时做。\n# 再记几个消息类型\n\n```cpp\n{\n    // ...\n    case WM_LBUTTONDOWN:\n    {\n        int x_coord = lparam & 0xffff;\n        int y_coord = lparam >> 16;\n        wchar_t text[50] = L\"\";\n        // 打印到text字符数组中\n        swprintf(text, 50, L\"%i, %i\", x_coord, y_coord);\n        ::MessageBox(nullptr, text, L\"BtnTest\", MB_OK);\n    }\n        break;\n    // ...\n}\n```\n\n1. WM_LBUTTONDOWN：鼠标左键按钮按下动作。[WM_LBUTTONDOWN message (Winuser.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-lbuttondown)\n    1. 消息里的属性有：wparam，lparam。w代表字，l代表long，现代已经全部升级为32位的long了。lparam中，低16位是X坐标，高16位是Y坐标。如果要从32位数中取出16位，需要做与掩码的按位与运算。比如取X：`int x_coord = lparam & 0xffff;`，取Y：`int y_coord = lparam >> 16;`\n\n# 自定义消息类型\n\nWindows中默认的message都是有相应预定义好的值的。比如在`WinUser.h`中：\n```cpp\n#define WM_MOUSEMOVE      0x0200\n#define WM_LBUTTONDOWN    0x0201\n#define WM_LBUTTONUP      0x0202\n```\n\n我们也可以根据需要自定义一个消息类型，在`WinUser.h`中，又一个给出的`WM_USER`值，它的注释说明了，小于`0x0400`的值已被系统占用，自定义类型值需要从`0x0400`开始：\n```cpp\n/* \n * NOTE: All Message Numbers below 0x0400 are RESERVED.\n * Private Window Messages Start Here:\n */\n#define WM_USER          0x0400 \n```\n所以，比较简便的自定义消息类型的预定义语句可以这么写：\n```cpp\n#define MYMSG            WM_USER + 10\n```\n\n使用：通过左击鼠标，用PostMessage来发送MYMSG到wnd的消息队列。下次取出MYMSG消息后做相应的动作。\n```cpp\n{\n    // ...\n    case WM_LBUTTONDOWN:\n        ::PostMessage(wnd, MYMSG, wparam, lparam);\n        break;\n    case MYMSG:\n        ::MessageBox(nullptr, L\"My Message\", L\"MyMsg\", MB_OK);\n        break;\n    // ...\n}\n```\n也可以用SendMessage，区别是不经过消息队列，直接发送消息。效果是在SendMessage后，立即调用回调函数，处理完毕后，再回到原先的SendMessage下一条位置继续。\n```cpp\n{\n    // ...\n    case WM_LBUTTONDOWN:\n        ::SendMessage(wnd, MYMSG, wparam, lparam);\n        break;\n    case MYMSG:\n        ::MessageBox(nullptr, L\"My Message\", L\"MyMsg\", MB_OK);\n        break;\n    // ...\n}\n```\n\n# 带参数\n\n利用SendMessage、PostMessage中可以带wparam、lparam，回调函数可以使用这些参数。\n\n发送消息时携带参数：\n```cpp\nstruct MyParam\n{\n    int x_coord;\n    int y_coord;\n}\n// ...\n{\n    // ...\n    case WM_LBUTTONDOWN:\n    {\n        int x_coord = lparam & 0xffff;\n        int y_coord = lparam >> 16;\n        MyParam* param = new MyParam{ x_coord, y_coord };\n        ::SendMessage(wnd, MYMSG, reinterpret_cast<WPARAM>(param), lparam);\n    }\n        break;\n    // ...\n}\n```\n\n处理消息时解析参数：\n```cpp\n{\n    // ...\n    case MYMSG:\n    {\n        MyParam* param = reinterpret_cast<MyParam*>(wparam);\n        std::wstring text = std::format(L\"{0}, {1}\", x_coord, y_coord);\n        ::MessageBox(nullptr, text.c_str(), L\"Param Test\", MB_OK);\n        delete param;\n    }\n        break;\n    // ...\n}\n```\n\n# 总结\n\nWindows SDK的开发，聚焦的点主要就在于window_procedure里的代码逻辑和消息的处理。","categories":["操作系统","Windows"]},{"title":"Cpp_文件库","url":"/Cpp/Cpp_文件库/","content":"`C++17`之后，有新引入的文件库。屏蔽了操作系统的差异性，有统一的标准。\n`<filesystem>`\n示例：读取当前目录下（包括所有子目录）的Cpp、C相关的文件名，并统计其行数。\n\n遍历搜索：\n```cpp\n#include <filesystem>\nstd::vector<std::string>\nfile_directories()\n{\n    std::vector<std::filesystem::directory_entry> entries;\n    std::copy_if(std::filesystem::recursive_directory_iterator(\"./\"),\n    std::filesystem::recursive_directory_iterator(),\n    std::back_inserter(entries),\n    [](std::filesystem::directory_entry const& p) -> boll\n    {\n        if (p.is_regular_file())\n            if (p.path().extension().c_str() == L\".cpp\" ||\n                p.path().extension().c_str() == L\".h\" ||\n                p.path().extension().c_str() == L\".c\")\n                return true;\n        return false;\n    });\n    std::vector<std::string> file_names(entries.size());\n    // entry -> string name\n    std::transform(\n        entries.cbegin(),\n        entries.cend(),\n        file_names.begin(),\n        [](std::filesystem::directory_entry const& p) -> std::string\n        {\n            return p.path().generic_string();\n        });\n    return file_names;\n}\n```\n在VS环境下，默认的当前文件目录是`ProjectName.vcxproj`所在的位置。\n\n统计行数：通过`<fstream>`中的`std::ifstream`构造函数填入文件名打开文件，已经处理好了RAII，无需考虑关闭。\n```cpp\nstd::vector<int>\ncount_lines_in_files(std::vector<string::string> & file_names)\n{\n    std::vector<int> line_counts;\n    char ch = 0;\n    int line_count{ 0 };\n\n    for (auto const & file_name : file_names)\n    {\n        std::ifstream in{ file_name };\n        line_count = 0;\n        while (in.get(ch))\n        {\n            if (ch == '\\n')\n            {\n                if (ch == '\\n')\n                    ++line_count;\n            }\n        }\n        line_counts.emplace_back(line_count);\n        // in.close();  // RAII\n    }\n    return line_counts;\n}\n```\n测试\n```cpp\nint main()\n{\n    auto file_names = file_directories();\n    auto file_counts = count_lines_in_files(file_names);\n    std::for_each(\n        file_names.cbegin(),\n        file_names.cend(),\n        [](auto&& file_name) -> void\n        {\n            std::cout << file_name << std::endl;\n        });\n    std::for_each(\n        file_counts.cbegin(),\n        file_counts.cend(),\n        [](auto&& file_count) -> void\n        {\n            std::cout << file_count << std::endl;\n        });\n    std::cout << \"Files Count: \" << file_names.size() << std::endl;\n}\n```\n# 结合算法库\n结合算法库，可以大大简化我们自己写的代码。尤其是繁杂的for循环。\n\n`istream`虽然不是容器，但也有相应的迭代器，在`<iterator>`中有`Predefined iterators`其中的`istream_iterator`。\n如果读写比较频繁，有效率更高的`istreambuf_iterator`。\n```cpp\nint count_lines(std::string const& file_name)\n{\n    std::ifstream in{ file_name };\n    return std::count(\n        std::istreambuf_iterator<char>(in),\n        std::istreambuf_iterator<char>(),/* 不写默认是end */\n        '\\n');\n}\n```\n之前的函数可以简化为：\n```cpp\nstd::vector<int>\ncount_lines_in_files(std::vector<string::string> & file_names)\n{\n    std::vector<int> line_counts;\n    for (auto const& file_name : file_names)\n    {\n        line_counts.emplace_back(count_lines(file_name));\n    }\n    return line_counts;\n}\n```\n还能再次改进：\n```cpp\nstd::vector<int>\ncount_lines_in_files(std::vector<string::string> & file_names)\n{\n    std::vector<int> line_counts(file_names.size());\n\n    std::transform(\n        std::execution::par,\n        file_names.cbegin(),\n        file_names.cend(),\n        line_counts.begin(),\n        count_lines);\n    return line_counts;\n}\n```\n也可以结合ranges：一行代码解决！\n>`C++23`中可以通过`std::ranges::to<Container>`来输出到就地生成的容器中\n\n```cpp\nstd::vector<int>\ncount_lines_in_files(std::vector<string::string> & file_names)\n{\n    return file_names | std::views::transform(count_lines) |\n        std::ranges::to<std::vector>();\n}\n```","categories":["Cpp","Modern"]},{"title":"Cpp_仿函数_lambda表达式","url":"/Cpp/Cpp_仿函数_lambda表达式/","content":"# 仿函数\nFunctor\n\n仿函数是类。\n相比于普通函数，仿函数作为类对象，有更多功能可以集成。\n\n```cpp\nclass IsOdd\n{\npublic:\n    bool operator () (int const& v)\n    {\n        return v % 2 != 0;\n    }\n};\n```\n使用如下：需要先实例化出一个对象。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    \n    IsOdd is_odd_functor;\n\n    auto it != std::find_if(vec.begin(), vec.end(), is_odd_functor);\n}\n```\n## 剖析find_if\n1. first和last是迭代器，需要先解引用才能使用pred去判断值。\n2. first到last左闭右开，first等于last时结束。\n3. 内部封装了pred的实际调用形式`pred(...)`。所以不管是函数、仿函数，只要支持`(...)`的调用形式就能使用。\n```cpp\ntemplate <class InputIterator, class UnaryPredicate>\nInputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred)\n{\n    while (first != last)\n    {\n        if (pred(*first))\n            return first;\n        else\n            ++first;\n    }\n    return last;\n}\n```\n# lambda表达式\n\n也叫lambda-calculus（演算）、lexical closure（词法闭包，闭包指穷举所有的状态）\n\n>在`C++`中，本质上是生成了一个类，拥有一个static方法。\n\n为什么叫做词法闭包呢？\n\n假设，fn在内部定义了fn2、fn4，fn2内部定义了fn3。外界调用fn时是看不到它的内部的。但fn的结果依赖于fn2、fn4，fn2依赖于fn3。\n总之，定义在内部，外界看不到，类似于黑盒，而且各部分的依赖关系不能断，需要穷尽路线，所以叫闭包。\n1. 功能不在全局定义，而是在内部定义。空间不易混乱\n2. fn可以直接使用fn2作为部分功能\n![](../../images/Cpp_20240515_仿函数/image-20240719052258968.png)\n有了lambda表达式，就可以形式上在函数中嵌套定义函数了。\n但有个问题，fn中定义的变量，fn2可以访问吗？\n```cpp\n#include <iostrean>\nvoid bar(void)\n{\n    \n}\nint main()\n{\n    return 0;\n}\n```\n## 写法形式\n```cpp\n[Capture List](Parameters) -> ReturnType {};\n    ^              ^       ^       ^      ^\n 捕获列表          参数   goes to  返回类型  函数体\n```\n类似于函数，可以互相传递，还可以在中间捕获。\n```cpp\n#include <iostrean>\nint bar(void)\n{\n    int a = 10;\n    // 以下生成了函数对象，可以就地调用：\n    int b = [a]() -> void \n        {\n            return a + 20;\n        }()/* 熟悉的函数调用标志：圆括号 */;\n    int c = [a](int v) -> void \n        {\n            return a + v + 20;\n        }(5);\n    return b;\n}\nint main(void)\n{\n    int r = bar();\n    return 0;\n}\n```\n## 按值捕获\n```cpp\nint bar()\n{\n    int a = 10, b = 11;\n    int c = [a, b](int v) -> int\n        {\n            return a + b + v + 20;\n        }(5);\n    // 也可以在中括号只填一个\"=\"，代表按值捕获全部\n    int d = [=](int v) -> int\n        {\n            return a + b + v + 20;\n        }(5);\n    return c;\n}\n```\n按值捕获时，内部lambda函数对捕获的变量修改时，外部值不变，相当于成为了自己的局部变量。\n这个捕获的局部变量在内部也是默认不能改值的，但可以加mutable。明确告诉编译器自己要修改，并不是误会。但加了mutable依然不会影响外部。\n```cpp\nint bar()\n{\n    int a = 10, b = 11;\n    int c = [=](int v) -> int\n        {\n            return a + b++ + v + 20; // error, b can't be modified.\n        }(5);\n    int d = [=](int v) mutable -> int\n        {\n            return a + b++ + v + 20; // ok. , b = 12\n        }(5);\n    return b;  // b = 11\n}\n```\n## 按引用捕获\n\n```cpp\nint bar()\n{\n    int a = 10, b = 11;\n    // 如果想要按引用捕获全部变量，可以在[]中只写一个\"&\"\n    int c = [=, &b](int v) -> int\n        {\n            return a + b++ + v + 20;\n        }(5);\n    return b;  // b = 12\n}\n```\n1. 如果想要按引用捕获全部变量，可以在`[]`中只写一个\"&\"\n2. 也可以在中括号只填一个\"=\"，代表按值捕获全部\n3. 但是不能`[=, &]`既全部按值又全部按引用。同时存在时必须有一个是部分变量如`[=, &b]`\n4. 引用可以把外部值联动改变。\n## 函数对象\n1. 可以用函数对象来存储定义的lambda函数。\n2. 不能用函数指针直接引用。\n```cpp\nint bar()\n{\n    int a = 10, b = 11;\n    \n    auto lambda = [=, &b](int v) -> int\n        {\n            return a + b++ + v + 20;\n        };\n    return lambda(5);\n}\n```\n以上是使用auto来自动推断、接收。\n也可以使用`std::function`准确定义相应的函数对象类型来接收lambda函数。（也可以接收普通函数，只要返回值类型、参数类型符合即可）\n```cpp\n#include <functional>\nint bar()\n{\n    int a = 10, b = 11;\n    \n    std::function<int(int)> lambda = [=, &b](int v) -> int\n        {\n            return a + b++ + v + 20;\n        };\n    return lambda(5);\n}\n```\n## lambda函数对象的生存周期\n```cpp\nstd::function<int(int)> bar()\n{\n    int a = 10, b = 11;\n    std::function<int(int)> lambda = [=, &b](int v) -> int\n        {\n            return a + b++ + v + 20;\n        }\n}\nint main()\n{\n    auto lam = bar();\n    int r = lam(5);\n    r = lam(5);\n}\n```\n以上main函数调用了两次`bar()`函数内部生成的lambda函数，其中lambda函数自己内部的b是按引用捕获的。\n如果是普通函数的栈帧，则bar函数按理来说在第一行代码结束后就会塌陷，导致引用的b空间被污染。\n在之前的`C++11`版本确实会存在这类问题，因为`C++`是静态编译期计算的，而Java、C#、Python是有垃圾回收机制的，有一个引用计数，如果仍有人引用b，则不会对其析构，因此往往让这些局部变量在堆上创建。但`C++`早期是建立在栈上，因此会发生问题。\n后续版本`C++17`之后克服了此问题，每个厂商具体细节不同，微软公司也是把局部变量建立在堆上了，并用智能指针管理，即使bar函数栈帧塌陷了，也会帮你把类似a、b的局部变量存储到其他地方。\n## lambda函数与面向对象结合（捕获this）\n比如让lambda函数调用某个对象的成员方法、成员变量，可以在lambda表达式中的捕获列表里写this指针。\n# 面向函数编程\n比较关心逻辑，不太关心细节。细节用高阶函数来完成。\n就像是：如果不使用`copy_if`来做filter，那么就需要另写繁琐的for循环。\n\n","categories":["Cpp"]},{"title":"Cpp_STL_算法_ranges","url":"/Cpp/Cpp_STL_算法_ranges/","content":"# 模板库是什么\n由三部分组成。\n1. 容器Container：装数据的\n2. 迭代器Iterator：不同容器的结构、算法行为不一样，用迭代器来屏蔽差异。Iterator有好多种，但是有通用的接口，在容器和算法中间，通过迭代器与另一者相互通信。\n3. 算法Algorithm：插入、修改、删除等\n\n>有的说法是六大组件组成：容器、迭代器、算法、仿函数、适配器、分配器\n\n![](../../images/Cpp_20240512_STL/image-20240717000140107.png)\n\n# 以vector为例\n```cpp\ntemplate<class T, class Alloc = allocator<T> >\nclass vector;\n```\n第一个模板参数是容器中元素的类型。\n第二个模板参数是空间配置器。\n## 初始化、遍历\n遍历示例：\n```cpp\nint main()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    std::vector<int>::iterator it = vec.begin();\n    for (; it != vec.end(); ++it)\n    {\n        std::cout << *it << std::endl;\n    }\n    // 以下是ranged for的遍历写法\n    // 取出的是值，不是迭代器。效率较低\n    for (auto v : vec)\n    {\n        std::cout << v << std::endl;\n    }\n    // 取出的是引用，效率高。实际v的类型是int &\n    for (auto&& v : vec)\n    {\n        std::cout << v << std::endl;\n    }\n}\n```\n## size和capacity\n1. size是当前容器内有效元素数\n2. capacity是当前容器的容量\n3. capacity大于等于size\n4. 当满容时，vector会扩容到原来的1.5倍。之前的数据拷贝到新区后销毁。\n## `push_back`和`emplace_back`\n1. `push_back`的语义是把构造好的对象，或用封装的数据临时构造一个对象，再插入到容器的尾部。发生了拷贝构造、右值引用拷贝构造。\n2. `emplace_back`是把数据一个一个直接填充到容器尾部的空间上。\n    1. 用到了完美转发\n\n```cpp\nclass Test\n{\npublic:\n    Test(int a, int b)\n    {\n        std::cout << \"Test(a, b)\" << std::endl;\n    }\n};\nint main()\n{\n    std::vector<Test> vec{ {10, 20}, {30, 40}, {50, 60}, {70, 80} };\n    vec.push_back({ 90, 100 });\n    Test test{ 110, 120 };\n    vec.push_back(test);\n    vec.emplace_back(130, 140);\n    std::cout << vec.size() << std::endl;\n    std::cout << vec.capacity() << std::endl;\n}\n```\n\n# 迭代器的分类\n\n1. 所有都：\n    1. 支持析构、拷贝构造、拷贝赋值。\n    2. Can be incremented `++a or a++`\n2. Input/Output：迭代器的输入、输出是相对于算法来说的。\n    1. Input：程序通过迭代器向算法传参，可以理解为只读\n        1. 支持相等比较\n        2. 支持解引用为右值\n    2. Output：算法通过迭代器向外输出\n        1. 支持解引用为左值\n3. Forward\n    1. 支持默认的构造\n4. Bidirectional\n    1. Can be decremented `--a or a--`\n5. Random Access\n    1. 支持随意加减 `a + n, n + a, a - n, a - b`\n    2. 支持和另一迭代器之间的不等比较 `a < b, a > b`\n    3. 支持复合赋值运算 `a += n, a -= n`\n    4. 支持偏移量（offset）解引用 `a[n]`\n\n![](../../images/Cpp_20240512_STL/image-20240717010603321.png)\n\n## 通过concepts约束迭代器类型\n\n在没有concept之前，编程时乱用不匹配的迭代器编译时是不知道对错的，运行的时候才报错。\n而Modern `C++`之后随着模板和concept的发展，可以约束迭代器的行为。比如规定此迭代器类必须支持`++`、`--`操作，从而此迭代器是Bidirectional。\n有了concepts，在编译期就能知道程序的对错了。\n\n具体见《Cpp_concept》\n## back_inserter\n```cpp\ntemplate <class Container>\nback_insert_iterator<Container> back_inserter (Container& x);\n```\n构建后插入迭代器\n构建一个尾插入迭代器，该迭代器在X的末尾插入新元素。\n尾插迭代器是一种特殊的输出迭代器，旨在允许频繁覆盖元素的算法（例如copy）在容器末端自动插入新元素。\nX的类型需要具有`push_back`成员函数（例如vector、Deque和List）。\n在返回的迭代器上使用赋值运算符（是否解引用），使容器通过一个元素扩展，该元素被初始化为分配的值。\n效果就是不用操心给容器扩容了，来一个建一个。\n返回的迭代器支持输出迭代器的所有其他典型操作，但失效了：分配的所有值均在容器的末尾插入。\n\n体现了适配器模式。\n\n与之相类似的，还有`front_inserter`，头插迭代器。\n\n示例见`ranges`中`copy_if`的用法\n# 删除时迭代器的处理\n1. erase后，此it失效。`++`操作也会失效\n2. erase返回下一个有效的it，所以，删除后用此返回值赋给it。\n3. 其他情况正常`++`\n4. 如果只需要删1个，就在erase后`break`，否则后面条件匹配的全部会删除\n\n```cpp\n#include<iostream>\n#include<vector>\nint main()\n{\n    std::vector<int> vec{ 10, 20, 30, 40, 50, 60, 70, 80 };\n    for (auto it = vec.begin(); it != vec.end(); /* 不++ */)\n    {\n        if (*it == 40)\n        {\n            // erase后，此it失效。++也会失效\n            // erase返回下一个有效的it\n            it = vec.erase(it);\n            // break;  // 如果只需要删1个，就break，否则全部40删除\n        }\n        else\n        {\n            ++it;\n        }\n    }\n    for (auto&& v : vec)\n    {\n        std::cout << v << std::endl;\n    }\n}\n```\n# 算法\n`<algorithm>`\n## find\n```\nconstexpr _InIt find<_InIt, _Ty>(_InIt _First, const _InIt _Last, const _Ty &_Val);\n```\n1. InIt表示Input Iterator，指被输入，是用于接收的迭代器，或者理解为只读不修改。\n2. First表示搜索范围的上限，Last表示搜索范围的下限。\n3. 区间是左闭右开。`[First, Last)`\n4. Val是要查找的值\n5. 返回指向Val值其位置的迭代器。如果没找到，则返回`xxx.end()`\n```cpp\n#include <algorithm>\nint main()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    auto it = std::find(vec.begin(), vec.end(), 6);\n    if (it != vec.end())\n        std::cout << *it << std::endl;\n}\n```\n## find_if、谓词、仿函数\nfind是默认寻找相等的val。而find_if可以自定义条件。\n```cpp\ntemplate <class InputIterator, class UnaryPredicate>\nInputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);\n```\n模板参数1是只读迭代器。\n模板参数2是一元谓词。\n\n遍历输出容器中所有的奇数：\n1. 定义谓词为返回bool的函数\n2. 先找一次，返回it\n3. 若不为end，打印后，继续循环找、打印\n4. 直到it返回end。\n\n```cpp\n// 判断是否为奇数\nbool is_odd(int const& v)\n{\n    return v % 2 != 0;\n}\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    auto it = std::find_if(vec.begin(), vec.end(), is_odd);\n    while (it != vec.end())\n    {\n        std::cout << *it << std::endl;\n        it = std::find_if(it + 1, vec.end(), is_odd);\n    }\n    return 0;\n}\n```\n也可以拿仿函数作为谓词。\n```cpp\nclass IsOdd\n{\npublic:\n    bool operator () (int const& v)\n    {\n        return v % 2 != 0;\n    }\n};\n```\n使用如下：需要先实例化出一个对象。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    \n    IsOdd is_odd_functor;\n\n    auto it = std::find_if(vec.begin(), vec.end(), is_odd_functor);\n    // ...\n}\n```\n也可以使用lambda表达式\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    \n    auto it = std::find_if(\n        vec.begin(),\n        vec.end(),\n        [](int const& v) -> bool\n        {\n            return v % 2 != 0;\n        });\n    // ...\n}\n```\n### 剖析\n1. first和last是迭代器，需要先解引用才能使用pred去判断值。\n2. first到last左闭右开，first等于last时结束。\n3. 内部封装了pred的实际调用形式`pred(...)`。所以不管是函数、仿函数，只要支持`(...)`的调用形式就能使用。\n\n```cpp\ntemplate <class InputIterator, class UnaryPredicate>\nInputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred)\n{\n    while (first != last)\n    {\n        if (pred(*first))\n            return first;\n        else\n            ++first;\n    }\n    return last;\n}\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    \n    IsOdd is_odd_functor;\n    // 不是std的find_if 是我们自己写的\n    auto it = ::find_if(vec.begin(), vec.end(), is_odd_functor);\n\n    while (it != vec.end())\n    {\n        std::cout << *it << std::endl;\n        it = ::find_if(it + 1, vec.end(), is_odd_functor);\n    }\n}\n```\n## `remove_if`\n```cpp\ntemplate <class ForwardIterator, class UnaryPredicate>\nForwardIterator remove_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);\n```\n需要Iterator可以Forward单向移动。\n```cpp\ntemplate <class ForwardIterator, class UnaryPredicate>\nForwardIterator remove_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred)\n{\n    ForwardIterator result = first;\n    while (first != last) {\n        if (!pred(*first)) {\n            if (result != first)\n                *result = std::move(*first);\n            ++result;\n        }\n        ++first;\n    }\n    return result;\n}\n```\n从实现可以看出：\n1. 遍历时遇到要删的，first先往后面继续遍历，result不动；\n2. 遇到不匹配条件的（不删的），first的值就往前面与result的值交换，result后移。\n3. 最后，result的位置以及之后就是要删的所有数据。\n\n这样是为了防止批量删除时，数据频繁的前移。如此，可以只进行交换，后面一并删除。\n因此，`remove_if`不会帮我们删除数据，而是帮我们整理好容器内数据的排布后，再返回一个it迭代器，指示要删除的开始位置。\n```\n调用前：\n{ 0, 1, 2, 3, 4, 5, 6, 7, 8 }\n调用后：\n{ 0, 2, 4, 6, 8, 1, 3, 5, 7 }\n                 ^\n                 it -> 要删除的数据的开始位置\n```\n\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    auto it = std::remove_if(\n        vec.begin(),\n        vec.end(),\n        [](int const& v) -> bool {return v % 2 != 0;});\n    while (it != vec.end())\n    {\n        it = vec.erase(it);\n    }\n    // 也可以这么写：表示从it到end全删完，就不用while了。\n    // vec.erase(it, vec.end());\n}\n```\n## for_each\n指定范围，每一个元素做某事。\n\n以下表示：从begin到end，每个元素输出自己的值+10的结果。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n\n    std::for_each(\n        vec.begin(),\n        vec.end(),\n        [](auto const & v)\n        {\n            std::cout << v + 10 << std::endl;\n        });\n}\n```\n### 并行Policy\n可以在`for_each`中第一个参数加上`std::execution::par`表示并行处理。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n\n    std::for_each(\n        std::execution::par,\n        vec.begin(),\n        vec.end(),\n        [](auto const & v)\n        {\n            std::cout << v + 10 << std::endl;\n        });\n}\n```\n但是输出可能会乱七八糟的：\n![](../../images/Cpp_20240512_STL/image-20240717062532492.png)\n这是因为没有加锁、同步机制。\n>除了`std::execution::par`还有`std::execution::seq`，表示顺序执行。\n## adjacent_find\n返回有重复值的开始位置。\n\n|           |                                                                                                                                                                   |\n| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| equality  | `template <class ForwardIterator>`<br>`ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last);`                                              |\n| predicate | `template <class ForwardIterator, class BinaryPredicate>`<br>`ForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last, BinaryPredicate pred);` |\n实现：\n```cpp\ntemplate <class ForwardIterator>\nForwardIterator adjacent_find (ForwardIterator first, ForwardIterator last)\n{\n    if (first != last)\n    {\n        ForwardIterator next=first; ++next;\n        while (next != last) {\n            if (*first == *next)     // or: if (pred(*first,*next)), for version (2)\n                return first;\n            ++first; ++next;\n        }\n    }\n    return last;\n}\n```\n要求迭代器是const的。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 2, 4, 5, 6, 7, 8 };\n    //                          ^\n    //                          it\n    auto it = std::adjacent_find(vec.cbegin(), vec.cend());\n    while (it != vec.end())\n        std::cout << *it++ << std::endl;\n}\n/* 输出：\n * 2\n * 2\n * 4\n * 5\n * 6\n * 7\n * 8\n */\n```\n### 通过二元谓词限定\n返回重复值开始位置只是`adjacent_find`的默认行为，实际上是容器内两个相邻元素的一种`==`对比，我们可以自定义对比相邻元素的行为。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    //                             ^\n    //                             it\n    auto it = std::adjacent_find(\n        vec.cbegin(),\n        vec.cend(),\n        [](auto const& v, auto const& v2) -> bool)\n        {\n            return v == 3;\n        };\n    while (it != vec.end())\n        std::cout << *it++ << std::endl;\n}\n/* 输出：\n * 3\n * 4\n * 5\n * 6\n * 7\n * 8\n */\n```\n## count、count_if\n```cpp\ntemplate <class InputIterator, class T>\ntypename iterator_traits<InputIterator>::difference_type count (InputIterator first, InputIterator last, const T& val);\n```\n合计从first到last的val值有多少。\n### 与execution结合\n可以在第一个参数中设定`std::execution::par`以分解任务的并行方式执行。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 3};\n    auto n = std::count(std::execution::par, vec.cbegin(), vec.cend(), 3);\n    // n = 2\n}\n```\n### lambda\n如下，统计奇数。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 3};\n    auto n = std::count_if(\n        std::execution::par,\n        vec.cbegin(),\n        vec.cend(),\n        [](auto const& v) -> bool\n        {\n            return v % 2 != 0;\n        });\n    // n = 5\n}\n\n```\n## copy、shuffle、is_permutation\n### copy\n```cpp\ntemplate <class InputIterator, class OutputIterator>\nOutputIterator copy (InputIterator first, InputIterator last, OutputIterator result);\n```\n1. first到last是要被拷贝的数据位置\n2. result是要写入的位置\n3. result不能指向first到last中的任意一个。\n4. 返回写入的最后一个数据的下一个位置。\n实现：\n```cpp\ntemplate<class InputIterator, class OutputIterator>\nOutputIterator copy (InputIterator first, InputIterator last, OutputIterator result)\n{\n    while (first != last) {\n        *result = *first;\n        ++result;\n        ++first;\n    }\n    return result;\n}\n```\n### shuffle\nshuffle意为随机洗牌的意思。\n```cpp\ntemplate <class RandomAccessIterator, class URNG>\nvoid shuffle (RandomAccessIterator first, RandomAccessIterator last, URNG&& g);\n```\n1. 参数1、2为可随机访问的迭代器\n2. 参数3是URNG，指基于的引擎，常常使用`<random>`中的。\n3. 如果需要每次运行时的结果不一样，需要传入种子。\n### is_permutation\npermutation表示一组数据可能的一种序列、排列。此函数用于检查两个序列是否是彼此的排列（即，两个序列中的元素相同，顺序可能不同）\n\n>permutation and combination   n. 排列组合\n\n|           |                                                                                                                                                                                                               |\n| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| equality  | `template <class ForwardIterator1, class ForwardIterator2>`<br>`bool is_permutation (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);`                                              |\n| predicate | `template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>`<br>`bool is_permutation (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, BinaryPredicate pred);` |\n1. 对比first1到last2是不是first2开始的相同数目的元素的一种排列。\n2. 可以加二元谓词，如果不加则默认是用`==`作谓词。\n3. 需要注意：\n    1. L1元素数目应当小于等于L2的元素数目，\n    2. 如果L1元素数目大于L2，则程序崩溃。\n    3. L1长度如果小于L2，只和L2的前L1长度个元素进行对比。\n    4. 所以如果要得到正确的结果，应该前提知道L1长度等于L2长度。\n\n以下为实现：\n```cpp\n// 全程中，first1 和 first2、last2一旦确定就固定了。\n// it1是L1的末尾边界（开区间），是前进指针。\ntemplate <class InputIterator1, class InputIterator2>\nbool is_permutation (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)\n{\n    // 寻找L1和L2不匹配的地方\n    // std::mismatch 函数返回一个 std::pair，其中包含两个迭代器，分别指向两个序列中第一个不匹配的元素。\n    std::tie(first1, first2) = std::mismatch(first1, last1, first2);\n    // 全匹配，直接true\n    if (first1 == last1)\n        return true;\n    // last2移动last1到first1的差值，确定L2的范围\n    InputIterator2 last2 = first2;\n    std::advance(last2,std::distance(first1, last1));\n    // 总体是计算L1每个出现过的元素在L2中有多少个\n    // 里面在first1到it1之间find it1是为了避免重复查询\n    for (InputIterator1 it1 = first1; it1 != last1; ++it1) \n    {\n        if (std::find(first1, it1, *it1) == it1)\n        {\n            // 开始计算L1中这个*it1在L2中出现多少次\n            auto n = std::count(first2, last2, *it1);\n            // 如果在L2中没出现过，肯定false。\n            // 计算在L1中的次数。看看和n是否匹配。\n                // 即使在L2出现过，但是L2中的次数与L1的次数不对应 则 还是不匹配相同次数。\n                // 为何不直接计算、对比两个组中的次数？因为一旦n为0就不用计算L1中次数了，稍稍提升一下效率。\n            if (n == 0 || std::count(it1, last1, *it1) != n)\n                return false;\n        }\n    }\n    return true;\n}\n```\n### 示例\n把vec复制到vec2，vec随机化，然后再判断\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    std::vector<int> vec2(vec.size());\n\n    std::copy(vec.cbegin(), vec.cend(), vec2.begin());\n    std::shuffle(vec.begin(), vec.end(), std::default_random_engine());\n    bool res = std::is_permutation(vec.cbegin(), vec.cend(), vec2.cbegin());\n    if (res) \n        std::cout << \"vec经过打乱后，依然是vec2的重新排列\" << std::endl;\n    else std::cout << \"vec不是vec2的重新排列\" << std::endl;\n    \n    for (auto const& v : vec)\n        std::cout << v << std::endl;\n}\n/* 输出：\n * vec经过打乱后，依然是vec2的重新排列\n * 4\n * 0\n * 3\n * 1\n * 5\n * 7\n * 6\n * 2\n * 8\n */\n```\n## transform\ntransform range. 经过一个计算操作，变换为另一种单位。\n操作可以是一元，也可以是二元。\n### 一元\n以下操作表示：把vec中的数据每个都平方、转为long long后存到vec2。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    std::vector<long long> vec2(vec.size());\n    std::transform(\n        std::execution::par, //依然可以用par执行\n        vec.cbegin(),\n        vec.cend(),\n        vec2.begin(),\n        [](auto const& v) -> long long\n        {\n            return v * v;\n        });\n}\n```\n\n>这里发现一个问题：当`(auto const& v)`中`&`改为`&&`时就运行时报错。\n>而去掉`const`后，`(auto && v)`中`&&`就又没问题了。\n>看来如果以后想用转发引用`&&`，就不能和const共存。\n>经过分析，发现`(auto && v)`是可以推断出v是`const int &`的，因此不要再自己加const了。\n\n### 二元\n```cpp\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    std::vector<int> vec2{ 10, 11, 12, 13, 14, 15, 16, 17, 18 };\n    std::vector<long long> vec3(vec.size());\n    std::transform(\n        std::execution::par, //依然可以用par执行\n        vec.cbegin(),\n        vec.cend(),\n        vec2.cbegin(),\n        vec3.begin(),\n        [](auto && v, auto && v2) -> long long\n        {\n            return v + v2;\n        });\n}\n```\n### 与`<funcational>`结合\n该库中提供了一些运算类。如minus、plus、multiplies\n原型：\n```cpp\ntemplate <class T>\nstruct plus\n{\n    T operator() (const T& x, const T& y) const\n    {\n        return x + y;\n    }\n    typedef T first_argument_type;\n    typedef T second_argument_type;\n    typedef T result_type;\n};\n```\n使用：直接放在functor的位置，不用声明参数，直接就给你提取了。甚至可以不填模板参数！太强悍了。\n```cpp\n#include <functional>\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    std::vector<int> vec2{ 10, 11, 12, 13, 14, 15, 16, 17, 18 };\n    std::vector<long long> vec3(vec.size());\n    std::transform(\n        std::execution::par, //依然可以用par执行\n        vec.cbegin(),\n        vec.cend(),\n        vec2.cbegin(),\n        vec3.begin(),\n        std::plus<int>()/* 甚至可以省略为 std::plus() */);\n}\n// 运行后vec3中结果：10 12 14 16 18 20 22 24 26\n```\n## accumulate、reduce\n来自`<numeric>`\n把所有部分累积起来。`C++17`之后演化成了reduce。\nreduce可以用par，而accumulate不能。\n \n|        |                                                                                                                                                                  |\n| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| sum    | `template <class InputIterator, class T>`<br>`T accumulate (InputIterator first, InputIterator last, T init);`                                                   |\n| custom | `template <class InputIterator, class T, class BinaryOperation>`<br>`T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op);` |\n其中init可以指定一个起始值、基准值。\n\n实现\n```cpp\ntemplate <class InputIterator, class T>\nT accumulate (InputIterator first, InputIterator last, T init)\n{\n    while (first!=last) {\n        init = init + *first;  // or: init=binary_op(init,*first) for the binary_op version\n        ++first;\n    }\n    return init;\n}\n```\n使用\n```cpp\n#include <numeric>\nint main()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    \n    // sum = 36\n    auto sum = std::reduce(std::execution::par, vec.cbegin(), vec.cend());\n    // sum = 100 + 36\n    auto sum = std::reduce(std::execution::par, vec.cbegin(), vec.cend(), 100);\n}\n```\n### 制定reduce规则\n使用lambda表达式，指定reduce的计算规则。比如可以让它从累加变为累乘。\n如果是二元运算，必须提供init值，作为第一次运算时v1的占位值，（第一次运算，v2占据`vec[0]`，必须提供一个v1搭配，就由init充当）\n但是要注意，如果是乘法，则init不可以为0，否则无论如何计算结果都为0，正确的应设置为1。\n```cpp\n#include <numeric>\nint main()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    \n    auto sum = std::reduce(\n        std::execution::par,\n        vec.cbegin(),\n        vec.cend(),\n        100,          // 起始值\n        [](auto&& v, auto&& v2) -> int\n        {\n            return v + v2 + 15;\n        });\n}\n```\n同理，也可以用`<functional>`中的functor作为谓词。\n```cpp\nint main()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    \n    auto sum = std::reduce(\n        std::execution::par,\n        vec.cbegin(),\n        vec.cend(),\n        0,          // 起始值\n        std::plus());\n    // sum = 36\n}\n```\n# ranges、流水线（pipeline）、面向过程（函数）编程\n`C++20`\nranges可以让计算进行流水线化。以下是案例：\n\n把奇数挑出来。并且把每个数做一次变换。\n```cpp\nclass IsOdd\n{\npublic:\n    bool operator () (int const& v)\n    {\n        return v % 2 != 0;\n    }\n};\nint main()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    std::vector<int> vec2(vec.size());\n\n    auto it = std::copy_if(\n        vec.cbegin(),\n        vec.cend(),\n        vec2.begin(),\n        [](auto&& v) -> bool\n        {\n            return v % 2 != 0;\n        });\n}\n```\n## 与尾插迭代器结合\n`std::back_inserter(vec2)`只用执行一次，与vec2产生关联，生成一个输出迭代器。在算法发生输出时，就在尾部自动扩容并插入数据。\n\n>但`back_inserter`不适合与vector搭配，因为尾插会造成容量频繁改变。更适合与list搭配。\n\n```cpp\n#include <iterator>\nint main()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    // 无需给vec2开辟空间了，下面的back_inserter帮我们处理\n    std::vector<int> vec2;\n    // filter\n    auto it = std::copy_if(\n        vec.cbegin(),\n        vec.cend(),\n        std::back_inserter(vec2),\n        [](auto&& v) -> bool\n        {\n            return v % 2 != 0;\n        });\n    // transform \n    std::transform(\n        std::execution::par,\n        vec2.cbegin(),\n        vec2.cend(),\n        vec2.begin(),\n        [](auto && v) -> auto\n        {\n            return v * v;\n        });\n}\n```\n1. 先生成源数据（可以用generator或fill来填充）\n2. 选择性拷贝，即filter\n    1. 用高阶函数（lambda函数对象）限定filter行为\n    2. 用`back_inserter`做输出\n3. transform。\n\n这种数据流式（data flow）、流水线式的操作，是一种常见于大型软件的设计模式。这种就很适合用`C++20`中的ranges库来处理、简化。\n## 示例\n一般的filter如`copy_if`的参数需要两个输入迭代器、一个输出迭代器和一个谓词，现在ranges搭配管道符号，参数只需要填写谓词即可。\nfilter、transform都是一个view，每一个view在内部都有自己的迭代系统。\n```cpp\nvoid example()\n{\n    std::vector<int> vec{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    auto trans_view = vec | std::ranges::views::filter(\n        [](auto&& v) -> bool\n        {\n            return v % 2 != 0;\n        }) | std::ranges::views::transform(\n            [](auto && v) -> auto\n            {\n                return v * v;\n            });\n    for (auto && v : trans_view)\n    {\n        std::cout << v << std::endl;\n    }\n}\nint main()\n{\n    example();\n    // 输出 1 9 25 49\n}\n```\n调试时，发现首先略过了view，而是到了for循环取结果时才回去求值。这种求值方式称之为：惰性求值。\n被过滤掉的值，在原位置上用`ranges::dangling`作占位符。\n这种编程范式称之为：functional programming\n\n更简洁的写法：（ranges可以省略，直接写`std::views`）\n```cpp\n// 更简洁的写法：\nvoid example()\n{\n    auto is_odd = [](auto& v) -> bool\n        {\n            return v % 2 != 0;\n        };\n    auto square = [](auto&& v) -> auto\n        {\n            return v * v;\n        };\n     for(auto&& v : vec | std::views::filter(is_odd) | std::views::transform(square))\n     {\n         std::cout << v << std::endl;\n     }\n}\n```\n## views、惰性计算\n![](../../images/Cpp_20240512_STL/image-20240720064453824.png)\n1. view是依赖vector的，内容来自vector，实际上view对容器的每个元素进行了一些连接\n2. view经过各种变换，如`filter`、`transform`，也将变为一个view\n3. view可以通过管道+`std::ranges::to`变为一个容器。\n\n惰性计算：\n1. view中没有任何实体元素，只是逻辑上的映射。\n2. 如果此时view要让元素6加2，则view是把元素6+2的这个操作内容、抽象逻辑传给下一步。在实际操作之前，一系列的操作内容可以积累到一起，到最后再一次性计算。实际的操作只有最后vector被读取、调用的时候才去从vector取元素。\n3. 中间的view只是把操作连接上，相当于函数套内部函数，逻辑行为套内部行为。就类似于lambda函数。这种都叫做惰性计算，是面向函数编程范式的特点，更关注于高阶的抽象、干什么逻辑，不关注具体操作。","categories":["Cpp","Modern","STL"]},{"title":"Source Insight使用","url":"/一些工具的使用/Source Insight使用/","content":"# 快速上手\n\n1. 左上角，Project，New Project，新建一个工程。出现以下界面：\n   ![](../../images/Source%20Insight使用/image-20240506213527152.png)\n2. Source Insight的工程文件夹和源码根文件夹需要并列在一起。可以在源码根文件夹之外创建一个\"Insight\"（名字自定）的文件夹。\n   ![](../../images/Source%20Insight使用/image-20240506213827928.png)\n3. 将Insight的目录地址拷贝到第1步的第2个空内。点击OK。\n   ![](../../images/Source%20Insight使用/image-20240506214358083.png)\n4. 出现New Project Settings窗口，默认不改变设置。继续OK。\n   ![](../../images/Source%20Insight使用/image-20240506214516331.png)\n5. 出现Add and Remove Project Files窗口，点击源码根文件夹，再点击右侧边的Add Tree按钮。添加完成后，Close此窗口即可。\n   ![](../../images/Source%20Insight使用/image-20240506214715147.png)\n6. 添加完工程文件后。接着，左上角，Project，Synchronize Files。同步以后，在Source Insight中编辑时可以同时同步磁盘上的文件。（不同步其实也可以，麻烦之处就是如果稍微改动一下代码它就总会提示是否保存）\n   ![](../../images/Source%20Insight使用/image-20240506215047348.png)\n7. 同步完后，即可点击工具栏中的圆圈带P的按钮，打开菜单，查看文件。\n   ![](../../images/Source%20Insight使用/image-20240506215346027.png)\n# 配置\n\n如果文件后缀名不是常规的，比如Cpp的`.cpp`扩展名写作了`.cc`，那么就需要人为配置。\n1. 左上方，Options，File Type Options\n   ![](../../images/Source%20Insight使用/image-20240506215618397.png)\n2. 左侧栏选择某一语言的文件类型，在右侧最上方的File Filter中详细加规则，如图：\n   ![](../../images/Source%20Insight使用/image-20240506215938879.png)\n3. 配置完后，需要再次Add Tree，需要点击Project，Add and Remove Project Files\n   ![](../../images/Source%20Insight使用/image-20240506220109756.png)\n# 快捷键配置\n\nOptions，Key Assignments。可以配置代码高亮的快捷键。\n![](../../images/Source%20Insight使用/image-20240506224734346.png)\n\n","categories":["一些工具的使用"]},{"title":"Cpp_Concepts","url":"/Cpp/Cpp_Concepts/","content":"# Concepts\n意为概念，用于限定类型是哪些子类型。\n# Concepts中的requires约束\n\n```cpp\n#include<iostream>\n#include<concepts>\ntemplate <typename T>\nT add<T a, T b>\n{\n    return a + b;\n}\n\nint main()\n{\n    auto c = add(1, 2);\n    return 0;\n}\n```\n以上，会自动推断出1、2为int，返回值3亦为int。\n目前有需求，仅仅想要add进行int的计算，比如禁止浮点型的计算。则可用requires约束\n```cpp\n#include<iostream>\n#include<concepts>\ntemplate <typename T> requires(std::integral<T>)\nT add(T a, T b)\n{\n    return a + b;\n}\n\nint main()\n{\n    auto c = add(1, 2);\n    return 0;\n}\n```\n如果main函数调用add时传入浮点型：则编译不通过\n> 报错：\n> no instance of function template \"add\" matches the argument list\n> argument types are: (double, double)\n\n```cpp\nint main()\n{\n    auto c = add(1.0, 2.0);   // error\n    return 0;\n}\n```\n如果想要接受浮点型数据，可以在requires中加入`||`\n```cpp\ntemplate <typename T> requires(std::integral<T> || std::floating_point<T>)\nT add(T a, T b)\n{\n    return a + b;\n}\n\nint main()\n{\n    auto c = add(1.0, 2.0);     // ok\n    return 0;\n}\n```\n# `type_traits`\n\nType Traits就是在编译期把各种情况列举出来，根据不同的种类去判断T是不是属于某种情况。然后就可以用在concept中。\n\n`std::is_integral`\n\nMember types:\n\n| member type  | definition                         |\n| ------------ | ---------------------------------- |\n| `value_type` | bool                               |\n| type         | either `true_type` or `false_type` |\n\nMember constants:\n\n| member constant | definition               |\n| --------------- | ------------------------ |\n| value           | either `true` or `false` |\n\n`std::is_integral`后面往往要加`<T>::value`以取出真假值，或者可以用`std::is_integral_v<T>`代替。\n```cpp\n// concepts 文件 中 std::integral<T>的原型\n_EXPORT_STD template <class _Ty>\nconcept integral = is_integral_v<_Ty>;\n```\n有好多种写法：\n1. `std::integral<T>`\n2. `std::is_integral<T>::value`\n3. `std::is_integral_v<T>`\n# 自定义concept\n\n针对某种类型进行约束：\n```cpp\ntemplate<typename T>\nconcept my_concept = std::integral<T> || std::floating_point<T>;\n```\n如此，requires后面使用约束条件就更加方便了：\n```cpp\ntemplate<typename T> requires(my_concept<T>)\nT add(T a, T b)\n{\n    return a + b;\n}\n```\n\n# 更复杂的concept\n\nrequires不仅可以直接使用concept，也可以用于定义新的concept。\n如：`template<typename T> concept my_concept = requires(T t) { // ... }`\n或`template<typename T> concept my_concept = requires(bool参数)`\n第一种是使用一些类型参数，大括号内会去匹配你规定的形式，这些形式需要遵循官方规定的写法。\n## 限制 类必须有 某个限定函数\n\n如下定义，表达的是：t是否有名为`get_v`、无参数的方法，并且返回的是不是`bool`类型。\n```cpp\ntemplate<typename T>\nconcept my_concept = requires(T t)\n{\n    { t.get_v() } -> std::same_as<bool>;\n}; // 记得加;\n```\n使用如下：\n```cpp\nclass Test\n{\npublic:\n    bool get_v(void)\n    {\n        return true;\n    }\n};\ntemplate<typename T> requires(my_concept<T>)\nvoid show(T t)\n{\n    auto r = t.get_v();\n    std::cout << r << std::endl;\n}\nint main()\n{\n    Test test;\n    show(test);\n}\n```\n如果把Test类中的`get_v`方法改名为`get_v2`，让show函数调用`t.get_v2`。最后编译不通过。因为模板参数T对应的Test类中没有名为`get_v`、无参数且返回值为bool的方法。\n> 报错：\n> no instance of function template \"show\" matches the argument list\n> argument types are: (Test)\n\n```cpp\ntemplate<typename T>\nconcept my_concept = requires(T t)\n{\n    { t.get_v() } -> std::same_as<bool>;\n};\nclass Test\n{\npublic:\n    bool get_v2(void)\n    {\n        return true;\n    }\n};\ntemplate<typename T> requires(my_concept<T>)\nvoid show(T t)\n{\n    auto r = t.get_v2();  // 不报错，但main函数中的show(test)报错\n    std::cout << r << std::endl;\n}\nint main()\n{\n    Test test;\n    show(test);    // error\n}\n```\n### 对成员方法的const修饰符忽略\n`bool get_v(void) const`虽然加了const，但可以通过\n```cpp\ntemplate<typename T>\nconcept my_concept = requires(T t)\n{\n    { t.get_v() } -> std::same_as<bool>;\n};\nclass Test\n{\npublic:\n    bool get_v(void) const // 虽然加了const 但可以通过\n    {\n        return true;\n    }\n};\ntemplate<typename T> requires(my_concept<T>)\nvoid show(T t)\n{\n    auto r = t.get_v();\n    std::cout << r << std::endl;\n}\nint main()\n{\n    Test test;\n    show(test);   // ok\n}\n```\n## 复合\n1. T类型有名为`get_v`、无参数的方法，并且返回`bool`类型。\n    1. 必须有`{ } -> type`的形式\n2. T类型有名为read的方法，且参数必须是u的类型`std::string const &`。没有规定返回值类型\n3. T类型必须有名为val的成员变量\n    1. 发现如果定义val为private（甚至static private）是不可以通过的，必须是可以从外部访问的。\n\n```cpp\ntemplate <typename T>\nconcept my_concept = requires(T t, std::string const& u)\n{\n    { t.get_v() } -> std::same_as<bool>;\n    t.read(u);\n    T::val;  // 或者写成t.val;\n};\n\nclass Test\n{\npublic:\n    bool get_v(void) const // 虽然加了const 但可以通过\n    {\n        return true;\n    }\n    void read(std::string const& str) const\n    {\n    }\npublic:\n    int val{ 5 }; // ok\n/*\nprivate:\n    static int val;  //error\n*/\n};\n```\n## 嵌套requires\n可以用来限定某一个成员变量的类型\n\nrequires的内容是：T类型中要有val，而且val的类型要和float一样。\n```cpp\ntemplate <typename T>\nconcept my_concept = requires(T t)\n{\n    requires std::same_as<decltype(t.val), float>;\n};\n```\n# 应用\n## 通过concepts约束迭代器类型\n\n在没有concept之前，编程时乱用不匹配的迭代器编译时是不知道对错的，运行的时候才报错。\n而Modern `C++`之后随着模板和concept的发展，可以约束迭代器的行为。比如规定此迭代器类必须支持`++`、`--`操作，从而此迭代器是Bidirectional。\n有了concepts，在编译期就能知道程序的对错了。\n## 通过concepts约束谓词类\n1. 首先编写针对Unary Predicate的concept\n2. 再加到`find_if`这个模板函数后限定：\n    1. “模板参数1 UnaryPredicate”符合`UnaryPredicateConcept`中T的要求。（T有`t(*u)`且返回bool的方法）\n3. 注意，`t(*u)`中u前必须有`*`，不然`t()`的参数将被限定为InputIterator。那么`bool operator () (int const& v)`由于参数是int将无法通过。\n\n```cpp\ntemplate <typename T, typename U>\nconcept UnaryPredicateConcept = requires(T t, U u)\n{\n    { t(*u) } -> std::same_as<bool>;\n};\n\ntemplate <class InputIterator, class UnaryPredicate>\n    requires(UnaryPredicateConcept\n        <UnaryPredicate, InputIterator>)\nInputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred)\n{\n    while (first != last)\n    {\n        if (pred(*first))\n            return first;\n        else\n            ++first;\n    }\n    return last;\n}\n\nclass IsOdd\n{\npublic:\n    bool operator () (int const& v)\n    {\n        return v % 2 != 0;\n    }\n};\n\nint main()\n{\n    std::vector<int> vec{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n    IsOdd is_odd_functor;\n    // 此find_if目前受UnaryPredicateConcept的制约。\n    auto it = ::find_if(vec.begin(), vec.end(), is_odd_functor);\n    while (it != vec.end())\n    {\n        std::cout << *it << std::endl;\n        it = ::find_if(it + 1, vec.end(), is_odd_functor);\n    }\n}\n```\n此`find_if`目前受UnaryPredicateConcept的制约。\n现在，`find_if`的参数3必须是：“包含`t(*u)`且返回bool的函数”的类型。\n## 升级模板库\n\n把一个算法升级为通用算法，放到库中支持所有类型。\n首先升级为模板函数。再用concept对模板类型做限制，从而在编译期就可以做相关检查。","categories":["Cpp","Modern","模板"]},{"title":"Cpp_const家族_与模板的关系","url":"/Cpp/Cpp_const家族_与模板的关系/","content":"# 内容\n\n1. const：运行期；只能修饰变量（即使能修饰成员函数，但是本质上修饰的是this变量）；常性\n2. constexpr：可能运行期、可能编译期；可修饰变量、可修饰函数；常性\n    * if constexpr\n3. consteval：编译期；只能修饰函数；函数是一段代码，没有常性一说。比constexpr更严格\n4. 模板参数可以传入常量\n    1. 传入某一类型的常量\n    2. 传入auto常量\n5. constinit：编译期；修饰全局变量（包括静态变量）；无常性\n# 常量\n\n不能以变量给数组的大小做定义。因为数组要确定容量，在编译时就确定了它的内存的映像、结构（即必须在运行前就需要清楚大小），执行时不能改变。\n> 类似数组的大小要确定的例子，还有switch case中的值，必须用字面常量或常量来描述。\n\n```cpp\nint main()\n{\n    int a = 5;\n    int arr[a] = { 0 };  // error\n}\n```\n普通int肯定是不行的。但是const int却可以：\n```cpp\nint main()\n{\n    const int N = 5;\n    int arr[N] = { 0 };  // ok\n}\n```\n为什么呢？因为此处的const就代表：编译期时，N可以得到确定为5。所以，满足了数组的定义的条件即编译期时确定大小，于是可以通过。\n> 但const修饰变量不是一定能在编译期确定的。比如：\n\n```cpp\nint get_size(int);\nint main()\n{\n    const int N = get_size(5);  // ok\n    int arr[N] = { 0 };        // error\n}\nint get_size(int a)\n{\n    return a;\n}\n```\n通过函数返回值去初始化const变量时，虽然可以定义、初始化const变量，但是用在`arr[N]`中又会报错。这说明，const int N在定义时，是可以感知到后面的值是一个字面常量还是一个函数返回值（本质上是一个变量）的。如果是通过函数返回值（变量）初始化的，虽然可以得到初始化，但是却不能用于定义数组。这是因为，函数本质上是在执行代码时，通过栈帧动态进行的，这又陷入了执行期才能确定具体结果，所以不能给数组定义。\n\n所以：const修饰的变量，不一定能在编译期决定，即也是有可能在执行期确定的。但是编译期是可以清楚地分明你这个N的来历的，即使N被声明const也无所谓。因此const这个关键字是模棱两可的。\n于是，如果我们要限制一个变量必须在编译期就确定常性，就得用constexpr来修饰。而不是用const；const以后则可以用于修饰运行期的行为，以后最好不要再乱用const来修饰编译期常量。\n# constexpr\n\nModern Cpp提供的关键字。\n1. 如果用来修饰变量：就可以用于限制等式右边的值是一个常量。这个常量一定是在编译期就确定了的。\n2. 如果用来修饰函数：函数被constexpr修饰后，看调用点接收返回值的变量是否也为constexpr。\n    1. 如果是，则编译期就会确定死返回值，直接在调用点替换，而不生成代码。\n    2. 如果不是，则改函数正常生成可编译代码，变为普通的函数在运行期流转。\n\n如下，如果告知了N是一个constexpr变量，但发现`get_size`不是一个constexpr，则编译不通过。\n```cpp\nint main()\n{\n    constexpr int N = get_size(5);  // error\n    int arr[N] = { 0 };             // error\n}\nint get_size(int a)\n{\n    return a;\n}\n```\n如果改为5，则通过。\n```cpp\nint main()\n{\n    constexpr int N = 5;  // ok\n    int arr[N] = { 0 };   // ok\n}\n```\n那么，如何通过函数返回值初始化constexpr变量呢？就需要给函数也用constexpr修饰。但是注意，不再支持前置声明，后置定义函数的形式，而只能直接写在前置：\n```cpp\nconstexpr int get_size();\n// 错误，get_size() 必须在调用点之前完整定义\nint main(void)\n{\n    constexpr int N = get_size();\n    int arr[N] = { 0 };          \n}\nconstexpr int get_size()\n{\n    return 5;\n}\n```\n正确写法：\n```cpp\nconstexpr int get_size(void)\n{\n    return 5;\n}\nint main(void)\n{\n    constexpr int N = get_size();//ok\n    int arr[N] = { 0 };          //ok\n}\n```\n因为constexpr的函数实际不会生成函数体，因此不支持前置声明、后置定义的形式。所以，constexpr的函数建议写为inline类型或者写在头文件中包含到前置。\n# consteval\n\n不能修饰变量，只能用于修饰函数，目的是比constexpr更严格地限制修饰的内容要在编译期确定。\n\n如果发现函数中返回值表达式中有非常量（下例则是val是变量），则不能编译通过。\n```cpp\nconsteval int get_size(int val)\n{\n    return 5 + val;\n}\nint get_value(void)\n{\n    return 3;\n}\nint main()\n{\n    const int b = get_value();    // ok\n    const int a = get_zize(b);    // error\n}\n```\n若改为：\n```cpp\nconsteval int get_size(int val)\n{\n    return 5 + val;\n}\nint get_value(void)\n{\n    return 3;\n}\nint main()\n{\n    const int b = 3;\n    const int a = get_zize(b);    // ok\n}\n```\n> 其实a用const、constexpr修饰都已无所谓了，因为consteval已经可以严格限制`get_size(b)`的返回值是编译期确定的了，无需靠constexpr来约束，用const也行。\n# 总结constexpr和consteval\n1. constexpr修饰函数时，并不严格限制函数中的内容必须是编译期就确定的，分两种情况：\n    1. 满足编译期就确定时，函数变为常量表达式，在调用点处替换\n    2. 不满足时，如传入一个变量参数，则必须在运行期才能确定的，就退化为一个普通函数。\n2. consteval是加强版的constexpr，不能修饰变量，因为修饰变量没意义。主要是用于修饰函数。主要是看函数参数是否全支持编译期确定。\n3. 被constexpr、consteval修饰的函数体内可以是递归。比如递归求和：（此时把鼠标挪在a上面，发现直接计算出了结果，55）\n\n```cpp\nconsteval int sum(int n)\n{\n    if(n == 0)\n        return n;\n    return n + sum(n - 1);\n}\nint main()\n{\n    constexpr int a = sum(10);\n}\n```\n但是，递归的层数默认最多为512层。这个值，不同编译器可以通过不同命令修改。\n# 模板参数传入常量\n## 模板参数传入某一类型的常量\n\n```cpp\ntemplate <int N>\nconstexpr int get_number(void)\n{\n    return N;\n}\nint main()\n{\n    constexpr int a = get_number<15>();\n}\n```\n实际编译完后，相当于产生以下代码：\n```cpp\nint get_number(void)\n{\n    return 15;\n}\nint main()\n{\n    constexpr int a = get_number();\n}\n```\n> 此例中的模板参数N必须是常量，最好用constexpr修饰。总之：变量不行；const可能不行（若等号右边的值不是字面常量、常量）\n> 同理，因为模板函数也是编译期确定的，所以N这种特定值参数必须也像上面谈的常量的用法一样，编译期必须确定。\n\n```cpp\ntemplate <int N>\nconstexpr int get_number(void)\n{\n    return N;\n}\nint main()\n{\n    //int b = 15;\n    //constexpr int a = get_number<b>(); // error\n    \n    constexpr int b = 15;\n    constexpr int a = get_number<b>();   // ok\n}\n```\n\n### `get_element`\n\n编译期判断。用constexpr修饰if语句\n\n```cpp\nstruct Obj\n{\n    int a;\n    std::string b;\n}\n\ntemplate<int N>\nauto get_element(Obj & obj)\n{\n    if constexpr (N == 0)\n        return obj.a;\n    else if constexpr (N == 1)\n        return obj.b;\n}\n```\n如果编译时确定`N == 1`，则会生成相应的函数。auto将切换成对应类型。\n```cpp\nstd::string get_element(Obj & obj)\n{\n    return obj.b;\n}\n```\n\n```cpp\nint main()\n{\n    Obj obj { 5, \"Hello\" };\n    int a = get_element<0>(obj);           // 5\n    std::string b = get_element<1>(obj);   // Hello\n}\n```\n\n## 模板参数传入auto常量\n\n`template<int N>`是int类型的特定值，而`template<auto V>`是任意类型的特定值。\n\nstatic的特点是，生命周期和全局变量一样，但是可见范围仅限于一部分，下面的value就仅限于类中可见。\n```cpp\ntemplate <auto V>\nclass Constant\n{\npublic:\n    static constexpr auto value = V;\n}\n```\n\n```cpp\nint main()\n{\n    auto a = Constant<19>::value;\n}\n```\n### constexpr配合auto，配合模板auto常量使用\n\n如果把a修饰为constexpr，则就会变为编译期计算。\n```cpp\nint main()\n{\n    constexpr auto a = Constant<19>::value;\n}\n```\n这么做的意义在于，可以让一个同名的变量具有不同的类型、不同的值，即复用了名字。模板原先只能用于类模板、函数模板，这样，套了一个类模板的外壳，让变量也具有了模板的能力。\n# 优化全局变量的初始化：constinit\n1. 与作用域无关\n2. 与常性无关\n3. 修饰全局变量（包含静态变量）\n\n```cpp\nvoid bar(void)\n{\n    static int val = 8;\n    std::cout << val << std::endl;\n}\nint main()\n{\n    bar();\n}\n```\n以上程序，val的初始化不在bar函数中，而是在main函数执行之前。所以调试的断点会掉下来。\n但是这不代表val是编译期执行的。\n```cpp\nint get_int(void)\n{\n    return 7;\n}\nvoid bar(void)\n{\n    static int val = get_int();\n    std::cout << val << std::endl;\n}\nint main()\n{\n    bar();\n    bar();\n}\n```\n以上代码，通过函数确定val值时，第一次调用bar，static语句是在bar函数执行时才执行的。而第二次调用bar，static语句不执行任何动作。\n\n全局变量，可能有两种行为：\n1. 在static语句前就执行完了\n2. 在static语句执行\n\n能不能优化，让static语句在static语句前就执行完？或者说，让它在编译期就完成行为？\n用constinit修饰就能起到这个作用。\n```cpp\nint get_int(void)\n{\n    return 7;\n}\nvoid bar(void)\n{\n    // constinit static int val = get_int();  // error, get_int() is not const value\n    constinit static int val = 8;             // ok\n    std::cout << val << std::endl;\n}\nint main()\n{\n    bar();\n    bar();\n}\n```\n与consteval有异曲同工之妙，被constinit修饰的变量，必须保证等号右边是一个常量（即编译期确定下来），否则编译不通过。这样，就能保证static语句在编译期初始化完毕。\n所以，val不能直接接受普通的`get_int()`函数返回值，如果要编译通过，需要修饰函数为`consteval`。\n\n虽然关键字带有const，但是不代表被修饰的变量是常性的，后期该值会不会被修改，是未定义的。如果要保证这个全局变量是常性，需要另外修饰const。\n\n> 其实用constexpr直接修饰全局变量，也可以起到让全局变量在编译期执行的效果，但是constinit的特点在于，它修饰后，变量不带有常性，可以后期更改，而constexpr修饰变量后，后面就没法更改了。\n\n# 总结\n\n模板都是和类型打交道。各种的策略最后本质上都是以不同类型决定的。本质上做的工作就是帮助编译器在编译期分辨各种类型，组装类、函数、实例，供开发人员使用。\n\n判断类型的特性，比如看是否是指针？需要用到`if constexpr`\n\n```cpp\ntemplate<typename T>\nauto get_val(T t)\n{\n    if constexpr (std::is_pointer_v<T>)\n        return *t;\n    else\n        return t;\n}\n\nint main()\n{\n    int a = 9;\n    auto v = get_val(&a); // &a 识别为 int *  返回值得到的是int型，值为9\n    auto v2 = get_val(a); // a 识别为  int    返回值得到的是int型，值为9\n}\n```","categories":["Cpp","Modern","模板"]},{"title":"Cpp_模板_Traits_Policy","url":"/Cpp/Cpp_模板_Traits_Policy/","content":"# 模板是为了什么？\n\n> 利用了模板的元编程，可以像面向对象那样复用、组合可用的代码（即也可以把一段代码作为组件使用），但是这不是Cpp的本意，实际上是Cpp的“副作用”，只是貌似是一种优势。\n> 利用了模板的元编程的更有价值的作用在于：可以编译期执行、计算。\n\n模板是为了编译期运算，编译期运算就可以达到零开销的效果。\n\n传统的运行时运算的程序的性能主要依赖于客户端的计算机性能。而编译期运算的性能则主要依赖开发侧的计算机性能。`C++`的设计目标就在于`Zero Overhead`，即零开销，意思是尽量把工作都在编译期间完成。\n\n主要体现在模板、元编程上，指导编译器生成代码\n\n比如，现在有一个需求，是编写add函数，返回两个操作数的加和值。\n\n刚开始可能只想到了两个整型。\n```cpp\n#include<iostream>\nint add(int a, int b)\n{\n    return a + b;\n}\nint main()\n{\n    int c = add(1, 2);\n}\n```\n但是问题在于，后期可能要加上float型的情况。那我们可以通过Cpp的函数重载功能进行解决。\n```cpp\nfloat add(float a, float b)\n{\n    return a + b;\n}\n```\n由此可以看出，需要模板的地方在于：\n1. 需要函数重载\n2. 虽然是函数重载，但是这些函数的结构相似，具体的操作、行为都一样。\n3. 区别仅在于操作的对象的数据类型不同。\n\n在这种情况下，可以不用反复重载，而是利用模板，让编译器为我们自动生成。当然，编译器不会一下子全部把所有情况都生成，而是我们当时的代码具体用哪个，就在编译期特别地生成哪个。这就叫做模板编程。\n# 模板编程\n\n以下叫做函数模板。不能叫做函数。这个函数模板也不是编译单元，即不是可编译的代码。\n```cpp\ntemplate<typename T>\nT add(T a, T b)\n{\n    return a + b;\n}\n```\n而是从`add<float>`开始到之后才是编译单元。总之：模板不会生成代码，模板不能编译，而是在使用模板的时候，指导编译器生成相应的函数代码，才有了可编译的代码。\n```cpp\nint main()\n{\n    float c = add<float>(1.0f, 2.0f);\n}\n```\n\n# 模板特化\nSpecialization\n## 全特化\nFull Specialization\n\n如果模板中的所有类型T都被具体类型替代了，那么`< >`中就不用写`typename T`了，空着。叫做全特化。\n\n```cpp\ntemplate < >\nint add(int a, int b)\n{\n    return a + b;\n}\n```\n### 灵活利用特化\n\n```cpp\ntemplate<typename T, typename R>\nR add(T a, T b)\n{\n    return static_cast<R>(a + b);\n}\n```\n以下语句是无法编译通过的，因为调用语句只说明了函数参数的类型，而函数返回类型系统是无法推断的。\n```cpp\nint main()\n{\n    float f = add(1, 2);\n}\n```\n如果以下这样写呢？也不行，因为模板中类型的顺序问题，导致float对应的是第一个类型T，因此系统还是未知函数返回类型。\n```cpp\nint main()\n{\n    float f = add<float>(1, 2);\n}\n```\n只能全部写出：`add<int, float>(1, 2);`\n\n或者：使用类似于后位缺省的写法习惯，来解决这个问题。即把T、R换个顺序，那么在调用add时，就可以略去T了。\n```cpp\ntemplate<typename R, typename T>\nR add(T a, T b)\n{\n    return static_cast<R>(a + b);\n}\n```\n以下调用，走的是`template<typename R, typename T>`的add。会生成：`float add(int, int)`。\n```cpp\nint main()\n{\n    float f = add<float>(1, 2);\n}\n```\n如果：配合上全特化模板函数。如以下main函数调用`add<int>`，则系统就判断出我们调用的是`int add(int, int)`了。总之，只要R和T全都对应上了特化的模板函数的所有类型，就会走模板特化函数。\n```cpp\ntemplate<typename R, typename T>\nR add(T a, T b)\n{\n    return static_cast<R>(a + b);\n}\ntemplate < >\nint add(int a, int b)\n{\n    return a + b;\n}\nint main()\n{\n    int c = add<int>(1, 2); //int add(int a, int b)\n}\n```\n### 简便的写法\n\n模板类型的后面的参数是可以有默认类型的。\n如果还是T、R的顺序，如下写：就是在说：如果不指定模板第二个类型参数，就会默认返回类型为int。\n```cpp\ntemplate<typename T, typename R = int>\nR add(T a, T b)\n{\n    return static_cast<R>(a + b);\n}\ntemplate < >\nint add(int a, int b)\n{\n    return a + b;\n}\n```\n而我们模板第一个类型参数T又是可以通过函数参数推断的，那么就可以全部省略：\n```cpp\nint main()\n{\n    int c = add(1, 2); //int add(int a, int b)\n}\n```\n\n来看看以下的情况：此时走的是`R add(T a, T b)`，是`int add(double, double)`\n```cpp\nint main()\n{\n    int c = add(1.0, 2.0);\n}\n```\n而如果这样：就会编译不通过，因为无法推断T的类型。\n```cpp\nint main()\n{\n    int c = add(1.0, 2.0f);\n}\n```\n那么就需要明确在add后加`< >`指出，T是什么。如果加的是double，那么`2.0f`会转为double型进行计算。\n```cpp\nint main()\n{\n    int c = add<double>(1.0, 2.0f);\n}\n```\n## 部分特化（实际上是函数模板的重载）\n\n```cpp\ntemplate<typename T, typename R = int>\nR add(T a, T b)\n{\n    return static_cast<R>(a + b);\n}\ntemplate<typename R = float>\nR add(long long a, long long b)\n{\n    return a + b;\n}\ntemplate < >\nint add(int a, int b)\n{\n    return a + b;\n}\nint main()\n{\n    auto c = add(1ll, 2ll);\n}\n```\n以上，add函数优先和特化的模板函数匹配，而不是和`R add(T a, T b)`匹配，因为，参数`1ll`和`2ll`与特化模板函数中的long long对应上了，即`R add(long long a, long long b)`，所以最后生成的函数是`float add(long long a, long long b)`。\n\n实际上，`template<typename R = float>`，这个形式，本质上是一种函数模板的重载。因为，给出了参数在某些特别类型下，函数的重定义，体现了多态。总之：同一个名字，不同的形式，都叫overload。\n### 再举一个例子_1\n\n```cpp\ntemplate<typename R = float>\nR add(long long a, long long* pb)\n{\n    return a + *pb;\n}\n```\n\n```cpp\nint main()\n{\n    auto b = 2ll;\n    auto c = add(1ll, &b);\n}\n```\n走的是`R add(long long a, long long* pb)`。这也是一个function template overload。\n### 再举一个例子_2\n\n```cpp\ntemplate<typename R = float>\nR add(long long a, long long b)\n{\n    return a + b;\n}\n\ntemplate<typename R = float>\nR add(long long a, long long& b)\n{\n    return a + b;\n}\n```\n\n```cpp\nint main()\n{\n    auto b = 2ll;\n    auto c = add(1ll, &b);\n}\n```\n此时，如果没有用到`add(long long, long long&)`，是可以正常编译的。\n但是，如果一旦用到了：\n```cpp\nint main()\n{\n    auto b = 2ll;\n    auto c = add(1ll, b);\n}\n```\n就会报错：\n```\n'add': ambiguous call to overloaded function\n\nmore than one instance of overloaded function \"add\" matches the argument list:\n    function template \"R add(long long a, long long b)\"\n    function template \"R add(long long a, long long &b)\"\n```\n# 类模板\n\n```cpp\ntemplate <typename R, typename T>\nclass Addition\n{\npublic:\n    R add(T a, T b) const noexcept\n    {\n        return a + b;\n    }\n}\n```\n\n```cpp\nint main()\n{\n    Addition<int, int> addition;\n    auto c = addition.add(1, 2);\n}\n```\n1. `Addition<int, int>`是对类模板的实例化，产生了类。\n2. `Addition<int, int> addition;`是对类的实例化，产生了对象。\n3. `addition.add(1, 2);`调用类模板函数。生成了代码。\n## 简便的写法\n\n能不能省一个模板参数，写出构造函数？\n```cpp\ntemplate<typename R, typename T = int>\nclass Addition\n{\npublic:\n    Addition(void)\n    {\n    }\n    Addition(T a, T b) : _a{ a }, _b{ b }\n    {\n        \n    }\n    R add(T a, T b) const noexcept\n    {\n        return a + b;\n    }\n    R add(void) const noexcept\n    {\n        return _a + _b;\n    }\nprivate:\n    T _a;\n    T _b;\n};\n```\n\n```cpp\nint main()\n{\n    Addition addition(1, 2);     // C++14标准无法编译通过\n    auto c = addition.add(1, 2); \n}\n```\n\n## 类的部分特化（偏特化）\nClass Template Partial Specialization\n\n```cpp\ntemplate<typename R, typename T>\nclass Addition\n{\npublic:\n    R add(T a, T b) const noexcept\n    {\n        return a + b;\n    }\n};\n```\n类的部分特化，定义时，要在类名后写尖括号，写入模板参数。\n```cpp\ntemplate <typename T>\nclass Addition<T, int>\n{\npublic:\n    int add(T a, T b) const noexcept\n    {\n        return a + b;\n    }\n};\n```\n\n```cpp\nint main()\n{\n    Addition<int, int> addition;\n    auto c = addition.add(1, 2); \n}\n```\n类的实例化走的是`class Addition<T, int>`。\n## 类的全特化\nClass Template Full Specialization\n\n```cpp\ntemplate < >\nclass Addition<int, int>\n{\npublic:\n    int add(int a, int b) const noexcept\n    {\n        return a + b;\n    }\n};\n```\n\n```cpp\nint main()\n{\n    Addition<int, int> addition;\n    auto c = addition.add(1, 2); \n}\n```\n类的实例化走的是`class Addition<int, int>`。\n### 再来个例子\n\n```cpp\ntemplate < >\nclass Addition<int, int*>\n{\npublic:\n    int add(int a, int* b) const noexcept\n    {\n        return a + *b;\n    }\n};\n```\n\n```cpp\nint main()\n{\n    auto b = 2;\n    Addition<int, int*> addition;\n    auto c = addition.add(1, &b);\n}\n```\n类的实例化走的是`class Addition<int, int*>`。\n# Traits\n\nTraits是特质、特性的意思，主要用来区分不同类型。在Modern Cpp中，有`<traits>`库，可以用来分析各种类型。\n如果要对某种类型单独做特别的处理时，就会用到Traits，这在meta progrmming中是一种设计模式。\n## AddTraits\n\n比如拿Addition加和函数举例：整型有整型的策略，浮点型有浮点型的策略。更具体地，整型中也有不同的整型：int有int的策略，long有long的策略……\n1. int数和另一个int数相加，可能会溢出，这时就需要转为long数加和并返回。\n2. long数和另一个long数相加，可能会溢出，这时就需要转为long long数加和并返回。\n## 在没有用到Traits时的解决方案\n如果只是通过两个模板参数来解决这个问题，可以采用如下方案：\n```cpp\ntemplate<typename R, typename T>\nR add(T a, T b)\n{\n    return a + b;\n}\n```\n但是，这个方案不够自动化。每当处理不同的类型，都需要时刻调整模板参数：\n```cpp\nint main()\n{\n    int a = 10, b = 20;\n    long c = add<long, int>(a, b);\n    long d = 2000;\n    long long e = add<long long, long>(c, d);\n}\n```\n## 用到Traits，让调用更爽\nTraits就是为了解决这个问题。通过提前约束不同类型的行为，从而让调用更简便。这让模板函数在使用上更自动化了。\n\n要写这样的Addition模板群，就要先声明一个主模板：\nT代表操作数类型。而操作数的返回值类型通过T对应的具体的class得出（本例中为R）。\n这个主模板可以不实现，因为这个主模板是一个抽象的定义。后期才会定义具体的、特化的类模板。\n```cpp\ntemplate <typename T>\nclass AddTraits;\n```\n## 通过类模板的特化实现AddTraits\n\nTraits是利用特化来实现的。通过类模板的特化，来区分不同类型的加和。\n\n拿unsigned short的\"加和\"类模板举例：\n```cpp\ntemplate < >\nclass AddTraits<unsigned short>\n{\npublic:\n    typedef unsigned int R;\n};\n```\n以上，在unsigned short类型的加和下，规定了目标类型R（即加和的返回类型）为unsigned int。\n这个R，要在模板类外部得到其实例可以如下操作：\n```cpp\nint main()\n{\n    // AddTraits<unsigned short>::R 前面需要加一个typename，不然R可能会被认作是静态变量名字。\n    typename AddTraits<unsigned short>::R r = 9;\n}\n```\n更多地：\n**unsigned int**的加和类模板，规定了目标类型R（即加和的返回类型）为unsigned long long。\n```cpp\ntemplate < >\nclass AddTraits<unsigned int>\n{\npublic:\n    typedef unsigned long long R;\n};\n```\n更多地：\n**unsigned long**的加和类模板，规定了目标类型R（即加和的返回类型）为unsigned long long。\n```cpp\ntemplate < >\nclass AddTraits<unsigned long>\n{\npublic:\n    typedef unsigned long long R;\n};\n```\n## 用AddTraits类模板编写Add函数模板\n\n我们的需求、目标就是，已知两个T类型的数，加和，返回T加和后特定、自定、规定的更大包容的类型。那么这个更大包容的类型就是每一个特化类模板中的R，现在可以统一写为：`typename AddTraits<T>::R`。\n\n>为了便于书写，可以重命名`AddTraits<T>::R`为R。\n\n```cpp\ntemplate<typename T>\ntypename AddTraits<T>::R add(T a, T b)\n{\n    typedef AddTraits<T>::R R;\n    return static_cast<R>(a) + static_cast<R>(b);\n}\n ```\n\n> 以上函数形式也可以如下写。即在模板参数中就通过缺省值的形式指明R是什么的别名，就可以用在返回值类型的简化了。\n\n```cpp\ntemplate <typename T, typename R = AddTraits<T>::R>\nR add(T a, T b)\n{\n    return static_cast<R>(a) + static_cast<R>(b);\n}\n```\n测试：\n```cpp\nint main()\n{\n    unsigned short a = 1u;\n    unsigned short b = 2u;\n    // 调用的是unsigned int add<unsigned short>(unsigned short a, unsigned short b)\n    auto c1 = add(a, b);\n    // 调用的是unsigned long long add<unsigned int>(unsigned int a, unsigned int b)\n    auto c2 = add(1u, 2u);\n    // 调用的是unsigned long long add<unsigned long>(unsigned long a, unsigned long b)\n    auto c3 = add(1ul, 2ul);\n}\n```\n# Policy\n\n上面谈到的Traits是关于类型的封装。\n\n而Policy——策略，是关于行为的封装。比如把加法、减法、乘法、除法都封装成一样的行为，就是Policy。再如，日志系统，有的要写到文件中，有的则要写到服务器中，或者直接控制台输出。\n## 封装AddPolicy\n\n比如要把加法封装为Policy，就是要封装上面的`R add(T a, T b)`：\n> AddPolicy即是一个具体的OperatePolicy，那么，OperatePolicy都将有一个calculate方法。\n\n以加法Policy来说，它的特征就是：\n1. 有两个操作数a、b，类型为T。\n2. 有一个计算的指令，指令名可以都叫做calculate，作为函数名。函数名中则是具体的计算行为，加法Policy中则是`a + b`。\n3. 会返回一个值，类型为R。\n\n> 我们只是利用类的外壳，实际有用的是静态方法。\n> 再利用Traits，通过具体T指明R将返回什么。`R = AddTraits<T>::R`\n\n```cpp\n// T是操作数类型，R是返回类型\ntemplate <typename T, typename R = AddTraits<T>::R>\nclass AddPolicy\n{\npublic:\n    static R calculate(T a, T b)\n    {\n        return static_cast<R>(a) + static_cast<R>(b);\n    }\n};\n```\n## 封装MultiplyPolicy\n\n现在我们要编写第二个具体的Policy，即乘法Policy。因为加法和乘法最后都表现出同样的特质，所以乘法Traits可以复用AddTraits。\n```cpp\ntemplate <typename T, typename R = AddTraits<T>::R>\nclass MultiplyPolicy\n{\npublic:\n    static R calculate(T a, T b)\n    {\n        return static_cast<R>(a) * static_cast<R>(b);\n    }\n};\n```\n# 封装 Traits 和 Policy 为 Operate 函数模板\n\n设计一个函数模板，把数据特性 Traits 和行为抽象 Policy 封装。\n\n其中，T 是原始数据类型，U 是一个 Policy，如 AddPolicy。\n## 封装AddOperate\n\n首先可以尝试封装一个具体的 Policy 如 AddPolicy 。\n这个函数返回 AddPolicy 的 calculate 的计算结果，即返回数据类型是`AddTraits<T>::R`。\n```cpp\n// T是操作数类型，U是Policy\ntemplate<typename T, typename U = AddPolicy<T> >\ntypename AddTraits<T>::R AddOperate(T a, T b)\n{\n    return U::calculate(a, b);\n}\n```\n\n```cpp\nint main()\n{\n    std::cout << AddOperate(1, 2) << std::endl; // 3\n}\n```\n### 优化\n\nAddOperate 函数的返回类型书写太冗长，考虑可以用个简化的别名。可以利用`AddTraits<T>::R`在 AddPolicy 中存在、使用这个特点，则可以在 AddPolicy 中另起模板参数R的别名为RTNTYPE（除了R，其他名字都行）。\n好处在于：类中另起的 RTNTYPE 和模板参数的 R 相比，前者可以在类外部直接使用，而后者不可以。\n```cpp\n// T是操作数类型，R是返回类型\ntemplate <typename T, typename R = AddTraits<T>::R>\nclass AddPolicy\n{\npublic:\n    using RTNTYPE = R;\n    static R calculate(T a, T b)\n    {\n        return static_cast<R>(a) + static_cast<R>(b);\n    }\n};\n```\n\n> T为操作数类型；U为Policy；R为返回值类型。\n\n```cpp\ntemplate <typename T, U = AddPolicy<T> >\nU::RTNTYPE AddOperate(T a, T b)\n{\n    return U::calculate(a, b);\n}\n```\n\n```cpp\nint main()\n{\n    unsigned short a = 7u;\n    unsigned short b = 3u;\n    auto c = AddOperate(a, b);\n    std::cout << c << std::endl;\n}\n```\n## 封装抽象Operate\n\n抽象的Operate是真正的可以传入任意的Policy参数的。\n\n```cpp\ntemplate <typename U, typename T>\nU::RTNTYPE Operate(T a, T b)\n{\n    return U::calculate(a, b);\n}\n```\n但是，如果这样写的话，得给AddPolicy后面加具体的操作数类型才能编译通过。\n```cpp\nint main()\n{\n    unsigned short a = 3u;\n    unsigned short b = 7u;\n    auto c = Operate<AddPolicy<decltype(a)> >(a, b);\n    std::cout << c << std::endl;\n}\n```\n有没有什么办法能不传入`decltype(a)`就能进行的呢？那样的话，就可以非常地简洁：`Operate<AddPolicy>(a, b)`。\n方法就是把Operate中的U参数指明为类模板。\n```cpp\ntemplate <typename T, template<typename, typename> class Policy>\nPolicy<T, Policy::RTNTYPE>::RTNTYPE Operate(T a, T b)\n{\n    return Policy<T, Policy::RTNTYPE>::calculate(a, b);\n}\n```\n但是以上代码肯定编译不过，因为出现了无限递归解析：Policy不是一个具体类，因此无法通过Policy指明具体RTNTYPE，于是就得加第三个模板参数Traits。\n\n> 注意，`Policy<T, typename Traits::R>`中的`Traits::R`前面应该加typename。以明确区分传入的是类型而不是常量值（因为模板参数可以传入常量值）\n\n```cpp\ntemplate <template<typename, typename> class Policy, typename Traits, typename T>\nTraits::R Operate(T a, T b)\n{\n    return Policy<T, typename Traits::R>::calculate(a, b);\n}\n```\n\n```cpp\nint main()\n{\n    unsigned short a = 3u;\n    unsigned short b = 7u;\n    auto c = Operate<AddPolicy, AddTraits<decltype(a)>>(a, b);\n    std::cout << c << std::endl;\n}\n```\n\n这样的话，还是得在AddTraits后加一个`decltype(a)`才行，能不能彻底消灭呢？类比指明Policy是个类模板的经验，把Traits也指明为一个类模板，即可：\n```cpp\ntemplate <template<typename, typename> class Policy,\n            template<typename> class Traits,\n            typename T>\nTraits<T>::R Operate(T a, T b)\n{\n    return Policy<T, typename Traits<T>::R>::calculate(a, b);\n}\n```\n\n```cpp\nint main()\n{\n    unsigned short a = 3u;\n    unsigned short b = 7u;\n    auto c = Operate<AddPolicy, AddTraits>(a, b);\n    std::cout << c << std::endl;                  // 10\n    c = Operate<MultiplyPolicy, AddTraits>(a, b);\n    std::cout << c << std::endl;                  // 21\n}\n```\n如此，终于把Operate的调用变得简洁、美观了！这个调用形式也体现了Policy和Traits合二为一、相辅相成的美感。\n# 最终代码\n\n```cpp\n#include<iostream>\n\ntemplate <typename T>\nclass AddTraits;\n\ntemplate < >\nclass AddTraits<unsigned short>\n{\npublic:\n    typedef unsigned int R;\n};\n\ntemplate < >\nclass AddTraits<unsigned int>\n{\npublic:\n    typedef unsigned long long R;\n};\n\ntemplate < >\nclass AddTraits<unsigned long>\n{\npublic:\n    typedef unsigned long long R;\n};\n\ntemplate <typename T, typename R = typename AddTraits<T>::R>\nclass AddPolicy\n{\npublic:\n    using RTNTYPE = R;\n    static R calculate(T a, T b)\n    {\n        return static_cast<R>(a) + static_cast<R>(b);\n    }\n};\n\ntemplate <typename T, typename R = typename AddTraits<T>::R>\nclass MultiplyPolicy\n{\npublic:\n    using RTNTYPE = R;\n    static R calculate(T a, T b)\n    {\n        return static_cast<R>(a) * static_cast<R>(b);\n    }\n};\n\ntemplate <template<typename, typename> class Policy, template<typename> class Traits, typename T>\ntypename Traits<T>::R Operate(T a, T b)\n{\n    return Policy<T, typename Traits<T>::R>::calculate(a, b);\n}\n\nint main()\n{\n    unsigned short a = 3u;\n    unsigned short b = 7u;\n    auto c = Operate<AddPolicy, AddTraits>(a, b);\n    std::cout << c << std::endl;\n    c = Operate<MultiplyPolicy, AddTraits>(a, b);\n    std::cout << c << std::endl;\n}\n```\n# 更加简化\n升级AddTraits为`OperationTraits`\n```cpp\n#include<iostream>\n\ntemplate <typename T>\nclass OperationTraits;\n\ntemplate < >\nclass OperationTraits<unsigned short>\n{\npublic:\n    using R = unsigned int;\n};\n\ntemplate < >\nclass OperationTraits<unsigned int>\n{\npublic:\n    using R = unsigned long;\n};\n\ntemplate < >\nclass OperationTraits<unsigned long>\n{\npublic:\n    using R = unsigned long long;\n};\n\ntemplate <typename T>\nclass AddPolicy\n{\npublic:\n    using RTNTYPE = typename OperationTraits<T>::R;\n    static RTNTYPE calculate(T a, T b)\n    {\n        return static_cast<RTNTYPE>(a) + static_cast<RTNTYPE>(b);\n    }\n};\n\ntemplate <typename T>\nclass MultiplyPolicy\n{\npublic:\n    using RTNTYPE = typename OperationTraits<T>::R;\n    static RTNTYPE calculate(T a, T b)\n    {\n        return static_cast<RTNTYPE>(a) * static_cast<RTNTYPE>(b);\n    }\n};\n\ntemplate <template<typename> class Policy, typename T>\ntypename Policy<T>::RTNTYPE Operate(T a, T b)\n{\n    return Policy<T>::calculate(a, b);\n}\n\nint main()\n{\n    unsigned short a = 3u;\n    unsigned short b = 7u;\n    auto c = Operate<AddPolicy>(a, b);\n    std::cout << c << std::endl;\n    c = Operate<MultiplyPolicy>(a, b);\n    std::cout << c << std::endl;\n}\n```","categories":["Cpp","模板"]},{"title":"Cpp_string仿写","url":"/Cpp/Cpp_string仿写/","content":"# 内容\n\n1. 分析string的设计、实现\n2. 由at方法引出的`C++`异常机制（有单独详细的文章）\n3. 由字符串对象的比较引出的`<compare>`库、**比较机制（三路比较）**\n4. `cout`输出流机制，以及引出的友元\n5. `cin`输入流机制\n6. 引入**右值引用**拷贝、赋值\n# String的历史\n在`C++`手册中的`<string>`header中，Class instantiations（类实例）有：string、u16string、u32string、wstring（宽字符）。\nstring 是 ANSI 规范的普通字符。\nwstring（宽字符）是 Unicode 字符集，开发中推荐使用。\n# String方法\n1. `length()`：返回字符串有效字符长度，即不包括`\\0`。\n2. `size()`：也是返回有效字符长度。与`length()`等价。\n    1. 但在 vector 中，二者有区别。\n    2. Cpp字符串的长度函数是以上两个，调用形式是：`str.size() str.length()`。而C语言的`<cstring>`中的调用形式是`strlen(str)`\n# 仿写成员方法\n\n## 基本思想1：体现面向对象中封装的特性：构造\n## 基本思想2：RAII\nRAII 全称 Resource Acquisition is Initialization. 这是`C++`的设计哲学。\n意为：`C++`的对象在创建或构造时意味着初始化的开始，比如`char * _str`成员在string构造时自动地指向一块新申请的区域。那么，相对应的过程是析构就意味着要释放资源。这个过程就是推荐的`C++`对象的自然设计、自然行为。\n而Java的设计理念是类启动时并没有进行初始化，还要进行`init()`。\n### 常量字符串构造\n`std::string str(\"Hello\")`\n```cpp\nclass MyString\n{\npublic:\n    MyString(const char * str)\n    {\n        if(!str) return;\n        size_t len = strlen(str);\n        _str = new char[len + 1];\n        strcpy(_str, str);\n    }\n\n    const char * c_str(void) const\n    {\n        return _str;\n    }\nprivate:\n    char * _str{ nullptr };\n}\n```\n### 拷贝构造\n```cpp\nclass MyString\n{\npublic:\n    MyString(MyString const & str)\n    {\n        if(!str._str) return;\n        size_t len = strlen(str._str);\n        _str = new char[len + 1];\n        strcpy(_str, str._str);\n    }\n}\n```\n## 赋值重载\n\n把旧的内容清空，赋予新的内容。\n```cpp\nclass MyString\n{\npublic:\n    MyString& operator = (const char * str)\n    {\n        if(_str)\n        {\n            delete[] _str;\n            _str = nullptr;\n        }\n        if(str != nullptr)\n        {\n            size_t len = strlen(str);\n            _str = new char[len + 1];\n            strcpy(_str, str);\n        }\n        return *this;\n    }\n    MyString& operator = (MyString const & str)\n    {\n        if(&str == this) return *this;\n        if(_str)\n        {\n            delete[] _str;\n            _str = nullptr;\n        }\n        if(str._str != nullptr)\n        {\n            size_t len = strlen(str._str);\n            _str = new char[len + 1];\n            strcpy(_str, str._str);\n        }\n        return *this;\n    }\n}\n```\n## `+=`\n两种情况：\n1. 类本身是空的，则直接new，复制\n2. 类有东西，则想办法搞合适的空间，追加\n    1. 可能要扩容原空间\n\n```cpp\nclass MyString\n{\npublic:\n    MyString& operator += (const char * str)\n    {\n        // 要追加的str为空 退出\n        if(!str) return *this;\n        \n        size_t oldlen = strlen(_str);\n        size_t newlen = strlen(str);\n        // 要追加的str内容为空串 退出\n        if(newlen == 0) return *this;\n\n        // 重新分配更大的空间\n        // 需要先备份到newstr临时空间\n        char * newstr = new char[oldlen + newlen + 1];\n        strcpy(newstr, _str);\n        strcat(newstr, str);\n        //如果本身串不为空 则需要销毁旧空间\n        if(_str != nullptr)\n        {\n            delete[] _str;\n            _str = nullptr;\n        }\n        _str = newstr;\n        return *this;\n    }\n    MyString& operator += (MyString const & str)\n    {\n        //\n    }\n}\n```\n## 析构\n\n```cpp\n~MyString()\n{\n    if (_str)\n    {\n        delete[] _str;\n        _str = nullptr;\n    }\n}\n```\n## Boolean Operator\n\n为了便于运算`if(str)`这类语句。`C++11`版本允许有bool运算符的重载。\n\nbool运算符的重载的特点：\n1. 因为布尔运算符的返回值必须为Boolean，锁定了返回值类型，所以可以省略不写。\n2. 和小括号运算符不一样，小括号运算符可以返回任何值类型，但bool运算符必须返回boolean类型。\n```cpp\nclass MyString\n{\npublic:\n    // 不用写返回值，默认就一定是bool类型\n    operator bool() const\n    {\n        return _str;\n    }\n}\n```\n## at（抛异常，检查边界）\n\n有两种：\n1. at位置的字符不能修改\n2. at位置的字符可以修改\n\n1. 可能会out of range。\n2. 返回的都是引用类型，引用不能为空，所以不能通过返回值是否为空来判断是否错误了，所以得用异常机制。\n```cpp\n#include<exception>\nclass OutOfRange : public std::exception\n{\npublic:\n    OutOfRange() : std::exception{\"MyString: out of range!\"}\n    {\n    }\n}\nclass MyString\n{\npublic:\n    char & at(const size_t off)\n    {\n        size_t len = strlen(_str);\n        if(off > strlen - 1)\n            throw OutOfRange{};\n        return _str[off];\n    }\n    char const & at(const size_t off) const\n    {\n        size_t len = strlen(_str);\n        if(off > strlen - 1)\n            throw OutOfRange{};\n        return _str[off];\n    }\n}\nint main()\n{\n    if(str)\n    {\n        try\n        {\n            std::cout << str.at(11) << std::endl;\n        }\n        catch (const std::exception &e)\n        {\n            std::cout << e.what() << std::endl;\n        }\n    }\n}\n```\n## `[]`（不抛异常，不检查边界）\n\n与at函数的不同在于，`[]`是不抛出异常的，因此不检查边界。如果越界，则行为未定义。\n```cpp\nclass MyString\n{\npublic:\n    char& operator[](const size_t off) noexcept\n    {\n        return _str[off];\n    }\n    char const & operator[](const size_t off) const noexcept\n    {\n        return _str[off];\n    }\n}\n```\n## `<=>`三路比较运算符\n\n`C++20`标准中，有`<compare>`库。\n1. `strong_ordering`\n    1. less\n    2. greater\n    3. equal：相等\n    4. equivalent：等价\n2. `weak_ordering`\n    1. less\n    2. greater\n    3. equivalent：等价，或者说模糊的相等\n3. `partial_ordering`\n    1. less\n    2. greater\n    3. equivalent\n    4. unordered\n\n`strong_ordering`测试如下\n```cpp\n#include<compare>\nint main()\n{\n    int a = 3;\n    int b = 4;\n    auto c = a <=> b;//c的类型：std::strong_ordering\n    if(c < 0)\n        std::cout << \"less\" << std::endl;\n    else if(c > 0)\n        std::cout << \"greater\" << std::endl;\n    else if(c == 0)\n        std::cout << \"equal\" << std::endl;\n    return 0;\n}\n```\n\n`partial_ordering`测试如下，主要测试`unordered`的情况。用一个NaN浮点数比较时，就会出现。\n>NaN定义于limits库\n\n```cpp\n#include<limits>\nint main()\n{\n    double a = 4.0;\n    double b = std::numeric_limits<double>::quiet_NaN(); //得出double类型的NaN\n    auto c = a <=> b; //c的类型：std::partial_ordering\n    if(c < 0)\n        std::cout << \"less\" << std::endl;\n    else if(c > 0)\n        std::cout << \"greater\" << std::endl;\n    else if(c == 0)\n        std::cout << \"equivalent\" << std::endl;\n    else\n        std::cout << \"unordered\" << std::endl;\n    return 0;\n}\n```\n\n对于字符串来说，我们返回一个strong或weak都可以。strong要求肯定更严格一些，比如区分字母大小写等等，而weak要求则松一些，比如不管大小写，都算相等。\n\n类中怎么使用`<=>`\n1. default的`<=>`是按照类中的成员顺序依次比较。\n2. 如果不是按照默认顺序依次比较，则需要自定义函数逻辑\n\n以下是默认的例子\n```cpp\nclass Point\n{\npublic:\n    Point(int x, int y) : _x{ x }, _y{ y }\n    {\n    }\n    std::strong_ordering operator <=> (Point const & pt) const = default;\n    \nprivate:\n    int _x;\n    int _y;\n};\nint main()\n{\n    Point pt{1, 2}, pt2{1, 2};\n    if(pt == pt2)\n    {\n        std::cout << \"equal\" << std::endl;\n    }\n}\n```\n### string中的实现\n以下回到MyString中的`<=>`比较运算符。我们定义其返回`weak_ordering`。即不管大小写混合与否，都是等价关系。总的来说，我们在大小写不敏感的情况下返回`weak_ordering`。\n\n1. 统一大小写，再比对，一样则返回等价，不一样则返回大、小\n\n```cpp\n#include<compare>\nclass MyString\n{\npublic:\n    std::weak_ordering operator <=> (MyString const & other) const noexcept\n    {\n        // 全部转换为大写或小写。可以使用cctype中的toupper、tolower处理\n        /*for\n        if(!islower())\n        {\n            tolower()\n        }*/\n        int c = strcmp(_str, other.c_str());\n        if(c == 0)\n            return std::weak_ordering::equivalent;\n        else if(c > 0)\n            return std::weak_ordering::greater;\n        else\n            return std::weak_ordering::less;\n    }\n}\n```\n类中只要定义了`<=>`这个运算符（参数是一个const 同类引用），那么，外部的比较运算符就转向运行该函数进行比较。\n```cpp\nint main()\n{\n    MyString str{ \"Hello\" };\n    MyString str2{ \"Hello\" };\n    if(str == str2)\n        std::cout << \"equal\" << std::endl;\n    else if(str < str2)\n        std::cout << \"less\" << std::endl;\n    else\n        std::cout << \"greater\" << std::endl;\n}\n```\n## cout识别本类（全局重载）\n\ncout 是 ostream 的实例。如果我们要做到让 cout 认识自定义类 MyString 的话，就需要重载 cout 的`<<`运算符。注意，与 MyString 的成员方法没关系，因为cout的形式是：`std::cout << str`。\n```cpp\nstd::ostream& operator <<(std::ostream &os, MyString const & str)\n{\n    os << str.c_str();\n    return os;\n}\n```\n## 友元\n\n假如类外部需要访问类内私有成员，则需要再类内任意位置授权该类外函数。即在函数声明形式的语句之前，加friend。\n这是遵循封装性的程序设计下的一种妥协的通路。在特殊情况下，可以破坏封装性。\n```cpp\nclass MyString\n{\n    friend std::ostream& operator << (std::ostream& os, MyString const& str);\n}\nstd::ostream& operator <<(std::ostream &os, MyString const & str)\n{\n    // private\n    os << str._str;\n    return os;\n}\n```\n## cin\ncin 的位置在`<istream>`中。内部有输入缓冲区。以回车标志着输入完毕，空格标志着数据的间隔。\n```cpp\n#include <iostream>\nint main()\n{\n    std::string str;\n    std::string str2;\n    std::cin >> str;\n    std::cin >> str2;\n}\n// 输入：12 23 34 回车\n// str: 12\n// str2:23\n```\n### cin的方法\n![](../../images/Cpp_20240410_string仿写_compare库_引入右值引用/image-20240716053343096.png)\n`cin.get()`方法不带参数表示从缓冲区析出一个字符，并且不再返回缓冲区。\n如果放在`cin >> x`的后面，前面`>>`已经把有效数据拿走，则此时恰好可以在间隔符（空格或回车）的位置上get，因此不会影响正常数据。\n```cpp\n#include <iostream>\nint nums[100];\n// 向nums输入数据，以空格为间隔，以回车为结束标志\nint main()\n{\n    int i = 0;\n    while (std::cin >> nums[i++])\n    {\n        if (std::cin.get() == '\\n')\n            break;    \n    }\n    for (int j = 0; j < i; ++j)\n        std::cout << nums[j] << std::endl;\n}\n// 输入：1 2 3 4 5 6 7 回车\n// 输出：1 2 3 4 5 6 7\n```\n### cin重载（全局）\n首先调用cin的`>>`后用户要先输入一些东西，保存到了缓冲区。\n需要用到`cin.get(char* s, streamsize n)`表示从缓冲区析出 n 个字符大小，写入 s 指向的区域中。\n```cpp\nstd::istream& operator >>(std::istream& is, MyString const& str)\n{\n    char * in_c_str = new char[1024];\n    memset(in_c_str, 0, 1024); // <cstring>\n    \n    is.get(in_c_str, 1024);    // 1. 从缓冲区析出1024个字符，写入到in_c_str中\n    \n    // 要追加的str为空 退出\n    if(!&str) return *this;\n    \n    size_t inlen = strlen(in_c_str);\n    // 要追加的str内容为空串 退出\n    if(inlen == 0) return *this;\n    \n    size_t oldlen = strlen(_str);\n    // 重新分配更大的空间\n    // 需要先备份到newstr临时空间\n    char * newstr = new char[oldlen + newlen + 1];\n    strcpy(newstr, _str);\n    strcat(newstr, in_c_str);\n    //如果本身串不为空 则需要销毁旧空间\n    if(_str != nullptr)\n    {\n        delete[] _str;\n        _str = nullptr;\n    }\n    _str = newstr;\n\n    return is;               // 2. 返回is\n}\n```\n## 测试\n```cpp\nint main()\n{\n    MyString str{\"Hello\"};\n    std::cout << str.c_str() << std::endl;\n    MyString str2{str};\n    // MyString str2 = str; 等效于MyString str2{str}; 都是走拷贝构造\n    std::cout << str2.c_str() << std::endl;\n    str = \"Test =\";\n    std::cout << str.c_str() << std::endl;\n    if(str)\n    {\n        std::cout << str.c_str() << std::endl;\n    }\n    str += \"Test +=\";\n    std::cout << str.c_str() << std::endl;\n\n    std::cout << str.at(5) << std::endl;\n}\n```\n# 问题代码\n\n![../../image-20211121150816082](../../images/String%E4%BB%BF%E5%86%99/image-20211121150816082.png)\n\n问题：\n1. 在`return String(newch)`后，不能delete该函数体中的缓冲区newch，造成内存泄漏。\n2. 系统崩溃。因为返回的将亡值`String(newch)`在`s3 = s1 + s2`语句结束前浅拷贝，把有值的str给了s3的str。语句结束后自动析构，释放了堆区空间`(String(newch)).str`，虽然str置空了，但s3的str是脏值。\n    1. 首先，由于堆区释放了，s3用不了了\n    2. 其次更严重的是，main函数结束时由于s3的str为脏值，不为空，因此会再次`delete[]str`，导致系统崩溃。\n# 引入右值赋值函数\n\n![../../image-20211121153216410](../../images/String%E4%BB%BF%E5%86%99/image-20211121153216410.png)\n\n此时，等号赋值调用右值移动函数，将临时构造的s1+s2对象的str的拥有权转移给了s3。\n# 将亡值\n\n某一句表达式产生了一个不具有名字的实体。\n生存期只存在某一句表达式中。\n此实体即为将亡值。\n# 右值引用\n\n## 1\n```c\nString fun()\n{\n    String s2 = (\"yhping\");\n    return s2;\n}\nint main()\n{\n    String s1;\n    s1 = fun();\n    return 0;\n}\n/*\n此程序产生3个对象。\n首先main函数产生s1；\t\t\t\t\t1\n其次，fun函数栈帧产生s2对象。\t\t\t2\n然后，拷贝s2构造一个无名对象到main函数栈帧。 3\t\ns1再调用等号赋值，即无名对象的值赋给s1。\n*/\n```\n## 2\n```c\nString & fun()\n{\n    String s2 = (\"yhping\");\n    return s2;\n}\nint main()\n{\n    String s1;\n    s1 = fun();\n    cout << s1 << endl;\n    return 0;\n}\n/*\n不能这样做。\n因为如果要以引用返回，则s1会从析构后的s2上取值，则会产生随机值\n*/\n```\n## 3\n右值引用只能引用字面常量或**无名**量。左值引用不能引用无名量。\n```c\nint main()\n{\n    String s1;\n    \n    String & sx = s1;\n    String && sy = sx;//error\n    String && sz = String(\"hello\");//ok\n}\n```\n\n```c\nString && fun()//error，因为s2有名字，不能以右值引用方式返回。\n{\n\tString s2(\"yhping\");\n\treturn s2;\n}\n```\n\n```c\nint main()\n{\n    int && a = 10;\n    int && b = a;//依然不可以，虽然a是一个右值引用，但是a有了名字，所以b不能右值引用a。\n}\n```\n## 4\n```c++\nclass String\n{\n\npublic:\n    String(String && s)\n    {\n        cout << \"move copy construct :\" << this << endl;\n        str = s.str;\n        s.str = NULL;\n    }\n    String& operator=(String && s)\n    {\n        \n    }\n};\n```\n\n# 写时拷贝的String\n```c\nint main()\n{\n    String s1(\"xcgong\");\n    String s2(s1);\n    String s3(s2);\n    String s4(s3);\n}\n/*\n有两种情况：\n如果是浅拷贝，则会出现重复析构；\n如果是深拷贝，则会出现多次重复的堆空间。\n*/\n```\n写时拷贝的String是GCC里String的方案。","categories":["Cpp","右值引用"]},{"title":"Cpp_三路比较_compare库","url":"/Cpp/Cpp_三路比较_compare库/","content":"# `<=>`三路比较运算符\n\n`C++20`标准中，有`<compare>`库。\n1. `strong_ordering`\n    1. less\n    2. greater\n    3. equal：相等\n    4. equivalent：等价\n2. `weak_ordering`\n    1. less\n    2. greater\n    3. equivalent：等价，或者说模糊的相等\n3. `partial_ordering`\n    1. less\n    2. greater\n    3. equivalent\n    4. unordered\n# strong_ordering\n```cpp\n#include<compare>\nint main()\n{\n    int a = 3;\n    int b = 4;\n    auto c = a <=> b; //c的类型：std::strong_ordering\n    if(c < 0)\n        std::cout << \"less\" << std::endl;\n    else if(c > 0)\n        std::cout << \"greater\" << std::endl;\n    else if(c == 0)\n        std::cout << \"equal\" << std::endl;\n    return 0;\n}\n```\n# partial_ordering\n`partial_ordering`测试如下，主要测试`unordered`的情况。用一个NaN浮点数比较时，就会出现。\n>NaN定义于limits库\n\n```cpp\n#include<limits>\nint main()\n{\n    double a = 4.0;\n    double b = std::numeric_limits<double>::quiet_NaN(); //得出double类型的NaN\n    auto c = a <=> b; //c的类型：std::partial_ordering\n    if(c < 0)\n        std::cout << \"less\" << std::endl;\n    else if(c > 0)\n        std::cout << \"greater\" << std::endl;\n    else if(c == 0)\n        std::cout << \"equivalent\" << std::endl;\n    else\n        std::cout << \"unordered\" << std::endl;\n    return 0;\n}\n```\n# 类中怎么使用`<=>`\n\n对于字符串来说，我们返回一个strong或weak都可以。\nstrong要求更严格一些，比如区分字母大小写等等，\n而weak要求则松一些，比如不管大小写，都算相等。\n\n1. `<=>`的默认行为是**按照类中的成员顺序依次比较**。\n2. 如果不是按照默认顺序依次比较，则需要自定义函数逻辑\n\n以下是默认的例子\n```cpp\nclass Point\n{\npublic:\n    Point(int x, int y) : _x{ x }, _y{ y }\n    {\n    }\n    std::strong_ordering operator <=> (Point const & pt) const = default;\n    \nprivate:\n    int _x;\n    int _y;\n};\nint main()\n{\n    Point pt{1, 2}, pt2{1, 2};\n    if(pt == pt2)\n    {\n        std::cout << \"equal\" << std::endl;\n    }\n}\n```\n## 实际的例子：见《Cpp_string仿写》","categories":["Cpp"]},{"title":"Cpp_异常机制","url":"/Cpp/Cpp_异常机制/","content":"# `C++`异常处理机制\n\n```cpp\nint bar(int a, int b)\n{\n    return a / b;\n}\nint main()\n{\n    int result = 0;\n    result = bar(10, 0);\n    return 0;\n}\n```\n以上会产生除0异常：\n![](../../images/Cpp_20240410_异常机制/image-20240716044013847.png)\n\n如果是Release的程序，不处理异常，就会造成闪退。\n## throw\nthrow可以是任何东西，一个对象，一个指针，一个值。\n只要throw了，那么程序就会中断、跳转，如果有try-catch就走catch，如果没有则进行下一条语句。\n```cpp\nint bar(int a, int b)\n{\n    if(b == 0)\n    {\n        throw e;\n    }\n}\n```\n## try-catch\n类似于switch-case，但是case值不限制类型。可以通过`catch(...)`代表default。\n```cpp\nint main()\n{\n    int result = 0;\n    try\n    {\n        result = bar(10, 0);\n    }\n    catch (const double& e)\n    {\n        std::cout << e << std::endl;\n    }\n    catch (const int& e)\n    {\n        std::cout << e << std::endl;\n    }\n    catch (...)\n    {\n        std::cout << \"Unhandled Exception!\" << std::endl;\n    }\n    std::cout << result << std::endl;\n    return 0;\n}\n```\n# noexcept关键字\n\n声明该函数不抛出异常。\n```cpp\nint bar(int a, int b) noexcept;\n```\n但是一旦实际运行时抛出了异常，程序就会直接挂掉。\n![](../../images/Cpp_20240410_异常机制/image-20240716045247884.png)\n# 异常库`<stdexcept>`\n\n该库下，有两类errors：\n1. Logic Errors\n2. Runtime Errors\n![](../../images/Cpp_20240410_异常机制/image-20240716045704242.png)\n## `std::exception`\n基本上所有的exception类都继承于`std::exception`。如`out_of_range`：\n![](../../images/Cpp_20240410_异常机制/image-20240716045815882.png)\n`std::exception`可以拿字符串构造，然后用`what()`方法打印这个异常信息。\n```cpp\n#include <exception>\nstd::exception bar_exception{ \"bar exception!\" };\n\nint bar(int a, int b)\n{\n    if(b == 0)\n        throw bar_exception;\n    return a / b;\n}\n```\n\n```cpp\n#include <exception>\nint main()\n{\n    int result = 0;\n    try\n    {\n        result = bar(10, 0);\n    }\n    catch (std::exception const& e)\n    {\n        std::cout << e.what() << std::endl;\n    }\n    catch (...)\n    {\n        std::cout << \"Unhandled Exception!\" << std::endl;\n    }\n    std::cout << result << std::endl;\n    return 0;\n}\n```\n## 自定义exception\n```cpp\nclass BarException : public std::exception\n{\npublic:\n    char const* what() const override\n    {\n        return \"bar exception!\";\n    }\n};\n```\n\n```cpp\n#include <exception>\nint bar(int a, int b)\n{\n    if(b == 0)\n        throw BarException{};\n    return a / b;\n}\nint main()\n{\n    int result = 0;\n    try\n    {\n        result = bar(10, 0);\n    }\n    catch (std::exception const& e) // 可以接受bar_exception\n    {\n        std::cout << e.what() << std::endl;\n    }\n    catch (...)\n    {\n        std::cout << \"Unhandled Exception!\" << std::endl;\n    }\n    std::cout << result << std::endl;\n    return 0;\n}\n```\n# 实例\n异常用在什么地方呢？不能通过函数的返回值来判断正确与否的时候。如下：\n## string的at（抛异常，检查边界）\n\n有两种：\n1. at位置的字符不能修改\n2. at位置的字符可以修改\n\n1. 可能会out of range。\n2. 返回的都是引用类型，引用不能为空，所以不能通过返回值是否为空来判断是否错误了，所以得用异常机制。\n```cpp\n#include<exception>\nclass OutOfRange : public std::exception\n{\npublic:\n    OutOfRange() : std::exception{\"MyString: out of range!\"}\n    {\n    }\n}\nclass MyString\n{\npublic:\n    char & at(const size_t off)\n    {\n        size_t len = strlen(_str);\n        if(off > strlen - 1)\n            throw OutOfRange{};\n        return _str[off];\n    }\n    char const & at(const size_t off) const\n    {\n        size_t len = strlen(_str);\n        if(off > strlen - 1)\n            throw OutOfRange{};\n        return _str[off];\n    }\n}\nint main()\n{\n    if(str)\n    {\n        try\n        {\n            std::cout << str.at(11) << std::endl;\n        }\n        catch (const std::exception &e)\n        {\n            std::cout << e.what() << std::endl;\n        }\n    }\n}\n```\n## string的`[]`（不抛异常，不检查边界）\n\n与at函数的不同在于，`[]`是不抛出异常的，因此不检查边界。如果越界，则行为未定义。\n```cpp\nclass MyString\n{\npublic:\n    char& operator[](const size_t off) noexcept\n    {\n        return _str[off];\n    }\n    char const & operator[](const size_t off) const noexcept\n    {\n        return _str[off];\n    }\n}\n```\n# 总结\n\n1. 异常用在什么地方呢？不能通过函数的返回值来判断正确与否的时候。比如返回值是引用，引用没有空值。\n2. 如果函数在内部自己处理了异常，即不会抛出异常，那么最好声明为noexcept。代表别人调用此函数时，别人就不用try-catch了。","categories":["Cpp"]},{"title":"刷题_无重复字符的最长子串","url":"/算法/刷题_无重复字符的最长子串/","content":"# 内容\n\n原题名叫做：[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/ \"https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/\")。给定一个字符串，找出其中不含有重复字符的最长子串的长度。\n```\n示例 1:\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n\n示例 2:\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n示例 3:\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n提示：\n0 <= s.length <= 5 * 10^4\ns 由英文字母、数字、符号和空格组成\n```\n# 分析\n\n要判断\n# 代码\n## 解1_暴力+哈希\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(std::string s) {\n        typedef std::unordered_map<char, int> CharIntMap;\n        CharIntMap charIntMap;\n        int s_len = s.length();\n        int longestLen = 0;\n        for (int i = 0; i < s_len; ++i)\n        {\n            for (int j = i; j < s_len; ++j)\n            {\n                if (charIntMap[s[j]] == 1)\n                {\n                    if (j - i > longestLen)\n                    {\n                        longestLen = j - i;\n                    }\n                    charIntMap.clear();\n                    break;\n                }\n                else\n                {\n                    charIntMap[s[j]] = 1;\n                    if (j - i > longestLen)\n                    {\n                        longestLen = j - i;\n                        // this is wrong. should update longest\n                    }\n                }\n            }\n        }\n        return longestLen;\n    }\n};\n```\n### 坑\n\n如果字符串本来就没有重复的，我们应该也在else中给longest计数，但要注意，应该是`j - i + 1`与longest比较。\n```cpp\n                else\n                {\n                    charIntMap[s[j]] = 1;\n                    if (j - i + 1 > longestLen)\n                    {\n                        ++longestLen;\n                    }\n                }\n```\n\n### 效果\n\n虽然正确。但是效率不是特别高，结果如下：\n```\n987/987 cases passed (654 ms)\nYour runtime beats 5 % of cpp submissions\nYour memory usage beats 5.02 % of cpp submissions (148.9 MB)\n```\n\n### 优化_利用哈希记录的已出现过的字符位置，加速滑动\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(std::string s) {\n        typedef std::unordered_map<char, int> CharIntMap;\n        CharIntMap charIntMap;\n        int s_len = s.length();\n        int longestLen = 0;\n        for (int i = 0; i < s_len; ++i)\n        {\n            int j = i;\n            if (charIntMap[s[j]] == 1)\n            {\n                if (j - i > longestLen)\n                {\n                    longestLen = j - i;\n                }\n                charIntMap.clear();\n                break;\n            }\n            else\n            {\n                charIntMap[s[j]] = 1;\n                if (j - i > longestLen)\n                {\n                    longestLen = j - i;\n                    // this is wrong. should update longest\n                }\n            }\n        }\n        return longestLen;\n    }\n};\n```\n\n## 解2_哈希记录已出现过的字符位置，加速滑动\n\nMap表中的value应该存char的标记\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(std::string s) {\n        typedef std::unordered_map<char, int> CharIntMap;\n        CharIntMap charIntMap;\n        int s_len = s.length();\n        int longestLen = 0;\n        for (int i = 0; i < s_len; ++i)\n        {\n            for (int j = i; j < s_len; ++j)\n            {\n                if (charIntMap[s[j]] == 1)\n                {\n                    if (j - i > longestLen)\n                    {\n                        longestLen = j - i;\n                    }\n                    charIntMap.clear();\n                    break;\n                }\n                else\n                {\n                    charIntMap[s[j]] = 1;\n                    if (j - i > longestLen)\n                    {\n                        longestLen = j - i;\n                        // this is wrong. should update longest\n                    }\n                }\n            }\n        }\n        return longestLen;\n    }\n};\n```\n# 心得\n\n这个题目属于\n\n# 总结\n\n1. ","categories":["算法","刷题"]},{"title":"刷题_反转字符串里的单词","url":"/算法/刷题_反转字符串里的单词/","content":"# 内容\n\n原题名叫做：[反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/ \"https://leetcode.cn/problems/reverse-words-in-a-string/description/\")。不是把每个字符全部反转，而是按词为整体反转。\n```\n输入：s = \"the sky is blue\"\n输出：\"blue is sky the\"\n\n输入：s = \"  hello world  \"\n输出：\"world hello\"\n解释：反转后的字符串中不能存在前导空格和尾随空格。\n\n输入：s = \"a good   example\"\n输出：\"example good a\"\n解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n\n提示：\n1. 1 <= s.length <= 104\n2. s 包含英文大小写字母、数字和空格 ' '\n3. s 中 至少存在一个 单词\n\n进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n```\n# 分析\n\n1. 首先把多余的空格删除\n2. 把整体进行逆序\n3. 按空格划分，逆序每个单词\n# 代码\n\n## 解1_\n\n```cpp\n#include<iostream>\nclass Solution {\npublic:\n    // 返回结尾下标\n    int moveLeft(std::string& s, int idx, int wordLen, int step)\n    {\n        // if(s == nullptr || idx < 0) return;\n        if (step != 0)\n        {\n            int i = 0;\n            while (i < wordLen)\n            {\n                s[idx - step + i] = s[idx + i];\n                ++i;\n            }\n        }\n        return idx - step + wordLen - 1;\n    }\n    std::string removeExtraSpace(std::string& s)\n    {\n        int cur = s.length() - 1;\n        while (s[cur] != '\\0' && s[cur] == ' ')\n        {\n            --cur;\n        }\n        int lastSpace = cur;\n        int validEndIdx = cur;\n        while (cur >= 0)\n        {\n            while (cur >= 0 && s[cur] != '\\0' && s[cur] != ' ')\n            {\n                --cur;\n            }\n            lastSpace = cur;\n            ++cur;\n            while (lastSpace >= 0 && s[lastSpace] != '\\0' && s[lastSpace] == ' ')\n            {\n                --lastSpace;\n            }\n            if (lastSpace != -1)\n                ++lastSpace;\n            validEndIdx = moveLeft(s, cur, validEndIdx - cur + 1, cur - lastSpace - 1);\n            cur = lastSpace - 1;\n        }\n        s.resize(validEndIdx + 1);\n        return s;\n    }\n    void reverseWord(char* cp, int len)\n    {\n        for (int i = 0; i < len / 2; ++i)\n        {\n            char tmp = cp[i];\n            cp[i] = cp[len - 1 - i];\n            cp[len - 1 - i] = tmp;\n        }\n\n    }\n    std::string reverseWords(std::string s)\n    {\n        removeExtraSpace(s);\n        reverseWord((char *)s.c_str(), s.length());\n        const char* ccp = s.c_str();\n        char* cp = (char *)ccp;\n        int len = 0;\n        // 这里如果直接给ccp+1会越过\\0导致越界，leetcode报错heap-buffer-overflow通不过\n        while (*ccp != '\\0')\n        {\n            while (*ccp != '\\0' && *ccp != ' ')\n            {\n                ++len;\n                ++ccp;\n            }\n            reverseWord(cp, len);\n            len = 0;\n            if(*ccp != '\\0')\n            {\n                ++ccp;\n                cp = (char*)ccp;\n            }\n        }\n        return s;\n    }\n};\nint main()\n{\n    Solution sol = Solution();\n    std::string str(\"  345  1 2 89    \");\n    std::string res = sol.reverseWords(str);\n    std::cout << res << std::endl;\n}\n```\n测试结果：`345 1 2 89`\nC语言版\n```c\nint moveLeft(char* s, int idx, int wordLen, int step)\n{\n    if (step != 0)\n    {\n        int i = 0;\n        while (i < wordLen)\n        {\n            s[idx - step + i] = s[idx + i];\n            ++i;\n        }\n    }\n    return idx - step + wordLen - 1;\n}\nint removeExtraSpace(char* s, int len)\n{\n    if (len <= 0) return 0;\n    int cur = len - 1;\n    while (cur >= 0 && s[cur] != '\\0' && s[cur] == ' ')\n    {\n        --cur;\n    }\n    int lastSpace = cur;\n    int validEndIdx = cur;\n    while (cur >= 0)\n    {\n        while (cur >= 0 && s[cur] != '\\0' && s[cur] != ' ')\n        {\n            --cur;\n        }\n        lastSpace = cur;\n        ++cur;\n        while (lastSpace >= 0 && s[lastSpace] != '\\0' && s[lastSpace] == ' ')\n        {\n            --lastSpace;\n        }\n        if (lastSpace != -1)\n            ++lastSpace;\n        validEndIdx = moveLeft(s, cur, validEndIdx - cur + 1, cur - lastSpace - 1);\n        cur = lastSpace - 1;\n    }\n    s[validEndIdx + 1] = '\\0';\n    return validEndIdx + 1;\n}\nvoid reverseWord(char* cp, int len)\n{\n    for (int i = 0; i < len / 2; ++i)\n    {\n        char tmp = cp[i];\n        cp[i] = cp[len - 1 - i];\n        cp[len - 1 - i] = tmp;\n    }\n}\nchar* reverseWords(char* s)\n{\n    const char* ccp = s;\n    int slen = 0;\n    while (*ccp++ != '\\0')\n    {\n        ++slen;\n    }\n    int newlen = removeExtraSpace(s, slen);\n    reverseWord(s, newlen);\n    ccp = s;\n    char* cp = s;\n    int len = 0;\n    while (*ccp != '\\0')\n    {\n\n        while (*ccp != '\\0' && *ccp != ' ')\n        {\n            ++len;\n            ++ccp;\n        }\n        reverseWord(cp, len);\n        len = 0;\n        // 这里如果直接给ccp+1会越过\\0导致越界，leetcode报错heap-buffer-overflow通不过\n        if (*ccp != '\\0')\n        {\n            ++ccp;   // 最后一次会越界\n            cp = (char*)ccp;\n        }\n    }\n    return s;\n}\n```\n### 优化消除空格函数\n\n```c\n// 返回新串长度\nint removeExtraSpace(char* s, int len)\n{\n    int i = 0;\n    int cur = 0;\n    while (i < len)\n    {\n        while (i < len && s[i] == ' ')\n        {\n            ++i;\n        }\n        // s[i] != ' ', = char\n        while (i < len && s[i] != ' ')\n        {\n            s[cur++] = s[i++];\n        }\n        if (i >= len)\n        {\n            if (i > cur)\n            {\n                s[cur] = '\\0';\n            }\n            // 一定要break\n            break;\n        }\n        // s[i] == ' ' || s[i] == '\\0'\n        s[cur++] = s[i++];\n    }\n    // 坑\n    if (s[cur - 1] == ' ')\n    {\n        --cur;\n        s[cur] = '\\0';\n    }\n    return cur;\n}\n```\n### 坑\n\n# 心得\n\n这个题目属于\n\n# 总结\n\n1. ","categories":["算法","刷题"]},{"title":"刷题_另一个树的子树","url":"/算法/刷题_另一个树的子树/","content":"# 内容\n\n原题名叫做：[另一个树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)。总的来说就是找一个树T1中有没有和T2完全结构一样的子树。\n# 分析\n\n要判断树中是否包含某个具体的结构，可以使用遍历序列来判断。\n但是要注意：示例2就是一种容易忽略的情况。如果仅仅依靠非空节点的遍历序列去判断，则就会忽略掉T1中的比T2多余的部分，比如：T1的前序遍历为`341205`，T2的前序遍历为`412`。虽然T1包含T2的序列`412`，但是T1的`2`节点下面还挂着左孩子`0`。这就导致实际上T1中这个子树和T2结构不完全一样！\n所以，还要给叶子节点的空孩子加标记符，比如`#`代表空。\n如此，T1的前序遍历为`341##20#5##`，T2的前序遍历为`41##2##`，这样就能区分了。\n除此之外：还要在每次写val值（包括空）之后附加个`!`标记，因为`122334`有可能是`12,23,34`，也有可能是`1,223,34`。这就造成了歧义。\n补充一句，前序、中序、后序选择哪一个都可以，只要给出有效节点值、空节点以及访问节点结束标志，就能完全确定一个树的结构。\n![](../../images/刷题_另一个树的子树/image-20240331050434535.png)\n![](../../images/刷题_另一个树的子树/image-20240331050449419.png)\n# 代码\n\n## 解1_两树序列化为字符串，判断是否包含子串\n\nJava中字符串不断的拼接一定要用StringBuilder。可以提高效率。\n```java\npackage 字符串;\nimport common.TreeNode;\npublic class _572_另一个树的子树 {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n         \n    }\n    // 此处用后序遍历序列来表达树的结构。换成前序、中序也可以。\n    private String postSerialize(TreeNode root)\n    {\n        StringBuilder sb = postSerialize(root, sb);\n        return sb.toString();\n    }\n    private void postSerialize(TreeNode root, StringBuilder sb)\n    {\n        if(root != null)\n        {\n            postSerialize(root.left, sb);\n            postSerialize(root.right, sb);\n            sb.append(root.val);\n        }\n        else\n        {\n            sb.append(\"#\");\n        }\n        sb.append(\"!\");\n        return;\n    }\n}\n\n```\n测试\n```java\nimport common.TreeNode;\nimport common.printer.BinaryTreeInfo;\nimport common.printer.BinaryTrees;\n\n    public static void main(String[] args)\n    {\n        TreeNode root = new TreeNode(3);\n        root.right = new TreeNode(5);\n        root.left = new TreeNode(4);\n        TreeNode curRoot = root.left;\n        curRoot.left = new TreeNode(1);\n        curRoot.right = new TreeNode(2);\n        BinaryTrees.println(new BinaryTreeInfo() {\n            @Override\n            public Object root() {\n                return root;\n            }\n            @Override\n            public Object left(Object node) {\n                return ((TreeNode)node).left;\n            }\n            @Override\n            public Object right(Object node) {\n                return ((TreeNode)node).right;\n            }\n            public Object string(Object node) {\n                return ((TreeNode)node).val;\n            }\n        });\n        System.out.println(postSerialize(root));\n    }\n```\n结果：\n```\n  ┌─3─┐\n  │   │\n┌─4─┐ 5\n│   │\n1   2\n#!#!1!#!#!2!4!#!#!5!3!\n```\nisSubtree函数：对比两个字符串，判断T1字符串是否包含T2字符串。可以调用java的库函数contains。但据说contains用的不是KMP，因此效率可能较低，最好调用KMP算法。\n```java\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if(root == null || subRoot == null) return false;\n        return postSerialize(root).contains(postSerialize(subRoot));\n    }\n```\n### 坑\n\n虽然前序、中序、后序都可以，但是以上先序遍历转化的字符串有缺陷，仍不能通过T1先序字符串包含T2先序字符串就断定T2一定是T1的子树。比如：T1是33单节点，那么T1的字符串为`33!#!#!`，T2为3单节点，那么T2的字符串为`3!#!#!`，可以看到，虽然T1字符串包含T2字符串，但是T2的3节点压根就跟T1的33节点没关系！\n于是，可以看到，前序遍历是存在缺陷的，这个缺陷只出现在顶点打印的歧义。\n中序、后序都没有这样的问题。所以，如果是用前序遍历来序列化树，那么要在打印的最开始再另加一个标志如`?`，如此：T1字符串变为`?33!#!#!`，T2字符串变为`?3!#!#!`，由此就可以判别出，T1字符串不包含T2字符串了，因此可以正确判断出，T2不是T1的子树。\n# 心得\n\n这个题目属于二叉树的结构方面的问题，类似这类题型，考虑利用二叉树序列的特点和意义，转化为字符串序列，相当于把不好解决的树形结构降维打击成了一维结构。所以，本质上，这个题目考察的是二叉树的序列化、反序列化。\n\n# 总结\n\n1. 非空节点：`值!`，空节点：`#!`\n2. 空节点也必须序列化，才能完整地表达唯一的一棵树，而且前序、中序、后序遍历都可以确定一棵树，但是层序遍历不可以。","categories":["算法","刷题"]},{"title":"刷题_有效的字母异位词","url":"/算法/刷题_有效的字母异位词/","content":"# 内容\n\n原题名叫做：[有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/ \"https://leetcode.cn/problems/valid-anagram/description/\")。给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。（只包含小写字母）\n\n举例：\n```\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n\n输入: s = \"rat\", t = \"car\"\n输出: false\n\n提示:\n\n1. 1 <= s.length, t.length <= 5 * 104\n2. s 和 t 仅包含小写字母\n \n\n进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n```\n即每种字母的数目一样，但是顺序不一定。\n# 分析\n\n若是有限个字母比如26个英文字母，则可以建立一个一维数组S，遍历s，计每种祖母数。然后再建立一个一维数组T，遍历t，计数。最后判断S和T的内容是否一样。\n# 代码\n\n## 解1_\n\n```cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        std::vector<int> vis = std::vector<int>(26);\n        std::vector<int> vit = std::vector<int>(26);\n        const char * cp = s.c_str();\n        while(*cp != '\\0')\n        {\n            ++vis[*cp++ - 'a'];\n        }\n        cp = t.c_str();\n        while(*cp != '\\0')\n        {\n            ++vit[*cp++ - 'a'];\n        }\n        int i = 0;\n        while(i < 26)\n        {\n            if(vis[i] != vit[i++])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n### 优化\n\n可以不用去创建另外一个数组，而是在遍历t的过程中去减第一个数组中的value，遇到小于零的情况则false。（这已经足够了，不需要去判断第一个数组中是否全部为0了。因为前置条件已经限制两串长度一致，假如2号串中出现1串中不一样的字符，肯定会出现负值。如果2号串的字符种类没有多出来的，而数目多，比如1号串car，2号串raa，则a的值也会出现负值）\n```cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length() != t.length()) return false;\n        if(s.length() == 0) return false;\n        std::vector<int> vis = std::vector<int>(26);\n        const char * cp = s.c_str();\n        while(*cp != '\\0')\n        {\n            ++vis[*cp++ - 'a'];\n        }\n        cp = t.c_str();\n        while(*cp != '\\0')\n        {\n            if(--vis[*cp++ - 'a'] < 0)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n### 坑\n\n## 解2_hashmap\n\n```cpp\n#include<unordered_map>\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        //using std::hash_map<char, int> = CharIntMap;\n        if(s.length() != t.length()) return false;\n        if(s.length() == 0) return false;\n        typedef std::unordered_map<char, int> CharIntMap;\n        CharIntMap charIntMap_s;\n        const char * cp = s.c_str();\n        while(*cp != '\\0')\n        {\n            ++charIntMap_s[*cp++];\n        }\n        CharIntMap charIntMap_t;\n        cp = t.c_str();\n        while(*cp != '\\0')\n        {\n            ++charIntMap_t[*cp++];\n        }\n        for(auto it = charIntMap_s.begin(); it != charIntMap_s.end(); ++it)\n        {\n            if(charIntMap_t[it->first] != it->second)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n# 心得\n\n这个题目属于\n\n# 总结\n\n1. ","categories":["算法","刷题"]},{"title":"刷题_判断旋转词","url":"/算法/刷题_判断旋转词/","content":"# 内容\n\n原题名叫做：[字符串轮转](https://leetcode.cn/problems/string-rotation-lcci/description/)。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成。比如，waterbottle是erbottlewat旋转后的字符串）\n\n示例：输入`s1 = \"back\", s2 = \"ackb\"`，则输出`True`；\n输入`s1 = \"aa\", s2 = \"aba\"`，则输出`False`。\n\n# 分析\n\n拿wake举例，它的旋转词有4种情况：\n```\nSa:wake\nSb:akew\nSc:kewa\nSd:ewak\n```\n发现，可以让原串重复一次，成为`wakewake`。发现，wake的旋转词都能在这个重复串中找到子串。\n那么，问题就转化为从原串中匹配s2，即匹配字符串。\n\n![](../../images/刷题_判断旋转词/image-20240328032130071.png)\n![](../../images/刷题_判断旋转词/image-20240328032559844.png)\n![](../../images/刷题_判断旋转词/image-20240328032621207.png)\n# 代码\n\n## 解1_调库_调用Java库函数contains\n\n```java\npackage 字符串;\n/**\n * https://leetcode.cn/problems/string-rotation-lcci/\n * \n */\npublic class 面试题01_09_字符串轮转 {\n    public static boolean isRevolving(String s1, String s2)\n    {\n        if(s1 == null || s2 == null) return false;\n        if(s1.length() != s2.length()) return false;\n        return (s1 + s1).contains(s2);\n    }\n    public static void main(String[] args)\n    {\n        System.out.println(isRevolving(\"wake\", \"ewak\"));\n    }\n}\n```\n\n## 解2_编写KMP\n\n一般来说，面试手撕KMP的可能性还是比较低的，除非面试官时间很充足。\n如果是用的提供库调用的在线编译平台，则优先调用库函数：因为是java代码，而且contains有可能是暴力匹配，可能性能比较底下，先尝试能不能符合编译器最小时间需求。\n如果不让用库函数，或者java库函数代码性能低下，则只能手撕KMP了。\n如果实在没时间了，或者手撕不出来，则可以与面试官讲自己非常理解KMP的思路，毕竟思路是最重要的，代码是第二位。\n\n# 心得\n\n这个题目给了字符串类问题一个解决思路：**原串重复两次——即原串再次拼接一个原串**，有些问题可能就迎刃而解了。多去想想，就能转化成两个拼接的串中匹配一个子串的问题。","categories":["算法","刷题"]},{"title":"Java_String","url":"/Java/Java_String/","content":"# 字符串\n\n1. Java的字符串是在`java.lang`包中，所以可以直接使用，无需引包。\n2. Java 8之前的String是用char数组实现的。即`\"abc\"`的底层实现为`{'a', 'b', 'c'}`。\n3. 从Java 9开始，改为使用byte数组实现。\n4. 字符串字面量实际是String类的实例（相当于自动给你new了一个String，假设为s1，但是如果第二次用这个字面量初始化s2的话，就不会重新new了，而是直接把s1的对象引用给s2，详见[`==`](#`==`)）。\n5. String对象一旦创建完毕，该对象内部其中的字符内容不可以修改。\n    1. 但是String对象指针的指向可以更改。\n\n# 内存位置\n```java\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        String s = \"555\";\n        s += \"555\";\n        s = \"666\";\n        test(s);\n        System.out.println(s);\n    }\n    static void test(String str)\n    {\n        //str += \"555\";\n        str = str + \"555\";\n    }\n}\n```\n\nString字符串都是new出来的，因此都是在堆空间中。\n\n![](../../images/Java_20240328_String/image-20240328165008942.png)\n\n![](../../images/Java_20240328_String/image-20240328165046122.png)\n\n![](../../images/Java_20240328_String/image-20240328165117159.png)\n\n![](../../images/Java_20240328_String/image-20240328165138608.png)\n\n![](../../images/Java_20240328_String/image-20240328165149688.png)\n\n# 字符串常量池 (String Constant Pool, SCP)\n\n1. 字符串常量池。是指：从Java 7开始，属于堆空间的一部分。（以前是放在方法区中的）\n2. 遇到字符串字面量时，会去查SCP。\n    1. 如果SCP中匹配到与该字面量内容一致的字符串对象A时，则返回A。\n    2. 否则创建一个新的对象D，加入到SCP中，返回D。\n```java\nString s1 = \"xcg\";\nString s2 = \"xcg\";\nSystem.out.println(s1 == s2);\n```\n\n```java\nString s1 = \"xcg\";\nString s2 = new String(\"xcg\");\nString s3 = new String(s1);\nString s4 = new String(s2);\nchar[] cs = {'x', 'c', 'g'};\nString s5 = new String(cs); //用char数组new String\nString s6 = new String(s5); \nSystem.out.println(s1 == s2);\n```\n\n传入常量字符串的new底层：\n```java\nnew String(\"xcg\");\n----------------------\npublic String(String original)\n{\n    this.value = original.value;\n    this.hash = original.hash;\n}\n```\n`\"xcg\"`的底层空间是只有一份的，在SCP中。而`new String(\"xcg\")`本质上只是新创建了一个String对象，value的拷贝只是把旧地址给了新String中的value指针。即两个value数组是同一个地址的数组。这属于浅拷贝。\n![](../../images/Java_20240328_String/image-20240328170910662.png)\n因此，`s1`到`s4`只是String对象地址不同，但是，内部的value数组是同一个。\n![](../../images/Java_20240328_String/image-20240328171911687.png)\n\n传入字符数组的new底层：\n```java\nchar[] cs = {'x', 'c', 'g'};\nnew String(cs);\n---------------------------------\npublic String(char value[])\n{\n    this.value = Arrays.copyOf(value, value.length);\n}\n---------------------------------\npublic static char[] copyOf(char[] original, int newLength)\n{\n    char[] copy = new char[newLength];\n    System.arraycopy(original, 0, copy, 0,\n                    Math.min(original.length, newLength));\n    return copy;\n}\n```\n可以看到，用字符数组去new一个String的话，底层要深拷贝一个数组，即产生一个新数组的地址赋给String对象内部的value指针。\n![](../../images/Java_20240328_String/image-20240328172027084.png)\n# intern方法\n\n```java\npublic native String intern();\n```\n被native关键字修饰，代表不是用Java编写的，可能是C语言。返回一个字符串。\n\n作用是：如果SCP中存在一个与B内容一样的字符串对象A，则返回A；**否则，将B加入到SCP中**，返回B。\n\n看下面的代码：\n```java\npublic class static void main(String[] args)\n{\n    int a = 1, b = 2, c = 3;\n    String s1 = String.format(\"%d%d%d\", a, b, c);\n    String s2 = String.format(\"%d%d%d\", a, b, c);\n    System.out.println(s1 == s2);  // false\n    \n    String s3 = s1.intern();\n    String s4 = s2.intern();\n    System.out.println(s1 == s3);  // true     - intern 第一次调用\n    System.out.println(s1 == s4);  // true ??? - intern 第二次调用\n    \n    String s5 = \"123\";\n    System.out.println(s1 == s5);  // true\n    \n}\n```\ns1不等于s2，因为通过format生成的字符串不是字符串常量！因此，s1和s2指向的字符数组不是字符串常量池中的变量。\n\n去SCP观察有没有重复串的情况**仅限于**涉及到字符串字面量的情况，或者用另一个字符串对象直接构造新的。或者：直接调用String类的intern方法，这是手动去观察SCP有无重复串。但是要记住了，intern有一个隐形操作：”**否则，将B加入到SCP中**“！\n因此，在s1调用了intern之后，s1的内容`\"123\"`就放入了常量池中。一旦intern被调用过一次，那么之后s2的intern返回的就是常量池中的地址了。\n因此，`s3==s4`。\n至于s5，因为是用字符串字面量初始化的，所以隐形调用了intern，所以实际指向的也是s1的value地址。\n我们可以推测出，两个字符串直接`==`判断是去判断内部成员的value地址是否一样。即判断是否是浅拷贝。\n# 字符串常用方法\n\n## 去除左右空格 - trim\n\n去除首左、尾右的空格\n```java\n\" 123  456  \".trim() // -> 123  456\n```\n## contains\n\n是否包含目标串（字符串匹配）\n```java\n\"123456\".contains(\"34\")\n```\n## split\n\n将字符串按照分隔符分割为数组\n```java\n\"1_2_3_4\".split(\"_\") // -> [1, 2, 3, 4]\n```\n\n## compareTo\n\n挨个比较大小\n```java\n\"abc\".compareTo(\"adc\")\n```\n\n## equals\n\n查看内容是否相等\n```java\nString s1 = \"abc\";\nString s2 = new String(\"abc\");\ns1.equals(s2);\n```\n## `==`\n\n如果直接用`s1 == s2`去比较字符串，则变成了引用之间的比较。则是去比较的是两个字符串对象的内存地址。\n```java\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        String s1 = \"123\";\n        String s2 = \"123\";\n        String s3 = new String(\"123\");\n        System.out.println(s1 == s2); // true\n        System.out.println(s1 == s3); // false\n    }\n}\n```\n\n## 截取子串 - subString\n\n截取`beginIndex`及之后的，`endIndex`之前的串。左闭右开。\n```java\nint beginIndex = 2;\nint endIndex = 5;\n\"xcg123go\".subString(beginIndex);           // g123go\n\"xcg123go\".subString(beginIndex, endIndex); // g12\n```\n## 替换目标串 - replace\n\n```java\n\"xcg123go\".replace(\"123\", \"Never\"); // xcgNervergo\n```\n# StringBuilder\n\n与String相比，共同点是都实现了CharSequence接口。\n\n在进行字符串频繁的改动时（拼接、替换等），使用StringBuilder。\n\n```java\nStringBuilder sb = new StringBuilder();\nsb.append(\"123\");\nsb.append(\"456\");\n```\n## 常用方法\n\nappend, insert, delete, replace, reverse\n\n## append原理\n\nStringBuilder的底层是也是一个`value = new char[n];`的字符数组。\n与String的不同是，这个字符数组有预留空间，记录length来标记数组中有效结尾。\n当空间满时，动态扩容。","categories":["Java"]},{"title":"刷题_反转链表","url":"/算法/刷题_反转链表/","content":"# 内容\n\n反转链表。\n\n针对的是不带头节点的单链表。\n# 三指针法\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) return head;\n        ListNode * cur = head;\n        ListNode * prev = nullptr;\n        while (cur != nullptr)\n        {\n            ListNode * tmp = cur->next;\n            cur->next = prev;\n            prev = cur;\n            cur = tmp;\n        }\n        return prev;\n    }\n};\n```\n\n# 头插法（双指针法）\n需要构建一个虚拟头节点。\n```cpp\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) return head;\n        ListNode * headNode = new ListNode(0, head);\n        ListNode * cur = head;\n        ListNode * tmp = nullptr;\n        headNode->next = nullptr;\n        while (cur != nullptr)\n        {\n            tmp = cur;\n            cur = cur->next;\n            tmp->next = headNode->next;\n            headNode->next = tmp;\n        }\n        head = headNode->next;\n        delete headNode;\n        return head;\n    }\n};\n```\n\n","categories":["算法","刷题"]},{"title":"Cpp_引用","url":"/Cpp/Cpp_引用/","content":"# 引用\n\n引用的作用是给变量起一个别名。\n# 引用的地址常性\n\n```cpp\nint main()\n{\n    int a2 = 9;\n    int a = 10;\n    int& b = a;\n    b = a2;     // a\n}\n```\n\n在定义引用时，必须指定一个被引用者（地址）。一旦定义成功，在其生命期中，就不可更换地址了。这是引用的地址常性。\n\n相当于`int & b = a`在本质上是`int * const b = &a`。\n\n但是这与引用的该地址上的内存数据的常性不冲突。如果需要赋予数据常性，则仍需修饰const：`int const & b = a`。此时，就无法通过引用b去修改内存上的数据值了。","categories":["Cpp"]},{"title":"Cpp_面向对象","url":"/Cpp/Cpp_面向对象/","content":"# 对象是什么\n\n对现实事物的抽象。\n\n面向对象的三大特征：封装、继承、多态。（有的还会加一个“抽象”）\n\n面向对象编程：Oriented Object Programming\n# 封装\n\n具体地，Cpp的对象是基于C结构体实现的。\n\n把函数和变量封装到一起，这就叫面向对象编程。\n\n因此，面向对象的第一个特性就是封装性。\n\n封装性就在于，不能直接访问对象的变量。这样的好处就是，解耦合。即使换了对象，虽然内容的细节变了，但是对外的方法都是统一的。\n## 控制访问权限\n那么，如何控制访问权限？就引入了访问域控制符private、public\n```cpp\nstruct Person\n{\nprivate:\n    int m_age;\npublic:\n    int get_age(void) const\n    {\n        return m_age;\n    }\n    void set_age(int age)\n    {\n        m_age = age;\n    }\n};\nint main()\n{\n    Person person;\n    person.set_age(90);\n    std::cout << person.get_age() << std::endl;\n}\n```\n目前，给变量加了private控制，造成无法在类外进行初始化，那么就需要引入公有的构造函数。\n```cpp\nstruct Test\n{\npublic:\n    Person(int age)\n    {\n        m_age = age;\n    }\n};\n```\n## class和struct的区别\n1. struct默认是public\n2. class默认是private\n# 多态\n\n只有指针和引用才能产生多态。\n## overload - 重载 - 静态多态\noverload（重载）是静态多态性。\n\n按照**名字相同**，**参数类型**或**参数个数**的不同来决定能否重载。返回值类型不参与决策。（主要是名字要相同，一名多用，因此叫做重zhong载，即超负荷）\n```cpp\n{\n    int val(void) const\n    {\n        return _val;\n    }\n    void val(int val)\n    {\n        _val = val;\n    }\n    void val(double val)\n    {\n        _val = val - 1;\n    }\n}\n```\n### 利用静多态写现代风格的get、set\n```cpp\nclass Person\n{\nprivate:\n    int m_age;\npublic:\n    int age(void) const\n    {\n        return m_age;\n    }\n    void age(int age)\n    {\n        m_age = age;\n    }\n};\n```\n### 构造函数的重载\n如果不提供自定义构造函数，系统会提供默认的无参数、空定义的构造函数。\n\n析构函数不支持重载。\n```cpp\nclass Test\n{\npublic:\n    Test(void) : _val{7}\n    {\n        std::cout << \"Test()\" << std::endl;\n    }\n    Test(int val) : _val{ val }\n    {\n        std::cout << \"Test(int val)\" << std::endl;\n    }\n};\n```\n#### POD类型的构造\n如果类型中所有的成员都是public的，那么这个类型就叫做POD类型，全称Plain Old Data。\n>在C++中，POD（Plain Old Data）类型指的是一种传统的数据结构，它的行为和布局类似于C语言中的结构体或基本数据类型。POD类型被认为是“old”的主要原因是它们代表了早期C和C++编程中常见的简单数据结构，而现代C++引入了更多复杂和强大的特性，使POD类型显得相对原始和过时。\n\n这种类型在没有定义构造函数时，可以直接用`{ 1, 2, 3 }`这种形式进行初始化。\n```cpp\nclass Test\n{\npublic:\n    int _val;\n    int _val2;\n    int _val3;\n};\nint main()\n{\n    Test test{ 1, 2, 3 };\n    \n}\n```\n### 默认值\n默认值的重载要注意不能出现二义性。\n比如函数有两个参数的默认值全给了，但是和无参数的函数调用冲突了。\n默认值只能从右往左连续依次设置。\n```cpp\nclass Test\n{\npublic:\n    Test(void) : _val{7}\n    {\n        std::cout << \"Test()\" << std::endl;\n    }\n    Test(int val, int val2 = 12) : _val{ val2 }\n    {\n        std::cout << \"Test(int val, int val2)\" << std::endl;\n    }\n};\nint main()\n{\n    // (10, 12)\n    Test test{ 10 };\n    // (10, 11)\n    Test test{ 10, 11};\n}\n```\n### NULL和nullptr用于重载\n```cpp\nclass Test\n{\npublic:\n    void show(int val)\n    {\n        std::cout << \"show(int)\" << std::endl;\n    }\n    void show(int * val)\n    {\n        std::cout << \"show(int*)\" << std::endl;\n    }\n};\nint main()\n{\n    int * c_ptr      = NULL;\n    int * cpp_ptr    = nullptr;\n    Test test;\n    test.show(c_ptr);// 走int*\n    test.show(NULL); // 走int\n}\n```\n发现，如果函数参数传入NULL，则cpp认为是整型。\n因为Cpp下NULL是整数0的宏定义：\n```cpp\n#ifndef NULL\n    #ifdef __cplusplus\n        #define NULL 0\n    #else\n        #define NULL ((void *)0)\n    #endif\n#endif\n```\nCpp中nullptr是C++11引入的关键字，专门用于表示空指针。类型是`std::nullptr_t`，这是一个专门的类型，可以隐式转换为任何指针类型。\nnullptr解决了NULL的类型问题，更加明确和安全。\n## override - 重写\n\n1. 要重写，基类成员方法就要加virtual关键字。\n2. 此后子类的virtual可以省略。\n3. 重写函数必须**函数签名完全一致**。包括返回值类型。\n4. 子类如果要重写方法，在`C++11`之后最好加上override关键字，这样可以帮助检查方法名、参数列表是否一致。\n### 接口\n\n接口就是定义了一套规范，但是没有具体实现。\n```cpp\nclass IVal\n{\npublic:\n    virtual int val(void) = 0;\n};\n```\n如上，纯虚函数，即是一个`C++`的接口。只有虚函数才有这种`= 0`的写法，普通成员函数没有。\n如果一个类中有一个纯虚函数，那么这个类就是抽象类。\n### 虚函数表\n\nvfptr虚函数表指针，指向一个虚函数表，这个表是一维函数指针数组。虚函数表指针位于基类对象的前4或8个字节。\n虚函数表存放于常量区或静态存储区，C++委员会未规定，编译器厂商自行决定。\n#### 动态联编\n虚函数表的内容由new的实际对象类型决定，和声明的类型无关。\n这就叫做**动态联编**。\n### 虚的析构函数\n\n如果不给析构函数加虚的话：\n```cpp\nclass A\n{\npublic:\n    void func() { std::cout << \"call A::func\" << std::endl; }\n    ~A() { std::cout << \"~A()\" << std::endl; }\nprivate:\n    int ma;\n};\nclass B : public A\n{\npublic:\n    void func() { std::cout << \"call B::func\" << std::endl; }\n    ~B() { std::cout << \"~B()\" << std::endl; }\nprivate:\n    int mb;\n};\n\nint main()\n{\n    A* a = new B();\n    delete a;\n}\n```\n输出：`~A()`，子类部分内存泄漏。\n\n而如果我们在基类的析构函数加虚了的话，A调用析构函数时，查表，则首先析构的是B，而后再来析构A自己。这样就完美地形成了A派生B，而B返回A的轮回、循环。有种递归的美感。\n# 继承\n\n## hidden - 覆盖（隐藏）\n隐藏和重载都是名字相同，但隐藏强调的是父子类之间的关系。重载强调的是同一作用域的关系（在一个类中，或在同一个全局区定义的函数）。\n### 成员方法的覆盖\n父子类的成员方法名字相同（无论参数列表），则父类方法被隐藏（覆盖）。当调用字类对象的该名字方法时，是无法显式调用父类中被隐藏的方法的。但是也可以利用**完全限定符**进行显式调用：`child.Test::val()`\n\n```cpp\nclass Test\n{\npublic:\n    Test(void) : _val{ 5 }\n    {\n    \n    }\n    ~Test(void)\n    {\n    \n    }\n    void val(int val)\n    {\n        _val = val;\n    }\nprotected:\n    int _val;\n}\nclass Child : public Test\n{\npublic:\n    Child(void)\n    {\n    }\n    ~Child(void)\n    {\n    }\n    int val(int a, int b) const\n    {\n        return _val;\n    }\n}\nvoid foo(void)\n{\n    Child child;\n    std::out << child.Test::val() << std::endl;\n}\nint main()\n{\n    foo();\n    return 0;\n}\n```\n### 成员变量的覆盖\n变量也可以覆盖。给Child也定义一个`_val`成员变量，调用父类的`val()`方法去观察：\n```cpp\nclass Test\n{\npublic:\n    Test(void) : _val{ 5 }\n    {\n    \n    }\n    ~Test(void)\n    {\n    \n    }\n    void val(int val)\n    {\n        _val = val;\n    }\nprotected:\n    int _val;\n}\nclass Child : public Test\n{\npublic:\n    Child(void) : _val{ 22 }\n    {\n    }\n    ~Child(void)\n    {\n    }\n    //int val(int a, int b) const\n    //{\n    //    return _val;\n    //}\nprivate:\n    // hidden\n    int _val;\n}\nvoid foo(void)\n{\n    Child child;\n    std::out << child.val() << std::endl;\n}\nint main()\n{\n    foo();\n    return 0;\n}\n// 结果为：5  -- 说明调用父类的val()方法后，返回的_val变量为父类中的_val而不是子类的。\n```\n现在让子类覆盖父类的`val()`方法：\n```cpp\nclass Child : public Test\n{\npublic:\n    Child(void) : _val{ 22 }\n    {\n    }\n    ~Child(void)\n    {\n    }\n    int val(void) const\n    {\n        return _val;\n    }\nprivate:\n    // hidden\n    int _val;\n}\nvoid foo(void)\n{\n    Child child;\n    std::out << child.val() << std::endl;\n}\nint main()\n{\n    foo();\n    return 0;\n}\n// 结果为：22  -- 说明调用子类的val()方法后，返回的_val变量为子类中的_val\n```\n如果我们删除掉子类中`_val`变量的定义：\n```cpp\nclass Child : public Test\n{\npublic:\n    Child(void) : // _val{ 22 }\n    {\n    }\n    ~Child(void)\n    {\n    }\n    int val(void) const\n    {\n        return _val;\n    }\nprivate:\n    // int _val;\n}\nvoid foo(void)\n{\n    Child child;\n    std::out << child.val() << std::endl;\n}\nint main()\n{\n    foo();\n    return 0;\n}\n// 结果为：5  -- 调用子类的val()方法后，没找到子类中存在_val变量，因此返回的_val变量为父类中的_val\n```\n因此，总结下来就是：\n1. 如果子类中定义了父类中的同名变量，而没有方法覆盖，则只能调用父类方法，是使用父类的变量。\n2. 如果子类中定义了父类中的同名变量，并且定义了子类覆盖方法（父类同名方法），则使用子类的变量。\n3. 如果子类没有定义父类中的同名变量，并且没有方法覆盖，则只能调用父类方法，是使用父类的变量。\n4. 如果子类没有定义父类中的同名变量，而定义了子类覆盖方法（父类同名方法），则使用父类的变量。\n所以：要让子类同名方法使用子类的变量而不是使用父类的同名变量，必须：既覆盖方法、又覆盖变量。\n## 多重继承\n\n如果Child继承Base、Base2，如下：\n```cpp\n\nclass Base\n{\npublic:\n    Base(void)\n    {\n        std::cout << \"Base(void)\" << std::endl;\n    }\n    virtual ~Base()\n    {\n        std::cout << \"~Base()\" << std::endl;\n    }\n    virtual void show(void) const\n    {\n        std::cout << \"Base::show(void) const\" << std::endl;\n    }\n};\nclass Base2\n{\npublic:\n    Base2(void)\n    {\n        std::cout << \"Base2(void)\" << std::endl;\n    }\n    virtual ~Base2()\n    {\n        std::cout << \"~Base2()\" << std::endl;\n    }\n    virtual void show(void) const\n    {\n        std::cout << \"Base2::show(void) const\" << std::endl;\n    }\n};\nclass Child : public Base, public Base2\n{\npublic:\n    Child(void)\n    {\n        std::cout << \"Child(void)\" << std::endl;\n    }\n    ~Child()\n    {\n        std::cout << \"~Child()\" << std::endl;\n    }\n    void show(void) const\n    {\n        std::cout << \"Child::show(void) const\" << std::endl;\n    }\n    // 新虚方法\n    virtual void newFunc()\n    {\n        std::cout << \"Child::newFunc()\" << std::endl;\n    }\n}\n};\n// 对应下边的第4条中的前半句。\nint main()\n{\n    Child * child = new Child;\n    child->show();\n    delete child;\n    child = nullptr;\n}\n// 对应下边的第4条中的后半句，讨论另外的基类是否也会更新虚方法。\nint main()\n{\n    Base2 * base2 = new Child;\n    base2->show();\n    delete base2;\n    base2 = nullptr;\n}\n// 对应下边的第5条，编译不通过，验证了不会在第二个基类的虚表增加这个派生类的新的虚函数。报错信息：newFunc is not a member of 'Base2'\nint main()\n{\n    Base2* base2 = new Child;\n    base2->newFunc();  // error\n    delete base2;\n    base2 = nullptr;\n}\n```\n那么，Child就有两个同级基类。逻辑上，继承关系链变成了多维的，但是，程序编译肯定是要降维为一维顺序执行的。因此必然规定一个先后次序才行。\n1. 每一条支链都可以有一个虚表指针，如果支链上有一个类有虚函数的话，那么虚表指针就在起始有虚函数的基类对象的前4或8个字节。\n2. 构造基类对象的顺序按照冒号`:`后的类名顺序来定。\n3. 子类重写哪个基类的方法，就相应地在哪个基类的虚表中更新。\n4. 如果子类重写的方法和多个基类中的方法相同，默认在第一个基类中正常更新虚表，虚表中的内容直接指向重写的方法；在运行效果上来看，另外的基类也会更新虚方法表，表中记录的函数指针使用了adjustor thunk技术，间接地指向派生类的重写的方法。\n    1. 如果多个基类有相同的虚函数，而子类没有重写该方法，那么Child指针指向Child对象在调用此方法名字时，必须指出调用的是哪个基类。\n5. 如果在子类新增一个虚函数，那么，只在第一个基类的虚表更新（即在尾部写下这个派生类的新函数）。不会在第二个基类的虚表增加这个派生类的新的虚函数。\n### 菱形继承的问题\nDiamond\n\n菱形继承的最大问题是数据冗余、二义性问题。\n比如，学生、职工继承于人，在职学生继承于学生、职工。在默认的模型中，学生、职工对象内部都会存在人，那么对于在职学生这个角度，会看到两个人。\n\n解决方案一是在今后的调用中均显式加上具体类来源。\n解决方案二是使用virtual继承。这会使继承人中的基类对象“消失”，归属于第三层子类，原来的位置变为一个虚基表指针（vbptr，virtual base table pointer），该表记录了本类对象与虚基类对象的偏移地址。\n\n要清楚地知道，不仅是成员变量的冗余问题，两个不同的方案会导致对象的虚表行为改变。\n\n方案一，存在两个虚表。分别在学生中的人、职工中的人。要想调用虚函数，需要显式指出调用学生还是职工。\n方案二，只存在单个虚表、共有的一个基类对象。这样的后果是，如果学生和职工都重写了人的方法，那么单个虚表又会不够用了，即出现了二义性。\n\n两个方案都不完美，方案一的缺点在于数据冗余，方案二的缺点在于限制了多态性，即会出现二义性。\n\n总之：\n1. 要么选择：有两个基类成员，有两个虚函数表。学生、职工可以同时重写，只不过需要显式调用。但是有矛盾的双份基类数据。\n2. 要么：只有一个基类成员，只有一个虚函数表。学生、职工不能同时重写基类的方法。但不需要显式调用。\n### 虚继承\n虚继承，会产生一个vbptr，指向一个虚基表。表中保存了虚基类在内存中的偏移信息，用于在对象内正确定位虚基类子对象。如果使用虚继承引入了一个基类，则可以确保该虚基类只被构造一次。vbptr 并非 C++ 标准的一部分，而是一些编译器（如 Microsoft Visual C++）在实现虚拟继承时采用的内部机制。\n```cpp\n#include<iostream>\nclass A\n{\npublic:\n    virtual void func() { std::cout << \"call A::func\" << std::endl; }\nprivate:\n    int ma;\n};\nclass B : virtual public A\n{\npublic:\n    void func() { std::cout << \"call B::func\" << std::endl; }\nprivate:\n    int mb;\n};\nint main()\n{\n    A * p = new B();\n    p->func();\n    delete p;\n    return 0;\n}\n```\n调用func没问题，输出`call B::func`，但最终会崩溃报错：（注意，以下讨论均基于Windows VS编译器环境，据说Linux `g++`环境下delete p时p会自动偏移回B的位置导致不崩溃，待测试）\n![](../../images/Cpp_20240324_面向对象/image-20240715041734762.png)\n这是因为p指向的是A的起始地址（vfptr），而整个B对象在内存中的起始位置是先于A的，而delete、free的时候要看那个位置的上文记录信息。由于p的位置没有信息，那么就会释放一个不该释放的位置。\n\n如何验证呢？发现64位下`sizeof(B)`是32，`sizeof(*p)`是16。如果最后`delete (p - 1);`即不崩溃。\n\n>派生类对象取地址，是基类对象的起始地址。这是定律。 \n\n```\n+-----\n+vbptr\n+-----   ------> 正确的delete的位置\n+ mb\n+-----   ------> p指向的位置\n+vfptr\n+-----\n+ ma\n+-----\n```\n然而，更明智的做法是：只要把A的析构函数写为虚的，就能正常了：这样，delete p的时候，在调用析构时，就会去查基类（A）中的虚方法表指针，从而先去析构B，然后，再去析构A。\n>对比单继承下的虚析构时delete顺序链：派生顺序A-B-C，虚析构时，delete的是A地址，但查表后先去析构C，再析构B，再析构A。\n\n```cpp\nclass A\n{\npublic:\n    virtual void func() { std::cout << \"call A::func\" << std::endl; }\n    virtual ~A() { std::cout << \"~A()\" << std::endl; }\nprivate:\n    int ma;\n};\n\nclass B : virtual public A\n{\npublic:\n    void func() { std::cout << \"call B::func\" << std::endl; }\n    ~B() { std::cout << \"~B()\" << std::endl; }\nprivate:\n    int mb;\n};\n```\n输出：\n```\ncall B::func\n~B()\n~A()\n```\n# 对象的本质\n\n实际上，对象只能存储变量。方法是通过转化转移到了代码区。\n\n要区分不同对象，需要用到this指针，因此每一个普通成员方法都有隐含的this指针参数。\n比如Child类的`val()`方法实际的完整形式如下：\n```cpp\nclass Child\n{\n//...\n    int val(Child * const this) const\n    {\n        return this->_val;\n    }\n//...\n}\n```\n下面是实际调用的过程：\n```cpp\n形式调用过程：\n----------------\nChild child;\nchild.val();\n----------------\n实际调用过程：\n----------------------\nChild child;\nChild::val(&child);\n----------------------\n```\n## 基类指针指向子类对象\n\n### 静态联编：在编译期就确定死了\n```cpp\nvoid foo(void)\n{\n    Test * base = new Child;\n    std::cout << base->val() << std::endl;\n}\n```\n\n### 动态联编：在运行时才能确定\n需要把函数放到数据中。只有数据是动态的，因此要想动态联编只能通过数据的转化。函数也有指针和地址，所以，可以通过改变函数指针的地址来进行动态转换。\n```cpp\n\n```\n# 类型转换\n## dynamic_cast\n动态类型转换用于父子类之间切换指针类型。转换成功则返回目标指针类型，不成功则返回空。\n```c++\ndynamic_cast<Target Type*>(Origin Pointer)\n```\n1. 从子类转到基类，是上行转换（upcast）\n2. 从基类转到子类，是下行转换（downcast）\n3. 如果有父子类关系，上行转换肯定会成功，难点在于下行转换。\n4. 下行转换，小括号中的指针或引用对应的父类必须要有虚函数。否则编译不通过。编译不通过说明小括号中的类没有虚函数。\n5. 下行转换，编译通过，但运行失败了，则说明二者没有父子关系，失败的情况：\n    1. 如果下行转换指针，失败则返回空指针，需要通过判断是否为空来判断是否转换成功。\n    2. 如果下行转换引用，失败无法返回空引用，只能抛出异常，异常信息是：bad dynamic cast，需要通过异常处理来判断是否成功。\n\n```cpp\nclass Base\n{\npublic:\n    Base()\n    {\n        std::cout << \"Base()\" << std::endl;\n    }\n    virtual ~Base()\n    {\n        std::cout << \"~Base()\" << std::endl;\n    }\n    virtual void show() const\n    {\n        std::cout << \"Base::show()\" << std::endl;\n    }\n};\nclass Child : public Base\n{\npublic:\n    Child()\n    {\n        std::cout << \"Child()\" << std::endl;\n    }\n    ~Child()\n    {\n        std::cout << \"~Child()\" << std::endl;\n    }\n    void show() const\n    {\n        std::cout << \"Child::show()\" << std::endl;\n    }\n};\nclass Other\n{\npublic:\n    void show() const\n    {\n        std::cout << \"Other::show()\" << std::endl;\n    }\n};\n// Upcast\n// output: Child::show()\nint main()\n{\n    Child* child = new Child;\n    Base* base = dynamic_cast<Base*>(child);\n    if (base)\n    {\n        base->show();\n        delete base;\n        base = nullptr;\n    }\n    child = nullptr;\n}\n// Downcast - success\n// output: Child::show()\nint main()\n{\n    Base* base = new Child;\n    Child* child = dynamic_cast<Child*>(base);\n    if (child)\n    {\n        child->show();\n        delete child;\n        child = nullptr;\n    }\n    base = nullptr;\n}\n// Downcast - error_pointer\n// output: Downcast error\nint main()\n{\n    Base* base = new Child;\n    Other* other = dynamic_cast<Other*>(base);\n    if (other)\n    {\n        other->show();\n        delete other;\n        other = nullptr;\n    }\n    else\n    {\n        std::cout << \"Downcast error\" << std::endl;\n        delete base;\n        base = nullptr;\n    }\n}\n// Downcast - error_reference\n// output: Bad dynamic_cast!\nint main()\n{\n    Child child;\n    Base& base = child;\n    try\n    {\n        Other& other = dynamic_cast<Other&>(base);\n    }\n    catch (const std::exception& e)\n    {\n        std::cout << e.what() << std::endl;\n    }\n}\n```\n## static_cast\n通俗来说，是复制一个老的值，创建一个新的值。\n1. 支持基础普通类型的转换。也可以类实体之间的、父子类指针（引用）之间的转换。\n2. 实体之间的转换，实际上是按小括号里的实体复制了一份新的实体。\n3. 父子类指针（引用）之间的上下转换，只要有父子关系，都能转换成功。不依赖虚函数表。\n    1. 但是，下行转换是强行解释的，因为子指针指向了父对象。\n4. 不支持指针和实体之间的转换。支持实体转到引用。\n```c++\nstatic_cast<Target Type*>(Origin Pointer)\nstatic_cast<Basic Type>(Basic Type)\n```\n\n```cpp\nint main()\n{\n    double d = 15.2;\n    auto f = static_cast<float>(d);\n}\n```\n\n```cpp\nclass Base\n{\npublic:\n    Base()\n    {\n        std::cout << \"Child()\" << std::endl;\n    }\n    virtual ~Base()\n    {\n        std::cout << \"~Base()\" << std::endl;\n    }\n    virtual void show() const\n    {\n        std::cout << \"Base::show()\" << std::endl;\n    }\n};\nclass Child : public Base\n{\npublic:\n    Child()\n    {\n        std::cout << \"Child()\" << std::endl;\n    }\n    ~Child()\n    {\n        std::cout << \"~Child()\" << std::endl;\n    }\n    void show() const\n    {\n        std::cout << \"Child::show()\" << std::endl;\n    }\n};\nint main()\n{\n    Base  * base  = new Child;\n    Child * child = static_cast<Child*>(base);\n    if (child)\n    {\n        child->show();\n    }\n    delete child;\n    child = nullptr;\n    base = nullptr;\n}\n```\n## reinterpret_cast\n用于指针重新解释一个值或对象。\n1. 可以两个指针（引用）之间，或值和指针（引用）之间进行转换。\n    1. 值和指针（引用）之间进行转换目的是为了把值当作地址用。\n2. 基础类型之间不能转换\n3. 编译器没有安全检查，正确性由程序员把握。\n\n```cpp\nreinterpret_cast<Target Type*>(Origin Pointer)\nreinterpret_cast<Target Type*>(Origin Value)\nreinterpret_cast<Target Type>(Origin Pointer)\n```\n## const_cast\n1. 主要用于指针引用一个去掉常性的变量，强调对其进行修改。\n    1. 也可以用于指针引用一个加上常性的变量，强调不对其进行修改。但是其实没必要，直接在前面指针声明的时候加const就行。\n2. 只能进行指针（引用）之间的转换。\n\n```cpp\nconst_cast<Target Type*>(Origin Pointer)\n```\n\n```cpp\nint main()\n{\n    int         a = 123;\n    int const * p = &a;\n\n    *p                   = 222;  // error\n    *const_cast<int*>(p) = 222;\n}\n```\n既然规定了const，为什么还要给`const_cast`机制？这是为了让程序员有修改const变量的权限。这个显式的机制是为了让程序员保证他们不是在误操作修改。\n```cpp\nclass Base\n{\npublic:\n    Base()\n    {\n        std::cout << \"Child()\" << std::endl;\n    }\n    virtual ~Base()\n    {\n        std::cout << \"~Base()\" << std::endl;\n    }\n    virtual void show() /* const */\n    {\n        std::cout << \"Base::show()\" << std::endl;\n    }\n};\nclass Child : public Base\n{\npublic:\n    Child()\n    {\n        std::cout << \"Child()\" << std::endl;\n    }\n    ~Child()\n    {\n        std::cout << \"~Child()\" << std::endl;\n    }\n    void show() /* const */\n    {\n        std::cout << \"Child::show()\" << std::endl;\n    }\n};\nint main()\n{\n    Base const * base = new base;\n    base->show();  // error\n    const_cast<Base*>(base)->show();\n    delete base;\n    base = nullptr;\n}\n```\n如上，常对象不能调用非常方法。\n解决办法：\n1. 修改非常方法为常方法\n2. 用`const_cast`临时转换base的类型为非常类型。虽然可能违背了原本的设计，但是这是一种特殊情况下的权限。\n## 总结\n1. dynamic是唯一必须有虚函数表的\n2. static是唯一支持两个基础类型转换的\n3. reinterpret可以转换各种指针，包括可以把值和指针互转，但是必须要有一个指针参与。\n4. const只能转换指针（引用）。","categories":["Cpp"]},{"title":"网络_基础概念","url":"/网络/网络_基础概念/","content":"# 网段\n\n两台主机`192.168.1.10`和`192.168.2.11`，通过网线直连，是不能直接ping通的。\n因为不在同一网段下。需要路由器进行连接。\n\n网线直连、同轴电缆、集线器、网桥、交换机，所连接的设备必须在同一网段，连接的设备处在同一广播域。\n\n网桥、交换机可以隔绝冲突域。\n1. 网桥有两个接口，可以记录计算机在网桥哪一侧、IP和对应的MAC地址，从而可以阻挡非跨侧的无效通信，减少线路压力。\n2. 交换机有很多接口，可以让计算机之间进行全双工通信。完全隔绝了冲突。\n3. 如果两个计算机的IP地址设置在不同网段，比如一个是`192.168.1.10/24`，另一个是`192.168.2.10/24`。而如果他们用交换机连接，那他们是无法通信的，甚至直连网线也不行。\n4. 如果全世界设备都用交换机连接，先不说广播风暴的问题，IP地址也面临不够用的问题！\n路由器可以在不同网段之间转发数据，可以隔绝广播域。\n1. 虽然网桥、交换机可以隔绝冲突域，但是某个计算机在首次发起通信时需要广播ARP包给这一网段中的所有机器，即交换机连接着的所有设备，这称之为一个广播域。\n2. \n# MAC\n\n`arp -a`可以看本机缓存的IP地址和对应的MAC地址\n# 线材\n\n相同设备之间中交叉线，不同设备之间用直通线。比如计算机连接Hub用直通线，而Hub连接Hub用交叉线。\n\n但是，如果两个集线器之间隔了一个网桥，那么Hub-网桥-Hub的两根线依然是交叉线。\n\n# IP\n\n1. 按字节划分为4部分\n2. 按功能划分为2部分：网络标识（网络号）、主机标识（主机号）\n    1. 同一网段的网络号相同\n        1. 通过子网掩码可以计算出网络号：`子网掩码 &(按位与) IP地址`\n           ```\n             192.168.  1.10\n           & 255.255.255. 0\n           ------------------\n             192.168.  1. 0\n           ```\n        2. 子网掩码的**后面的连续的**非1位置（若干个0位）是给主机号准备的。\n# 数据包传输过程\n\n1. 如果是跨路由器传输，则源IP和目标IP不变，一直变化的是源MAC和目标MAC\n\n# 接口\n\n1. Fast Ethernet: 交换机和路由器之间通过以太网口连接\n2. Serial: 路由器和路由器之间通过串口连接\n\n# VPN\n\nVirtual Private Network: 虚拟私人网络。在公共网络上建立专用网络，进行加密通讯。","categories":["网络"]},{"title":"Cpp_auto","url":"/Cpp/Cpp_auto/","content":"# 内容\n1. 初识auto\n# auto\n\n如果不在返回auto的函数的返回值类型有冲突的后面加` -> int`，则会编译不通过，因为auto无法推断到底返回浮点型还是整型，则可以加` -> int`进行声明：返回值统一强转为int。\n\n这种auto在前，返回值类型在后的用处还有一个好处就是：如果返回值类型特别复杂、特别长，则可以先写auto代替，把又臭又长的名字放在后缀，起到了使代码美观的作用（避免头重脚轻）。\n\n```cpp\nauto show(int v)\n{\n    if(v < 10)\n        return 30.0;\n    else\n        return 30;\n}\n```\n\n```cpp\nauto show(int v) -> int\n{\n    if(v < 10)\n        return 30.0;\n    else\n        return 30;\n}\n```\n","categories":["Cpp"]},{"title":"Cpp_初始化列表","url":"/Cpp/Cpp_初始化列表/","content":"# 内容\n1. 三种形式的initialization\n2. 构造函数的初始化列表写法\n# Cpp的initialization\n有三种形式：\n1. 赋值（assignment形式）\n2. 卷括号（大括号，curly braces）\n3. 函数式（圆括号）\n\n```cpp\nint main()\n{\n    // assignment initialization\n    double a = 17.5;\n    // braces initialization\n    double b{ 17.5 };\n    // functional initialization\n    double c(17.5);\n}\n```\n\n委员会推荐新出的大括号形式的初始化，最通用，相比于圆括号来说更少有歧义。\n# 构造函数中的初始化列表\n\n冒号后面的初始化列表，除了assignment形式，小括号、大括号都可以。现代C++更推荐大括号。\n\n```cpp\nclass Test\n{\npublic:\n    Test(void) : _val{ 7 }\n    {\n        //_val = 7;\n    }\nprivate:\n    int _val;\n}\n```\n\n初始化列表的初始化是先于构造函数的，即给对象创建空间后立马填成员的值。\n而构造函数中赋值，是对象创建完毕后才去执行。\n## 初始化列表的语法糖\n\n如果要初始化的东西是常量，则`C++11`有语法糖：直接在成员变量后加初始化括号。\n```cpp\nclass Test\n{\npublic:\n    Test(void)\n    {\n        //_val = 7;\n    }\nprivate:\n    int _val{ 7 };\n};\n```\n","categories":["Cpp"]},{"title":"Cpp_概述","url":"/Cpp/Cpp_概述/","content":"# 内容\n1. Cpp是个什么语言，组成部分。\n# Cpp组成部分\n根据`legacy.cplusplus.com`手册中Reference一栏。标准C++库包含以下部分（此网站2017年停止更新）：\n1. C库\n2. 容器\n3. 输入输出流\n4. 原子和线程库（C++11之后）\n5. 杂项（Miscellaneous headers）\n    1. 算法库（algorithm）\n    2. 时间库（chrono）\n    3. 异常库（exception）\n    4. 函数对象（functional）\n    5. 迭代器（iterator）\n    6. 内存管理（memory）：尤其是智能指针\n    7. 随机（Random）\n        1. 梅森旋转算法，使用的是分布律。随机性能很好。\n    8. 工具（utility）：用的最多的是pair\n# 名字空间\n这个不是C++的专利，所有的面向对象语言，都有名字空间的概念。\n\n以前在C语言中，随意定义全局变量可能会产生污染。此时只有“全局空间”一说。\n\n现在在C++中，可以自定义一个名字空间，在其中定义自己的东西。防止与他人冲突。\n```cpp\nnamespace xcg\n{\nclass Person\n{\nprivate:\n    int m_age;\npublic:\n    int age(void) const\n    {\n        return m_age;\n    }\n    void age(int age)\n    {\n        m_age = age;\n    }\n};\n}\nnamespace other\n{\nclass Person\n{\nprivate:\n    int m_age;\npublic:\n    int age(void) const\n    {\n        return m_age;\n    }\n    void age(int age)\n    {\n        m_age = age;\n    }\n};\n}\nint main()\n{\n    xcg::Person person;\n}\n```\n## 名字空间可以嵌套\n第一种写法：\n```cpp\nnamespace xcg::alpha\n{\n    // ...\n}\n```\n第二种写法：\n```cpp\nnamespace xcg\n{\n    namespace beta\n    {\n        // ...\n    }\n}\n```","categories":["Cpp"]},{"title":"Cpp_流式IO处理_字符控制_pf操作符","url":"/Cpp/Cpp_流式IO处理_字符控制_pf操作符/","content":"# 内容\n\nCpp的基于流的IO系统\n1. ostream中`<<`运算符方法中的参数：pf控制符\n# `<<`\n`<<`叫做**流插入**运算符（insertion operator）。把后面跟随的内容插入到流中。\n```cpp\nint main()\n{\n    std::cout << \"Hello\" << \"\\n\";\n    return 0;\n}\n```\n## `<<`后面支持跟着哪些东西\n1. 数字类型（arithmetic types）\n2. 流缓冲（stream buffers）\n3. 控制符（manipulators）\n# `>>`\n`>>`称作流析出运算符（extraction operator）。\n# 控制符号\n## `std::endl`\nend of line\n\n`std::endl`是定义在`ostream`中的**函数**。\n![](../../images/Cpp_流式IO处理/image-20250308103912962.png)\n实际上就是输出了一个`\\n`，并且刷新缓冲区。\n# cout哪来的？ostream\n在`<iostream>`中，cout是这么定义的：\n```cpp\nextern ostream cout;\n```\n![](../../images/Cpp_流式IO处理/image-20250308133737867.png)\n`iostream`是继承于ostream、iostream的。\n\n在`<ostream>`中，ostream是`basic_ostream<char>`的别名。\n```cpp\ntypedef basic_ostream<char> ostream;\n```\ncout、cerr、clog是定义于`basic_ostream<char>`，即ostream的对象。\n关于详细的：[ostream](https://legacy.cplusplus.com/reference/ostream/ostream/)\n# ostream的方法\n## width方法控制数字宽度\n\ncout本身有一些方法，比如width就是。通过`std::cout.width(n)`进行调用。\n这个变量是继承于`std::ios_base`得来的。[std::ios_base::width - cppreference.com](https://en.cppreference.com/w/cpp/io/ios_base/width)\n\n```cpp\nint main()\n{\n    int val = 90;\n    std::cout.width(10);\n    std::cout << val << std::endl;\n    return 0;\n}\n```\n输出：\n```\n12345678\n        90\n```\n可以看到，width为10时，如果不足10个字符，则前面空出补位。\n## precision方法控制浮点数的精度\n[precision](https://legacy.cplusplus.com/ios_base::precision)\n和width一样，是cout的方法。\n```cpp\n#include<iostream>\nint main()\n{\n    double f = 3.14159;\n    std::cout.precision(5);\n    std::cout << f << std::endl;\n}\n```\noutput:\n```\n3.1416\n```\n# 基于流插入的形式进行的字符控制\n## ostream中的pf\nhttps://legacy.cplusplus.com/reference/ostream/ostream/operator%3C%3C/\npf是`<<`方法中值得注意的参数。pf是一个函数指针。可以填入不同的操作符（manipulator）。\n![](../../images/Cpp_流式IO处理/image-20250308142525262.png)\n## 操作符（manipulator）\n### endl\n其实我们最常见的`std::endl`就是一个。\n```cpp\n// Defined in header <ostream>\nostream& endl (ostream& os);\n```\n可以看到，endl实际上是一个函数。作用是往cout写入一个`\\n`，然后flush一下cout，最后再返回cout。\n### boolalpha控制bool输出形式\n\n除了endl这个manipulator，还有其他更专用的。如`boolalpha / noboolalpha`。（定义于标准库标头`<ios>`）\n默认下的bool类型：false输出0，true输出1。插入boolalpha后，就会false输出false、true输出true。而且一旦插入了boolalpha，就会持续保持状态，因为cout是一个全局对象。如果要恢复原态需要再次插入noboolalpha。\n```cpp\nint main()\n{\n    bool d{ false };\n    // 默认下的bool类型：false输出0，true输出1\n    std::cout << d << std::endl;\n    // 插入boolalpha后，就会false输出false、true输出true。\n    std::cout << std::boolalpha << d << std::endl;\n    // 插入noboolalpha后，就会false输出0、true输出1。\n    std::cout << std::noboolalpha << d << std::endl;\n}\n```\n### setw\n在`<iomanip>`定义的`std::setw`也可以控制width：\n[std::setw - cppreference.com](https://en.cppreference.com/w/cpp/io/manip/setw)\n\n>setw是一个扩展的manipulator。需要另外引入`<iomanip>`\n\n它也可以控制宽度，但较于width，它是基于流插入的形式进行的。通过`std::setw(n)`进行。\n```cpp\n#include<iostream>\n#include<iomanip>\nint main()\n{\n    std::cout << std::setw(6) << std::right << -77 << '\\n';\n}\n```\noutput:\n```cpp\n   -77\n```\n### left、right、internal\n可以配合internal、left、right进行对齐。（from `<ios>`）\n[std::left, std::right, std::internal - cppreference.com](https://en.cppreference.com/w/cpp/io/manip/left)\n1. internal是符号左、数字右；\n2. left是符号和数字整体左；\n3. right是符号和数字整体右。\n### 示例\n经过测试，必须每次都事先设置width，才能有效果。\n```cpp\nint main()\n{\n    int n = -77;\n    std::cout.width(6);\n    std::cout << std::internal << n << '\\n';\n    std::cout.width(6);\n    std::cout << std::left << n << '\\n';\n    std::cout.width(6);\n    std::cout << std::right << n << '\\n';\n}\n```\noutput:\n```cpp\n-   77\n-77   \n   -77\n```\n### setprecision\n[std::setprecision - cppreference.com](https://en.cppreference.com/w/cpp/io/manip/setprecision)\nsetprecision也是一个扩展的manipulator。（from `<iomanip>`）\n和precision方法一样，可以用于控制数字的精度，但setprecision是基于插入形式的。\n```cpp\n#include<iostream>\n#include<iomanip>\nint main()\n{\n    double f = 3.14159;\n    std::cout << std::setprecision(5) << f << '\\n';\n    std::cout << std::setprecision(9) << f << '\\n';\n    std::cout << std::fixed;\n    std::cout << std::setprecision(5) << f << '\\n';\n    std::cout << std::setprecision(9) << f << '\\n';\n}\n```\noutput:\n```cpp\n3.1416\n3.14159\n// fixed\n3.14159\n3.141590000\n```\n### 控制数字类型的输出\n\n还有showbase、showpoint、showpos、uppercase、`dec / hex / oct`等等（from `<ios>`）\n\n`dec / hex / oct`的作用在于控制输出数字类型的进制。比如\n```cpp\nint main()\n{\n    std::cout << std::hex << 10 << '\\n';   // a\n}\n```\n\nshowbase的作用在于输出时不同进制数加前缀，比如开启了showbase后，输出16进制数：\n```cpp\nint main()\n{\n    int n = 20;\n    std::cout << std::hex << std::showbase << n << '\\n';   //0x14\n    std::cout << std::hex << std::noshowbase << n << '\\n'; //14\n}\n```\n\nuppercase的作用是输出**数字类型**时，区分大小写格式。比如开启uppercase后16进制数`0x4d`就会变为`0X4D`。\n```cpp\nint main()\n{\n    std::cout << std::showbase << std::hex;\n    std::cout << std::uppercase << 77 << '\\n';   //0X4D\n    std::cout << std::nouppercase << 77 << '\\n'; //0x4d\n}\n```\n### fixed\n当 floatfield 设置为 fixed 时，浮点值将使用**定点表示法**写入：该值的小数部分位数与精度字段( [precision](https://legacy.cplusplus.com/ios_base::precision) ) 指定的位数完全相同，并且没有指数部分。\n### 默认浮点表示法、定点表示法、科学计数法\n默认浮点表示法和定点表示法以及科学计数法之间有所不同（请参阅 [precision](https://legacy.cplusplus.com/ios_base::precision) ）。在默认浮点表示法中，精度字段指定小数点前后显示的是最大有意义位数，而在定点表示法和科学计数法中，精度字段精确指定小数点后显示多少位数字，即使这些数字是小数点后的零。\n```cpp\n// modify floatfield\n#include <iostream>     // std::cout, std::fixed, std::scientific\n\nint main () {\n  double a = 3.1415926534;\n  double b = 2006.0;\n  double c = 1.0e-10;\n\n  std::cout.precision(5);\n\n  std::cout << \"default:\\n\";\n  std::cout << a << '\\n' << b << '\\n' << c << '\\n';\n\n  std::cout << '\\n';\n\n  std::cout << \"fixed:\\n\" << std::fixed;\n  std::cout << a << '\\n' << b << '\\n' << c << '\\n';\n\n  std::cout << '\\n';\n\n  std::cout << \"scientific:\\n\" << std::scientific;\n  std::cout << a << '\\n' << b << '\\n' << c << '\\n';\n  return 0;\n}\n```\noutput:\n```\ndefault:\n3.1416\n2006\n1e-010\n\nfixed:\n3.14159\n2006.00000\n0.00000\n\nscientific:\n3.14159e+000\n2.00600e+003\n1.00000e-010\n```\n# 基于流析出的形式\n`>>`称作流析出运算符（extraction operator）。\n## istream中的pf\n![](../../images/Cpp_流式IO处理/image-20250308193423855.png)\n可以看到，相比于ostream的pf，istream中的可选项少了一些。\n1. boolalpha，可以通过输入false、true字符串从而给bool变量写值的操作。\n2. `dec/hex/oct`，可以通过输入十进制、十六进制、八进制数字进而给整型变量写值。","categories":["Cpp"]},{"title":"网络_配置网卡","url":"/网络/网络_校园网环境下的配置/","content":"# 同时启用两个网卡时如何分流\n```\nEthernet adapter K20 Pro:\n\n   Connection-specific DNS Suffix  . :\n   IPv6 Address. . . . . . . . . . . : 240e:404:b731:3135:295c:a44f:73e8:7ab8\n   Temporary IPv6 Address. . . . . . : 240e:404:b731:3135:d4b7:5350:f5c7:bc25\n   Link-local IPv6 Address . . . . . : fe80::687:6:df5d:ea58%28\n   IPv4 Address. . . . . . . . . . . : 192.168.173.153\n   Subnet Mask . . . . . . . . . . . : 255.255.255.0\n   Default Gateway . . . . . . . . . : fe80::18c8:bfff:fe13:c1c2%28\n                                       192.168.173.248\nEthernet adapter School Net:\n\n   Connection-specific DNS Suffix  . : proxy.bjut.edu.cn\n   IPv6 Address. . . . . . . . . . . : 2001:da8:216:210f:954a:ccee:b328:8b0f\n   Temporary IPv6 Address. . . . . . : 2001:da8:216:210f:2989:37b0:8612:84fd\n   Link-local IPv6 Address . . . . . : fe80::46e4:b62a:f433:24cf%13\n   IPv4 Address. . . . . . . . . . . : 172.21.15.227\n   Subnet Mask . . . . . . . . . . . : 255.255.255.0\n   Default Gateway . . . . . . . . . : fe80::21b:53ff:fe4a:997f%13\n                                       172.21.15.254\n   DNS: 172.21.0.21 (Unencrypted) 172.21.201.22 (Unencrypted)\n```\n自己的网卡A的网关为192.168.175.219，校园网网卡B的网关为172.21.15.254\n\n1. 输入`route print`我们能看到本机目前的路由表\n2. 使用`route delete`删除所有0.0.0.0的路由,也就是默认设置，删除默认路由后无法上网。\n   ```\n   route delete 0.0.0.0\n   route delete ::/0\n   ```\n3. 添加路由表，指定使用网卡B访问特定的IP。设置完后因为我们把默认路由删了，所有就只能访问该地址。\n   ```\n   route -p add 172.30.201.2 mask 255.255.255.0 172.21.15.254 METRIC 1\n   ```\n    1. -p 是为了设置为静态永久路由，防止重启时配置消失\n    2. add 添加路由\n    3. 1.1.1.1 指定网卡访问的IP\n    4. 255.255.255.0是网关掩码\n    5. 172.21.15.254指定使用网卡B的网关访问该地址\n    6. METRIC 跃点数，跃点数越小优先级越高，范围1~9999，默认就是1\n4. 设置默认路由，恢复上网\n    1. 设置校园网卡B的默认路由，跃点数为200，指定IP走默认路由，才能上校园网\n       ```\n       route -p add 0.0.0.0 mask 0.0.0.0 172.21.15.254 METRIC 200\n       route -p add ::/0 mask ::/0 fe80::21b:53ff:fe4a:997f METRIC 200\n       ```\n    2. 现在网卡B上不了非校园网，所以要设置网卡B的默认路由，跃点数为100，要比200小。因此默认使用网卡A上网，而不是网卡B。\n       ```\n       route -p add 0.0.0.0 mask 0.0.0.0 192.168.173.248 METRIC 100\n       route -p add ::/0 mask ::/0 fe80::f435:31ff:fe10:28af METRIC 100\n       ```\n    3. 此时网卡A和B同时使用时优先使用网卡A。\n5. 如果设置出问题了请用下面命令进行解决。\n   ```\n   NETSH INT IP RESET  （重置IP设置）\n   NETSH WINSOCK RESET （重置网络设置）\n   NETSH WINHTTP RESET PROXY  （重置代理设置）\n   IPCONFIG /FLUSHDNS  （刷新DNS缓存）\n   ```\n\n# 校园网网址\n\n| 网址               | IP                     |\n| ---------------- | ---------------------- |\n| lgn.bjut.edu.cn  | 172.30.201.2           |\n| lgn6.bjut.edu.cn | [2001:da8:216:30c9::a] |\n| my.bjut.edu.cn   | 172.21.94.12           |\n# OpenWrt的配置\n为了正确使用IPV6。\n\n参考文章：[OpenWRT 路由器IPv6实战配置长篇教程](https://post.smzdm.com/p/awzodmpp/)\n\n首先给迷你主机刷机，安装OpenWrt系统。\n参考[大河李斯特视频工作室](https://space.bilibili.com/12562485/)\n\n注意手边需要有一个显示器、有线键盘，用于进PE刷机、显操作终端界面。\n\n可以在刷机后进OpenWrt系统后：\n1. 设置root管理员密码\n\n```sh\npasswd\n```\n2. 修改wan、lan接口号。建议把wan、wan6设置为eth0，lan设置为eth1。\n\n```sh\nvim /etc/config/network\n```\n3. 设置完后reboot。lan口网线插入主PC终端或者AP路由器即可在终端访问`192.168.5.1`以远程操作OpenWrt了。\n\n```sh\nreboot\n```\n## 网络-接口配置\nWAN口配置如下：\n![](../../images/网络_校园网环境下的配置/image-20240823020934427.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823020949117.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021000464.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021007455.png)\n\nWAN6口配置如下：\n![](../../images/网络_校园网环境下的配置/image-20240823021025883.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021032265.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021037823.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021043740.png)\n\nLAN口设置如下：\n![](../../images/网络_校园网环境下的配置/image-20240823021109711.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021129468.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021136612.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021144590.png)\n\nLAN口页面下面的DHCP服务配置：\n![](../../images/网络_校园网环境下的配置/image-20240823021206064.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021210784.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823021217626.png)\n\n## 网络-DHCP/DNS配置\n重点注意：由于校园网环境需要先在lgn网关进行用户登录，比如在一个172开头的内网进行，而要用的是lgn.bjut.edu.cn来访问，需要用到自动获取的校园网DNS来解析。\n\n在`DHCP/DNS`配置页面中（服务器设置-基本设置），有一项“重绑定保护”需要取消勾选！不然无法使用内网的DNS，无法访问内网地址。\n\n![](../../images/网络_校园网环境下的配置/image-20240823021743551.png)\n\n还有一项，如果要使用IPV6环境，务必把`高级设置`中的“禁止解析 IPV6 DNS 记录”取消勾选。否则无法访问IPV6网址（如lgn6.bjut.edu.cn）。\n其他默认即可。\n\n![](../../images/网络_校园网环境下的配置/image-20240823021948491.png)\n\n## 网络-防火墙配置\n目前不确定校园网环境下使用OpenWrt时防火墙的默认配置是否有影响。\n\n默认下是这样的：\n![](../../images/网络_校园网环境下的配置/image-20240823022413512.png)\n\n修改后是这样的，即把基本设置的“转发”改为接受。wan口的“入站”、“转发”也改为接受。\n![](../../images/网络_校园网环境下的配置/image-20240823022447143.png)\n除了基本设置以外，其他的都默认。\n# AP路由器配置\n在开启有线中继时，总是会出现莫名其妙的Bug。比如只有某一个电脑能正常访问lgn6.bjut.edu.cn以及lgn.bjut.edu.cn，其他电脑则只能访问lgn.bjut.edu.cn。更有一种奇葩的现象是那个能正常访问IPV6的电脑有时会无法访问lgn.bjut.edu.cn？\n\n所以干脆就开启正常的路由器模式吧！实测在BJUT的校园网环境下，不会造成多设备识别。网关后台的在网设备只显示了一条设备记录。\n![](../../images/网络_校园网环境下的配置/image-20240823023037664.png)\n路由器型号：Redmi路由器 AX6000\n系统ROM版本：MiWiFi 稳定版 1.0.67\n## 设置\n常用设置-上网设置中：\n上网设置，默认是DHCP。保持不动。\n![](../../images/网络_校园网环境下的配置/image-20240823023212834.png)\nIPV6网络设置，需要打开，修改上网方式为NAT6。\n![](../../images/网络_校园网环境下的配置/image-20240823023226433.png)\n其他保持不变。\n\n正常状态下，上网信息如下显示：\n![](../../images/网络_校园网环境下的配置/image-20240823023329342.png)\n至此，只要一个设备连接了此路由器，在lgn6.bjut.edu.cn进行IPV6、IPV4统一认证后，其他设备直接连接此路由器即可同样地按照统一的方式上网，并且无需再进行认证。\n# OpenClash配置\n通过以上的配置，达到了软路由+AP路由器可以多设备依赖AP路由器的IPV4、IPV6同时上网。\n以下，来配置OpenClash，达到丝滑的代理上网效果。\n## 下载内核文件\n在“服务-OpenClash”中，进入OpenClash页面。\n首先要下载内核。\n其自带的下载不好用，网络差时，需要手动下载。\n在“插件设置-版本更新”页面，依次点击3个Clash内核对应的“下载到本地”。会从Github上下载3个tar.gz压缩包到你现在的终端机。比如Windows电脑。\n我们可以把它解压后，通过OpenWrt中的“系统-文件传输”依次上传到`/tmp/upload`。\n上传后，在Windows终端进行ssh远程连接OpenWrt。\n```sh\nssh root@192.168.5.1\n```\n如果弹出了私钥相关的信息，初次访问的话，打一个yes即可。\n（也可以在“系统-TTYD 终端”操控OpenWrt终端）\n进入终端后，把刚才上传的文件移动到3个内核分别对应的位置。\n![](../../images/网络_校园网环境下的配置/image-20240823024534391.png)\n\n```sh\nmv /tmp/upload/clash /etc/openclash/core/clash\nmv /tmp/upload/clash_tun /etc/openclash/core/clash_tun\nmv /tmp/upload/clash_meta /etc/openclash/core/clash_meta\n```\n移动完后，发现OpenClash不能识别、执行此文件，需要改变权限。\n```\nchmod 777 clash\nchmod 777 clash_tun\nchmod 777 clash_meta\n```\n## 配置订阅\n系统-OpenClash-配置订阅\n添加。配置文件名写一个好辨识的，订阅地址按实际的写。一般Clash能用的，都可以。\n填完后，保存配置。\n上面的自动更新，勾选，更新模式选择“循环”，间隔1440分钟。\n填完后，保存配置。最后点更新配置。\n## 配置上网模式\nFake-IP在某些限制比较强的网站（如ChatGPT），可能表现得更好。\n\n点页面下面的“切换页面到Fake-IP模式”。\n\nMeta内核相比其他内核比较活跃，并且支持更多的特性。在模式设置中，勾选“使用Meta内核”。\n\n运行模式，选择Fake-IP（TUN）模式。（因为据说TUN访问网页的响应速度更快）\n\n网络栈类型，下面的小字说“请自行根据运行速度为 TUN 模式选择合适的网络栈”，当前软路由主机的芯片配置还算可以，x86体系的，因此可以选择\"Mixed\"先试试。\n\n![](../../images/网络_校园网环境下的配置/image-20240823025746861.png)\n\n模式设置改完了。先点下面的保存配置，别太快地点应用配置。\n## 流量控制\n\n取消勾选“禁用QUIC”，因为实测勾选此选项时无法访问Mac端的ChatGPT App。\n\nWAN接口名称、LAN接口名称应正确选择，目前系统的WAN接口是eth0，LAN接口是eth1。\n\n至于“绕过服务器地址”、“绕过大陆IP”，为了避免配置过于复杂，先不勾选。\n\n其他的默认不动。点击保存配置。\n![](../../images/网络_校园网环境下的配置/image-20240823030118691.png)\n## DNS设置\n由于在校园网环境下使用，需要配置内网DNS。\n在DNS设置页面中，勾选“启用第二DNS服务器”，指定服务器为172.21.201.21。（BJUT的DNS有两个，172.21.201.21和172.21.201.20）\n下面的域名列表填入一行：`*.bjut.edu.cn`。\n点击保存配置。\n![](../../images/网络_校园网环境下的配置/image-20240823030355957.png)\nOpenClash推荐使用Dnsmasq转发，但是易用性实在难以恭维，在校园网环境下，先这样凑合用吧！\n## IPV6设置\n为了可以在代理上网的同时支持IPV6，需要勾选“IPv6流量代理”、“允许IPv6类型DNS解析”。\n除此之外，为了支持更多网站，勾选“UDP流量转发”。\nIPv6代理模式选择“Redirect模式”，具体原因忘记了。\n其他默认不变，保存配置。\n![](../../images/网络_校园网环境下的配置/image-20240823030727179.png)\n## 最后\n别忘了点应用配置，看看启动效果、上网效果。\n![](../../images/网络_校园网环境下的配置/image-20240823030832728.png)\n\n可以进3种控制面板选择节点。\n\n## 再次DNS配置\n不幸的是，根据测试，即使启用了第二DNS，也无法正常访问内网，比如lgn.bjut.edu.cn、my.bjut.edu.cn。而如果输入IP地址却能访问，显然还是DNS的问题。\n\n那么只能停用“插件设置-DNS设置”中的“本地DNS劫持”了。\n![](../../images/网络_校园网环境下的配置/image-20240823032504633.png)\n\n之后，在“覆写设置-DNS设置”中\n\n勾选“自定义上游DNS服务器”、“追加上游DNS”。\n![](../../images/网络_校园网环境下的配置/image-20240823032555109.png)\n\n并在下面“设置自定义上游 DNS 服务器”添加一个自定义DNS。\n![](../../images/网络_校园网环境下的配置/image-20240823032622741.png)\n\n![](../../images/网络_校园网环境下的配置/image-20240823032631949.png)\n\n至此，保存配置、应用配置。\n就可以访问内网了。\n# 成果\n可以多设备连接AP路由器愉快地网上冲浪了！\n并且实测，按以上配置，可以不关闭OpenClash的情况下，直接搭配“下载CDN重定向IPV6工具包”正常使用！","categories":["网络"]},{"title":"Floyd图算法中的动态规划_C语言实现","url":"/算法/Floyd图算法中的动态规划_C语言实现/","content":"# Floyd\n\nFloyd是图的经典算法，可以使用动态规划方法解决。但是真正写图搜索算法时不要用Floyd算法，因为它比Dijkstra较慢。但是Floyd对于算法思想的启发很有研究价值。实用价值、研究价值要辩证看。\n# 图\n\n和树一样，有好多节点，但没有树的规律。树是图的子集。\n\n1. 节点和节点之间可以是连通的也可以是不连通的。\n2. 连通的线如果没有方向则称之为无向图，如果有方向则为有向图。\n3. 如果有循环，则是有环图；如果没有循环则是无环图。\n\n1. 节点的出度：离开这个节点的线的个数；\n2. 节点的入度：进入这个节点的线的个数。\n\n应用：地图算法，搜索、寻路；软件工程中Element Block利用有向无环图进行拓扑排序，根据依赖关系、前置关系进行排序。但是还是没有树的应用范围广。\n\n网络路由选择：OSPF（开放式最短路径优先）中就用到了Dijkstra算法。配置路由表。\n\n## 术语\n\n1. 逆时针：CCW (Counter Clock Wise)\n2. 顺时针：CW (Clock Wise)\n\n## 计算机处理图实际的数据结构\n\n![image-20240314012545833](../../images/C语言_20240313_/image-20240314012545833.png)\n\n# Floyd - 动态规划思想\n\n从某一点到某一点，选择通路，求最短的路径长度。\n\n第一个参数是始发节点，第二个参数是目的节点。第三个参数是可以参与的节点范围（如果是4，则表示1、2、3、4节点全都可以参与），如果是0的话，表示没有中间节点参与。\n\n比如说：`floyd(from, to, n)`表示：从节点from走到节点to，节点1到n可以参与。求最短路径长度。\n\n运用背包问题的思想。\n\n```c\nfloyd(from, to, n)\n    不选择第n节点：floyd(from, to, n - 1)\n    选择第n节点：  floyd(from, n, n - 1) + floyd(n, to, n - 1)\n    最终结果：min {不选择, 选择}\n终止条件：\n    （1）没有节点参与时，即n == 0 - 结果值为权重表对应数值(某点直接到某点的距离)\n    （2）from == to，到达自身。  - 结果值为0\n递归方法的时间复杂度：3^n\n```\n\n## 递归法\n\n如果不选择节点n，则`from`到`to`还需在剩下的`n-1`节点中走。\n如果选择节点n，则问题分解成了`from`到节点`n`（确定走`n`，所以可以少走最后的一个节点，因此是`n-1`），加上剩下的`n`到`to`，需要在`n-1`个节点中走（因为已经到达了节点`n`，因此可以少走1个）（至于后半段的节点数为什么不是1？要正确理解参数3的意思，指的是可参与的节点，并不是说必须走n个（多于、少于n都可以））。\n\n\n```c\nint path[5][5] = {\n    { 0,   0,   0,   0,   0 },\n    { 0,   0, 100, 100,   1 },\n    { 0,   3,   0,  10,   5 },\n    { 0, 100,   9,   0, 100 },\n    { 0, 100, 100,   4,   0 }\n};\nint floyd_recur(int from, int to, int n)\n{\n    if (from == to)return 0;\n    if (n == 0)\n    {\n        return path[from][to];\n    }\n    int no = floyd_recur(from, to, n - 1);\n    int yes = floyd_recur(from, n, n - 1) + floyd_recur(n, to, n - 1);\n    return no <= yes ? no : yes;\n}\n```\n\n### 测试\n```c\nint floyd_recur(int from, int to, int n);\nint main()\n{\n    int shortest = floyd_recur(2, 3, 4); // 8\n    return 0;\n}\n```\n### 复杂度分析\n递归方法的时间复杂度：$3^n$\n## 迭代法\n\n![image-20240314024640598](../../images/C语言_20240313_/image-20240314024640598.png)\n\n因为有三个参数，所以需要三维数组来进行迭代。$n$的有效取值范围为$[0,4]$，0代表没有节点参与。而$from$和$to$的有效取值范围为$[1,4]$，即0是多余的，数组给出多余的1行1列只是为了方便编程。\n\n```c\nint shortpath[5][5][5];\nint floyd(int from, int to, int n)\n{\n    // n == 0 时\n    // 把path表格复制到第0面\n    // 行\n    for(int i = 0; i <= n; ++i)\n    {\n        // 列\n        for(int j = 0; j <= n; ++j)\n        {\n            shortpath[0][i][j] = path[i][j];\n        }\n    }\n    // 每一面的from == to 时，等于0\n    for(int k = 1; k <= n; ++k)\n    {\n        for(int i = 0; i <= n; ++i)\n        {\n            shortpath[k][i][i] = 0;\n        }\n    }\n    //根据第0面迭代\n    // k为对应n的面  i为对应from的行 j为对应to的列\n    // shortpath 第一个数为面 第二个数为from 第三个数为to\n    for(int k = 1; k <= n; ++k)\n    {\n        for(int i = 1; i <= n; ++i)\n        {\n            for(int j = 1; j <= n; ++j)\n            {\n                int no = shortpath[k - 1][i][j];\n                int yes = shortpath[k - 1][i][k] + shortpath[k - 1][k][j];\n                \n                shortpath[k][i][j] = no <= yes ? no : yes;\n            }\n        }\n    }\n    return shortpath[n][from][to];\n}\nint main()\n{\n    int shortest = floyd(2, 3, 4); // 8\n    return 0;\n}\n```\n### 复杂度分析\n\n$O(n^3)$\n\n# 各种图算法\nBFS、DFS、Dijkstra、Bellman-Ford（BF）、Floyd、Prim和Kruskal 等算法是图论和搜索领域中的核心算法，它们各有用途、适用场景和特性。在面试中，通常会从算法的**原理**、**适用场景**、**时间复杂度**、**空间复杂度**、以及一些**优化细节**来考查。因此，了解它们的关联与区别是非常重要的。\n\n1. 遍历算法\n    1. DFS\n    2. BFS\n2. 最短路径算法\n    1. Dijkstra（好）\n    2. Bellman-Ford（好、使用领域广泛，但是最坏性能差）\n    3. Floyd（性能不好）\n    4. 拓扑排序\n3. 最小生成树算法（连通图的子图）\n    1. Prim（不好）\n    2. Kruskal（好）\n## 1. 广度（BFS）和深度优先搜索（DFS）\n\n### 关联\n- BFS和DFS都是**图搜索算法**，用于遍历或搜索图的节点。\n- 两者都可以用于无向图和有向图，能够找到**可达性**，即从一个节点到其他节点的路径。\n### 区别\n- **BFS**：逐层扩展节点，适合寻找**最短路径（无权图）**。\n- **DFS**：沿路径深入搜索，适合找到**所有路径**或用于**图的拓扑排序**和**强连通分量**等应用。\n### 关键点\n- **时间复杂度**：O(V + E)，其中V是节点数，E是边数。\n- **应用场景**：BFS常用于无权最短路径、迷宫等问题；DFS常用于路径搜索、连通分量检测等。\n## 2. Dijkstra算法\n### 关联\n- **Dijkstra**是单源最短路径算法，与BFS类似，都用于路径搜索，但**适用于带权图**。\n- 与Bellman-Ford的区别在于它**不能处理负权边**。\n### 关键点\n- **时间复杂度**：$O((V + E) * log V)$（使用优先队列）。\n- **适用场景**：地图导航、网络路由（OSPF）、带权路径问题。\n- **限制**：不能处理负权边。面试中可能会询问原因，重点在于算法的贪心性质。\n### 与Floyd算法相比\n当我们主要用于搜索图时（搜索单源路径），尽量用Dijkstra算法，因为Floyd太耗时了。\n## 3. Bellman-Ford算法\n\n### 关联\n- 与Dijkstra一样，Bellman-Ford也用于单源最短路径。\n- Bellman-Ford与Dijkstra的不同之处在于它**可以处理负权边**，且可以检测**负权环**。\n### 关键点\n- **时间复杂度**：O(V * E)。\n- **适用场景**：处理负权边的路径问题，如金融图表中的盈亏边。\n- **特点**：可以检测负权环。面试中可能会问到与Dijkstra的区别以及负权环检测方法。\n## 4. Floyd算法\n\n### 关联\n\n- **Floyd**用于**多源最短路径**问题，与Bellman-Ford和Dijkstra不同，它直接求解图中**任意两点间的最短路径**。\n- 与Prim和Kruskal不同，它不用于生成树，而是直接在**邻接矩阵**上处理所有对路径的情况。\n### 关键点\n\n- **时间复杂度**：O(V^3)。\n- **适用场景**：计算稠密图中所有节点对的最短路径，尤其是对小规模图的处理。\n- **优缺点**：算法简单但复杂度较高；适用于小图。面试中可能会问到Floyd的实现及其适用范围。\n\n## 5. Prim算法和Kruskal算法\n\n### 关联\n\n- Prim和Kruskal都是最小生成树（MST）算法，通常用于无向图。\n- 它们都是贪心算法，通过不同的方法来构造最小生成树。\n### 区别\n\n- **Prim**：逐步扩展生成树的节点，适合稠密图。\n- **Kruskal**：通过选择最小的边逐步合并生成树，适合稀疏图。\n### 关键点\n\n- **时间复杂度**：Prim为O(E log V)（堆优化），Kruskal为O(E log E)。\n- **适用场景**：网络设计、最小代价连接等。\n- **优缺点**：Prim对稠密图较好，Kruskal对稀疏图较好。面试中常问到如何实现Union-Find（用于Kruskal中的连通性检测）。\n## 总结与面试中的关键考查点\n\n1. **算法适用场景**：每种算法都有特定的应用场景，面试中可能会考查候选人能否识别何时使用BFS、DFS、Dijkstra、Floyd或MST算法。\n2. **算法的优化和复杂度**：了解时间和空间复杂度，尤其是如何优化（如Dijkstra的优先队列优化，Kruskal的Union-Find等），可以帮助在面试中展示优化思维。\n3. **差异点**：\n    - Dijkstra与Bellman-Ford的差异：特别在处理负权边的能力上。\n    - Prim与Kruskal：适用图密度的不同，考查对图结构的理解。\n    - 多源最短路径（Floyd）与单源最短路径（Dijkstra、Bellman-Ford）的区别，考查对路径搜索的理解。\n4. **细节实现和边界情况**：面试中可能会问到实现细节和一些边界情况，比如：\n    - Dijkstra的贪心限制，无法处理负权边。\n    - Bellman-Ford如何检测负权环。\n    - Union-Find在Kruskal中的应用及优化。\n# Union-Find 并查集\n**Union-Find**（联合-查找）是一种用于处理**动态连通性**问题的数据结构，通常用于图的连通性检测、最小生成树（如Kruskal算法中的使用）、网络连接问题等。\n## 主要功能\n\nUnion-Find 数据结构主要提供两个操作：\n\n1. **Find**（查找）：用于查找某个元素所在的集合（也可以理解为查找某个元素的代表元素或根节点）。\n2. **Union**（合并）：将两个元素所属的集合合并成一个集合。\n\n这两个操作支持**高效的动态连接操作**，适用于处理图的连通性问题。例如，判断图中两个节点是否在同一连通分量中，或合并两个节点所属的连通分量。\n\n## 数据结构实现\n\nUnion-Find 使用一棵**树**来表示每个集合的结构。每个节点指向一个父节点，根节点代表整个集合。通过路径压缩和按秩合并（按大小合并）这两种技术，可以使操作的时间复杂度接近常数时间（$O(α(n))$，其中α是反阿克曼函数，是非常慢增长的）。\n### Find 操作\n- **目标**：查找一个元素属于哪个集合。即找到该元素的根节点。\n- **路径压缩**：为了优化后续查询，我们将路径中的所有节点都直接连接到根节点上，使得树更平衡，从而提高效率。\n\n```cpp\nint find(int x)\n{\n    if (parent[x] != x)\n    {\n        parent[x] = find(parent[x]);\n        // 递归查找并压缩路径\n    }\n    return parent[x];\n}\n```\n### Union操作\n\n- **目标**：将两个元素合并到同一个集合中。\n    \n- **按秩合并（Union by Rank/Size）**：将树小的根节点连接到大的根节点，保持树的平衡，避免树变得过高。\n\n```cpp\nvoid union(int x, int y)\n{\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY)\n    {  // 如果 x 和 y 不在同一集合\n        if (rank[rootX] > rank[rootY])\n        {\n            parent[rootY] = rootX;\n        }\n        else if(rank[rootX] < rank[rootY])\n        {\n            parent[rootX] = rootY;\n        }\n        else\n        {    \n            parent[rootY] = rootX;\n            rank[rootX]++;\n            // 增加秩\n        }\n    }\n}\n```\n## 时间复杂度\n\n- **Find** 和 **Union** 的时间复杂度是接近 O(α(n))，其中 **α(n)** 是反阿克曼函数，它增长非常慢，实际上几乎可以认为是常数时间（对于实际应用，α(n) 小于 5 即可）。\n- 因此，Union-Find 数据结构非常高效，适用于处理大规模的连通性问题。\n## 应用场景\n\n1. **判断两个元素是否在同一个集合中**：比如判断图中的两个节点是否连通。\n2. **最小生成树**：Kruskal 算法中用于判断两条边是否连接在同一个连通分量中，若是，则跳过；若不是，则合并两个分量。\n3. **网络连接问题**：如社交网络中的朋友关系，或者计算机网络中设备的连通性。\n4. **动态连通性**：例如实时地在网络中查询两个节点是否连通，并合并它们的连接。\n\n## 例子\n\n假设有一个图，节点为 0, 1, 2, 3，边为 (0,1), (1,2), (2,3)，我们可以用 Union-Find 来检测这些节点是否在同一个连通分量内，并且合并这些连通分量。\n\n```cpp\n#include <iostream>\n#include <vector>\n\nclass UnionFind {\nprivate:\n    std::vector<int> parent;\n    std::vector<int> rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;  // 初始化每个元素的父节点为自身\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);  // 路径压缩\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    UnionFind uf(4);\n\n    // 合并 (0, 1), (1, 2), (2, 3)\n    uf.unionSets(0, 1);\n    uf.unionSets(1, 2);\n    uf.unionSets(2, 3);\n\n    // 判断是否连通\n    std::cout << \"Is 0 and 3 connected? \" << (uf.find(0) == uf.find(3)) << std::endl;  // 输出 1，表示连通\n    std::cout << \"Is 0 and 2 connected? \" << (uf.find(0) == uf.find(2)) << std::endl;  // 输出 1，表示连通\n    std::cout << \"Is 0 and 4 connected? \" << (uf.find(0) == uf.find(4)) << std::endl;  // 输出 0，表示不连通\n\n    return 0;\n}\n\n```\n\n## 关键特性\n\n- **路径压缩**：使得树更加扁平化，提高查询效率。\n- **按秩合并**：合并两个集合时，保持树的平衡，减少树的高度，进一步优化性能。\n\n## 面试中可能的考点\n\n1. Union-Find的基本原理，尤其是如何实现`Find`和`Union`操作。\n2. **路径压缩**和**按秩合并**的优化思路及其时间复杂度。\n3. 在图算法中（特别是Kruskal算法）如何利用Union-Find来解决连通性问题。\n4. 处理**动态连通性**时的常见问题，如如何动态添加边、合并不同的子图等。\n\n总之，Union-Find 是一种非常高效的解决动态连通性问题的数据结构，是图论问题中不可或缺的工具之一，特别在处理大规模图的场景中表现尤为突出。","categories":["C","算法","动态规划","图"]},{"title":"动态规划_C语言实现","url":"/算法/动态规划_C语言实现/","content":"# 动态规划\n\n高阶马尔科夫模型。\n\n一个问题是否是动态规划，决定因素在于某一状态是否依赖于前面的一些状态，至少要依赖多于一种的状态才行。贪心算法其实也是动态规划的一种，可以转化为简单的动态规划。而动态规划与贪心的区别就在于动态规划的眼光比较长远，而贪心只顾及眼前的利益。\n\n动态规划常能解决的有：01背包问题。\n\n简单来说动态规划就是把难以解决的问题分割为很多结构相似的小问题。\n\n# Fibonacci\n\n斐波那契数列。\n\n```\n1 1 2 3 5 8 13 21 34 55 89\n\n```\n\n## 递归法\n\n```c\nint fibo(int n)\n{\n    if(n == 1 || n == 2)\n    {\n        return 1;\n    }\n    return fibo(n - 1) + fibo(n - 2);\n}\n```\n\n测试\n\n```c\nint main(void)\n{\n    int i = fibo(8);\n    return 0;\n}\n```\n\n## 迭代法\n\n即循环，无需硬件栈，速度更快，状态不重复，但是需要依赖表格。\n\n```c\nint fibo2(int n)\n{\n    int dp[50] = {0};\n    dp[1] = 1;\n    dp[2] = 1;\n    for(int i = 3; i <= n; ++i)\n    {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n}\n```\n\n# 背包\n\n起始于一种状态：有一个包，小偷偷东西，有大有小，有贵有贱。那么小偷就要考虑如何在有限的容量下拿尽多价值的东西。\n\n| item | Value | Weight |\n| ---- | ----- | ------ |\n| 0    | 5     | 9      |\n| 1    | 9     | 11     |\n| 2    | 7     | 6      |\n| 3    | 11    | 15     |\n| 4    | 16    | 18     |\n| 5    | 13    | 14     |\n\n## 递归法\n\n```c\nint vals[] = {5, 9, 7, 11, 16, 13};\nint weights[] = {9, 11, 6, 15, 18, 14};\nint ks(int n, int cap)\n{\n    if(n == 0)\n    {\n        return cap >= weights[n] ? vals[n] : 0;\n    }\n    // 如果不选，则价值为：\n    int no = ks(n - 1, cap);\n    // 如果选择的价值：（先初始化为不选）\n    int yes = no;\n    if(cap >= weights[n])\n    {\n        yes = ks(n - 1, cap - weights[n]) + vals[n];\n    }\n    return no >= yes ? no : yes;\n}\n```\n\n测试，结果应为45\n\n```c\nint main()\n{\n    int i = ks(5, 50);\n}\n```\n\n## 迭代法\n\n```c\nint vals[] = {5, 9, 7, 11, 16, 13};\nint weights[] = {9, 11, 6, 15, 18, 14};\nint ks2(int n, int cap)\n{\n    // 6行 51列\n    int res[6][51] = {0};\n    // 初始化表格\n    // i指的是背包目前的容量\n    for(int i = 0; i <= 50; ++i)\n    {\n        if(i < weights[0])// weights[0]对应于 第0号物品的重量\n        {\n            res[0][i] = 0;\n        }\n        else\n        {\n            res[0][i] = vals[0];\n        }\n    }\n    // 遍历计算每一个状态\n    // 行 对应于n\n    for(int i = 1; i <= n; ++i)\n    {\n        // 列 对应于cap\n        for(int j = 0; j <= cap; ++j)\n        {\n            int no = res[i - 1][j];\n            int yes = no;\n            if(j >= weights[i])\n            {\n                yes = vals[i] + res[i - 1][j - weights[i]];\n            }\n            res[i][j] = no >= yes ? no : yes;\n        }\n    }\n    return res[n][c];\n}\n```\n\n测试，结果应为45\n\n```c\nint main()\n{\n    int i = ks2(5, 50);\n}\n```\n\n# 背包变型 - 凑数\n\n```c\nnums[] = 5 8 1 3 9 2 4 7 6 -> 能不能凑出25\nbool mk_sum(n, target_val)\n不取：mk_sum(n - 1, target_val)           ->能不能从剩下的n-1个中凑出tar\n取： mk_sum(n - 1, target_val - nums[n])  ->能不能从剩下的n-1中凑出tar-nums[n]\n    \n两个状态之间应该取OR（或）的关系，只要有一边可以达到，则就可以凑出25\n    \n终止条件：\n    （1）n = 0，此时看target_get和第0个数是否相等。\n    （2）或者target_val为0（全不选即可凑为0）\n```\n\n```c\nint sums[] = {5, 8, 1, 3, 9, 2, 4, 7, 6};//9个数\nint mk_sum(int n, int target_val)\n{   \n    // 终止条件\n    if(target_val == 0)return 1; //true\n    if(n == 0)return target_val == nums[0];\n    int no = mk_sum(n - 1, target_val);\n    int yes = no;\n    if(target_val >= nums[n])\n    {\n        yes = mk_sum(n - 1, target_val - nums[n]);\n    }\n    return no || yes;\n}\n```\n\n## 迭代法\n\n```\nn ∈ [0, 8]\ntarget ∈ [0, 99] //其实target应该无上限才对，本例只看99以下的凑数情况\n所以需要 9 × 100 的数组\n```\n\n\n\n```c\nint sums[] = {5, 8, 1, 3, 9, 2, 4, 7, 6};\nint mk_sum2(int n, int target_val)\n{\n    char res[9][100] = {0};//因为表中的值只能有0、1，为了节省空间，用char\n    for(int i = 0; i <= n; ++i)\n    {\n        res[i][0] = 1;// 第0列，代表target_val为0，此时为凑0，即全不选即可\n    }\n    // 以下for其实可以替换为一句话：res[0][nums[0]] = 1\n    for(int j = 1; j <= target_val; ++j)\n    {\n        // 在第0个数时，为一个终止条件，看j正好与自身nums[0]相等时正好能凑\n        res[0][j] = j == nums[0];\n    }\n    // 计算表格中每一个状态\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= target_val; ++j)\n        {\n            char no = res[i - 1][j];\n            char yes = no;\n            if(nums[i] <= j)\n            {\n                yes = res[i - 1][j - nums[i]];\n            }\n            res[i][j] = yes || no;\n        }\n    }\n    return res[n][target_val];\n}\n```\n\n测试，结果应为1\n\n```c\nint main()\n{\n    char i = mk_sum2(8, 45);//从八个数中凑45\n}\n```\n\n# 每次两边二选一最后总数最大\n若干个小球排列成一排，每个小球上面写有一个整数。\n玩家a和玩家b依次拿走小球，一名玩家一次只能拿一个球，规定玩家a先拿，玩家b后拿，但是每个玩家每次只能拿走最左或最右的球。\n游戏结束时，每个玩家已经拿走的球上面的数字之和就是他得到的分数。\n玩家a和玩家b都绝顶聪明，他们总会采用最优策略。\n请返回最后获胜者的分数。\n\n示例：\n小球序列用一个整型数组 A 表示。\n如：`arr = [1,2,100,3]`\n开始时玩家A只能拿走`1`或`3`。如果玩家A拿走1，则排列变为`[2,100,3]`，接下来玩家B可以拿走`2`或`3`，然后继续轮到玩家A。如果开始时玩家A拿走`3`，则排列变为`[1,2,100]`，接下来玩家B可以拿走`1`或`100`，然后继续轮到玩家A。玩家A作为绝顶聪明的人不会先拿`3`，因为拿了`3`之后玩家B将拿走`100`。所以玩家A会先拿`1`，让排列变为`[2,100,3]`，接下来玩家B不管怎么选，`100`都会被玩家A拿走、玩家A会获胜，分数为`101`。所以返回`101`。\n如：`arr = [1,100,2]`\n开始时玩家A不管拿`1`还是`2`，玩家B作为绝顶聪明的人，都会把`100`拿走。玩家B会获胜，分数为`100`，所以返回`100`。\n## 结构体\n可以自定义一个结构体，最后返回这个结构体，从而可以分析两个记录值。\n```cpp\ntypedef struct _Score\n{\n    int current;\n    int other;\n}Score;\n```\ncurrent代表当前人的总分数，other代表另一个人的总分数。\n第一次选时，假设current是A，other是B。\n则第二次选时（问题深度加1），current是B，other是A。\n可以用king代表函数名，函数中有两个参数，`left`代表最左数的下标，`right`代表最右数的下标。\n`king(left, right)`表示A先选，返回值`current`表示A在`left`到`right`之间，和B一起轮流选后的总分，other表示B的总分。\n通过分析，可以清晰地知道，只有`left`和`right`两个通路，以此可以递推出两个迭代函数。\n```\n1 2 100 3\n\nking(left, right) = ?\n\n最后最高得分：\n第1人（A）选择left:  king(left + 1, right)  -- 此时Current变为B\n第1人（A）选择right: king(left, right - 1)  -- 此时Current变为B\n```\n## 递归法\n```c\n#include<iostream>\ntypedef struct _Score\n{\n    int current;\n    int other;\n}Score;\nint arr[] = { 1, 2, 100, 3 };\n\nScore king_recur(int left, int right)\n{\n    Score score;\n    if (left == right)\n    {\n        score.current = arr[left]; // left == right, 只有一个数\n        score.other = 0;\n        return score;\n    }\n    Score left_score  = king_recur(left + 1, right);\n    Score right_score = king_recur(left, right - 1);\n    // left_score.other + arr[left]   表示 上次选的人 选择左之后 的分数\n    // left_score.other + arr[right]  表示 上次选的人 选择右之后 的分数\n    // left_score.current             表示  这次要选的人        的分数\n    // 如果 上次的人选 左边 之后 的 分数 减去 这次要选的人 的分数，\n    // 比  上次的人选 右边 之后 的 分数 减去 这次要选的人 的分数大，则 上次的人（current）选左边：\n    if (left_score.other + arr[left] - left_score.current >= right_score.other + arr[right] - right_score.current)\n    {\n        // 上次的other成为了这次的current，选了左边，因此current = other+arr[left]\n        score.current = left_score.other + arr[left];\n        // 上次的current成为了这次的other\n        score.other   = left_score.current;\n    }\n    else // 否则，上次的人（current）就选右边。\n    {\n        score.current = right_score.other + arr[right];\n        score.other   = right_score.current;\n    }\n    return score;\n}\nint main()\n{\n    Score score = king_recur(0, 3);\n    std::cout << \"A: \" << score.current << \", B: \" << score.other << std::endl;\n}\n```\n\n测试：A: 101, B: 5\n### 复杂度分析\n每一次迭代有2个分支，因此递归法的时间复杂度为$O(2^n)$。\n## 迭代法\n\n终止条件是：`left == right`。这时只剩下一个球，只能选择这个球，此时值为这个球的数字。\n因此，在迭代法中，就可以先以对角线斜行进行初始化。\n还有一些可以轻松排除的：left不可能大于right，这些位置的值都无效，左下半角数值无意义。\n\n![](../../images/C语言_20240223_0310_动态规划/image-20241115035830301.png)\n接下来，我们再来分析`left = 0, right = 1`的情况：\n1. 如果上一次的人选走了0号（1），那么`king(0, 1) => current = 2, other = 1`\n2. 如果上一次的人选走了1号（2），那么`king(0, 1) => current = 1, other = 2`\n3. 即每一个格子的值都依赖于左边的格或下边的格。\n    1. 如果选了左边，则和下方格的other加和，作为当前current，与下方格的current对比，求差值=`左other+下数字价值-左current`\n    2. 如果选了下边，则和左方格的other加和，作为当前current，与左方格的current对比，求差值=`下other+左数字价值-下current`\n    3. 如果差值1大于差值2，则选左边；如果差值2大于差值1，则选右边。\n\n这种需要依赖左1和下1的，需要斜着迭代，而不是简单地一行一行、一列一列地。\n```c\nint arr[] = { 1, 2, 100, 3 };\nScore scores[4][4];\nScore king_interation(int left, int right)\n{\n    for (int i = left; i <= right; ++i)\n    {\n        scores[i][i].current = arr[i];\n        scores[i][i].other   = 0;\n    }\n    std::cout << \"Matrix:\" << std::endl;\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            std::cout << scores[i][j].current << \",\" << scores[i][j].other << \" \";\n        }\n        std::cout << std::endl;\n    }\n    for (int j = left + 1; j <= right; )\n    {\n        int i;\n        for (i = left; i <= right - (j - i); ++i, ++j)\n        {\n            // i小，j大\n            // 选右边的情况 优于 选左边的情况\n            if (scores[i][j - 1].other + arr[j] - scores[i][j - 1].current >= scores[i + 1][j].other + arr[i] - scores[i + 1][j].current)\n            {\n                // 左边的other（以前选的）+ 这次选的右边\n                scores[i][j].current = scores[i][j - 1].other + arr[j];\n                scores[i][j].other = scores[i][j - 1].current;\n            }\n            else// 选右边的情况 差于 选左边的情况\n            {\n                // 右边的other（以前选的）+ 这次选的左边\n                scores[i][j].current = scores[i + 1][j].other + arr[i];\n                scores[i][j].other = scores[i + 1][j].current;\n            }\n        }\n        j = j - i + 1;\n    }\n    return scores[left][right];\n}\nint main()\n{\n    score = king_interation(0, 3);\n    std::cout << \"Matrix:\" << std::endl;\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            std::cout << scores[i][j].current << \",\" << scores[i][j].other << \" \";\n        }\n        std::cout << std::endl;\n    }\n    std::cout << \"A: \" << score.current << \", B: \" << score.other << std::endl;\n}\n```\n### 优化逻辑\n其实可以直接比较得分而无需计算差值。\n我们之所以不使用“差值”进行比较，是因为这里的目标并不是仅仅**最大化与对手的得分差**，而是**获得尽可能多的分数**。在这个游戏的规则下：\n- 每个回合的目标是为当前玩家（无论是A还是B）取得当前回合的最高得分；\n- 同时，下一轮再以递归的方式计算对手得分的最大化策略。\n\n因此，**差值并不能准确反映最佳选择**，因为差值只考虑到某一轮次的得失，而不是整个局面的最优解。而在动态规划中，我们将所有可能的得分组合记录下来，从而避免错过任何潜在的最优策略。\n```cpp\nScore king_interation(int left, int right)\n{\n    for (int i = left; i <= right; ++i)\n    {\n        scores[i][i].current = arr[i];\n        scores[i][i].other   = 0;\n    }\n    std::cout << \"Matrix:\" << std::endl;\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            std::cout << scores[i][j].current << \",\" << scores[i][j].other << \" \";\n        }\n        std::cout << std::endl;\n    }\n    for (int j = left + 1; j <= right; )\n    {\n        int i;\n        for (i = left; i <= right - (j - i); ++i, ++j)\n        {\n            // 选择左边或右边球\n            int pickLeft = arr[i] + scores[i + 1][j].other;\n            int pickRight = arr[j] + scores[i][j - 1].other;\n        \n            // 选择更优策略\n            if (pickLeft > pickRight) {\n                scores[i][j].current = pickLeft;\n                scores[i][j].other = scores[i + 1][j].current;\n            }\n            else {\n                scores[i][j].current = pickRight;\n                scores[i][j].other = scores[i][j - 1].current;\n            }\n        }\n        j = j - i + 1;\n    }\n    return scores[left][right];\n}\n```\n### 动态规划与贪心的区别\n\n在这个动态规划的方案中：\n1. **完整性**：动态规划表记录了从每一个子问题的解开始，构建整个问题的解。这样就保证了即使在更早的步骤中没有获得“局部最高得分”，也能通过累计得到最终的最优解。\n2. **非贪心性**：如果采用贪心策略，每一步都会选择当前“最显眼”的得分选项（例如，选择最大值或最小值），忽视之后的可能得分。然而动态规划在 `scores[i][j]` 中记录了所有可能选项带来的得分情况，使得每一步都是基于整体最优，而非局部最优。对于 `[0, 3]` 的序列，不直接依赖于局部差值，而是递归地从 `scores[0][1], scores[1][3]` 等子问题的最优解构建整个区间的最优解。\n## 总结\n这道题的难点在于：current、other这两个变量名我们是固定好的，但是每一次选完之后，current和other的实际身份互换。要在错综复杂的分析中明确迭代方程在本层与上一层之间的联系、区别。同时，if条件表达式比较长，需要保持清楚的逻辑分析出，究竟需要看什么条件，此题不只是简单的看谁最终取得最大值，而是在过程中，看A选左边或右边之后，与B的差值，哪个大。\n# Playing with Beads\nThere are `N` people in a group labeled from `1` to `N`. People are connected to each other via threads in the following manner.\nThe person with label number `K` is connected to all the persons with label `J` such that `J` exactly divides `K`. Beads can be passed through the threads. If a person `P` has a bead, in how many ways can the bead be passed in the network of threads so that it returns to the same person within `X` moves or less?\n\nMOVE: Passing the bead from one person to the other.\n\nInput specification:\ninput1: `N`, denoting the number of people.\ninput2: `P`, label of the person having the bead\ninput3: `X`, maximum number of moves that can be made\n\nOutput specification:\nYour function should return the total number of ways in which the bead will return to its initial position within `X` moves.\n\nExample 1:\n```\ninput1: 3\ninput2: 2\ninput3: 2\n\nOutput: 1\n\nExplanation:\nOnly 1 way:\n2->1->2\n```\nExample 2:\n```\ninput1: 3\ninput2: 2\ninput3: 4\n\nOutput: 3\n\nExplanation:\n3 ways:\n2->1->2\n2->1->3->1->2\n2->1->2->1->2\n```\n## 分析\n假如K可以被J整除，则K和J相连。相连者可以互传球。\n1. 输入1：共有N个人。标记为1到N。\n2. 输入2：从P开始传球\n3. 输入3：在X步内，有多少种方法可以传回同一人？\n\n## 递归法\n```cpp\n#include<iostream>\nint n;\nint begin;\nint playbeads_recur(int p, int x)\n{\n    int sum = 0;\n    if (x == 0)\n    {\n        std::cout << \"End\" << std::endl;\n    }\n    else\n    {\n        for (int i = 1; i <= n; ++i)\n        {\n            if ((i % p == 0 || p % i == 0) && (i != p))\n            {\n                std::cout << p << \"->\" << i << \", \" << std::endl;\n                if (i == begin)\n                {\n                    sum += 1;\n                    std::cout << \"This is a Way\" << std::endl;\n                }\n                sum += playbeads_recur(i, x - 1);\n            }\n        }\n    }\n    return sum;\n}\nint main()\n{\n    n = 3;\n    begin = 2;\n    int x = 4;\n    int sum = playbeads_recur(begin, x);\n\n    std::cout << \"Total Ways: \" << sum << std::endl;\n}\n```\n结果：\n```\n2->1,\n1->2,\nThis is a Way\n2->1,\n1->2,\nThis is a Way\nEnd\n1->3,\nEnd\n1->3,\n3->1,\n1->2,\nThis is a Way\nEnd\n1->3,\nEnd\nTotal Ways: 3\n```\n## 迭代法\n```cpp\n#include<iostream>\nint n;\nint begin;\nint arr[4][5];\nint playbeads(int p, int x)\n{\n    for (int i = 0; i <= n; ++i)\n    {\n        for (int j = 0; j <= x; ++j)\n        {\n            arr[i][j] = 0;\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        if (begin == i)\n        {\n            arr[i][0] = 1;\n        }\n    }\n    std::cout << \"Matrix\" << std::endl;\n\n    for (int i = 0; i <= n; ++i)\n    {\n        for (int j = 0; j <= x; ++j)\n        {\n            std::cout << arr[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    // i 是 第几人\n    // j 是 剩下几步\n    for (int j = 1; j <= x; ++j)\n    {\n        for (int i = 1; i <= n; ++i)\n        {\n            // 注意，i==begin 且 j==x时表示第一步球在p手中，不能算\n            if (i == begin && j != x)\n            {\n                arr[i][j] += 1;\n            }\n            for (int k = 1; k <= n; ++k)\n            {\n                if ((i != k) && (i % k == 0 || k % i == 0))\n                {\n                    arr[i][j] += arr[k][j-1];\n                }\n            }\n        }\n    }\n    std::cout << \"Matrix\" << std::endl;\n    for (int i = 0; i <= n; ++i)\n    {\n        for (int j = 0; j <= x; ++j)\n        {\n            std::cout << arr[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return arr[p][x];\n}\nint main()\n{\n    n = 3;\n    begin = 2;\n    int x = 4;\n    //int sum = playbeads_recur(begin, x);\n    int sum = playbeads(begin, x);\n    std::cout << \"Total Ways: \" << sum << std::endl;\n}\n```\n输出：\n```\nMatrix\n0 0 0 0 0\n0 0 0 0 0\n1 0 0 0 0\n0 0 0 0 0\nMatrix\n0 0 0 0 0\n0 1 1 3 3\n1 1 2 2 3\n0 0 1 1 3\nTotal Ways: 3\n```\n# ","categories":["C","算法","动态规划"]},{"title":"C语言_串匹配算法","url":"/C/C语言_串匹配算法/","content":"# 串的匹配\n\n串的匹配就是从大的字符串中找到字串，并且返回第一个字串的位置。\n\nC语言库函数有一个`strstr`，是朴素的串匹配算法，也叫BF算法。\n```c\nint BF(string source, string pattern)\n{\n    int i = 0;\n    int j = 0;\n    while(i < source.size() && j < pattern.size())\n    {\n        if(source[i] == pattern[j])\n        {\n            ++i;\n            ++j;\n        }\n        else\n        {\n            i = i - j + 1;//后退j个字符，再进1\n            j = 0;\n        }\n    }\n    if(j == pattern.size())//如果pattern的j走到了最后，则说明已经全部匹配\n    {\n        return i - j;\n    }\n    return -1;\n}\n```\n\n# KMP算法\n\n是一个升级版的串匹配算法，名字取自三个人名（Knuth-Morris-Pratt）。\n\n总地来说，KMP的核心效果就是让原串的指示器不用退回。如何达到这个效果？就是考虑和模式串已经匹配的部分。这一部分模式串的**子串**，如果后缀有和前缀相重复的部分，则就可以跳过这些部分，即跳过前缀，在前缀的后一个字符开始再次比对（实际操作中，原串指示器不动，而是模式串的指示器回退到当时**子串**前缀的后一个字符位置）。\n\n于是，整个问题的核心，就从关注原串变到关注模式串本身了。需要找到模式串的不同长度（起点一致，不能从中间分割）下子串的前缀后缀相等的前缀（后缀）最大长度，从而建立一个所谓的next数组。\n\n这个next数组，教科书的求法是：\n```c\nint * getNext(string str)\n{\n    int * next = new int[str.size()];\n    \n    int j = 0;   // j 用来遍历子串\n    int k = -1;   // k 用来表示公共前后缀的长度\n    next[0] = -1; // 表示，当第0个字符都已经匹配失败了，则原串前进1，模式串位置给-1，前进1后自然地（巧妙处理）到0位置。\n    while(j < str.size() - 1)//size不包括\\0，即不处理最后一位字符位置\n    {\n        if(-1 == k || str[j] == str[k])\n        {\n            ++j;\n            ++k;\n            next[j] = k;\n        }\n        else\n        {\n            k = next[k];     //如果在找相同的后缀失配，同样也可以使用KMP的思想，在已匹配的这部分字符串中找相同的前后缀部分，从而去回溯k！比如：如果没有相同前后缀，则k为0\n            // 这里巧妙地复用了next数组，因为在推进k的过程中，观察的也是这个模式串的一部分，所以可以使用此next作为前缀的next！\n        }\n    }\n}\nint KMP(string source, string pattern)\n{\n    int i = 0;\n    int j = 0;\n    int * next = getNext(pattern);//add\n    while(i < source.size() && j < pattern.size())\n    {\n        if(source[i] == pattern[j])\n        {\n            ++i;\n            ++j;\n        }\n        else// modify\n        {\n            j = next[j];   \n        }\n    }\n    if(j == pattern.size())//如果pattern的j走到了最后，则说明已经全部匹配\n    {\n        return i - j;\n    }\n    return -1;\n}\n```\n上面这个求next数组的代码虽然看起来很简洁，但要彻底理解，还是比较难的，因为代码的细节处理得很巧妙，其中`k = next[k]`更是复用了KMP的next数组思想。\n这个求`getNext`的函数可以优化，避免模式串中重复的字段：见ShiLei算法180节\n比如：`abcabc`的next数组如果没有优化，则会成为`-1 0 0 0 1 2`，而经过优化以后：`-1 0 0 -1 0 0`\n```c\nint * getNext(string str)\n{\n    int * next = new int[str.size()];\n    \n    int j = 0;   // j 用来遍历子串\n    int k = -1;   // k 用来表示公共前后缀的长度\n    next[0] = -1; // 表示，当第0个字符都已经匹配失败了，则原串前进1，模式串位置给-1，前进1后自然地（巧妙处理）到0位置。\n    while(j < str.size() - 1)//size不包括\\0，即不处理最后一位字符位置\n    {\n        if(-1 == k || str[j] == str[k])\n        {\n            ++j;\n            ++k;\n            // 优化：如果发现此时k的位置字符和j的字符一样，则说明遇到了重复的字段，则继续进行回退，就省去了在kmp处理中多余的回退。\n            if(str[k] == str[j])\n            {\n                next[j] = next[k];\n            }\n            else\n            {\n                next[j] = k;\n            }\n        }\n        else\n        {\n            k = next[k];     //如果在找相同的后缀失配，同样也可以使用KMP的思想，在已匹配的这部分字符串中找相同的前后缀部分，从而去回溯k！比如：如果没有相同前后缀，则k为0\n            // 这里巧妙地复用了next数组，因为在推进k的过程中，观察的也是这个模式串的一部分，所以可以使用此next作为前缀的next！\n        }\n    }\n}\n```\n还有一个更直白的找模式串子串的前后缀最大长度的方法如下：\n```c\nint PMT[50] = {0};\nvoid init_pmt(char const * pattern)\n{\n    int len = strlen(pattern);\n    char sub[50] = {'\\0'};\n    for(int i = 1; i <= len; ++i)\n    {\n        strncpy(sub, pattern, i);\n        sub[i] = '\\0';\n        char prefix[50] = {'\\0'};\n        char suffix[50] = {'\\0'}\n        for(int j = 1; j <= i - 1; ++j)\n        {\n            strncpy(prefix, sub, j);\n            prefix[j] = '\\0';\n            strcpy(suffix, sub + i - j);\n            if(strcmp(prefix, suffix) == 0)\n            {\n                PMT[i - 1] = j;\n            }\n        }\n    }\n}\nint kmp(char const * source, char const * pattern)\n{\n    //i 指示 原串，j指示模式串\n    int i = 0, j = 0;\n    while(source[i] && pattern[j])\n    {\n        if(source[i] == pattern[j])\n        {\n            ++i;\n            ++j;\n        }\n        else //仅仅是这里与BF不一样。\n        {\n            // 首位不相等，i进1\n            if(j == 0)\n            {\n                ++i;\n            }\n            else// 除了首位不相等j归0外，其他情况为回退j，回退多少？查表\n            {\n                j = PMT[j - 1];// j - 1是已匹配了的最后位置\n            }\n        }\n    }\n    if(pattern[j] == '\\0')//如果j移到了最后，说明已经匹配到\n    {\n        return i - j;//返回的是原串中 匹配到的模式串的起始位置\n    }\n    return -1;\n}\n```\n![image-20240320015452152](../../images/C语言_20240214_20240219_串匹配算法/image-20240320015452152.png)\n\n# Bayer Moore\n\n## 坏字符\n\n每次把目标字符串和原字符串从后往前比较，如果某位置对应不上，则原字符串的这个字符称为“坏（bad）”字符。需要在目标字符串从后往前**继续寻找**（已经在之前匹配上的字符跳过）与这个bad字符相等的字符，然后按照这个相等字符的位置与原字符串的坏字符位置对齐（后移目标字符串）；如果在目标字符串中没找到坏字符，则把目标字符串整体后移到坏字符位置的下一个位置。对齐之后，重新把目标字符串和原字符串从后往前比较。\n\n找匹配串中下一个坏字符，需要告诉：当前坏字符是什么（原串中的字符），当前坏字符位置在哪（模式串中的下标值），以及目标串指针。即从匹配串中的坏字符的位置的前一个位置开始找下一个相同的字符。\n\n```c\nint next_bad(char bad, char const * pattern, int wherebad)\n{\n    // pattern串中从后往前找与原串的坏字符相同的字符，从哪里坏的位置的前一个开始\n    // 若未找到字符则i = -1自然退出\n    int i = -1;\n    for (i = wherebad - 1; i >= 0; --i)\n    {\n        if (pattern[i] == bad)\n        {\n            break;\n        }\n    }\n    return i;\n}\n```\n\n## 好后缀\n\n在模式字符串从后往前与原串一一匹配的过程中，遇到了坏字符，那么坏字符之后的，即已经匹配上了的在后面的部分串称之为好后缀。那么，我们可以去寻找模式字符串中还是否存在好后缀。如果存在，则可以让模式字符串的下一个好后缀与原串的当前位置的好后缀对齐，从而达到让模式串快速前进。\n\n**好后缀的思想很类似于KMP算法，即找公共前后缀，让重复的前缀对齐原串的后缀位置。但是区别就在于，BM算法是从后往前去匹配的，找到好后缀的同时，顺带着也找到了坏字符的位置。**\n\n下一个坏字符与原串当前坏字符对齐，或者下一个好后缀与原串当前好后缀对齐，模式字符串前进的步数会不一样，那么，就可以去对比哪个可以前进得更多。\n\n那么，类似于KMP地，去聚焦于模式字符串本身，不同点在于，每次寻找后缀都是从右向左寻找最近的下一个好后缀。（如果找的不是最近的而是靠左的下下个好后缀的话，那么模式字符串在BM算法前进过程中就会步子迈大了，跳过了可能完全成功匹配的机会）\n\n去建立一个`SUFFIX_TB`表格，下标值`i`代表**此位置**开始的后缀字符串，内容值`SUFFIX_TB[i]`代表**左边下一个最近的好后缀的下标位置**。\n`SUFFIX_TB`表格起初把全部值初始化为`-1`。表示当前`i`位置时没找到下一个好后缀。\n```c\nint SUFFIX_TB[50] = {0};\nvoid init_suffix(char const * const pattern)\n{\n    int pattern_len = strlen(pattern);\n    char sub[50] = {'\\0'};\n    \n    for(int i = 0; i < 50; ++i)\n    {\n        SUFFIX_TB[i] = -1;\n    }\n    // i指示的是后缀的起始位置，从第1个下标位置开始找\n    for(int i = 1; i < pattern_len; ++i)\n    {\n        // 当前要找的好后缀为 i下标位置开始到最后 \n        strcpy(sub, pattern + i);\n        // 从好后缀开始的位置（i下标）的上一个开始，从右向左比较，因为要找最近的\n        for(int j = i - 1; j >= 0; --j)\n        {\n            // sub是要找的好后缀。pattern + j是要对比的字符串的起始位置，他们的长度都应为pattern_len - i\n            if(strncmp(sub, pattern + j, pattern_len - i) == 0)\n            {\n                // 找到从右往左的最近的下一个好后缀，更新表格。i代表此位置开始的后缀字符串。j代表下一个好后缀的起始位置。\n                SUFFIX_TB[i] = j;\n                // 不要忘记break！如果不break继续找的话，左边可能有另一个完全匹配的好后缀，会覆盖掉\n                break;\n            }\n        }\n    }\n}\n```\n封装到`next_good`函数，参数只需要一个wherebad，即坏字符的位置（模式串中的下标值），那么就可以确定好后缀的位置了（即坏字符的下一个位置）。\n```c\nint next_good(int wherebad)\n{\n    return SUFFIX_TB[wherebad+1];\n}\n```\n## 实现BM算法\n\n每次比较选择坏字符和好后缀哪个可以让模式字符串走的更远。参数一个原串指针，一个模式串指针。返回值为匹配成功后，原串中目标子串的起始下标值。如果没找到则返回`-1`。\n\n```c\nint boyer_moore(char const* const source, char const* const pattern)\n{\n    init_suffix(pattern);\n    int src_len = strlen(source), pattern_len = strlen(pattern);\n    // 因为BM是从后往前比对的，因此，初始值都是 模式串 最后位置的下标值-1\n    int i = pattern_len - 1, j = pattern_len - 1;\n    // 循环寻找目标串的条件是 原串i 没到结尾\n    // 这个循环处理的是i，即只要遇到失配的情况，则i前进，j重新对齐下一个位置进行再次一一匹配。\n    while (i < src_len)\n    {\n        // 这个循环处理的是j。只要模式串j和原串i位置的字符相等，则j和i同时左移1。同时j的值需要大于等于0。\n        while (source[i] == pattern[j] && j >= 0)\n        {\n            --i;\n            --j;\n        }\n        // 如果退出了小while循环，则有两种情况\n        //情况1： j < 0, 说明模式串j走到最左，则完全匹配。此时i位置处在目标子串开始的前一个位置。则结果应返回i+1\n        if (j < 0)\n        {\n            return ++i;\n        }\n        //情况2： 此时出现失配，即原串的i位置字符失配。\n            // 参数：当前坏字符是什么（原串中的字符）；目标串指针；当前坏字符位置在哪（模式串中的下标值）\n        int next_bad_index = next_bad(source[i], pattern, j);\n        int next_good_index = next_good(j);\n        // 对比这两个值。选择哪个？\n\n        // 如果坏字符、好后缀都没找到      0  0 模式串起始点重新对齐到i的下一个位置，i再挪到最后\n        // 如果没找到坏字符，找到了好后缀  0  1 由于没找到坏字符，则有好后缀也没意义了，所以与0 0一样：模式串起始点重新对齐到i的下一个位置，i再挪到最后\n        // 如果找到了坏字符，没找到好后缀  1  0 虽然好后缀是-1，看起来可以跳过很多，但是！由于存在坏字符，不能一下略过去，所以不能选择好后缀。要选择坏字符位置值\n        // \n        // 总结：只要有一个没找到，则二者最小值为 -1。模式串起始点都是重新对齐到i的下一个位置\n\n        // 如果找到了坏字符，找到了好后缀   1  1\n            // 再次分情况：看next_good和next_bad谁值小，选谁。\n        //总结：取二者最小值。\n            //如果是好后缀则将相当于可以把模式串后移j - next_good + 1。\n            //如果是坏字符则将相当于可以把模式串后移j -  next_bad。\n                //如果两个都是最小值。即相等，则优先选择好后缀，因为对齐时，好后缀比坏字符更能多进1位。\n                //如果最小值为-1，则模式串起始点重新对齐到i的下一个位置\n        if (next_bad_index == -1 || next_good_index == -1)\n        {\n            if (next_bad_index == -1)\n            {\n                i += j + 1;\n            }\n            else if(next_good_index == -1)\n            {\n                i += pattern_len - 1 - next_bad_index;\n            }\n        }\n        else if (next_bad_index < next_good_index)\n        {\n            //i += pattern_len - 1 - j + j - next_bad_index;\n            i += pattern_len - 1 - next_bad_index;\n        }\n        else if (next_good_index <= next_bad_index)\n        {\n            i += pattern_len - 1 - next_good_index + 1;\n        }\n        j = pattern_len - 1;\n    }\n    return -1;\n}\n```\n测试\n```c\nint main()\n{\n    int res = boyer_moore(\"GATTGCTAGATTAACTATACTAA\", \"CTATACTA\");\n    return 0;\n}\n// 结果：14\n```\n总结来说，\n1. 如果坏字符、好后缀都找到了。那么取最小值作为下一个的对齐点。\n    1. 如果二者相等，则优先取好后缀。因为模式字符串重新对齐时，好后缀比坏字符更能多进1位。\n2. 如果至少有一个没找到：\n    1. BM算法最大的易错点：**如果找到了坏字符而没找到好后缀，则必须去对齐坏字符。因为好后缀有时候找不到是很正常的。如果跳过了这个坏字符，那么就会忽略中间的情况！**\n    2. 如果找到了好后缀而没找到坏字符，则忽略这个好后缀。因为模式串中根本就没有下一个坏字符，你去对齐好后缀是没意义的！所以，没找到坏字符就相当于二者都没找到！见2.3。\n    3. 如果都没找到，则模式串起始点重新对齐到当前原串指示位置`i`的下一个位置（实际上是调整`i`的值来做到对齐），j再挪到模式串的最后，重新从后向前一一匹配！\n# 实际的场景\n\n线上项目涉及到数据搜索、字符串匹配，如果数据量很大时，应用最多的其实是字典树、倒排索引的数据结构。例子：百度搜索、开源的Lucene、ElasticSearch（ElasticSearch是一个基于Lucene构建的开源项目）\n\n```\nLucene 和 Elasticsearch（ES）都主要基于倒排索引（Inverted Index）进行高效率搜索。\n\n倒排索引是一种数据结构，用于快速查找包含特定词条（term）的文档。它将文档中的每个词条映射到包含该词条的文档列表，这样的索引结构使得搜索过程能够快速定位到包含特定词条的文档，而无需扫描整个文档集合。\n\n在倒排索引中，每个词条都关联着一个包含该词条的文档列表（称为倒排列表），并且可以附加一些额外的信息，如词频、位置等。这使得搜索引擎可以快速定位到满足查询条件的文档，并根据相关度进行排序。\n\nLucene 是基于 Java 编写的搜索引擎库，提供了倒排索引的实现和管理功能，开发人员可以使用 Lucene 来构建自己的搜索引擎或搜索功能。而 Elasticsearch 是一个基于 Lucene 构建的分布式搜索和分析引擎，它使用 Lucene 的倒排索引作为核心数据结构，同时提供了分布式存储、查询和分析等功能，使得用户可以轻松地构建和管理大规模的搜索应用。\n\n因此，倒排索引是 Lucene 和 Elasticsearch 实现高效率搜索的关键数据结构之一。\n```\n\n## 字典树\n\n字典树是指基于树的一种数据结构，用于以一种能够高效搜索、插入和删除操作的方式存储一组键（通常是字符串）。Trie树（又称prefix tree）和三叉搜索树（Ternary Search Tree，又称T-tree、T树）是字典树的具体实现，各自具有其特点和优势。\n\n1. Trie树（前缀树）特别适用于需要进行前缀匹配和检索的任务，例如字典实现和自动完成系统。\n2. T树（三叉搜索树）在空间效率和快速字符串搜索操作之间提供了平衡。它们也适用于字典实现以及拼写检查和近似字符串匹配等任务。\n\n总之，虽然Trie树和三叉搜索树是不同的实现，但它们都属于字典树类别，用于高效存储和检索键-值对，尤其是字符串。\n\n## 其他树\n### B树\n\nB树的全名是“Bayer–McCreight B树”。这是一种由Rudolf Bayer和Edward M. McCreight于1972年引入的数据结构。B树的名称来自于这两位作者姓氏的首字母。B树被广泛应用于数据库和文件系统中，用于高效地存储和检索数据，尤其是在处理大型数据集和基于磁盘的存储时。\n### `T*`树\n  \n`T*`树是B树数据结构的一种变体，旨在提高范围查询的性能，例如查找在给定范围内的所有值，与传统的B树相比。\n\n在`T*`树中，每个节点可以有不同数量的子节点，通常范围在$\\sqrt d​到2d$之间，其中$d$是树的最大度数。这允许更灵活地平衡树，并且可以使得树的高度相比传统的B树更浅，尤其是对于大型数据集而言。\n\n`T*树`通过在其内部节点中存储额外的摘要信息来实现高效的范围查询性能，例如存储在其子树中的键的聚合值或范围。这样在范围查询期间可以更快地遍历和修剪不必要的子树。\n\n总的来说，`T*`树旨在在保持B树的优点，如高效的插入、删除和搜索操作的同时，提供改进的范围查询性能。它们在数据库系统和其他需要高效范围查询的应用中被广泛使用。\n\n### `B*`树\n\n`B*`树是B树的一种改进版本，旨在减少节点的分裂和合并操作，从而减少树的高度，提高查询性能。\n与普通的B树不同，`B*`树在节点填满时不会立即进行分裂，而是等到达到阈值时才分裂，这样可以减少分裂的频率，减小树的高度。\n\n`B*`树还通过在非叶节点中保留更多的键来减少合并操作的频率，从而进一步减小树的高度。\n\n虽然`B*`树和`T*`树都是B树的变体，但它们的设计目标和实现方式略有不同。`B*`树的重点是减少树的高度，而`T*`树的重点是提高范围查询的性能。","categories":["C","算法","串匹配"]},{"title":"C语言_树","url":"/C/C语言_树/","content":"# BST（Binary Search Tree，二叉搜索树）\n\nBinary Search Tree，二叉搜索树，也称为二叉排序树。\nBST（二叉搜索树）具有以下性质：\n1. **有序性**：对于任意节点，其左子树中所有节点的值均小于该节点的值，右子树中所有节点的值均大于该节点的值。\n2. **递归结构**：左子树和右子树本身也是BST。\n\n```c\nstruct _TreeNode{\n    unsigned key;\n    char val;\n    struct _TreeNode * left;\n    struct _TreeNode * right;\n}\n```\n例如下图的树就是一个BST：\n![](../../images/C语言_树/image-20250224214548495.png)\n## 性质\n1. 可以发现，BST树不一定是完全二叉树。\n2. 关于前、中、后序遍历的有序性：\n    - **中序遍历**（左 → 根 → 右）的结果是**升序有序序列**。这是由BST的性质直接保证的。\n    - **前序遍历**（根 → 左 → 右）和**后序遍历**（左 → 右 → 根）的结果**通常不是有序序列**。仅在某些特殊结构有序（如退化为单链表形态的左斜树或右斜树）。\n## 插入\n\n在当前节点下插入元素，返回新的root。\n\n>为什么要求返回一个新的root呢？\n>\n>1. 便于返回新的root。根节点不一定不变，比如之后如果有平衡化的操作。\n>2. 便于进行递归，因为树本身就是递归结构，完成insert也可以依赖递归进行，在递归过程中，root是动态变化的，层层递进。\n\n如果遇到插入key相同的情况，将value内容替代。\n\n以下是自己写的版本：left、right指针没有接上新节点！\n\n```c\nPTreeNode insert(PTreeNode root, PTreeNode node)\n{\n    if(root == NULL) return node;//终止条件，root为空时，直接将node作为根\n    if(node->key == root->key)\n    {\n        root->val = node->val;\n        return root;\n    }\n    if(node->key < root->key)\n    {\n        root = root->left;\n    }\n    else\n    {\n        root = root->right;\n    }\n    insert(root, node);\n}\n```\n\n简洁明了的正确版本：\n\n```c\nPTreeNode insert(PTreeNode root, PTreeNode node)\n{\n    if(!root) return node;//终止条件，插入的地方为空时，返回node本身作为根\n    if(node->key < root->key) // key小于root时，插入到左侧\n    {\n        root->left = insert(root->left, node);\n    }\n    else if(node->key > root->key)\n    {\n        root->right = insert(root->right, node);\n    }\n    else\n    {\n        root->val = node->val;\n        free(node);//实际上不该由此函数处理，应该由外部处理\n    }\n    return root;\n}\n```\n\n## 创建节点\n\n```c\nPTreeNode make_tree_node(unsigned key, char val)\n{\n    PTreeNode node = (PTreeNode)malloc(sizeof(TreeNode));\n    node->key = key;\n    node->val = val;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n```\n\n测试\n\n```c\nint main(void)\n{\n    PTreeNode root = NULL;\n    root = insert(root, make_tree_node(3, 'c'));\n    root = insert(root, make_tree_node(2, 'b'));\n    root = insert(root, make_tree_node(4, 'd'));\n    root = insert(root, make_tree_node(1, 'a'));\n}\n```\n\n## 查找\n\n建立树就是为了查找，虽然插入困难了些，但是一旦有建立好的树，则搜索要简单得多。\n\n```c\nPTreeNode search(PTreeNode root, unsigned key)\n{\n    if(!root) return NULL;\n    if(key < root->key)\n    {\n        return search(root->left, key);\n    }\n    else if(key > root->key)\n    {\n        return search(root->right, key);\n    }\n    return root;\n}\n```\n\n测试\n\n```c\nint main(void)\n{\n    PTreeNode root = NULL;\n    root = insert(root, make_tree_node(3, 'c'));\n    root = insert(root, make_tree_node(2, 'b'));\n    root = insert(root, make_tree_node(4, 'd'));\n    root = insert(root, make_tree_node(1, 'a'));\n    PTreeNode node = search(root, 2);\n    PTreeNode node2 = search(root, 20);\n}\n```\n\n## 删除\n\n给定一个root，查找特定的key，删除后，返回0或1（C语言中没有bool类型，用int代替）\n\n>需要考虑：\n>\n>1. 删除的节点如果有子树怎么办？\n\n首先递归查找key，如果找到了指定key，则有以下几种情况：\n\n1. 要删除的节点为叶子节点：直接删除\n2. 要删除的节点只有一支子树（左子树或右子树）：子树节点代替上来即可\n3. 要删除的节点有两支子树：在两棵子树中找到一个值大小邻近的节点，交换位置后，就可以转化为上述1、2的情况，就可以简化删除过程。\n    1. 可以选择左子树的最右侧节点：左子树中最大值，但其有可能有左子树（一定不会存在右子树的），因此转化为2。如果没有子树，则转化为1，直接删除。\n    2. 也可以选择右子树的最左侧节点：右子树中最小值，但其有可能有右子树（一定不会存在左子树的），因此转化为2。如果没有字树，则转化为1，直接删除。\n\n![](../../images/C语言_树/image-20250225005338833.png)\n\nremove也是一种递归，终止条件为当前root为空。\n\n> 1. 找到节点为叶子节点时，发现返回值应当为PTreeNode，因为你递归删除子树时，需要反馈给上层一个节点地址信息，以更新上层root的孩子链接。\n> 2. 当目标节点有两支子树时，从左右侧找相邻值均可。我们选择从右子树找最小值。\n> 3. remove和系统库函数名字冲突，需要改名为`remove_node`\n\n```c\nint remove_node(PTreeNode root, unsigned key)\n{\n    if(!root) return NULL;\n    if(key < root->key)\n    {\n        root->left = remove_node(root->left, key);\n    }\n    else if(key > root->key)\n    {\n        root->right = remove_node(root->right, key);\n    }\n    else // 找到key\n    {\n        // 情况1：叶子节点\n        if(root->left == NULL && root->right == NULL)\n        {\n            free(root);\n            root = NULL;\n        }\n        // 情况3：同时有两支子树\n        // 当目标节点有两支子树时，从左右侧找相邻值均可。我们选择从右子树找最小值。\n        else if(root->left != NULL && root->right != NULL)\n        {\n            PTreeNode right_min = find_right_min(root);\n            exchange(right_min, root);\n            // root已经交换到深层，其可能成为了叶子节点，也可能存在一支右子树。再次递归走情况1、2删除。\n            root->right = remove_node(root->right, key);\n        }\n        else// 情况2：有且仅有一支子树\n        {\n            PTreeNode newroot = NULL;\n            if(root->left != NULL)\n            {\n                newroot = root->left;\n            }\n            else\n            {\n                newroot = root->right;\n            }\n            free(root);\n            root = newroot;\n        }\n    }\n    return root;\n}\n```\n\n```c\n//除了交换val值，不要忘记交换key值\nvoid exchange(PTreeNode n1, PTreeNode n2)\n{\n    unsigned key = n1->key;\n    n1->key = n2->key;\n    n2->key = key;\n    \n    char val = n1->val;\n    n1->val = n2->val;\n    n2->val = val;\n}\n```\n\n```c\nPTreeNode find_right_min(PTreeNode root)\n{\n    //形参传入的是根节点，不是根节点的右子树，所以初始化一定注意应当传入root->right\n    PTreeNode right_min = root->right;\n    while(right_min->left)\n    {\n        right_min = right_min->left;\n    }\n    return right_min;\n}\n```\n\n# 树的遍历方式\n\n树是一种非线性结构，既然要遍历就得按照一定顺序。\n\n1. 若按深度优先（DFS），从访问根节点的时机来看，有前序、中序、后序。\n    1. 首先访问根节点，第二遍历左子树，第三遍历右子树：是前序\n    2. 首先遍历左子树，第二访问根节点，第三遍历右子树：是中序\n    3. 首先遍历左子树，第二遍历右子树，第三访问根节点：是后序\n2. 若按广度优先（BFS），则按层次遍历。\n\n## 前序（PreOrder）\n\n前序是先访问根节点，再访问左子树、右子树。\n\n```c\nvoid visit(void PTreeNode root)\n{\n    printf(\"key: %u, val: %c\\n\", root->key, root->val);\n}\nvoid preorder(PTreeNode root)\n{\n    //终止条件，根节点为空\n    if(!root){\n        return;\n    }\n    //访问根节点\n    visit(root);\n    //遍历左子树\n    preorder(root->left);\n    //遍历右子树\n    preorder(root->right);\n}\n```\n\n前序遍历测试代码如下，结果应为：3 2 1 4\n\n```c\nint main(void)\n{\n    PTreeNode root = NULL;\n    root = insert(root, make_tree_node(3, 'c'));\n    root = insert(root, make_tree_node(2, 'b'));\n    root = insert(root, make_tree_node(4, 'd'));\n    root = insert(root, make_tree_node(1, 'a'));\n    preorder(root);\n}\n```\n\n## 中序（InOrder）\n\n```c\nvoid inorder(PTreeNode root)\n{\n    //终止条件，根节点为空\n    if(!root){\n        return;\n    }\n    //遍历左子树\n    inorder(root->left);\n    //访问根节点\n    visit(root);\n    //遍历右子树\n    inorder(root->right);\n}\n```\n\n中序遍历测试代码如下，结果应为：1 2 3 4\n\n```c\nint main(void)\n{\n    PTreeNode root = NULL;\n    root = insert(root, make_tree_node(3, 'c'));\n    root = insert(root, make_tree_node(2, 'b'));\n    root = insert(root, make_tree_node(4, 'd'));\n    root = insert(root, make_tree_node(1, 'a'));\n    inorder(root);\n}\n```\n\n## 后序（PostOrder）\n\n```c\nvoid postorder(PTreeNode root)\n{\n    //终止条件，根节点为空\n    if(!root){\n        return;\n    }\n    //遍历左子树\n    postorder(root->left);\n    //遍历右子树\n    postorder(root->right);\n    //访问根节点\n    visit(root);\n}\n```\n\n后序遍历测试代码如下，结果应为：1 2 4 3\n\n```c\nint main(void)\n{\n    PTreeNode root = NULL;\n    root = insert(root, make_tree_node(3, 'c'));\n    root = insert(root, make_tree_node(2, 'b'));\n    root = insert(root, make_tree_node(4, 'd'));\n    root = insert(root, make_tree_node(1, 'a'));\n    postorder(root);\n}\n```\n\n## 层序（BFS）\n\n递归思想、栈结构对于层序遍历不太好使，需要换一种思路，队列、先进先出（FIFO）。\n\n```c\nvoid bfs(PTreeNode root)\n{\n    push_node(root);\n    while(queue_size() > 0)\n    {\n        PTreeNode top = pop();\n        visit(top);\n        if(top->left != NULL)\n        {\n            push_node(top->left);\n        }\n        if(top->right != NULL)\n        {\n            push_node(top->right);\n        }\n    }\n}\n```\n\n### 队列设计\n\n使用链表充当队列。\n\n```c\ntypedef struct _QueueNode\n{\n    PTreeNode val;\n    struct _QueueNode * next;\n}QueueNode, * PQueueNode;\n\nPQueueNode queue_top = NULL;\n\nPQueueNode make_queue_node(PTreeNode treeNode)\n{\n    PQueueNode queue_node = (PQueueNode)malloc(sizeof(QueueNode));\n    queue_node->val = treeNode;\n    queue_node->next = NULL;\n    return queue_node;\n}\n\nvoid push_node(PTreeNode treeNode)\n{\n    PQueueNode queue_node = make_queue_node(treeNode);\n    //判断目前是否有首节点，没有就当作首节点\n    if(queue_top == NULL)\n    {\n        queue_top = queue_node;\n    }\n    else\n    {\n        PQueueNode cur_node = queue_top;\n        while(cur_node->next)\n        {\n            cur_node = cur_node->next;\n        }\n        cur_node->next = queue_node;\n    }\n}\nunsigned queue_size()\n{\n    unsigned cnt = 0u;\n    PQueueNode node = queue_top;\n    while(node)\n    {\n        ++cnt;\n        node = node->next;\n    }\n}\nPTreeNode pop()\n{\n    if(queue_top == NULL)return NULL;\n    PTreeNode treeNode = queue_top->val;\n    PQueueNode oldNode = queue_top;\n    queue_top = queue_top->next;\n    free(oldNode);\n    oldNode = NULL;\n}\n```\n\n层序遍历测试代码如下，结果应为：3 2 4 1\n\n```c\nint main(void)\n{\n    PTreeNode root = NULL;\n    root = insert(root, make_tree_node(3, 'c'));\n    root = insert(root, make_tree_node(2, 'b'));\n    root = insert(root, make_tree_node(4, 'd'));\n    root = insert(root, make_tree_node(1, 'a'));\n    bfs(root);\n    return 0;\n}\n```\n\n# B树（2-3-(4)树）\n\nB代表Balanced，据说也代表波音公司，因为它是由Rudolf Bayer和Edward M. McCreight在波音研究实验室工作时发明的。\n其性质是为了解决BST树的退化问题的，比如说一直向左子树插入一个边缘值，就会导致树退化为链表，这种不平衡导致效率降低。\n\nB树派生出好多种形态的树，2-3-(4)树就是B树的4阶形式。红黑树又是2-3-(4)树的一种形式，是一种多叉树的二叉树实现。\n## B树、AVL树、红黑树的对比\nAVL树、B树、红黑树，都是解决BST树退化问题的自平衡结构。\n1. 结构上：\n    1. AVL树和红黑树都是二叉树。节点中都记录了平衡状态。\n        1. AVL存储平衡因子。\n        2. 红黑树存储颜色标记。\n    2. B树为多路树，节点有多个键、子节点指针。\n2. 性能上：\n    1. AVL树，严格平衡。查询效率最高。\n    2. 红黑树，不严格平衡。查询效率略慢于AVL树。\n        1. 但在数学上，AVL和红黑树的增删查时间复杂度都是大O(log n)。\n        2. 对于插入操作，AVL和红黑树都是最多旋转2次。\n        3. 对于删除操作，AVL树由于需要严格平衡，旋转次数可能需要O(log n)次，而红黑树可以通过翻转颜色，让旋转次数最多3次。\n            1. 为什么不能直接说“logn 次”？\n                1. 平衡因子：每个节点的左右子树高度差（Balance Factor, BF）的绝对值不超过1。\n                2. 高度约束：对于包含 n 个节点的AVL树，其高度 h≤1.44log2​n（基于斐波那契数列的黄金分割比例）。\n                3. 树高与路径长度：若树高为 h，删除节点的路径长度最多为 h。\n                4. 每层最多一次旋转：每层失衡节点需一次或两次旋转（如双旋），但旋转次数的增长趋势仍为 O(h)。\n                5. 最终结果：最坏旋转次数=O(h)=O(logn)\n    3. B树也是平衡的，但其只适用于外存（磁盘）IO操作。\n        1. 见“高级数据结构_B树”\n        2. B树不需要旋转节点。是通过分裂、合并节点达到平衡的。\n        3. 为什么B树不像AVL、红黑树那样适用于内存操作：\n            1. **指针操作开销**：B树的插入/删除涉及多次指针调整（分裂或合并节点），而AVL/红黑树的旋转操作仅需修改少量指针。\n            2. B树节点的数据量通常较大（例如一个节点占4KB），可能超出CPU缓存行（通常64B-256B），导致缓存未命中率增加。\n            3. 总之，**局部性差**：二叉树的节点较小，更容易被缓存命中；而B树的节点遍历需要访问更多内存块，降低缓存利用率。\n    4. 因此。AVL树适合读多写少；红黑树适合写多读少。\n\n与B树不同的是，AVL是一种BST，是二叉树，即比平衡二叉搜索树多了平衡的概念，具体来说多了旋转的操作、节点的状态。\nB树在原型上，是多叉树，且节点可有多个值。由于B树不是二叉树，因此B树不属于BST。\n\n对于AVL和红黑树：由于AVL是严格平衡的，在查询效率上略优于红黑树这种不严格平衡的树，但它们的时间复杂度都是$O(\\log n)$;\n但是，对于AVL和B树而言，搜索算法没什么差异，AVL树和B树同样都是二分查找的分治策略, 时间复杂度都为$O(\\log n)$;\n## 节点形态\n\n有2型节点、3型节点。\n\n2型节点是节点内部有1个key，可以有两个子节点；3型节点是内部有2个key，可以有三个子节点。2-3树的意思是，树中可能包含2型节点和3型节点。\n\n插入节点位置的规则遵循BSTree的规则，即从左往右按从小到大的顺序，左侧最小、右侧最大。如果是3型节点，则需要满足：左侧最小，key1次小，中子树是中值，key2次大，右侧最大。\n![](../../images/C语言_树/image-20250225014448845.png)\n\n除了以上规则以外，为了能更好地控制2-3-(4)树，多了一个特殊的附加规则：**2、3、4型节点要么是叶子节点（没有子节点），要么子节点全都占满，没有中间状态**。\n![](../../images/C语言_树/image-20250225034030105.png)\n1. 假设目前有一个内含6的2型节点\n   ![](../../images/C语言_树/image-20250225034704385.png)\n2. 要插入9，由于子树要么空要么满，所以只能将其与6并列放入2型节点中，变为一个内含6、9的3型节点。\n   ![](../../images/C语言_树/image-20250225040509456.png)\n3. 继续插入7，会进入一个临时状态，即将其与6、9并列，变为一个内含6、7、9的4型节点。但是紧接着，会分裂为3个2型节点：7作为根节点，左子树为6，右子树为9。\n   ![](../../images/C语言_树/image-20250225040736460.png)\n4. 继续插入5，经过对比，向7的左子树6插入，与6并列，变为一个内含5、6的3型节点。\n   ![](../../images/C语言_树/image-20250225041013571.png)\n5. 继续插入4，经过对比，向7的左子树（5、6）插入，与5、6并列，变为一个内含4、5、6的4型节点。\n6. 紧接着，左子树又要面临分裂为3个2型节点，但如果单纯地分别把4、6下裂后，只有左支的深度单独加1，会导致整个树的不平衡（左偏）。\n7. 但如果换个方向，向父节点推5，会巧妙地保持整个树深度同步。\n8. 而5上推与7并列后，根节点变为3型节点，需要有三个子树，那么9保留原位，而4、6正好可以各占一个子树的位置。所以，最终结果为：整根为（5、7），子树1为4，子树2为6，子树3为9。\n   ![](../../images/C语言_树/image-20250225041636018.png)\n## 实现\n1. 其中一个比较棘手的问题是，凡是两个数以上的比较，都需要一个机制来对比，哪怕是三个数的对比。\n2. 2-3-4树的数据结构不确定，有中间不稳定的4型节点，所以不能简单地用left、middle、right对比。\n3. 如果B树单个节点中有上千个数据，那么就用数组来存放。但是如果此B树是2-3-4树，则数组就显得比较大动干戈了。\n4. 综上原因，我们想到一个巧妙的方法，就是用颜色来代替某些支。由此产生了：红黑树\n\n# 红黑树（二叉搜索红黑树）\n\n红黑树其实是2-3树的一个变形（不存在4型节点）。\n\n我们加以人为规定：把原先2-3树，同一节点中的较小数裂在根节点的左侧子树。这样的话，3型节点就转化成了二叉树。\n\n>当然也可以人为规定把较大数放在右侧子树，甚至说同时存在较小数放左、较大数放右的情况。这样徒使程序变得很复杂，失去了简化2-3树的意义。所以为了编写程序简单，统一规定都按左侧（左斜）处理。\n\n![](../../images/C语言_树/image-20250225072634225.png)\n上图的 c 用红线相连，指向 a，称 a 为红色节点，代表 a、c 原先在2-3树中曾为同一节点。红色代表鲜明，可以理解为：有血肉联系。c 是黑色节点。\n## 红黑树对应2-3树的有效形式\n1. 我们将树中的链接分为两种类型：\n    1. 红链接将两个2- 结点连接起来构成一个3- 结点\n    2. 黑链接则是2-3 树中的普通链接。\n    3. 确切地说，我们将3- 结点表示为由一条左斜的红色链接（两个2-结点其中之一是另一个的左子结点）相连的两个2- 结点。\n    4. 规定只能左红，不能出现右红。\n2. 规定只能连续一支红线，即一个节点最多只能由一个红线连接，即表示在2-3树中的3型节点。不能出现连续两支红线。\n3. 在实际程序中，因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们把颜色存储在左子树节点。\n4. 如果指向它的链接是红色的，那么为红色。我们约定空链接为黑色（因此根节点存储的应当总是黑色。我们在每次插入后都要将根结点设为黑色。注意，每当根结点由红变黑时树的黑链接高度就会加1）。\n5. 有这样的性质，红黑树最长支的长度 不超过 最短支的长度的2倍。虽然AVL树最大差1，但AVL树插入性能太慢。红黑树就很好地平衡了层数差异和性能。\n\n## 极端形式\n\n二叉树的极端形式就是：一支最长、一支最短：左子树最长情况下是一红线一黑线交替穿插。右子树最短情况下是全黑。这种情况下，左支和右支的高度差最大是2倍。这个高度差是可以接受的，因为红黑树相比于其他树来说插入较简单，比如两边最多差1的AVL树插入是很费劲的，时间复杂度太高。而又能兼顾到查找的速度。\n\n## 应用\n\nSTL中的map（dictionary）、set；\n\nLinux中网络编程中epoll用到的数据结构\n\n## 节点定义\n\n> 用直观的符号代替不直观的内容（整数，不能是小数）。通常需要typedef，否则在声明、初始化枚举类时，需要写出全称`enum Color`。\n```c\ntypedef enum _Color\n{\n    Black = 0,\n    Red\n}Color;\n```\n\n```c\ntypedef struct _RBNode\n{\n    unsigned key;\n    char val;\n    Color color;\n    struct _RBNode * left;\n    struct _RBNode * right;\n}RBNode, *PRBNode;\n```\n\n## 插入\n\n我们可以默认创造出的新节点都是红色的，因为2-3树在插入节点时，节点总是试图与上层节点结合成为同一节点。\n### 创建节点（默认红色）\n```c\nPRBNode make_rb_node(unsigned key, char val)\n{\n    PRBNode node = (PRBNode)malloc(sizeof(RBNode));\n    node->val = val;\n    node->key = key;\n    node->color = Red;\n    node->left = NULL;\n    node->right = NULL;\n}\n```\n### 根节点的颜色问题（插入空树）\n在下面插入的过程中，可能会有颜色转换操作，会使根结点变为红色。这也可能出现在很大的红黑树中。严格地说，红色的根结点说明根结点是一个3- 结点的一部分，但实际情况并不是这样。因此我们在每次插入后都会将根结点设为黑色。注意，每当根结点由红变黑时树的黑链接高度就会加1。\n```cpp\n// 树空时插根节点的情况。\nPRBNode insert_rb_node(PRBNode root, PRBNode node)\n{\n    if(root == NULL)return node;\n    //...\n}\nPRBNode insert_node(PRBNode root, PRBNode node)\n{\n    root = insert_rb_node(root, node);\n    //在插入过程中，根节点有可能变红，插入后要把根设为黑色。\n    if(is_red(root))\n    {\n        root->color = Black;\n    }\n    return root;\n}\n```\n### 插入到2-型节点\n1. 比如向一个内含 c 的 2-型节点插入 a，已知 2-型节点没有子树，则将 a 插入到 c 左子树，则相当于在 2-3 树中合并节点的情况，在红黑树中则相当于 c 的颜色设为红色即可。c 默认就是红色，不用操作。最后：c 红，a 黑。\n2. 比如向一个内含 c 的 2-型节点插入 d，2-型节点没有子树，则将之插入到右子树，因为 c 没有子树，则相当于在 2-3树中合并节点的情况。由于默认创建出来的节点是红的，造成**右红**，那么就需要**左旋操作**：即让 d 上位，c 下位至 d 的左子树，且 c 右支接管 d 原先的左子树。插入之前，b 是黑色，c 是红色，插入之后，还需将 b、c 的颜色交换。\n\n```c\nPRBNode left_rotate(PRBNode root)\n{\n    PRBNode newroot = root->right;\n    root->right = newroot->left;\n    newroot->left = root;\n    return newroot; //new root\n}\n```\n\n```c\nvoid exchange_color(PRBNode n1, PRBNode n2)\n{\n    Color color = n1->color;\n    n1->color = n2->color;\n    n2->color = color;\n}\n```\n\n### 插入到3-型节点\n该3-型节点此时一定有左子树，且左子树一定为红色，右子树不可能是红的。\n1. **左红右红**：向（c、f）节点（没有右子树）插入 h ： h 将要插到 f 的右子树，但 h 默认为红色，**出现了左红右红**，需要调整。此时相当于在2-3-4树中合并为过渡4-型节点的情况，之后即将分裂为3个2-型节点。而在红黑树中，自然地省去了分裂的步骤，此时需要把 c、h 节点的红色反转为黑色（flip color）。注意！还需要把 f 的颜色反转为红色，因为在2-3-4树中的分裂操作中，被上推的节点企图与上层进行结合，一旦结合，就成红色了。总之，**3 节点翻转颜色**。\n\n```c\nint flip_color(PRBNode root)\n{\n    if(root == NULL)return 0;\n    if(root->color == Red)\n    {\n        root->color = Black;\n    }\n    else\n    {\n        root->color = Red;\n    }\n    return 1;\n}\nvoid flip_colors(PRBNode root)\n{\n    //如果根节点颜色反转成功，则才能继续反转子节点\n    if(flip_color(root))\n    {\n        flip_color(root->left);\n        flip_color(root->right);\n    }\n}\n```\n2. **左连续红**：向（c、f）节点（没有右子树）插入 a ：a 将要插到 c 的左子树，但 a 默认为红色， **出现了左支连续红色**，需要调整。此时相当于在2-3-4树中合并为过渡4-型节点的情况，之后即将分裂为3个2-型节点，把 c 上推，把 a、f 下裂。在红黑树中，则需要**右旋**操作： f 下位至 c 的右子树，且 f 的左支接管 c 原先的右子树。此时又出现了**左红右红**，效仿情况1，把3个节点颜色全部反转即可。则最后：a 黑、c 红、f 黑。\n    1. 颜色问题：右旋前的颜色为：a 红、c 红、f 黑，右旋后的颜色为：a 红、c 黑、f 红。为什么上移的 c 变黑了？因为 c（newRoot）相当于替代了 f（oldRoot）的位置，旧根本来就是黑的，所以 c 要变黑。\n\n```c\nPRBNode right_rotate(PRBNode root)\n{\n    PRBNode x = root->left;\n    root->left = x->right;\n    x->right = root;\n    exchange_color(x, root);\n    return x;// new root\n}\n```\n3. **左空右红**：向（c、f）节点（没有右子树）插入 d ：d 将要插到 c 的右子树（注意，不是根节点 f 的右子树，而是其左子树 c 的右子树），但 d 默认为红色，**出现了右支红色**，需要调整。需要以 c 为根**左旋**，之后 c 成了 d 的左支，d 成了 f 的左支，**出现了左支连续红色**。此时和在情况2中一样，需要以 f 为根**右旋**，即把 d 上推，把 c、f 下裂。f 下位至 d 的右子树，且 f 的左支接管 d 原先的右子树。整体来说：先左旋，后右旋。\n    1. 像情况2一样，右旋后，又出现了**左红右红**，则需要把3个节点颜色全部反转。最后：c 黑、d 红、f 黑。\n### 整体过程\n![](../../images/C语言_树/image-20250228100027670.png)\n相比于BSTree的插入，前面的流程一致，只是多了插入后的调平的操作。\n1. 终止条件是当时的root为空\n2. 要插入的node的key与已存在的节点的key相等时，认为是更新节点值的操作\n3. 调整——我们需要精心安排 if 的顺序，经过3种情况分析：\n    1. 左黑右红：在左旋后会出现左连续红，则需要右旋，之后会出现左红右红。\n    2. 左连续红：右旋后会出现左红右红。\n    3. 左红右红：翻转颜色即可。\n    4. 总体来说：\n        1. 1和2是互斥关系：以上图为例，c为根时，只能看到c、d两层，看不到情况 2 从 f 层开始的左连续红。\n        2. 1和3也是互斥关系：由于1和2是互斥关系，不会在那一层递归进行对 f 的右旋，所以不会出现左红右红，因此1和3也是互斥关系。\n        3. 2和3是并列先后顺序关系。在 情况2 对 f 进行右旋后，能在同一层递归关系中继续看到 c、d、f 的颜色关系，出现左红右红，因此2必须在3前面。\n        4. 情况3，对三个节点全部翻转颜色。\n4. 最后红黑树还要注意一条规则是总根一定是黑色的。\n\n```c\nPRBNode insert_rb_node(PRBNode root, PRBNode node)\n{\n    if(root == NULL)return node;//此处不用调整了，会由上一层调整\n    if(root->key == node->key)\n    {\n        root->val = node->val;\n        return root;\n    }\n    //递归向下\n    //左支递归插入\n    if(node->key < root->key)\n    {\n        root->left = insert_rb_node(root->left, node);\n    }\n    else//右支递归插入\n    {\n        root->right = insert_rb_node(root->right, node);\n    }\n    //递归向上\n    //调整\n    //左空右红。\n    // 左空右红时局部左旋后会出现左侧连续红，\n    // 但不能在同一层递归处理后续情况，因此是if-else关系\n    if(!is_red(root->left) && is_red(root->right))\n    {\n        root = left_rotate(root);//可能会更新root\n    }\n    else\n    {\n        //左侧连续红\n        // 必须排到左红右红前面，因为右旋后出现左红右红，需要在同一层递归处理。因此是if-if先后顺序关系。\n        if(is_red(root->left) && is_red(root->left->left))\n        {\n            root = right_rotate(root);\n        }\n        //左红右红：反转颜色\n        if(is_red(root->left) && is_red(root->right))\n        {\n            flip_colors(root);\n        }\n    }\n    return root;\n}\nint is_red(PRBNode root)\n{\n    if(root)\n    {\n        return root->color == Red;\n    }\n    return Black;// 若root为空则返回黑\n}\nPRBNode insert_node(PRBNode root, PRBNode node)\n{\n    root = insert_rb_node(root, node);\n    //在插入过程中，根节点有可能变红，插入后要把根设为黑色。\n    if(is_red(root))\n    {\n        root->color = Black;\n    }\n    return root;\n}\n```\n\n测试\n\n```c\nint main()\n{\n    PRBNode root = NULL;\n    root = insert_node(root, make_rb_node(3, 'c'));\n    root = insert_node(root, make_rb_node(2, 'b'));\n    root = insert_node(root, make_rb_node(4, 'd'));\n    root = insert_node(root, make_rb_node(1, 'a'));\n    return 0;\n}\n```\n\n## 支持4-型节点的红黑树（存在左红右红）\nCpp的STL模板库以及其他语言的库，Dictionary和Map中用的都是支持4-型节点的红黑树。\n\n首先我们要明确，我们在2-3树下的红黑树规定了红链接只能出现在左侧。\n原先2-3树下的红黑树，插入过程中**临时存在**的4-型节点，只是一个临时、不稳定的中间状态，插入后要立即检查左连续两红、左红右红、左空右红，这几种非法的4-型节点情况，调整。\n现在如果支持4-型节点，那么红链接支持出现在右侧。那么就会允许左连续两红、左红右红、左空右红的存在吗？不！仍然不允许，因为这仍是基于左倾的红黑树，实际仅能存在节点为黑色、左右字节点为红色的这样的情况（即左红右红）。\n\n但是，微妙的是，虽然允许了4-型节点的合法存在，但在插入过程中，为了操作简便，把4-型节点又拆解为非4-型节点了，**拆解中用到的旋转操作是我们上文写过的2-3树下的左倾红黑树下的操作。于是树经过拆解后，又变成了2-3树下的左倾红黑树**，就又可以用到之前的操作了。\n\n总之，基于左倾旋转操作的支持4-型节点的红黑树，有以下性质：\n一棵红黑树是满足下面红黑性质的二叉搜索树：\n1. 每个结点或是红色的，或是黑色的。\n2. 根结点是黑色的。\n3. 每个叶结点 (NIL) 是黑色的。\n4. 如果一个结点是红色的，则它的两个子结点都是黑色的。\n5. 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。\n\n如果支持4-型节点稳定存在，在结构上，相比只有2-3型的结构，2-3-4树的层数会更少一些。虽然实际在红黑树的形式下层数没有明显减少，然而，操作效率上会得到改善。\n但是，就要解决一个问题，即4-型节点再插入一个节点，怎么处理？是允许临时5-型节点存在吗？这样就使程序复杂化了。\n![](../../images/C语言_树/image-20250228103056554.png)\n高效、巧妙的处理方式：\n1. 在递归向下、插入之前，事先分解掉红黑树中所有的4-型节点（但必须是等价转化，不能让2-3-4树形式上的层数变多，对于红黑树形式来说，可能会多1层，但还是符合平衡的要求范围内的，可以看上图）。这样，后续插入时就不会存在4-型节点，要么是2-型、要么是3-型。\n    1. 我们发现，分解4-型节点，其实仅需翻转颜色而已。\n2. 插入\n3. 插入之后，递归向上调平。\n    1. 只需要处理：左黑右红、左连续红的情况。\n    2. 左黑右红和左连续红不在同一递归层次中处理，互斥。\n\n```c\nPRBNode insert_rb_node(PRBNode root, PRBNode node)\n{\n    if(root == NULL)return node;//此处不用调整了，会由上一层调整\n    if(root->key == node->key)\n    {\n        root->val = node->val;\n        return root;\n    }\n    //递归向下之前，先分解所有遇到的4-型节点。\n    if(is_red(root->left) && is_red(root->right))\n    {\n        flip_colors(root);\n    }\n    //递归向下\n    //左支递归插入\n    if(node->key < root->key)\n    {\n        root->left = insert_rb_node(root->left, node);\n    }\n    else//右支递归插入\n    {\n        root->right = insert_rb_node(root->right, node);\n    }\n    //递归向上\n    //调整\n    //左空右红。\n    // 左空右红时局部左旋后会出现左侧连续红，\n    // 但不能在同一层递归处理后续情况，因此是if-else关系\n    if(!is_red(root->left) && is_red(root->right))\n    {\n        root = left_rotate(root);//可能会更新root\n    }\n    else\n    {\n        //左侧连续红\n        if(is_red(root->left) && is_red(root->left->left))\n        {\n            root = right_rotate(root);\n        }\n        // 在允许4-型的红黑树中，左红右红合法。不用处理。\n        //if(is_red(root->left) && is_red(root->right))\n        //{ }\n    }\n    return root;\n}\nint is_red(PRBNode root)\n{\n    if(root)\n    {\n        return root->color == Red;\n    }\n    return Black;// 若root为空则返回黑\n}\nPRBNode insert_node(PRBNode root, PRBNode node)\n{\n    root = insert_rb_node(root, node);\n    if(is_red(root))\n    {\n        root->color = Black;\n    }\n    return root;\n}\n```\n\n测试\n\n```c\nint main()\n{\n    PRBNode root = NULL;\n    root = insert_node(root, make_rb_node(3, 'c'));\n    root = insert_node(root, make_rb_node(2, 'b'));\n    root = insert_node(root, make_rb_node(4, 'd'));\n    root = insert_node(root, make_rb_node(1, 'a'));\n    return 0;\n}\n```\n\n## 删除\n\n红黑树的删除可以参考BST的过程。\n\n红黑树形式的分析——类比BST树\nBST中，如果节点是\n1. 叶子节点，直接删除\n2. 只有一支子树，则直接删除，删除后让该支子树替代root自身即可（叶子节点的子树为NULL））\n3. 如果有两个子树，则选取一个叶子节点交换（选择两支子树中相近大小的节点替代自身），即把将要删除的节点下移至叶子节点或者下移至只有一支子树的状态，就可以转化为情况1、2了。\n4. 递归返回后需要调平\n\n2-3-4树形式的分析——类比插入的思想\n除此之外，红黑树是2-3-4树，拿2-3-4树的形式来分析，如果要删除的节点在叶子节点中，可能在一个4-型节点、3-型节点、2-型节点中，4-型、3-型可以直接删除，因为不影响该路径层数的平衡。\n总之，如果是2-型节点，就不能直接删除。\n\n类比于红黑树避免插入4-型节点而分解所有的4-型节点的道理，我们可以在避免删除2-型节点而让所有的2-型节点扩张为3-型或4-型节点。\n\n因此，4-型节点在红黑树中，既可以存在，也可以不存在。\n如果允许存在4-型节点，则删除后不用向上递归分解4-型节点。如果不允许存在4-型节点，则删除后需要向上递归分解4-型节点。\n\n代码可以参照算法（4th）291页3.3.41\n# 红黑树非递归版本\n见算法（4th）265页3.2.13。\n## 模型\n我们分析的模型，基于的红黑树形式是：实际4-型节点仅能存在为根黑色、左右字节点为红色的这样的情况（即左红右红）。详见[支持4-型节点的红黑树（存在左红右红）](#支持4-型节点的红黑树（存在左红右红）)。\n如果仅分析新节点插到左子树的情况：\n1. 爷黑，左红右红。\n    1. 爷爷、父、叔全部翻转颜色。爷爷的父节点可能还是红色，需要不断向上调整，直到达到根，根记得设为黑色。\n2. 爷黑，左连续两红。\n    1. 插到了父节点（红色）的左子树\n        1. 翻转父节点、爷爷节点颜色，之后以爷爷节点右旋。\n    2. 插到了父节点（红色）的右子树\n        1. 先以父节点左旋，就会转化为上面的情况。\n3. 爷黑，左黑、右无所谓。直接插\n\n实际上，新节点插到右子树只是上述过程的镜像。所以我们无需再分析。\n\n默认插入的新节点为红色。\n若树为空树，则直接插入节点，最后记得根要设为黑色；\n若树不为空，且插入位置的父节点为黑色，则直接插入。\n若插入位置的父节点为红色：\n只分析节点插入到左支的情况。\n1. 叔叔节点为红色，插入的位置**不管是父节点的左侧还是右侧**。都相当于爷爷黑、爷爷的左红右红。翻转上面3个节点颜色即可。但是，爷爷变红之后，可能还和爷爷的父节点冲突，需要不断向上调整，直到找到整个树的根，设为黑色。\n2. 叔叔节点为黑色，插入的位置是**父节点的左侧**。则相当于爷爷黑、左连续两红。需要先把父节点和爷爷的节点颜色翻转（父设为黑，爷爷设为红）。再以爷爷为轴右旋。则父节点上位，为黑色，结束。\n3. 叔叔节点为黑色，插入的位置是**父节点的右侧**。则相当于爷爷黑、左连续两红。以父节点左旋，之后变成了情况2。\n\n![](../../images/C语言_树/image-20250303142622944.png)\n\n![](../../images/C语言_树/image-20250303142653323.png)\n\n![](../../images/C语言_树/image-20250303142726649.png)\n\n为了能实现回溯之前节点，需要在节点中包含一个父节点指针。\n```cpp\ntemplate <typename T>\nclass RBTree\n{\n    // 节点的颜色\n    enum Color\n    {\n        BLACK,\n        RED\n    };\n    // 节点类型\n    struct Node\n    {\n        Node(T data = T(), Node *parent = nullptr,\n             Node *left = nullptr, Node *right = nullptr,\n             Color color = BLACK)\n            : data_(data), left_(left), right_(right), parent_(parent), color_(color)\n        {\n        }\n        T data_;\n        Node *left_;\n        Node *right_;\n        Node *parent_; // 指向当前节点的父节点\n        Color color_;  // 节点的颜色\n    };\n    // 指向红黑树的根节点\n    Node *root_;\n};\n```\n## 插入\n```cpp\nvoid insert(const T &val)\n{\n    if (root_ == nullptr)\n    {\n        root_ = new Node(val);\n        return;\n    }\n\n    Node *parent = nullptr;\n    Node *cur = root_;\n    // BST 插入流程\n    while (cur != nullptr)\n    {\n        if (cur->data_ > val)\n        {\n            parent = cur;\n            cur = cur->left_;\n        }\n        else if (cur->data_ < val)\n        {\n            parent = cur;\n            cur = cur->right_;\n        }\n        else\n        {\n            return;\n        }\n    }\n    // parent现在是node的父节点\n    Node *node = new Node(val, parent, nullptr, nullptr, RED);\n    // 判断node插到了parent左还是右，然后让其left或right指向node\n    if (parent->data_ > val)\n    {\n        parent->left_ = node;\n    }\n    else\n    {\n        parent->right_ = node;\n    }\n\n    // 如果新插入的红色节点，父节点也是红色，不满足红黑树性质，进行插入调整操作\n    if (RED == color(parent))\n    {\n        fixAfterInsert(node);\n    }\n}\n// 调平函数\nvoid fixAfterInsert(Node *node)\n{\n    // 如果当前红色节点的父节点是红色，不断向上调整\n    while (color(parent(node)) == RED)\n    {\n        // 左镜像的3种情况，即插入的节点在左子树当中\n        if (left(parent(parent(node))) == parent(node))\n        {\n            Node *uncle = right(parent(parent(node)));\n            if (RED == color(uncle)) // 情况一\n            {\n                setColor(parent(node), BLACK);\n                setColor(uncle, BLACK);\n                setColor(parent(parent(node)), RED);\n                node = parent(parent(node)); // 继续调整\n            }\n            else\n            {\n                // 先处理情况三\n                if (right(parent(node)) == node)\n                {\n                    node = parent(node);\n                    leftRotate(node);\n                }\n                // 统一处理情况二\n                rightRotate(parent(parent(node)));\n                break; // 调整已经完成\n            }\n        }\n        else // 右镜像的3种情况，即插入的节点在右子树当中\n        {\n            Node *uncle = left(parent(parent(node)));\n            if (RED == color(uncle)) // 情况一\n            {\n                setColor(parent(node), BLACK);\n                setColor(uncle, BLACK);\n                setColor(parent(parent(node)), RED);\n                node = parent(parent(node)); // 继续调整\n            }\n            else\n            {\n                // 先处理情况三\n                if (left(parent(node)) == node)\n                {\n                    node = parent(node);\n                    rightRotate(node);\n                }\n                // 统一处理情况二\n                leftRotate(parent(parent(node)));\n                break; // 调整已经完成\n            }\n        }\n    }\n    // 此处强制root为黑色节点\n    setColor(root_, BLACK);\n}\n```\n分析出，红黑树的插入，最多旋转2次：先左旋、再右旋；或者先右旋、再左旋。\n## 删除\n总体思路：\n1. 叶子节点的删除：\n    1. 根。先把根清理，再删除。\n    2. 红色叶子，直接用BST方式删除。\n    3. 黑色叶子，**从兄弟借黑色节点**。\n2. 有两个子树的节点删除：\n    1. 删除有两个子树的节点，可以把节点与其左子树的最右节点（此时最多有一个子树，或者为叶子节点）替换，然后转化为删除只有一个子树的节点或删除叶子节点。\n3. 有一个子树的节点删除：\n    1. 主要思想是把孩子替补上来。\n        1. 补上来的孩子是红色，直接把孩子涂成黑色。\n        2. 补上来的孩子是黑色，无法再从自己孩子这里补充黑色了，需要**从兄弟借黑色节点**。\n\n```cpp\nvoid remove(const T &val)\n{\n    // 查找\n    if(root_ == nullptr)\n    {\n        return;\n    }\n    Node* cur = root_;\n    while(cur != nullptr)\n    {\n        if (cur->data_ > val)\n        {\n            cur = cur->left_;\n        }\n        else if(cur->data_ < val)\n        {\n            cur = cur->right_;\n        }\n        else\n        {\n            break;\n        }\n    }\n    if(cur == nullptr)\n    {\n        return;\n    }\n    // 删除\n    // 左右都不为空，则找左子树中的最右值（前驱）或者右子树中的最左值（后继），替换\n        // 此处找的是左子树中的最右值（前驱）\n    if (cur->left_ != nullptr && cur->right_ != nullptr)\n    {\n        Node * pre = cur->left_;\n        while (pre->right_ != nullptr)\n        {\n            pre = pre->right_;\n        }\n        // 替换值\n        cur->data_ = pre->data_;\n        cur = pre; // 转化为删除pre\n    }\n    // 删除cur指向的节点，目前可以确定其最多有一棵子树，或者全空\n    Node * child = cur->left;\n    if (child == nullptr)\n    {\n        child = cur->right_;\n    }\n    \n    // 如果cur有子树，需要更新cur子树的parent指向cur的parent\n    if (child != nullptr)\n    {\n        child->parent_ = cur->parent_;\n        // 如果cur的parent为空，则说明删除cur后，child变成了根\n        if (cur->parent_ == nullptr)\n        {\n            root_ = child;\n        }\n        else\n        {\n            // 因为cur是最右节点，不可能有右子树。\n            // cur在左支，删除后 需要把孩子继承给cur的parent的左支\n            if (cur->parent_->left_ == cur)\n            {\n                cur->parent_->left_ = child;\n            }\n            else\n            {\n                // 因为cur是最右节点，不可能有右子树。\n                // cur在右支，删除后 需要把孩子继承给cur的parent的右支\n                cur->parent_->right_ = child;\n            }\n        }\n        Color color = color(cur);\n        delete cur;\n        // 若删除的节点是红色，完毕。\n        // 若删除的节点是黑色，需要调整\n            // 如果补上来的孩子是红色，直接涂成黑色\n            // 如果补上来的孩子是黑色，无法再借孩子黑色，需要借兄弟的。\n        if (c == Black)\n        {\n            fixAfterRemove(child);\n        }\n    }\n    else // cur没有子树。\n    {\n        // 看parent是否为空，若是，说明其为根节点\n        if (cur->parent_ == nullptr)\n        {\n            delete cur;\n            root_ = nullptr;\n            return;\n        }\n        else // 此时删除的节点cur是正常的叶子节点\n        {\n            // 删除黑色叶子，要借兄弟一个黑色节点\n            if (color(cur) == Black)\n            {\n                fixAfterRemove(cur);\n            }\n            // 不管叶子是黑还是红，都要走以下步骤\n            if (left(parent(cur)) == cur)\n            {\n                left(parent(cur)) == nullptr;\n            }\n            else\n            {            {\n                right(parent(cur)) == nullptr;\n            }\n            delete cur;\n        }\n    }\n}\n```\n1. 根黑或者红。兄弟黑\n    1. 兄弟的右孩子是红色，左无所谓\n        1. **把兄弟的右孩子设为黑色**。以根节点为轴，左旋。完毕。\n        2. 总之，借了右支的黑节点。右支需要改一个红色为黑色。\n    2. 兄弟的左孩子是红色，右是黑色\n        1. 以兄弟为轴右旋，于是转化为了情况1。\n        2. 注意兄弟换了，需要更新（`brother=parent->right`）。\n    3. 兄弟的两个孩子全黑。\n        1. 总体思想：由于左边即将失去一个黑色，可以把**黑色的兄弟涂红**以平衡。\n            1. 右支新添了红色节点，回头需看若根节点为红色，则**改为黑色**。结束。\n            2. 若根节点为黑色，则向上追溯一个红色节点，**改为黑色**。\n2. （情况4）根黑或者红。兄弟红\n    1. 兄弟的两个孩子全黑（因为兄弟节点是红，其孩子不能出现红）。意味着根的右支已经没有孩子可借。\n        1. 以根为轴，左旋。这样，要删除的节点就有了黑色兄弟。\n        2. 但是要注意，要删除的节点的兄弟换了，需要更新（`brother=parent->right`）。\n        3. 可以归结到上述兄弟黑的三种情况了。\n\n![](../../images/C语言_树/image-20250304021224853.png)\n\n![](../../images/C语言_树/image-20250304021232069.png)\n\n![](../../images/C语言_树/image-20250304021240983.png)\n\n![](../../images/C语言_树/image-20250304021248122.png)\n\n```cpp\n// 旋转时产生的颜色交换应集成在旋转函数中\nvoid fixAfterRemove(Node * node)\n{\n    while (node != root_ && color(node) == Black)\n    {\n        // 左镜像，即删除的节点在根的左支。\n        if (left(parent(node)) == node)\n        {\n            Node * brother = right(parent(node));\n            // 情况4，兄弟红。转化为兄弟黑的情况\n            if (color(brother) == RED)\n            {\n                leftRotate(parent(node));\n                brother = right(parent(node));\n            }\n            // 情况3，兄弟的两个孩子为黑。\n            if (color(left(brother)) == Black && color(right(brother)) == Black)\n            {\n                setColor(brother, Red);\n                node = parent(node);\n                // 进入下一次while循环看父节点是黑还是红。遇到红则退出。\n            }\n            else //情况2 兄弟的左孩子是红色，右是黑色\n            {\n                if (color(right(brother)) == Black)\n                {\n                    rightRotate(brother);\n                    brother = right(parent(node));\n                }\n                // 情况1 兄弟的右孩子是红色，左孩子无所谓。\n                setColor(right(brother), Black);\n                leftRotate(parent(node));\n                break;\n            }\n        }\n        else // 右镜像，即删除的节点在根的右支。\n        {\n            Node * brother = left(parent(node));\n            // 情况8，兄弟红。转化为兄弟黑的情况\n            if (color(brother) == RED)\n            {\n                rightRotate(parent(node));\n                brother = left(parent(node));\n            }\n            // 情况7，兄弟的两个孩子为黑。\n            if (color(left(brother)) == Black && color(right(brother)) == Black)\n            {\n                setColor(brother, Red);\n                node = parent(node);\n                // 进入下一次while循环看父节点是黑还是红。遇到红则退出。\n            }\n            else //情况6 兄弟的右孩子是红色，左是黑色\n            {\n                if (color(left(brother)) == Black)\n                {\n                    leftRotate(brother);\n                    brother = left(parent(node));\n                }\n                // 情况5 兄弟的左孩子是红色，右孩子无所谓。\n                setColor(left(brother), Black);\n                rightRotate(parent(node));\n                break;\n            }\n        }\n    }\n    // 直到node指向的节点是红色，则直接涂成黑色，结束。\n    setColor(node, Black);\n}\n```\n分析出，红黑树的删除，最多旋转3次：先左旋、再右旋、再左旋；或者先右旋、再左旋、再右旋。","categories":["C","高级数据结构","树"]},{"title":"快速幂_C语言实现","url":"/算法/快速幂_C语言实现/","content":"# FastPower - 快速幂\n\n在ACM中或有的面试中会考到。核心问题是如何加速算法。\n\n$a^n$即n个a相乘。如何转化？\n\n例：$a^{13_{(10)}}$的计算。\n\n我们可以发现：$a^{4_{(10)}}\\cdot a^{4_{(10)}} = (a^{4_{(10)}})^{2_{(10)}} = a^{8_{(10)}}$\n\n更一般地，（以下为10进制）\n$$\na^1\\\\\n(a^{1})^2 = a^{2}\\\\\n(a^{2})^2 = a^{4}\\\\\n(a^{4})^2 = a^{8}\\\\\n(a^{8})^2 = a^{16}\\\\\n...\n$$\n则$a^{13_{(10)}}$可以转化为$a^{1101_{(2)}} = a^{8_{(10)}}\\cdot a^{4_{(10)}}\\cdot a^{1_{(10)}}$，如此，$a^{13_{(10)}}$的计算不用把a傻傻地连乘13次，而是转化为需要计算3个小的数即可。\n\n所以，整个计算过程可以利用前面计算过程中的中间值进行计算，提高效率。\n\n## 具体算法\n\n把指数看作二进制，对指数最后一位判断是否为1（与1按位与），为1则记录下来处理，之后右移1位，接着判断下一位，如此循环。\n\n```c\nlong long fast_pow(long a, unsigned n)\n{\n    long long product = 1;\n    while(n)\n    {\n        if(n & 1)\n        {\n            product *= a;\n        }\n        a *= a;  // 每次对应 a^2  a^4  a^8 ...\n        n >>= 1;\n    }\n    return product;\n}\n```\n\n","categories":["C","算法"]},{"title":"C语言_文件","url":"/C/C语言_文件/","content":"# 文件\n\n## FILE\n\n```c\ntypedef struct _iobuf\n{\n    void * _Placeholder;\n}FILE;\n_ACRTIMP _ALT FILE* __cdecl __acrt_iob_func(unsigned _Ix);\n```\n\n实际就是一个无符号整型ID值，当做了形式为指针来用了。\n\n为什么要用指针，是为了防止单纯的整型随意被赋值，而不同类型的指针不可以随意赋值，因此可以用指针来阻挡一下，出错概率就小了。\n\n### mode\n\nmode是以内存视角来说的：\n\n1. 从设备写入到内存中是input，是`\"r\"`；\n2. 从内存中写出到磁盘是output，是`\"w\"`。如果文件存在，则删掉内容，从0开始写。\n\n### fopen\n\n```c\nint main()\n{\n    FILE * file = fopen(\"e:\\\\aa.txt\", \"w\");  //绝对路径\n    fclose(file);\n}\n```\n\n`\\`是转义字符，所以，`\\\\`表示`\\`。如果不想写`\\\\`，也可以只写一个`/`\n\n### 写东西\n\n文件中有两个流，输出流和输入流，两个流的指针位置互相独立、互不干扰。指针位置可以用`fseek`、`fsetpos`等改变。\n\n在这里用fwrite写入文件：Write block of data to stream.\n\n```c\nsize_t fwrite(const void * ptr, size_t size, size_t count, FILE * stream);\n// ptr指示缓冲区的起始位置；Pointer to the array of elements to be written, converted to a const void *\n// size是要写入的元素类型的大小\n// count是有多少个元素\n// stream是哪个文件\n// 返回值是指写入了多少个元素，而不是字节数。\n```\n\n```c\nint main()\n{\n    int val = 24;\n    FILE * file = fopen(\"e:\\\\aa.txt\", \"w\");  //绝对路径\n    if(NULL == file) return 0;\n    // 写入一个int。\n    size_t byte_written = fwrite(&val, sizeof val, 1, file);\n    fclose(file);\n    file = NULL;\n}\n```\n\n### 程序中读文件\n\n如果已经有存在的文件，则就不要再执行写入的部分。需要用宏条件语句来控制程序。\n\nfread是Read block of data from stream.\n\n```c\nsize_t fread(void * ptr, size_t size, size_t count, FILE * stream);\n```\n\n```c\nint main()\n{\n    FILE * file = NULL;\n#ifdef _CREATE_FILE__\n    int val = 24;\n    file = fopen(\"e:\\\\aa.txt\", \"w\");\n    if(!file)\n        return 0;\n    size_t num_written = fwrite(&val, sizeof val, 1, file);\n#else\n    int val = 0;\n    file = fopen(\"e:\\\\aa.txt\", \"r\");\n    size_t size_to_read = sizeof val;\n    if(!file)\n        return 0;\n    // 返回的是元素个数，为1个\n    size_t num_read = fread(&val, sizeof val, 1, file);\n    if(num_read == size_to_read)\n        printf(\"%i\\n\", val);\n#endif // _CREATE_FILE__\n    fclose(file);\n    file = NULL;\n    return 0;\n}// 24\n```\n\n### 实际上\n\n默认暂时在缓存区中存放内容，比如向磁盘中写入东西，直到缓冲区满时，才会真正开始写入磁盘。也可以中途调用`fflush`进行立即刷新缓存区。\n","categories":["C"]},{"title":"C语言_链表","url":"/C/C语言_链表/","content":"# 链表\n\n1. 不要求地址连续，因此可以建立在堆上。\n2. 插入的时间复杂度低。\n\n## 节点定义\n\n以下为无头节点的单链表。\n\n```c\ntypedef struct _Node\n{\n    unsigned id;\n    char val;\n    struct _Node * next;\n}Node, *PNode;\n// 指向链表中第1个有效元素的指针，不是教科书上的头节点（头节点是无效值，仅代表标识）\nPNode header = NULL;\n```\n\n## push_back\n\n```c\nvoid push_back(PNode node)\n{\n    PNode current = header;\n    if(current == NULL)\n    {\n        header = node;\n        return;\n    }\n    while(current->next != NULL)\n    {\n        current = current->next;\n    }\n    current->next = node;\n    return;\n}\n```\n\n## make_node\n\n```c\nPNode make_node(unsigned id, char val)\n{\n    PNode node = (PNode)malloc(sizeof(Node));\n    if (node != NULL)\n    {\n        node->id = id;\n        node->val = val;\n        node->next = NULL;\n    }\n    return node;\n}\n```\n\n测试\n\n```c\nint main()\n{\n    PNode node = make_node(1, 'a');\n    push_back(node);\n    node = make_node(2, 'b');\n    push_back(node);\n    node = make_node(3, 'c');\n    push_back(node);\n}\n```\n\n## traversal\n\n```c\nvoid traversal()\n{\n    PNode current = header;\n    while(current != NULL)\n    {\n        printf(\"id: %u, val: %c\\n\", current->id, current->val);\n        current = current->next;\n    }\n}\n```\n\n## `insert_after_id`\n\n```c\nvoid insert_after_id(unsigned id, PNode node)\n{\n    PNode current = header;\n    while(current != NULL)\n    {\n        if(id == current->id) break;\n        current = current->next;\n    }\n    if(current != NULL)\n    {\n        node->next = current->next;\n        current->next = node;\n    }\n    else\n    {\n        push_back(node);\n    }\n}\n```\n\n测试\n\n```c\nint main()\n{\n    PNode node = make_node(1, 'a');\n    push_back(node);\n    node = make_node(2, 'b');\n    push_back(node);\n    node = make_node(3, 'c');\n    push_back(node);\n    traversal();\n    node = make_node(4, 'd');\n    insert_after_id(2, node);\n    traversal();\n}\n//第一次遍历：1 2 3\n//第二次遍历：1 2 4 3\n```\n\n## `insert_before_id`\n\n自己写的版本\n\n```c\nvoid insert_before_id(unsigned id, PNode node)\n{\n    PNode current = header;\n    if(current == NULL)\n    {\n        push_back(node);\n        return;\n    }\n    if(current->id == id)\n    {\n        header = node;\n        node->next = current;\n        return;\n    }\n    while(current->next != NULL)\n    {\n        if(id == current->next->id) break;\n        current = current->next;\n    }\n    if(current->next != NULL)\n    {\n        node->next = current->next;\n        current->next = node;\n    }\n    else\n    {\n        push_back(node);\n    }\n}\n```\n\n测试\n\n```c\nint main()\n{\n    PNode node = make_node(1, 'a');\n    push_back(node);\n    node = make_node(2, 'b');\n    push_back(node);\n    node = make_node(3, 'c');\n    push_back(node);\n    traversal();\n    node = make_node(4, 'd');\n    insert_before_id(1, node);\n    traversal();\n}\n//第一次遍历：1 2 3\n//第二次遍历：4 1 2 3\n```\n\n双指针法\n\n```c\nvoid insert_before(unsigned id, PNode node)\n{\n    PNode p = header, pp = NULL;\n    while(p)\n    {\n        if(p->id == id)\n        {\n            break;\n        }\n        pp = p;\n        p = p->next;\n    }\n    if(!p)//插入的位置为空\n    {\n        push_back(node);\n        return;\n    }\n    // 找到id，且p不为空\n    if(p != NULL && pp == NULL)//第一次while循环即找到了id，即id在首元素，需要插到首位置，要换头。\n    {\n        header = node;\n        node->next = p;\n        return;\n    }\n    // 剩下就是在中间插入的情况了。\n    pp->next = node;\n    node->next = p;\n}\n```\n\n## remove_node\n\n删除指定id\n\n```c\nvoid remove_node(unsigned id)\n{\n    PNode current = header;\n    if(header != NULL && header->id == id)\n    {\n        free(header);\n        header = NULL;\n        return;\n    }\n    PNode prev = NULL;\n    while(current != NULL)\n    {\n        if(id == current->id) break;\n        prev = current;\n        current = current->next;\n    }\n    if(current != NULL)\n    {\n        prev->next = current->next;\n        free(current);\n        current = NULL;\n    }\n}\n```\n\n测试\n\n```c\nint main()\n{\n    PNode node = make_node(1, 'a');\n    push_back(node);\n    node = make_node(2, 'b');\n    push_back(node);\n    node = make_node(3, 'c');\n    push_back(node);\n    traversal();\n    node = make_node(4, 'd');\n    insert_before_id(1, node);\n    traversal();\n    remove_node(1);\n    traversal();\n    remove_node(2);\n    traversal();\n    remove_node(3);\n    traversal();\n    remove_node(4);\n    traversal();\n    remove_node(5);\n    traversal();\n}\n/* 结果：\nid: 1, val: a\nid: 2, val: b\nid: 3, val: c\n\nid: 4, val: d\nid: 1, val: a\nid: 2, val: b\nid: 3, val: c\n\nid: 4, val: d\nid: 2, val: b\nid: 3, val: c\n\nid: 4, val: d\nid: 3, val: c\n\nid: 4, val: d\n\n空\n*/\n```\n\n## 环\n\n### 制造环\n\n标记一个id，之后让尾节点next指向该id\n\n```c\nPNode find_id(unsigned id)\n{\n    PNode current = header;\n    while(current != NULL)\n    {\n        if(current->id == id) break;\n        current = current->next;\n    }\n    return current;\n}\nvoid make_cycle(unsigned id)\n{\n    // 确保有两个节点\n    if(header == NULL || header->next == NULL) return;\n    PNode cycle_begin = find_id(id);\n    // 确保有这个id  并且  确保cycle_begin不是尾节点\n    if(cycle_begin == NULL || cycle_begin->next == NULL) return;\n    PNode current = header;\n    while(current->next != NULL)\n    {\n        current = current->next;\n    }\n    current->next = cycle_begin;\n}\n```\n\n### 如何判断是否有环？快慢指针\n\n一个指针走一步，一个指针走两步。\n\n如果两个指针重合则有环，如果无环的话，快指针肯定能到终点NULL。\n\n```c\nint has_cycle()\n{\n    if (header == NULL || header->next == NULL) return 0;\n    PNode fast = header;\n    PNode slow = header;\n    while (fast != NULL)\n    {\n        fast = fast->next;\n        if(fast != NULL)\n            printf(\"fast1: -> %i\\n\", fast->id);\n        if (fast != NULL)\n        {\n            fast = fast->next;\n            if (fast != NULL)\n                printf(\"fast2: -> %i\\n\", fast->id);\n            slow = slow->next;\n            printf(\"slow: -> %i\\n\\n\", slow->id);\n            if (fast == slow && fast != NULL)\n            {\n                fast = header;\n                while (fast != slow)\n                {\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n                printf(\"有环: %i\\n\", slow->id);\n                return 1;\n            }\n        }\n        else\n        {\n            printf(\"无环\");\n            return 0;\n        }\n    }\n}\nint main()\n{\n    PNode node = make_node(7, '7');\n    push_back(node);\n    node = make_node(5, '5');\n    push_back(node);\n    node = make_node(6, '6');\n    push_back(node);\n    node = make_node(8, '8');\n    push_back(node);\n    node = make_node(2, '2');\n    push_back(node);\n    node = make_node(0, '0');\n    push_back(node);\n    node = make_node(4, '4');\n    push_back(node);\n    traversal();\n    make_cycle(6);\n    has_cycle();\n}\n// 有环：6\n```\n\n让一个快指针和一个慢指针再次相遇当然可以说明此链表有环。但，难点在于如何找到环的入口？\n\n设$x$为头节点到循环入口处的距离，$y$为循环入口处到相遇点的距离，$z$为相遇点到尾节点的距离（即该节点下一个是循环口）。并结合$fast$指针和$slow$指针的步数关系$fast=2slow$，得出在相遇点：$fast=x+n(y+z)+y$，$slow=x+y$（慢指针肯定不会在圈内转完一圈，可以想想，是合理的，因为快指针总比慢指针快$n$圈，肯定在慢指针走完一圈前和它相遇！），则\n$$\n\\begin{align}\nx+n(y+z)+y&=2(x+y)\\\\\nx&=n(y+z)-y\\\\\nx&=n(y+z)-(y+z)+z\\\\\nx&=(n-1)(y+z)+z\\\\\nx&=z\n\\end{align}\n$$\n$y+z$是圈长，我们可以想到，如果快指针要和慢指针相遇，$n$必须要大于等于$1$。至于$n$，即圈数具体为几，实际上无所谓，因为快指针在里面转了$n$圈和$1$圈，效果是一样的！所以我们可以得出，$x=z$！于是，已知$z$为相遇点到尾节点的距离（尾节点下一个是循环口），并且已知$z=x$（$x$为头节点到循环入口处的距离）。那么，让一个指针在相遇点，另一个指针在头节点，同时步进，直到相遇，就是循环入口处！\n\n参考：https://www.bilibili.com/video/BV1if4y1d7ob\n\n## 保存到文件\n\n保存所有节点信息到文件中。成功返回1，失败返回0。\n\n不应当把结构体作为整体完全保存到一行。\n\n而是每个属性一行一行地保存。因为next指针在下次运行失效的。需要按照每个属性重新构建每个节点。\n\n```c\nint save(char const * const filename)\n{\n    return 0;\n}\n```\n\n加载的时候，next指针的信息已经是失效的，需要重新`make_node`。\n\n```c\nint load(char const * const filename)\n{\n    return 0;\n}\n```\n\n","categories":["C","基础数据结构"]},{"title":"C语言_结构体_sizeof_分段","url":"/C/C语言_结构体_sizeof_分段/","content":"# 结构体\n\n>关于`;`的问题：\n>\n>1. 一般来说，大括号`{}`结尾后不用再加`;`。但是结构体的定义中的大括号`{}`后面要加`;`。因为结构体的定义属于数据的定义，只是有了大括号的形式而已，而数据的定义后面都要加`;`，因此结构体的定义中的大括号`{}`后面要加`;`。\n>2. 函数、if语句、for语句中的`{}`是语句的定义，则不用加`;`。\n\n```c\nstruct Stu\n{\n    unsigned id;\n    unsigned char age;\n    char name[10];\n};\n```\n\nC语言中，`struct`和`结构体名字`是一体的，共同才能合成一个类型，不能只写`Stu`。\n\n# 结构体的定义\n\n```c\nint main()\n{\n    struct Stu stu;\n    stu.age = 17;\n    stu.id = 123456;\n    strcpy(stu.name, \"xcg\");\n    printf(\"Age: %u, ID: %u, Name: %s\\n\", stu.age, stu.id, stu.name);\n}\n```\n\n# 结构体的大小\n\n```c\nstruct Test\n{\n    int a;          // 4\n    char b;         // 1  --> 实际: 4\n};\nint main()\n{\n    printf(\"%u\\n\", sizeof(struct Test));\n}// 8\n```\n\n## 字节对齐\n\n为了效率，即使char只占用一个字节，也会以结构体中大的数据类型为参考多占一些空间。如此在传输过程中就无需再去一个一个找分量，而是可以直接按照整体处理。一个时钟周期，64位数据都会一次性传输完成，所以说虽然浪费了一些空间，但换来了提高效率。\n\n1. 每一个元素的偏移量（相对0），都是自身类型大小的整数倍（0也算）。\n2. 结构体的整体大小，是内部最大的基础数据类型大小的整数倍。\n3. 我们控制不了的：**结构体的首地址，是体内最大基本数据类型大小的整数倍。**\n\n```c\nstruct Test\n{\n    int a;          // 4\n    char b;         // 1  --> 实际: 2\n    short c;        // 2\n};//8\nstruct Test\n{\n    int a;          // 4\n    char b;         // 1  --> 实际: 2\n    short c;        // 2\n    char d;         // 1  --> 实际: 4\n};//12\nstruct Test\n{\n    int a;          // 4\n    char b;         // 1\n    char d;         // 1\n    short c;        // 2\n    short e[10];    // 10 --> 12\n};//20\n```\n\n> 有办法关闭字节对齐特性：`#pragma comment package 1`\n\n# typedef\n\n```c\ntypedef struct _Stu\n{\n    unsigned id;\n    unsigned char age;\n    char name[11];\n}Stu;\n```\n\n## 结构体指针类型\n\n```c\ntypedef struct _Stu\n{\n    unsigned id;\n    unsigned char age;\n    char name[11];\n}*PStu;\n```\n\n如此定义，则效果为：`PStu`相当于`Stu*`\n\n`Stu* stu = (Stu*)malloc(sizeof(Stu));`就可以写为\n\n`PStu stu = (PStu)malloc(sizeof(Stu));`\n\n## 星号的结合问题\n\n```c\ntypedef int * PMyInt;\n```\n\n如此定义，`PMyInt`相当于`int*`，即是一个int指针类型。但是，实际上，`*`星号是跟着名字`PMyInt`结合的。`int*`这种写法只是大多数人的习惯而已。\n\n因此，`typedef int MyInt, *PMyInt;`才解释得通。如果`typedef int * MyInt, PMyInt`，则就变成了`MyInt`是指针类型，而`PMyInt`变成了int类型！\n\n# 堆创建结构体\n\n## stdlib\n\nC Standard General Utilities Library\n\n### malloc\n\n分配指定字节数的内存块，返回一个无类型指针，需要强制转换类型。此空间的伸缩不受限制，因此需要显式分配、释放。\n\n在小型设备上如果内存不够，则有可能会返回NULL。\n\n```c\n#include<stdlib.h>\nint main()\n{\n    Stu* stu = (Stu*)malloc(sizeof(Stu));\n}\n```\n\n### free\n\n```c\n#include<stdlib.h>\nint main()\n{\n    Stu* stu = (Stu*)malloc(sizeof(Stu));\n    free(stu);\n    stu = NULL;\n}\n```\n\n为什么要置空？不成文的规定：指针是否有效？由指针是否为空决定。如果指针不空则认为是指向的内容有效。\n\n如果不置空，即在释放指向的内容后依旧保留此指针，就成为了无意义的乱指。称为“野指针”或“迷途指针”。\n\n> 如果反过来：空间内容有效，但指针值丢失，则叫做内存泄漏。\n>\n> 怎么解决？\n>\n> 1. 小心编程\n> 2. 关闭进程，让操作系统收回所有内存\n\n## 结构体指针访问成员\n\n1. `(*stu).age` - `*`优先级是2，`.`优先级是1\n2. `stu->age` - `arrow`运算符。\n\n# 分段\n\n结构体不仅可以把小类型组合成大类型，还能把基本数据类型拆成小块。\n\n使用“位域”运算符（bit field operator）。\n\n```c\nstruct Test\n{\n    int a : 2;\n};\nint main()\n{\n    struct Test test;\n    test.a = 1;\n    printf(\"%i\\n\", test.a);\n}// 1\n```\n\n给`test.a`赋值1是可以的。但给`test.a`赋值2则会打印成`-2`\n\n```c\nint main()\n{\n    struct Test test;\n    test.a = 2;\n    printf(\"%i\\n\", test.a);\n}// -2\n```\n\n因为：a是有符号int型，但只有2位的空间。除去符号位，则只有1位空间。那么，把2这个int字面常量给了a，就相当于：`(10)2`给了a。那么，a实际空间存的是(10)2，因为它是有符号int，而又因为当前符号位是1，所以实际表达的值为：`(10)2`的补码，算出无符号值后，再加个负号，即$(01)_2+1=(10)_2$​得出2，再加个负号，即`-2`。\n\n此时的sizeof大小为多少呢？\n\n```c\nstruct Test\n{\n    int a : 2;\n};// 4  -->  整个int的大小\n```\n\n```c\n//a、b一起分了12个字节，还有20个没分配。因此还是1个int的大小\nstruct Test\n{\n    int a : 2;\n    int b : 10;\n};// 4  -->  1个int的大小\n```\n\n## 分隔符\n\n```c\n//a先分了2个字节，但是a剩下的空间不想再用，加个separator分隔符。\n//在分隔符后定义b。此时是第2个int空间。\nstruct Test\n{\n    int a : 2;\n    int : 0;     // separator  //无名\n    int b : 10;\n};// 8  -->  2个int的大小\n```\n\n下面这个分隔符的意义在于，虽然实际有效的是int类型，但是long long分隔符的作用在于在第一个和第二个int之间划分了8字节的位置，即a实际被提升为8字节大小，b也被提升为8字节大小。\n\n```c\n//a先分了2个字节，但是a剩下的空间不想再用，加个separator分隔符。\n//在分隔符后定义b。此时是第2个int空间。\nstruct Test\n{\n    int a : 2;\n    long long : 0;     // separator  //无名\n    int b : 10;\n};// 16  -->  2个long long的大小\n```\n\n## 实际用处\n\n1. 如果小于8 bits，则用位域运算符。如果是8 bits，则直接用char。\n2. separator一般不用，直接占满上面的空位即可，然后紧接着定义下一个类型。\n","categories":["C"]},{"title":"C语言_函数_栈帧_参数_递归","url":"/C/C语言_函数_栈帧_参数_递归/","content":"# 函数\n\n1. 每个编程语言都有函数。\n2. 函数是代码的模块/容器/载体，代码如果要执行，必须在函数内才能执行。\n\n# 内存结构、地址空间\n\n1. 对于可执行文件（Windows下是exe文件；Linux下是out文件），可执行文件有固定格式，从磁盘中加载到内存后，文件中相应部分的代码、数据等会映射到内存的五个不同的模块中。\n2. 每个程序都认为自己独占了整个的地址空间。如果是32位系统，则程序认为独占了32位的内存空间（0到4G）。这就是虚拟地址空间，自从386就开始有这个概念，便于多路程运行。\n\n# 栈帧\n\n1. m和n是actual parameters.（实参）\n2. a和b是formal parameters.（形参）\n3. 所有的参数都是按值传递的。\n\n```c\n#include<stdio.h>\nvoid bar(int a, int b);\n\nint main()\n{\n    int m = 5, n = 6;\n    bar(m, n);\n    return 0;\n}\nvoid bar(int a, int b)\n{\n    int c = a + b;\n    printf(\"%i\\n\", c);\n}\n```\n\n反了？\n\n![image-20240316220318599](../../images/C语言_20240115_函数/image-20240316220318599.png)\n\n栈是从高地址向低地址扩展的。越后定义的变量地址越低。\n\n`int m = 5, n = 6;`这条语句：先定义n，再定义m，因此n在高地址、m在低地址。\n\n# printf的参数\n\nvariable parameters\n\n```c\nint printf(char const * const _Format, ...);\n```\n\n启示：对外开放的函数，如果要防止误改内容，则加const表明只读，否则别人不敢传参数。\n\n## const是什么\n\nconst有三个位置可以放。\n\n看表达式：\n1. 无论右侧是什么，左侧是int，则右侧也是一个int\n   1. 左侧一个int，右侧一个a。\n\n```c\nint a;\n```\n\n   2. 左侧一个int，右侧是`*a`。`*a`是一个int：表示a这个变量解引用之后则是一个int，则a是一个指向int的指针。\n```c\nint *a;\n```\n\n2. const是修饰右侧东西的。\n   1. 如果在`int`后写const：`*a`是一个不能修改的int值。同理const写到int前面也一样：`const int * a;`。\n\n```c\nint const * a;\n```\n\n   2. 如果在`*`后写const：a是一个不能修改的值。`*a`是一个能修改的int值，a这个变量解引用之后则是一个int，则a是一个指向int的指针，但a是一个不能修改的值。\n\n### 后缀为`.c`测试\n\n```c\nint main()\n{\n    char * p = \"xxx\"; //可以编译通过\n    p[1] = 'M';       //可以编译通过\n}\n```\n\n但在运行阶段，会抛出异常：write access violation\n\n不要企图改变常量区。\n\n### 后缀为`.cpp`测试\n\n```c\nint main()\n{\n    char str[] = \"Hello\";\n    char * p = str;\n    p[2] = 'x';\n}// 是可以通过p间接修改str[]中的值的。\n//最后str[]变为\"Hexlo\"\n```\n\n```c\nint main()\n{\n    char str[] = \"Hello\";\n    char * p = str; \n    p = \"xxx\";// error      //char * p虽然可以改变指针值，但是不能指向常量字符串\n}\n```\n\n```c\nint main()\n{\n    char str[] = \"Hello\";\n    const char * p = str; \n    p = \"aaa\";      //char * p既可以改变指针值，也可以指向常量字符串\n    p[2] = 'x';     //error 虽然p可以指向常量字符串，但是不能间接修改值\n}\n```\n\n```c\nint main()\n{\n    char str[] = \"Hello\";\n    const char * const p = str; \n    p = \"aaa\";//error  //char * p不可以改变指针值，也不能通过p间接修改值\n    p[2] = 'x';//error\n}\n```\n\n## 可变参数\n\n欲用show打印可变参数中第n个值：\n\n需要取函数栈帧中n变量的地址，然后向上寻找n个int大小（因为参数是从高地址到低地址扩展的），即得到可变参数中第n个参数的地址。\n\n栈帧示意图：\n\n![image-20240316231327944](../../images/C语言_20240115_函数/image-20240316231327944.png)\n\n```c\nvoid show(int n, ...);\nint main()\n{\n    show(2, 10, 20, 30, 40, 50);  // 欲打印第2个值，20\n}\nvoid show(int n, ...)\n{\n    // 指针进行整数加运算。\n    printf(\"%i\\n\", *(&n + n));\n}\n//64位下：打印10\n//32位下：正确，打印20\n```\n\n奇怪的是，64位下：打印10；32位下：打印20。因为：int固然是4字节大小，而且`int`的指针加减`1`的大小也应该是4字节（`p + n = p的值 + sizeof(int)* n`）。但是，**在64位下的字长是8字节的，因为地址总线每一次至少会传64位（8字节）的内容。因此，每个int实际占用了8个字节。**所以我们`p+n`仅仅移动了8个字节，只能打到10。\n\n经过调试，可以看到实际的内存内容（16进制）：\n\n![image-20240316234542234](../../images/C语言_20240115_函数/image-20240316234542234.png)\n\n可以看到，`02` `0a` `14` `1e` `28` `32`依次是6个int参数，实际都占用了8个字节。大端地址存放高字节。则如果要打印可变参数中的第n个int，需要`*(&n + 2 * n)`或者把`&n`强制转换为64位大小的`long long*`：`*((long long*)&n + n)`。\n\n```c\nvoid show(int n, ...);\nint main()\n{\n    show(2, 10, 20, 30, 40, 50);  // 欲打印第2个值，20\n}\nvoid show(int n, ...)\n{\n    // 指针进行整数加运算。\n    printf(\"%i\\n\", *((long long*)&n + n));\n}\n//64位下：正确，打印20\n//32位下：错误，打印286331153\n```\n\n但是，这样的话，虽然64位下打印正确了，但是32位下又错了！因为移动了n个8字节，打到了函数栈帧之外！所以，必须想一个能判断32位、64位的通用方法，去控制int指针的大小（即64位下8字节、32位下4字节）。\n\n`Ctrl + 左键`点入`size_t`，会出来一些宏定义：\n\n```c\n#ifdef _WIN64\n    typedef unsigned __int64 size_t;\n    typedef __int64          ptrdiff_t;\n    typedef __int64 intptr_t;\n#else\n    typedef unsigned int     size_t;\n    typedef int              ptrdiff_t;\n    typedef int              intptr_t;\n```\n\n在程序为64位编译时，上面三个会生效、下面会失效；32位编译时反之。\n\n通过这个，可以控制int指针的大小。\n\n```c\nvoid show(int n, ...);\nint main()\n{\n    show(2, 10, 20, 30, 40, 50);  // 欲打印第2个值，20\n}\nvoid show(int n, ...)\n{\n    // 指针进行整数加运算。\n    printf(\"%i\\n\", *((intptr_t*)&n + n));\n}\n//64位下：正确，打印20\n//32位下：正确，打印20\n```\n\n# 数组和函数\n\n```c\n#include<stdio.h>\nvoid bar(int a[8]);\nint main()\n{\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    bar(arr);\n    return 0;\n}\n// 虽然传的是数组类型，但实际退化为指针了\nvoid bar(int a[8])\n{\n    printf(\"%i\\n\", sizeof a);\n}\n// 64位：8\n// 32位：4\n```\n\n虽然形参写的是带元素个数的数组类型，但是因为实际退化为指针了，所以写不写具体数目无所谓：`int a[]`，甚至直接写个`int * a`也是一样的。如果要告知数组具体个数，需要另传一个int参数n。\n\n```c\n#include<stdio.h>\nvoid bar(int * a, int n);\nint main()\n{\n    int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    bar(arr, sizeof arr / sizeof arr[0]);\n    return 0;\n}\nvoid bar(int * a, int n)\n{\n    for(int i = 0; i < n; ++i)\n    {\n        printf(\"%i\\n\", a[i]);\n    }\n}// 1 2 3 4 5 6 7 8 \n```\n\n## 二维数组\n\n行信息丢失，需要用int n代替，而我们要保留列信息，才能保证二维数组的有效。\n\n即传一个包含4列元素的行指针。\n\n```c\nvoid bar(int(*a)[4], int n);\nint main()\n{\n    int arr[2][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}};\n    bar(arr, sizeof arr / sizeof arr[0]);\n    return 0;\n}\nvoid bar(int(*a)[4], int n)\n{\n    for(int i = 0; i < n; ++i, printf(\"\\n\");)\n    {\n        for(int j = 0; j < 4; ++j)\n        {\n            printf(\"%i\\n\", a[i][j]);\n        }\n    }\n}\n// 1 2 3 4\n// 5 6 7 8 \n```\n\n# main参数\n\n```c\nint main(int ac, char * av[])\n{\n    return 0;\n}\n```\n\nac指argument count；av指argument value。\n\n```c\nint main(int ac, char * av[])\n{\n    for(int i = 0; i < ac; ++i)\n    {\n        printf(\"%s\\n\", av[i]);\n    }\n    return 0;\n}\n```\n\n编译程序后，在生成目录下命令行（cmd）测试\n\n```sh\nC:\\Users\\xcg\\Project1.exe #输入的\n\nC:\\Users\\xcg\\Project1.exe #输出的\n\nC:\\Users\\xcg\\Project1.exe -h -m #输入的\n\n#输出的\nC:\\Users\\xcg\\Project1.exe\n-h\n-m\n\n```\n\n## 实质上\n\n实质上，av的类型被退化为了二级指针。\n\n```c\nint main(int ac, char ** av)\n{\n    for(int i = 0; i < ac; ++i)\n    {\n        printf(\"%s\\n\", *(av + i));\n    }\n    return 0;\n}\n```\n\n更安全地，加const，让av指向的内容、av的行数组、av本身不可变\n\n```c\nint main(int ac, char const * const * const av)\n{\n    for(int i = 0; i < ac; ++i)\n    {\n        printf(\"%s\\n\", *(av + i));\n    }\n    return 0;\n}\n```\n\n# 递归\n\n递归表现在：行为一致，只是每次数据不一样。\n\n递归的两大要素：递推公式（状态转移方程）；终止条件。\n\n> 1. 下降的时候执行行为，即行为在调用递归之前，叫首递归\n> 2. 上升的时候执行行为，即行为在调用递归之后，叫尾递归\n> 3. 如果递归前后都有行为，叫中间递归\n\n```c\nvoid show(int n); // show(10) -> 10 9 8 ... 1\nint main()\n{\n    show(10);\n}\nvoid show(int n)\n{\n    if(n < 1) return;\n    printf(\"%i\\n\", n);\n    show(n - 1);\n}\n```\n\n```c\nvoid show(int n); // show(10) -> 1 2 3 ... 10\nint main()\n{\n    show(10);\n}\nvoid show(int n)\n{\n    if(n < 1) return;\n    show(n - 1);\n    printf(\"%i\\n\", n);\n}\n```\n\n## 求加和\n\n```c\nint sum(int n); // 1 + 2 + 3 + ... + 10\nint main()\n{\n    int r = sum(10);\n}\nint sum(int n)\n{\n    if(n == 1) return 1;\n    return n + sum(n - 1);\n}// r = 55\n```\n\n## Hanoi\n\n把`1 ~ n`的盘子通过A、B、C三个柱子挪到全部C。小的在上面，大的在下面。\n\n```c\nvoid hanoi(int n, char from, char via, char to)\n{\n    if(n == 0) return;\n    hanoi(n - 1, from, to, via);\n    printf(\"%d: %c --> %c\\n\", n, from, to);\n    hanoi(n - 1, via, from, to);\n}\n```\n\n测试\n\n```c\nint main()\n{\n    hanoi(3, 'A', 'B', 'C');\n}\n```\n\n```\n1: A --> C\n2: A --> B\n1: C --> B\n3: A --> C\n1: B --> A\n2: B --> C\n1: A --> C\n```\n","categories":["C"]},{"title":"C语言__指针_进阶_多维数组","url":"/C/C语言_指针_进阶_多维数组/","content":"# 指针\n指针是一种特殊的变量，存的是别的变量的内存的地址。提供了一种间接访问方法。\n## 指针的两大要素\n有两大要素：1、存放的内容：变量的起始地址；2、指针的类型：指明长度\n## 引用（take reference）、解引用（dereference）\ntake reference 表示取变量的地址。这是一种间接引用。\n>此处的引用是C语言中的，要和Cpp中的引用区分开。\n\n```c\nint main()\n{\n    int a = 12;\n    // take reference - 引用，取地址\n    int * p = &a;\n    // derefernce - 解引用\n    printf(\"%i\\n\", *p);\n    return 0;\n}//12\n```\n\n## 指针的大小\n\n指针的大小是固定的，只和内存地址相关。32位的系统用的是32位的地址总线，那么指针则是32位大小；64位的系统，那么指针则是64位大小，但是实际上的硬件并不是64根地址总线，而是48根，因为目前基本用不到那么多。\n\n```c\nint main()\n{\n    int a = 12;\n    // take reference - 取地址\n    int * p = &a;\n    printf(\"%i\\n\", sizeof p);\n    return 0;\n}\n//64位：8\n//32位：4\n```\n\n## 二级指针\n\n```c\nint main()\n{\n    int a = 12;\n    // take reference - 取地址\n    int * p = &a;\n    int * pp = &p;\n    // derefernce - 解引用\n    printf(\"%i\\n\", **pp);\n    return 0;\n}\n//12\n```\n\n有`**`这种连解引用，但是没有`&&`这种连取地址！因为第一次取完地址之后得出的是一个值（临时值），不具名且没有固定的内存地址，因此无法连取地址。\n\n> 在Cpp中，右值引用是可以对临时变量“取地址”的，但不是这种连取地址的方式。\n\n## 万能指针`void *`（master/universal pointer）\nmaster/universal pointer。只保留了指针的首地址，只在中间传输地址有用，无法直接解引用。记作`void *`。\n\n要解引用，必须以强制类型转换告知指针的具体的结尾位置在哪才行。\n\n```c\nint main()\n{\n    int a = 12;\n    void * p = &a;\n    printf(\"%i\\n\", *p);//error, 报错：incomplete type is not allowed\n    printf(\"%i\\n\", *(int*)p);\n}\n```\n\n## 案例\n定义一个整型数\n```cpp\nint a;\n```\n定义一个指向整型数的指针\n```cpp\nint * a;\n```\n定义一个指向指针的指针，它指向的指针是一个指向整型数指针\n```cpp\nint ** a;\n```\n定义一个有10个整型数的数组\n```cpp\nint a[10];\n```\n### 指针数组\n定义一个有10个指针的数组，该指针是一个指向整型数的指针\n\n此时需要考虑`*`和`[]`的优先级关系，谁与a先结合？\n`[]`是最高优先级，`*`次之。如题意，我们要定义a为数组，所以不用给`*`加`()`。\n```cpp\nint* a[10];\n```\n### 数组指针\n定义一个指向有10个整型数数组的指针\n\n如题意，我们要定义a为指针，所以需要给`*`加`()`。\n但是如下写是错误的：\n```cpp\nint (*) a[10];\n```\n这才是正确的，需要让`*`和a包在一起。\n```cpp\nint (*a) [10];\n```\n### 函数指针\n定义一个指向函数的指针，该函数有一个整型参数并返回整型数\n\na是个指针，而a右边又需要小括号表示函数的参数类型，所以需要让`*a`加括号。再在最左边标志函数的返回类型。\n```cpp\nint (*a)(int);\n```\n#### 函数名的隐式转换，Cpp中到底要不要加`&`\n在C语言中，函数名bar和`&函数名bar`的效果一样，都是取函数地址。\n>函数名会被隐式转换为函数指针，因此`pfun = bar`和`pfun = &bar`等价。\n\n在Cpp中，对于普通函数，隐式转换同样适用，但对于类成员函数则不是了，如果要取成员函数地址，必须显式加`&`，即`&类名::函数`。且调用时必须用`(obj.*p)()`的形式，来表示哪一个对象实例的调用。\n```cpp\nclass MyClass {\npublic:\n    void func() {}\n};\nint main() {\n    void (MyClass::*p)() = &MyClass::func;\n    MyClass obj;\n    (obj.*p)(); // 成员函数指针调用\n    //p();      // 非法!!!\n}\n```\n如果是静态成员函数，取地址时可以省略 `&`。相应地，通过函数指针调用时，可以直接加小括号，不用解引用。\n\n>为什么普通成员函数（不包括静态成员函数）取地址时必须显式使用 `&`？\n>\n>当我们取一个成员函数的地址时，我们获取到的是一个“成员函数指针”，这个指针并不指向一个普通的函数地址，而是指向一个带有额外 `this` 指针的特殊函数。由于成员函数并不是普通的全局函数或静态函数，编译器需要明确知道你想要的是一个带 `this` 指针的成员函数地址，而不是一个普通的函数指针。\n#### 两种等效的调用形式（C、Cpp均可）\n1. **直接调用**：`pfun();`\n2. **解引用后调用**：`(*pfun)();`\n\n```c\npfun();      // 直接调用\n(*pfun)();   // 解引用后调用\n```\n\n```cpp\n#include<stdio.h>\nvoid bar(void);\nint main()\n{\n    void (*pfun)(void) = &bar; // C语言中也可以用 = bar\n    bar();\n    (*pfun)();\n    return 0;\n}\nvoid bar(void)\n{\n    printf(\"Hello\\n\");\n}\n```\nC语言和Cpp中，都可以直接拿函数指针名字来调用它指向的函数。即**没必要解引用再调用**。\n因为本质上函数调用就是在地址后加`()`，即使是间接地址，也生效。\n```cpp\n#include<stdio.h>\nvoid bar(void);\nint main()\n{\n    void (*pfun)(void) = &bar; // C语言中也可以用 = bar\n    bar();\n    (*pfun)();\n    pfun(); // 等同于(*pfun)(); 等同于bar();\n    return 0;\n}\nvoid bar(void)\n{\n    printf(\"Hello\\n\");\n}\n```\n#### C和Cpp对于函数指针的注意事项\n对于普通全局函数，函数名都会被隐式转换为函数指针，因此`pfun = bar`和`pfun = &bar`等价。\n```cpp\nvoid (*pfun)(void) = bar;  // C和C++均可\nvoid (*pfun)(void) = &bar; // 更显式的写法\n```\n以上是函数签名完全一致的。C语言、Cpp都允许且正确。\n但，如果想要把另外一个不同签名的函数赋给pfun，则C会警告，Cpp则不允许：\n必须把foo强制转换为bar函数对应签名`(void(*)(void))`的函数指针类型才行。\n```cpp\nvoid foo(int);\nvoid (*pfun)(void) = foo; // C中允许（有警告），C++报错\nvoid (*pfun)(void) = (void(*)(void))foo;\n```\n#### 总结\n1. 类型检查\n    1. C中，函数指针可以不管函数签名类型，随意互传，可以编译通过，但是会有警告。\n    2. Cpp中，函数指针互传时必须类型一致。不同类型的需要强转。\n2. 取函数地址\n    1. Cpp中，普通函数名字或者静态成员函数，与C一样，可以隐式转换为函数地址。不用加`&`。\n    2. Cpp中，普通成员函数，取其地址，必须用`&类名::函数`的形式。\n3. 调用\n    1. 普通函数、静态成员函数可以直接用函数指针加小括号调用。\n    2. 普通成员函数，必须绑定对象实例，无法直接调用。因此必须先解引用。如`(obj.*p)`。\n#### 函数指针类型的typedef\n```cpp\nvoid bar(void);\nvoid (*pfun)(void) = bar;   // pfun是变量\ntypdef void(*PFun)(void);   // PFun是类型\nPFun pfun = bar;            // 等效于上面的pfun\n```\n#### 练习：定义函数指针数组\n定义一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回整型数。\n```cpp\nint (*a[10])(int);\n```\n1. 首先是一个数组，则`p[10]`。\n2. 其次，内容是指针，`*p[10]`，因为`[]`优先级比`*`高，则不用加小括号处理。\n3. 指针是指向函数的，得在后面加小括号表示参数类型：`*p[10](int)`，但是`()`优先级比`*`高，则系统会误以为这是函数调用（比如`fun(123);`）如此一来，就得在前面整体加小括号，让`*p[10]`先处理：`(*p[10])(int)`。\n4. 再加上返回类型，则：`int(*p[10])(int)`。\n#### 函数指针：函数的返回值是一个指针，这个指针指向一个数组\na是一个指针，指向一个函数，这个函数的参数为int型，**函数的返回值是一个指针，这个指针指向一个数组**，这个数组有10个元素，每个元素是一个`void *`型指针。\n```c\nvoid*(*(*a)(int))[10];\n```\n\n可以通过 `typedef` 分步定义类型，让声明更清晰：\n```cpp\ntypedef void* ElementType;         // 数组元素类型是 void*\ntypedef ElementType ArrayType[10]; // 数组类型：10个void*元素的数组\ntypedef ArrayType* ArrayPtr;       // 指针，指向上述数组\ntypedef ArrayPtr (*FuncPtr)(int);  // 函数指针，接受int参数，返回ArrayPtr\n\nFuncPtr a;  // 等价于 void*(*(*a)(int))[10]\n```\n\n在C语言中，理解复杂声明需要从变量名开始，逐步向外解析。对于声明 `void*(*(*a)(int))[10];`，我们可以分步拆解：\n1. **变量名 `a`**\n    `a` 是一个指针（由 `*a` 可知）。\n2. **`a` 指向一个函数**\n    `(*a)(int)` 表示 `a` 指向一个函数，该函数接受 `int` 类型的参数。\n3. **函数的返回值类型**\n    函数的返回值是 `*(...)`，即一个指针。\n    进一步分析 `*(*a)(int)`，说明返回值是一个指针。\n4. **指针指向一个数组**\n    `(*(*a)(int))[10]` 表示返回值指向一个包含10个元素的数组。\n5. **数组元素的类型**\n    数组的每个元素是 `void*` 类型（即 `void*` 指针）。\n\n为什么`[10]`要放在后面？\n如果要声明一个指针，指向一个包含10个int元素的数组：\n```cpp\nint (*ptr)[10];  // ptr是一个指针，指向int[10]的数组\n```\n- `ptr` 的类型是 `int(*)[10]`。\n- **语法规则**：`[10]` 必须放在指针标识符 `ptr` 后面，表示指针指向的是一个数组，而不是数组中的单个元素。\n\n如果函数返回一个指向数组的指针，声明如下：\n```cpp\nint (*func(int))[10];  // func是一个函数，接受int参数，返回指向int[10]的指针\n```\n- `func(int)` 是一个函数，返回类型是 `int(*)[10]`。\n- **语法规则**：`[10]` 必须放在函数返回类型的后面，表示返回值是一个指向数组的指针。\n\n此函数的声明和定义为以下形式：\n```cpp\nint (*func(int))[10];\nint main()\n{\n    func(1);\n}\nint (*func(int))[10]\n{\n    int (*arr)[10];\n    return arr;\n}\n```\n以下这么写是错误的：\n```cpp\nint(*)[10] func(int); // error\n```\n#### 函数指针：指向的函数返回值是另一个函数指针\na是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。\n```c\nfloat (*(*a)(int, int, int)) (int);\n```\n#### 函数指针：指向的函数返回值是函数指针数组\na是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型\n\n```c\nint(*(*(*a)(void)) [10])(void);\n```\n# 指针与数组的关系\n\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int * p = arr; //此时arr当做数组的首位int元素的int指针赋给了p\n    printf(\"%i\\n\", *p);//1\n}\n```\n\n## 指针的运算\n\n指针有加减运算。没有乘除运算。但是只能整数计算，不能小数计算。\n\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int * p = arr; //此时arr当做数组的首位int元素(第0位置)的int指针赋给了p\n    p += 2;        //移动2个int长度。即从0位置到2位置了。\n    printf(\"%i\\n\", *p);         //3\n    printf(\"%i\\n\", *(p + 1));   //4\n    printf(\"%i\\n\", *(arr + 1)); //2   (arr + 1)即 移动到第1位置\n}\n```\n\n### 指针减法的应用\n\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int * p = arr; //此时arr当做数组的首位int元素(第0位置)的int指针赋给了p\n    p += 2;        //移动2个int长度。即从0位置到2位置了。\n    printf(\"%i\\n\", p - arr); //2  是两个指针的差值，差出来2个元素\n    \n    int * p2 = p + 3;\n    printf(\"%i\\n\", p2 - p); //3  是两个指针的差值，差出来3个元素\n}\n```\n\n但是要注意，指针类型要一致，如果类型不一致：\n\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int * p = arr; //此时arr当做数组的首位int元素(第0位置)的int指针赋给了p\n    p += 2;        //移动2个int长度。即从0位置到2位置了。\n    printf(\"%i\\n\", p - arr); //2  是两个指针的差值，差出来2个int。\n    \n    char * p2 = p + 3;//注意此处的指针类型是char*\n    printf(\"%i\\n\", p2 - p); //12  p的类型被转换为p2的类型了，差了12个char大小\n}\n```\n\n## 语法糖\n\n1. 可以把上面的`*(p + 1)`直接用`p[1]`表示，那么`arr[1]`也就是`*(arr + 1)`，同理`arr[0]`也就是`*arr`。也就是说，数组的名字可以当做指向**首元素**的指针。可以作`arr + n`这种计算获得数组中后`n`的元素指针。\n2. 但是，不能对`arr`本身进行`+=`、`++`。因为这修改了`arr`本身的值，而数组一旦定义完成是不可删除、移动的。本质上，数组名字是一个const类型的。\n3. sizeof：对于数组名字，sizeof计算出来的是整个数组的大小。而对于sizeof p，(`int * p = arr`)，计算出来的是一个元素的大小。\n4. 除了上面两种特殊情况，数组名字arr和指针完全一样，可以替换使用。\n5. 对数组名进行取地址：`&arr`会是什么？是指向一维数组的指针。`int(*p)[8] = &arr`。用p如何打印数组某一元素？首先得对数组指针解引用`*p`，再对解引用后的值进行加减`*p + 1`（`*`解引用优先级大于`+`，所以不用给`*p`加括号），然后对加减后的值第二次解引用`*(*p + 1)`。**或者：第一次解引用之后，直接`(*p)[1]`。**\n\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int(*p)[8] = &arr;\n    printf(\"%i\\n\", *(*p + 1)); //2\n}\n```\n\n但是要注意：虽然`int(*p)[8] = &arr`把数组地址（不是首元素地址，虽然值一样）取出来了，即使值和首元素地址一样，但是它和数组首元素指针是有区别的，`&arr`的全部实际意义指的是从0到7的整个范围。如何证明呢？可以用`p + 1`来说明：p+1后p指向了整个数组的末尾。\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int(*p)[8] = &arr;\n    printf(\"%i\\n\", *(p + 1)); //-85893460  - 打印出来一个未定义值，因为p+1后指向了整个数组的末尾。\n}\n```\n\n如果p+1后，要打印数组中的内容6，则得用`(*(p + 1))[-3]`来打印。\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int(*p)[8] = &arr;\n    printf(\"%i\\n\", (*(p + 1))[-3]); //6 \n}\n```\n\n反过来讲，如果对p解引用：`*p`（`int(*p)[8] = &arr`），虽然值没变，都是首地址。但是解引用后的`*p`对应的是单个元素的指针，就失去了数组大小的属性。\n\n**结论：一维数组arr名字相当于元素指针，对数组名字取地址，则取到整个数组的指针，是行指针。如果对行指针解引用，则得到了元素指针。针对元素指针，可以移动，再次解引用，去取任意位置的元素。**\n\n# 二维数组\n\n上面5讨论的是指针`*`形式的解引用。如果要用中括号来取元素呢？\n\n```c\nint main()\n{\n    int arr[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    int(*p)[8] = &arr;\n    //printf(\"%i\\n\", *(*p + 1)); //2\n    printf(\"%i\\n\", p[0][1]);     //2\n}\n```\n\n`*(*p + 1)`等同于`p[0][1]`所以，实质上，指向一维数组的指针，是一种特殊的二维数组，即只有一行的二维数组。\n\n## 初始化\n\n```c\nint main()\n{\n    int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n    for(int i = 0; i < 2; ++i)\n        for(int j = 0; j < 4; ++j)\n            printf(\"%i\\n\", a[i][j]);\n}// 1 2 3 4 5 6 7 8\n```\n\n```c\nint main()\n{\n    int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n    // 欲打印数组中值为6的元素，则需要取出（从0开始）第1行、第1列的元素\n    printf(\"%i\\n\", a[1][1]);\n}\n// 6\n```\n\n## 取二维数组的地址\n\n打印6时，`[]`比`*`优先级高，因此`*p`需要加括号。如果不加括号，则先运算`p[1][1]`，再解引用，就完全不对了，`p[1]`指的是（从0开始）第1个二维数组，直接跨过了本身全部的数据。\n\n```c\nint main()\n{\n    int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n    int(*p)[2][4] = &a;\n    // 欲打印数组中值为6的元素，则需要取出（从0开始）第1行、第1列的元素\n    printf(\"%i\\n\", (*p)[1][1]); // []比*优先级高，因此*p需要加括号。\n}\n// 6\n```\n\n如何用纯指针方式打印6。\n\n```c\nint main()\n{\n    int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n    int(*p)[2][4] = &a;\n    printf(\"%i\\n\", *(*(*p + 1) + 1));\n}\n```\n\n## 二维数组的本质内存结构\n\n内存只有1维结构。\n\n设arr是一维数组`arr[8]`，a是二维数组`a[2][4]`。则`a[1][1] => arr[4 * 1 + 1] => arr[5]`\n\n### 用一维数组指针指向二维数组\n\n```c\nint main()\n{\n    int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n    int(*p)[8] = (int(*)[8])&a;\n    printf(\"%i\\n\", (*p)[5]);\n}// 6\n```\n\n# 三维数组\n\n用上面的二维数组指针p，只用中括号，打印6。\n\n```c\nint main()\n{\n    int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n    int(*p)[2][4] = &a;\n    printf(\"%i\\n\", p[0][1][1]);\n}\n```\n\n`*(*(*p + 1) + 1)`等同于`p[0][1][1]`所以，实质上，指向二维数组的指针，是一种特殊的三维数组，即只有一个面的三维数组。\n\n## 初始化\n\n```c\nint main()\n{\n    int a[2][2][2] = { \n        { { 1, 2 }, { 3, 4 } },   // 面0\n        { { 5, 6 }, { 7, 8 } }    // 面1 \n    };\n}\n```\n\n## 取三维数组的地址\n\n```c\nint main()\n{\n    int a[2][2][2] = { \n        { { 1, 2 }, { 3, 4 } },   // 面0\n        { { 5, 6 }, { 7, 8 } }    // 面1 \n    };\n    int(*p)[2][2][2] = &a;\n    printf(\"%i\\n\", (*p)[1][0][1]);     //      第1面，第0行，第1列\n    printf(\"%i\\n\", *(**(*p + 1) + 1)); // 第0体，第1面，第0行，第1列\n    printf(\"%i\\n\", p[0][1][0][1]);     // 第0体，第1面，第0行，第1列\n}\n// 6\n// 6\n// 6\n```\n\n`*(**(*p + 1) + 1)`等同于`p[0][1][0][1]`所以，实质上，指向3维数组的指针，是一种特殊的4维数组，即只有一个体的3维数组。\n\n## 三维数组的应用\n\n1. 三维建模。面、地形、探测、体元素、医疗。\n\n# 关联性\n\n## 降维\n\n`int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };`\n\n如何 让p 是一个 相当于 二维数组a的名字？\n\n首先分析，二维数组名字 相当于 行指针。一行有4个元素，因此是指向4个元素的数组指针\n\n> 1. 一维数组的名字相当于列指针（元素指针）\n> 2. 二维数组的名字相当于行指针（列数个元素的一维数组指针）\n> 3. 三维数组的名字相当于面指针（行数个元素$\\times$列数个元素的二维数组指针）\n\n```c\nint main()\n{\n    int a[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n    // 数组a降维至0维，损失了行数、列数\n    int * p = a;\n    // 数组a变换维至1维\n    int(*p)[8] = (int(*)[8])&a;\n    // 数组a\n    int(*p)[2][4] = &a;\n    \n    // 如何 让p 是一个 相当于 二维数组名字？\n    // 首先分析，二维数组名字 相当于 行指针。一行有4个元素，因此是指向4个元素的数组指针\n    // 数组a降维至1维，损失了行数。\n    int(*p)[4] = a;\n    printf(\"%i\\n\", p[1][1]);\n    \n    // 如何 让p 是一个 相当于 3维数组名字？\n    // 首先分析，3维数组名字 相当于 面指针。一面有2×2个元素，因此是指向2×2个元素的数组指针\n    // 数组a降维至2维，损失了面数。\n    int(*p)[2][2] = a;\n    printf(\"%i\\n\", p[1][0][1]);\n}\n```\n\n## 计算数组行数、列数大小\n\n遍历三维数组打印\n\n```c\nint main()\n{\n    int a[2][2][2] = { \n        { { 1, 2 }, { 3, 4 } },   // 面0\n        { { 5, 6 }, { 7, 8 } }    // 面1 \n    };\n    for(int i = 0; i < sizeof a / sizeof a[0]; ++i)\n        for(int j = 0; j < sizeof a[0] / sizeof a[0][0]; ++j)\n            for(int k = 0; k < sizeof a[0][0] / sizeof a[0][0][0]; ++k)\n                printf(\"%i\\n\", a[i][j][k]);\n}// 1 2 3 4 5 6 7 8\n```\n\n","categories":["C"]},{"title":"C语言_数组_字符串","url":"/C/C语言_数组_字符串/","content":"# 数组\n\n## 初始化\n\n```c\nint main()\n{\n    int a[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    for(int i = 0; i < 8; ++i)\n    {\n        printf(\"%i\\n\", a[i]);\n    }\n}// 1 2 3 4 5 6 7 8\n```\n\n初始化时，方括号内的数字可以省略\n\n```c\nint main()\n{\n    int a[] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    for(int i = 0; i < 8; ++i)\n    {\n        printf(\"%i\\n\", a[i]);\n    }\n}// 1 2 3 4 5 6 7 8\n```\n\n不给具体值，则里面装的是未定义值。\n\n```c\nint main()\n{\n    int a[8];\n    for(int i = 0; i < 8; ++i)\n    {\n        printf(\"%i\\n\", a[i]);\n    }\n}// -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460 -858993460\n```\n\n只给一个1，则里面装有1个1和7个0\n\n```c\nint main()\n{\n    int a[] = { 1 };\n    for(int i = 0; i < 8; ++i)\n    {\n        printf(\"%i\\n\", a[i]);\n    }\n}// 1 0 0 0 0 0 0 0\n```\n\n只给一个1和2，则里面装有1个1、1个2和6个0。而且与编译版本无关，Debug和Release版本的行为一致。\n\n```c\nint main()\n{\n    int a[] = { 1, 2 };\n    for(int i = 0; i < 8; ++i)\n    {\n        printf(\"%i\\n\", a[i]);\n    }\n}// 1 2 0 0 0 0 0 0\n```\n\n所以不要误会，初始化时只给一个0，只是恰巧全是0，如果只给一个1，那么不会全是1。\n\n## 通用化遍历输出\n\n1. `sizeof`+`数组名`=`整个数组所占的字节大小`\n2. `sizeof`+`数组名[0]`=`数组一个单独元素的大小`。既然有一个数组被定义出来，里面一定有一个元素，则`数组名[0]`一定存在。\n3. 则`整个数组所占的字节大小`/`数组一个单独元素的大小`=`数组元素个数`\n\n```c\nint main()\n{\n    int a[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };\n    for(int i = 0; i < sizeof a / sizeof a[0]; ++i)\n    {\n        printf(\"%i\\n\", a[i]);\n    }\n}// 1 2 3 4 5 6 7 8\n```\n\n## 特质\n\n数组一旦建立之后，就不能再改动它的属性了，比如容量。\n\n# 字符串\n\n如果数组中放的是如ASCII的字符，则可以输出一个字符串。但是如果全部遍历的话会出现无效信息。\n\n```c\nint main()\n{\n    char a[8] = { 'H', 'e', 'l', 'l', 'o' };\n    for(int i = 0; i < sizeof a / sizeof a[0]; ++i)\n        printf(\"%c\\n\", a[i]);\n}\n//H\n//e\n//l\n//l\n//o\n//空行  //实际为'\\0'+'\\n'\n//空行  //实际为'\\0'+'\\n'\n//空行  //实际为'\\0'+'\\n'\n//光标最终位置\n```\n\n## 普通char数组加哨兵模式进行遍历输出\n\nASCII码标准中规定，char值为0表示NULL，因此在字符数组中可以代表哨兵位，意味着此位之后的值无效。字符数组在实际中往往不知道有效位数，因为它是由哨兵位动态确定的，因此应该用while+break进行遍历输出字符。\n\n```c\nint main()\n{\n    char a[8] = { 'H', 'e', 'l', 'l', 'o', '\\0' };\n    int i = 0;\n    while(a[i] != '\\0')\n        printf(\"%c\", a[i++]);\n}\n//Hello\n```\n\n## C语言提供的字符数组简洁化操作\n\n### 初始化\n\n如下，其实`\"Hello\"`的本质就是`{ 'H', 'e', 'l', 'l', 'o', '\\0' }`。是一种语法糖\n\n```c\nint main()\n{\n    char a[8] = \"Hello\"; // \"Hello\"的本质是{ 'H', 'e', 'l', 'l', 'o', '\\0' }\n    int i = 0;\n    while(a[i] != '\\0')\n        printf(\"%c\", a[i++]);\n}\n//Hello\n```\n\n### 输出\n\nprintf中`%s`可以直接输出一个字符数组。\n\n```c\nint main()\n{\n    char a[8] = \"Hello\"; // \"Hello\"的本质是{ 'H', 'e', 'l', 'l', 'o', '\\0' }\n    printf(\"%s\", a);\n}\n//Hello\n```\n\n但是注意，`{ 'H', 'e', 'l', 'l', 'o', '\\0' }`和`\"Hello\"`不能完全等同。`\"Hello\"`的功能大于`{ 'H', 'e', 'l', 'l', 'o', '\\0' }`，`\"Hello\"`可以直接被`%s`输出，而`{ 'H', 'e', 'l', 'l', 'o', '\\0' }`不能。\n\n```c\nint main()\n{\n    printf(\"%s\", \"Hello\");                             //ok\n    //printf(\"%s\", { 'H', 'e', 'l', 'l', 'o', '\\0' }); //error\n}\n//Hello\n```\n\n## 操作字符串的C系统库函数\n\n微软下调用有写入操作的字符串库函数时，默认不允许使用不带`_s`的函数。可以在VS如下设置即可使用不带`_s`的普通函数：右键项目-属性（Configuration Properties）-`C/C++`-Preprocessor-Preprocessor Definitions下拉-Edit-在已有内容后换行写入`_CRT_SECURE_NO_WARNINGS`-OK\n\n1. strlen\n\n2. strcpy\n\n3. strcat\n   ```c\n   void str_cat(char des[], char src[])\n   {\n       int i = 0, j = 0;\n       while(des[i++]);//找到des的末尾\n       --j;//上面找到末尾后多移了一位，需要前移到第一个\\0位置\n       while(des[i++] = src[j++]);\n   }\n   ```\n\n   以上虽然可以达到目的，但是我们应该尽量利用`i`和`j`之间的相对位置关系，可以更进一步地优化性能：\n\n   ```c\n   void str_cat(char des[], char src[])\n   {\n       int i = 0, j = 0;\n       while(des[i++]);//找到des的末尾\n       --j;//上面找到末尾后多移了一位，需要前移a到第一个\\0位置\n       while(des[i + j] = src[j++]);\n   }\n   ```\n\n   以上，省略了一个`i++`的步骤，达到了性能的极致优化，而不是滥用后置`++`。\n\n4. strcmp\n   依次比较两个字符串中的字符，一旦不相等则返回，如果在一直相等的前提下，一旦遇到`\\0`则返回。\n\n   ```c\n   int str_cmp(char str1[], char str2[])\n   {\n       int i = 0;\n       while(str1[i] == str2[i] && str1[i] != '\\0')\n           ++i;\n       return str1[i] - str2[i];\n   }\n   ```\n\n5. strstr - locate sub string - 此处为朴素算法，提高版的有KMP、BM算法。\n   库函数返回的是一个char指针，我们此处返回子串具体开始的下标值。\n\n   ```c\n   int str_str(char str[], char substr[])\n   {\n       int i = 0, j = 0;\n       while(str[i] != '\\0')\n       {\n           while(str[i + j] == str[j] && str[j] != '\\0')\n               ++j;\n           if(str[j] == '\\0')\n           {\n               return i;\n           }\n           else//str[i + j] != str[j]\n           {\n               j = 0;\n               ++i;\n           }\n       }\n       return -1;\n   }\n   ```\n\n### 总结\n\n字符串的算法思想，归纳出来可以总结为：很多时候需要找到最长的路线，即为临界点，从这个临界点退出循环则开始进行各种情况的分支，再一一去解决、处理。\n","categories":["C"]},{"title":"C语言_运算符_语句","url":"/C/C语言_运算符_语句/","content":"# 优先级表格\n\n左结合的意思：先计算运算符左侧的内容；右结合就是先计算运算符右侧的内容。\n\n![Priority & Binding Property in C](../../images/C语言_20240109/Priority&BindingPropertyinC.png)\n\n## 举几个例子\n\n```c\n- 5 + 3 % 2    -> -4\n  3 * 7 % 3    -> 0\n- i++   (i=5)  -> 表达式值是-5, i值为6\n-i+++i++\n正确： - i ++ + i ++  -> 表达式值是0 , i值为7\n错误： - i + ++i++    -> 错误，因为无论哪个++先操作，返回的都是一个不具名的临时变量，后一个++无法操作于临时无名变量。\n```\n\n1. 后置`++`是等整个表达式计算完之后，再进行`++`；前置`++`是先`++`再参与到表达式中。\n\n2. 自增自减符（`++`、`--`）只能用于更改具名的变量，不能更改没有固定内存地址的操作数。\n\n3. 而加减乘除（`+` `-` `*` `/`）不能修改操作数，只能把每个操作数串联起来，组成表达式，最后计算值。\n4. 能改变变量本身的运算符只有`++`、`--`和赋值运算符（`=` `+=` `&=` `>>=`等等）\n\n## 赋值运算符\n\n```c\nx = 3 * 4    ->  x为12, 表达式也为12\nx = y = 3    ->  连续赋值，右结合，先计算y=3子表达式，表达式值为3，则 -> x=3\nx += p       ->  x = x + p\nx *= y - 3   ->  - 减号优先级大于 *= -> x = x * (y - 3)\n```\n\n## 关系运算符\n\n```c\n//a = 100, b = 99, c = 101, ch = 98\na > b == c      ->  1 == 101  -> 0\nch > 'a' + 1    ->  98 > 98   -> 0\nd = a + b > c   ->  d = 199 > 101 -> d = 1 -> 1\nb - 1 == a != c ->  ==和!=同优先级，左结合 -> 98 == 99 != 101 -> 0 != 101 -> 1\n```\n\n比较大小的关系运算符会返回boolean（真、假），其中0代表假，非零代表真。系统返回的真值默认为1。\n\n## 逻辑运算符`&&` `||`\n\n`&&`比`||`优先级高。\n\n```c\n//a = 100, b = 99, c = 101, x = 4, y = 6\na || b && c       -> 先计算 b&&c -> a || 1      -> 1\n!a && b           -> ! 比&&优先级高, 0 && b      -> 0\nx >= 3 && x <= 5  -> >=比&&优先级高, 1 && 1      -> 1\n!x == 2           -> ! 比==优先级高, 0 == 2      -> 0\na || 3 + 10 && 2  -> + 优先级最高,  a || 13 && 2 -> a || 1 -> 1\n```\n\n## 逗号（坑）\n\n1. 逗号用在3个地方。一个是定义和初始化，一个是逗号表达式，还有传参的分隔。\n2. 逗号运算符是优先级别最低的（一定要记住，比`=`还低）。\n3. 逗号运算符遵循左结合，即从左到右依次计算，最后逗号表达式的值为最右边的值。\n\n```c\nint main(void)\n{\n    int x = 5, y = 7;\n    x + y, 6 - y, 9;   //表达式值为9\n}\n```\n\n### 定义和初始化\n\n```c\nint x = 5, y = 7;\nint z = x + y, 6 - y, 9; //error，前面如果有声明类型，不能在后面写逗号表达式\n```\n\n```c\nint x = 5, y = 7, z = 0; \nz = x + y, 6 - y, 9;     //z被赋为12，但是因为逗号的优先级比=低，所以最后这个表达式值为9\n```\n\n### 函数传参中的逗号\n\n这里会有坑出现。（ 类似于量子测不准现象 doge\n\n```c\nprintf(\"%i\\n\",  x + y, 6 - y, 9 );   //打印出来为 x+y -> 12\nprintf(\"%i\\n\", (x + y, 6 - y, 9));   //加了括号之后, 打印9\n```\n\n这是因为，printf函数中有可变参，如果不加括号，则会把逗号视为参数的分隔符。\n\n```c\nprintf(const char * const format, ...)\n```\n\n### 后置`++`和逗号的爱恨情仇\n\n```c\nint x = 5, y = 7, z = 0;\nz = (x + y++, 6 - y++, 9, y);  //z最后的值为9\n```\n\n在本次测试中，逗号表达式的值为9，即y在逗号表达式结束前就自增了，也就是说后置`++`这个平时动作最慢的老家伙也穿越不了逗号。看来逗号可以被封为无敌懒神。\n\n然而，这只是本次测试的情况，后置`++`有时候比较讨厌，行为有时不一致，这和不同编译器不同的实现有关。\n\n```c\nint x = 5, y = 7, z = 0;\nz = x + y++, 6 - y++, 9, y;  //z最后的值为12\n```\n\n括号是`++`和逗号的他俩的定心丸（其实也称得上搅屎棍），如果括号去掉，则z最后就等于12，即在y自增前把x+7赋给z。\n\n## 按位运算符\n\n位运算符直接操作变量的机器码（二进制）。\n\n### 应用\n\n1. 网络程序中有时要专门处理某些位\n2. 工业控制中控制标识位\n3. 异或用于加密\n\n```c\n#define A 0b0001\n#define B 0b0010\n#define C 0b0100\n#define D 0b1000\n```\n\n要求，在不干扰其他灯的情况下，让B灯亮，按位或：\n\n```c\n1000  ->  1010\nP |= B:\n    1000\n  | 0010\n  -------\n    1010\n```\n\n检查B灯的亮灭，按位与：\n\n```c\n1000  ->  返回一个0值或非0值\nP & B:\n    1000\n  & 0010\n  -------\n    0000\n```\n\n灭掉B，先按位非后按位与：\n\n```c\n1010  ->  0000\n~B:\n  ~ 0010\n  -------\n    1101\nP &= ~B:\n    1010\n  & 1101\n  -------\n    1000\n\n```\n\n异或用于加密：\n\n```c\ntext     ->   1101\npassword ->   0011\n            ^\n            -------\nlocked        1110\npassword      0011\n            ^\n            -------\ntext          1101\n```\n\n## 移位运算符\n\n```c\nint main(void)\n{\n    unsigned char a = 14u;     //0000 1110  \n    unsigned char b = a >> 1;  //0000 0111  -> 7\n}\n```\n\n```c\nint main(void)\n{\n    unsigned char a = 128u;     //1000 0000  \n    unsigned char b = a >> 1;   //0100 0000  -> 64\n}\n```\n\n```c\nint main(void)\n{\n    char a = 128u;              //1000 0000  -> 无符号转为有符号 a 为-128\n    unsigned char b = a >> 1;   //1100 0000  -> 有符号转为无符号 b 为 192\n}\n```\n\n可得，对于有符号数，移位运算符保留了符号属性。如果不想保留符号特性，可以让操作数强制转为unsigned，如下：\n\n```c\nint main(void)\n{\n    char a = 128u;         //1000 0000  -> 无符号转为有符号 a 为-128\n    unsigned char b = (unsigned char)a >> 1; //0100 0000 -> b为64\n}\n```\n\n## 总结\n\n（笃定地讲）所有表达式最后肯定会产生一个临时值，如果没有值产生，就不是表达式，而是一个语句。\n\n# 语句\n\n1. 顺序语句\n2. 分支语句\n\n   1. if\n   2. \n3. 循环\n\n   1. while\n   2. do-while\n   3. for\n   \n\n## 分支语句\n\n```c\nint main(void)\n{\n    if (0)\n        printf(\"true\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}\n```\n\n```c\nint main(void)\n{\n    int x = 2;\n    if (x == 1)\n        printf(\"true\\n\");\n    else if (x == 2)\n        printf(\"true2\\n\");\n    else\n        printf(\"false\\n\");\n    return 0;\n}\n```\n\n### switch-case\n\n```c\nint main()\n{\n    if(a == 1)\n        printf(\"1\\n\");\n    else if(a == 2)\n        printf(\"2\\n\");\n    else if(a == 3)\n        printf(\"3\\n\");\n    else if(a == 4)\n        printf(\"4\\n\");\n    else\n        printf(\"else\\n\");\n    \n    switch(a)\n    {\n        case 1:\n            printf(\"1\\n\");\n            break;\n        case 2:\n            printf(\"2\\n\");\n            break;\n        case 3:\n            printf(\"3\\n\");\n            break;\n        case 4:\n            printf(\"4\\n\");\n            break;\n        default:\n            printf(\"else\\n\");\n            break;\n    }\n}\n```\n\n上面这个程序的所达到的效果，在逻辑上，if-else和switch-case是一样的。\n\nswitch后面括号内的变量只支持整型或枚举类型，枚举类型也是整型的一种。\n\n如果分支很多且判别表达式值为整型，则使用switch-case更合适。\n\n如果抛去这两个限制（分支的多少和判别表达式值的类型），则性能上switch-case更有优势：\n\n1. 编译器直接把case中的编号当做偏移量，对应到相应的内存地址上了。\n2. 于是直接略过了判断前面的过程，直接去找相应的分支。\n\n## 循环\n\n### while\n\n```c\nint main(void)\n{\n    while (1)\n        printf(\"Hello\");\n}\n```\n\n```c\nint main(void)\n{\n    while (1)\n    {\n        printf(\"Hello\");\n        break;\n    }\n}\n```\n\ncontinue\n\n```c\nint main(void)\n{\n    while (1)\n    {\n        printf(\"Hello\");\n        continue;\n        printf(\"end\"); //不走\n    }\n}\n```\n\n求1到100加和：自然终止\n\n```c\nint main(void)\n{\n    //sum: 1 ~ 100\n    int i = 1, sum = 0;\n    while (i <= 100)\n        sum += i++;\n    printf(\"sum: %i\\n\", sum); // 5050\n}\n```\n\n求1到100加和：条件break终止\n\n```c\nint main(void)\n{\n    //sum: 1 ~ 100\n    int i = 1, sum = 0;\n    while (1)\n    {\n        sum += i++;\n        if (i > 100)\n            break;\n    }\n    printf(\"sum: %i\\n\", sum); // 5050\n}\n```\n\n### do-while\n\n不管while括号内条件是否符合，至少执行一次循环体。\n\n```c\nint main()\n{\n    int i = 10;\n    do\n    {\n        printf(\"Hello\\n\");\n    }while(i < 10);  // 因为最后不是大括号结尾的，所以要加上;\n}\n```\n\n### for\n\nfor后的括号内是三条语句。第一条只运行一次，第二条是每次进入循环时都要判断，第三条是每次循环体运行完后执行。\n\n```c\nint main(void)\n{\n    //sum: 1 ~ 100\n    int sum = 0;\n    for (int i = 1; i <= 100; ++i)\n    {\n        sum += i;\n    }\n    printf(\"sum: %i\\n\", sum); // 5050\n}\n```\n\n### 九九乘法表\n\n```c\nint main(void)\n{\n    for(int i = 1; i <= 9; ++i, printf(\"\\n\"))\n    {\n        for(int j = 1; j <= i; ++j)\n        {\n            printf(\"%i*%i=%-2i \", j, i, i * j);\n        }\n    }\n}\n```\n\n1. `printf`中的`%-2i`代表有符号整数，附加的效果是占两位，**左对齐**（负号的作用）。\n2. `for`表达式中的第三个表达式是最后做的处理，往往不需要返回值。在本例中，第一层for循环代表行的处理，第二层for循环代表列的处理，每当第二层for循环完毕后，需要换行，即每当第一层for循环体内容结束后，需要做两个事情：1、i加1；2、换行，可以合并为逗号表达式放在for表达式第三个空中。因为for括号中的第三个语句没有人来接受它的返回值，所以可以直接写printf这种无返回值的函数。\n\n![image-20240120173829903](../../images/C语言_20240109/image-20240120173829903.png)\n\n### 总结\n\n1. while循环往往适用于不清楚运行次数的，不能精准控制步长的情况。\n2. for循环适用于知道运行次数的情况：需要明白i的范围、步长。\n","categories":["C"]},{"title":"C语言_变量_常变量_作用域_static","url":"/C/C语言_变量_常变量_作用域_static/","content":"# 作用域\n\n## 局部变量\n\n```c\n#include<stdio.h>\nvoid bar();\nint main()\n{\n    bar();\n    bar();\n    return 0;\n}\nvoid bar()\n{\n    int val = 10;\n    printf(\"%i\\n\", val++);\n}\n```\n\n以上程序两次都打印10。因为val的作用域只生存在函数当时所分配的栈帧中，此变量为自动/局部变量（auto/local variable），函数调用结束后变量自动销毁。\n\n## 全局变量\n\n全局变量（global variable）。\n\n```c\n#include<stdio.h>\nvoid var();\nint val = 10;\nint main()\n{\n    bar();\n    bar();\n    return 0;\n}\nvoid bar()\n{\n    printf(\"%i\\n\", val++);\n}\n```\n\n第一次打印10，第二次打印11。\n\n### 多文件下使用全局变量 - extern\n\n```c\n//文件A\n#include<stdio.h>\nvoid var();\n//int val = 10;\nextern int val;\nint main()\n{\n    bar();\n    bar();\n    return 0;\n}\nvoid bar()\n{\n    printf(\"%i\\n\", val++);\n}\n//文件B\nint val = 10;\n```\n\n1. 只需要声明，不用赋值。\n2. extern声明之后不会再次分配额外的空间\n3. extern在编译时不检查。\n4. extern在链接时会检查其他文件中实际有没有这个变量。\n\n## 更优雅的全局变量 - 静态变量\n\n### static修饰变量和函数的作用\n\n- **static修饰变量：** 在函数内部使用static修饰变量时，该变量称为静态局部变量。它的生命周期延长到整个程序运行期间，但作用域仅限于定义它的函数内部。静态局部变量在每次函数调用时不会被重新初始化，而是保留上一次调用结束时的值。\n\n```c\n#include <stdio.h>\n\nvoid exampleFunction()\n{\n    // 静态局部变量\n    static int counter = 0;\n    counter++;\n    printf(\"Counter: %d\\n\", counter);\n}\n\nint main()\n{\n    exampleFunction();  // 输出：Counter: 1\n    exampleFunction();  // 输出：Counter: 2\n    exampleFunction();  // 输出：Counter: 3\n    \n    return 0;\n}\n```\n\n在这个例子中，静态局部变量`counter`在每次函数调用之间保留其值，而不会被重新初始化。\n\n- **static修饰函数：** 在函数声明或定义时使用static修饰，将函数的链接属性变为内部链接，限制其作用域在当前源文件内。这样，其他源文件无法调用这个静态函数。\n\n```c\n#include <stdio.h>\n\n// 静态函数声明，限制其作用域在当前源文件内\nstatic void staticFunction()\n{\n    printf(\"This is a static function.\\n\");\n}\nint main()\n{\n    staticFunction();  // 可以调用静态函数\n    return 0;\n}\n```\n\n在这个例子中，使用static修饰的函数`staticFunction`只能在当前源文件内被调用。\n\n### static声明语句什么时候执行\n\n```c\n#include<stdio.h>\nvoid var();\n\nint main()\n{\n    bar();\n    bar();\n    return 0;\n}\nvoid bar()\n{\n    static int val = 10;\n    printf(\"%i\\n\", val++);\n}\n```\n\n之前我一直以为static在函数第一次调用时会被执行，其他时候函数调用则跳过。经过调试，发现，static语句在第一次调用函数时也会直接跳过这条语句。这说明static变量在main函数执行前就被初始化了。\n\n### static的本质\n\n1. 本质上还是一个全局变量\n2. 在应用程序建立的时候，静态变量就创建好了。\n3. 在程序中写的意义只是说明变量名字的可见范围。**如果写在大括号（不仅是函数体大括号，所有大括号都算）里，则出了大括号后就不认识该标识符**；如果写在main函数外，则可见范围仅限于此文件，所有函数都可见。\n   1. 如果函数里、函数外定义了同名static变量则：就近原则，优先选择本函数里的！\n\n```c\n#include<stdio.h>\nvoid fun()\n{\n\tstatic int val = 1;\n}\nint main()\n{\n\tprintf(\"val: %i\\n\", val);  // error, can't find val\n}\n```\n\n```c\n#include<stdio.h>\nstatic int val = 34;\nvoid fun()\n{\n\tstatic int val = 1;\n}\nint main()\n{\n\tfun();\n\tprintf(\"val: %i\\n\", val);  // 函数外的val，不认识fun函数里的val\n}\n```\n\n```c\n#include<stdio.h>\nstatic int val = 34;\nvoid fun()\n{\n\tstatic int val = 1;\n\tval = 2;  // 优先选择本函数里的val\n}\nint main()\n{\n\tfun();\n\tprintf(\"val: %i\\n\", val); // 打印34。读取的是函数外的val，不认识fun函数里的val\n}\n\n```\n\n```c\n#include<stdio.h>\nstatic int val = 34;\nvoid fun()\n{\n\t{\n\t\tstatic int val = 1;\n\t}\n\tval = 2;  // 只认识函数外的val，函数里的上面这个大括号里的val不认识\n}\nint main()\n{\n\tfun();\n\tprintf(\"val: %i\\n\", val); // 函数外的val，不认识fun函数里的val\n}\n\n```\n\n```c\n#include<stdio.h>\nstatic int val = 34;\nvoid fun()\n{\n\tstatic int val = 1;\n\tval = 2;  // 函数外的val\n}\nint main()\n{\n\tstatic int val = 33;\n\tfun();\n\tprintf(\"val: %i\\n\", val); // 打印33，优先选择本函数里的val\n}\n\n```\n\n# 宏\n\n```c\n#include<stdio.h>\n#define PI 3.14\nint main()\n{\n    int i = PI;\n    return 0;\n}\n```\n\n# 常变量\n\n如果PI赋予了普通的int型变量`i`，那么`i`可能会被篡改。这时可以用常变量修饰`i`。\n\n```c\n#include<stdio.h>\n#define PI 3.14\nint main()\n{\n    //int i = PI;\n    //i = 9.78;\n    const int i = PI; // or: int const i = PI;\n    return 0;\n}\n```\n\n但是常变量不建议这么使用。而是如下使用：\n\n```c\n#include<stdio.h>\nconst float PI = 3.14f;\nint main()\n{\n    float i = PI;\n    return 0;\n}\n```\n\n好处：\n\n1. 宏能做的，常变量都可以做到。\n2. 宏不能做到的：变量类型检查，常变量可以做。\n   1. 虽然`3.14f`可以正确地表达float字面常量\n   2. 但是`90`却不能正确地表达short字面常量，char、short诸如此类都是整型兼容的，形式与整型无区别，所以无法在宏定义时把类型信息附加上，因此丢失了类型信息。\n\n# 其他总结\n\n1. **#define宏定义和const的区别：**\n    - **#define宏定义：** 使用#define创建的宏是一种简单的文本替换机制。在预处理阶段，所有的宏名称都会被对应的文本替换，没有类型信息。例如：`#define PI 3.14`。\n    - **const关键字：** const用于创建常量，具有类型信息，并且在编译时进行类型检查。例如：`const double PI = 3.14;`。const创建的常量在内存中有分配空间，而宏定义只是简单的文本替换。\n2. **定义和声明的关系：**\n    - **定义：** 定义是创建一个变量、函数、或其他实体，并分配相应的存储空间。例如：`int x = 5;`。\n    - **声明：** 声明是告诉编译器某个实体的存在而不进行实际的创建。例如：`extern int x;`。\n    - **关系：** 定义包含声明，但声明不一定包含定义。如果在某个文件中声明了一个变量，而在另一个文件中定义了该变量，那么编译时需要链接这两个文件。\n","categories":["C"]},{"title":"C语言_C程序","url":"/C/C语言_C程序/","content":"# 语言的发展\n1. Procedure\n2. Function\n3. Object\n4. Meta (template)\n5. Component\n\n# Visual Studio使用\n\nSolution（解决方案）指的是解决某一问题整个的方案，需要1个或多个Project（项目）来协同完成。不同的项目可以是不同的语言如`C++`、`C#`等，可以把这些项目放在一个解决方案中联合编译。\n\n## 项目目录结构\n\n项目编译成功后，可执行exe文件会生成在项目目录下的`x64/Debug`中，名字为项目名称\n\n# 第一个C程序\n\n```c\n#include <stdio.h> /* standard input output. */\n\n// forward declarations.\nvoid bar(void);\n\nint main(void)\n{\n    bar();\n    return 0;\n}\n\nvoid bar(void)\n{\n    printf(\"Hello\\n\");\n}\n```\n\n前置**声明**的主要作用体现在：\n\n1. 编译器可以在代码中检测函数是否正确调用，如检查函数名、返回类型、参数类型。\n2. 如果代码中函数调用书写正确，则通过编译检测。我们可以写和前置声明中一样的调用书写来欺骗编译器，但是后面链接器会进一步检查是否在下面有函数的正确**定义**。\n\n如果我们删除bar函数定义\n\n```c\n#include <stdio.h> /* standard input output. */\n\n// forward declarations.\nvoid bar(void);\n\nint main(void)\n{\n    bar();\n    return 0;\n}\n```\n\n则链接器报错：\n\n```\n1>------ 已启动生成: 项目: Project1, 配置: Debug x64 ------\n1>Source.c\n1>Source.obj : error LNK2019: 无法解析的外部符号 bar，函数 main 中引用了该符号\n1>C:\\Users\\xcg\\source\\repos\\Solution1\\x64\\Debug\\Project1.exe : fatal error LNK1120: 1 个无法解析的外部命令\n1>已完成生成项目“Project1.vcxproj”的操作 - 失败。\n```\n\n# 什么情况下需要前置声明\n\n1. 如果把函数实现放在调用处的后面，则需要在调用处前面前置声明；\n2. 如果函数在此文件外，则需要在调用处前面前置声明；\n3. 如果函数在系统库中，也需要在调用处前面前置声明，只不过写到了`#include<XXX>`中去了，比如printf函数包含在`stdio.h`中；\n\n# 尖括号和双引号的区别\n\n1. 尖括号搜索范围小，编译速度快。\n2. 双引号会优先到当前工程路径下去扫描，没有扫描到则去系统库中搜索。\n\n# 编译链接步骤\n\n1. 预处理，如`#include`\n2. 编译，把每一个`.c`文件生成一个`.obj`文件，即目标文件，是CPU可识别的机器码，但无法直接执行。\n3. 汇编\n4. 链接，把所有的`.obj`文件组合为`.exe`文件（Linux下为`.out`）\n\n## `.exe`文件由什么组成\n\n1. 所有`.obj`文件（自己编写的内容，用户库）\n2. 系统库内容，如`printf`函数\n3. C启动代码\n   1. 首先需要一个调用者来调用main函数，程序才能从入口启动\n   2. 其次，有一些全局变量，需要启动代码在main函数执行前加载\n\n# C语言程序顶层角度\n\n程序由模块组成，即一个个功能单元。可以说：大的工厂分了好多车间，各个车间有各自的原料。那么，在程序里，语句把这些原料（数据），按多种方法（顺序、分支、循环）送到某一个位置。而表达式则是这些原料（数据）的载体。表达式由运算符、数据组成。\n\n```\nC Program\n         functions\n                   statements\n                              expressions __\n                                   |        \\\n                                   |         \\\n                                  operators   \\\n                                              elementary data type\n```\n\n","categories":["C"]},{"title":"英语笔记_概率导论","url":"/课堂笔记/英语笔记_概率导论/","content":"\n# 词汇\n\n1. devoted to ...\n   1. 致力于...的\n2. right away\n   1. 立刻、马上\n3. accomplish\n   1. 完成\n4. mutually exclusive\n   1. 互斥的\n5. specify\n   1. 列举；指定；特定\n   2. specified：规定的、额定的、特定的\n   3. spe'cific：特殊的；特定的；明确的；特效药\n6. axiom\n   1. 公理；格言；自明之理\n   2. 近义词：theory - 理论，theorem - 定理，principle - 原理\n7. consequence\n   1. 结果；后果\n8. im'ply\n   1. 隐含；暗示；意味\n   2. **hint**指通过时间接而有提示性的话语或表情来暗示某事。\n      **imply**侧重指话语、行为或情景中的一种暗示，听者或读者必须加以逻辑推断才能领会。\n      **suggest**指有意或无意的，直接或间接暗示，强调事物的表征等使人引起联想。\n9. discrete\n   1. 离散的；\n   2. discrete mathematics - 离散数学\n   3. continuous - 连续的\n10. sophisticated`/səˈfɪstɪkeɪtɪd/`\n    1. 老练的、老于世故的；\n    2. 精密的、尖端的；\n    3. 高雅的、有教养的。\n    4. complex 侧重内在关系的复杂，需通过仔细研究与了解才能掌握和运用。\n       complicated 与complex的含义接近，但语气更强，着重极其复杂，很难分析、分辨或解释。\n       sophisticated 侧重指事物发展到或达到高级的程度所体现出的复杂。\n       intricate 着重指错综复杂，令人迷惑理解。\n11. subtle\n    1. 微妙的、难以捉摸的、细微的；\n    2. I want a girl who's sexy, but in a subtle way—that's what gets me going.\n       我需要一个性感女孩，不过要**隐隐约约**地性感的那一种性感——就是能让我兴奋的那种类型。\n    3. 敏感的、敏锐的、有辨别力的\n    4. Roy. I'm more subtle and discreet(谨慎) than you.\n       罗伊，我比你更**低调**谨慎。\n    5. delicate 侧重指需要谨慎处理和对待。\n       fine 隐含“不易察觉的”意味。\n       subtle 侧重有洞察、领悟事物细微差别以及微妙关系的能力。\n\n# 句子\n\n1. A probabilistic model is a quantitative description of a situation, a phenomenon, or an experiment whose outcome is uncertain.\n   1. 概率模型是对结果不确定的情况、现象或实验的定量描述。\n2. we specify a probability law, which assigns probabilities to outcomes or to collections of outcomes. The probability law tells us, for example, whether one outcome is much more likely than some other outcome.\n   1. 我们指定一个概率定律，该定律将概率分配给结果或结果集合。概率定律让我们知道，比如，一个结果是否比其他结果更有可能。\n3. Probabilities have to satisfy certain basic properties in order to be meaningful.\n","categories":["英语","课堂笔记"]},{"title":"集群服务器架构_续篇_协程服务器","url":"/项目/集群服务器架构_续篇_协程服务器/","content":" 内容\n\n1. 项目需求及目标\n2. 开发环境\n3. `Json`介绍\n4. `muduo`网络库编程\n5. 服务器集群\n6. 基于`发布-订阅`的`Redis`——服务器中间件\n7. 数据库设计\n\n本项目要用到的技术栈：\n\n1. `Json`序列化和反序列化；\n2. `muduo`网络库开发；\n3. `nginx`源码编译安装和环境部署；\n4. `nginx`的`tcp`负载均衡器配置；\n5. `redis`缓存服务器编程实践；\n6. 基于`发布-订阅`的服务器中间件`redis`消息队列编程实践；\n7. `MySQL`数据库编程；\n8. `CMake`构建编译环境；\n9. `Github`托管项目\n\n本项目的内容包含了：通常开发的服务器，网络、业务、数据模块（数据库、数据的操作），项目中要把三大模块区分开，项目初期时以登录模块为主线，分三大块推进。\n\n# 项目需求及目标\n\n* 项目需求\n  1. 客户端新用户注册\n  2. 客户端用户登录\n  3. 添加好友和添加群组\n  4. 好友聊天和群组聊天\n  5. `nginx`配置`tcp`负载均衡\n  6. 集群聊天系统支持客户端跨服务器通信\n\n* 项目目标\n  1. 掌握服务器的网络`I/O`模块，业务模块，数据模块分层的设计思想\n  2. 掌握`C++` `muduo`网络库的编程以及实现原理\n  3. 掌握`Json`的编程应用\n  4. 掌握`nginx`配置部署`tcp`负载均衡器的原理及应用\n  5. 掌握服务器中间件的应用场景和基于`发布-订阅`的`redis`编程实践以及应用原理\n  6. 掌握`CMake`构建自动化编程环境\n\n# 开发环境\n\n具体配置略，翻阅其他文章。\n\n## 工程目录\n\n```\ninclude目录是头文件放的位置。\nserver和client的代码在同一工程中，最后生成时可以把C/S分开生成到bin目录下。\n可按server和client分类，比如生成代码所需用到的头文件可以分别放在/include/server和/include/client，而server和client共需的头文件直接放到/include下。比如消息的id。\nsrc放源码。\nthirdparty是第三方库文件夹，比如放json.hpp。\n本项目没有生成lib库(.a/.so)，所以没有lib文件夹。\n```\n\n## CMakeLists.txt编写\n\n* 根目录\n\n  ```cmake\n  cmake_minimum_required(VERSION 3.0.0)\n  project(chat)\n  # 配置编译选项\n  set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} -g)\n  # 配置最终的可执行文件输出的路径\n  set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)\n  # 配置头文件的搜索路径\n  include_directories(${PROJECT_SOURCE_DIR}/include)\n  include_directories(${PROJECT_SOURCE_DIR}/include/server)\n  # 加载子目录\n  add_subdirectory(src)\n  ```\n\n* `/src`\n\n  ```cmake\n  add_subdirectory(server)\n  ```\n\n* `/src/server`\n\n  ```cmake\n  # 定义了一个SRC_LIST变量，包含了该目录下所有的源文件\n  aux_source_directory(. SRC_LIST)\n  # 指定生成可执行文件\n  add_executable(ChatServer ${SRC_LIST})\n  # 指定可执行文件链接时 需要依赖的库文件\n  target_link_libraries(CharServer muduo_net muduo_base pthread)\n  ```\n\n  \n\n# Json介绍\n\nJson是一种轻量级的数据交换格式（也叫数据序列化方式）。Json采用完全**独立于编程语言**的文本格式\n来存储和表示数据。简洁和清晰的层次结构使得 Json成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\nJson的用处就是下图：\n\n![image-20220413164124873](../../images/集群服务器/image-20220413164124873.png)\n\n* Json第三方库\n\n本项目选用的是`JSON for Modern C++`，由德国人`nlohmann`编写的在`C++`下使用的`JSON`库。特点如下:\n\n1. 整个代码由一个头文件`json.hpp`包含，没有依赖关系，使用方便；\n2. 使用C++11标准编写；\n3. 使得json像STL容器一样，而且STL和json容器之间可以相互转换；\n4. 所有类都经过严格的单元测试，覆盖100％的代码，包括所有特殊的行为。此外，还检查了Valgrind是否有内存泄漏。为了保持高质量，该项目遵循“核心基础设施”倡议的最佳实践。\n\n* 测试json\n\n```cpp\n#include\"json.hpp\"\nusing json = nlohmann::json;\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n/* json序列化 示例1 */\nvoid func1()\n{\n    json js;\n    js[\"msg_type\"] = 2;\n    js[\"from\"] = \"zhang san\";\n    js[\"to\"] = \"li si\";\n    js[\"msg\"] = \"hello, i'm zhang san\";\n    cout << js << endl;\n}\nint main()\n{\n    func1();\n    return 0;\n}\n/* 输出结果\n * {\"from\":\"zhang san\",\"msg\":\"hello, i'm zhang san\",\"msg_type\":2,\"to\":\"li si\"}\n */\n```\n\n```cpp\n/* json序列化 实例2 */\nvoid func2()\n{\n\tjson js;\n    js[\"id\"] = {1, 2, 3, 4, 5};\n    js[\"name\"] = \"zhang san\";\n    js[\"msg\"][\"zhang san\"] = \"i'm zhang san\";\n    js[\"msg\"][\"li si\"] = \"i'm li si\";\n    /* 上面两句等同于下面这句一次性添加数组对象 */\n/*  js[\"msg\"] = {{\"zhang san\", \"i'm zhang san\"}, {\"li si\", \"i'm li si\"}}; */\n\tcout << js << endl;\n}\nint main()\n{\n    func2();\n    return 0;\n}\n/* 输出结果\n * {\"id\":[1,2,3,4,5],\"msg\":{\"li si\":\"i'm li si\",\"zhang san\":\"i'm zhang san\"},\"name\":\"zhang san\"}\n */\n```\n\n这个json库强大到直接把`C++` `STL`中的容器内容可以直接序列化成Json字符串，代码如下：\n\n```cpp\n/* json序列化 实例3 */\nvoid func3()\n{\n    json js;\n    vector<int> vec;\n    vec.push_back(1);\n    vec.push_back(2);\n    vec.push_back(5);\n    // 直接序列化一个vector容器\n    js[\"list\"] = vec;\n    map<int, string> m;\n    m.insert({1, \"黄山\"});\n    m.insert({2, \"华山\"});\n    m.insert({3, \"泰山\"});\n    // 直接序列化一个map容器\n    js[\"path\"] = m;\n    cout<<js<<endl;\n}\n/* 输出结果\n * {\"list\":[1,2,5],\"path\":[[1,\"黄山\"],[2,\"华山\"],[3,\"泰山\"]]}\n */\n```\n\n* API\n\n  * `dump`: `cout <<`能输出json对象是因为重载了`<<`运算符；而要实际生成`string`可用`dump()`，生成的字符串内容和`<< json`的一样。传输数据时，不要传`string`对象，而是要传`string`实际指向的字符串首指针，`c\\_str`。\n\n    ```cpp\n    void func1()\n    {\n        json js;\n        js[\"msg_type\"] = 2;\n        js[\"from\"] = \"zhang san\";\n        js[\"to\"] = \"li si\";\n        js[\"msg\"] = \"hello, i'm zhang san\";\n        string sendBuf = js.dump();\n        cout << sendBuf.c_str() << endl;\n    }\n    ```\n\n    \n\n# 网络IO模块\n\n## ChatServer\n\n### 成员属性\n\n1. `TcpServer m_server` - **基于事件驱动的、IO复用+epoll+线程池**的服务器类，完全**基于Reactor模型**\n2. `EventLoop *m_loop` - mainLoop的指针, 保存事件循环. 有了事件循环的指针，可以在合适的时候调用quit退出事件循环；\n\n```cpp\nprivate:\n    /* 组合的muduo库，实现服务器功能的类对象 */\n    TcpServer _server;\n    /* 指向事件循环对象的指针 */\n    EventLoop *_loop;\n```\n\n### 成员函数\n\n1. 构造 - 参数为`loop`指针, `listenAddr`, `name`, 用于初始化TcpServer\n   ```cpp\n   public:\n       /* 初始化聊天服务器对象 */\n       ChatServer(EventLoop* loop,\n                  const InetAddress& listenAddr,\n                  const string& nameArg);\n   ```\n\n2. `start` - 启动服务的接口\n\n   ```cpp\n   public:\n       void start();\n   ```\n\n3. `onConnection`/`onMessage` -  连接创建/断开, 读写事件发生的回调函数\n   \n   ```cpp\n   private:\n       /* 上报链接相关信息的回调函数（连接创建，连接断开）*/\n       void onConnection(const TcpConnectionPtr&);\n       /* 上报读写事件相关信息的回调函数 */\n       void onMessage(const TcpConnectionPtr&, Buffer*, Timestamp);\n   ```\n\n### 代码实现\n\n```cpp\n#ifndef CHATSERVER_H\n#define CHATSERVER_H\n#include <muduo/net/TcpServer.h>\n#include <muduo/net/EventLoop.h>\nusing namespace muduo;\nusing namespace muduo::net;\n/**\n * 聊天服务器的主类;\n *\n * 要注册两个方法:\n * 给TcpServer注册新用户的连接、连接断开的、已连接用户的可读写事件;\n */\nclass ChatServer\n{\npublic:\n    /* 初始化聊天服务器对象 */\n    ChatServer(EventLoop* loop,\n               const InetAddress& listenAddr,\n               const string& nameArg);\npublic:\n    /* 启动服务 */\n    void start();\n\nprivate:\n    /* 上报链接相关信息的回调函数（连接创建，连接断开）*/\n    void onConnection(const TcpConnectionPtr&);\n    /* 上报读写事件相关信息的回调函数 */\n    void onMessage(const TcpConnectionPtr&, Buffer*, Timestamp);\n\n\nprivate:\n    /* 组合的muduo库，实现服务器功能的类对象 */\n    TcpServer _server;\n    /* 指向事件循环对象的指针 */\n    EventLoop *_loop;\n};\n#endif\n```\n\n## Reactor模型\n\n本项目基于muduo库，模型是**基于事件驱动的、IO复用+epoll+线程池**的网络，完全**基于Reactor模型**，线程暂时设置为4个，有一个主Reactor是IO线程，主要负责新用户的连接，3个sub-Reactor是工作线程，主要负责已连接用户的读写事件的处理。\n\n# 业务模块\n\n## 业务模块与网络模块解耦 - 回调\n\n考虑问题：网络模块收到的消息如何派发到业务模块？让网络模块的代码和业务模块的代码解耦。\n\n假设有一个用户在做登录业务，登录业务包含messageID，name，password，要验证用户名密码是否正确。\n\n解耦的方案有两种：\n\n1. 使用基于面向接口的编程。（抽象基类）\n2. **基于回调函数**的操作。\n\n## 业务类型\n\n1. 登录 - `LOGIN_MSG/ACK`\n2. 注册 - `REG_MSG/ACK`\n3. 加好友 - `ADD_FRIEND_MSG`\n4. 一对一聊天 - `ONE_CHAT_MSG`\n5. 创建群组 - `CREATE_GROUP_MSG`\n6. 加入群组 - `ADD_GROUP_MSG`\n7. 群聊 - `GROUP_CHAT_MSG`\n\n```cpp\n#ifndef PUBLIC_H\n#define PUBLIC_H\n/* server和client的公共文件 */\n\nenum EnMsgType  //En表示Enum枚举\n{\n    LOGIN_MSG = 1,      //登录 消息id, 与chatservice中的login方法绑定\n    LOGIN_MSG_ACK,      //登录响应\n\n    REG_MSG,            //注册 消息id, 与chatservice中的reg方法绑定\n    REG_MSG_ACK,        //注册响应\n\n    ADD_FRIEND_MSG,     //添加好友\n    ONE_CHAT_MSG,       //一对一聊天\n\n    CREATE_GROUP_MSG,   //创建群组\n    ADD_GROUP_MSG,      //加入群组\n    GROUP_CHAT_MSG      //群聊\n};\n\nenum EnLoginErrType\n{\n    LOGIN_SUCCEESS = 0,\n    LOGIN_REPEAT = 1,\n    LOGIN_NOTFOUND = 2,\n    LOGIN_WRONGPWD = 3\n};\n#endif\n```\n\n## ChatService\n\n### 前置处理\n\n```cpp\n#include\"json.hpp\"\nusing json = nlohmann::json;\n```\n\n```cpp\n/* 表示处理消息的事件回调方法类型 */\nusing MsgHandler = std::function<void(const TcpConnectionPtr&, json&, Timestamp)>;\n```\n\n### 成员属性\n\n1. `unordered_map<int, MsgHandler> m_msgHandlerMap` - 映射消息类型id 和 事件回调函数\n\n   ```cpp\n   private:\n       /* 存储消息id和其对应的业务处理方法 */\n       unordered_map<int, MsgHandler> m_msgHandlerMap;\n   ```\n\n2. `unordered_map<int, TcpConnectionPtr> m_userConnectionMap` - 存储在线用户的通信连接\n\n   ```cpp\n   private:\n       /* 存储在线用户的通信连接 */\n       unordered_map<int, TcpConnectionPtr> m_userConnectionMap;\n   ```\n\n3. `mutex m_connMutex` - 定义互斥锁，保证`m_userConnectionMap`的线程安全\n\n   ```cpp\n   private:\n       /* 定义互斥锁，保证m_userConnectionMap的线程安全 */\n       mutex _connMutex;\n   ```\n\n4. 数据操作类对象\n\n   1. UserModel - `m_userModel`\n   2. OfflineMsgModel - `m_offlineMsgModel`\n   3. FriendModel - `friendModel`\n   4. GroupModel - `groupModel`\n\n   ```cpp\n   private:\n       UserModel       _userModel;         /* 数据操作类对象 */\n       OfflineMsgModel _offlineMsgModel;   /* 数据操作类对象 */\n       FriendModel     _friendModel;       /* 数据操作类对象 */\n       GroupModel      _groupModel;        /* 数据操作类对象 */\n   ```\n\n### 成员函数\n\n1. 构造函数 - 私有化, 单例处理\n   ```cpp\n   public:\n       static ChatService * instance();\n   private:\n       ChatService();\n   ```\n\n2. 业务接口\n\n   1. login - 登陆业务\n   2. reg - 注册业务\n   3. addFriend - 添加好友业务\n   4. oneChat - 一对一聊天业务\n   5. createGroup - 创建群组业务\n   6. addGroup - 加入群组业务\n   7. groupChat - 群组聊天业务\n\n   ```cpp\n   public:\n       /* 处理登录业务 */\n       void login(const TcpConnectionPtr &conn, json &js, Timestamp time);\n       /* 处理注册业务 */\n       void reg(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   \n       /* 添加好友业务 */\n       void addFriend(const TcpConnectionPtr &conn, json &js, Timestamp time);\n       /* 一对一聊天业务 */\n       void oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   \n       /* 创建群组业务 */\n       void createGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n       /* 加入群组业务 */\n       void addGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n       /* 群组聊天业务 */\n       void groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   ```\n\n3. getHandler - 获取消息对应的处理器\n   ```cpp\n   public:\n       /* 获取消息对应的处理器 */\n       MsgHandler getHandler(int msgid);\n   ```\n\n4. clientCloseException - 处理客户端异常退出\n   ```cpp\n   public:\n       /* 处理客户端异常退出 */\n       void clientCloseException(const TcpConnectionPtr & conn);\n   ```\n\n5. reset - 业务重置方法，通常在服务器异常退出时调用\n   ```cpp\n   public:\n       /* 业务重置方法，通常在服务器异常退出时调用 */\n       void reset();\n   ```\n\n### 代码实现\n\n```cpp\n#ifndef CHATSERVICE_H\n#define CHATSERVICE_H\n#include<muduo/net/TcpConnection.h>\n#include<unordered_map>\n#include<functional>\n\n#include\"usermodel.hpp\"\n#include\"offlinemsgmodel.hpp\"\n#include\"friendmodel.hpp\"\n#include\"groupmodel.hpp\"\n\nusing namespace std;\nusing namespace muduo;\nusing namespace muduo::net;\n#include\"json.hpp\"\nusing json = nlohmann::json;\n\n#include<mutex>\n\n/* 表示处理消息的事件回调方法类型 */\nusing MsgHandler = std::function<void(const TcpConnectionPtr&, json&, Timestamp)>;\n/**\n * 聊天服务器业务类. \n * 用映射关系来存储消息id和具体处理函数. \n * 此类有一个实例就够了，所以采用单例模式. \n */\nclass ChatService\n{\npublic:\n    /* 获取单例对象的接口函数 */\n    static ChatService* instance();\npublic:\n    /* 处理登录业务 */\n    void login(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 处理注册业务 */\n    void reg(const TcpConnectionPtr &conn, json &js, Timestamp time);\n\n    /* 添加好友业务 */\n    void addFriend(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 一对一聊天业务 */\n    void oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n\n    /* 创建群组业务 */\n    void createGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 加入群组业务 */\n    void addGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 群组聊天业务 */\n    void groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\npublic:\n    /* 获取消息对应的处理器 */\n    MsgHandler getHandler(int msgid);\npublic:\n    /* 处理客户端异常退出 */\n    void clientCloseException(const TcpConnectionPtr & conn);\npublic:\n    /* 业务重置方法，通常在服务器异常退出时调用 */\n    void reset();\n\nprivate:\n    ChatService();\nprivate:\n    UserModel       _userModel;         /* 数据操作类对象 */\n    OfflineMsgModel _offlineMsgModel;   /* 数据操作类对象 */\n    FriendModel     _friendModel;       /* 数据操作类对象 */\n    GroupModel      _groupModel;        /* 数据操作类对象 */\nprivate:\n    /* 定义互斥锁，保证m_userConnectionMap的线程安全 */\n    mutex _connMutex;\nprivate:\n    /* 存储消息id和其对应的业务处理方法 */\n    unordered_map<int, MsgHandler> _msgHandlerMap;\n    /* 存储在线用户的通信连接 */\n    unordered_map<int, TcpConnectionPtr> _userConnectionMap;\n};\n#endif\n```\n\n# 数据模块\n\n## 业务模块与数据模块解耦 - ORM框架\n\n> Object Relation Map - 对象关系映射。\n\n在这个框架中，业务层操作的都是对象，看不到具体的SQL操作。\n\n在DAO层（数据层），才有具体的数据库操作。\n\n解决了痛点：业务模块、数据模块之间的解耦。\n\n## 搭建MySQL数据库环境\n\n(以下命令基于ubuntu环境)\n\n1. 安装mysql-server和mysql开发包, 包括mysql头文件和动态库文件\n   ```bash\n   \n   sudo apt-get install mysql-server\t\t#安装最新版MySQL服务器\n   sudo apt-get install libmysqlclient-dev #安装开发包\n   ```\n\n2. 初始的用户名和密码是自动生成的，按下面步骤修改mysql的root用户密码为123456\n   ```bash\n   ~$ sudo cat /etc/mysql/debian.cnf\n   \n   [client]\n   host = localhost\n   user = debian-sys-maint \t\t\t#初始的用户名\n   password = Kk3TbShbFNvjvhpM\t\t\t#初始的密码\n   socket = /var/run/mysqld/mysqld.sock\n   ```\n\n   ```bash\n   # 用上面初始的用户名和密码，登录mysql server，修改root用户的密码，命令如下：\n   ~$ mysql -u debian-sys-maint -pKk3TbShbFNvjvhpM\n   #-u后面是上面查看的用户名; -p后面紧跟上面查看的密码\n   ```\n\n   ```mysql\n   mysql> update mysql.user set authentication_string=password('123456') where user='root' and host='localhost';\n   mysql> update mysql.user set plugin=\"mysql_native_password\";\n   mysql> flush privileges;\n   Query OK, 0 rows affected (0.01 sec)\n   mysql> exit\n   Bye\n   ```\n\n3. 设置MySQL字符编码utf-8，以支持中文操作\n   ```mysql\n   mysql> show variables like \"char%\"; # 先查看MySQL默认的字符编码\n   +--------------------------+----------------------------+\n   | Variable_name\t\t\t   | Value\t\t\t   \t\t\t|\n   +--------------------------+----------------------------+\n   | character_set_client     | utf8                       |\n   | character_set_connection | utf8                       |\n   | character_set_database   | latin1                     |\n   | character_set_filesystem | binary                     |\n   | character_set_results    | utf8                       |\n   | character_set_server     | latin1                     |#不支持中文！！！\n   | character_set_system     | utf8                       |\n   | character_sets_dir       | /usr/share/mysql/charsets/ |\n   +--------------------------+----------------------------+\n   8 rows in set (0.06 sec)\n   \n   mysql> set character_set_server=utf8;\n   Query OK, 0 rows affected (0.00 sec)\n   ```\n\n4. 修改表的字符编码：`alter table user default character set utf8;`\n   修改属性的字符编码：`alter table user modify column name varchar(50) character set utf8;`\n\n## MySQL类 - 封装MySQL操作\n\n需要引入`mysql/mysql.h`头文件\n```cpp\n#include<mysql/mysql.h>\n```\n\n### 成员变量\n\n`MYSQL *m_conn` - 记录MYSQL类型的指针, 以获取这个mysql连接\n\n```cpp\nprivate:\n    MYSQL *m_conn;\n```\n\n### 成员函数\n\n1. 构造/析构 - 初始化/释放数据库连接\n   ```cpp\n   public:\n       /* 初始化数据库连接 */\n       MySQL();\n       /* 释放数据库连接资源 */\n       ~MySQL();\n   ```\n\n2. getConnection - 获取连接, 即获取成员`m_conn`\n   ```cpp\n   public:\n       /* 获取连接 */\n       MYSQL * getConnection();\n   ```\n\n3. connect - 连接数据库, 返回值为bool, 说明连接成功与否\n   ```cpp\n   public:\n       /* 连接数据库 */\n       bool connect();\n   ```\n\n4. query - 查询操作, 参数是string类型的sql语句, 返回值为`MYSQL_RES`, 即MySQL结果集类型\n   ```cpp\n   public:\n       /* 查询操作 */\n       MYSQL_RES * query(string sql);\n   ```\n\n5. update - 更新操作, 参数是string类型的sql语句, 返回值为bool, 说明更新成功与否\n   ```cpp\n   public:\n       /* 更新操作 */\n       bool update(string sql);\n   ```\n\n### 代码实现\n\n前置全局声明\n```cpp\n#include <muduo/base/Logging.h>\t//日志工具\n/* 数据库配置信息 */\nstatic string server = \"127.0.0.1\";\nstatic string user = \"root\";\nstatic string password = \"123\";\nstatic string dbname = \"chat\";\n```\n\n1. 构造 - 调用`mysql_init`, 实际上只是对mysql连接进行空间资源的开辟, 返回一个指针赋给`m_conn`成员, 没有真正连接, 因此传入nullptr\n   ```cpp\n   /* 初始化数据库连接 */\n   MySQL::MySQL()\n   {\n       m_conn = mysql_init(nullptr);\n   }\n   ```\n\n2. 析构 - 调用`mysql_close(m_conn)`, 对MySQL连接资源进行释放\n   ```cpp\n   /* 释放数据库连接资源 */\n   MySQL::~MySQL()\n   {\n       if(m_conn != nullptr)\n       {\n           mysql_close(m_conn);\n       }\n   }\n   ```\n\n3. getConnection - 获取连接, 即返回`m_conn`成员\n   ```cpp\n   /* 获取连接 */\n   MYSQL * MySQL::getConnection()\n   {\n       return m_conn;\n   }\n   ```\n\n4. connect - 连接数据库, 内部调用`mysql_real_connect`, 传入`m_conn`, 以及server地址, user号, 密码, 要连接的数据库name, 服务器端口;\n   ```cpp\n   /* 连接数据库 */\n   bool MySQL::connect()\n   {\n       MYSQL *p = mysql_real_connect(m_conn, server.c_str(), user.c_str(),\n                                     password.c_str(), dbname.c_str(), 3306, nullptr, 0);\n       if(p != nullptr)\n       {\n           /* C/C++代码默认的编码字符是ASCII，如果不设置，则从MySQL上拉下来的中文无法正常显示 */\n           mysql_query(m_conn, \"set name gbk\");\n           LOG_INFO << \"connect mysql success!\";\n       }\n       else\n       {\n           LOG_INFO << \"connect mysql failed!\";\n       }\n       return p;\n   }\n   ```\n\n5. query - 查询操作\n\n   1. 内部调用`mysql_query`, 传入`m_conn`, `sql-string`的c风格字符串首址;\n\n      > `mysql_query`的返回值: \n      >\n      > 1. 如果查询成功，返回0;\n      > 2. 如果出现错误，返回非0值。\n\n   2. 返回值需要调用`mysql_use_result(m_conn)`获取结果集, 再return;\n\n   ```cpp\n   /* 查询操作 */\n   MYSQL_RES * MySQL::query(string sql)\n   {\n       if(mysql_query(m_conn, sql.c_str()))\n       {\n           LOG_INFO << __FILE__ << \":\" << __LINE__ << \":\" << sql << \"查询失败!\";\n           return nullptr;\n       }\n       return mysql_use_result(m_conn);\n   }\n   ```\n\n6. update - 更新操作\n\n   1. 内部调用`mysql_query`, 传入`m_conn`, `sql-string`的c风格字符串首址;\n   2. 判断`mysql_query`的返回值, 若为非0则更新失败; 若为0则更新成功;\n\n   ```cpp\n   /* 更新操作 */\n   bool MySQL::update(string sql)\n   {\n       if(mysql_query(m_conn, sql.c_str()))\n       {\n           LOG_INFO << __FILE__ << \":\" << __LINE__ << \":\" << sql << \"更新失败!\";\n           return false;\n       }\n       return true;\n   }\n   ```\n\n## Model层 - 对业务层封装底层数据库的操作\n\n以User类的操作为例\n\n### User类\n\n```cpp\n#ifndef USER_H\n#define USER_H\n#include<string>\nusing namespace std;\n/**\n * 属于映射类;\n * 匹配User表的ORM类;\n */\nclass User\n{\npublic:\n    User(int id = -1, string name=\"\", string password=\"\", string state=\"offline\")\n        : id_(id), name_(name), password_(password), state_(state)\n    {   \n    }\npublic:\n    void setId(int id){id_ = id;}\n    void setName(string name){name_ = name;}\n    void setPassword(string password){password_ = password;}\n    void setState(string state){state_ = state;}\npublic:\n    int getId() const{return id_;}\n    string getName() const{return name_;}\n    string getPassword() const{return password_;}\n    string getState() const{return state_;}\nprivate:\n    int id_;\n    string name_;\n    string password_;\n    string state_;\n};\n#endif\n```\n\n### UserModel类\n\n1. insert - 参数为User的引用, 返回值为bool\n2. query - 参数为id, 返回值为User\n3. updateState - 更新用户的状态信息, 参数为User的一个临时副本, 返回bool\n4. resetAllState - 重置所有用户的状态信息\n\n```cpp\n#ifndef USERMODEL_H\n#define USERMODEL_H\n#include\"user.hpp\"\n/* User表的数据操作类 */\nclass UserModel\n{\npublic:\n    /* User表的增加方法 */\n    bool insert(User &user);\npublic:\n    /* 根据用户号码查询用户信息 */\n    User query(int id);\npublic:\n    /* 更新用户的状态信息 */\n    bool updateState(User user);\n    /* 重置所有用户的状态信息 */\n    void resetAllState();\n};\n#endif\n```\n\n#### 代码实现\n\n```cpp\n#include\"usermodel.hpp\"\n#include\"db.h\"\n#include<iostream>\nusing namespace std;\n/* User表的增加方法 */\nbool UserModel::insert(User &user)\n{\n    /* 1.组装SQL语句 */\n    char sql[1024] = {0};\n    sprintf(sql, \"insert into user(name, password, state) values('%s', '%s', '%s')\",\n        user.getName().c_str(), user.getPassword().c_str(), user.getState().c_str());\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        if(mysql.update(sql))\n        {\n            /* 获取插入成功的用户数据生成的主键id */\n            /* 以下的mysql_insert_id是生成id的方法之一 */\n            user.setId(mysql_insert_id(mysql.getConnection()));\n            return true;\n        }\n    }\n    /* 注册失败 */\n    return false;\n}\n/* 根据用户号码查询用户信息 */\nUser UserModel::query(int id)\n{\n    /* 1.组装SQL语句 */\n    char sql[1024] = {0};\n    sprintf(sql, \"select * from user where id = %d\", id);\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        /* mysql.query内部申请了资源，处理完成User的构造后，需要free */\n        MYSQL_RES *res = mysql.query(sql);  // 此query为MySQL的query，和update同级。\n        if(res != nullptr)\n        {\n            MYSQL_ROW row = mysql_fetch_row(res);\n            if(row != nullptr)\n            {\n                User user;\n                user.setId(atoi(row[0]));\n                user.setName(row[1]);\n                user.setPassword(row[2]);\n                user.setState(row[3]);\n                mysql_free_result(res);\n                return user;\n            }\n        }\n    }\n    /* 如果没有有效的查询结果，返回一个默认User，id为-1，表示出错 */\n    return User();\n}\n/* 更新用户的状态信息 */\nbool UserModel::updateState(User user)\n{\n    /* 1.组装SQL语句 */\n    char sql[1024] = {0};\n    sprintf(sql, \"update user set state = '%s' where id = %d\", user.getState().c_str(), user.getId());\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        if(mysql.update(sql))\n        {\n            return true;\n        }\n    }\n    return false;\n}\n/* 重置所有用户的状态信息 */\nvoid UserModel::resetAllState()\n{\n    char sql[1024] = \"update user set state = 'offline' where state = 'online'\";\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        mysql.update(sql);\n    }\n}\n```\n\n# 测试\n\n点对点聊天\n\n```bash\n./ChatServer\n```\n\n点对点聊天的json格式：`{\"msgid\":5,\"from\":\"from_name\",\"to\":to_id,\"msg\":\"......\"}`\n\n```bash\n# xcg\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":22,\"password\":\"123\"}\t#登录\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello zhang san, i'm xcg!\"}\t#发送消息\n# 发送离线消息\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello - 1\"}\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello - 2\"}\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello - 3\"}\n\n```\n\n```bash\n# zhang san\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":13,\"password\":\"123456\"}\t#登录\n{\"msgid\":5,\"from\":\"zhang san\",\"to\":22,\"msg\":\"hello xcg, i'm zhang san!\"}#发送消息\n\n```\n\n# 好友业务\n\n1. 显示有哪些已添加的好友，id\n2. 添加好友\n\n但是业务并不严格，只要知道其id即可聊天。\n\n总体业务流程：向服务器发起添加好友的请求，服务器就把关系添加到friend表中，初版本不用征询对方的同意。\n\nfriend表就两个字段：userid、friendid是联合主键。\n\n## 测试\n\n添加好友、登陆成功后显示好友列表\n\n```bash\n./ChatServer\n```\n\n添加好友的json格式：`{\"msgid\":6,\"id\":22,\"friendid\":13}`。此语句意为：id为22的用户主动添加id为13的用户为好友，建立双向关系。\n\n添加后，查看friend表中是否有信息，应有一个id:22 - friendid:13。\n\n```mysql\nselect * from friend;\n```\n\n\n\n```bash\n# xcg\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":22,\"password\":\"123\"}\t# 登录\n{\"msgid\":6,\"id\":22,\"friendid\":13}\t# 添加id:13为好友\n\n# Ctrl + ] -> quit 退出\n# 重新登陆\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":22,\"password\":\"123\"}\t# 登录\n# 看看是否返回好友列表\n```\n\n# 群组业务\n\n1. 管理员创建群\n2. 用户加入群\n3. 群聊\n\n## 表\n\n与群组业务相关的有两张表：一个是AllGroup表，一个是GroupUser表。\n\nAllGroup表有三个字段：id、groupname、groupdesc(群组描述)\n\nGroupUser表，因为群和成员之间是多对多的关系，所以需要此中间表来描述这个关系。有三个字段：groupid、userid、grouprole(成员在群中的权限)。groupid和userid是联合主键。\n\n这两张表都是处理群组业务的，所以对应的model只创建了一个。\n\n## model\n\ngroupmodel.hpp\n\n# 负载均衡\n\n负载均衡器, 亦叫做反向代理服务器, 在集群服务器架构中, 作为统一接收客户端请求的端口, 其根据配置所界定的负载算法, 把客户端的请求分发到业务服务器上, 要做的三件事情：\n\n1. 把client的请求按照负载均衡算法分发到具体的业务服务器ChatServer上面；相应地, 服务器的响应也要经过负载均衡器, 准确地返回给这个client; \n\n   > 服务器的响应消息操作, 也可以通过服务器和客户端建立一个ip隧道实现, 达到直接连接, 这样的效率更好; \n2. 能够和ChatServer保持心跳机制，监测ChatServer故障；\n3. 能够发现新添加的ChatServer设备，方便扩展服务器数量, 最好是能够平滑地完成这个过程, 而不是需要重启负载均衡服务器导致服务停止。\n\n## nginx负载均衡模块\n\n本项目选择nginx的tcp负载均衡模块，要解决的问题\n\n1. 如何进行nginx源码编译，包含tcp负载均衡模块\n2. nginx.conf配置文件中如何配置负载均衡\n3. nginx的平滑加载配置文件启动\n\nnginx在1.9版本之前，只支持http协议web服务器的负载均衡，从1.9版本开始以后，nginx开始支持tcp的长连接负载均衡，但是nginx默认不编译tcp负载均衡模块，编写它时，需要加入`--with-stream`参数来激活这个模块。\n\n### 编译安装操作流程\n\n以`nginx-1.12.2.tar.gz`为例;\n\nnginx编译安装需要先安装pcre、openssl、zlib等库。\n\n>对开源产品发行源代码的编译安装, 一般都是: \n>\n>1. 先执行`./configure`, 生产相应的makefile文件;\n>2. `make`, 进行编译\n>3. `make install`, 进行安装\n\n解压`nginx-1.12.2.tar.gz`后，进入`nginx-1.12.2`目录，先运行`./configure --with-stream`生成`Makefile`后，运行`make`，最后`make install`。make install命令会向系统路径拷贝文件，所以需要在root用户下执行。\n\n编译完成后，默认安装在了`/usr/local/nginx`目录。\n\n`nginx`目录下，可执行文件在`sbin`目录里，配置文件在`conf`目录里。\n\n### 配置\n\n如何配置负载均衡?\n\n`/usr/local/nginx/conf/nginx.conf`中, 可以看到http字段, 这是基于http的负载均衡配置; \n\n```nginx\n#user  nobody;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n        location / {\n            root /var/www/hexo;\n            index  index.html index.htm;\n        }\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n}\n```\n\n而本项目是tcp服务器, 需要写到`stream`下, 表示基于tcp的负载均衡配置; \n\n1. server字段\n   1. listen - nginx负载均衡器将要监听的端口号\n   2. `proxy_pass` - 所有在listen字段端口号上的请求都将分发到这个标记字段所填充到信息中\n2. upstream字段 - 可用于负载均衡的服务器信息\n   1. server - IP:port - weight权重 - `max_fail`最多失败次数 - `fail_timeout`最长等待响应时间\n\n```nginx\n# nginx tcp loadbalance config\nstream {\n    upstream MyServer {\n        server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;\n        server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;\n    }\n    server {\n        # proxy connect timeout 1s;\n        listen     8000;\n        proxy_pass MyServer;\n    }\n}\n```\n\n### 常用操作\n\n```bash\nnginx -s reload\t\t# 重新加载配置文件，平滑启动\nnginx -s stop\t\t# 停止nginx服务\n```\n\n### 模型设计\n\n> reactors in process - one loop per process\n\nnginx服务器的网络模块设计是基于进程的, 采用多个Reactor充当I/O进程和工作进程, 通过accept锁完美解决多个Reactors的惊群现象;\n\n## 更加高并发?\n\n负载均衡也分为很多种, 可分为业务层负载均衡器, 通过业务分发; 也可分为传输层的负载均衡器, 通过udp/tcp分发; 网络层, 通过ip分发; 数据链路层通过数据帧分发; \n\n如何更进一步提高并发量?\n\n可以把负载均衡器也进行集群处理, 前端使用一个偏底层的LVS负载均衡器, 即, 一台LVS加多台nginx服务器的模型; LVS的并发量很容易扩展到十几万; \n\n# 跨服务器通信\n\n本项目中, 用户间的通信模型无非有两种：一对一聊天、群聊。\n\n集群环境中，即用户可能分布在不同服务器主机上。如果按照之前的代码逻辑，每台服务器上的一个Server都只有一个`m_userConnectionMap`（因为这个是ChatService中的成员，而ChatService是单例模式）。所以用户给对方发消息后，如果接收方用户不在同一台服务器上，那么该消息就会被当作离线消息，这显然是不对的。\n\n那么怎么解决跨服务器通信呢？\n\n最直观的想法是让各个ChatServer服务器互相之间直接建立TCP连接进行通信，相当于在服务器网络之间进行广播。这样的设计使得各个服务器之间耦合度太高，不利于系统扩展，并且会占用系统大量的socket资源，各服务器之间的带宽压力很大，不能够节省资源给更多的客户端提供服务，因此不是一个好的设计。\n\n集群部署的服务器之间进行通信，最好的方式就是引入中间件消息队列，解耦各个服务器，使整个系统松耦合，提高服务器的响应能力，节省服务器的带宽资源; 所以答案是引入服务器中间件如消息队列; 如此一来, 服务器仅需做的工作是：向中间件发布订阅消息，之后等待中间件通知去取消息。\n\n在集群分布式环境中，经常使用的中间件消息队列有ActiveMQ、RabbitMQ、Kafka等，都是应用场景广泛并且性能很好的消息队列，供集群服务器之间，分布式服务之间进行消息通信。限于本项目业务类型并不是非常复杂，对并发请求量也没有太高的要求，因此本项目中间件消息队列选型的是-基于发布-订阅模式的redis。\n\n## Redis环境安装和配置\n\n1. Ubuntu安装redis服务命令\n   ```bash\n   sudo apt-get install redis-server\n   ```\n\n2. 安装完成后会自动启动redis服务，通过ps命令确认; redis默认端口为6379\n   ```bash\n   ps -ef | grep redis\n   ```\n\n## redis-cli测试redis-server\n\n启动redis-cli客户端，连接redis server体验一下数据缓存功能\n\n```bash\nredis-cli\n```\n\n```redis\n127.0.0.1:6379> set \"abc\" \"hello world\" #设置key-value\nOK\n127.0.0.1:6379> get \"abc\"\n\"hello world\"\n```\n\n## Redis订阅/发布\n\nredis的发布-订阅机制：发布-订阅模式包含了两种角色，分别是消息的发布者和消息的订阅者。订阅者可以订阅一个或者多个频道channel，发布者可以向指定的频道channel发送消息，所有订阅此频道的订阅者都会收到此消息。\n\n订阅频道的命令是 subscribe，可以同时订阅多个频道，用法是`subscribe channel1 [channel2] ...`;\n\n```redis\n127.0.0.1:6379> subscribe 13\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"13\"\n3) (integer) 1\n```\n\n```redis\n127.0.0.1:6379> publish 13 \"hello, 13\" #另一端推送消息给13\n```\n\n订阅了`13`频道 的用户收到的消息: \n\n```redis\n1) \"message\"\n2) \"13\"\n3) \"hello, 13\"\n```\n\n### 对应于本项目\n\n由于服务器是集群化的, 所以登录到本系统的用户可能不在同一聊天服务器上, 需要观察Redis中间件来获取消息;\n\n即, 用户是观察者, 消息队列是被观察者;\n\n某一用户登陆到聊天系统后, \n\n1. 服务器需要向Redis订阅某一频道的消息, 这个频道的id号即为该用户的id号;\n2. 当该用户给另一用户发送消息时, 发现其不在本服务器中, 需要向该频道发布消息;\n\n## redis发布-订阅的客户端编程 - 封装为Redis类\n\nredis支持多种不同的客户端编程语言，例如Java对应Jedis，PHP对应phpredis，C++对应的是hiredis。\n\n### hiredis安装步骤\n\n1. `git clone https://github.com/redis/hiredis`\n\n2. make && make install\n   ```bash\n   cd hiredis\n   make\n   ...\n   sudo make install #拷贝生成的动态库到/usr/local/lib目录下\n   # 如果提示没有找到hiredis动态库，则执行下面\n   # sudo ldconfig /usr/local/lib\n   ```\n\n### 成员变量\n\n1. hiredis同步上下文对象\n\n   1. 一个专门负责publish消息\n   2. 一个专门负责subscribe消息\n\n   ```cpp\n   private:\n       /* hiredis同步上下文对象, 负责publish消息 */\n       redisContext * m_publish_context;\n       /* hiredis同步上下文对象, 负责subscribe消息 */\n       redisContext * m_subscribe_context;\n   ```\n\n2. 回调操作, 收到订阅的消息, 给service层上报\n   ```cpp\n   private:\n       /* 回调操作, 收到订阅的消息, 给service层上报 */\n       MessageCallback m_notify_handler;\n   ```\n\n>1. 对于\"hiredis上下文对象\"的理解:\n>   - 相当于一个redis-cli, 存储了连接相关的信息;\n>2. 为什么要写两个上下文对象?\n>   * 如果上下文对象正在subscribe那么其将会阻塞, 所以subscribe和publish需要分开操作;\n\n### 成员函数\n\n1. 构造/析构\n   ```cpp\n   public:\n       Redis();\n       ~Redis();\n   ```\n\n2. connect - 连接Redis服务器\n   ```cpp\n   public:\n       /* 连接Redis服务器 */\n       bool connect();\n   ```\n\n3. 发布/订阅消息\n   ```cpp\n   public:\n       /* 向指定的redis频道发布消息 */\n       bool publish(int channel, string message);\n       /* 向指定的redis频道订阅消息 */\n       bool subscribe(int channel);\n       /* 向指定的redis频道取消订阅消息 */\n       bool unsubscribe(int channel);\n   ```\n\n4. `observer_channel_message` - 在独立线程中接收订阅频道中的消息\n\n   ```cpp\n   public:\n       /* 在独立线程中接收订阅频道中的消息 */\n       void observer_channel_message();\n   ```\n\n5. `init_notify_handler` - 初始化向业务层上报频道消息 的回调函数, 需要用到一个int(频道号), 一个消息内容字符串\n\n   ```cpp\n   public:\n       using MessageCallback = function<void(int, string)>;\n       /* 初始化向业务层上报频道消息 的回调函数, 需要用到int(频道号), 消息内容字符串 */\n       void init_notify_handler(MessageCallback cb);\n   ```\n\n### 代码实现\n\n1. 构造 - 只是对两个上下文对象指针赋nullptr, 没有实际构造\n   ```cpp\n   Redis::Redis()\n       : m_publish_context(nullptr), m_subscribe_context(nullptr)\n   {\n   }\n   ```\n\n2. 析构 - 调用`redisFree`释放上下文对象资源\n   ```cpp\n   Redis::~Redis()\n   {\n       if(m_publish_context != nullptr)\n       {\n           redisFree(m_publish_context);\n       }\n       if(m_subscribe_context != nullptr)\n       {\n           redisFree(m_subscribe_context);\n       }\n   }\n   ```\n\n3. connect\n\n   1. 对context进行实际的申请资源/构造, 返回指针赋给成员, 底层调用`redisConnect`\n   2. 创建线程, 执行`observer_channel_message`, 即循环等待Redis频道的reply\n\n   ```cpp\n   bool Redis::connect()\n   {\n       m_publish_context = redisConnect(\"127.0.0.1\", 6379);\n       if(nullptr == m_publish_context)\n       {\n           cerr << \"connect redis failed!\" << endl;\n           return false;\n       }\n   \n       m_subscribe_context = redisConnect(\"127.0.0.1\", 6379);\n       if(nullptr == m_subscribe_context)\n       {\n           cerr << \"connect redis failed!\" << endl;\n           return false;\n       }\n   \n       /**\n        * 由于subscribe操作是阻塞的, \n        * 在实际的使用环境下, 不可能因为一个订阅操作去阻塞一个服务器, \n        * 所以要用一个单独的线程来完成监听频道上的事件,\n        * 有消息则给业务层进行上报; \n        */\n       thread t(\n           [&]() { observer_channel_message();} );\n       t.detach();\n   \n       cout << \"connect redis-server success!\" << endl;\n       return true;\n   }\n   ```\n\n4. publish - 相当于向redis-server发送命令, reply接收命令执行结果\n   ```cpp\n   bool Redis::publish(int channel, string message)\n   {\n       /* 相当于向redis-server发送命令, reply接收命令执行结果 */\n       redisReply * reply = (redisReply*)redisCommand(\n           m_publish_context, \"PUBLISH %d %s\", channel, message.c_str());\n       if(nullptr == reply)\n       {\n           cerr << \"publish command failed!\" << endl;\n           return false;\n       }\n       freeReplyObject(reply);\n       return true;\n   }\n   ```\n\n5. subscribe - 相当于把redisCommand细化了, 只操作了发命令, 接收结果交给单独的线程做了, 详见`observer_channel_message`\n   ```cpp\n   bool Redis::subscribe(int channel)\n   {\n       if(REDIS_ERR == redisAppendCommand(\n           m_subscribe_context, \"SUBSCRIBE %d\", channel))\n       {\n           cerr << \"subscribe command failed!\" << endl;\n           return false;\n       }\n       /* 循环发送缓冲区内容, 直到发送完毕 */\n       int done = 0;\n       while(!done)\n       {\n           if(REDIS_ERR == redisBufferWrite(m_subscribe_context, &done))\n           {\n               cerr << \"subscribe command failed!\" << endl;\n               return false;\n           }\n       }\n       /**\n        * 这里不做redisReply的操作,\n        * 这是个阻塞的操作, 放在observer_channel_message中做;\n        */\n       return true;\n   }\n   ```\n\n6. unsubscribe\n   ```cpp\n   bool Redis::unsubscribe(int channel)\n   {\n       if(REDIS_ERR == redisAppendCommand(\n           m_subscribe_context, \"UNSUBSCRIBE %d\", channel))\n       {\n           cerr << \"unsubscribe command failed!\" << endl;\n           return false;\n       }\n       /* 循环发送缓冲区内容, 直到发送完毕 */\n       int done = 0;\n       while(!done)\n       {\n           if(REDIS_ERR == redisBufferWrite(m_subscribe_context, &done))\n           {\n               cerr << \"unsubscribe command failed!\" << endl;\n               return false;\n           }\n       }\n       /**\n        * 这里不做redisReply的操作,\n        * 这是个阻塞的操作, 放在observer_channel_message中做;\n        */\n       return true;\n   }\n   ```\n\n7. `observer_channel_message`\n\n   * Redis频道如果有消息, 则有三个字段, \n     1. 对应的是redisGetReply返回的`reply->element[0],[1],[2]`;\n     2. 本项目的`element[1]`对应的是频道号;\n     3. 本项目的`element[2]`对应的是消息体;\n\n   ```cpp\n   void Redis::observer_channel_message()\n   {\n       redisReply *reply = nullptr;\n       int res = REDIS_ERR;\n       while(REDIS_OK==(res = redisGetReply(\n                                   m_subscribe_context, (void**)&reply)))\n       {\n           if(reply != nullptr &&\n              reply->element[2] != nullptr &&\n              reply->element[2]->str != nullptr)\n           {\n               /* 给业务层上报频道上发生的消息, 即频道号+消息体 */\n               m_notify_handler(atoi(reply->element[1]->str),\n                                reply->element[2]->str );\n           }\n           freeReplyObject(reply);\n       }\n       if(res == REDIS_ERR)\n       {\n           cerr << \"redisGetReply err\" << endl;\n           return;\n       }\n       cerr << \"observer_channel_message quit\" << endl;\n   }\n   ```\n\n8. `init_notify_handler` - 设置`m_notify_handler`回调\n\n   ```cpp\n   void Redis::init_notify_handler(MessageCallback cb)\n   {\n       m_notify_handler = cb;\n   }\n   ```\n\n> redisCommand和redisAppendCommand的区别:\n>\n> 1. redisAppendCommand只是把命令先写到本地缓存中;\n> 2. 写到缓存之后还需要调用redisBufferWrite把缓存中的命令发送到Redis服务器;\n> 3. 最后, 如果要获得reply, 还需要调用redisGetReply获取结果, 这个操作对于subscribe是阻塞的;\n> 4. 由于publish操作一般不会阻塞, 所以直接调用redisCommand;\n> 5. 由于subscribe操作最后的redisGetReply将会阻塞, 所以我们把这几个步骤单独写出来, 粒度减小, 追求效率;\n\n# ChatService加入Redis组件\n\n1. 首先, 需要在`chatservice.hpp`中, 引入头文件`\"redis.hpp\"`; 然后在`ChatService`的类成员变量中声明一个`Redis m_redis`redis操作对象;\n   ```cpp\n   private:\n       Redis m_redis;\n   ```\n\n2. 在ChatService类中, 添加一个处理redis业务的成员函数`handleRedisSubscribeMessage`\n   ```cpp\n   public:\n       void handleRedisSubscribeMessage(int channel, string message);\n   ```\n\n3. 在`chatservice.cpp`中, ChatService的构造函数中, 需要添加连接redis服务器的操作; 如果连接成功, 给redis设置回调函数为`handleRedisSubscribeMessage`, 参数为chatservice对象指针, channel, message;\n   ```cpp\n   ChatService::ChatService()\n   {\n       // ...\n       if(m_redis.connect())\n       {\n           m_redis.init_notify_handler(std::bind(\n               &ChatService::handleRedisSubscribeMessage, this, _1, _2));\n       }\n   }\n   ```\n\n   \n\n","categories":["Cpp","项目","集群"]},{"title":"协程_Cpp协程简单实现","url":"/多线程/协程_Cpp协程简单实现/","content":"\n在`C++`中实现协程库可能是一项具有挑战性的任务，但它是深入了解协程工作原理的好方法。 \n\n# 协程工作原理\n\n在高层次上，协程允许编写看似同步的代码，但可以异步挂起和恢复。 \n\n基本思想是协程是一个可以在执行过程中的特定点暂停和恢复的函数，允许其他代码同时运行。\n\n# 状态机实现协程\n\n要在`C++`中实现协程，需要管理协程的状态，包括其当前堆栈帧、指令指针和任何局部变量。还需要能够在执行过程中的特定点暂停和恢复协程。\n\n在`C++`中实现协程的一种方法是使用状态机。状态机跟踪协程的状态并提供挂起和恢复协程的方法。当协程第一次被调用时，它进入初始状态并开始执行。当遇到挂起点时，状态机保存协程的状态并将控制权返回给调用代码。当协程恢复时，状态机恢复协程的状态并从它停止的地方继续执行。\n\n下面是一个示例，说明如何使用状态机实现一个简单的协程库：\n\n```cpp\n#include <iostream>\n#include <functional>\n#include <vector>\n\nclass Coroutine {\npublic:\n    Coroutine(std::function<void()> f)\n        : m_function(f), m_state(0)\n    {}\n\n    void resume() {\n        switch (m_state) {\n        case 0: // Start\n            m_state++;\n            m_function();\n            break;\n        case 1: // Suspend\n            return;\n        }\n    }\n\n    bool is_complete() const {\n        return m_state == 2;\n    }\n\nprivate:\n    std::function<void()> m_function;\n    int m_state;\n};\n\nclass Scheduler {\npublic:\n    void add_coroutine(Coroutine coroutine) {\n        m_coroutines.push_back(coroutine);\n    }\n\n    void run() {\n        while (!m_coroutines.empty()) {\n            auto coroutine = m_coroutines.front();\n            m_coroutines.pop_front();\n\n            coroutine.resume();\n\n            if (!coroutine.is_complete()) {\n                m_coroutines.push_back(coroutine);\n            }\n        }\n    }\n\nprivate:\n    std::deque<Coroutine> m_coroutines;\n};\n\n// Example usage\nvoid foo(Coroutine& coroutine) {\n    for (int i = 0; i < 5; i++) {\n        std::cout << \"foo \" << i << std::endl;\n        coroutine.resume();\n    }\n}\n\nvoid bar(Coroutine& coroutine) {\n    for (int i = 0; i < 3; i++) {\n        std::cout << \"bar \" << i << std::endl;\n        coroutine.resume();\n    }\n}\n\nint main() {\n    Scheduler scheduler;\n    Coroutine coroutine1(std::bind(foo, std::placeholders::_1));\n    Coroutine coroutine2(std::bind(bar, std::placeholders::_1));\n\n    scheduler.add_coroutine(coroutine1);\n    scheduler.add_coroutine(coroutine2);\n\n    scheduler.run();\n\n    return 0;\n}\n```\n\n在这个例子中，我们定义了一个 Coroutine 类，它接受一个函数对象作为它的构造函数参数。 resume() 方法将协程推进到下一个状态，is_complete() 方法检查协程是否已执行完毕。\n\n我们还定义了一个 Scheduler 类，它维护一个协程列表并一次运行一个，直到它们全部完成。 在示例用法中，我们定义了两个简单的函数 foo 和 bar，它们打印出一些文本并调用`coroutine.resume()`来暂停协程并将控制权交还给调度程序。我们创建两个`Coroutine`对象，每个函数一个，并将它们添加到`Scheduler`中。 最后，我们调用`scheduler.run()`开始运行协程。\n\n运行该程序时，您应该会看到以下输出：\n\n```\nfoo 0\nbar 0\nfoo 1\nbar 1\nfoo 2\nbar 2\nfoo 3\nfoo 4\n```\n\n这演示了协程如何工作的基本思想。 foo 和 bar 函数以来回的方式执行，因为调度程序暂停和恢复协程。\n\n当然，这只是一个简单的例子，实现一个功能完备的协程库还有很多细节。 但是，我希望这能让您大致了解如何在 C++ 中实现协程。\n\n# 实现\n\n要在`C++`中实现协程库，您需要使用`C++20`中引入的语言对协程的内置支持。具体来说，您需要使用`std::coroutine_traits`模板来定义协程类型，并使用`std::suspend_always`和`std::suspend_never`类来指示协程何时应该挂起和恢复。\n","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"Go_基础语法","url":"/Go/Go_基础语法/","content":"\n# Work before Hello World\n\n1. Open a command prompt and cd to home directory.\n\n2. Create a hello directory for the first Go source code.\n\n   ```bash\n   mkdir hello\n   cd hello\n   ```\n\n3. Enable dependency tracking for your code.\n\n   When your code imports packages contained in other modules, you manage those dependencies through your code's own module. **That module is defined by a `go.mod` file that tracks the modules that provide those packages**. That go.mod file stays with your code, including in your source code repository.\n\n   To enable dependency tracking for your code by creating a go.mod file, run the [`go mod init` command](https://go.dev/ref/mod#go-mod-init), giving it the name of the module your code will be in. The name is the module's module path.\n   In actual development, the module path will typically be the repository location where your source code will be kept. For example, the module path might be `github.com/mymodule`. If you plan to publish your module for others to use, the module path *must* be a location from which Go tools can download your module. For more about naming a module with a module path, see [Managing dependencies](https://go.dev/doc/modules/managing-dependencies#naming_module).\n   But for the purposes of just a tutorial, just use `example/hello`.\n\n   ```bash\n   $ go mod init example/hello\n   go: creating new go.mod: module example/hello\n   ```\n\n4. In your text editor, create a file hello.go in which to write your code.\n\n5. Paste the following code into your hello.go file and save the file.\n   ```go\n   package main\n   \n   import \"fmt\"\n   \n   func main(){\n       fmt.Println(\"Hello, World!\")\n   }\n   ```\n\n   This is your Go code. In this code, you:\n\n   * Declare a `main` **package (a package is a way to group functions, and it's made up of all the files in the same directory)**.\n   * Import the popular [`fmt` package](https://pkg.go.dev/fmt/), which contains functions for formatting text, including printing to the console. This package is one of the [standard library](https://pkg.go.dev/std) packages you got when you installed Go.\n   * Implement a `main` function to print a message to the console. A `main` function executes by default when you run the `main` package.\n\n6. Run the code to see the greeting.\n\n   ```bash\n   $ go run .\n   Hello, World!\n   ```\n\n## Key Points\n\n1. When your code imports packages contained in other modules, you manage those dependencies through your code's own module. **That module is defined by a `go.mod` file that tracks the modules that provide those packages**. That go.mod file stays with your code, including in your source code repository.\n2. To enable dependency tracking for your code by creating a go.mod file, run the [`go mod init` command](https://go.dev/ref/mod#go-mod-init), giving it the name of the module your code will be in. The name is the module's module path.\n3. In actual development, the module path will typically be the repository location where your source code will be kept. For example, the module path might be `github.com/mymodule`. If you plan to publish your module for others to use, the module path *must* be a location from which Go tools can download your module. For more about naming a module with a module path, see [Managing dependencies](https://go.dev/doc/modules/managing-dependencies#naming_module).\n4. Package is a way to group functions, and it's made up of all the files in the same directory.\n5. A `main` function executes by default when you run the `main` package.\n6. go mod init command: `go mod init example/hello `\n7. go run command: `go run example/hello`\n8. go build command and run: `go build example/hello/main.go` `./example/hello/main`\n\n# variable type\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"math\"\n)\n\nfunc main() {\n\tvar a = \"initial\"\n\tvar b, c int = 1, 2\n\tvar d = true\n\tvar e float64\n\tf := float32(e)\n\tg := a + \"foo\"\n\tfmt.Println(a, b, c, d, e, f)\n\tfmt.Println(g)\n\n\tconst s string = \"constant\"\n\tconst h = 500000000\n\tconst i = 3e20 / h\n\tfmt.Println(s, h, i, math.Sin(h), math.Sin(i))\n}\n```\n\n## Key Points\n\n1. go语言是一门强类型语言，每一个变量都有它自己的变量类型\n2. go语言的字符串是内置类型，可以直接通过加号拼接，也能够直接用等于号去比较两个字符串。\n3. go语言变量的声明有两种方式\n   1. 一种是通过`var name string = \"\"`这种方式来声明变量，声明变量的时候，一般会自动去推导变量的类型。\n   2. 如果有需要，也可以显式写出变量类型。另一种声明变量的方式是：`使用变量 冒号 := 值`。\n4. 常量就是把var改成const，值得一提的是go语言里面的常量没有确定的类型，会根据使用的上下文来自动确定类型。\n\n# if else\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tif 7%2 == 0 {\n\t\tfmt.Println(\"7 is even\")\n\t} else {\n\t\tfmt.Println(\"7 is odd\")\n\t}\n\tif 8%4 == 0 {\n\t\tfmt.Println(\"8 is divisible by 4\")\n\t}\n\tif num := 9; num < 0 {\n\t\tfmt.Println(num, \"is negative\")\n\t} else if num < 10 {\n\t\tfmt.Println(num, \"has 1 digit\")\n\t} else {\n\t\tfmt.Println(num, \"has multiple digits\")\n\t}\n}\n```\n\n```\n7 is odd\n8 is divisible by 4\n9 has 1 digit\n```\n\n## Key Points\n\n1. if后面没有括号。\n2. if执行语句块必须接大括号。不能像C或者Cpp一样，直接把if里面的语句同一行。\n\n# for\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ti := 1\n\tfor {\n\t\tfmt.Println(\"loop\")\n\t\tbreak\n\t}\n\tfor j := 7; j < 9; j++ {\n\t\tfmt.Println(j)\n\t}\n\tfor n := 0; n < 5; n++ {\n\t\tif n%2 == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(n)\n\t}\n\tfor i <= 3 {\n\t\tfmt.Println(i)\n\t\ti = i + 1\n\t}\n}\n```\n\n```\nloop\n7\n8\n1\n3\n1\n2\n3\n```\n\n## Key Points\n\n1. go语言只有for循环\n2. 最简单的for后面什么也不写，是死循环\n3. for i等于0，i小于n，i加加。这中间三段，任何一段都可以省略。\n\n# switch\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ta := 2\n\tswitch a {\n\tcase 1:\n\t\tfmt.Println(\"one\")\n\tcase 2:\n\t\tfmt.Println(\"two\")\n\tcase 3:\n\t\tfmt.Println(\"Three\")\n\tcase 4, 5:\n\t\tfmt.Println(\"four or five\")\n\tdefault:\n\t\tfmt.Println(\"Other\")\n\t}\n\n\tt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"It's before noon\")\n\tdefault:\n\t\tfmt.Println(\"It's after noon\")\n\t}\n}\n```\n\n```\ntwo\nIt's after noon\n```\n\n## Key Points\n\n1. go语言的switch后面的那个变量名，不要括号。\n2. 很大的一点不同的是，在cpp里面，switch case如果不加break的话会然后会继续往下跑完所有的case，在go语言里面的话不加break也会跳出来。\n3. 相比C或者Cpp，go语言里面的switch功能更强大。可以使用任意的变量类型，甚至可以用来取代任意的if else语句。你可以在switch后面不加任何的变量，然后在case里面写条件分支。这样代码相比你用多个if else代码逻辑会更为清晰。\n\n# array\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar a [5]int\n\ta[4] = 100\n\tfmt.Println(a[4], len(a))\n\n\tb := [5]int{1, 2, 3, 4, 5}\n\tfmt.Println(b)\n\n\tvar twoD [2][3]int\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\ttwoD[i][j] = i + j\n\t\t}\n\t}\n\tfmt.Println(\"2d: \", twoD)\n}\n```\n\n```\n100 5\n[1 2 3 4 5]\n2d:  [[0 1 2] [1 2 3]]\n```\n\n## Key Points\n\n1. 数组就是一个具有编号且长度固定的元素序列。\n2. 对于一个数组，可以很方便地取特定索引的值或者往特定索引取存储值，然后也能够直接去打印一个数组。不过，在真实业务代码里面，很少直接使用数组，因为长度是固定的，用的更多的是切片。\n\n# Slice\n\n在Go语言中，\"slice\"是对数组的一种抽象表示。你可以把它想象成从数组中\"切下\"来的一片，所以被称为\"slice\"（切片）。切片是动态的，它们可以根据需要自动增长和缩小，这与数组的固定大小形成对比。切片提供了一个更灵活，更强大的接口来处理序列类型的数据。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ts := make([]string, 3)\n\ts[0] = \"a\"\n\ts[1] = \"b\"\n\ts[2] = \"c\"\n\tfmt.Println(\"get:\", s[2])   //c\n\tfmt.Println(\"len:\", len(s)) //3\n\n\ts = append(s, \"d\")\n\ts = append(s, \"e\", \"f\")\n\tfmt.Println(s) // [a b c d e f]\n\tc := make([]string, len(s))\n\tcopy(c, s)\n\tfmt.Println(c)\n\n\tfmt.Println(s[2:5]) // [c d e]\n\tfmt.Println(s[:5])  // [a b c d e]\n\tfmt.Println(s[2:])  // [c d e f]\n\n\tgood := []string{\"g\", \"o\", \"o\", \"d\"}\n\tfmt.Println(good) // [g o o d]\n}\n```\n\n## Key Points\n\n1. 可以用make来创建一个切片，可以像数组一样去取值\n2. 使用append来追加元素。注意append的用法，必须把append的结果返回给原数组。因为slice的原理实际上是它有一个它存储了一个长度和一个容量，加一个指向一个数组的指针，在执行append操作的时候，如果容量不够的话，会扩容并且返回新的 slice。\n3. slice初始化的时候也可以指定长度。\n4. slice拥有像python一样的切片操作，比如取出第二个到第五个位置的元素，不包括第五个元素。不过不同于python的是不支持负数索引。\n\n# map\n\n1. 可以用make创建一个空map\n\n   ```go\n   m := make(map[string]int)\n   ```\n\n   \n","categories":["Go"]},{"title":"协程_Cpp协程框架简单实现","url":"/多线程/协程_Cpp协程框架简单实现/","content":"\n# 进程、线程、协程的对比\n\n|                | 进程                                    | 线程                               | 协程                              |\n| -------------- | --------------------------------------- | ---------------------------------- | --------------------------------- |\n| 切换者         | 操作系统                                | 操作系统                           | 用户                              |\n| 切换时机       | 根据操作系统的调度策略，对用户透明      | 根据操作系统的调度策略，对用户透明 | 用户自己决定                      |\n| 切换内容       | 1、页全局目录；2、内核栈；3、硬件上下文 | 1、内核栈；2、硬件上下文           | 硬件上下文                        |\n| 切换内容的保存 | 保存于内核栈中                          | 保存于内核栈中                     | 保存于用户自己的变量（用户栈/堆） |\n| 切换过程       | 用户态->内核态->用户态                  | 用户态->内核态->用户态             | 用户态                            |\n\n硬件上下文可以在网上查阅资料。\n\n## 协程的优缺点\n\n1. IO阻塞时，协程的切换效率比较高\n2. 不需要锁机制。实际上，创建了大量的协程之后，它们是按顺序执行的，不存在竞争关系。\n\n但是不能利用多核CPU。\n\n# 如何实现协程\n\n利用操作系统提供的接口来实现协程。\n\n1. Linux的ucontext\n2. Windows的Fiber\n\n## `ucontext_t`结构\n\n根据UNIX环境高级编程第三版280页。`ucontext_t`被用作标识进程的上下文信息。该结构至少包含下列字段：\n\n```cpp\nstruct ucontext_t\n{\n    ucontext_t * uc_link; //pointer to context resumed when this context returns\n    stack_t uc_stack;     //stack used by this context\n    mcontext_t uc_mcontext;//machine-specific representation of saved context\n}\n```\n\n`uc_stack`字段描述了当前上下文使用的栈，至少包括下列成员：\n\n```cpp\nstruct uc_stack\n{\n    void * ss_sp;   //stack base or pointer\n    size_t ss_size; //stack size\n    int ss_flags;   //flags\n}\n```\n\n## ucontext提供的四个接口\n\n```cpp\nint getcontext(ucontext_t *ucp);\nint setcontext(const ucontext_t *ucp);\nvoid makecontext(ucontext_t *ucp, (void *func)(), int argc, ...);\nint swapcontext(ucontext_t *oucp, const ucontext_t *ucp);//保存oucp, 换到ucp\n```\n\n1. getcontext: 保存上下文，将当前运行到的寄存器的信息保存到`ucontext_t`结构体中。\n2. setcontext: 恢复上下文，将`ucontext_t`结构体变量中的上下文信息重新恢复到CPU中并执行。\n3. makecontext: 修改上下文，给`ucontext_t`上下文指定一个程序入口函数，让程序从该入口函数中开始执行。\n4. swapcontext: 切换上下文，保存当前上下文，并将下一个要执行的上下文恢复到CPU中。\n\n## ucontext简单的使用示例\n\n```cpp\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<ucontext.h>\n\nint main()\n{\n    int i = 0;\n    ucontext_t ctx;\n    \n    getcontext(&ctx);        //获取当前上下文\n    printf(\"i = %d\\n\", i++);\n    sleep(1);\n    \n    setcontext(&ctx);        //恢复上下文\n    return 0;\n}\n```\n\n# 协程框架设计\n\n## 协程类\n\n三个状态：就绪态、运行态、挂起态。\n\n成员：\n\n1. 上下文`m_ctx`\n2. 状态`m_status`\n3. 栈空间指针`m_stack`，及栈空间大小`m_stack_size`\n\n成员方法：\n\n1. run：纯虚函数，需要子类来实现协程的具体业务逻辑\n2. resume：继续执行已经挂起的线程。\n3. yield：当前协程“放弃”执行，让调度器调度另一协程继续执行。\n\n```cpp\nclass Routine\n{\npublic:\n    enum Status { RT_READY = 0, RT_RUNNING, RT_SUSPEND };\n    Routine();\n    virtual ~Routine();\n    \n    virtual void run() = 0;\n    void resume();\n    void yield();\n    int status();\nprotected:\n    static void func(void * ptr);\nprivate:\n    ucontext_t m_ctx;\n    int m_status;\n    char * m_stack;\n    int m_stack_size;\n};\n```\n\n默认无参构造函数不分配栈空间，只有yield时才分配。\n\n```cpp\nRoutine::Routine() : m_status(RT_READY), m_stack(nullptr), m_stack_size(0)\n{}\n```\n\n### yield实现\n\n```\n注意：yield一般是在run方法中最后一句话中主动调用的。而run方法是在用户指定的m_ctx中执行的，所以，yield中定义的变量地址也是处于m_ctx指定的栈空间中分配的。\n```\n\n主要的工作是：\n\n1. 把协程栈中的内容复制保存到`m_stack`中存储。**利用了一个dummy变量，探测协程栈实际使用了的边界地址（最低地址，栈的增长方向是从高到低）。**\n\n其他的工作：\n\n2. 把自身放入到调度器中的任务队列中；\n3. 调用swapcontext。保存`m_ctx`上下文，切换到`s->m_main`上下文。\n\n```cpp\nvoid Routine::yield()\n{\n    auto s = Singleton<Schedule>::instance();\n    char dummy = 0;\n    assert(s->m_stack + s->m_stack_size - &dummy <= s->m_stack_size);\n    if(m_stack_size < s->m_stack + s->m_stack_size - &dummy)\n    {\n        delete [] m_stack;\n        m_stack_size = s->m_stack + s->m_stack_size - &dummy;\n        m_stack = new char[m_stack_size];\n    }\n    std::memcpy(m_stack, &dummy, m_stack_size);\n    m_status = RT_SUSPEND;\n    s->append(this);\n    swapcontext(&m_ctx, &s->m_main);\n}\n```\n\n\n\n### resume实现\n\n通常是Schedule单例对象来从其任务队列中出队一个Routine，并调用该routine的resume方法。\n\n挂起状态：\n\n1. 把`m_stack`中保存的内容复制到`s->m_stack + s->m_stack_size - m_stack_size`的位置，即从`s->m_stack`位置开始正好存储`m_stack_size`。\n2. 调用`swapcontext`，保存`s->m_main`上下文，切换到`m_ctx`上下文。\n\n```cpp\ncase RT_SUSPEND:\n    std::memcpy(s->m_stack + s->m_stack_size - m_stack_size, m_stack, m_stack_size);// dest src size\n    m_status = RT_RUNNING;\n    swapcontext(&s->m_main, &m_ctx);\n```\n\n准备状态：\n\n1. getcontext将当前运行到的寄存器的信息保存到`ucontext_t`结构体中。\n2. 设置`m_ctx`的栈空间，用`m_ctx.uc_stack.ss_sp`指定，此时我们使用调度器s的共享栈空间。\n3. `m_ctx.uc_link`，表示pointer to context resumed when this context returns。指向`s->m_main`。\n4. 调用makecontext，指定其运行func函数，参数为1个，即this指针，并且指定其在`m_ctx`上下文中执行。\n5. 调用swapcontext，保存`s->main`上下文，切换到`m_ctx`上下文。\n\n```cpp\ncase RT_READY:\n    getcontext(&m_ctx);\n    m_ctx.uc_stack.ss_sp = s->m_stack;\n    m_ctx.uc_stack.ss_size = s->m_stack_size;\n    m_ctx.uc_link = &s->m_main;\n    m_status = RT_RUNNING;\n    makecontext(&m_ctx, (void (*)(void))Routine::func, 1, this);\n    swapcontext(&s->m_main, &m_ctx);\n```\n\n以上代码的目的：指定协程使用s的公共栈。并且指定协程执行完毕回到调度器。\n\n### 实例\n\n```cpp\n#include<iostream>\n#include<routine/routine.h> \nusing namespace xcg::routine;\n\nclass ARouine : public Routine\n{\npublic:\n    ARoutine(int * num) : Routine(), m_num(num) {}\n    ~ARoutine()\n    {\n        if(m_num != nullptr)\n        {\n            delete m_num;\n            m_num = nullptr;\n        }\n    }\n    void run() overide\n    {\n        for(int i = 0; i < *m_num; ++i)\n        {\n            std::cout << \"a run: num=\" << i << std::endl;\n            yield();\n        }\n    }\nprivate:\n    int * m_num;\n}\n```\n\nmain\n\n```cpp\n#include<iostream>\n\n#include<routine/schedule.h>\nusing namespace xcg::routine;\n\n#include<test/a_routine.h>\n#include<test/b_routine.h>\n\nint main()\n{\n    Logger::instance()->open(\"./main.log\");\n    Logger::instance()->console(false);\n    \n    auto s = Singleton<Schedule>::instance();\n    s->create();\n    \n    int * num1 = new int;\n    *num1 = 5;\n    Routine * a = new ARoutine(num1);\n    s->append(a);\n    \n    int * num2 = new int;\n    *num2 = 10;\n    Routine * b = new BRoutine(num2);\n    s->append(b);\n    \n    while(!s->empty())\n    {\n        std::cout << \"main run\" << std::endl;\n        s->resume();\n    }\n    return 0;\n}\n```\n\n## 总结\n\n总而言之，协程在不断地进行yield、resume。在准备/挂起、运行态中不断切换。更进一步说，本质上就是`swapcontext(&s->m_main, &m_ctx);`和`swapcontext(&m_ctx, &s->m_main);`的不断调用。\n\n## 调度器Schedule\n\n成员：\n\n1. 记录上下文的变量`m_main`\n2. 栈指针`m_stack`，及栈大小`m_stack_size`\n3. 任务队列`m_queue`，用list存放协程指针\n\n成员方法：\n\n1. create：初始化协程调度器\n2. append：添加一个新协程到队列\n3. resume：唤醒队列里某个协程执行\n\n```cpp\nclass Schedule\n{\n    friend class Routine;\npublic:\n    Schedule();\n    ~Schedule();\n    \n    void create(int stack_size = 1024 * 1024);\n    void append(Routine * c);\n    bool empty() const;\n    int size() const;\n    \n    void resume();\nprivate:\n    ucontext_t m_main;\n    char * m_stack;\n    int m_stack_size;\n    std::list<Routine *> m_queue;\n}\n```\n\n### 创建实现\n\n使用`new char[]`创建一个栈，并初始化为0。\n\n```cpp\nvoid Schedule::create(int stack_size)//默认1024*1024\n{\n    m_stack_size = stack_size;\n    m_stack = new char[stack_size];\n    std::memset(m_stack, 0, stack_size);\n}\n```\n\n### 析构实现\n\n```cpp\nSchedule::~Schedule()\n{\n    for (auto it : m_queue)\n    {\n        delete it;\n    }\n    m_queue.clear();\n    if (m_stack != nullptr)\n    {\n        delete [] m_stack;\n        m_stack_size = 0;\n    }\n}\n```\n\n### 入队实现\n\n```cpp\nvoid Schedule::append(Routine * c)\n{\n    m_queue.push_back(c);\n}\n```\n\n### resume实现\n\n```cpp\nvoid Schedule::resume()\n{\n    if (m_queue.empty())\n    {\n        return;\n    }\n    auto c = queue.front();\n    m_queue.pop_front();\n    c->resume();\n}\n```\n\n# 基于协程的C++异步网络框架\n\n## Server\n\n```cpp\n#pragma once\n#include<string>\nusing std::string;\n\n#include <utility/system.h>\n#include <utility/logger.h>\n#include <utility/ini_file.h>\n#include <utility/singleton.h>\nusing namespace xcg::utility;\n\nnamespace xcg{\nnamespace frame{\n\nclass Server\n{\npublic:\n    Server();\n    ~Server();\n    \n    void listen(const string & ip, int port);\n    void start();\n    void set_connects(int connects);\nprivate:\n    string m_ip;\n    int m_port;\n    int m_connects;\n};\n}\n}\n```\n\n### 构造函数\n\n1. 按照配置文件初始化Server类成员的ip和端口信息；\n2. 初始化日志模块\n\n```cpp\nServer::Server() : m_connects(1024)\n{\n    System * sys = Singleton<System>::instance();\n    sys->init();\n    \n    // init inifile\n    Inifile * ini = Singleton<IniFile>::instance();\n    ini->load(sys->get_root_path() + \"/config/server.ini\");\n    \n    m_ip = (string)(*ini)[\"server\"][\"ip\"];\n    m_port = (*ini)[\"Server\"][\"port\"];\n    m_connects = (*ini)[\"server\"][\"max_conn\"];\n    \n    int level = (*ini)[\"server\"][\"log_level\"];\n    bool console = (*ini)[\"server\"][\"log_console\"];\n    \n    // init logger\n    Logger::instance()->open(sys->get_root_path() + \"/log/server.log\");\n    Logger::instance()->level(level);\n    Logger::instance()->console(console);\n}\n```\n\n### 启动函数\n\n1. 启动、初始化socket连接池\n2. 启动调度器\n3. 用`m_ip, m_port`构造ServerSocket\n4. 用封装好的ServerSocket构造ServerRoutine，然后把ServerRoutine加入到调度器的任务队列中。\n5. resume任务队列中的协程。\n\n```cpp\nvoid Server::start()\n{\n    Singleton<ObjectPool<Socket>>::instance()->init(m_connects);\n    auto s = Singleton<Schedule>::instance();//调度器\n    s->create();                             //创建第一个协程，服务协程\n    s->append(new ServerRoutine(new ServerSocket(m_ip, m_port)));\n    while(!s->empty())\n    {\n        s->resume();\n    }\n}\n```\n\n\n\n## 服务协程\n\n1. 监听和建立客户端的连接\n2. 当客户端没有新连接时立刻让出CPU，切换到下一个协程。\n3. 当客户端有新连接时，给对应的连接新建一个client routine。\n\n```cpp\n#pargma once\n#include<cerrno>\n#inlcude<socket/socket.h>\nusing namespace xcg::socket;\n\n#include<routine/routine.h>\n#inlcude<routine/schedule.h>\nusing namespace xcg::routine;\n\nnamespace xcg\n{\nnamespace async\n{\n\nclass ServerRoutine : public Routine\n{\npublic:\n    ServerRoutine(Socket * socket);\n    ~ServerRoutine();\n    \n    void run() override;\nprivate:\n    Socket * m_socket;\n};\n\n}\n}\n```\n\n```cpp\n#include<async/server_routine.h>\n#include<async/client_routine.h>\nusing namespace xcg::async;\n\n#include<utility/singleton.h>\n#include<utility/object_pool.h>\nusing namespace xcg::utility;\n\nServerRoutine::ServerRoutine(Socket * socket) : Routine(), m_socket(socket)\n{}\n\nServerRoutine::~ServerRoutine()\n{\n    if(m_socket != nullptr)\n    {\n        delete m_socket;\n        m_socket = nullptr;\n    }\n}\nvoid ServerRoutine::run()\n{\n    log_debug(\"Server routine run\");\n    while(true)\n    {\n        int sockfd = m_socket->accept();\n        if(sockfd < 0)\n        {\n            log_debug(\"server accept would block: sockfd=%d errno=%d error=%s\", sockfd, errno, strerror(errno));\n            yield();                     //没有新连接，让出CPU\n        }\n        else//有有效连接\n        {\n            Socket * socket = nullptr;\n            while(true)//如果连接池无资源则一直卡住申请\n            {\n                //ObjectPool为连接池，从连接池中取一个资源给socket。\n                socket = Singleton<ObjectPool<Socket>>::instance()->allocate();\n                if(socket != nullptr)\n                {\n                    break;\n                }\n                log_error(\"socket pool is empty\");\n                yield();                //连接池已满，让出CPU\n            }\n            // 有效连接并且申请得到资源 后的操作\n            socket->m_sockfd = sockfd;\n            socket->set_non_blocking(); //套接字设置为非阻塞的\n            //新建一个Client Routine，添加到调度器队列。\n            Singleton<Schedule>::instance()->append(new ClientRoutine(socket));\n        }\n    }\n}\n```\n\n## 客户端协程\n\n1. 当客户端没有数据到达，让出CPU，切换到下一个协程。\n2. 当客户端有数据到达，立刻处理；\n3. 当客户端关闭连接，协程自动销毁。\n\n```cpp\n#pragma once\n#include<socket/socket.h>\nusing namespace xcg::socket;\n\n#include<routine/routine.h>\nusing namespace xcg::routine;\n\nnamespace xcg{\nnamespace async{\nclass ClientRoutine : public Routine\n{\npublic:\n    ClientRoutine(Socket * socket);\n    ~ClientRoutine();\n    void run() override;\nprivate:\n    Socket * m_socket;\n};\n}\n}\n```\n\n```cpp\n#include<async/client_routine.h>\nusing namespace xcg::async;\n\n#include<utility/singleton.h>\n#include<utility/object_pool.h>\nusing namespace xcg::utility;\n\nClientRoutine::ClientRoutine(Socket * socket) : Routine(), m_socket(socket)\n{}\n\nClientRoutine::~ClientRoutine()\n{\n    if(m_socket != nullptr)\n    {\n        Singleton<ObjectPool<Socket>>::instance()->release(m_socket);\n        m_socket = nullptr;\n    }\n}\n\nvoid ClientRoutine::run()\n{\n    log_debug(\"client routine run\");\n    char buf[1024];\n    while(true)\n    {\n        std::memset(buf, 0, 1024);\n        //socket已经在创建时设置为非阻塞模式，返回值有三种情况:0 ->closed <0 ->此时没数据到达 >0 ->有数据到达\n        int len = m_socket->recv(buf, 1024);\n        if(len == 0)\n        {\n            log_info(\"socket closed by peer\");\n            m_socket->close();\n            break;\n        }\n        else if(len < 0)\n        {\n            log_debug(\"socket recv would block: len=%d, errno=%d, error=%s\", len, errno, strerror(errno));\n            yield();\n        }\n        else\n        {\n            log_info(\"socket recv: len=%d data=%s\", len, buf);\n            m_socket->send(buf, strlen(buf));\n            yield();\n        }\n    }\n}\n```\n\n## 入口函数\n\n```cpp\n#include<iostream>\n#include<frame/server.h>\nusing namespace xcg::frame;\n\nint main()\n{\n    Server * server = Singleton<Server>::instance();\n    server->listen(\"127.0.0.1\", 8080);\n    server->start();\n    \n    return 0;\n}\n```\n\n# 基于协程网络框架的聊天服务器\n\n## 封装一个TcpServer类\n\n```cpp\n#pragma once\nclass TcpServer : noncopyable\n{\npublic:\n    using ThreadInitCallback = std::function<void(EventLoop*)>;\npublic:\n    TcpServer(EventLoop *loop, const InetAddress &listenAddr,\n              const std::string &nameArg, Option option = kNoReusePort);\n    ~TcpServer();\n    void setThreadInitCallback(const ThreadInitCallback &cb)\n    {\n        m_threadInitCallback = cb;\n    }\n    void setConnectionCallback(const ConnectionCallback &cb)\n    {\n        m_connectionCallback = cb;\n    }\n    void setMessageCallback(const MessageCallback &cb)\n    {\n        m_messageCallback = cb;\n    }\n    void setWriteCompleteCallback(const WriteCompleteCallback &cb)\n    {\n        m_writeCompleteCallback = cb;\n    }\n\n    /* 设置底层subLoop个数 */\n    void setThreadNum(int numThreads);\n    /* 开启服务器监听 */\n    void start();\nprivate:\n    void newConnection(int sockfd, const InetAddress & peerAddr);\n    void removeConnection(const TcpConnectionPtr & conn);\n    void removeConnectionInLoop(const TcpConnectionPtr & conn);\nprivate:\n    ConnectionCallback      m_connectionCallback;   //新连接时的回调\n    MessageCallback         m_;      //有读写消息时的回调\n    WriteCompleteCallback   m_writeCompleteCallback;//消息发送完成后的回调\n    ThreadInitCallback      m_threadInitCallback;   //loop线程初始化的回调\nprivate:\n    using ConnectionMap = std::unordered_map<std::string, TcpConnectionPtr>;\n    ConnectionMap m_connections;\nprivate:\n    std::atomic_int m_started;\n    int m_nextConnId;\n};\n```\n\n```cpp\n/**\n * 有新客户端连接时, acceptor会执行这个回调操作; \n */\nvoid TcpServer::newConnection(int sockfd, const InetAddress &peerAddr)\n{\n    EventLoop *ioLoop = m_threadPool->getNextLoop();\n    char buf[64] = {0};\n    snprintf(buf, sizeof buf, \"-%s#%d\", m_IPport.c_str(), m_nextConnId);\n    ++m_nextConnId;\n    std::string connName = m_name + buf;\n    LOG_INFO(\"%s [%s] - new connection [%s] from %s\\n\",\n             __FUNCTION__, m_name.c_str(), connName.c_str(), peerAddr.toIPport().c_str());\n    \n    //通过sockfd获取其绑定的ip地址和端口信息\n    sockaddr_in local;\n    bzero(&local, sizeof local);\n    socklen_t addrlen = sizeof local;\n    if(::getsockname(sockfd, (sockaddr*)&local, &addrlen) < 0)\n    {\n        LOG_ERROR(\"socket::getsockname\\n\");\n    }\n    InetAddress localAddr(local);\n\n    //根据连接成功的sockfd, 创建TcpConnection连接对象\n    TcpConnectionPtr conn(std::make_shared<TcpConnection>\n        (ioLoop, connName, sockfd, localAddr, peerAddr));\n    m_connections[connName] = conn;\n    //下面的回调是用户给TcpServer设置的\n    conn->setConnectionCallback(m_connectionCallback);\n    conn->setMessageCallback(m_messageCallback);\n    conn->setWriteCompleteCallback(m_writeCompleteCallback);\n\n    //设置如何关闭连接 - 用户调用conn->shutdown() 时回调\n    conn->setCloseCallback(std::bind(&TcpServer::removeConnection, this, _1));\n    //直接调用TcpConnection::connectEstablished, 把state置为connected, channel tie操作, enableReading;\n    ioLoop->runInLoop(std::bind(&TcpConnection::connectEstablished, conn));\n}\n```\n\n## TcpConnection\n\n```cpp\n#pragma once\n#include\"noncopyable.h\"\n#include\"inetaddress.h\"\n#include\"buffer.h\"\n#include\"callbacks.h\"\n#include<memory>\n#include<atomic>\nclass EventLoop;\nclass Socket;\nclass Channel;\nclass TcpConnection : noncopyable,\n               public std::enable_shared_from_this<TcpConnection>\n{\npublic:\n    enum StateE{\n        kDisconnected, kConnecting, kConnected, kDisconnecting\n    };\n    TcpConnection(EventLoop *loop, const std::string& name, int sockfd,\n                  const InetAddress& localAddr, const InetAddress& peerAddr);\n    ~TcpConnection();\npublic:\n    void connectEstablished();\n    void connectDestoryed();\npublic:\n    /* 关闭连接 */\n    void shutdown();\npublic:\n    void setConnectionCallback(const ConnectionCallback & cb)\n    {\n        m_connectionCallback = cb;\n    }\n    void setMessageCallback(const MessageCallback & cb)\n    {\n        m_messageCallback = cb;\n    }\n    void setWriteCompleteCallback(const WriteCompleteCallback & cb)\n    {\n        m_writeCompleteCallback = cb;\n    }\n    void setCloseCallback(const CloseCallback &cb)\n    {\n        m_closeCallback = cb;\n    }\n    void setHighWaterMarkCallback(const HighWaterMarkCallback & cb, size_t highWaterMark)\n    {\n        m_highWaterMarkCallback = cb;\n        m_highWaterMark = highWaterMark;\n    }\npublic:\n    bool connected() const {return m_state == kConnected;}\n    void setState(StateE state) {m_state = state;}\npublic:\n    EventLoop * getLoop() const {return m_loop;}\n    const std::string& name() const {return m_name;}\n    const InetAddress& localAddress() const {return m_localAddr;}\n    const InetAddress& peerAddress() const {return m_peerAddr;}\nprivate:\n    void handleRead(Timestamp receiveTime);\n    void handleWrite();\n    void handleClose();\n    void handleError();\nprivate:\n    /**\n     * 发送数据;\n     * 用户会给TcpServer注册onMessageCallback, \n     * 已建立连接的用户有读写事件时, 尤其是读事件, onMessage会响应; \n     * 处理完客户端发来的事件后(onMessageCallback), 服务端会send给客户端回发消息; \n     * \n     * 收发数据的方式: \n     * 本项目的数据收发统一使用json或protobuf格式化的字符串进行, \n     * 所以此send函数的参数为了方便起见, 直接规定为string类型; \n     */\n    void send(const std::string & buf);\nprivate:\n    /**\n     * 发送数据;\n     * 应用写的快, 而内核发送数据慢, \n     * 需要把待发送数据写入缓冲区, 而且设置了水位回调.\n     */\n    void sendInLoop(const void * data, size_t len);\nprivate:\n    void shutdownInLoop();\n/*************************属性*************************/\nprivate:\n    ConnectionCallback\t    m_connectionCallback;       //关于连接的回调\n    MessageCallback\t        m_messageCallback;          //已连接用户有读写事件发生时的回调\n    WriteCompleteCallback   m_writeCompleteCallback;    //消息发送完成后的回调\n    HighWaterMarkCallback   m_highWaterMarkCallback;    //高水位回调，为了控制收发流量稳定\n    CloseCallback           m_closeCallback;            //关闭连接的回调\nprivate:\n    EventLoop *m_loop;                  //subLoop\nprivate:\n    std::unique_ptr<Socket>  m_socket;  //unique_ptr管理\n    std::unique_ptr<Channel> m_channel; //unique_ptr管理\nprivate:\n    const InetAddress m_localAddr;      //本地地址信息\n    const InetAddress m_peerAddr;       //对端地址信息\nprivate:\n    Buffer m_inputBuffer;               //写缓冲区\n    Buffer m_outputBuffer;              //读缓冲区\nprivate:\n    const std::string m_name;\n    \n    std::atomic_int m_state;            //atomic，用枚举类变量赋值\n    \n    bool m_reading;\n    \n    size_t m_highWaterMark;             //高水位阈值\n};\n```\n\n```cpp\nvoid TcpConnection::handleRead(Timestamp receiveTime)\n{\n    int savedErrno = 0;\n    ssize_t n = m_inputBuffer.readFd(m_channel->fd(), &savedErrno);\n    if(n > 0)\n    {\n        //已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage\n        m_messageCallback(shared_from_this(), &m_inputBuffer, receiveTime);\n    }\n    else if(n == 0) //客户端断开\n    {\n        handleClose();\n    }\n    else\n    {\n        errno = savedErrno;\n        LOG_ERROR(\"%s\\n\", __FUNCTION__);\n        handleError();\n    }\n}\nvoid TcpConnection::handleWrite()\n{\n    if(m_channel->isWriting())\n    {\n        int savedErrno = 0;\n        ssize_t n = m_outputBuffer.writeFd(m_channel->fd(), &savedErrno);\n        if(n > 0)\n        {\n            m_outputBuffer.retrieve(n);\n            if(m_outputBuffer.readableBytes() == 0)\n            {\n                m_channel->disableWriting();\n                if(m_writeCompleteCallback)\n                {\n                    /* 唤醒loop对应的thread线程, 执行回调 */\n                    m_loop->queueInLoop(std::bind(m_writeCompleteCallback,\n                                                  shared_from_this()));\n                }\n                if(m_state == kDisconnecting)\n                {\n                    shutdownInLoop();\n                }\n            }\n        }\n        else\n        {\n            LOG_ERROR(\"%s\\n\", __FUNCTION__);\n        }\n    }\n    else\n    {\n        LOG_ERROR(\"%s: connection fd = %d is down, no more writing.\\n\",\n                   __FUNCTION__, m_channel->fd());\n    }\n}\nvoid TcpConnection::handleClose()\n{\n    LOG_INFO(\"%s: fd = %d, state: %d\\n\", __FUNCTION__, m_channel->fd(), m_state.load());\n    setState(kDisconnected);\n    m_channel->disableAll();\n\n    TcpConnectionPtr connPtr(shared_from_this());\n    m_connectionCallback(connPtr);\n    m_closeCallback(connPtr);\n}\nvoid TcpConnection::handleError()\n{\n    int optval;\n    socklen_t optlen = sizeof optval;\n    int err = 0;\n    if(::getsockopt(m_channel->fd(), SOL_SOCKET, SO_ERROR, &optval, &optlen) < 0)\n    {\n        err = errno;\n    }\n    else\n    {\n        err = optval;\n    }\n    LOG_ERROR(\"%s name: %s - SO_ERROR: %d\\n\", __FUNCTION__, m_name.c_str(), err);\n}\n/**\n * 1. 判断当前连接的状态是否为connected; \n * 2. 判断此loop是否在本thread中, 如果是则调用sendInLoop; 否则runInLoop, 绑定的函数也是sendInLoop;\n */\nvoid TcpConnection::send(const std::string &buf)\n{\n    if(m_state == kConnected)\n    {\n        if(m_loop->isInLoopThread())\n        {\n            sendInLoop(buf.c_str(), buf.size());\n        }\n        else\n        {\n            m_loop->runInLoop(std::bind(&TcpConnection::sendInLoop,\n                              this, buf.c_str(), buf.size()));\n        }\n    }\n}\n/**\n * 发送数据;\n * 应用写的快, 而内核发送数据慢, \n * 需要把待发送数据写入缓冲区, 而且设置了水位回调.\n */\nvoid TcpConnection::sendInLoop(const void * data, size_t len)\n{\n    ssize_t nwrote = 0;\n    size_t remaining = len;\n    bool faultError = false;\t//记录是否产生错误\n    if(m_state == kDisconnected)\n    {\n        LOG_ERROR(\"Disconnected, give up writing!\");\n        return;\n    }\n    /** \n     * m_channel->isWriting()为false表示channel第一次开始写数据, \n     * readableBytes()为0说明缓冲区没有待发送数据; \n     */\n    if(!m_channel->isWriting() && m_outputBuffer.readableBytes() == 0)\n    {\n        nwrote = ::write(m_channel->fd(), data, len);\n        if(nwrote >= 0)\n        {\n            remaining = len - nwrote;\n            if(remaining == 0 && m_writeCompleteCallback)\n            {\n                //如果此时数据全部发送完毕, 不用再给channel设置epollout事件\n                m_loop->queueInLoop(std::bind(m_writeCompleteCallback, shared_from_this()));\n            }\n        }\n        else //nwrote < 0\n        {\n            nwrote = 0;\n            if(errno != EWOULDBLOCK)\n            {\n                LOG_ERROR(\"%s\\n\", __FUNCTION__);\n                if(errno == EPIPE || errno == ECONNRESET)// SIGPIPE or RESET\n                {\n                    faultError = true;\n                }\n            }\n        }\n    }\n    if(!faultError && remaining > 0)//没有出错, 没有发送完毕, 剩余数据需要存到缓冲区, 然后给channel注册epollout事件, LT模式, poller发现tcp的发送缓冲区有空间, 会通知相应的sock->channel, 调用writeCallback方法, 即调用handleWrite, 直到把发送缓冲区中数据全部发送\n    {\n        size_t oldlen = m_outputBuffer.readableBytes();\n        if(oldlen + remaining >= m_highWaterMark && oldlen < m_highWaterMark && m_highWaterMarkCallback)\n        {\n            m_loop->queueInLoop(std::bind(m_highWaterMarkCallback, shared_from_this(), oldlen+remaining));\n        }\n        m_outputBuffer.append((char*)data+nwrote, remaining);//data+nworte即剩余的位置\n        if(!m_channel->isWriting())//m_channel->isWriting()为false表示channel第一次开始写数据, 之前没有注册epollout, 现在需要注册\n        {\n            m_channel->enableWriting();\n        }\n    }\n}\n```\n\n\n\n## 重点在于ClientRoutine的数据处理代码编写\n\n```cpp\n   void ClientRoutine::run()\n   {\n       log_debug(\"client routine run\");\n       char buf[1024];\n       while(true)\n       {\n           std::memset(buf, 0, 1024);\n           //socket已经在创建时设置为非阻塞模式，返回值有三种情况:0 ->closed <0 ->此时没数据到达 >0 ->有数据到达\n           int len = m_socket->recv(buf, 1024);//接受客户端发的消息\n           if(len == 0)\n           {\n               log_info(\"socket closed by peer\");\n               m_socket->close();\n               break;\n           }\n           else if(len < 0)\n           {\n               log_debug(\"socket recv would block: len=%d, errno=%d, error=%s\", len, errno, strerror(errno));\n               yield();\n           }\n           else\n           {\n               log_info(\"socket recv: len=%d data=%s\", len, buf);\n               //handleRead\n               //已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage\n               //messageCallback(m_socket, buf, time);\n               \n               //handle\n               m_socket->send(buf, strlen(buf));//给客户端发送消息\n               yield();\n           }\n       }\n   }\n```\n\n### onMessage\n\n```cpp\n/* 上报读写事件相关信息的回调函数*/\nvoid ChatServer::onMessage(const TcpConnectionPtr& conn,\n                           Buffer* buffer,\n                           Timestamp time)\n{\n    /**\n     * muduo库或从网络上读取的数据首先在数据缓冲区;\n     * 收到一个消息后，retrieveAllAsString可以把缓冲区的数据;\n     * 取出到一个字符串中。\n     */\n    string buf = buffer->retrieveAllAsString();\n    /**\n     * 数据的反序列化;\n     * json中包含message_type，message_id;\n     */\n    json js = json::parse(buf);\n    /**\n     * 通过js[\"msgid\"]绑定一个回调操作，即一个id一个操作;\n     * 解析到msgid后获取业务处理器handler，处理器是事先绑定的方法。网络模块看不到，业务模块绑定的;\n     * 回调handler时，conn、js对象、time都可以传入;\n     * 我们要达到的目的：完全解耦网络模块的代码和业务模块的代码;\n     */\n    auto msgHandler = ChatService::instance()->getHandler(\n        js[\"msgid\"].get<int>());    // js[\"msgid\"] 依旧是json类型，需要转为int\n    /* 回调消息绑定好的事件处理器，来执行相应的业务处理 */\n    msgHandler(conn, js, time);\n}\n```\n\n\n\n\n\n## ChatService类的设计与实现\n\n```cpp\n      #ifndef CHATSERVICE_H\n      #define CHATSERVICE_H\n      #include<muduo/net/TcpConnection.h>\n      #include<unordered_map>\n      #include<functional>\n      \n      #include\"redis.hpp\"\n      \n      #include\"usermodel.hpp\"\n      #include\"offlinemsgmodel.hpp\"\n      #include\"friendmodel.hpp\"\n      #include\"groupmodel.hpp\"\n      \n      using namespace std;\n      using namespace muduo;\n      using namespace muduo::net;\n      #include\"json.hpp\"\n      using json = nlohmann::json;\n      \n      #include<mutex>\n      \n      /* 表示处理消息的事件回调方法类型 */\n      using MsgHandler = std::function<void(const TcpConnectionPtr&, json&, Timestamp)>;\n      /**\n       * 聊天服务器业务类. \n       * 用映射关系来存储消息id和具体处理函数. \n       * 此类有一个实例就够了，所以采用单例模式. \n       */\n      class ChatService\n      {\n      public:\n          /* 获取单例对象的接口函数 */\n          static ChatService* instance();\n      public:\n          /* 处理登录业务 */\n          void login(const TcpConnectionPtr &conn, json &js, Timestamp time);\n          /* 处理注册业务 */\n          void reg(const TcpConnectionPtr &conn, json &js, Timestamp time);\n      \n          /* 添加好友业务 */\n          void addFriend(const TcpConnectionPtr &conn, json &js, Timestamp time);\n          /* 一对一聊天业务 */\n          void oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n      \n          /* 创建群组业务 */\n          void createGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n          /* 加入群组业务 */\n          void addGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n          /* 群组聊天业务 */\n          void groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n      public:\n          /* 获取消息对应的处理器 */\n          MsgHandler getHandler(int msgid);\n      public:\n          /* 处理客户端异常退出 */\n          void clientCloseException(const TcpConnectionPtr & conn);\n      public:\n          /* 业务重置方法，通常在服务器异常退出时调用 */\n          void reset();\n      #ifdef __CLUSTER__\n      public:\n          /* 从Redis消息队列中获取订阅的消息 */\n          void handleRedisSubscribeMessage(int channel, string message);\n      #endif\n      \n      private:\n          ChatService();\n      private:\n          UserModel       _userModel;         /* 数据操作类对象 */\n          OfflineMsgModel _offlineMsgModel;   /* 数据操作类对象 */\n          FriendModel     _friendModel;       /* 数据操作类对象 */\n          GroupModel      _groupModel;        /* 数据操作类对象 */\n      private:\n          /* 定义互斥锁，保证m_userConnectionMap的线程安全 */\n          mutex _connMutex;\n      private:\n          /* 存储消息id和其对应的业务处理方法 */\n          unordered_map<int, MsgHandler> _msgHandlerMap;\n          /* 存储在线用户的通信连接 */\n          unordered_map<int, TcpConnectionPtr> _userConnectionMap;\n      #ifdef __CLUSTER__\n      private:\n          /* redis操作对象 */\n          Redis m_redis;\n      #endif\n      };\n      #endif\n```\n\n```cpp\n      #include\"chatservice.hpp\"\n      #include\"public.hpp\"\n      #include<muduo/base/Logging.h>  // LOG_ERROR <<\n      \n      using namespace muduo;\n      \n      #include<vector>\n      using namespace std;\n      \n      ChatService* ChatService::instance()\n      {\n          static ChatService service;\n          return &service;\n      }\n      /**\n       * 注册消息以及对应的Handler回调操作\n       * 对unordered_map成员变量进行初始化\n       * 这是业务模块的核心，也是对项目进行解耦的核心\n       */\n      ChatService::ChatService()\n      {\n          /* 键：消息id - 值：函数对象 */\n          _msgHandlerMap.insert({LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});\n          _msgHandlerMap.insert({REG_MSG, std::bind(&ChatService::reg, this, _1, _2, _3)});\n          _msgHandlerMap.insert({ONE_CHAT_MSG, std::bind(&ChatService::oneChat, this, _1, _2, _3)});\n          _msgHandlerMap.insert({ADD_FRIEND_MSG, std::bind(&ChatService::addFriend, this, _1, _2, _3)});\n      #ifdef __CLUSTER__\n          if(m_redis.connect())\n          {\n              m_redis.init_notify_handler(std::bind(\n                  &ChatService::handleRedisSubscribeMessage, this, _1, _2));\n          }\n      #endif\n      }\n      /* 业务重置方法，通常在服务器异常退出时调用 */\n      void ChatService::reset()\n      {\n          /* 把所有online用户的状态置为offline */\n          _userModel.resetAllState();\n      }\n      /* 获取消息对应的处理器 */\n      MsgHandler ChatService::getHandler(int msgid)\n      {\n          /* 记录错误日志，msgid没有对应的事件处理回调时 */\n          auto it = _msgHandlerMap.find(msgid);\n          if(it == _msgHandlerMap.end())\n          {\n              /* 没有找到处理器时，返回一个默认的处理器，空操作。\n               * 如此设计的好处，即使没有找到程序也不会因此挂掉，进行空操作，继续运行。\n               * 因为需要获取函数参数msgid，所以[=]按值获取。\n               */\n              return [=](const TcpConnectionPtr&, json&, Timestamp)\n              {\n                  LOG_ERROR << \"msgid: \" << msgid << \" can't find handler\";\n              };\n          }\n          else\n          {\n              return _msgHandlerMap[msgid];\n          }\n      }\n      /* 处理登录业务 */\n      void ChatService::login(const TcpConnectionPtr &conn,\n                              json &js, Timestamp time)\n      {\n          /* 从json参数获取账号、密码信息 */\n          int id = js[\"id\"].get<int>();\n          string password = js[\"password\"];\n          User user = _userModel.query(id);\n      \n          json response;\n          response[\"msgid\"] = LOGIN_MSG_ACK;\n          if(user.getId() == id && user.getPassword() == password)\n          {\n              if(user.getState() == \"online\")\n              {\n                  /* 该用户已经登录在线，不允许重复登陆 */\n                  response[\"errno\"] = LOGIN_REPEAT;\n                  response[\"errmsg\"] = \"该用户已经登录\";\n              }\n              else if(user.getState() == \"offline\")\n              {\n                  /* 登陆成功 */\n                  {\n                      /* 记录用户连接信息 */\n                      lock_guard<mutex> lock(_connMutex);\n                      _userConnectionMap.insert({id, conn});\n                  }\n      #ifdef __CLUSTER__\n                  /**\n                   * 集群环境下, 向redis订阅此id \n                   */\n                  m_redis.subscribe(id);\n      #endif\n                  /* 更新用户状态信息 */\n                  user.setState(\"online\");\n                  _userModel.updateState(user);\n      \n                  response[\"errno\"] = LOGIN_SUCCEESS;\n                  response[\"id\"] = user.getId();\n                  response[\"name\"] = user.getName();\n                  /* 查询该用户是否在离线时未收到的消息 */\n                  vector<string> offlineMsgVec = _offlineMsgModel.query(id);\n                  if(!offlineMsgVec.empty())\n                  {\n                      response[\"offlinemsg\"] = offlineMsgVec;\n                      /* 把该用户的所有离线消息从从数据中删除掉 */\n                      _offlineMsgModel.remove(id);\n                  }\n                  /* 查询该用户的好友信息，并返回 */\n                  vector<User> userVec = _friendModel.query(id);\n                  if(!userVec.empty())\n                  {\n                      vector<string> friendJsonInfoVec;\n                      for(User &user : userVec)\n                      {\n                          json js;\n                          js[\"id\"] = user.getId();\n                          js[\"name\"] = user.getName();\n                          js[\"state\"] = user.getState();\n                          friendJsonInfoVec.push_back(js.dump());\n                      }\n                      response[\"friends\"] = friendJsonInfoVec;\n                  }\n              }\n          }\n          else if(user.getId() != id)\n          {\n              /* 登录失败，用户不存在 */\n              response[\"errno\"] = LOGIN_NOTFOUND;\n              response[\"errmsg\"] = \"用户不存在\";\n          }\n          else if(user.getPassword() != password)\n          {\n              /* 登录失败，密码不匹配 */\n              response[\"errno\"] = LOGIN_WRONGPWD;\n              response[\"errmsg\"] = \"密码验证失败\";\n          }\n          conn->send(response.dump());\n      }\n      /* 处理注册业务 */\n      void ChatService::reg(const TcpConnectionPtr &conn,\n                            json &js, Timestamp time)\n      {\n          /* LOG_INFO << \"do reg service.\"; */\n          string name = js[\"name\"];\n          string password = js[\"password\"];\n      \n          User user;\n          user.setName(name);\n          user.setPassword(password);\n          bool state = _userModel.insert(user);\n          json response;\n          response[\"msgid\"] = REG_MSG_ACK;\n          if(state)\n          {\n              /* 注册成功 */\n              response[\"errno\"] = 0;\n              response[\"id\"] = user.getId();\n          }\n          else\n          {\n              /* 注册失败 */\n              response[\"errno\"] = 1;\n          }\n          conn->send(response.dump());\n      }\n      /* 处理客户端异常退出 */\n      void ChatService::clientCloseException(const TcpConnectionPtr & conn)\n      {\n          /* 查找 */\n          lock_guard<mutex> lock(_connMutex);\n          User user;\n          for(auto it = _userConnectionMap.begin(); it != _userConnectionMap.end(); ++it)\n          {\n              if(it->second == conn)\n              {\n                  /* 从map表删除用户的连接信息 */\n                  user.setId(it->first);\n                  _userConnectionMap.erase(it);\n                  break;\n              }\n          }\n      #ifdef __CLUSTER__\n          /**\n           * 集群环境下, 向redis取消订阅此id\n           */\n          m_redis.unsubscribe(user.getId());\n      #endif\n          /* 更新用户的状态信息 */\n          if(user.getId() != -1)\n          {\n              user.setState(\"offline\");\n              _userModel.updateState(user);\n          }\n      }\n      /* 一对一聊天业务 */\n      void ChatService::oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time)\n      {\n          int to = js[\"to\"].get<int>();\n          {\n              lock_guard<mutex> lock(_connMutex);\n              auto it = _userConnectionMap.find(to);\n              if(it != _userConnectionMap.end())\n              {\n                  /* 接收方在线，转发消息 */\n                  /* 服务器主动推送消息给接收方 */\n                  it->second->send(js.dump());    // it->second 表示 \n                  return;\n              }\n          }\n      #ifdef __CLUSTER__\n          /**\n           * 集群环境下, 需要查询对方(to)是否在线;\n           * 不可通过服务器connMap查询, 是通过数据库信息;\n           */\n          User user = _userModel.query(to);\n          if(user.getState() == \"online\")\n          {\n              m_redis.publish(to, js.dump());\n              return;\n          }\n      #endif\n          /* 接收方离线，存储离线消息 */\n          _offlineMsgModel.insert(to, js.dump());\n      }\n      /* 添加好友业务 */\n      void ChatService::addFriend(const TcpConnectionPtr &conn, json &js, Timestamp time)\n      {\n          int userid = js[\"id\"].get<int>();\n          int friendid = js[\"friendid\"].get<int>();\n      \n          /* 存储好友信息 -> include\"friendmodel.hpp\" */\n          _friendModel.insert(userid, friendid);\n      }\n      \n      /* 创建群组业务 */\n      void ChatService::createGroup(const TcpConnectionPtr &conn, json &js, Timestamp time)\n      {\n          int userid = js[\"id\"].get<int>();\n          string groupName = js[\"groupname\"];\n          string groupDesc = js[\"groupdesc\"];\n      \n          /* 存储新创建的群组信息 */\n          Group group(-1, groupName, groupDesc);\n          if(_groupModel.createGroup(group))\n          {\n              /* 把创建人加入群组 */\n              _groupModel.addGroup(userid, group.getId(), \"Creator\");\n          }\n      }\n      /* 加入群组业务 */\n      void ChatService::addGroup(const TcpConnectionPtr &conn, json &js, Timestamp time)\n      {\n          int userid = js[\"id\"].get<int>();\n          int groupid = js[\"groupid\"].get<int>();\n          _groupModel.addGroup(userid, groupid, \"Normal\");\n      }\n      /* 群组聊天业务 */\n      void ChatService::groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time)\n      {\n          int userid = js[\"id\"].get<int>();\n          int groupid = js[\"groupid\"].get<int>();\n          vector<int> useridVec = _groupModel.queryGroupUsers(userid, groupid);\n      \n          bool offline = true;\n          bool reallyOffline = true;\n          for(int id : useridVec)\n          {\n              {\n                  lock_guard<mutex> lock(_connMutex);\n                  auto it = _userConnectionMap.find(id);\n                  if(it != _userConnectionMap.end())//在本台服务器上线\n                  {\n                      offline = false;\n                      reallyOffline = false;\n                      it->second->send(js.dump());\n                  }\n              }\n      #ifdef __CLUSTER__\n              if(offline)\n              {\n                  /**\n                   * 集群环境下, 需要判断其是否在其他服务器上在线;\n                   */\n                  User user = _userModel.query(id);\n                  if(user.getState() == \"online\")\n                  {\n                      reallyOffline = false;\n                      m_redis.publish(id, js.dump());\n                  }\n              }\n      #endif\n              if(reallyOffline)\n              {\n                  _offlineMsgModel.insert(id, js.dump());\n              }\n              reallyOffline = true;\n              offline = true;\n          }\n      }\n      #ifdef __CLUSTER__\n      /**\n       * 场景: 本台服务器收到了redis某一频道发来的通知消息;\n       *  在前面的代码逻辑中, redis的publish都是判断用户在线之后才发的;\n       *   但是用户可能在这个判断和真正收到消息这段时间内下线,\n       *  所以, 本服务器处理收到redis某一频道上消息的回调时,\n       *   需要再次判断此id是否在线, 如果在线则发送, \n       *   如果不在线, 需要存到离线消息数据库中; \n       */\n      void ChatService::handleRedisSubscribeMessage(int userid, string msg)\n      {\n          lock_guard<mutex> lock(_connMutex);\n          auto it = _userConnectionMap.find(userid);\n          /* 该用户在线, 则直接发送 */\n          if(it != _userConnectionMap.end())\n          {\n              it->second->send(msg);\n              return;\n          }\n          /* 存储该用户的离线消息 */\n          _offlineMsgModel.insert(userid, msg);\n      }\n      #endif\n```\n\n# 问题\n\n1. 如果聊天内容带有`'`单引号，则会影响SQL语句的正确输入，需要处理转义。\n\n","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"Linux_Ubuntu配置","url":"/Linux/Linux_Ubuntu配置/","content":"\n# 内容\n\n1. 关闭Ubuntu动画\n\n2. 配置终端代理\n\n3. 下载安装make、g++-12/gcc-12、git、net-tools、curl\n\n   1. g++和gcc有什么关系？d41d8c的回答 - 知乎 https://www.zhihu.com/question/20940822/answer/1768772877\n\n   2. 将g++默认为g++-12(参考https://cloud.tencent.com/developer/ask/sof/100275)\n\n      ```\n      sudo apt-get install g++-12\n      sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-12 100\n      sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 100\n      \n      sudo update-alternatives --set g++ /usr/bin/g++-12\n      sudo update-alternatives --set gcc /usr/bin/gcc-12\n      ```\n\n   3. 命令格式：`update-alternatives [<选项> ...] <命令>`(参考https://blog.csdn.net/JasonDing1354/article/details/50470109)\n\n      ```\n      Commands:\n        --install <link> <name> <path> <priority>\n          [--slave <link> <name> <path>] ...\n                                 在系统中加入一组替换项.\n        --remove <name> <path>   从 <名称> 替换组中去除 <路径> 项.\n        --remove-all <name>      从替换系统中删除 <名称> 替换组.\n        --auto <name>            将 <名称> 的主链接切换到自动模式.\n        --display <name>         显示关于 <名称> 替换组的信息.\n        --query <name>           machine parseable version of --display <name>.\n        --list <name>            列出 <名称> 替换组中所有的可用替换项.\n        --get-selections         list master alternative names and their status.\n        --set-selections         read alternative status from standard input.\n        --config <name>          列出 <名称> 替换组中的可选项，并就使用其中\n                                       哪一个，征询用户的意见.\n        --set <name> <path>      将 <路径> 设置为 <名称> 的替换项.\n        --all                    对所有可选项一一调用 --config 命令.\n      <link> 是指向 /etc/alternatives/<名称> 的符号链接>.\n        (e.g. /usr/bin/pager)\n      <name> 是该链接替换组的主控名.\n        (e.g. pager)\n      <path> 是替换项目标文件的位置.\n        (e.g. /usr/bin/less)\n      <priority> 是一个整数，在自动模式下，这个数字越高的选项，其优先级也就越高.\n      Options:\n        --altdir <directory>     指定不同的可选项目录.\n        --admindir <directory>   指定不同的管理目录.\n        --log <file>             设置log文件.\n        --force                  allow replacing files with alternative links.\n        --skip-auto              skip prompt for alternatives correctly configured\n                                 in automatic mode (relevant for --config only)\n        --verbose                详尽的操作进行信息，更多的输出.\n        --quiet                  安静模式，输出尽可能少的信息.\n        --help                   显示本帮助信息.\n        --version                显示版本信息.\n      ```\n\n4. 下载安装vim\n\n   1. ```\n      git clone https://github.com/vim/vim.git\n      # if you don't have local changes, update to the latest version with:\n      cd vim\n      git pull\n      # If you made some changes, e.g. to a makefile, you can keep them and merge with the latest version with:\n      cd vim\n      git stash\n      git pull\n      git stash pop\n      # If you have local changes you may need to merge. If you are sure you can discard local changes (e.g. if you were just trying a patch), you can use:\n      git fetch --all\n      git reset --hard origin/master\n      ```\n\n   2. ```\n      # Building Vim\n      cd src\n      make distclean  # if you build Vim before\n      make\n      sudo make install\n      ```\n\n   3. ```\n      checking for tgetent()... configure: error: NOT FOUND!\n            You need to install a terminal library; for example ncurses.\n            On Linux that would be the libncurses-dev package.\n            Or specify the name of the library with --with-tlib.\n      # sudo apt-get install libncurses5-dev\n      ```\n\n5. 配置镜像源 - huaweicloud, http协议\n\n6. 更新系统软件\n\n7. 安装ssh-server `sudo apt-get install openssh-server`\n\n# 关闭Ubuntu动画\n\nUbuntu Desktop应用程序菜单带有从屏幕底角到屏幕中心的动画。虽然这看起来很酷，但感觉它很卡，尤其是在集成显卡和虚拟机的环境中。有一种方法可以关闭此动画，从而可以更快地从“应用程序”菜单中启动应用程序。\n\n1. 打开“终端”\n2. 执行以下命令，关闭动画，立即生效（不用root）\n\n```\ngsettings set org.gnome.desktop.interface enable-animations false\n```\n\n想要重新开启动画，只需要执行\n\n```\ngsettings set org.gnome.desktop.interface enable-animations true\n```\n","categories":["操作系统","Linux"]},{"title":"词汇总结","url":"/英语/词汇总结/","content":"# reverse - reserve - conserve - converse - convert - revert - transverse - invert - converge\n\n在拉丁语中，`vers-`表示-弯曲、转向；`-ile`表示-有...的倾向\n\n1. reverse: v. 反转 adj. 反向的；相反的\n    1. revert: 恢复原状；归还\n        1. reversion: n. 恢复\n    2. rehabilitate: `/ˌriːəˈbɪlɪteɪt/` vt. 平反昭雪；使康复；恢复原状\n    3. transverse: adj. 横向的；横切的\n2. reserve: 预订\n    1. reservation: 保留的座位、住处等；预订；保留意见\n3. converse: adj. 相反的；v. 交谈，谈话\n    1. conversation: 谈话\n    2. conversion: 变换；转化\n5. **converge: `/kənˈvɜːdʒ/` vi. 汇合；趋同**\n6. convert: v. （使）转变 - conversion: n. 转化；转换；换算\n    1. invert: v. 使...颠倒；倒置...\n7. conserve: 保护\n    1. conservation: 保存；保护\n\nvert、verse都有转向、转化的意思。verge是趋向、接近的意思。\n## divert - diverse - versatile - deflect - inflect - deviate - distort - bias\n\n```\nvers-, vert-, -verse, -version, -version, -versation, -versal, -versary, -vert, vort-, vors-【拉丁】表示“转动，旋转”；“使弯曲”\n同根词advertisement|irreversible|universal|verse|incontrovertible|conversation|conversely|versatile|\n```\n\n1. diverse: 不同的；多种多样的\n2. divert: 使转向；使分心、转移注意力；供...消遣\n3. diversion - n. 转向、转移；偏离、绕行路线；消遣、娱乐。\n4. versatile: adj. 多才多艺的；多方面的；多用途的\n5. deflect: v. (使)转向；(使)偏斜 - deflection: n. 突然转向；偏斜；偏离\n6. inflect: v. 弯曲；改变 - inflection: n. 变音；转调\n7. reflect: vt. 反射；照出；**反省** vi. 反映；映现；深思 - reflection: n. 映像，反映；反射；深思\n\t1. reflective: adj. 沉思的，与思考有关的；**有反射性的**\n\t2. flexible: adj. 可弯曲的\n8. **deviate: `/ˈdiːvieɪt/` v. 偏离，脱离**\n    1. deviation: `/ˌdiːviˈeɪʃn/` n. 偏离；偏差；背离；违背\n9. distort: v. 使变形；扭曲，歪曲；曲解\n    1. distortion: n. 扭曲；变形；曲解；失真\n    2. retort: v. 反驳，回嘴 n. 反驳；曲颈瓶（比如蒸馏器）\n        1. resort: n. 旅游胜地；采取、措施、手段（诉诸；向...求助）\n            1. assort: v. 把…分类\n                1. assortment: n. 各种各样\n        2. refute: `/rɪˈfjuːt/` v. 证伪；否认、反驳\n10. bias: n. 偏向 v. 使偏向 adv. 偏 adj. 斜的, 【电】偏动的\n## 倾向\n\n1. prone: `/prəʊn/` adj. 易于遭受...的；有做...（坏事）的倾向\n2. disposed: adj. 有…倾向的；打算做…的；有某种健康状态的 v. 处理；配置；使有倾向；使适应（dispose的过去分词）\n3. incline: v. 倾向\n    1. decline: v. 下降\n4. mindset: `/ˈmaɪndset/` n. 思维倾向；观念模式\n# re-: -cede\n\n1. retreat: v./n. 撤退、后退；让步 n. 隐居地；静养所\n    1. entreat: v. 恳求；乞求\n2. rescind: `/rɪ'sɪnd/` v. 撤销、废除；取消\n    1. prescind: `/prɪˈsɪnd/` vi. (过早或突然地从整体中)分割；不考虑某事\n    2. abscind: `/æb'sɪnd/` v. 切断、割断\n    3. exscind: `/ek'sɪnd/` vt. 割开,切除\n3. recede: `/rɪ'siːd/` vi. 后退，减弱\n    1. cede: vt. 屈服；让给，割让；放弃\n    2. precede: v. 领先，在…之前；优于，高于\n    3. concede: v. 承认；出让；容许\n       The arrogant runner conceded defeat reluctantly. 这位傲慢的跑步运动员很不情愿地承认了失败。\n    4. accede: vi. 答应, 同意；(正式)加入，参加；开始任职，就职，就任；就位，即位，继任；(通过财产的添附而)增加；继承(财产)\n    5. secede: v. 退出；脱离；割让\n## 消遣 - treat - recreation - diversion - amusement\n\n1. recreation: n. 消遣、娱乐；重现、重建\n2. entertainment\n3. treatment\n    1. entreat: v. 恳求；乞求\n    2. retreat: v. & n. 撤退、后退；让步 n. 隐居地；静养所\n    3. **treaty: n. （国家间的）条约、协定**\n4. relaxation\n5. diversion: `/daɪˈvɜːʃn/` n. 偏离；消遣、娱乐\n   The city is full of diversions. 城市里各种娱乐活动比比皆是。\n6. amusement\n# dis-\n\n1. dismay: n. 沮丧，绝望，灰心 v. 使惊愕；使灰心，使失望\n    1. frustrate: v.（尤指因无法改变或实现某事而）使心烦；使恼怒\n        1. The frustrating thing about innovation is that there are many approaches, but no magic formula. 关于创新令人沮丧的是，创新有很多方法，却没有那种奇妙的程式方案。\n2. distress: n. （极度）痛苦、悲伤 v. 使忧虑、悲伤\n3. disdain: v. 蔑视\n    1. scorn: 蔑视\n        1. scold: v. 骂；责备、数落 n. 吵吵嚷嚷\n4. discard: v. 丢弃；抛弃；遗弃\n## discourse - discourage - recourse\n\n1. discourse: n. 对话；话语；演讲；论文 v. 讲述；论述\n2. discourage: v. 使气馁；使沮丧\n3. recourse: n. 求助；依靠；依赖\n## 派送、派遣、发；分配\n\n1. dispatch: n. v. 派遣；发送；派送；急件\n    1. dispatcher: 车辆、航班调度员\n2. distribute: 分发；分散\n    1. scatter: 分散\n    2. contribute: 贡献\n3. disperse: v. （使）分散、散开；疏散、驱散\n4. allot: v. 分配；分派（任务）\n    1. allotment: n. 配额\n    2. alloy: `/ˈælɔɪ/` n. 合金 v. 把...铸成合金\n        1. unalloyed: `/ˌʌnəˈlɔɪd/` adj. 纯粹的\n## -stinc-；本能的、直觉的、自发的\n\n1. instinct: **n.** 本能、直觉\n    1. instinctive: adj. 本能的、直觉的\n    2. **spontaneous**: `/spɒn'teɪniəs/` adj. **自发的，自然产生的**\n    3. intuitive: adj. 直觉的；不假思索的\n        1. intuition: n. 直觉力\n2. integral: `/ˈɪntɪɡrəl，ɪnˈteɡrəl/` adj. 必需的；不可或缺的\n    1. integrate: `/ˈɪntɪɡreɪt/` v. 整合、使成为一体 - integrated circuit: 集成电路\n    2. integrity: `/ɪnˈteɡrəti/` n. 正直；完整性\n3. distinct: adj. 清晰的、明显的；截然不同的\n    1. distinction: n. 区别、区分；杰出、卓越\n    2. distinguish: v. 区别；使杰出\n4. extinct: adj. 灭绝的\n    1. extinction: n. 灭绝\n5. intrinsic: `/ɪnˈtrɪnzɪk/` adj. 本身固有的；内在的、本质的\n6. qualitative: `/ˈkwɒlɪtətɪv/` adj. 定性的；性质的\n## 蔑视 - 歧视 - disdain - discriminate - underestimate - prejudice\n\n1. 歧视：discriminate\n    1. prejudice: n. 偏见、成见；歧视 v. 使...怀有偏见\n2. 蔑视：disdain: `/dɪsˈdeɪn/` v./n. 蔑视、鄙视\n    1. disdainful: `/dɪsˈdeɪnfl/` adj. 轻视的；鄙视的；倨傲的\n    2. 同义词：contempt: `/kənˈtempt/` n. 轻蔑\n        1. contemplate: `/ˈkɒntəmpleɪt/` v. 考虑\n    3. despise: `/dɪˈspaɪz/` v. 鄙视、蔑视、看不起\n        1. despite: `/dɪˈspaɪt/` prep. 不顾；即使、尽管\n            1. spite: `/spaɪt/` n. 恶意；怨恨 = malice\n                1. in spite of: 尽管；不管、不顾\n    4. scorn\n    5. underestimate: `/ˌʌndərˈestɪmeɪt/` v./n. 低估、轻视\n    6. defiance: `/dɪˈfaɪəns/` n. 违抗、拒绝服从；无视、藐视\n        1. defiant: adj. 违抗的；挑衅的\n## illusion - disillusion\n\n1. illusion: `/ɪˈluːʒn/` n. 错觉, 幻想, 错误观念\n    1. delusion: `/dɪˈluːʒn/` n. 错觉；妄想\n2. disillusion: `/ˌdɪsɪˈluːʒn/` v. 使醒悟，使觉醒；使幻想破灭\n## difference - discrepancy\n\n1. discrepancy: `/dɪˈskrepənsi/` n. 差异；不符合；不一致\n# 杰出；例外\n\n1. exception: adj. 异常；特别；例外\n    1. exceptional: adj. 杰出的；优秀的；异常的；特别的；例外的\n2. distinction: n. 区别，差别；卓越，杰出\n3. extraordinary: adj. 不平凡的；特派的；临时的\n\t1. extravagant: adj. 奢侈的；铺张浪费的\n4. exterior: adj. 外部的 n. 外观、外表\n# 僵硬的；顽固的 - 习惯\n\n1. rigid: adj. 严格的；僵硬的，死板的；坚硬的；精确的\n2. solid - 固体的、实心的；结实的、可靠的；\n3. conventional - 传统的；习惯的；守旧的（某种程度也可以引申为顽固派的）；\n    1. convention: n. 公约、约定、习俗\n4. customary: adj. 习俗的，习惯的；特有的，独特的\n5. tough - 坚韧的、牢固的；艰难的；强硬的（可引申为n. 恶棍、暴徒）；\n    1. rough - 粗糙的；艰难的、令人痛苦的 - roughly - 大致地；粗暴地\n    2. thorough: adj. 彻底的，完全的；仔细的；缜密的\n    3. throughout: `/θruː'aʊt/` prep. 遍及，贯穿 adv. 到处，自始至终\n6. stiff: adj. 不易弯曲的；硬的；挺直的；僵硬的 adv. 非常；极其 v. 不给小费\n    1. cliff: n. （常指海洋边的）悬崖\n7. accustom: v. 使习惯 - accustomed: adj. 习惯于；通常的；惯常的\n8. obstinate: adj. 执拗的；顽固的；棘手的；难以应付的\n    1. Middle English: from Latin `obstinatus`, past participle(过去分词) of `obstinare ‘persist’`.\n# 彻底的\n\n1. thorough: adj. 彻底的，完全的；仔细的；缜密的\n    1. throughout: `/θruː'aʊt/` prep. 遍及，贯穿 adv. 到处，自始至终\n2. radical: `/ˈrædɪkl/` adj. 根本的；彻底的，完全的；激进的\n    1. late Middle English (in the senses ‘forming the root’ and ‘inherent’): from late Latin `radicalis`, from Latin `radix(基数；根), radic- ‘root’`.\n# 移动\n\n1. motion - n. 运动；移动 v. 运动；向...打手势\n2. movement - n. 移动；活动；迁移；乐章 - 可数，例 hand/eye movements手/眼睛的活动\n3. motive: n. 动机；缘由；目的\n# 可到达的\n\n1. navigable - 用来形容航线、路线是通行的。而不是说某一个地点是可到达的。\n    1. negotiate: 谈判；磋商\n2. accessible - 可访问的；无障碍的\n# 副的、附的、补充的、附属\n\n1. auxiliary: adj. 辅助的；备用的 n. 助动词；辅助工；辅助人员\n2. affiliate: `/əˈfɪlieɪt/` v. 使并入、隶属于较大的组织 n. 附属机构\n    1. affiliation: `/əˌfɪliˈeɪʃn/` n. 隶属关系、从属关系\n        1. political affiliation: 政治背景、立场，政治面貌\n3. affixation: ` /ˌæfɪk'seɪʃən/` n. 加缀、附加；词缀法\n    1. affix: `/ˈæfɪks/` vt. 附加上 vi. 固定在 n. 词缀\n4. accessory: 附加的；附件\n5. annex: `/ˈæneks/` v. 强占、吞并 n. 附加、附属\n6. vice - 副的；代替的\n7. deputy: n. 副手；副职；代理人\n8. assistant - 协助的；助手\n    1. collaborate: v. 合作；协作；勾结、通敌 - collaboration n. 合作；协作；通敌行为\n    2. assassin: `/əˈsæsɪn/` n. 暗杀者\n        1. assassination: `/əˌsæsɪˈneɪʃn/` n. 暗杀、行刺\n        2. assault: `/əˈsɔːlt/` n./v. 侵犯身体；袭击\n9. associate: 副的；联合的\n10. complementary: `/ˌkɒmplɪˈmentri/` adj. 互补的\n    1. complimentary: `/ˌkɒmplɪˈmentri/` adj. 免费的、赠送的；赞扬的、钦佩的:\n        1. compliment: `/ˈkɒmplɪmənt/` n. 问候、致意；赞扬\n11. supplementary - 补充的\n12. compatible: adj. 可兼容的；可共存的；关系好的\n    1. compact: `/kəmˈpækt/, /ˈkɒmpækt/` adj. 紧凑的、紧实的 n. 协议 v. 压紧、压实\n13. addition\n14. accompany: v. 陪伴，伴随；给……伴奏 adj. 和…一起发生的；附随的 - accompaniment: n. 伴随物, （音乐）伴奏, 佐餐物, 伴随发生的事情\n    1. accomplish: v. 完成、实现\n# -cess\n\n```\n-cede, -ceed, -cess, -cease【拉丁】移动；走，走开；放弃\n同根词incessant|access|exceed|exceedingly|excess|excessive|necessary|predecessor|\n```\n\n1. exceed: `/ɪkˈsiːd/` v. 在数量或大小上超过\n    1. excess: n. `/ɪkˈses/` 过量 adj. `/ˈekses/` 过量的\n        1. abundant: `/əˈbʌndənt/` adj. 大量的\n            1. abandon: `/əˈbændən/` 遗弃\n            2. redundant: `/rɪˈdʌndənt/` adj. 被裁减的；多余的\n                1. redundancy: n. 裁员、解雇；冗余\n2. accessory: adj. 附加的；辅助的 n. 附件、配件；同谋、帮凶\n    1. access: 访问；达到\n        1. accessible: 可访问的；无障碍的\n    2. fitting: n. 可拆除装置、附件 adj. 合身的\n3. predecessor: n. 前辈；前任；原先的事物\n# exert - excel - exile\n\n1. exert: v. 用(力)、运用；发挥\n    1. exertion: n. 费力；努力\n       The old man was out of breath from the exertion of climbing stairs. 这名老人费力爬楼梯后，累得上气不接下气。\n2. excel: `/ɪkˈsel/` v. 卓越；优于，胜过；擅长\n    1. exceed\n    2. transcend: `/trænˈsend/` vt. 超出\n3. exile: `/ˈeksaɪl/` n./v. 流放、流亡；放逐\n# 上升；提高；增长；扩大\n\n1. arise\n2. rise\n3. increasingly\n4. flourish - 繁荣、兴旺；迅速发展\n    1. nourish: v. 抚养，滋养；培养，助长\n    2. flour: n. 面粉\n5. sprawl: 蔓延；随意扩展，无组织无计划扩张\n   Perhaps matching the trend among the public, green leaders are increasingly advocating cooperation between hunters and environmental groups: After all, both deplore urban sprawl and habitat destruction. 或许是为了迎合公众的趋势，环保领袖正不断倡导猎人和环保组织之间的合作：毕竟，两者都在谴责城市的扩张和栖息地的破坏。\n6. thrive: v. 繁荣；兴旺\n7. enhance: v. 提高；增强；增进 - enhancement: n. 增强；改善；增加；增进\n8. exalt: vt. 提升；提拔；赞扬；使得意\n9. promote: vt. 提升；提拔；促进\n10. prolong: v. 延长\n11. foster: vt. 养育，抚育；培养；抱（希望等） adj. 收养的，养育的\n12. boom: n. 繁荣, 吊杆, （某种体育运动、音乐等）突然风靡的时期, 帆桁 v. 激增, 繁荣昌盛, 轰鸣, 轰响 adj. 〈美〉猛涨起来的\n13. ascend: v. 上升；攀登\n14. accrue: v. (逐渐)增长；积累\n15. soar: v. 猛增\n    1. surge: v./n. 急剧猛增；奔放\n16. swell: v./n 扩大、鼓出；肿胀\n    1. sw**o**llen: adj. 肿胀的\n17. mount: v. 登上（山）；增加、上升、增长；发起、组织开展\n18. escalate: `/ˈeskəleɪt/` v. 逐步扩大（影响不好地、恶化地）（注意是扩大，不是下降）\n    The house prices in China have escalated sharply. 中国房价飙升。\n## prompt - promote\n\n1. prompt: v. 促进 adj. 迅速的 n. 计算机屏幕上的提示符、演员的提词提白\n    1. promptly: 迅速地；立刻\n    2. impromptu: `/ɪmˈprɒmptjuː/` adv./adj. 即兴的（地）；无准备的（地）\n    3. impetus: `/ˈɪmpɪtəs/` n. 推动、促进、刺激\n    4. stimulate: `/ˈstɪmjuleɪt/` v. 刺激；激发；促进\n        1. stimulus: `/ˈstɪmjələs/` n. 刺激物；促进因素\n2. promote vt. 提升，提拔；促进\n    1. promotion: n. 晋升；提拔\n    2. exalt: vt. 提升；提拔；赞扬；使得意\n# -ump: lump - bump - pump - hump - stump\n\n1. bump: n. 碰撞；隆起、肿块 v. 碰撞；颠簸而行\n2. pump: n./v. 泵\n3. lump: n. 块状；肿块 vt. 使成块状；使...归并、混在一起\n    1. slump: v./n. 骤降、猛跌\n    2. stump: n. 树桩；残余部分、残根\n4. hump: n. （平面上的）大隆起物；驼背（好友记第1集）\n5. ridge: `/rɪdʒ/` n. 山脊、山脉；隆起\n# 下降；缩短；恶化\n\n1. recede: `/rɪ'siːd/` vi. 后退，减弱\n2. abridge: v. 删节，节略（书籍、剧本等）\n3. aggravate: `/ˈæɡrəveɪt/` v. 使严重、恶化\n    1. aggregate: `/ˈæɡrɪɡət/` v./n. 总计\n    2. exaggerate: `/ɪɡˈzædʒəreɪt/` v. 夸大事实、夸张\n        1. extravagant: `/ɪkˈstrævəɡənt/` adj. 浪费的\n        2. congregate: v. 集合\n        3. segregate: v. 隔离并区别对待\n4. escalate: `/ˈeskəleɪt/` v. 逐步扩大（影响不好地、恶化地）（注意是上升，不是下降）\n    The house prices in China have escalated sharply. 中国房价飙升。\n5. **adverse: `/ədˈvɜːrs/, /ˈædvɜːrs/` adj. 坏的、不利的、有害的；反面的**\n6. slump: v./n. 骤降、猛跌\n7. tumble: n./v. 暴跌\n    1. humble: adj. 谦逊的；卑微的 v. 贬低；使感到卑微\n8. plunge: v. 暴跌，骤降 n. 骤降\n9. reduction: n. 削减；降低\n## de-\n\n1. decline: v. 下降\n    1. incline: v. 倾向\n2. descend: v. 下降\n    1. descent: n. 下降；血统、家世\n    2. ascend: `/əˈsend/` vi. 上升；攀登\n        1. ascent: n. 下降\n3. deteriorate: `/dɪˈtɪəriəreɪt/` vi. 恶化\n    1. deter: v. 阻止、制止\n       拉丁前缀`deterior-`：变得更坏\n        1. defer: `/dɪˈfɜː(r)/` vt. 推迟、延期\n        2. detergent: `/dɪˈtɜːdʒənt/` n. 洗涤剂、洗涤粉\n    2. detrimental: adj. 不利的\n    3. **wholesome: 有益健康的**\n    4. impair: v. 损害；削弱\n    5. toxic: `/ˈtɒksɪk/` adj. 有毒的、有害的\n1. deprive: v. 剥夺；失去\n    1. 常与of搭配：Young people are being deprived of the thing they need most, perspective. 年轻人被剥夺了他们最需要的东西，客观判断力。\n## di-: dilute - diminish - diligence\n\n1. dilute: `/daɪˈluːt/` v. 稀释 adj. 稀释的, 淡的\n    1. dilution: `/daɪˈluːʃn/` n. 稀释；削弱\n2. diminish: v. 减少、减弱、降低；贬低、贬损；轻视\n    1. 拉丁：di-: 否定；分离；完全；min-: 变小、变少\n       古英语：-ish: 动词后缀\n    2. minish: v. 使减少；使缩小\n3. diligence: n. 勤奋；勤勉；用功 - diligent: adj. 孜孜不倦的；勤勉的；刻苦的\n4. disposal: n. 处理干净；清除\n# dispose - disposition - impose - imposition - expose - exposition\n\n1. dispose: v. 处理、处置、安排；使倾向于、使有意于、使易于\n    1. disposition: n. （性格）倾向；安排、布置\n    2. disposal: n. 处理干净；清除\n2. impose: `/ɪmˈpəʊz/` v. 强制推行、实行；迫使、把…强加于\n    1. imposition: `/ˌɪmpəˈzɪʃn/` n. （规则的）实施；征收；（强迫）的要求\n    2. compulsory: `/kəmˈpʌlsəri/` adj. 必须做的；强制的、强迫的；义务的\n3. expose: `/ɪkˈspəʊz/` v. 暴露、显露；揭露；面临、遭受\n    1. exposition: `/ˌekspəˈzɪʃn/` n. 解释、说明、阐述\n# -dge; -orge\n\n1. budget: n. 预算\n2. badge: n. 象征；标记\n    1. barge: v. 冲撞、乱闯\n3. lodge: `/lɒdʒ/`v. （向机构）正式提出（声明）；借宿，租住；为...提供住宿；寄存，存放，使固定、嵌入 n. 传达室、管理员室；门房, 旅馆；乡间小屋\n4. dodge: `/dɒdʒ/` v. 躲避 n. 推脱的诡计\n5. forge: `/fɔːdʒ/` v. 锻造；伪造、假冒 n. 锻造炉、锻造工厂\n6. cartridge: n. 弹盒；墨盒\n    1. carton: `/ˈkɑːtn/` n. 硬纸盒\n    2. cartoon: `/kɑːˈtuːn/` n. 漫画\n7. pledge:`/pledʒ/` n./v. 保证、承诺\n## abridge - ridge - bribe - bride - bridle - abide\n\n1. abridge: `/əˈbrɪdʒ/` v. 删节，节略（书籍、剧本等）\n    1. ridge: `/rɪdʒ/` n. 山脊、山脉；隆起\n2. bribe: `/braɪb/` v./n. 贿赂\n3. bride: `/braɪd/` n. 新娘\n    1. bridegroom: 新郎\n4. bridle: `/ˈbraɪdl/` n. 马勒；系带；约束物；缰绳 vt. 控制；给装马勒\n5. abide: `/əˈbaɪd/` v. 容忍、忍受；居住\n# 政治文化\n\n## 王国、军事文化\n\n1. realm: 王国；领域、范围\n   由reg-词根开头，拉丁语中表示“统治、管理”\n    1. reign: v. 君主统治 - rein: 统治、支配 - reinforce: 加固；加强\n    2. regiment: n. （军队的）团；一大群人（或事物）\n1. troop: n. 军队、部队；一群、一队 v. 成群结队而行；列队行进\n2. **extent: n. 程度；范围**\n3. empire: `/ˈempaɪə(r)/` n. 帝国\n    1. emperor: `/ˈempərə(r)/` n. 皇帝\n    2. empirical: `/ɪmˈpɪrɪkl/` adj. 经验主义的\n    3. imperial: `/ɪmˈpɪəriəl/` adj. 皇帝的；帝国的\n        1. imperative: n. 紧要的事情；**祈使语气** adj. 紧要的\n4. crown: `/kraʊn/` n. 皇冠、王冠 v. 加冕\n5. territory: `英/ˈterətri/ 美/ˈterətɔːri/` n. 领土，领地；（知识）领域，范围\n6. royal: 王室的\n    1. loyal: 忠诚的\n    2. moral: n. 寓意；道德 adj. 道德上的；有道德的\n7. majesty: `/'mædʒəsti/` n. 威严、庄严\n   The queen was seated on the throne in all her majesty. 女王威严地坐在王座上。\n    1. throne: `/θrəʊn/` n. 宝座；王位\n8. palace: n. 宫殿, 王宫, 总统府, 住在王宫里的人\n9. dictatorship: 独裁、专政\n    1. dictate: v. 口授、口述；发号施令；支配；使听写\n10. earl: n. 伯爵\n11. lieutenant: 陆军中尉；海军、空军上尉；副职官员\n   英`/lefˈtenənt/` 美`/luːˈtenənt/`\n    1. tenant: n. 承租人；房客；居住者\n9. sergeant: `/ˈsɑːdʒənt/` n. 士兵；中士\n    1. corporal: `/ˈkɔːpərəl/` n. 下士 adj. 肉体的 - corporal punishment: 体罚\n10. marshal: v. 控制人群（动员）、集结 n. 空军元帅；司仪；典礼官\n    1. convene: `/kənˈviːn/` v. 召集；召唤；聚集；集合\n        1. congregate: v. 集合\n        2. summon: v. 传唤某人出席；召集\n        3. recruit: `/rɪˈkruːt/` v. 招收；动员 n. 新成员\n    2. martial adj. 军事的；威武的\n    3. marsh: n. 沼泽、湿地\n11. infantry: n. （统称）步兵\n    1. cavalry 骑兵 artillery 炮兵 archer 弓兵\n12. navy: `/'neɪvi/` n. 海军, 海军部队\n13. warship: n. 舰艇；军舰\n    1. worship: n. 崇拜, 爱慕, 做礼拜 vi. 做礼拜 vt. 崇拜, 爱慕\n14. sway: v. 摇动；使动摇；说服、使相信 n. 影响；动摇；统治\n15. veteran: `/'vetərən/` n. 老手 adj. (尤指军事方面)老练的\n16. scout: n. 侦察员；侦察机 v. 侦察，搜寻；物色\n17. escort: `/ˈeskɔːt/` n. 陪同；护送者；护航舰；护卫队 vt. 护送；陪同\n18. skirmish: n. 小冲突\n19. faction: n. 派系，小集团；内讧\n20. militia: n. 民兵\n    1. militancy: n. 战斗状态；好战倾向\n21. patriot: `英/ˈpætriət/ 美/ˈpeɪtriət/` n. 爱国者\n    1. patriotism: n. 爱国主义；爱国精神\n22. sovereign: `/ˈsɒvrɪn/` n. 君主、元首\n    1. sovereignty: `/ˈsɒvrənti/` n. 最高统治权\n23. ammunition: `/ˌæmjəˈnɪʃn/` n. 弹药、军火\n24. fort: `/fɔːt/` n. 要塞；堡垒\n    1. fortify: `/ˈfɔːtɪfaɪ/` vt. 加强（建筑防御）\n        1. fortification: n. 碉堡、围墙；防御工事\n## 民主、选举文化\n\n1. vote\n2. elect: v. 选举、选择 adj. 被选出的；候任的\n    1. electoral: `/ɪˈlektərəl/` adj. 有关选举的\n3. candidate: `/ˈkændɪdeɪt/` n. 候选人\n4. nominee: 提名人\n5. applicant: 参与人\n6. constituent: `kən'stitjuənt`  n. 成分；选民；委托人 adj. 构成的；选举的\n7. parliament: `/ˈpɑːləmənt/` n. 议会；国会 - 英国议会需大写（包括下议院和上议院）\n8. committee: n. 委员会\n    1. commitment: n. 承诺、保证；约束、义务\n    2. delegation: n. 代表团\n        1. delegate: v. 选派、委派；授权\n9. franchise - n./v. 授权（经销权）；选举权 - enfranchise: 给...选举权；解放（奴隶）\n10. emancipation: n. 解放（运动）\n    The political emancipation of women gave females freedom and rights. 妇女的政治解放给予了女性自由和权利。\n11. lobby: v. （就某一问题向立法者）游说 - lobbyist: n. 说客，议案通过者\n    And the water is muddied by lobbying from the industries that profit from consumption of obesity-inducing products. 同时，那些从致肥胖产品的消费中获益的产业，通过游说把这趟水搅浑了。\n12. abolition: n. 废止\n    The reforms finally led to the abolition of the monarchy. 这些改革最终废除了君主制。\n13. tenure: `/ˈtenjə(r)/` n. 任期\n14. senator: `/ˈsenətə(r)/` n. 参议员\n15. cabinet: n. 内阁；橱、柜 - cabinet minister: 内阁大臣\n16. parade: `/pəˈreɪd/` n./v. （炫耀地）游行\n    1. paradigm: n. 模型、模范、榜样\n### nominate - dominate - prominent - eminent\n\n1. nominate: vt. 提名；任命；指定；推荐\n2. dominate: vt. 支配；控制；占优势；在…中占主要地位 vi. 处于支配地位；占优势\n    1. dominance: n. 优势;支配地位;控制力 = dominancy: n. 优势,统治\n          1. 在生物学中，是显性的意思。\n    2. predominance: n. 卓越；优势；控制\n3. **prominent: adj. 突出的、显著的**\n4. eminent: `/ˈemɪnənt/` adj. 著名的、显赫的；非凡的、杰出的\n    1. eminence: n. 著名、显赫\n### designate - designation - signify\n\n1. designate: v. 指定；选派；标明；指明\n2. designation: `/dezɪg'neɪʃ(ə)n/` n. 名称；指定；称号；选定\n3. resign: 辞职\n4. signify: v. 指明、指示\n## 官职\n\n1. minister: n. 部长；大臣；外交使节\n2. hierarchy: `/ˈhaɪərɑːki/` n. 层次体系；等级制度\n    1. hierarchical: `/ˌhaɪəˈrɑːkɪkl/` adj. 按等级划分的\n3. magistrate: `/ˈmædʒɪstreɪt/` n. 基层执法官\n# 宗教文化\n\n1. pilgrim: n. 朝圣者 (a person who travels to a holy place for religious reasons)\n    1. The pilgrims put their palms together and slowly approached the church.朝圣者双手合十，慢慢走近教堂。\n2. deliverance: n. 拯救, 解救, 解脱 - 和宗教有关，意为“救赎”\n    1. redemption；salvation `/sælˈveɪʃn/`；atonement\n        1. Massive infrastructure construction proved to be the salvation of the country's economy. 大量的基础设施建设挽救了该国经济。\n    2. savior: `/ˈseɪvjə(r)/` n. 救世主\n        1. savage: `/ˈsævɪdʒ/` adj. 野蛮的 n. 野蛮人\n        2. sovereignty: `/ˈsɒvrənti/` n. 最高统治权\n3. bishop: n. 主教\n4. cardinal: n. 红衣主教 adj. 最基本的\n    1. cardinal number: 数学上的基数\n5. canon\n    1. canon: n. 教规；规则；标准；原则\n6. priest: n. 神职人员\n\t1. prime: adj. 主要的；首要的\n    \t1. primitive: adj. 原始的、远古的；落后的\n\t2. clergy: n. 神职人员\n7. divine: `/dɪˈvaɪn/` adj. 神圣的；上天的\n   He suggested that the earthquake had been a divine punishment. 他暗示说地震是上天的惩罚。\n7. sacred: `/ˈseɪkrɪd/` adj. 神圣的\n    1. sacrifice: n./v. 牺牲；献祭\n# 经济、商业文化\n\n1. fiscal: `/ˈfɪskl/` adj. 财政的；国库的\n2. levy: `/ˈlevi/` n. 税款 v. 征税\n3. exempt: `/ɪɡˈzempt/` adj. 豁免的 v. 免除、豁免\n    1. exemplify: `/ɪɡˈzemplɪfaɪ/` v. 是...的例证、榜样；证明了...\n## 贸易、市场\n\n1. barter: v. 互换 n. 互换物 - a barter economy 以物易物的经济形式\n2. bargain: 讨价还价\n3. incoterms: n. 国际贸易术语（International Commercial Terms）\n4. glut: n./v. 供应过剩；供过于求\n5. budget: n. 预算\n    1. assess: v. 估算、估价；评估\n6. promissory: adj. 表示允诺的, 约定的, 【商】约定支付的\n    1. Roger signed a promissory note pledging to pay Fiona $50,000. 罗格签了一张期票，承诺付给菲奥娜5万美元。\n7. bid: v. 投标；出价；吩咐；表示 n. 出价；叫牌；努力争取\n    1. bidding: n. 投标；出价；命令\n8. wholesale: adv. 以批发的方式: `The factory claims they only sellwholesale, not to the public. 该工厂宣称他们只批发，不零售`\n    1. retail: n./v. 零售\n9. vacant: `/ˈveɪkənt/` adj. 闲置的、未被占用的 - vacant properties: 闲置的房产\n    1. vacation: `/veɪˈkeɪʃn/ /vəˈkeɪʃn/` n. 假期\n    2. vocation: `/vəʊˈkeɪʃn/` n. 职业；工作；使命\n    3. vaccine: `/ˈvæksiːn/` n. 疫苗\n        1. vaccinate: `/ˈvæksɪneɪt/` v. 给…接种疫苗\n10. investment: 投资\n    1. investigate: 采访；调查\n        1. inquiry: n. 打听、调查\n11. smuggle: v. 走私\n12. turnover: `/ˈtɜːnəʊvə(r)/` n. 营业额、成交量；人员更替率\n## 报酬、工资\n\n1. wage - 日薪、周薪\n2. remuneration: 报酬\n    1. 拉丁语中的munerate是“展示”的意思，因为词根`muner-`有“给”的意思，在这里可以看作“付出劳动”。re是“归”的意思。所以，“归+付出劳动”=付出劳动的回馈。remunerate: 付酬给...\n3. recompense: `/'rekəmpens/` v. 给…以补偿, 赔偿 n. 报酬, 赔偿, 补偿\n## 归因于、归咎于；欠\n\n1. deserve\n2. due: adj. 由于...的；预计的、到期的；（形容钱、物品，sth. is due to sb.）应付给某人的、欠某人的（not before n.）；（形容人，sb. be due for ...）某人应有、应得到...的；合适的、恰当的\n3. owe: v.\n4. ascribe: `/əˈskraɪb/` v. sth. is ascribed to ... 某事归因于...\n## debit - credit - debt\n\n1. debit: `/ˈdebɪt/` n. 财务记录中所欠或花费的一笔钱的书面记录 v. 当银行从账户借记款项时，它会从账户中扣除款项 - debit card 借记卡\n2. debt: `/det/` n. 欠款、债务；人情债、恩情\n    1. indebted: `/ɪnˈdetɪd/` adj. 感激的、蒙恩的；（国家）负债的\n3. credit: `/ˈkredɪt/` n. 欠账；信誉；学分 v. 允许…赊欠；为…提供贷款；给(学生)记学分\n    1. creditor: 贷方\n    2. credit card: 信用卡\n## 租赁\n\n1. hire: 租赁\n    1. fire: 解雇\n        1. redundant: `/rɪˈdʌndənt/` adj. 被裁减的；多余的\n            1. redundancy: n. 裁员、解雇；冗余\n2. lease: `/liːs/` n. 租约、租契 v. 租用，租借，出租\n    1. lessee: `/le'siː/` n. 承租人, 租户\n## boycott\n\n1. boycott: v. 抵制；拒绝参加 n. 联合抵制\n## 金融\n\n1. monetary: adj. 货币的；金融的\n2. surplus: n. 生产过剩；贸易顺差 adj. 过剩的；剩余的；多余的\n3. earmark: v. 指定（款项）用途；预先安排（要做的事）；确定（未来发生的事） n. 标记；特征\n4. crisis: `/ˈkraɪsɪs/` n. 危机\n5. leverage: `/ˈliːvərɪdʒ/` v./n. 杠杆作用；充分利用\n## 企业、产业、行业\n\n1. premises: n. （企业的）房屋；经营场地\n2. estate: `/ɪˈsteɪt/` **n.** 地产；财产\n3. dismissal: n. 解雇, 开除, 解散, 撤职\n    1. Many employees firmly oppose the unfair dismissal and are claiming for **compensation**. 许多员工坚决反对这种不公平的解雇，并要求赔偿。\n    2. dismiss: v. 对...不屑；解雇...\n4. compensate: v. 补偿、赔偿；付报酬（尤指企业中）\n    1. compensation: n. 赔偿金；薪酬\n5. aviation: n. 航空；航空业\n6. entrepreneurial: `/ˌɒntrəprəˈnɜːriəl/` adj. 创业的；企业家的；具有创业素质的\n    1. entrepreneur: `/ˌɒntrəprəˈnɜː(r)/` n. 创业家；承包商\n7. syndicate: `/ˈsɪndɪkət/` n. 财团；企业联合组织\n8. counterfeit: `/ˈkaʊntəfɪt/` adj. 高仿的 v. 高仿\n## 法律\n\n1. arbitrator: n. 仲裁人；公断人\n    1. arbiter: n. 仲裁人；公断人；裁决人；决定者\n2. accuse: v. 指责，谴责；控告\n3. **prosecute**: `/ˈprɒsɪkjuːt/` vt. 检举、告发某人；继续从事(某事物)\n    1. 词源：late Middle English (in sense (3)): from Latin `prosecut- ‘pursued, accompanied’`, from the verb `prosequi`, from `pro- ‘onward’` + `sequi ‘follow’`. pro(向前)+secut(跟随)+ion(名词后缀)=起诉、原告；实施、从事\n    2. prosecution: n. 诉讼；原告；实施；从事\n      He could face prosecution for his role in the robbery. 他可能因参与抢劫而面临起诉。\n    3. **persecute**: v. 迫害、残害；骚扰、纠缠、困扰\n        1. persecution: n. 迫害\n    4. indict: `/ɪnˈdaɪt/` vt. 控告、起诉（常用于被动） - \"c\"不发音\n        1. indictment: `/ɪnˈdaɪtmənt/` n. 社会的衰败、腐败迹象；起诉书；控告、起诉\n4. clause: n. 从句、字句；（法律）条款\n   There is a clause in the contract requiring(规定) a paid leave. 合同里有一项条款规定了带薪假期。\n5. waive: v. `/weɪv/` 放弃（权利）\n    1. waiver: n. 弃权声明\n    2. wield: v. 行使、使用；支配、掌权\n6. plaintiff: `/ˈpleɪntɪf/` n. 原告；起诉人\n    1. plaint: n. 诉苦；悲叹 - complaint n. 不满、抱怨\n7. oblige: `/əˈblaɪdʒ/` v. 强制\n    1. **obligation: `/ˌɒblɪˈɡeɪʃn/` n. 义务、职责**\n    2. eligible: `/ˈelɪdʒəbl/` adj. 有资格的\n        1. ineligible: adj. 不符合资格的\n            1. inevitable: `/ɪnˈevɪtəbl/` adj. 不可避免的\n8. jury: n. 陪审团\n9. mandatory: adj. 法定的、义务的、强制的\n10. infringe: `/ɪnˈfrɪndʒ/` v. 违反（法律）；侵犯\n    1. infringement: `/ɪnˈfrɪndʒmənt/` n. 违法；侵权\n    2. fringe: `/frɪndʒ/` n. 边缘 v. 成为...的边缘\n11. **liable: `/ˈlaɪəbl/` adj. 应负法律责任的（表语）；可能遭受...的**\n    1. **liability: n. 责任、义务；债务、麻烦的人或事**\n12. solicitor: `/səˈlɪsɪtə(r)/` n. 事务律师；初级律师\n# -sequent\n\n1. consequently: 因此\n2. subsequent: adj. 随后的、紧接的\n# 专业、专家\n\n1. specification - 具体的规则、规范、规格、标准\n2. specific - adj. 明确的、具体的 - specifics n. 详情、细节\n3. particular: adj. 专指的，特定的；独特的，特别的；讲究的，挑剔的 n. 细节，详情\n4. specialist - 专家；专科医生\n5. expert: n.专家 adj. 熟练的；内行的\n    1. expertise: n. 专长；专门知识；\n6. amateur: `/ˈæmətə(r)/` adj. 业余的 n. 业余爱好者；生手\n    1. layman: `/ˈleɪmən/` n. 非专业人员、门外汉\n7. veteran: `/'vetərən/` n. 老兵, 老手 adj. (尤指军事方面)老练的\n8. exclusive: adj. 高级的，奢华的；专用的；独家的 n. 独家新闻，独家报道\n    1. exclusivity: n. 排他性；专有权；独特性\n9. proficient: adj. 熟练的；精通的\n# 革命、革新、罢工: -volve; stri-\n\n1. innovation: n. 创新，革新；新观念，新方法\n2. evolve: v. 演变；进化\n    1. evolutionary 进化的\n3. revolve: v. 旋转\n    1. revolutionary 革命性的；创新的\n4. revolt: n./v. 叛乱；反抗\n5. reform: `/rɪˈfɔːm/` n./v. 改革 - reform and opening-up 改革开放\n## 卷入、忙于: involve\n\n1. engaged: 从事于、忙于；被占用的；订婚的\n2. involved: 被卷入的；涉及的\n    1. evolve: v. 演变、发展、进化\n        1. revolve: vi. 旋转\n    2. entail: vt. 使承担；牵涉\n        1. retail: n./v. 零售\n## stri-、stro-\n\n1. strive - 努力、奋斗\n2. strike - 击打；罢工\n3. stroke: n. (疾病的)突然发作；中风\n4. stroll: v./n. 散步；闲逛\n# complement - compliment - accomplish - competence - compel - offset\n\n1. **compliment: n. 致意、问候；赞美、称赞**\n2. complimentary: adj. 免费的、（从问候的引申而来）赠送的；钦佩的、赞美的\n3. 注意和complement区别：complement是补充；complementary是补充的、补足的\n    1. 同义词：supplementary - 补充的；额外的\n4. completion - n. 完成、结束\n5. accomplish: v. 完成\n    1. accomplishment - n. 成就, 完成, 成绩, 技艺\n    2. accompany: vt. 陪伴, 陪同；伴随…同时发生；伴奏\n    3. complain: v. 抱怨\n7. compete: `/kəmˈpiːt/` vi. 竞争\n    1. competence: `/ˈkɒmpɪtəns/` n. 能力；胜任；（法律）权限、管辖权\n        1. competent: adj. 有能力的；能胜任的\n    2. competition: `/ˌkɒmpəˈtɪʃn/` n. 比赛\n    3. competitive: `/kəmˈpetətɪv/` adj. 有竞争力的\n    4. competitor: `/kəmˈpetɪtə(r)/` n. 竞争者\n        1. rival: `/ˈraɪvl/` n. 竞争对手\n    5. campaign: `/kæmˈpeɪn/` n. 运动；战役 v. 参加运动；领导运动\n    6. vie: `/vaɪ/` vi. 激烈竞争；争夺\n        1. 法语中的vie是生命的意思；拉丁语中是vita\n        2. viable: `/ˈvaɪəbl/` adj. 可生存的；可行的 = feasible\n            1. early 19th cent.: from French, from `vie` ‘life’, from Latin `vita`.\n    7. contention: `/kənˈtenʃn/` n. 争论；看法、观点\n        1. content: n. `/ˈkɒntent/` 内容；目录 adj./v. `/kənˈtent/` 满意的、愿意的\n        2. contend: `/kənˈtend/` vt. 声称、主张、认为、辩论（约等于argue） vi. 竞争、争夺\n8. compel: v. 强迫，迫使\n    1. compelling: adj. 不可抗拒的；令人信服的 - compelling reason: 充分的、令人信服的理由\n    2. camel: n. 骆驼\n9. offset: `/ˈɒfset/` v. 用花费弥补、补偿、抵消\n# 精确的、详细的、明确的\n\n1. accurate - 精确的 - accuracy - 精确度\n2. precise - 精确的 - precision - 精确度\n3. exact\n4. explicit: `/ɪkˈsplɪsɪt/` adj. 详述的、明白的；显式的\n   He gave me very explicit directions on how to get there. 他清楚地向我说明了去那儿的路线。\n    1. implicit: adj. 含蓄的；隐式的\n        1. **obscure: `/əbˈskjʊə(r)/` adj. 模糊的；费解的；隐约的**\n            1. obscurity: n. 默默无闻；隐晦\n    2. elicit: `/iˈlɪsɪt/` vt. 引出、诱出\n# 邪恶、暴力、恶毒\n\n1. vice: `/vaɪs/` n. 缺点、恶习；adj. 副的；代替的\n    1. vicious: `/ˈvɪʃəs/` adj. 恶毒的；暴力的\n2. villain: `/ˈvɪlən/` n. 恶棍；反派人物；罪魁祸首 - 由vile引申而来，vile是卑鄙恶劣的意思\n    1. villainous: `/ˈvɪlənəs/` adj. 邪恶的\n3. riotous: `/ˈraɪətəs/` adj. 暴力的\n4. delinquency: n. 违法行为\n    1. delinquent: adj. 有违法倾向的；欠债的\n5. fierce: `/fɪəs/` adj. 猛烈的、凶猛的、残暴的\n## 强盗\n\n1. pirate: 海盗\n2. bandit: 强盗；土匪 - band布条，it后缀——用布条蒙面的人\n## 创伤：vulnerable - violent\n\n1. vulner: n. 创伤；漏洞\n    1. vulnerate: vt. 使受伤\n    2. vulnerable: adj. 易受创伤的\n    3. vulnerability: 脆弱性；弱点；易伤性\n2. injure: v. 伤害；使受伤\n    1. injury: n. 损伤, 挫伤\n3. impair: vt. 损害；削弱\n4. violent - 暴力的\n5. vicious: 恶毒的\n# 盘问、监视、监督\n\n1. scrutiny: n. 仔细检查；认真审查；密切监视\n    1. censorship: n. 审查、检查\n2. supervise: v. 监督；管理 - supervision: n. 监督；管理\n3. probe: 追究、盘问；详细调查\n4. supervision: n. 监督；指导 - supervise引申而来，强调监督、监管地指导。\n5. ward: n. 监督、监视、保护、看护；病房\n    1. warder: n. (监狱的)看守；狱吏\n6. surveillance: `/sɜːˈveɪləns/` n. 监视；盯梢\n# inferior - superior\n\n```\n-ior【拉丁】后缀；表示“与……有关”\n同根词inferior|anterior|posterior|excelsior|\ninfer【拉丁】表在……下\n同根词inferior|infernal|inferno|inferiority|\n```\n\n1. inferior: `/ɪnˈfɪəriə(r)/` adj. 下等的，较差的 n. 级别较低的人\n    1. be inferior to: 比...低级\n2. superior: `/suːˈpɪəriə(r)/` adj. 级别更高的 n. 上级、上司\n# 感觉: tense - sense - absence - caution - casual - discern - sentiment - attend - attract - inspiration - tentative\n\n1. sensation - 感觉、知觉；感觉力、察觉力；轰动、哗然；引起轰动的人或事\n    1. sence - n. 感觉 - sense - v. 感觉\n    2. sensitivity: n. 体贴，善解人意；敏感，多愁善感；灵敏度；过敏性\n        1. tentative: adj. 不确定的、不肯定的、暂定的；踌躇的、犹豫不定的、不果断的\n2. **perception** - 知觉、感觉；洞察力、认识能力；观念、看法；\n    1. perceive: v. 认为、视为；察觉、感觉\n    2. percent: 百分比\n3. absence n. 不注意；缺乏 - absent adj. 缺席的；不用心的\n    1. presence - 出席\n4. caution: 严谨\n5. casual: `/ˈkæʒuəl/` adj. 漫不经心的；不正经的\n    1. **casualty: `/ˈkæʒuəlti/` n. 伤员；受害者**\n    2. casualness: `/ˈkæʒuəlnəs/` n. 漫不经心、随意\n6. distraction: 不注意；分心\n7. attend: v. 参加；注意；照料\n    1. attention - 注意\n    2. attentive: adj. 注意的；专心的；留心的；关心的\n8. attraction: n. 吸引\n    1. attributive: adj. 定语的 - attributive clause: 定语从句\n        1. attributable: adj. 可归因于...；可能由于...\n9. preoccupy: `/priˈɒkjupaɪ/` vt. 占据(某人)思想；使对…全神贯注，使专心于\n10. disturb - 打扰 - disturbance - 干扰\n    1. intervene: v. 干涉；干预；打断 - intervention n. 干预；干涉；介入\n    2. interfere - interference: 干涉、干预\n        1. interpret: v. 解释、阐述\n    3. interrupt - interruption: n. 打扰；打岔；阻断物；中断时间\n        1. abrupt: adj. 突然的；鲁莽的；（斜坡）陡峭的；（文章或讲话）不流畅的\n        2. internal: adj. 内部的；组织内的\n    4. intrusion: `/ɪnˈtruːʒn/ `n. 闯入；侵扰\n      His phone call was an intrusion into a peaceful morning. 他的电话打破了这个宁静的早晨。\n    5. disruption: n. 中断、扰乱；破裂\n10. agitation: 忧虑；烦乱；骚动，煽动\n11. discern: v. 看出、识别出\n12. sentiment: n. 观点；看法；情绪；（过于）伤感\n    1. sentimental: adj. 情感的（而非理性的）, （失之过度或不恰当地）伤感的, 多愁善感的\n13. concentrate: v. 专心于；全神贯注；集中、聚集\n    1. concentration: n. 专心、注意力；集中、集结；浓度、含量\n14. inspiration: `/ˌɪnspəˈreɪʃn/` n. 灵感；鼓舞；妙计\n## -tract-\n\n1. extract: v. 提取；提炼；（费力）取出；求根 n. 提取物；摘录\n    1. extration: n. 提取；开采；提炼；抽出；抽出物；血统、出身\n2. attract: v. 吸引\n    1. appeal: v. 有吸引力；请求、求助； n. 上诉；恳求；吸引力、趣味性\n        1. appease: v. 安抚\n            1. appeasement: n. 安抚、绥靖政策\n            2. soothe: `/suːð/` v. 抚慰、安慰；减轻疼痛\n            3. console: `/kənˈsəʊl/` v. 抚慰、安慰\n                1. console: `/ˈkɒnsəʊl/` n. 控制台\n                2. consolation: `/ˌkɒnsəˈleɪʃn/` n. 安慰\n3. tract: n. 大片土地\n# 精密、复杂\n\n1. sophistication - n. 精密、复杂；老练；诡辩；温文尔雅\n    1. The sophistication of new technologies is growing. 新技术的精密程度在不断提升。\n    2. sophisticate - v. 使...老于世故，使堕落；使复杂、精致；使迷惑（误解）；曲解、篡改、诡辩 n. 老于世故的人；精于...之道的人\n        1. distort: v. 使变形；扭曲，歪曲；曲解\n            1. distortion: n. 扭曲；变形；曲解；失真\n2. elaborate: `/ɪˈlæbərət/` adj. 复杂的；详尽的；精心制作的 v. 详尽阐述；详细描述\n    1. late 16th cent. (in the sense ‘produced by effort of labour’): from Latin elaborat- ‘worked out’, from the verb elaborare, from e- (variant of ex-) ‘out’ + labor ‘work’.\n    2. elaboration: n. 详细的说明、描述\n3. meticulous: `/məˈtɪkjələs/` adj. 极仔细的; 一丝不苟的\n    1. mid 16th cent. (in the sense ‘fearful or timid’): from Latin `meticulosus`, from `metus ‘fear’`. The word came to mean ‘excessively careful about detail’, hence the current sense (early 19th cent.).\n# tomb - timber\n\n1. tomb - 墓碑\n2. timber - 木材\n    1. boarding: n. 木材；板材\n# -teur\n\n1. amateur: 外行；业余爱好者\n# virtual\n\n1. virtual: adj. 虚拟的（只用在计算机领域，其实可以理解为仿真的） adj. 实际上的、实质上的\n2. virtually: adv. 实际上、事实上；几乎、差不多（很少被翻译为虚拟地）\n3. virtue: n. 美德；优点；善行\n# 假设 - 假装/伪装 - 虚假\n\n1. presume - 假设；假定 - presumably: 大概；想必是\n2. assume\n    1. assumption: \n3. suppose\n4. sham - n. v. adj. 假装；伪装；假象\n5. dummy - v. 做假动作；n. 人体模型；仿造物；adj. 假的\n6. vanity\n    1. 词根是vain，徒劳的\n    2. vanity，徒劳的名词，虚的，所以意思是虚荣心。\n7. disguise: `/dɪs'ɡaɪz/` v. 假装，假扮；掩饰 n. 装扮，伪装\n# 文学类、语言类\n\n1. tale - 富含想象力的小故事；历险记；讲述\n2. myth: `/mɪθ/` n. 神话故事, 荒诞的说法\n3. biography - 传记\n    1. biographer: n. 传记作家\n    2. biology: 生物学 - biological: 生物学的\n        1. organism: n. 生物体、有机体（我总是记成“机体、机能”）\n4. novel - 长篇小说；新颖的\n5. textual - 文本的；篇章的。以text为词根。\n    1. 注意和textile区分，textile是织物；纺织业\n6. verbal: adj. 口头的, 言语的, 词语的, 口头（而非书面）的 n. 〈美口〉口供, 非限定动词, 〈罕〉同“verbal noun”\n7. clause: n. 子句, 从句, 分句, （法律文件的）条款\n8. phrase: n. 短语；习语；措辞\n    1. phase: `/feɪz/` n. 阶段；时期；位相 v. 分阶段进行\n9. infinitive: n. （动词的）不定式\n    1. finite: adj. 有限的；限定的 n. 有限之物\n    2. definite: adj. 明确的, 确切的；一定的, 肯定的\n    3. infinite: adj. 无限的，无穷的；无数的；极大的 n. 无限；无限的东西（如空间，时间）；无穷大\n    4. initial: n. 首字母 adj. 最初的\n        1. initiative: n. 主动性、积极性；积极的对策、倡议 adj. 自发的\n           A lot depends on how such monitoring initiatives are communicated and this could prevent possible revolts being staged. 这在很大程度上取决于如何沟通此类监督举措，这可能会防止可能上演的反抗行为。\n            1. motive: n. 动机\n10. intone: v. 缓慢庄重地说 - intonation: n. 语调；声调；音准\n11. aforesaid: adj. 前述的；上述的\n12. literary: `/ˈlɪtərəri/` adj. 文学的；精通文学的；书面的\n    1. illiteracy: `/ɪ'lɪtərəsi/` n. 文盲\n13. preposition: n. 介词\n14. brief: adj. 简短的、简洁的 n. 简介、摘要\n    1. brevity: `/ˈbrevəti/` n. 简练；简洁\n    2. abbreviate: `/əˈbriːvieɪt/` v. 缩略；缩写\n        1. abbreviation: `/əˌbriːviˈeɪʃn/` n. 缩略语；缩写词\n    3. concise: `/kənˈsaɪs/` adj. 简洁的\n15. synonym: `/ˈsɪnənɪm/` n. 同义词\n16. metaphor: `/ˈmetəfɔː(r)/` n. 象征；隐喻\n    1. metaphorical: adj. 隐喻的\n17. rhetorical: `/rɪˈtɒrɪkl/` adj. 修辞性的（个人理解是“阴阳怪气的”）\n    1. rhetorical question: 反问；设问；修辞性疑问句\n18. narrative: n. 叙事 adj. 叙事体的\n    This novel uses first-person narrative, which quickly brings readers into the story. 这部小说运用了第一人称的叙事模式，能很快把读者带入到进故事里。\n    1. narrate: v. 叙述；讲故事\n16. satirical: `/sə'tɪrɪk(ə)l/` adj. 讽刺的\n    1. satire: `/ˈsætaɪə(r)/` n. 讽刺；讽刺文学作品\n        1. satirist: `/'sætərɪst/` n. 讽刺作家\n17. prose: `/prəʊz/` n. 散文\n## 描述\n\n1. depict: 口头描述\n    1. depiction: n. 描写\n2. portray: `/pɔːˈtreɪ/` v. 尤指小说的描述、描写；描绘\n    1. 注意不要和“tray - 盘子、杯碟”记混\n    2. portrayal: `/pɔːˈtreɪəl/` n. 描述、描写、描绘；展现方式\n       His latest movie is a grim portrayal of the natural disaster. 他最新的电影是对自然灾害的残酷描绘。\n    3. portrait: `/ˈpɔːtreɪt/, /ˈpɔːtrət/` n. 半身画像；详细的描述、描绘\n## 悲剧、灾难、混乱: tragedy - tragic\n\n1. tragedy: n. 悲剧；（文学）悲剧；不幸；灾难\n    1. tragic: adj. 悲剧的；悲惨的；可悲的\n2. strategy: `/ˈstrætədʒi/` n. 策略\n3. havoc:`/ˈhævək/` n. 浩劫、灾害；大破坏、大混乱\n4. turbulent: adj. 骚乱的\n    1. turbulence: n. 动荡；混乱、骚乱\n    2. turmoil: n. 骚乱、混乱；焦虑\n5. catastrophe: `/kəˈtæstrəfi/` n. （突如其来的）大灾难、大灾祸\n6. devastate: `/ˈdevəsteɪt/` v. 彻底破坏；毁灭\n7. disaster: `/dɪˈzɑːstə(r)/` n. 灾难\n# 揭露；显露\n\n1. uncover\n2. reveal\n    1. conceal: v. 隐藏；掩盖\n3. expose: `/ɪkˈspəʊz/` v. 暴露、显露；揭露；面临、遭受\n    1. exposition: `/ˌekspəˈzɪʃn/` n. 解释、说明、阐述\n4. emerge: v. 出现；显露；变得显眼 - emergency n. 紧急情况\n   merge, mers-【拉丁】表示“浸没，浸入”\n   词根助记：submerge:sub在下面+merge→沉到下面去\n   同根词emergency|submerge|immerse|merge|emergence|merger|submersible|\n    1. submerge: v. 浸没；潜入水中\n    2. immerse: v. 使沉浸、深陷\n        1. immersion: n. 沉浸；专心\n        2. immune: adj. 免疫的\n            1. allergic: adj. 过敏的\n                1. allergy: n. 过敏反应\n5. encounter: v. 遭遇；与…发生冲突 n. 遭遇；冲突\n    1. em-,en-【希腊】进入，向内；使成为\n       词根助记：encounter: en进入+ counter对立= 进入对立状态= 遭遇，冲突\n       同根词encounter|enlighten|\n    2. contra-, contro-, counter, contre-【拉丁】对立\n       同根词encounter|contradiction|contrast|contradict|counterpart|contradictory|contraband|\n# -rine\n\n1. marine - 航海的；船舶的；海事的；海洋的 - submarine - 潜艇\n# 海\n\n1. marine: `/məˈriːn/` adj. 海洋的；海产的、海生的\n    1. maritime: `/ˈmærɪtaɪm/` adj. 海的、海事的；船的\n2. ocean\n    1. oceanic\n3. lieutenant: 陆军中尉；海军、空军上尉。\n4. reef: n. 礁、礁脉 v. 收帆\n5. waterfront: n. 滨水地区（港口或海边）；水边地\n    1. harbor: n. 港口、港湾 v. 心怀（想法或感情）；庇护、窝藏\n6. pirate: n. 海盗; 盗版者 v. 非法复制, 盗印; 抢掠\n7. vessel: n. 船；容器，器皿（尤指装液体的，如碗、桶）；血管\n    1. vessel血管；artery动脉；vein静脉\n8. hull: `/hʌl/` n. 船体、船身；壳\n9. cruise: `/kruːz/` n. 航游\n# 赞赏、钦佩\n\n1. admire: `/ədˈmaɪə(r)/` v. 钦佩、赞赏、欣赏\n    1. admiration: `/ˌædməˈreɪʃn/` n. 钦佩、赞赏、欣赏\n2. appreciate: `/əˈpriːʃieɪt/` v. 增值、升值；重视、欣赏；感激、感谢\n    1. appreciation: `/əˌpriːʃiˈeɪʃn/` n. 增值、升值；重视、欣赏；感激、感谢\n    2. depreciate: `/dɪˈpriːʃieɪt/` v. 贬值；折旧；贬低、轻视\n    3. depreciation: `/dɪˌpriːʃiˈeɪʃn/` n. 贬值；折旧\n3. acknowledge: 承认；公开感谢\n4. adore: 爱慕、崇拜\n# 承认\n\n1. acknowledge\n2. concede: v. 承认；出让；容许\n3. confess: v. 承认；坦白；忏悔 - confession: n. 坦白；供词；认罪\n    1. profess: v. 妄称、伪称；宣称、公开表明\n# cogni-\n\n1. cognitive: adj. 认知的；认识能力的\n2. recognize: v. 认识出 - recognition: n. 承认，接受\n\t1. negative: adj. 否认的，拒绝的\n# 收养；培养\n\n1. foster: v. 培养、照料 adj. 代养的, 收养的\n2. adopt\n3. breed: n. 品种; 类型 v. 饲养; 繁殖; 养育, 教育; 酿成, 导致\n4. nourish: v. 抚养，滋养；培养，助长\n    1. nourishment: n. 营养；滋养品；养料\n    2. nurture: `/ˈnɜːtʃə(r)/` v./n. 养育、培育（偏向于后天培养）\n       This preoccupation inevitably leads to an old debate: whether nature or nurture moulds us more. 这种关注不可避免地导致了一场熟悉的辩论：天性和后天培养哪一个塑造我们更多。\n        1. nutrition: `/njuˈtrɪʃn/` n. 营养\n        2. malnutrition: `/ˌmælnjuˈtrɪʃn/` n. 营养不良\n    1. aliment: n. 滋养品；食物 vt. 向…提供营养物\n    2. varnish: n. 清漆、亮光漆；光泽面 v. 在…上涂清漆；使…有光泽\n        1. a liquid that is painted onto wood, metal, etc. and that forms a hard shiny surface that you can see through when it is dry\n        2. Middle English: from Old French `vernis`, from medieval Latin `veronix ‘fragrant resin’` or medieval Greek `berenikē`, probably from Berenice, a town in Cyrenaica, a region of NE Libya.\n5. propagate: v. 繁殖；传播；宣传\n    1. propaganda: n. （政治）宣传；鼓吹\n# 执行\n\n1. perform\n2. conduct: v./n. 实施；举止、表现；指挥（音乐）；带领，引导；（热、电）传导\n    1. conduction: n. （热、电）传导\n3. execute - execution - executive: adj. 行政的；管理的；董事\n# 说服、证明；支持、同意、许可类词汇\n\n## probe - probable\n\n1. probable - 我们都很熟悉，是“可能的”的意思。\n2. probe是probable的词根。实际上probe是“盘问；弄清楚”的意思（probe，v. 盘问、追问；探查、探测 - n. 探究、详细调查；探针、探测器），因此可以引申为“证明清白”。因此，probable直译为“可被证明的”，引申为“可能的”。\n3. 更根本的，`prob-`在拉丁语中表示“诚实；证明；检验、测试”的意思。\n4. probing - 刨根问底的\n5. probity - 直译为经过试炼证明 - 因此意为：正直、诚实\n## convince - 说服、信任、信服、确认 - determine - assure - resolute - credulous - deceit - affirm\n\n1. convince: v. 使...相信；说服...\n    1. convinced: adj. 被说服的；信了的、坚信不移的\n    2. convict: v. 定罪；证明有罪（常用于被动语态）\n        1. **conviction: n. 证罪；坚定的信念**\n2. persuade: v. 说服、劝告；使相信\n    1. persuasion: n. 说服、劝告；信仰、信念\n    2. persuasive: adj. 令人信服的；能说会道、口才好的\n        1. eloquence: `/ˈeləkwəns/` n. 口才好\n            1. eloquent: `/ˈeləkwənt/` adj. 口才好的、雄辩的\n    3. 易混：pursuit: n. 追求；追赶\n3. determine: v. 使下决心；确定\n4. assure: v. 保证、确信、确保 - assurance\n    1. insurance n. 保险\n    2. reassure: v. 使…安心, 打消…的疑虑\n       re再次+sur肯定=再次肯定=使安心\n5. resolute: **adj.** 坚决的；有决心的\n    1. resolution: n. 决心；解决、决议；**分辨率**\n6. repute: `/rɪˈpjuːt/` n. 名声；人们对某个人、物的看法(opinion)\n    1. reputable: `/ˈrepjətəbl/` adj. 名声好的\n7. credulity: n. 轻信\n    1. credulous: adj. 轻信的；易受骗的\n    2. incredulous: adj. 不能相信的；表示怀疑的\n    3. credit: `/ˈkredɪt/` n. 欠账；信誉；学分 v. 允许…赊欠；为…提供贷款；给(学生)记学分\n        1. creditor: 贷方\n8. deceit: `/dɪ'siːt/` n. 欺骗；诡计 - deceitful: adj. 不诚实的；骗人的\n9. debit: `/ˈdebɪt/` n. 财务记录中所欠或花费的一笔钱的书面记录 v. 当银行从账户借记款项时，它会从账户中扣除款项 - debit card 借记卡\n10. affirm: v. 断言；肯定\n    1. affirmative: adj. 肯定的；同意的\n11. pledge: `/pledʒ/` n./v. 保证、承诺\n## just-\n\n1. `just-`拉丁语中表示公正的\n2. justice - 公正 - injustice - 不公正\n3. justify - 证明...正确、有理；为...辩护\n    1. justification - 辩护；正当理由\n4. justifiable - adj. 合理的, 有理由的, 无可非议的, 正当的\n    1. legitimate: adj. 合法的；正当合理的 v. 使合法；认为正当\n    2. legislative: `/ˈledʒɪslətɪv/` adj. 立法机关的\n       a legislative assembly/body/council: 立法议会／机构／委员会\n        1. legislation: n. 立法\n## 准许、许可、同意、支持\n\n1. verify: v. 证明；核实；证实\n2. prove\n3. consent: n./v. 同意、允许\n4. approve - approval: 同意；认可\n5. concur: v. 同意, 赞同, 意见一致; 同时发生\n6. permit: v. 允许；许可 n. 许可证；执照\n    1. permissive: adj. 放任的；纵容的；姑息的；放纵的\n7. affirmative: adj. 肯定的；同意的\n8. countenance: n. (formal or literary)面容，表情 v. (formal)支持；赞同；认可\n    1. Middle English: from Old French `contenance ‘bearing, behaviour’`, from `contenir`, from Latin `continere`, from `con- ‘altogether’` + `tenere ‘to hold’`. The early sense was ‘bearing, demeanour(举止)’, also ‘facial expression’, hence ‘the face’.\n9. recipient: n. 接受者；领奖者；接收器\n   Bob Dylan is the recipient of the Nobel Prize for Literature in 2016.\n   鲍勃·迪伦是2016年诺贝尔文学奖得主。\n   Americans routinely overestimate the share of black recipients of public assistance programs.\n   比如，美国人总是高估公共救助计划中黑人接受者的比例。\n10. endorse: `/ɪnˈdɔːs/` v. 公开赞同、支持、认可；广告代言、宣传\n    1. endorsement: n. 背书；公开支持\n# 追求、坚持类的词\n\n1. desire: v./n. 渴望\n    1. desirable: adj. 理想的；令人向往的\n2. persist: v. 坚持\n    1. persist**e**nce: n. 坚持\n    2. insist: `/ɪnˈsɪst/` v. 坚持要求\n3. resist: v. 抵抗\n    1. resist**a**nce: n.\n    2. counteract: `/kənˈspaɪə(r)/` v. 抵制、抵抗；抵消\n4. persevere: `/ˌpɜːsəˈvɪə(r)/` v. 坚持不懈\n    1. perseverance: `/ˌpɜːsəˈvɪərəns/` n. 毅力、韧性；不屈不挠\n5. sustain: `/səˈsteɪn/` v. 保持、使持续不断\n   Earth can sustain life. 地球能维持生命。\n6. pursue: v. 追求\n    1. pursuit: n. 追求\n7. adhere: vi. 黏附、附着\n    1. adherence: `/ədˈhɪərəns/` n. 坚持；遵守、遵循\n8. cling: `/klɪŋ/` vi. 抓紧、紧握；粘住、附着；坚持、墨守\n# enclosure\n\n1. enclosure: n. 圈地；围场；附件\n    1. enclose: v. 围绕，包围；把……放入信封\n## substance\n\n1. substance - 物质；实质；大意、要旨；根据\n2. substantiate v. 证实；证明\n3. substantial: adj. 大量的、可观的；实质的\n## sway - wag - 摇\n\n1. sway: v. 摇动；使动摇；说服、使相信 n. 影响；动摇；统治\n    1. sway=influence(影响)\n2. wag: v. 摇动；摆（尾巴），（尾巴）摇，摆动 n. 摇摆，摆动；老开玩笑的人，爱闹着玩的人\n# 碰撞、冲突\n\n1. crash: 碰撞\n2. clash: 冲突、交锋\n3. collide: `/kəˈlaɪd/` v. 碰撞；相撞；严重不一致；抵触 - collision: n. 碰撞；冲突\n    1. collapse: v./n. 崩塌；折叠\n        1. collaborate: v. 合作；协作；勾结、通敌 - collaboration n. 合作；协作；通敌行为\n4. conflict\n    1. inflict: vt. 使...遭受（不快、痛苦）\n5. bump: n. 碰撞；隆起、肿块 v. 碰撞；颠簸而行\n    1. pump: n./v. 泵\n6. clash: `/klæʃ/` n./vi. 冲突；争论\n# 抓、挠、咬\n\n1. gnaw: 老鼠似的啃咬；折磨 - nibble: v. 一点点地咬 n. 一小口；点心 - ripple: 涟漪、水纹\n2. bite: 狗咬\n3. sting: 蚊子咬\n4. peck: 鸟啄\n## scrap - scrub - crack - scratch - crash - crush - cricket - stab - snatch - smack - snap - spur - scotch - scorch - squash - stitch - scramble - rash - staple - ditch\n\n1. scrap: n. 碎片；丝毫 v. 取消\n    1. scrub: v. 擦洗、刷洗\n2. crack: 破裂\n3. scratch: 抓挠\n4. itch: 使...发痒\n    1. tickle: v./n. 挠痒痒；感到发痒\n    2. tackle: vt. 处理、解决（难题、局面）\n        1. reckon: vt. 认为；把...当作；**估算**\n            1. beckon: `/ˈbekən/` v. 招手示意；吸引、诱惑\n               The man beckoned the waitress to his counter. 男人招手示意服务员到他的柜台前来。\n            2. reckless: `/ˈrekləs/` adj. 无所顾忌的；不计后果的\n        2. sparkle: n./v. 闪光、闪烁、闪耀\n            1. spark: 火星；诱因、导火线\n        3. formidable: `/fəˈmɪdəbl/,` adj. 难对付的\n5. crash: 碰撞\n    1. collide: v. 碰撞；相撞；严重不一致；抵触 - collision: n. 碰撞；冲突\n    2. rash: adj. 鲁莽的 n. 一连串、大量；疹子\n6. crush: 压碎、压扁；暗恋、迷恋\n7. cricket: 板球运动；蟋蟀 - not cricket: （口）不公平、不正当\n8. stab: v. 刺、戳\n    1. prick: v. 戳、刺；扎 n. 蠢货；笨蛋\n9. snatch: v. 一下夺去, 抢走 n. 片段；只言片语\n10. smack: v. 用巴掌打 n. 拍击(声) adv. 直接地；猛烈地\n    1. smack one's lips: 不是扇某人的嘴巴，而是咂咂嘴\n       lick one's lips: 垂涎三尺\n11. snap: v. 突然折断；突然生气；突然发作；突然移动；砰然关上；猛咬；厉声说\n12. spur: v./n. 刺激；激励；鞭策\n13. scotch: v. 使...结束；扑灭；镇压 adj. (大写Scotch)苏格兰的\n14. scorch: v. 烧焦；枯萎\n15. squash: `/skwɒʃ/` vt. 压扁，压烂，挤碎\n16. stitch: v./n. 缝补；缝合 n. 针脚\n17. scramble: v./n. 攀爬；争抢；忙乱\n18. staple: `/ˈsteɪpl/` adj. 主要的、重要的 n. 订书钉 v. 用订书钉装订\n19. ditch: v. 抛弃、拜托\n    She couldn't stand her boyfriend anymore so she ditched him. 她再也忍受不了她男朋友了，于是就把他甩了。\n# 碎片、条\n\n```\nfrag-, frang-, fract-, fring-【拉丁】表示“弄断”；“破碎的”\n```\n\n1. fraction: n. 一小点儿；碎片\n    1. friction: n. 摩擦\n    2. fracture: v./n. 断裂；破裂\n2. strip: n. 条、带；除去；剥夺\n    1. strand: n. （线、绳）股，缕 v. 使滞留；使搁浅\n3. rag: n. 抹布、破布\n    1. ragged: adj. 衣衫褴褛的\n4. slit: n. 狭缝，裂缝；狭长切口 v. 切开，划开，撕开，划破\n    1. stab: v. 刺，戳\n    2. slot: n. 空位；插槽、槽位；（节目表的）一档位置 v. 插入、塞入\n5. slice: n. 薄片、切片；切开、划破\n6. fragile: `英：/ˈfrædʒaɪl/ 美：/ˈfrædʒl/` adj. 易碎的\n    1. fragility: `/frəˈdʒɪləti/` n. 脆弱；脆性\n    2. delicate\n        1. delicacy: `/ˈdelɪkəsi/` n. 脆弱；小心、温柔、周到、体贴；棘手、微妙\n    3. fragment\n        1. segment: n. 段；片\n7. scrap: n. 碎片、丝毫；取消\n8. debris: `/ˈdebriː/` n. 碎片；残骸 - 结尾`s`不发音\n## rip - lip\n\n1. rip:`/rɪp/ ` v. 撕破；猛地扯开；突然拉开 n. 撕开的大口子\n    1. ripe:`/raɪp/` adj. 成熟的 - ripen:`/ˈraɪpən/` v. 使成熟\n2. lip: 有小缝的唇\n# fr-\n\n## frugal\n\n1. frugal: adj. 节俭的；（对金钱、食物等）节约的；简单廉价的\n# -rain: refrain - strain - constrain - drain\n\n1. refrain: v. 克制；节制；避免 n. 副歌；迭歌；迭句\n    1. refrain from doing ... 节制做...\n2. strain: v./n. 拉伤；压力过大\n3. constrain: v. 强迫；限制\n    1. constrict: v. （使）紧缩；限制、约束\n    2. restrict: v. 限制；束缚、阻碍\n    3. confine: v. （常用于被动）限制；监禁、紧闭\n        1. confinement: n. 禁闭、关押、监禁\n        2. custody: `/ˈkʌstədi/` n. 监护、保管；拘留、羁押\n4. drain: v. 流干\n# -athe\n\n1. bathe - bathroom的词根。用水清洗（洗澡）；游泳。\n2. lathe: 机床；用机床加工\n# -stitute: 组成；替代物\n\n1. constitute - 组成、构成；成立、设定\n    1. constituent: adj. 组成的、构成的；任命的、选举的；n. 组成部分、成分；选民\n    2. constitution: 组织；宪法\n2. substitute: n. 替代物 v. 用...替代\n# counsel: 咨询\n\n1. counsel: 尤指法律顾问。\n# 官职\n\n1. lieutenant: 陆军中尉；海军、空军上尉\n2. errand: `/ˈerənd/` n. 差事；跑腿 - 约等于trip\n    1. errant: `/ˈerənt/` adj. 行为不当的、出格的；出轨的、偏离正路的；迷途的\n    2. appointment: n. 任命；委派；约会；预约\n# 装饰 - decorate - adorn\n\n1. adorn\n    1. adore: 爱慕、崇拜\n2. decorate: v. 装饰，装修\n# 特有或常见物体\n\n1. marble: n. 大理石\n## 不常见的词但可能会常说的词\n\n1. ailment: n. 小病、不适\n    1. ail: v. 困扰；干扰\n    2. aliment: n. 滋养品；食物 vt. 向…提供营养物\n    3. nausea: n. 恶心；反胃；作呕\n2. tan: v. 晒黑 adj. 晒黑的 n. 晒黑的皮肤\n3. dwarf: n. 小矮人；侏儒 adj. 矮小的 v. 使显得矮小，使相形见绌\n    1. awkward: adj. 笨拙的；尴尬的；棘手的；不合适的\n    2. cowardly: adj. 怯懦的\n4. pest: n. 害虫；讨厌的人（或物）\n5. tyre: 轮胎\n6. quota: 配比；定额、配额\n## 生活用具\n\n1. thermometer: `/θəˈmɒmɪtə(r)/` n. 温度计；体温计\n2. barometer: n. 气压计\n## 生活用品：餐具、容器\n\n1. tray: 盘子、杯碟\n2. plate: 盘子\n3. lid: n. 盖子；眼睑 v. 给装盖子\n    1. hamper: n. 带盖子的大篮子 v. 阻碍\n4. pot: n. 锅；罐；盆\n5. frying-pan: n. 煎锅；长柄平锅\n6. pail: n. 桶；一桶的量\n7. cuisine: `/kwɪˈziːn/` n. 烹饪，菜肴；风味\n   The hotel restaurant is noted for its excellent cuisine. 这家饭店的餐厅以美味佳肴闻名遐迩。\n8. chef: 主厨 - chief: 最高的（CEO的C）\n9. hospitality: n. 好客、殷勤；（款待客人的）餐饮、服务\n\t1. hostile: 敌意\n11. basin: n. 脸盆\n12. seal: v./n. 密封\n    1. seam: `/siːm/` n. 接缝；矿层、煤层\n## 家纺、家具、家居\n\n1. blanket: 毯子\n2. rug: n. 小地毯\n3. couch: n. 长沙发; 长椅\n4. mat: n. 垫子\n5. curtain: n. 窗帘；门帘\n6. pillar: n. （尤指装饰的）支柱、柱状物 v. 用柱子装饰\n7. furniture: n. 家具 - a piece of furniture\n8. knit: v. 编织（衣物、毯子）；使团结、联合\n    1. knitting: n. 针织品、编织物\n9. balcony: `/ˈbælkəni/` n. 阳台；楼台\n## 农业工具\n\n1. rake: `/reɪk/` n./v. 耙、耙状工具\n    1. rakish: `/ˈreɪkɪʃ/` adj. （形容男）放荡的、肆无忌惮的\n2. shovel: `/ˈʃʌvl/` n. 铲\n    1. shove: `/ʃʌv/` v./n. 猛推；乱挤\n3. bait: n. 诱饵；鱼饵 vt. 引诱\n4. crop: n. 庄稼；作物 v. 裁切\n5. grain: 谷物；颗粒状的东西\n    1. particle: n. 颗粒；微粒；极少量\n    2. corn: n. 玉米, (脚上的)鸡眼；谷物 v. 腌；使成颗粒\n        1. maize: `/meɪz/` n. 玉米\n6. fodder: n. 草料；饲料\n    1. hay: n. （用作饲料的）干草，草料\n7. furrow: v. 犁；（使）皱（眉） n. 沟；犁沟；车辙；皱纹\n    1. wrinkle: n. 脸上的皱纹；皱褶，皱痕 v. 起皱纹；皱起；（使）起皱褶\n       She wrinkles her brow since she can't understand this question. 她看不懂这个问题，便皱起了眉(brow)。\n8. pole: n. 杆子；地极；磁极\n    1. a tent pole 帐篷支柱；South Pole 南极 North Pole 北极\n    2. polar: adj. 两极的；极地的；完全对立的；截然不同的\n    3. polarity: n. 截然对立；两极化；极性\n9. sickle: n. 镰刀\n10. poultry: `/'pəʊltri/` n. 家禽；禽肉\n## 牧业\n\n1. ranch: `/rɑːntʃ/` n. 大牧场；大饲养场\n## 工业生产用具、工具\n\n1. gear: n. 齿轮传动装置；v. 用齿轮连接\n2. hinge: n. 铰链、合叶 v. 给...装上铰链 - unhinge: v. 使精神失常错乱\n    1. hinge on 取决于...\n    2. linger: `/ˈlɪŋɡə(r)/` vi. 徘徊；磨蹭；余音绕梁、仍有阴影\n       Is the lingering shadow of the global financial crisis making it harder to accept extravagant indulgences? 全球金融危机残余的阴影是否正在使人们更难接受奢侈的放纵?\n3. valve: 阀门\n4. adhesive: `/əd'hiːsɪv/` n. 黏合剂, 黏着剂 adj. 黏合的, 黏附的, 有附着力的\n5. utensil: n. 器具；用具\n6. catalyst: n. 催化剂；刺激因素；促使因素 - catalytic: adj. 起催化作用的\n7. hose: 软管\n8. bolt: n. 螺栓；插销；门闩 v. 用闩、螺栓固定...\n   I closed the door and drew the bolt. 我关上门，拉上了插销。\n9. gauge: `/ɡeɪdʒ/` n. 测量仪器；宽度、厚度、尺度 v. 测量；判断\n## 天气现象\n\n1. mist: 薄雾；fog: 浓雾；smog: 雾霾、烟雾\n    1. frog: n. 青蛙\n2. frost: 结霜\n    1. condense: `/kənˈdens/`v. 压缩；冷凝、凝结\n        1. condensation: n. 凝结的水珠；书的简缩版\n3. melt: 融化\n4. hail: `/heɪl/` n. 冰雹 vt. 向...欢呼；使像下雹样落下 int. 欢迎；万岁\n## 植物、树\n\n1. oak: 橡树\n2. maple: 枫树\n## 食物、酱\n\n1. sauce: 酱\n2. mustard: 芥末\n3. jelly: n. 果冻；胶凝物 v. 使凝成胶状 - jellied: adj. 胶冻状的\n\t1. jellyfish 水母；海蜇\n\t2. royal jelly 蜂王浆\n4. powder: 粉末 - chilli powder: 辣椒粉\n    1. ponder: v. 沉思；琢磨；考虑\n        1. fond: adj. 喜欢的；渴望的\n            1. fonder（比较级）\n                1. ponder: v. 琢磨\n5. yeast: n. 酵母；酵母菌\n6. vinegar: `/'vɪnɪɡə(r)/` n. 醋\n7. dough: 面团\n    1. flour: 面粉\n8. recipe: `/ˈresəpi/` n. 食谱；烹饪法\n    1. recite: `/rɪˈsaɪt/` v. 背诵；逐一列举\n        1. cite: v. 引用；举例\n        2. rehearse: `/rɪˈhɜːs/` v. 排练；默默练习\n## 乐器\n\n1. flute: 长笛\n## 纤维、纺织品、布料\n\n1. fiber = fibre: 纤维素\n2. fabric: 织物；结构\n3. textile: 纺织业；织物；纺织品\n4. linen: `/ˈlɪnɪn/` adj. 亚麻制的 n. 亚麻织品；亚麻布\n    1. liner: `/ˈlaɪnə(r)/` n. 客轮\n        1. linear: `/ˈlɪniə(r)/` adj. 线性的\n## 衣物、钱包\n\n1. blouse: 女衬衣\n2. purse: 女钱包\n3. cloak: n. 披风，斗篷；遮盖物 v. 遮盖；掩盖\n4. mitten: n. 连指手套\n5. sweater: 毛衣\n6. scarf: n. 围巾, 头巾, 披巾\n## 材料、物质\n\n1. material: 材料；物质的 - raw material 原材料\n    1. substance: 实质；大意、要旨；根据\n        1. substantiate v. 证实；证明\n2. leather: 皮革；feather: 羽毛\n    1. fleece: n. （相对于wool，指处理前的）羊毛, （一只羊一次剪下的）毛, 羊毛状织物, 绒头织物短上衣 v. 敲诈, 敲竹杠\n3. foam: 泡沫材料（橡胶、塑料等） - foamy: adj. 泡沫的；起泡沫的\n4. timber - 木材\n    1. boarding: n. 木材；板材\n5. cable - 线缆；电缆；钢索\n6. carbon - 碳\n7. synthetic - （物质）合成的；人造的 - synthetic materials: 合成材料\n    1. `syn-`一起 + `thet-`放置 + `-ic`与...有关；...的本质\n    2. artificial: adj. 人造的\n8. petroleum: `/pəˈtrəʊliəm/` n. 石油\n    1. 希腊语传入拉丁语：petro-: 石头、岩石；oleo-: 油\n    2. petrol: 汽油\n9. fuel: n. 燃料\n10. fossil: n. 化石\n    1. foil: `/fɔɪl/` n. 金属薄片；箔纸\n## 度量、物理性质\n\n1. density: 密度；密集\n2. dozen: 一打\n    1. doze: 小睡；小憩\n3. dose: `/dəʊs/` n. 剂量；一剂\n4. handful: 一把\n5. humidity: `/hjuː'mɪdəti/` n. （空气）湿度；湿气；湿热\n    1. Humi: 湿度 - humid: adj.潮湿的 - humidify: vt. 使潮湿；使湿润 - humidifier: n. 增湿器，加湿器\n    2. 同义词: moist, moisture, dampness, damp, wet, wetness\n    3. humanity: 人性\n    4. humiliate: `/hjuːˈmɪlieɪt/` vt. 羞辱\n        1. humiliation: `/hjuːˌmɪliˈeɪʃn/` n. 屈辱、耻辱\n6. tonnage: n. 吨位；吨数\n7. quart: n. 夸脱（液量单位，在英国和加拿大等于2品脱或1.14升，在美国等于0.95升）\n    1. 4夸脱 = 1加仑\n    2. quarter: 一刻钟；四分之一\n        1. quarterly: adj. 季度的 adv. 每季一次\n8. elastic: n. 松紧带；橡皮带 adj. 有弹性的\n    1. elasticity: `/ɪˌlæˈstɪsəti/` n. 弹性；弹力\n9. texture: `/ˈtekstʃə(r)/` n. 质地；肌理、纹理；构造\n10. momentum: `/məˈmentəm/` n. 动力、势头；动量\n## 饰品\n\n1. bead: n. 珠子；（液体）小滴珠 vt. 用小珠装饰 vi. 形成珠状，起泡\n    1. beard: `/bɪəd/` n. 胡须\n2. pearl: `/pɜːl/` n. 珍珠\n    1. peril: `/ˈperəl/` n. 严重危险\n        1. hazard: n. 危险；危害\n            1. hazardous: adj. 危险的；有害的\n        2. **menace: `/ˈmenəs/` n. 威胁；危险的人\n3. jewelry: n. 珠宝, 首饰, 珠宝饰品\n    1. jewel珠宝，钻石，可数名词。 jewelry/jewellery是珠宝的总称,不可数名词。\n## 器官、人体部位\n\n1. kidney: n. 肾\n2. liver: n. 肝\n3. gland: n. 腺\n4. bowel: `/ˈbaʊəl/` n. 肠\n    1. bowl: `/bəʊl/` n. 碗\n    2. vowel: 元音\n6. hip: n. 髋；臀部；野蔷薇果 adj. 时尚的，赶时髦的\n7. jaw: `/dʒɔː/` n. 颌；下颌（下巴）\n8. limb: n.（人、四足动物的）肢，肢体；（鸟的）翼\n9. breast: `/brest/` n. 胸部\n10. thumb: n. 拇指 v. 用拇指摸, 用拇指捋\n11. rib: n. 肋骨, 排骨, （船或屋顶等的）肋拱, （织物的）凸条花纹 v. 嘲笑, 逗弄, 开（某人的）玩笑（笑时肋骨会运动——嘲笑）\n    1. rid: v.免除,清除,使...获自由\n12. skeleton: n. 骨架，骨骼；骨瘦如柴的人（或动物）；框架，提纲，概要\n    1. skeptical: adj. 怀疑的\n        1. suspicious: adj. 怀疑的\n    2. sketch: n. 素描、速写；草图\n13. elbow: `/'elbəʊ/` v. 用肘推, 挤身进来 n. 肘, 肘状物, 曲折\n14. whisker: n. （硬）须；络腮胡子；微弱的差距\n    1. a very small distance or space \"they lost the election by a whisker\"\n    2. a long stiff hair growing from the snout or brow of most mammals as e.g. a cat\n15. snout: n. 鼻子\n16. organ: n. (人体或动植物的)器官; 风琴; 口琴; 机构, 机关\n## 药名\n\n1. aspirin: 阿司匹林\n2. penicillin: 盘尼西林；青霉素\n## 动物\n\n1. leopard: n. 豹\n2. panther: `/'pænθə(r)/` n. 黑豹\n3. beak: n. 鸟喙, 鹰钩鼻, 尖鼻, 鼻子\n4. wasp: n. 黄蜂；胡蜂\n    1. waspish: adj. 暴躁的, 易怒的\n5. rooster: n. 公鸡\n6. hound: `/haʊnd/` n. 猎犬；猎狗 v. 纠缠，不断骚扰\n7. penguin: `/ˈpeŋɡwɪn/` n. 企鹅\n8. pigeon: `/ˈpɪdʒɪn/` n. 鸽子\n## 册子\n\n1. leftlet: `/ˈliːflət/` n. 宣传册；传单 v. 散发传单（或小册子）\n    1. leaf树叶；let小的。leaflet 就是小树叶一样的东西，和传单很相似，到处漂。\n2. pamphlet: 小册子\n## 病\n\n1. indigestion: `/ˌɪndɪ'dʒestʃən/` n. 消化不良（症）\n    1. indigenous: `/ɪnˈdɪdʒənəs/` adj. 土生土长的、本地的\n2. epidemic: `/ˌepɪˈdemɪk/` n. （传染病）流行、传播\n    1. episode: `/ˈepɪsəʊd/` n.（电视剧）一集；（小说、人生的）插曲\n# limb - lumber - timber\n\n1. limb: n. 四肢\n2. lumber: n. 木材, 木料；杂物, 破烂儿 vi. 缓慢吃力地移动；笨拙地行进\n3. timber: n. 木材\n# foremost\n\n1. 最重要的；首要的\n# 抑制: suppress - oppress - repress - depress - stifle\n\n1. sup - suppress: `/səˈpres/` 压制、压抑\n2. op - oppress: `/əˈpres/` v. 欺压、压迫、压制；压抑\n3. re - repress: `/rɪˈpres/` v. 克制、抑制；压抑\n4. de - depress: `/dɪˈpres/` v. 使抑郁\n5. deplore: `/dɪˈplɔː(r)/` vt. 公开谴责；强烈反对\n6. stifle: `/ˈstaɪfl/` v. 扼杀；抑制\n7. strangle: vt. 扼杀；阻碍\n8. hamper: n. 带盖子的大篮子 v. 阻碍\n9. hinder: vt. 阻碍\n10. withhold: `/wɪðˈhəʊld/, /wɪθˈhəʊld/` vt. 拒绝给；不给\n11. inhibit: v. 阻止\n12. deter: v. 阻止、制止\n    1. deterrent: `/dɪˈtɜːrənt/` n. 威慑力；威慑手段\n## 障碍、缺陷；残疾、瘫痪: handicap - obstacle - hinder - withhold - drawback\n\n1. handicap: `/ˈhændikæp/` n. 生理（或智力、交际功能）缺陷；不利因素，障碍 v. 妨碍；阻碍\n    1. paralysis: `/pəˈræləsɪs/` n. 麻痹、瘫痪；（活动、工作能力）完全丧失\n        1. paradox: `/ˈpærədɒks/` n. 矛盾的人、事物；悖论\n    2. cripple: `/ˈkrɪpl/` v. 使残疾；严重损害 n. 残疾人、瘸子、跛子\n2. obstacle: `/ˈɒbstəkl/` n. 障碍、绊脚石\n3. drawback: `/ˈdrɔːbæk/` n. 缺点；不利条件、障碍\n# emission - eliminate - climate - diffusion - omission\n\n1. emit: v. 发出（声音）；散发（气体、辐射物） - emission - 尤指气体的扩散、发散、消散\n\t1. permeation: 渗透；扩散\n2. eliminate - 消除、去除、排除\n3. climate - 气候\n\t1. climax: n. 高潮；极点 - anticlimax: 扫兴\n\t\t1. summit: n. 顶会，峰会\n\t\t2. culminate: v. 以...告终 n. 顶点、巅峰、高潮；终点\n\t\t   My arguments with the boss culminated in my resignation. 我和老板的争论以我的辞职而告终。\n4. diffusion: n. 传播、散布；推广\n   Modern technologies make the diffusion of information extremely rapid. 现代技术使信息的传播极为迅速。\n    1. infusion: n. 灌输；\n5. omission: `/ə(ʊ)'mɪʃ(ə)n/` n. 遗漏、疏忽\n# 授予 - 奖励、奖章 - 象征、标记\n\n1. award: n. 奖；奖金 v. 授予，给与；裁定\n    1. reward: 回报\n2. bestow: v. 授予；献给 - He bestowed high praise on the winners.\n3. endow\n4. badge: n. 象征\n5. impart: v. 通知、透露、传授；把（某性质）赋予、将…给予\n6. confer: `/kənˈfɜː(r)/` vi. 协商 vt. 授予（学位、奖项、荣誉）\n7. grant: `/ɡrɑːnt/` v. 同意、准予、授予 n. 拨款\n## 版权、授权、批准 - franchise\n\n1. franchise: n./v. 授权（经销权）；选举权\n    1. enfranchise: 给...选举权；解放（奴隶）\n2. pirate: `/ˈpaɪrət/` n. 海盗；盗版者 v. 盗用\n3. entitle: `/ɪnˈtaɪtl/` v. 授权；使有权利、资格；给...题名\n4. concession: `/kənˈseʃn/` n. 让步、妥协；许可、承认；特许经营权\n5. ratify: `/ˈrætɪfaɪ/` v. 正式批准；使正式生效\n6. eligible: `/ˈelɪdʒəbl/` adj. 有资格的\n7. certify: v. 书面证明；办法合格证书\n    1. certificate: `/səˈtɪfɪkət/` n. 证明书；文凭\n    2. certification: `/ˌsɜːtɪfɪˈkeɪʃn/` n. 证明、鉴定的过程\n8. credential: `/krəˈdenʃl/` n. 凭证\n9. ratify: `/ˈrætɪfaɪ/` vt. 批准\n    1. ratification: `/ˌrætɪfɪˈkeɪʃn/` n. 正式批准\n10. voucher: `/ˈvaʊtʃər/` n. 优惠券、代币券、票券凭证\n# 易忘的\n\n1. agitation: `/ˌædʒɪˈteɪʃn/` n. 焦虑不安、烦乱；骚动、煽动\n    1. agitate: v. 煽动、鼓动；使不安、烦乱\n2. **aggravate: vt. 使严重、恶化**\n    1. aggravation: n. 加重、恶化\n    2. aggressive: adj. 入侵的\n        1. invade: v. 武装入侵\n            1. invasive: adj. 侵入的 - invasive cancer 扩散性肿瘤；有创的 - invasive surgery 开刀手术\n3. delinquency: n. 违法行为\n    1. delinquent: adj. 有违法倾向的；欠债的\n4. peel: 扒果皮\n5. flaw: n. 错误；缺陷\n    1. Flaws have appeared in the new version of the software.\n    2. paw: n. 动物的爪\n        1. claw: n. 动物的爪子\n6. franchise: n./v. 授权（经销权）；选举权\n    1. enfranchise: 给...选举权；解放（奴隶）\n7. pine: v. 憔悴；思念；悼念 n. 松树\n8. fare: `/feə(r)/` n. 路费 v. 做事、干；进展\n   bus/taxi fares\n9. whereas: conj. (conjunction) 而, 却；反之\n10. cozy: adj. 亲密无间的、密切的；（尤指因地方小或封闭而）惬意的\n11. consecutive: `/kən'sekjətɪv/` adj. 连续不断的\n12. juvenile: `/ˈdʒuːvənaɪl/` adj. （与）青少年（有关）的\n    Lack of care from parents may give rise to juvenile crime. 父母对孩子缺乏关爱容易引发青少年犯罪。\n    1. avenue: `/ˈævənjuː/` n. 林荫道\n        1. venue: `/ˈvenjuː/` n. 活动场地（如音乐厅、体育比赛场馆、会场）\n13. customs: n. 关税；海关部门\n    1. custom: 习俗\n14. faculty: 学院；全体教学人员\n    1. dean: n. 院长；主任\n15. bracket: n. 括号；同等级的人\n16. intensive: adj. 紧张的 = intense `adj.`\n    1. intensity: n. 剧烈；紧张\n    2. intent: adj. 专注的\n        1. intend: v. 打算；想要\n17. inevitable: `/ɪnˈevɪtəbl/` adj. 必然发生的、不可避免的\n18. feasible: adj. 可行的；现实的\n    1. feasibility: n. 可行性；现实性\n19. deliberate: adj. 故意的 v. 仔细考虑\n    1. liberate: 解放\n20. maneuver: n./v. 机动；谋略；操作、操纵\n    The driver carried out a complex maneuver to pass the narrow lane. 这个司机做出了复杂而精巧的操作通过了这条狭窄的道路。\n    1. rig: `/rɪɡ/` v. （不正当地）操纵；给船装帆、提供索具；安装、装配 **n. 有专门用途的设备、装置**\n21. orient: `/ˈɔːrient/` v. 使朝向（常用于被动语态） = orientate\n    1. oriented: `/ˈɔːrientɪd/` adj. 定向的\n    2. orientation: n. 方向；取向\n22. logistic: `/ləˈdʒɪstɪk/` adj. 后勤相关的 = logistical\n23. quench: v. 解燃眉之急、熄灭火焰；解渴、满足渴望\n24. cult: `/kʌlt/` n. 狂热、崇拜\n25. chronic: `/ˈkrɒnɪk/` adj. 长期的、持续时间很长的；慢性的\n    1. choir: `/ˈkwaɪə(r)/` n. 合唱团\n26. reclaim: `/rɪˈkleɪm/` v. 重新得到；取回、拿回\n27. ethic: `/ˈeθɪk/` n. 道德规范；伦理\n    1. ethnic: `/ˈeθnɪk/` adj. 种族的、民族的\n## 困难词汇\n\n1. endeavour: `/in'devə/` v./n. 努力；勤奋\n   If we acknowledge that human manipulation of the Earth has been a destructive force, we can also imagine that human endeavours can help us build a less destructive world in the centuries to come. 如果我们承认人类对地球的操纵是一种破坏性的力量那么我们也可以想象，人类可以努力在未来几个世纪里建立一个破坏性较小的世界。\n2. envisage: `/ɪnˈvɪzɪdʒ/` v. 想象、设想；面对\n   Nicole didn't celebrate her 30th birthday as she had envisaged. 妮可没有像自己预想的那样去庆祝自己的30岁生日。\n   The plan cost a lot more than we had originally envisaged. 这项计划花费的资金比我们最初预计的要多。\n    1. visage: n. （人的）脸\n3. prestigious: `/preˈstɪdʒəs/` adj. 有威望的\n    1. prestige: `/preˈstiːʒ/` n. 威信\n    2. **preside: `/prɪˈzaɪd/` v. 主持、担任（会议主席）**\n5. dedicate: v. 献出；致力于 - dedication: n. 奉献\n6. reminiscent: `/ˌremɪˈnɪsnt/` adj. 使勾起回忆的\n   That film is so reminiscent of my adolescence. 那部电影勾起了我对青少年时代的无限回忆。\n    1. reminiscence: n. 追忆、回忆\n6. unilateral: adj. 单方面的\n    1. lateral: adj. 侧面的\n        1. flank: n. 侧面 v. 侧面有...；位于...的侧面\n    2. facet: `/ˈfæsɪt/` n. （事物的）方面、部分、特征 = asoect\n    3. unanimous: `/juˈnænɪməs/` adj. 一致的\n7. adolescence: `/ˌædəˈlesns/` n. 青春期\n8. simultaneous: `/ˌsɪmlˈteɪniəs/` adj. 同时的\n    1. **spontaneous**: `/spɒn'teɪniəs/` adj. **自发的，自然产生的**；无意识的；天真率直的\n    2. simulate: `/ˈsɪmjuleɪt/` v. 模拟\n        1. imitate: `/ˈɪmɪteɪt/` v. 模仿\n        2. emulate: `/ˈemjuleɪt/` v. 向...看齐；（计算机）仿真\n9. panorama: `/ˌpænəˈrɑːmə/` n. 全景\n    1. panoramic: `/ˌpænəˈræmɪk/` adj. 全景的\n10. embroider: v. 刺绣\n    1. embroidery: n. 刺绣\n11. benevolence: `/bəˈnevələns/` n. 善良、乐于助人和慷慨的品质\n    1. 词根：bene-: 好的东西\n12. inventory: n. 现有库存清单\n    1. inventory = invent + ory : 发现、发明的东西记个表\n13. gorgeous: `/ˈɡɔːdʒəs/` adj. 华丽的；美丽动人的\n14. excursion: `/ɪkˈskɜːʃn/` n. 短途远足旅行（尤指集体组织）\n15. reconcile: `/ˈrekənsaɪl/` v. 调和；和解\n    1. reconciliation: `/ˌrekənsɪliˈeɪʃn/` n. 调和；和解；和谐一致\n    2. reconciliatory: `/ˌrekən'siliətəri/` adj. 和解的；调和的\n16. itinerary: `/aɪˈtɪnərəri/` n. 行程表、旅行计划\n17. aftermath: `/ˈɑːftəmæθ/` n. （战争、事故、不快事情的）后果\n    A lot of rebuilding took place in the aftermath of the war. 战后进行了大量的重建工作。\n    How does a country cope with the aftermath of war? 一个国家如何处理战后问题？\n18. assimilate: `/əˈsɪməleɪt/` v. 透彻理解、消化、吸收；使同化、融入、接受\n19. hypocrite: `/ˈhɪpəkrɪt/` n. 伪君子、伪善者、虚伪的人\n20. renaissance: `英 /rɪˈneɪsns/ 美 /ˈrenəsɑːns/` n. 复兴；文艺复兴\n21. contingent: `/kənˈtɪndʒənt/` adj. 依情况而定的；偶然的、临时的（约等于depend on） n. 来自同一地方的代表团\n22. conspicuous: `/kənˈspɪkjuəs/` adj. 显眼的、显著的\n## 各种学家: 心理学家、考古学家、哲学家\n\n1. archaeology: 考古学家\n2. philosophical: `/ˌfɪləˈsɒfɪkl/` 哲学的\n3. physiological: `/ˌfɪziəˈlɒdʒɪkl/` adj. 生理学的；生理功能的\n4. psychological: 心理学的\n5. psychiatric: `/ˌsaɪkiˈætrɪk/` adj. 精神病学的\n    1. psychiatrist: `/saɪˈkaɪətrɪst/` n. 精神病专家\n6. physicist: 物理学家\n7. physician: 内科医生\n8. geology: 地理学\n9. zoology: 动物学\n10. astronomy: 天文学\n## 主义\n\n1. optimism: n. 乐观主义 - optimistic: adj. 乐观的\n2. pessimism: n. 悲观主义\n3. cynicism: `/'sɪnɪsɪz(ə)m/` n. 人人自私主义；悲观；玩世不恭（对生活不严肃、不认真）\n4. aesthetic: `英 /iːsˈθetɪk/ 美 /esˈθetɪk/` adj. 美学的；审美的\n5. bureaucracy: `/bjʊəˈrɒkrəsi/` n. 官僚主义\n    1. bureaucratic: `/ˌbjʊərəˈkrætɪk/` adj. 官僚主义的\n## 跟马有关的\n\n1. pony: n. 矮马, 小型马, 25 英镑 v. 用注解书学习；付清、清偿 adj. 小(型)的 - tony tail: 马尾发型\n\t1. toll: `/təʊl/` n. （自然灾害、冲突事故）伤亡人数；过路费\n# equa- / formula-\n\n词根：formula - 方程式、公式、准则、配方\n\n1. equation: 相等、相同；方程式；等式；平衡、综合体（雅思真题：要考虑多种因素的复杂局面、复合体）\n2. formulate: `/ˈfɔːmjuleɪt/` v. 规划、构想；确切表达\n    1. formulation: `/ˌfɔːmjuˈleɪʃn/` n. 规划、构想；配制、制剂；公式化的表达\n# 赌注、股份\n\n1. stake: `/steɪk/` n. 股份；桩；赌注 v. 拿...冒险、打赌\n2. stock: n. 股份；库存；家畜\n3. gamble: v. 冒风险；碰运气；以…为赌注 n. 赌博；打赌；冒险\n    1. ramble: n./v. 漫步；漫谈\n# stain\n\n1. stainless: 不锈的\n2. stain有生锈的意思，本质上，有“污染、染色”的意思\n# roar pour horn moan groan barn growl morn scorn adorn corn\n\n1. roar: 吼叫、咆哮\n2. pour: 倾倒\n3. horn: 动物的角；喇叭、号\n4. moan: 悲叹、呻吟；没原因的抱怨；风的声音；\n5. groan: n. v.（因痛苦）呻吟\n    1. grain: 谷物；颗粒状的东西\n    2. grind: `/ɡraɪnd/` v. 碾碎, 磨碎 n. 苦差事\n6. barn: n. 谷仓；畜棚；仓房\n   The hay barn needs repairing. 干草棚需要修缮。\n    1. bran: 糠\n1. growl: n. v. 低沉的怒吼、咆哮\n2. morn: n. [诗]破晓；[诗]早晨\n3. scorn: v. 蔑视\n4. adorn: v. 装饰\n5. corn: n. 玉米, (脚上的)鸡眼；谷物 v. 腌；使成颗粒\n# chilly冷的 - `*ill*`\n\n1. chill: `/tʃɪl/` n. 寒冷；害怕 v. 使...冰冷；使恐惧 adj. 寒冷的\n2. chilly: `/ˈtʃɪli/` adj. 阴冷的、寒冷的；冷淡的、不友好的\n3. drill: 钻\n# dia-: dairy - diary; diagnose - dialogue\n\n1. dairy: `/ˈdeəri/` n. 乳制品 adj. 乳制的\n2. diary: `/ˈdaɪəri/` n. 日记\n3. diagnose: `/ˌdaɪəɡˈnəʊs/` v. 诊断\n    1. diagnosis: `/ˌdaɪəɡˈnəʊsɪs/` n. 诊断\n4. dialogue: `/ˈdaɪəlɒɡ/` n. 对话\n# sham shed shred shield shelter shun shade cloak shiver shove shrewd\n\n1. sham是假意；伪装；假象；虚假\n2. shed: v. 摆脱；去除；脱落（皮、毛） n. 棚屋\n3. shred: `/ʃred/` v. 切碎；撕碎 n. 细条、碎片；极少量、一丁点\n4. shield是掩体 = shelter\n5. shiver: `/ˈʃɪvə(r)/` v. 颤抖，哆嗦\n    1. shaver: `/'ʃeɪvə/` n. 剃须刀\n6. shun: v. 避开, 回避, 避免\n7. shade: n. 荫凉处，阴影；色调，色度 v. 给…遮挡（光线）；荫蔽\n    1. shady: `/'ʃeɪdi/` adj. 阴凉的，成荫的；非法的，不正当的\n8. cloak: n. 披风，斗篷；遮盖物 v. 遮盖；掩盖\n9. shove: `/ʃʌv/` v./n. 猛推；乱挤\n    1. shovel: `/ˈʃʌvl/` n. 铲\n10. shaft: n. 电梯井；杆、轴\n11. shrewd: `/ʃruːd/` adj. 精明的、敏锐的；高明的\n# 得体的、恰当的、合适的、正常的；中立的\n\n1. decent - decency\n2. moderate - 中等的；温和的\n3. medium - adj. 中等的；适中的 n. 方法；媒介\n    1. mediate: `/ˈmiːdieɪt/` v. 调停；斡旋\n        1. mediator: `/ˈmiːdieɪtə(r)/` n. 调停者\n        2. intermediate: adj. （两极）中间的\n4. Nothing special - 没特色；中规中矩\n5. regular - 正常的；规则的\n6. normal - 一般的\n7. common - 普通的\n    1. Commonwealth: `/ˈkɒmənwelθ/` n. 联邦体；联合体\n        1. federal: `/ˈfedərəl/` adj. 联邦制的\n    2. commonweal: `/'kɒmənwiːl/` n. （网络）公益、大众福利\n        1. weal: `/wiːl/` n. 福利 - weal and woe: 祸福\n            1. wealth: `/welθ/` n. 财富\n8. appropriate: adj. 合适的、适当的、恰当的 **vt. （擅自）挪用**\n    1. **appropriation: n. 盗用**\n    2. approximate: `/əˈprɒksɪmət/` adj. 近似的、大约的\n        1. proximate: `/ˈprɒksɪmət/` adj. （时间、顺序等）最接近的\n9. tactful: adj. 圆滑的、不得罪人的；得体的\n    1. tact: n. 圆滑、老练；得体\n        1. tactic: `/ˈtæktɪk/` n. 策略；手段\n10. apt: `/æpt/` adj. 恰当的、适当的；有...倾向的\n    1. aptly: adv. 适当地\n11. pertinent: `/ˈpɜːtɪnənt/` adj. 恰当的；相宜的、相应的\n12. due: adj. 由于...的；预计的、到期的；（形容钱、物品，sth. is due to sb.）应付给某人的、欠某人的（not before n.）；（形容人，sb. be due for ...）某人应有、应得到...的；**合适的、恰当的**\n    1. undue: `/ˌʌnˈdjuː/` adj. 不适当的；过度的\n# potent - potential - essential - patent\n\n1. potent: adj. 有力的；烈性的\n   This is a very potent drug with little side-effect. 该药效力很强，而副作用小。\n    1. potency: n. 效力, 影响力, 支配力\n    2. patent: n. 专利 adj. 专利的；新奇的；显然的 v. 获得专利\n2. potential: adj. 潜在的 n. 潜在性、可能性\n3. essential: 关键的\n    1. criticize: 批判 - critical: 批判性的；关键的（relating to or denoting a point of transition from one state to another. 关于或表示从一种状态到另一种状态的过渡点）\n# hint - hire - hut - hunt\n\n1. hint - 暗示\n    1. clue - 线索；提示\n2. hire - 租赁 - fire - 解雇\n    1. lease: `/liːs/`n. 租约，租契 v. 租用，租借，出租\n        1. lessee: `/le'siː/` n. 承租人, 租户\n3. hut: 小屋\n4. hunt: v./n. 猎捕；搜寻\n# 猎物；掠夺\n\n1. hunt: v./n. 猎捕；搜寻\n2. hound: `/haʊnd/` n. 猎犬；猎狗 v. 纠缠，不断骚扰\n3. prey: `/preɪ/` vi. 捕食 - prey on ; n. 受害者；猎物 - be/fall prey to/for sth. 受...的坏影响\n4. predator: `/ˈpredətə(r)/` n. 捕食者；掠夺者\n# monotonous - consonant\n\n1. monotonous: adj. 单调乏味的\n    1. monotone: adj. 单调的 n. 单调；单音调 vt. 单调地读\n2. consonance: n. 一致、协调；协和音程\n    1. consonant: adj. 一致的、和谐的 n. 辅音；辅音字母\n        1. vowel: 元音；元音字母\n# obesity - obedient - observe - obsess\n\n1. obesity: 肥胖症\n2. obedient: 服从的\n    1. obey: 服从\n        1. comply: `/kəmˈplaɪ/` vi. 遵守、服从\n            1. compliance: `/kəmˈplaɪəns/` n. 遵守、服从\n        2. conform: `/kənˈfɔːm/` vi. 随波逐流；遵从、服从；相符合\n3. observe: v. 观测、观察、监视；遵守\n    1. serv-, -serve【拉丁】表示“看”；“维护，保护”\n       词根助记：observance: ob (=ab 去，对) + serv = 去遵守(惯例，仪式)\n       同根词conservation|conservative|deserve|observation|observe|preserve|reserve|observance|\n    2. observance: n. 遵守(规则、传统)；(宗教的、正式的)仪式、惯例\n        1. ritual: `/ˈrɪtʃuəl/` n. 仪式；礼节程序 adj. 例行公事的\n            1. ritualism: `/'rɪtjʊəlɪzəm/` n. 仪式主义\n4. obsess: `/əbˈses/` vt. 使痴迷 vi. 挂念；担心\n   A lot of young girls obsess about their weight. 许多年轻女孩都过于担心自己的体重。\n    1. obsessive: adj. 痴迷的\n    2. captive: adj. 被俘获的 n. 俘虏\n        1. captivating: adj. 迷人的、有吸引力的\n    3. seduce: `/sɪˈdjuːs/` v. 诱骗\n        1. seduction: `/sɪˈdʌkʃn/` n. 诱惑力、魅力\n    4. fascinate: `/ˈfæsɪneɪt/` v. 深深吸引；使着迷\n    5. beckon: `/ˈbekən/` v. 招手吸引、诱惑\n    6. indulge: `/ɪnˈdʌldʒ/` v. 沉迷于 vt. 放纵某人、某事\n# transverse - traverse\n\n1. transverse: `/ˈtrænzvɜːs/` adj. 横向的；横断的；横切的\n2. traverse: `/trəˈvɜːs/` v./n. 横穿\n# 蒸发、蒸汽、喷发\n\n1. vapor: 蒸汽\n2. evaporate: 蒸发、消失\n    1. evaporation: 蒸发\n    2. evacuate: v. 疏散、撤离\n        1. evade: `/ɪˈveɪd/` v. 躲避、逃避\n3. steam: 蒸汽\n4. volcano: 火山\n5. erupt: 喷发、爆发\n    1. eruption\n# span - spin - skin\n\n1. span: n. 一段时间；持续时间 v. （时间）持续；跨越 - life span: 寿命\n# 议题、宣布: issue - manifesto\n\n1. issue: n. 发行物；问题 v. 发行\n2. manifesto: n. 宣言\n\t1. manifest: v. 清楚表明；显示\n    \t1. manifestation: n. 显现、显灵；表现\n# pecu - speculate - articulate - singular - odd - stipulate - queer\n\n1. peculiar: adj. 古怪的；特有的\n    1. peculiarity: 怪癖；怪异；特点\n    2. singular: adj. 单数的；奇特的、异常的\n        1. singularity: n. 异常、奇特；（数学、物理）奇点（黑洞中心）\n    3. odd: adj. 怪异的；奇数的、单数的\n        1. oddity: n. 怪异现象\n    4. queer: adj. 奇怪的、反常的；gay的、娘的\n2. **speculation: n. 猜测；投机买卖**\n    1. speculative: adj. 猜测的、揣摩的\n3. articulate: v. `/ɑːˈtɪkjuleɪt/` 流利地表达 adj. `/ɑːˈtɪkjələt/` 善于表达的\n4. stipulate: v. `/ˈstɪpjuleɪt/` 规定；明确要求\n    1. stipulation: `/ˌstɪpjuˈleɪʃn/` n. 规定；明确要求\n# counter- 对立: controversy\n\n1. counterpart: 对立的人；对应的人；（职位、作用）相当的人\n2. counteract: `/kənˈspaɪə(r)/` v. 抵制、抵抗；抵消\n3. encounter: v. 遭遇；与…发生冲突 n. 遭遇；冲突\n    1. em-,en-【希腊】进入，向内；使成为\n       词根助记：encounter: en进入+ counter对立= 进入对立状态= 遭遇，冲突\n       同根词encounter|enlighten|\n    2. contra-, contro-, counter, contre-【拉丁】对立\n       同根词encounter|contradiction|contrast|contradict|counterpart|contradictory|contraband|\n3. **contrast: n. 反差**\n    1. **contract: n. 合同、契约 v. 收缩、缩紧**\n        1. contradict: v. 反驳、否认\n            1. contradiction: n. 矛盾、对立\n4. contrary: adj. 相反的，截然不同的 n. 相反 - on the contrary正相反\n5. controversy: n. 争论、争议\n    1. controversial: adj. 引起争论的、有争议的\n6. antagonist: `/ænˈtæɡənɪst/` n. 对手；敌人\n    1. foe: n. 敌人\n    2. opponent: `/əˈpəʊnənt/` n. 对手；敌人\n# explore - explode/explosion - expedition - expedience\n\n1. explore: 探索（险）\n2. expedition: 探险\n3. explode - explosion - 爆炸\n    1. blast: n. & v. 爆炸 - blasted: adj. 可恶的\n4. expedience: n. 方便，私立，权宜之计；不得已而做的事情\n   for expedience‘s sake 权宜之计\n    1. As a matter of expedience, our company will not recruit new staff this year. 出于权宜之计，我们公司今年不再招聘新员工。\n# mosque - mosquito - monastery\n\n1. mosque: 清真寺\n2. mosquito: 蚊子\n3. monastery: n. 修道院；庙宇\n# 可观的、大量的、巨大的、一群\n\n1. spectacle: 壮观景象 - spectacular adj. 壮观的\n2. considerable: 大量的 - considerably: 相当地；非常 - inconsiderable: 微小的；价值低的；不值得考虑的\n    1. considerate: 体谅的；考虑了的；考虑周全的 - inconsiderate: 考虑不周的\n3. abundant: `/əˈbʌndənt/` adj. 大量的\n    1. abandon: `/əˈbændən/` 遗弃\n    2. redundant: `/rɪˈdʌndənt/` adj. 被裁减的；多余的\n        1. redundancy: n. 裁员、解雇；冗余\n4. myriad: adj. 无数的 n. 无数；大量\n5. plentiful\n6. extensive: adj. 大量的\n7. enormous: 巨大的、庞大的\n8. overwhelming: adj. 巨大的；压倒性的、无法抗拒的 - overwhelmingly: adv. 压倒性地\n9. fabulous: `/ˈfæbjələs/` adj. 巨大的；极好的\n10. chunk: n. 相当大的部分、数量；大块\n11. substantial\n12. monumental: adj. 重要的、意义深远的、不朽的；非常大的\n    1. monument: n. 纪念碑；典范\n    2. instrumental: `/ˌɪnstrəˈmentl/` adj. 起重要作用的；器乐的\n13. magnitude: n. 巨大\n14. immense: adj. 极大的；巨大的\n    1. immensely: adv. 极大地；极端地\n    2. immensity: n. 巨大\n15. immerse: v. 沉浸\n    1. immersion: n. 沉浸；专心\n## 团、群: mass - swarm - regiment\n\n1. mass: n. 一大群；大量\n    1. massive: adj. 大而重的；结实的\n    2. massacre: `/ˈmæsəkə(r)/` n./v. 大屠杀\n        1. slaughter: `/ˈslɔːtə(r)/` n./v. 屠宰、屠杀\n    3. mess: n. 杂乱\n2. swarm: n. 一大群（蜜蜂等昆虫）, 一大批（向同方向移动的人） v. 成群地来回移动, 成群地飞来飞去\n3. regiment: n. （军队的）团；一大群人（或事物）\n4. multitude: n. 大量；一大群人\n5. flock: n. 一群 v. 蜂拥而至\n    1. block: n. 一大块\n6. herd: n. 兽群 - a herd of: 一群\n    1. hurdle: n. 跨栏比赛中的栏架\n    2. herb: n. 药草；草本植物\n        1. herbal: adj. 药草的\n# 考虑\n\n1. ponder: v. 沉思；琢磨；考虑\n    1. fond: adj. 喜欢的；渴望的 - fonder（比较级）\n2. consider: v. 考虑\n3. contemplate: v. 考虑\n    1. contemplative: `/kənˈtemplətɪv/, /ˈkɒntəmpleɪtɪv/` adj. 深思熟虑的\n    2. contemplation: `/ˌkɒntəmˈpleɪʃn/` n. 深思、沉思；凝视\n    3. contempt: n. 轻视，蔑视；耻辱\n4. given: prep.(preposition) 考虑到；鉴于 adj. 既定的\n   Given his age, he's a remarkably fast swimmer. 考虑到他的年龄，他可称得上是个很出众的游泳选手了。\n# -ct-\n## -spect-、-cular\n\n1. spectacle: 壮观景象 - spectacular adj. 壮观的\n2. spectrum: n. 光谱，声谱，频谱；范围，幅度；系列，层次\n3. prospect: n. 可能性、希望；前景、前途 vi. 勘探；勘察\n## reluctant\n\n1. reluctant: 不情愿\n   The arrogant runner conceded defeat reluctantly. 这位傲慢的跑步运动员很不情愿地承认了失败。\n    1. reluctance: n. 不情愿\n## punctual - punctuality\n\n1. punctual: adj. 准时的，守时的；精确的\n\t1. punctuality: n. 严守时间, 敏捷\n\t   punctuality is a precious quality: 守时是一种珍贵的品质。\n2. punctuate: 打断；加标点\n\t1. punctuation: 标点符号；打断\n\t2. perpetuate: `/pəˈpetʃueɪt/` v. 使持久化\n# 正直；垂直: erect - vertical - upright\n\n```\nrecti-, rect-【拉丁】表示“正，直”；“引导”；“统治”\n词根助记：erection:e上+rect=直立向上\n同根词correct|correction|direct|direction|director|erect|incorrect|erection|\n```\n1. erect: v. 建立；建造；竖起 adj. 垂直的，竖直的，直立的\n    1. vertical: adj. 垂直的\n    2. upright: `/ˈʌpraɪt/` adj./adv./n. 直立的；（人）正直的、诚实的\n    3. erection: n. 建造; 竖立; 竖立物; 建筑物\n\n# 预兆、预先、预言、预测\n\n1. herald: `/ˈherəld/` vt. 是...的预兆、预示着... n. 预兆\n2. predict: 预测\n3. presume: v. 推测；假设\n4. proforma: adj. 预计的 n. 估价单\n5. presentiment: n. 预感, （尤指）不祥之感\n6. propose: v. 计划；提议；求婚 - proposal: n. 提出、提议；计划；提案；求婚\n7. prospect: n. 可能性、希望；前景、前途 vi. 勘探；勘察\n    1. late Middle English (as a noun denoting the action of looking towards a distant object): from Latin `prospectus ‘view’`, from `prospicere ‘look forward’`, from `pro- ‘forward’` + `specere ‘to look’`. Early use, referring to a view of landscape, gave rise to the meaning ‘mental picture’ (mid 16th cent.), which led to the meaning ‘anticipated event’.\n8. earmark: v. 指定（款项）用途；预先安排（要做的事）；确定（未来发生的事） n. 标记；特征\n9. prophet: n. 预言家, 先知\n    1. Middle English: from Old French `prophete`, via Latin from Greek `prophētēs ‘spokesman’`, from `pro ‘before’` + `phētēs ‘speaker’` (from `phēnai ‘speak’`).\n# 提出\n\n1. propose: v. 计划；提议；求婚 - proposal: n. 提出、提议；计划；提案；求婚\n2. present: v. 呈现；介绍；提出；赠送 adj. 出席的；现在的 n. 现在；礼物；瞄准\n    1. presence: n. 出席\n    2. presentation: n. 提供；显示；外观；授予（物）；赠送（仪式）；报告；表演\n3. lodge: `/lɒdʒ/`v. （向机构）正式提出（声明）；借宿，租住；为...提供住宿；寄存，存放，使固定、嵌入 n. 传达室、管理员室；门房, 旅馆；乡间小屋\n4. sponsor: n. 赞助者；（法案的）发起者 v. 赞助；发起（提案、议案）\n\t1. patronage: `/ˈpeɪtrənɪdʒ/` n. 赞助；惠顾 = sponsorship\n    \t1. patron: `/ˈpeɪtrən/` n. 赞助者、资助人\n        \t1. patronize: `/ˈpeɪtrənaɪz/` v. 摆出高人一等的派头\n        \t2. patrol: `/pəˈtrəʊl/` n./v. 巡逻\n    2. endow: `/ɪnˈdaʊ/` v. 资助、捐赠；给予、赋予；具有\n    3. subsidize: `/ˈsʌbsɪdaɪz/` v. 资助\n        1. subsidy: `/ˈsʌbsədi/` n. 政府补贴、补助金\n    4. spouse: n. 配偶 - spouses: n. 夫妇 - spousal: n. 结婚\n    \t1. 拉丁词根：spous-: 新郎；新娘；订婚\n# even\n\n1. even: adv. 甚至 adj. 平坦的；均匀的；双数的，偶数的 v. 使平坦、平均 - evenly: adv. 均匀地；公平地\n    1. uneven: 不平坦的；凹凸不平的；不规则的\n# surrender - surround\n\n1. surrender: v./n. 屈服；让步；投降\n    1. give up\n2. surround: 围绕\n# host - hostile - hustle - hasten - retaliate\n\n1. host: 主人\n2. hostile: 怀有敌意的\n    1. hostility: n. 不友善；敌意\n3. hustle: v. 推搡；催促 - 类似于urge\n4. haste: n. 匆忙；急忙；轻率 vi. 匆忙；赶紧 vt. 赶快\n    1. hasty: adj. 仓促完成的, 急忙的, 急速的；草率的, 轻率的\n        1. nasty: adj. 糟糕的\n    2. hasten: `/'heɪsn/` v. 促进, 急忙进行, 赶紧说（或做）, 使加快\n5. retaliate: `/rɪˈtælieɪt/` vi. 报复、复仇；反击\n    1. retaliation: `/rɪˌtæliˈeɪʃn/` n. 报复\n    2. revenge: `/rɪˈvendʒ/` n. 复仇、报复\n        1. vengeance: `/ˈvendʒəns/` n. 报仇、复仇\n# blunt\n\n1. blunt: adj. 钝的；率直的\n    1. bluntly: 直截了当地\n# hare - bare\n\n1. hare: n. 野兔 v. 飞跑；疾走\n2. bare: adj. 光秃秃的, 无遮蔽的；赤裸的；刚好够的, 勉强的\n# 轮廓；外形；概述\n\n1. profile\n2. generalization\n3. figure\n    1. 图形；数字；体形；画像\n    2. 计算；认为；描绘 - figure out\n4. embody: `/ɪmˈbɒdi/` v. 使具体化；体现\n   She embodies her principles in her behavior. 她把自己的原则体现在行动中。\n    1. embodiment: n. 典型；化身\n# 评估；评价\n\n1. evaluate - evaluation\n    1. elevate: vt. 举起；提升；振奋情绪等；提升…的职位\n    2. evacuate: v. 撤离、撤出；转移、排空\n2. estimate\n3. rate\n# deduce - conclude - conduce - exclude - induce - include - delusive\n\n```\nclud-,clus【拉丁】表示“关”\n词根助记：exclude:ex外+clud关=关在外面=排除在外\n同根词preclude|conclude|exclude|seclude|occlude|\nclud-, claud-, claus-, clos-, -clude, -clois, -cluding, -cluded, -clus, -clusion, -clusive【拉丁】关闭\n词根助记：exclude:ex外+clud关=关在外面=排除在外\n同根词preclude|cloister|close|conclude|conclusion|exclude|include|\n```\n1. deduce: v. 推断, 演绎, 推论\n    1. 易混词：deduct: vt. 扣除，减去；演绎\n    2. deduction: n. 扣除, 减除；扣除的量；推演, 推理；结论\n2. conclude: vt. 结束；推断；决定，作结论 vi. 决定；推断；断定\n3. conduce: `/kən'djuːs/` vi. 有益于、导致\n    1. conducive: adj. 有益于...的；使...容易发生的\n4. exclude: v. 不包括，排除；排斥\n    1. include: 包括\n    2. exclusive: adj. 专有的；排外的 n. 独家新闻、独家报道\n        1. exclusivity: n. 排他性；专有权；独特性\n5. induce: v. 诱使，引诱；引起，导致；催生\n    1. inducement: n. 诱因；刺激\n    2. lure: `/lʊə(r)/` v./n. 诱惑、引诱；饵\n       The lure of fame and money tends to make people commit crimes. 名与利的诱惑可能会引人犯罪。\n        1. allure: `/əˈlʊə(r)/` n. 诱惑力、吸引力\n    3. incent: vt. 刺激...采取行动；激励\n        1. incentive: `/ɪnˈsentɪv/` n. 刺激、激励；激励奖金、激励性减免优惠、让利\n1. include: v. 包括 - inclusive: adj. 包含在内的；包罗万象的，范围广泛的\n2. delusive: adj. 欺瞒的；使迷惑的\n    1. early 17th cent.: from Latin `delus- ‘mocked’`, from the verb `deludere ‘to mock’`, (from `de- (with pejorative force)` + `ludere ‘to play’`) + -ive.\n# demand - demonstrate - demographic\n\n1. demand: v./n. 要求；需要\n2. demonstrate: v. 演示；演示；证明；示威\n3. demographic: `/ˌdeməˈɡræfɪk/` n. 人口统计数据 adj. 人口学的\n4. amend: `/əˈmend/` v. 修正；修订；赔偿、赔罪\n# 严厉、严苛、严重；庄严、尊严\n\n1. harsh: 严酷的；恶劣的；粗糙的\n   Harsh weather conditions shaped people's lifestyles. 恶劣的天气状况塑造了人们的生活方式。\n2. severe\n3. cruel\n4. rough\n5. tough\n6. rigor: n. 严谨、严格、严厉；艰辛、严酷\n    1. rigorous: adj. 谨慎的；细致的；严格的；严厉的\n    2. rigid: adj. 严格的；僵硬的，死板的；坚硬的；精确的\n7. grim: adj. 严肃的、严酷的、严苛的、无情的；令人沮丧的、令人担忧的\n8. solemnity: `/səˈlemnəti/` n. 庄严、郑重\n9. sober: `/ˈsəʊbə(r)/` adj. 没喝醉的；冷静的、清醒的 v. 使冷静\n3. dignity: `/ˈdɪɡnəti/` n. 庄重、庄严、尊严；尊贵、高贵、高尚\n# 礼貌\n\n1. courtesy: `/'kɜːtəsi/` n. 礼貌，谦恭；客气话 adj. 免费使用的; 出于礼节的\n    1. Middle English: from Old French `cortesie`, from `corteis`, based on Latin `cohors ‘yard, retinue’`.\n    2. court: `/kɔːt/` n. 法院\n2. manner: n. 方式, 方法；态度；礼貌, 规矩；(人或物的)种类\n# -ff\n\n1. stiff: adj. 不易弯曲的；硬的；挺直的；僵硬的 adv. 非常；极其 v. 不给小费\n2. cliff: n. （常指海洋边的）悬崖\n3. scoff: v. 嘲笑；讥讽；狼吞虎咽\n## stuff - staff = crew\n\n1. stuff: `/stʌf/` n. 东西\n2. staff: `英 /stɑːf/ 美 /stæf/` n. 全体员工\n    1. crew: `/kruː/` n. 全体工作人员\n        1. brew: v. 酿造（啤酒）\n            1. brewery: `/ˈbruːəri/` n. 啤酒厂\n        2. screw: `/skruː/` v. 用螺丝固定、拧紧 n. 螺丝钉\n            1. shrewd: `/ʃruːd/` adj. 精明的、敏锐的；高明的\n# 心情、情绪\n\n## 愤怒、怨恨\n\n1. resent: `/rɪˈzent/` vt. 对…感到愤怒\n    1. resentful: adj. 感到愤恨的\n2. irritation: `/ˌɪrɪˈteɪʃn/` n. 刺激；刺激物；激怒\n    1. irritate: v. 使烦恼；刺激\n    2. irrigation: n. 灌溉\n    3. agitation: `/ˌædʒɪˈteɪʃn/` n. 焦虑不安、烦乱；骚动、煽动\n3. outrage: n. 愤怒；暴行 v. 激怒\n    1. rage: `/reɪdʒ/` n. 暴怒、狂怒 v. 猛烈进行\n4. grudge: n. 怨恨；嫌隙 v. 不情愿地做...\n5. malice: `/ˈmælɪs/` n. 恶意；怨恨\n    1. Middle English: via Old French from Latin `malitia, from malus ‘bad’`.\n    2. spite: `/spaɪt/` n. 恶意；怨恨 = malice\n        1. in spite of: 尽管；不管、不顾\n    3. malicious: adj. 恶意的\n    4. **menace: `/ˈmenəs/` n. 威胁；危险的人**\n6. vex: vt. 使烦恼；使苦恼；使生气\n7. exasperate: v. 使烦恼、使恼怒 adj. 被激怒的\n   asper【拉丁】粗糙；困难\n   同根词exasperate|asperity|exasperation|exasperated|\n8. dismay: n. 沮丧，绝望，灰心 v. 使惊愕；使灰心，使失望\n    1. frustrate: v.（尤指因无法改变或实现某事而）使心烦；使恼怒\n      The frustrating thing about innovation is that there are many approaches, but no magic formula. 关于创新令人沮丧的是，创新有很多方法，却没有那种奇妙的程式方案。\n    2. infrastructure: n. 基础设施\n9. distress: n. 痛苦；悲伤 v. 使悲伤；使苦恼\n10. disdain: v. 蔑视\n    1. scorn: 蔑视\n        1. scold: v. 骂, 责备, 数落, 奚落\n## 焦虑、烦恼、痛苦、担忧、忧虑、哀悼\n\n1. weo: n. 麻烦；问题；痛苦、苦恼；悲伤\n    1. woeful: adj. 糟糕的；严重的；不合意的；悲惨的\n        1. nasty: `英 /ˈnɑːsti/ 美 /ˈnæsti/` adj. 糟糕的\n        2. atrocious: `/əˈtrəʊʃəs/` adj. 糟糕的\n    2. thorny: `/ˈθɔːni/` adj. 棘手的、麻烦的；有刺的\n2. anxiety: n. 焦虑\n3. agony: n. 极度痛苦 - agonize: v. 苦苦思索；焦虑不已\n    1. annoy: vt. 使恼怒、使生气\n        1. anonymity: n. 匿名\n            1. anonymous: adj. 匿名的\n4. perturb: v. 使焦虑；使不安 - perturbed: adj. 焦虑的\n5. dread: v. 害怕；担心 n. 恐惧\n    1. dreadful: adj. 糟糕的；可怕的；极其的\n6. vex: v. 使恼火, 使烦恼, 使忧虑\n7. fluctuate: vi. 波动；起伏\n\t1. fluctuation: n. 波动,涨落,起伏\n\t2. punctuation: 标点符号；打断\n        1. punctuality: 敏捷；准时\n8. preoccupy: v. if something is preoccupying you, you think or worry about it very often or all the time 使日夜思考；使忧心忡忡\n   Thoughts of failure preoccupied him. 失败的想法困扰着他。\n9. grieve: `/ɡriːv/` v. 为...伤心、哀悼\n    1. grief: n. 悲伤、哀悼\n10. harassment: n. `/ˈhærəsmənt/` 侵扰；骚扰\n    1. racial/sexual harassment 种族侵扰；性骚扰\n    2. hound: v. 纠缠；不断骚扰\n    3. plague: `/pleɪɡ/` vt. 折磨、纠缠 n. 瘟疫\n    4. ordeal: n. 折磨、磨难\n11. inflict: vt. 使...遭受（不快、痛苦）\n12. awe: `/ɔː/` v. 使敬畏、畏怯\n    1. awful: adj. 可怕的\n    2. awesome: adj. 令人敬畏的、惊叹的\n13. appall: v. 使大为震惊、惊骇\n    1. appalling: adj. 令人震惊的；骇人听闻的\n    2. startle: `/ˈstɑːtl/` v. 使惊吓、使吓一跳、使大吃一惊\n14. anguish: `/ˈæŋɡwɪʃ/` n. 痛苦\n15. rattle: v. 使紧张、恐惧；使咔哒作响 n. 咔哒声\n16. frantic: `/ˈfræntɪk/` adj. （由于恐惧或担心）无法控制感情的，发狂似的；手忙脚乱的\n## hate\n\n1. hate: v. 仇恨；憎恨；厌恶\n2. hatred: n. 仇恨；憎恨；厌恶\n## 抱怨: murmur - mutter - grudge - complain - plague\n\n1. murmur: v. 抱怨\n2. mutter: v. 咕哝地抱怨；轻声低语\n3. grudge: n. 怨恨, 积怨, 嫌隙 v. 勉强做, 不情愿地给, 吝惜, 认为…不应得到\n4. complain: v. 抱怨；发牢骚\n5. plague: `/pleɪɡ/` n. 瘟疫 vt. 折磨、纠缠\n    1. outrage: n. 愤怒；暴行 v. 激怒\n        1. rage: `/reɪdʒ/` n. 暴怒、狂怒 v. 猛烈进行\n    2. grudge: n. 怨恨；嫌隙 v. 不情愿地做...\n# irr-、re-\n\n1. resist: v. 抵抗、抵制\n    1. resistible: adj. 可抵抗的\n2. irresistible: adj. 不可遏止的, 无法抵制的, 极诱人的, 忍不住想要的\n## 合理: rational - irrational - plausible\n\n1. rational: adj. 合理的\n    1. plausible: adj. 似乎合理的\n        1. 词根：plaus-: (拉丁) 认可地鼓掌\n2. irrational: adj. 不合理 n. 无理数；无理性的生物\n## 愤怒: irritation\n\n1. irritation: 愤怒\n# 自负、傲慢: conceit - arrogant - concept - conceive - deceive - complacent\n\n1. conceit: n. 自负；狂妄；幻想 vt. 幻想\n2. conceited: adj. 自负的；骄傲自大的\n    1. arrogant: 傲慢的\n        1. arrogance: n. 傲慢、自大\n3. concept: n. 概念\n    1. notion: n.概念；观念；看法，见解\n4. conceive: v. 构想、设想\n    1. deceive: `/dɪˈsiːv/` v. 欺骗；误导\n5. haughty: adj. 傲慢的；高傲自大的\n6. complacent: `/kəmˈpleɪsnt/` adj. 过于自满的\n# infant\n\n1. infant: `/ˈɪnfənt/` n. 婴儿；幼儿 adj. 婴儿的；初期的\n2. infantry: n. （统称）步兵\n# hypothesis - hypothetical\n\n```\nhypo-, hyp-【希腊】前缀；在……之下；比……少；不足的\n同根词hypothesis|hypocrisy|adenohypophysis|\n\nthe-; them-, themat-, thes-, thet-【拉丁】表示“放置”\n同根词hypothesis|anathema|antithesis|apothecary|boutique|epithet|hypothetical|\n```\n\n1. hypothesis: `/haɪ'pɒθəsɪs/` n. 假设, 假说; (凭空的)猜测\n    1. 复数：hypotheses\n2. hypothetical: `/ˌhaɪpəˈθetɪkl/` adj. 假设的\n# prescribed - prescription\n\n```\nprescription = pre(之前) + script(scribe = write写) + tion,“在抓药之前先给你写出来的东西”，处方\n```\n\n1. prescribed: v. 规定；开药方（“prescribe”的过去式和过去分词） adj. 规定的\n2. prescription: n. 药方；开处方；诀窍；秘诀\n# 雕刻、雕塑\n\n1. carve: v. 雕刻，切割\n    1. crave: v. 渴望；恳求\n2. sculpt: v.雕塑 - sculpture n. 雕像，雕塑品；雕刻术，雕塑术\n    1. statue: n. 雕像；塑像；铸像\n        1. stationary: adj. 不动的、静止的\n        2. stationery: n. 文具；信纸\n# cord-\n\n`cor-`、`cord-`、`cour-`在拉丁语中表示“心”(core核心)，`-ial`表示形容词后缀\n\n1. cord: n. 绳索；粗线；电线 = rope\n2. cordial: `英/ˈkɔːdiəl/ 美/ˈkɔːrdʒəl/` adj. 热情友好的; 真心的, 由衷的 n. 甜果汁饮料; 烈性甜酒; 兴奋剂\n3. accord: ac(朝向)+cord(心)=心向着一个方向=使一致\n4. concord: con一起+cord心=大家齐心=和睦，公约\n# agree\n\n1. agreed: adj. 已一致的\n2. agreeable: adj. 欣然同意的；令人愉快的，惬意的\n    1. 近 - 反：accordant - discordant；consistent - inconsistent\n# device - devise\n\n1. device\n2. devise: `/dɪˈvaɪz/` v. 设计; 发明; 策划\n# sullen\n\n1. sullen: adj. 闷闷不乐的，郁郁寡欢的；（天空或天气）阴沉的\n# haunt\n\n1. haunt: v. 萦绕于脑际（余音绕梁）；缠扰 n. 常去的场所，消磨时光的去处\n    1. linger: `/ˈlɪŋɡə(r)/` vi. 徘徊；磨蹭；余音绕梁、仍有阴影\n    2. Let's meet at the haunt. 老地方见。\n    3. haunted: adj. 闹鬼的，反复出现的\n    4. haunting: adj. 萦绕心头的\n        1. a haunting melody 萦绕心头的曲调\n# genius - genuine\n\n1. genius: `/ˈdʒiːniəs/` n. 天才\n    1. ingenious: `/ɪnˈdʒiːniəs/` adj. 精巧的；心灵手巧的\n2. genuine: `/ˈdʒenjuɪn/` adj. 真实的；真正的；诚恳的\n# 卫生 - hygiene - sanitary - insane\n\n1. hygiene: n. 卫生\n    1. hygienic: adj. 卫生的\n2. sanitary: adj. 卫生的；环境卫生的；公共卫生的；清洁的 n. （有卫生设备的）公共厕所\n\t1. sal, san【拉丁】表“健康, 健全”；“福利”\n\t   同根词salute|insane|salutary|sane|sanitary|sanity|insanity\n\t2. insane: adj. 精神失常的；愚蠢的\n\t\t1. insanity: n. 精神失常；十分愚蠢的行为\n\t\t2. inmate: `/ˈɪnmeɪt/` n. 同住者；同狱犯人；同病房病人\n\t3. sanctuary: n. 避难所；保护区\n    \t1. refuge: `/ˈrefjuːdʒ/` n. 避难；庇护\n        \t1. refusal: n. `/rɪˈfjuːzl/` n. 拒绝\n    \t2. shelter: n. 掩体；避难所 v. 躲避；保护\n    \t3. haven: `/ˈheɪvn/` n. 避难所；保护区 - tax haven: 避税区\n3. foul: `/faʊl/` adj. 含有（或充满）有害物质的；令人恶心的；难闻的，恶臭的\n   His boss has a foul temper. 他的老板脾气很坏。\n4. filth: n. 污物，污秽；下流言辞；淫秽书刊\n\t1. filthy: adj. 肮脏的、污秽的 adv. 肮脏地；富得流油地\n5. stale: 不新鲜的\n6. odour = (US) odor: `/ˈəʊdə(r)/` n. 气味（尤指臭味）\n# blot - spot - slot - plot\n\n1. spot: n. 污点；地点、场所；少量  vt. 看出、认出  v. 弄上污渍\n2. blot:  n. 污点；耻辱  v. 吸干、擦干；弄脏、污损；使蒙耻\n    1. Blot it dry with a tissue. 用纸巾把它吸干。\n    2. blotter: 吸墨纸板；吸墨用具；（警察管区的）拘捕记录\n3. slot: n. 空位；插槽、槽位；（节目表的）一档位置 v. 插入、塞入\n4. plot: n. 情节；密谋\n# 主张: profess - confess - contend\n\n1. profess: `/prə'fes/` v.\n    1. to claim that something is true or correct, especially when it is not: 妄称；伪称；声称\n    2. to state openly that you have a particular belief, feeling, etc.: 宣称；公开表明\n    3. **profession: n. 职业；行业、领域（的同行）**\n2. confess: v. 供认；坦白\n3. contend: `/kənˈtend/` vt. 声称、主张、认为、辩论（约等于argue） vi. 竞争、争夺\n# 指责；责骂\n\n## 指责、谴责；责备\n\n1. rebuke: `/rɪˈbjuːk/` v./n. 指责；批评\n    1. 多指上级对下级进行的公开、强烈、严正而不宽容的责备。隐含一定权威的意味。\n2. blame: v./n. 把...归咎于；责怪、指责\n    1. 语气较弱。指一般的责难、归咎，不含责骂之意。\n3. condemn: `/kənˈdem/` \n    1. 正式用词，表示谴责，有较强的司法意味，侧重从道义或原则上的谴责。\n4. denounce: `/dɪˈnaʊns/` v. 公开指责\n    1. 与condemn同义，但着重公开性。\n5. reproach: `/rɪˈprəʊtʃ/` n./v. 责备\n    1. 侧重指因他人粗心、自私等引起不满而去指责、找岔。\n    2. The look of reproach on his mother's face made Tom feel guilty. 妈妈脸上责备的表情令汤姆愧疚不已。\n## 责骂\n\n1. scold: `/skəʊld/` \n    1. 普通用词，多指上级对下级、长辈对后辈或雇主对雇员的态度粗暴、言词激烈的数落。\n    2. scorn: `/skɔːn/` n./v. 蔑视\n2. swear: `/sweə(r)/` v. 咒骂；发誓\n    1. 过去式: swore\n# 仅；勉强；不过\n\n1. merely: 仅仅；只不过\n2. solely: adv. 只, 仅, 唯, 单独地\n    1. solemnity: `/səˈlemnəti/` n. 庄严、郑重\n3. barely: adv. 勉强才能；几乎不能\n# embrace - gratify\n\n1. embrace: v. 欣然接受；拥抱；包含 n. 拥抱\n2. gratify: v. 使高兴, 使满意, 满足（愿望、需要等）=satisfy\n# ambiguity - ambiguous\n\n1. ambiguity: n. 歧义, 模棱两可, 不明确, 一语多义\n2. ambiguous\n# -tain\n\n1. sustain: v. 维持；承受，经受；支持\n# threat - theater - theatrical - theoretical\n\n1. threat: `/θret/` n. 恐吓、威胁\n    1. threaten: `/ˈθretn/` v. 恐吓、威胁\n        1. intimidate: `/ɪnˈtɪmɪdeɪt/` v. 恐吓、威胁\n2. theater: theatre = theater - theatrical 剧场的、夸张的 = dramatic\n3. theoretical: adj. 理论的；理论性的；理论上的\n# prevail - prevalent\n\n1. pr**e**vail: v. 流行；占优势、上风\n    1. pr**ivi**lege: n. 特权、特殊待遇\n    2. prevalent: adj. 流行的，盛行的；普遍的\n2. medieval: 中世纪的\n# 几何类、数学\n\n1. elliptical: adj. 椭圆的；省略的；隐晦的\n2. hemisphere: n. 半球\n3. diameter: n. 直径\n4. symmetry: n. 对称；相似；相等 - symmetrical: adj. 对称的\n5. perpendicular: n. 垂直线；垂直的位置 adj. 垂直的；呈直角的\n6. vertical: adj. 垂直的；纵向的\n7. spiral: n. 螺旋形 adj. 螺旋形的 v. 呈螺旋状下降或上升；急剧增长\n8. ordinate: n. 坐标轴\n    1. ordination: n. 任命；排成等级、分类\n    2. subordination: 下级地位\n# consicous - confuse - conscience\n\n1. conscience: `/ˈkɒnʃəns/` n. 良心、良知；内疚、愧疚\n    1. Middle English (also in the sense ‘inner thoughts or knowledge’): via Old French from Latin `conscientia, from conscient- ‘being privy to’`, from the verb `conscire`, from `con- ‘with’` + `scire ‘know’`.\n    2. conscientious: `/ˌkɒnʃiˈenʃəs/` adj. 勤勤恳恳的；一丝不苟的\n2. conscious: `/ˈkɒnʃəs/` adj. 意识到的；神志清醒的；故意的\n3. confuse: v. 混淆；使迷惑\n    1. baffle: `/ˈbæfl/` v. 使困惑\n        1. late 16th cent. (in the sense ‘cheat, deceive’): perhaps related to French `bafouer ‘ridicule’` or obsolete(老式的；废弃的) French `beffer ‘mock, deceive’`.\n4. delusive: `/dɪˈluːsɪv/` adj. 欺瞒的；使迷惑的\n# anticipate\n\n在拉丁语中，`anti-`表示-在...前面。`cip-`表示-捕捉、抓、握住。`-ate`表示-做；使，让\n1. anticipate: v. 预期；期望\n    1. anticipation: n. 预期；期望\n2. participate: 参与\n# bounce - bound - boundary - redound - bond - bandage - bind\n\n1. bounce: v. 弹跳；跳动\n    1. bouncy: adj. 弹性好的；生机勃勃的；精神饱满的\n2. bound: adj. 一定的；受约束的、有义务的 v. 跳跃；形成界线 n. 跳跃；边界 v. 动词bind的过去式&过去分词\n    1. boundary: n. 分界线，边界\n3. redound: v. 有益于\n   This course of action will redound to our advantage. 这种做法对我们很有好处。\n   Our efforts will redound to the general good. 我们的努力将增进大众的利益。\n4. bond: n. 纽带；联系\n    1. bondage: n. 束缚；奴役；捆绑癖好\n5. bandage: n. 绷带\n6. bind: v. 捆绑；系上\n# projector\n\n1. projector: n. 放映机；投影机\n2. projection: n. 投影；投射；预测；放映\n# represent - present\n\n1. represent: v. 代表；表示；象征；描绘；表现\n    1. representation: n. 代理人；代表；表现；描述；陈述\n    2. masterpiece: n. 杰作；名著；代表作\n2. present: v. 呈现；介绍；提出；赠送 adj. 出席的；现在的 n. 现在；礼物；瞄准\n    1. presence: n. 出席\n    2. presentation: n. 提供；显示；外观；授予（物）；赠送（仪式）；报告；表演\n# regret\n\n1. regret: v. 后悔；感到遗憾 n. 遗憾；后悔\n2. regretful: adj. 后悔的；失望的；令人惋惜的；遗憾的\n# 极其、非常；少量；稍微\n\n1. exceedingly\n2. **mighty**: n. 强而有力的；巨大的；非凡的 adv. 非常；很；极其\n3. vast: adj. 巨大的；大量的 - vastly: adv. 非常；很；广大地\n4. particularly: 特别；尤其\n5. bitterly: adv. 非常, 伤心地, 愤怒地, 极其\n6. particle: n. 极少量；微粒\n7. trifle: `/'traɪfl/` n. 小事, 琐事; 不值钱的小物件; 稍微，少量\n\t1. trivia - trivial\n\t2. intricacy: n. 错综复杂的细节 - intricate: adj. 错综复杂的\n\t\t1. intrigue: n. 阴谋诡计 v. 迷住；施诡计\n8. slight: adj. 少量的；轻微的\n    1. slightly: adv. 稍微地\n    2. sight: n. 视力、视觉\n9. sip: v. 小口地喝；抿 n. 一小口的量\n10. shred: `/ʃred/` v. 切碎；撕碎 n. 细条、碎片；极少量、一丁点\n    1. shrewd: `/ʃruːd/` adj. 精明的、敏锐的；高明的\n# can-、van-\n\n1. canvas: n. 帆布；画布；油画\n2. canvass: v. 游说, 劝说, 兜售, (大范围的)调查 n. 游说, 讨论, 民意调查\n# -ea-、-ee-: bead - breed - beak - greed - reef - reed - steak - sheer - steer\n\n1. bead: 珠子\n2. breed: n. 品种 vi. 交配以繁殖 vt. 养育；孕育、导致\n    1. 被动语态：bred: I'm a Londoner, born and bred. 我土生土长在伦敦。\n    2. species: n. 品种\n4. beak: n. 鸟喙, 鹰钩鼻, 尖鼻\n5. greed: n. 贪婪，贪心 - greedy: adj. 贪心的\n6. reef: n. 礁、礁脉\n7. reed: n. 芦苇\n8. steak: `/steɪk/` n. 牛排；鱼排；肉块\n9. sheer: adj./adv. 数量之大的；纯粹的；陡峭的\n10. steer: v. 控制、操纵；驾驶（船、汽车等）\n11. steep: 陡峭的\n12. **feat: n. 功绩；英勇事迹**\n13. conceal: v. 隐藏；掩盖\n# mani-\n\n1. manipulate: v. 熟练地操作、使用；（暗中）控制、操纵\n# steward\n\n```\nward: n. 监督、监视、保护、看护；受监护人；区、选区；病房、病室 v. 守护、防御；使入病房\nwarder: n. (监狱的)看守；狱吏\n```\n\n1. steward: `/'stjuːəd/` n. 乘务员, 服务员; 管理员; 管家;（比赛、集会等大型公众活动的）负责人, 统筹人, 管事, 干事\n2. stewardess: n. 女乘务员\n# 事件；情况\n\n1. circumstance: n. 情况；情形；境况\n2. event\n3. case\n# -vey\n\n1. survey: 调查\n2. convey: v. 表达、传达（思想、感想、感觉等）；传递、传达（信息或消息）\n# assemble - assembly\n\n1. assemble: v.集合，收集；装配，组装\n2. assembly: **（名词）n.** 会议；议会；集合，集会；装配\n    1. assembly-language 汇编语言\n# vender - render\n\n1. vend: vt. 出售(尤指土地等财产)；(尤指在公共场所)贩卖，叫卖(小商品)；发表(意见，言论)；声明\n2. vender/vendor: n. （街头）小贩；卖主，卖方\n    1. pedlar: `/ˈpedlə(r)/` n. 流动小贩\n        1. peddle: ` /ˈpedl/` vt. 叫卖 vi. 沿街叫卖\n        2. pedal: `/ˈpedl/` n. 踏板\n        3. paddle: `/ˈpædl/` n. 划桨\n3. vending machine: 自动售货机\n4. vendee: n. 买主（法律用语）\n5. render: `/ˈrendə(r)/`\n    1. 使变成\n    2. 提交；回报\n    3. 表达\n# remainder\n\n1. remain: vi. 保持；依然；留下；剩余；逗留；残存 n. 遗迹；剩余物，残骸\n2. remainder: n. 其他人员；剩余物；余数\n    1. Nine people came in and the remainder stayed outside. 9个人进来，余下的人留在外面。\n# over-\n\n1. overlap: v. 重叠，部分相同；有共同之处\n    1. Here the methods of archaeology and ethnography overlap. 在这里，考古学和人种学的方法部分重叠了。\n2. overthrow: v. 推翻；将...赶下台\n3. overhear: v. 偶然听到；无意中听到\n4. overlook: v. 俯瞰；忽视；没注意到\n5. **oversee: vt. 监视、监督** vt. 偷看到，无意中看到\n6. overpower: v. 制服\n7. overreach: v. 走过头\n8. override: v. 制服；践踏 - overriding: adj. 最重要的；\n9. overrule: v. 驳回；否决\n10. overshadow: v. 遮蔽；使黯然失色\n11. overstate: v. 夸大的叙述\n# fortune - fortuity\n\n1. fortune: 财产，运气\n2. fortuity: n. 偶然性；偶然事件；偶然机会\n3. fortuitous: adj. 偶然的, 意外的；幸运的\n4. fortunate: adj. 幸运的，侥幸的\n5. opportunity: n. 机会\n# 天文地理\n\n## 城市\n\n1. downtown: adv. 在闹市区 n. 闹市区 adj. 闹市区的\n2. uptown: n./adv./adj. 在住宅区的\n3. urban: adj. 在城市的；在都市的\n4. suburban: adj. 郊区的 n. 郊区居民\n5. outland: adj. 远离中心的、偏远的 n. 边境地区\n6. inland: adj. 内陆的；内地的 adv. 在内陆；在内地\n7. vicinity: `/vəˈsɪnəti/` n. 周围地区；附近\n    1. in the vicinity of 30 or 40: 三四十左右\n## 形容词\n\n1. adjacent: adj. 毗连的，邻近的\n## 地理、地型、地貌、建筑设施\n\n1. swamp: n. 沼泽 v. 淹没；席卷\n2. inlet: n. 水湾；小港；注入口\n    1. harbor: n. 港口、港湾 v. 心怀（想法或感情）；庇护、窝藏\n    2. wharf: `/wɔːf/` n. 码头\n3. outlet: n. 出口；通风口\n4. valley: `/ˈvæli/` n. 山谷；溪谷\n5. ridge: `/rɪdʒ/` n. 山脊、山脉；隆起\n6. trench: `/trentʃ/` n. 沟；渠\n7. tropical: adj. 热带的\n8. continent: n. 大陆；大洲\n9. dam: n. 水坝；障碍 v. 筑坝\n10. canal: `/kəˈnæl/` n. 运河、渠道\n11. strait: `/streɪt/` n. 海峡、水道；困境\n    1. channel: 也有海峡的意思，比strait长而宽\n    2. straight: `/streɪt/` adj./adv. 笔直的（地）；立即、直接的（地）\n12. arena: `/əˈriːnə/` n. 圆形竞技场、剧场\n13. cliff: n. 悬崖\n14. equator: `/ɪˈkweɪtə(r)/` n. 赤道\n## 各种道路\n\n1. bypass: n. （绕过城镇或市中心的）支路；旁道 v. 绕开、避开；忽视、不顾\n2. aisle: `/aɪl/` n. 走廊、过道\n## 宇宙\n\n1. cosmos: 宇宙\n\t1. cosmopolitan: adj. 世界性的；四海为家的 n. 世界主义者；四海为家的人\n## 几何\n\n1. orbit: n. 轨道；v. 绕轨道而行\n2. axis: n. 轴\n   The earth **turns on its axis** once every 24hours. 地球每24小时**自转**一圈\n3. diameter: 直径\n4. curve: 曲线、弧线\n5. longitude: 经度\n    1. latitude: 纬度\n    2. gratitude: n. 感谢、感激\n# penetrate\n\n1. penetrate: v. 穿透，渗透 - penetration: n. 渗透，穿透；侵入，突破\n# 埋葬、葬礼：funeral - burial\n\n1. funeral: n. 葬礼 adj. 丧葬的\n2. burial: n. 埋葬；葬礼；弃绝 adj. 埋葬的\n# deposit - depot\n\n1. deposit: `英 /dɪˈpɒzɪt/ 美 /dɪˈpɑːzɪt/` n. 存款；押金、订金；沉积物、存储 v. 存放、寄存；(使)沉积\n2. depot: `英 /ˈdepəʊ/ 美 /ˈdiːpoʊ/` n. 仓库\n# neglect - negligible\n\n1. neglect: `/nɪˈɡlekt/` vt. 忽视，忽略 negligent a. 不注意的，疏忽的\n    1. neglectful: `/nɪˈɡlektfl/` adj. 忽视的；马虎的\n2. negligible: `/ˈneɡlɪdʒəbl/` adj. 微不足道的；不重要的；不值一提的\n# lapse\n\n1. lapse: n. 过失，疏忽；（两件事发生的）间隔时间 v. （合同、协议）期满终止；（逐渐）衰弱、消失\n# con-; com-\n1. convene: `/kənˈviːn/` v. 召集；召唤；聚集；集合\n    1. congregate: v. 集合\n        1. segregate: `/ˈseɡrɪɡeɪt/` v. 隔离并区别对待\n            1. separate: adj. `/ˈseprət/` 单独的；分开的 v. `/ˈsepəreɪt/` 使分开\n            2. aggravate: `/ˈæɡrəveɪt/` v. 使严重、恶化\n                1. aggregate: `/ˈæɡrɪɡət/` n./v. 总计\n            3. exaggerate: `/ɪɡˈzædʒəreɪt/` v. 夸大事实、夸张\n    2. marshal: v. 控制人群（动员）、集结 n. 空军元帅；司仪；典礼官\n    3. summon: v. 传唤某人出席；召集\n    4. mobilize: v. 动员；调动\n2. conquer: `/ˈkɒŋkə(r)/` v. 征服；克服 - conqueror: n. 征服者；占领者；胜利者\n3. convince: v. 使...相信；说服...\n    1. convinced: adj. 被说服的；信了的、坚信不移的\n    2. convict: v. 定罪；证明有罪（常用于被动语态）\n        1. **conviction: n. 证罪；坚定的信念**\n4. consign: v. 运送；把...置于（尤指不好的境地）；弃置\n5. conceal: v. 隐藏\n6. concise: `/kənˈsaɪs/` adj. 简洁的\n7. consent: n./v. 同意\n8. confront: vt. 使...面临、面对、对付；降临到...头上\n## 相符、一致；对应\n\n1. correspond: `/ˌkɒrəˈspɒnd/` adj. 符合的、相应的、相关的\n    1. correspondence: `/ˌkɒrəˈspɒndəns/ `n. **来往信件**；相关、相似\n    2. resemblance: `/rɪ'zembl(ə)ns/` n. 相似\n       She bears a remarkable resemblance to Amy. 她跟艾米长得非常相似。\n        1. analogy: `/əˈnælədʒi/` n. 类比；相似之处\n            1. analogous: `analogous` adj. 相似的、类似的\n    3. assemble: vt. 聚集、集合\n        1. assembly: n. 集会、议会\n2. accord: n. 协议 v. 一致、相符 - accord with - accordance n. 符合、一致\n3. coincide: v. 同时发生；相同，相符；位置重合，重叠\n    1. coincidence: n. 一致；（令人吃惊的）巧合；同时存在，并存\n        1. incidence: `/ˈɪnsɪdəns/` n. 发生范围、影响程度；发生率\n            1. incident: n. 发生的不好的、不寻常的事情\n    2. coincidental: adj. 巧合；碰巧；非计划之中\n        1. identical: adj. 一模一样的\n    3. simultaneously: `/ˌsɪmlˈteɪniəsli/` adv. 同时地\n        1. **spontaneous**: `/spɒn'teɪniəs/` adj. **自发的，自然产生的**；无意识的；天真率直的\n4. concur: v. 同意, 赞同, 意见一致; 同时发生\n5. **unanimous**: `/juˈnænɪməs/` adj. 全体一致的; 一致同意的; 无异议的\n    1. dissent: `/dɪˈsent/` n./vi. 异议；不同意\n6. consonance: n. 一致、协调；协和音程\n    1. consonant: adj. 一致的、和谐的 n. 辅音；辅音字母\n        1. vowel: 元音；元音字母\n7. conspire: `/kənˈspaɪə(r)/` v. 共谋；密谋\n8. **consecutive: `/kən'sekjətɪv/` adj. 连续不断的**\n9. **prosecution: n. 诉讼；原告；实施；从事**\n10. concurrent: adj. 同时存在(发生、完成)的\n\t1. currency: n. 通货，货币；流转\n\t2. currently: adv. 目前，当下\n11. coherence: n. 连贯性；条理性；一致性\n    1. coherent: adj. 连贯的；有条理的\n12. contract: n. 合同、契约 v. 收缩、缩紧\n    1. contrast: n. 反差\n13. compassion: n. 同情；怜悯\n# 巧合；偶然 - hazard\n\n1. coincidental: adj. 巧合；碰巧；非计划之中\n    1. identical: adj. 一模一样的\n2. haphazard: `/hæpˈhæzəd/` adj. 无计划的；组织混乱的 adj. 偶然的；随便的 n. 偶然；偶然事件\n    1. 词源：late 16th cent.: from `hap(‘chance, luck’)`+`hazard`.\n    2. hazard: n. 危险；危害\n        1. hazardous: adj. 危险的；有害的\n        2. **menace: `/ˈmenəs/` n. 威胁；危险的人**\n# vibrate\n\n1. vibrate: v. 颤动、震动\n    1. vibration: n. 震动、颤动；（感情的）共鸣、感应\n# 腐败: decay - rot - erode - corrode\n\n1. decay: `/dɪˈkeɪ/` v./n. 衰败；腐败；失修坏损\n2. rot: `/rɒt/` v./n. 腐败\n3. erode: `/ɪˈrəʊd/` v. 逐渐地腐蚀、削弱、流失\n    1. erosion: `/ɪˈrəʊʒn/` n. 逐渐破坏；流失\n4. corrode: `/kəˈrəʊd/` v. 腐蚀、侵蚀\n# 性格\n\n1. peculiar: adj. 古怪的；特有的 n. 特有财产 - peculiarity: 怪癖；怪异；特点\n2. eccentric: `/ɪkˈsentrɪk/` adj. 古怪的；异乎寻常的 - eccentricity: `/ˌeksen'trɪsɪtɪ/` n. 怪癖；古怪行为；反常\n3. meek: adj. 柔顺的；懦弱的 n. 温顺的人；谦恭的人\n# bold - bald\n\n1. bold: adj. 勇敢的, 无畏的；冒失的, 鲁莽的；明显的, 醒目的；粗体的, 黑体的\n2. bald: adj. adj. 秃顶的；光秃的；无装饰的 vi. 变秃\n# respective - perspective - prospective\n\n1. respective: 各自的；分别的\n    1. irrespective of: adj. 不顾...的、不考虑...的；无论\n        1. The law applies to everyone irrespective of race, religion or color. 法律适用于任何人，无论其种族、宗教或肤色。\n2. perspective: n. 客观判断力；观点、态度、视角\n3. prospective: `/prəˈspektɪv/` adj. 有望的、可能的；预期的；潜在的\n# isolate = desolate = insulate - violate - insult - consult\n\n1. **iso**late: `/ˈaɪsəleɪt/` v. 隔绝；孤立\n    1. separate: v. `/ˈsepəreɪt/` 使分开 adj. `/ˈseprət/` 单独的；分开的\n    2. segregate: `/ˈseɡrɪɡeɪt/` v. 隔离并区别对待\n2. desolate: `/ˈdesələt/` adj. 荒凉的；无人居住的\n3. **insu**late: `/ˈɪnsjuleɪt/` v. 使隔热、隔音；绝缘、隔绝\n    1. insulation: n. 隔热、隔音、绝缘的功效；隔热、隔音、绝缘材料\n4. violate: `/ˈvaɪəleɪt/` v. 违反（法律、协议）；侵犯、扰乱\n    1. infringe: `/ɪnˈfrɪndʒ/` v. 违反（法律）；侵犯\n5. insult: `/ˈɪnsʌlt/` v./n. 辱骂\n6. consult: `/kənˈsʌlt/` v. 咨询（只有动词）\n# -tter\n\n1. shatter: `/ˈʃætə(r)/` v. 打碎；粉碎；使终结；使破灭\n\t1. grind: `/ɡraɪnd/` v. 碾碎\n2. scatter: `/ˈskætə(r)/` v. 分散\n    1. disperse: `/dɪˈspɜːs/` v. （使）分散；散发、传播\n# comprise - compromise - premises - comprehend\n\n1. comprise: vt. 由...组成；包含\n2. compromise: n./v. 妥协\n3. premises: `/ˈpremɪsɪz/` n. （企业的）房屋；经营场地\n4. promissory: adj. 承诺的；约定的\n    1. Roger signed a promissory note pledging to pay Fiona $50,000. 罗格签了一张期票，承诺付给菲奥娜5万美元。\n5. comprehend: v. 理解；领悟\n# referent\n\n1. referent: `/'refərənt/` n. 指示物，所指对象\n# 动作: squat\n\n1. squat: vi. 蹲坐；蹲；擅自占住(空屋) adj. 矮胖的；矮而宽的 n. 蹲坐，蹲姿；被擅自占用的建筑物\n2. shrug: v. 耸肩（表示不知道或不在乎）\n   1. shrub: n. 灌木\n# 脆弱\n\n1. brittle: `/'brɪtl/` adj. 硬但易碎的, 脆性的, 脆弱的, 尖利的 n. 薄片脆糖 v. 变脆\n2. vulner: n. 创伤；漏洞\n    1. vulnerate: `/'vʌlnəreit/` vt. 使受伤\n    2. vulnerable: `/ˈvʌlnərəbl/` adj. 易受创伤的\n    3. vulnerability: `/ˌvʌlnərəˈbɪləti/` n. 脆弱性；弱点；易伤性\n3. susceptible: `/səˈseptəbl/` adj. 易受影响的；敏感的；感情丰富的\n    1. susceptibility: `/səˌseptəˈbɪləti/` n. 敏感性\n4. tender: adj. 脆弱的、嫩的、柔软的；易坏的 v./n. 投标；提议、提出\n# 家族；传承、遗传\n\n1. posterity: `/pɒ'sterəti/` n. 后代, 子孙, 后世, 后裔\n2. descendant:  adj. 下降的；祖传的 n. 后裔；子孙\n    1. ascend: v. 上升；攀登\n3. heritage: n. （贵重）遗产\n4. legacy: n. 遗产\n5. estate: n. 地产；财产\n# 淹没: inundate\n\n1. inundate: `/'ɪnʌndeɪt/` v. 淹没, 使不胜负荷, 使应接不暇, 泛滥\n    1. undu-, und-【拉丁语传入法语】表示“波动”；“涌出”\n       同根词surround|inundate|redundant|abound|\n    2. und【拉丁】表示“波动，波浪”\n       词根助记：inundate:in在内 + und=在里面有波浪=泛滥，淹没\n       同根词abundant|abundance|inundate|abound|fecundity|redound|undulate|\n   2. in进入，und波浪，ate一进入波浪则：淹没\n   3. undulate: v. 波动起伏；成波浪形\n   4. abundant: adj. 丰富的\n# exhibit - inhibit - prohibit\n\n1. exhibit: `/ɪɡˈzɪbɪt/` v. 显示、展览 n. 展览品；证据；展示会\n    1. exhibition: `/ˌeksɪˈbɪʃn/` n. 展览品；展览；表现；奖学金\n2. inhibit: `/ɪnˈhɪbɪt/` v. 阻止；抑制；使拘束、收敛\n    1. inhibition: `/ˌɪnhɪˈbɪʃn/` n. 拘谨、拘束感；抑制\n    2. inhabit: `/ɪnˈhæbɪt/` v. 居住在、栖居于\n        1. inhabitant: n. 居民\n3. prohibit: `/prəˈhɪbɪt/` vt. 阻止、禁止\n    1. prohibition: `/ˌprəʊɪˈbɪʃn/` n. （法律）禁止\n# hollow\n\n1. hollow: adj. 空的；空心的；空洞的 n. 树洞；凹陷处 v. 使凹陷\n# exhaust - fatigue\n\n1. exhaust: vt. 用尽、耗尽；使非常疲倦 vi. 排气 n. 排气装置；机器排出的废气\n    1. exhausted: adj. 耗尽的,用完的；筋疲力尽的；精疲力竭的\n2. fatigue: `/fəˈtiːɡ/` n. 疲劳 vt. 使疲劳 vi. 疲劳 adj. 疲劳的\n# 足够的、充分的: sufficient - adequate\n\n1. sufficient: adj. 足够的、充分的 - suffice: v. 足够；足以\n2. adequate: adj. 足够的、充分的；适当的\n# blend - mix\n\n1. blend: v./n. 混合；融合\n    1. 混合与其各成分的性质通常是一致的，侧重混合整体的统一性与和谐性。\n2. mix: v./n. 混和\n    1. 混合的各成分可能按原样存在，但不一定能辨别出来。\n# scarce - scarcity\n\n1. scarce: `/skeəs/` adj. 缺乏的、不足的；稀少的\n    1. scarcely: `/ˈskeəsli/` adv. 几乎不；难得、勉强\n    2. scarcity: `/ˈskeəsəti/` n. 缺乏、不足\n    3. deficient: `/dɪˈfɪʃnt/` adj. 缺乏的、不足的；有缺点的、有缺陷的\n        1. sufficient: `/səˈfɪʃnt/` adj. 足够的、充足的\n# wade\n\n1. wade: v. 跋涉；蹚水\n# 研讨会\n\n1. workshop\n2. seminar\n3. symposium\n# 死亡、毁灭: mortal - martyr - mar - toll - perish - doom\n\n1. mortal: `/ˈmɔːtl/` adj. 不能永生的；终将死亡的 n. 凡人；普通人\n    1. late Middle English: from Old French, or from Latin `mortalis, from mors, mort- ‘death’`\n    2. mortality: `/mɔːˈtæləti/` n. 死亡数量、死亡率；生命的有限性\n        1. toll: `/təʊl/` n. （自然灾害、冲突事故）伤亡人数；过路费\n        2. perish: `/ˈperɪʃ/` vi. 突然死亡、暴毙；毁灭\n        3. doom: `/duːm/` n. 死亡时刻；厄运 v. 使...注定失败（常用于被动，be doomed）\n2. corpse: `/kɔːps/` n. 死尸、尸体\n3. mar: v. 破坏、损毁\n    1. **martyr: `/ˈmɑːtə(r)/` n. 烈士；殉道者**\n        1. Old English `martir`, via ecclesiastical Latin from Greek `martur ‘witness’ (in Christian use, ‘martyr’)`\n# 居民；移民；邻居；居所\n\n1. adjacent: 毗连的，邻近的；隔壁的\n    1. adjective: n. 形容词\n        1. preposition: n. 介词\n2. inn: n. 客栈\n3. solitude: n. 独居、独处、隐居；孤独\n4. inhabit: `/ɪnˈhæbɪt/` v. 居住在、栖居于\n    1. inhabitant: `/ɪnˈhæbɪtənt/` n. 居民、住户；栖息的动物\n       The city's first inhabitants arrived in the 18th century.\n    2. inhibit: `/ɪnˈhɪbɪt/` v. 阻止；抑制；使拘束、收敛\n        1. inhibition: `/ˌɪnhɪˈbɪʃn/` n. 拘谨、拘束感；抑制\n5. reside: `/rɪˈzaɪd/` vi. 居住、定居\n    1. resident: n. 居民\n6. tenant: `/ˈtenənt/` n. 承租人；房客；居住者\n    1. rent: 租\n7. dwelling: n. 住宅、住所；公寓\n\t1. dweller: 居民、居住者；栖身者\n8. lounge: n. （机场等的）休息室\n    1. lodge: `/lɒdʒ/` v. （向机构）正式提出（声明）；借宿，租住；为...提供住宿；寄存，存放，使固定、嵌入 n. 传达室、管理员室；门房, 旅馆；乡间小屋\n9. abide: `/əˈbaɪd/` v. 容忍、忍受；居住\n10. accommodation: n. 住宿；和解、调解\n    1. accommodate: v. 容纳；适应；提供住宿\n    2. dormitory: n. 学生宿舍\n11. emigrate: `/ˈemɪɡreɪt/` v. 移居；移民至国外（指从本国移出，长期定居在外。）\n    1. migrate: （鸟或动物）迁徙\n    2. immigrate: vi. 移入（指从他国移入，长期定居。）\n# ally - alien\n\n1. ali**e**n: `/ˈeɪliən/` n. 外国人；外星人 adj. 不熟悉；不相容\n    1. alienate: `/ˈeɪliəneɪt/` v. 使疏远\n        1. alienation: `/ˌeɪliəˈneɪʃn/` n. 疏远；格格不入\n2. ally: `/ˈælaɪ/` n. 盟友 v. 与...结盟\n    1. alli**a**nce: `/əˈlaɪəns/` n. 联盟体\n# 积极的词汇\n\n1. triumph: `/ˈtraɪʌmf/` n. 巨大成功、成就、胜利\n    1. triumphant: `/traɪˈʌmfənt/` adj. 巨大成功的、大获全胜的；洋洋得意的\n    2. trumpet: `/ˈtrʌmpɪt/` n. 喇叭、小号 v. 宣扬、鼓吹\n2. benevolent: `/bəˈnevələnt/` adj. 慈善的\n    1. benign: `/bɪˈnaɪn/` adj. 和善的；无害的\n    2. amiable: `/ˈeɪmiəbl/` adj. 和善的\n3. welfare: `/ˈwelfeə(r)/` n. 幸福；（多为政府给予的）福利\n    1. warfare: `/ˈwɔːfeə(r)/` n. 战争\n4. merit: `/ˈmerɪt/` n. 优点、长处、价值；美德、功绩 v. 应得、值得 = worth\n# 消极的词汇\n\n1. plight: `/plaɪt/` n. 困境；苦难\n2. snob: `/snɒb/` n. 势利小人；自以为优越的人\n    1. cynicism: `/'sɪnɪsɪz(ə)m/` n. 人人自私主义；悲观；玩世不恭（对生活不严肃、不认真）\n3. **adverse: `/ədˈvɜːrs/, /ˈædvɜːrs/` adj. 坏的、不利的、有害的；反面的**\n    1. aversion: `/əˈvɜːʃn/` n. 厌恶、反感\n    2. averse: `/əˈvɜːs/` adj. 不喜欢的；不想的；反对的\n        1. 常用于not averse否定句型，表示喜欢、想做、不反对\n4. wretched: `/ˈretʃɪd/` adj. 不愉快的、难受的；可怜的\n    1. wretch: `/retʃ/` n. 可怜的人\n# 老友记\n\n1. omnipotent: `/ɒmˈnɪpətənt/` adj. 无所不能的、全能的\n    1. impotent: `/ˈɪmpətənt/` adj. 不起作用的、无能的；性无能的\n    2. 出自S1E4开场，Joey误把omnipotent听成impotent了。","categories":["英语"]},{"title":"雅思听力","url":"/英语/雅思听力/","content":"\n# 考试流程\n\n纸笔考试8点半前进场，9点发答题卡。\n\n# 雅思听力概况\n\n只读一遍。时间：35分钟+10分钟（填答题卡，只有纸笔考试才有）。\n\n四个部分，每个部分10道题。\n\n第一部分，conversation，两个讲话人。social and semi-official context。通常是咨询，所以两者是不同的身份。要预判谁说出来。租房子、咨询考试、订酒店。\n\n第二部分，talk，单独讲话（但是不排除有两个讲话人，但是另外一个人只是抛砖引玉）。介绍实习生工作、旅游路线。\n\n第三部分，conversation or discussion。最多四个讲话人，实际上最多三个人，但是从剑10 之后基本上都只有两个人。话题是基于学术或与课程相关的。\n\n第四部分，大学风格的lecture or talk，时间较长，内容较专业。物理、心理、商业、健康、环境保护、历史、人文、建筑。\n\n1、4大多考填空、填表、填句子、简答，主要写单词。2、3大多考选择，单选、多选、匹配、地图、流程（匹配题的变形）。第三部分通常会出长选择、匹配，难度最大。\n\n## 做题技巧\n\n1. 所听即所答，不会改词性。\n2. 注意重音，尤其是第三部分填空题\n3. 纸笔考试时，誊抄答案时，全部写为大写字母。除非强调了all lower case（网址、密码）\n   1. 避免遗忘大小写区分。\n   2. 对于检查拼写错误有帮助\n\n## 称谓\n\n1. Full Name\n   1. first name = given name = forename\n   2. last name = family name = surname\n2. Title\n   1. Mr.\n   2. `Mrs.` - 尾音siz 已婚, `Miss` - 尾音s 未婚, `Ms.` - 尾音z 未知是否已婚。\n\n## 地点\n\n1. 注意Postcode、Zip code（eg: MK32 6KT）\n2. Room Number\n   1. 15 & 50\n   2. 40A & 48\n3. Street, Road, Avenue最常考，Lane, Drive, Square, Boulevard, Place, Bay, Highway, Plaza认识就好。\n\n## 日期\n\n1. `DD/MM/YYYY` or `MM/DD/YYYY`均可\n2. 日期写成基数词或序数词均可，基数词简单，比如March 31。听到的时候可以先写个草稿Mar 31，但是誊抄时要拼全为March！\n\n## 数字\n\n1. passport number\n2. driving license number\n3. license plate number\n4. student ID/number\n5. membership number\n6. medical card number\n7. flight number\n8. account number\n9. credit card number\n10. fax number\n11. telephone number\n\npassport、driving license、flight、credit card专门考过这四个词的填空。\n\n### 分数、小数、百分数\n\n1. `2/3`: two thirds，`1/4`: one fourth，`3/4`: three fourths\n   1. over - `219/763`: two hundred and nineteen **over** seven hundred and sixty three\n   2. in out of - `15/20`: fifteen **in out of** twenty\n2. `12.789`: twelve **point** seven eight nine\n   1. `0.67`: **point** six seven; **naught point** six seven; **zero point** six seven\n3. `12.5%`: twelve point five percent; twelve and a half percent\n\n### 钱\n\n`￡1`: one pound, `￡2`: two pounds\n\n`￡2.50`: 不应该说成two point five pounds，后面的50应该落在fifty 便士上。最好应该说成两磅五，two pounds fifty。\n\n关于美元：雅思没考过美刀，但是考过Canadian Dollars、Australian Dollars。\n\n美元有可能`$ 25.50`会省略中间的dollar，会念成: twenty-five fifty。但是英镑没这样念过。\n\n## 民族\n\n1. -ish: **British, English, Spanish, Swedish**（瑞典，国名是Sweden）, Turkish（不常考）\n2. -an: American, Canadian, Australian, Russian, German, Italian\n3. -ese: Chinese, Japanese\n4. -i（不常考）: Iraqi, Kuwaiti, Pakistani\n5. -ic（不常考）: Icelandic, Arabic\n6. 特殊: New Zealander, French, Swiss（瑞士，国名是Switzerland）, Greek, Dutch（荷兰，国名是Netherlands）, Thai\n\n有关民族的题一律都填形容词。\n\n## 计量单位\n\n单位可以写缩写，但是缩写不能写成大写。缩写必须写成小写，且缩写后面不能加复数s。\n\n如果要和全部拼写大写保持一致的话，建议全拼出来，可以写成大写，比如KILOMETER，但是注意，如果是复数且是全拼，需要加S，KILOMETERS。\n\n1. 长度：kilometer/km, meter/m, centimeter/cm, mile/ml(Br)/mi(Am)英里（考过）, feet(pl)/foot(s)/ft英尺, inch/in英寸。\n2. 重量：kilogram/kg（考过）, gram/g, pound/lb, tonne/ton公吨/英吨\n3. 面积：square meter/sq m, hectare/ha公顷（考过）, acre英亩\n4. 液量：**liter/l**（考过）\n5. 温度：Fahrenheit/F, centigrade/Celsius/C\n6. 货币：1 dollar = 100 cents, 1 pound = 100 pence(p), Euro, Japanese Yen\n","categories":["英语"]},{"title":"雅思阅读","url":"/英语/雅思阅读/","content":"\n# 考试流程\n\n纸笔考试阅读总共60分钟，但是没有单独填答题卡的时间，所以实际上只能做54分钟。写一篇，填一篇。\n\n三篇文章。40道题。\n\n四大类题型：（共13个小的类别）\n\n1. 填空\n   1. 简答、完成句子、无/有选项summary、表格题、图表标记、流程图\n2. 判断\n3. 选择（单选、多选）\n4. 匹配\n   1. 特殊词匹配、首尾句匹配、段落信息匹配、小标题。\n\n填空、判断难度稍低；选择、匹配难度稍高。\n\n27-29道题6.5分，30-32道7.0，33-34道7.5。平均一篇文章只能错2到3道题，才能保证7分以上。\n\n60%考察基础词汇、句法；20%考察阅读理解、定位技巧；20%文章逻辑关系、判断力。\n\n内容不固定，但是文章体裁只有两类，说明文 - 现象解释、议论文 - 问题解决。\n\n## 其他\n\n在答题卡上不能只写t或f，不能写缩写，要全部都写完，not given你要写成not given。\n\n# 文章难度分析\n\n1. 三篇难度随机\n2. 第一篇难度大的比例有所提升\n3. 第三篇一般比较简单\n\n难在哪里？\n\n1. 文章内容偏离日常生活接触的知识\n   1. 咔嚓忽悠可的建筑群、古代的人\n   2. 地理类的Grand Canyon\n   3. 美国大峡谷的形成原因\n   4. 地理学的洋流\n   5. 心理学上情绪有关的大脑定量分析\n   6. 语言学上的口哨\n\n2. 题目回到原文同义替换的比例增加\n   1. 以前你的题目和你的文章还能看到一些原文原词，但是现在就没有了，现在你在题目里看到这个词，你在文章中怎么都看不着这个词，往往都是同义词替换\n\n\n## 优先选择容易题做\n\n1. 四大类题型：（共13个小的类别）填空、判断难度稍低；选择、匹配难度稍高。\n   1. 填空\n      1. 简答、完成句子、无/有选项summary、表格题、图表标记、流程图\n   2. 判断\n   3. 选择（单选、多选）\n   4. 匹配\n      1. 特殊词匹配、首尾句匹配、段落信息匹配、小标题。\n2. 如果题型看着差不多，就看文章的开头和topic。优先选择自己熟悉话题的文章。\n2. 按阅读量\n   1. 有的是不需要读太多的内容就能做得出来答案的\n   2. 有的题目要求阅读量比较高，它需要你可能读一整篇，或者是可能读一个段落才能做对这种情况。\n      1. 像选择和匹配就属于难度比较高，也就是阅读量比较高的题目\n      2. 但并不是说所有的简单题型都一定简单，也并不是说所有的难的题型一直难\n4. 按照文章长度来看的话，先做短文章，短的就意味着你所需要看的内容少，所以先做短的，如果长度也都差不多，那去看文章生词大概瞄一眼哪些文章里面生词最少，先做。\n\n# 如何练习\n\n每天打好基础语法和单词的就是练习。\n\n## 词汇\n\n在APP上背阅读词汇，一天背5组同义词替换（剑1~剑9同义替换、剑10同义替换、剑11同义替换、剑13同义替换），然后再看每一本不同书的时候去背它的必备词汇（雅思阅读必备词汇C4~C11），如果阅读分数想要在7.5分以上，单词量一定是在8000以上的，而且加上阅读技巧才能到7.5分以上，如果阅读技巧稍微弱一点的话，你就得到在10000、12000。\n\n但是阅读的单词有一个特点就是在于它不需要你对这个单词有非常深刻的认知，你只需要看到这个单词认识，知道它的大概中文意思就行了，一定不要太准确，如果阅读词汇你的中文意思背得太准确的话，其实也不好，因为你就不能快速的找到它的同义词。比如说有个例子说的是地方的水利灌溉系统的improving，给人们带来了足够的食物。那题目说的是 advanced application system给人们带来了足够的食物。如果你想advanced和improving这俩词儿，advanced是先进的，improving是进步。如果背得非常的准确，把单词背得非常的死的话，可能会觉得他俩说的意思不是特别的一致，但是其实他俩说的就是一模一样的意思，都是先进、进步、高阶、好，用一句话总结就是他俩说的都是好，水的灌溉系统的好，到使这里的人们可以生活得很好。所以对于阅读词汇来讲的话，我们一定是建议大概意思范围就行了，这是词汇。\n\n## 长难句不回读\n\n去找句子的主谓宾。因为在阅读里面，你时间比较长的一个非常重要的点，其实就是在于我题目看完回到原文，原文看完以后第一遍我没看出来，我要再看一遍到底说的是什么，要看好几遍来达到我知道这个答案是什么的目的。这种情况下，就会花费比较长的时间来做题，所以一定要有长难句的不回读训练。\n\n要做到看一遍就能够掌握到这句话里的主干是什么，修饰成分是什么，掌握到这句话的主要意思想表达的是什么，和题目里面的关系是什么。\n\n## 两种联系阅读的方法\n\n### 中英文对照阅读\n\n第一种，中英文对照阅读，一段话，先把它翻译成英文，翻译完以后和英文原版进行对照，有出入。对我们现在的语言水平来看的话，包括口语、写作是有好处的。如果按照中英文对照阅读的训练进行训练下去的话，你会发现你的翻译能力有大幅度的进步和提升，就意味着你的写作和你的口语都会有进步，这个方法确实会比较费时间。不建议坚持看一本书，比如哈利波特小王子什么的，那些就有点不太能够直接的跟我们的写作相对应。建议看什么？建议去看写作范文，哪些翻译软件非常的好用，直接把它翻译成中文，我发的肯定都是英文写作范文，然后你就把它翻译成中文，然后中文看完以后一句一句翻译，然后对照一下写作范文，哪些表达方式我们没有，我们把它积累出来，这样的话就会更加的直接的针对于我们的雅思学习。\n\n### 直接阅读\n\n第二种，是直接阅读。直接阅读是什么？跟我们平时阅读中文书籍一样，我们直接阅读英文文章，直接阅读英文文章就是可以阅读。可以拿剑4及以后的的那些文章直接来阅读，以理解文章大概内容为目的。直接阅读一定要注意去读做过题目的文章。如果这篇文章题目还没有做，就不要去读它。因为一共我们剑桥真题就这么多，对吧？每一题按照考试的流程去练才是最好的。\n\n或者读机经。机经是什么？就是以往的考试的可能存在的文章，就是以读文章为目的去看。\n\n另外一个在读的时候要注意的一个点就是一定不要边查边读。所有的英语学习，包括口语，包括写作，包括听力，包括阅读，不要把所有的这些听说读写最终都练成考词汇。你可以从书中来判断陌生单词的意思，比如说写作的时候你想要写这个词，但是你不太会表达，你可以先尝试用其他的表达方式来把它替换出来，然后最后补充词汇，最后查一下这个单词和它的意思和你想象的一不一致。最后查一下这个表达方式——你想要用的，但是第一时间没有表达出来的，这就是补充词汇。\n\n1. 读做过题目的文章\n2. 读机经\n3. 一定不要边查边读\n4. 最后补充词汇\n\n# 考试技巧\n\n雅思阅读就两个方面：一是定位题眼、同义替换。二是阅读理解、归纳总结。\n\n1. 定位且理解细节信息的能力——同义替换。\n2. 归纳文章或者段落主要信息的能力——阅读能力。\n\n## 定位题眼、同义替换\n\n如果有明显题眼，做题的时候一定是先看题，再看文章。\n\n1. 题目里面通常有题眼，要在文章里面找到题眼，就是所说的答案句，对比一下这两个说的是什么，然后选答案。\n2. 对于那些结构性的题目，需要考察你的阅读能力，结构性的题目并不能在文章中找到非常明显的题眼，可能要看一段话或者是整篇文章来做这道题，比如说有的题目最后一篇，最后一题，他会问你这篇文章作者的意图是什么？这篇文章的开头是什么？这篇文章的主旨中心思想是什么？需要归纳文章或段落信息的能力，所以两个不同的能力对应的是我们不同的题目。\n\n阅读之前补充定位——选择什么样的词作为定位词。有一些我们常见的或常选的词，第一个叫特殊词：两种情况，一个是题目里面有特殊词，一个是题目里面没有特殊词。\n\n如果题目里面有特殊词最好，比如说一些大写名词，人名或者是地名，一些数字等等，大写的重要名词。这些比较好找，并且在文章中不会被替换。但是数字要注意，他可能会给你挖坑，他在题目里跟你说1890年，在文章里他可能会跟你说19世纪末。所以数字要警惕它的替换。大写数字或者是一些斜体或者是带符号等等的这些词，这些词儿相对来说，回归文章当中都比较好找，所以如果题目里有这些特殊词，就直接以它为定位词会文章找就可以了。\n\n如果题目里没有特殊词，全都是一些小写的，平常的词汇，要用多点定位法：要选择more than one定位词，以避免漏掉信息，或者扫读的时候忽略了。所以多点定位是在句子的不同成分里面选名词或者是名词词组。主语选一个，宾语选一个，定语选一个，状语选一个，一般选2~3个，这样的话抓住大概的主、谓、宾、定、状等等的这些，再去对应的找意思相符合的大致范围。\n\n## 同义替换\n\n同义替换就是填空句子完成或简答找定位，然后理解细节信息，阅读能力匹配，找小标题等等这些段落主要信息。但是这个适合先看文章再做题。\n\n所以我们的考试技巧先看文章再看题，还是先看题再看文章，都有自己的优缺点。如果我们先看文章的话，我们做题的准确率就会比较高，但是需要看的内容比较多，因为阅读量大；如果先看题，再看文章的话，阅读量比较小，但是有可能由于前后忽略了一个信息，导致做不对。所以我们要根据题目的特性选择不同的技巧，比如说细节信息题，一定是先看题，再看文章，如果是章篇结构体，可能先看文章再看题比较好，所以不同的题目我们选择不同的做题技巧。\n\n# 阅读方法\n\n扫读、略读、精读。\n\n扫读只是为了找到定位词而已，不需要了解和认识里面的某一个词汇或者是某一个短语，或者是它的文章意思等等，找到那个点就行了。扫读完了以后，我们就找到了定位词，接下来就要去略读。\n\n略读：去看一下定位词跟我的题目说的这个东西大概一不一致，方向一不一样，是不是我的题目范围，然后再精读。\n\n精读：一字一句的去认真读这篇文章里面的词汇是什么，句法是什么，然后根据题目找答案。\n\n## 扫读\n\n扫读适合题目中有明显定位词，回到原文中找到定位词就可以解题了。那么在这种情况下来一定要注意，扫读不是逐字逐句阅读，用w阅读法。\n\nw阅读法是什么意思？不是横着看，而是横竖结合——斜着下斜着上，每次w阅读5行。视线范围内可以在同一时间最大限度的看到最多的内容。\n\n## 略读\n\n略读适合题目本身是概括总结性的话语，只需要看大致意思就可以了，只需要看文章主旨就行了。有选择性的阅读，跳过细节，抓取文章大概。\n\n## 精读\n\n精读要求就会比较高，主要就考练习了。\n\n第一就是找长难句。就是一套题中，选三篇文章里错题最多的那篇进行精读。精读是要把文章里面所有的长难句都找出来，把里面的生词整理出来，要求对文章背景有所了解，把文章的结构体系和逻辑关系都找出来。那么其中长难句找出来以后，按照我们长难句进行分析，看这个句子的主语是谁，谓语是谁。先看句子主句是谁，然后分句修饰成分是什么等等。\n\n第二，找里面的不认识的单词，包括一些重要名词，包括一些文章，特殊情况，比如文章讲的Marine mammals，海洋里面的哺乳动物，它里面肯定会讲到各种各样的名词，各种各样的哺乳动物的名字等等，这些也得整理出来，得了解。\n\n第三，了解文章的背景，除了这篇文章说的海洋的哺乳动物以外，它还可能有哪些方面。自己通过搜索引擎查找。\n\n第四个也是最重要的，即整理出文章的体系结构和逻辑关系，这些体系结构和逻辑关系可以帮助你理解与之相同类的文章的所有的体系结构和逻辑关系，还能帮助你进行写作的逻辑关系和体系结构的level up。但并不是翻译这篇文章，不是把这篇文章逐字逐句的翻译出来去理解它是什么，而是用你自己的话去总结它。比如说这篇文章说的是introduction to film sound，这篇文章的题目讲的就是电影声音，然后刚开始告诉你film sound很重要，它其中有三种表达方式，第一种是人声，就是我们所说的对白，第二种是音效，管乐和弦乐，第三种是音乐。即：先给你对于film sound上的一个introduction，然后再逐一去解释：对白的definition是什么；举例：真人和演员重合；举例：对话的数量和使用方式。体系结构其实是：看文章是从词看到句子，从句子看到意群，从意群看到章篇。\n\n![image-20230404203323026](../../images/雅思阅读/image-20230404203323026.png)\n\n# 日常工作\n\n同义词。\n\n长难句分析。\n","categories":["英语"]},{"title":"Linux_设置系统运行级别","url":"/Linux/Linux_设置系统运行级别/","content":"# 切换系统运行级别\n* runlevel命令可查看系统运行级别\n* 可以用init命令动态切换0-6七个级别\n    1. 关机\n    2. 单用户模式\n    3. 多用户无网络服务\n    4. 完全的多用户文本界面\n    5. 未定义或自定义\n    6. 图形化界面\n    7. 重启\n\n```bash\nrunlevel\n# 结果:\n\t# 图形化模式时 -> N 5\n\t# 命令行模式时 -> 5 3\ninit 3 #切换到命令行模式\n```\n\n# 启动级别Runlevel\n参考：https://www.bbsmax.com/A/x9J2PYpEd6/\n\n首先来了解下启动级别(Runlevel)：\n\n指Unix或类Unix操作系统下不同的运行模式，运行级别通常分为7级：\n\n0. 运行级别 0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动\n1. 运行级别 1：单用户工作状态，root权限，用于系统维护，禁止远程登陆，无网络连接，不运行守护进程，不允许非超级用户登录。（如果忘记了root密码，可通过开机热键进入单用户模式进行重置，前提是要接触到主机）\n2. 运行级别 2：多用户状态，无网络连接，不运行守护进程\n3. 运行级别 3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式，正常登录状态\n4. 运行级别 4：系统未使用，保留，用户自定义\n5. 运行级别 5：X11控制台，登陆后进入图形GUI模式，就是常见的带有图形界面的模式\n6. 运行级别 6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动\n\n# 设置开机进入命令行模式\n\n在全新的Linux systemD中已经使用target代替Runlevel，如multi-user.target相当于init 3，graphical.target相当于init 5，但是SystemD仍然兼容运行级别(Runlevel)。\n\n当前绝大多数发行版已采用systemd代替UNIX System V。\n\n要设置开机进入无图形化界面的命令行模式，就是将默认的开机进入运行级别 5 更改为开机进入运行级别 3。\n\n步骤：\n\n1. `sudo vim /etc/default/grub`\n2. sudo update-grub\n3. `systemctl set-default multi-user.target`\n4. reboot\n\n# 设置开机进入图形界面\n\n步骤：\n\n1. `sudo vim /etc/default/grub`\n2. sudo update-grub\n3. `systemctl set-default graphical.target`\n4. reboot\n","categories":["Linux"]},{"title":"协程_C语言协程实现","url":"/多线程/协程_C语言协程实现/","content":"# 问题引入：生产和消费\n\n如果此时有一段代码生成数据，另一段代码使用数据，哪一段代码是调用者，哪一段是被调用者呢？\n\n有一段非常简洁的`run-length decompression code`，和一段同样简洁的解析器代码：\n\n```c\n    /* Decompression code */\n    while (1)\n    {\n        c = getchar();\n        if (c == EOF)\n            break;\n        if (c == 0xFF)\n        {\n            len = getchar();\n            c = getchar();\n            while (len--)\n                emit(c);\n        }\n        else\n            emit(c);\n    }\n    emit(EOF);\n```\n\n```c\n\t/* Parser code */\n\twhile (1)\n    {\n        c = getchar();\n        \tbreak;\n        if (isalpha(c))\n        {\n            do\n            {\n                add_to_token(c);\n                c = getchar();\n            } while (isalpha(c));\n            got_token(WORD);\n        }\n        add_to_token(c);\n        got_token(PUNCT);\n    }\n```\n\n第一个片段每调用emit一次就生成一个字符；另一个片段每调用getchar一次就要使用一次字符。如果只能调用emit和getchar来相互传递数据，可以很简单地将两个片段连接在一起来达成目的，即解压器的输出直接传递到解析器。\n\n# 连接两个片段的方案\n\n在现代的操作系统中，可以使用两个进程或者线程之间的管道实现连接，解压器中的emit写入一个管道，解析器中的getchar从这个管道的另一端读取。简单、健壮，但是用线程来解决有点重量级、不够便携。 通常情况下，不需要为如此简单的任务将程序划分为多个线程。\n\n常规的答案(conventional answer)就是重写(rewrite)通信信道的末端中的一个，如此它就成了一个可被调用的函数。下面是对每个示例片段意味着什么的例子。\n\n```c\nint decompressor()\n{\n    static int repchar;\n    static int replen;\n    if (replen > 0)\n    {\n        replen--;\n        return repchar;\n    }\n    c = getchar();\n    if (c == EOF)\n        return EOF;\n    if (c == 0xFF)\n    {\n        replen = getchar();\n        repchar = getchar();\n        replen--;\n        return repchar;\n    }\n    else\n        return c;\n}\n```\n\n```c\nvoid parser(int c)\n{\n    static enum { START, IN_WORD } state;\n    switch (state)\n    {\n        case IN_WORD:\n            if (isalpha(c))\n            {\n                add_to_token(c);\n                return;\n            }\n            got_token(WORD);\n            state = START;\n            /* fall through */\n        case START:\n            add_to_token(c);\n            if (isalpha(c))\n                state = IN_WORD;\n            else\n                got_token(PUNCT);\n            break;\n    }\n}\n```\n\n当然，不必重写两个。如果重写解压缩器，以便每次被调用时返回一个字符，则原始解析器代码可以用decompressor替换getchar。相反，如果重写解析器，以便为每个输入的字符都调用一次，则原始解压缩代码可以调用parser而不是emit。如果你是一个贪吃惩罚的人，你只会想将这两个函数重写为被调用者。\n\n这就是重点。与原始函数相比，这两个重写的功能都非常丑陋。当作为调用者而不是被调用者编写时，这里发生的两个过程(process)都更容易阅读。试着去推导解析器能识别的语法，或者解压器能理解的压缩数据格式，仅仅通过阅读代码，你会发现原始的代码很清晰，重写的代码都不太清楚。 如果我们不必将任何一段代码从里到外重写，那就更好。\n\n## Knuth's coroutines\n\n在 The Art of Computer Programming 中，Donald Knuth 提出了解决此类问题的方法。他的回答是完全抛弃栈的概念。不要再将一个进程视为调用者，将另一个进程视为被调用者，而是开始将它们视为平等合作。\n\n实际操作上：用略有不同的原语(primitive: In programming, a fundamental element in a language that can be used to create larger procedures that do the work a programmer wants to do.)替换传统的“调用(call)”原语。 新的“调用”会将返回值保存在堆栈以外的其他位置，然后跳转到另一个保存的返回值中指定的位置。 因此，每次解压缩器发出另一个字符时，它都会保存其程序计数器并跳转到解析器中最后已知的位置 - 每次解析器需要另一个字符时，它都会保存自己的程序计数器并跳转到解压缩器保存的位置。 控制在两个例程(routines)之间来回穿梭(back and forth)。\n\n从理论上讲，这是非常好的，但是实际上只能以汇编语言进行操作，因为没有常用的高级语言支持协程调用的原语(coroutine call primitive)。像C这样的语言完全取决于其基于堆栈的结构，因此，每当控制从任何函数传递到任何其他函数时，都必须有一个是调用者，另一个必须是被调用者。因此，如果想编写便携式代码，则此技术至少与Unix Pipe解决方案一样不切实际。\n\n## Stack-based coroutines\n\n所以我们真正想要的是在C中模仿 Knuth 的协程调用原语的能力。我们必须接受现实，在C级别，一个函数将是调用者，另一个将是被调用者。在调用者中，我们没有问题；我们对原始算法进行code，几乎完全按照编写的方式进行，并且每当它有（或需要）一个字符时，它就会调用另一个函数。\n\n被调用者有全部的难题需要解决。对于被调用者，我们想要一个具有“返回并继续”操作的函数：从函数返回，下次调用它时，从返回语句之后恢复控制。 例如，我们希望能够编写一个函数：\n\n```c\nint function()\n{\n    int i;\n    for (int i = 0; i < 10; i++)\n    {\n        return i; /* won't work, but wouldn't it be nice */\n    }\n}\n```\n\n我们想要对函数进行十次连续调用，返回数字0到9。我们如何实现呢？ 可以使用goto语句将控制转移到函数中的任意点。 所以如果我们使用状态变量，我们可以这样做：\n\n```c\nint function()\n{\n    static int i, state = 0;\n    switch (state)\n    {\n        case 0: goto LABEL0;\n        case 1: goto LABEL1;\n    }\nLABEL0: /* start of function */\n    for (i = 0; i < 10; i++)\n    {\n        state = 1; /* so we will come back to LABEL1 */\n        return i;\nLABEL1:\n        ; /* resume control straight after the return */\n    }\n}\n```\n\n这个方法有效。我们在可能需要恢复控制的点上有一组标签：一个在开始处，一个在每个 return 语句之后。我们有一个状态变量，在函数调用之间保存，它告诉我们下一个需要恢复控制的标签。在任何return之前，我们更新状态变量以指向正确的标签；在任何调用之后，我们都会对变量的值进行切换以找出跳转到的位置。\n\n不过，它仍然很难看。最糟糕的部分是标签集必须手动维护，并且必须在函数体和初始 switch 语句之间保持一致。每次我们添加一个新的返回语句，我们必须发明一个新的标签名称并将其添加到开关中的列表中；每次我们删除 return 语句时，我们都必须删除其对应的标签。 我们刚刚将维护工作量增加了两倍。\n\n## Duff's device\n\nC语言中著名的“达夫装置”利用了这样一个事实，即 case 语句在其匹配的 switch 语句的子块中仍然是合法的。 Tom Duff 使用它来优化输出循环：\n\n```c\nswitch (count % 8)\n{\n    case 0: do { *to = *from++;\n    case 7:      *to = *from++;\n    case 6:      *to = *from++;\n    case 5:      *to = *from++;\n    case 4:      *to = *from++;\n    case 3:      *to = *from++;\n    case 2:      *to = *from++;\n    case 1:      *to = *from++;\n               } while ((count -= 8) > 0);\n}\n```\n\n我们可以在协程技巧中将其用于稍微不同的用途。我们可以使用 switch 语句来执行跳转，而不是使用 switch 语句来决定执行哪个 goto 语句：\n\n```c\nint function(void)\n{\n    static int i, state = 0;\n    switch (state)\n    {\n        case 0: /* start of function */\n            for (i = 0; i < 10; i++)\n            {\n                state = 1; /* so we will come back to \"case 1\" */\n                return i;\n        case 1:\n                ; /* resume control straight after the return */\n            }\n    }\n}\n```\n\n现在这看起来很有希望。 我们现在要做的就是构建一些精心挑选的宏，我们可以将血淋淋的细节隐藏在看似合理的东西中：（使用`do ... while(0)`来确保`crReturn`直接出现在 if 和 else 之间时不需要大括号）\n\n```c\n#define crBegin static int state=0; switch(state) { case 0:\n#define crReturn(i,x) do { state=i; return x; case i:; } while (0)\n#define crFinish }\nint function(void) {\n    static int i;\n    crBegin;\n    for (i = 0; i < 10; i++)\n        crReturn(1, i);\n    crFinish;\n}\n```\n\n这几乎正是我们想要的。 我们可以使用`crReturn`以这种方式从函数返回，以便在返回后立即恢复下一次调用的控制。 当然，我们必须遵守一些基本规则（用`crBegin`和`crFinish`包围函数体；如果需要在`crReturn`中保留所有局部变量，则将它们声明为静态的；永远不要将`crReturn`放在显式的`switch`语句中）； 但这些并没有限制我们太多。\n\n剩下的唯一障碍是`crReturn`的第一个参数。 正如我们在上一节中发明新标签时必须避免它与现有标签名称冲突一样，现在我们必须确保`crReturn`的所有状态参数都是不同的。 结果将是相当良性的——编译器会捕获它并且不会让它在运行时做可怕的事情——但我们仍然需要避免这样做。\n\nANSI C提供了特殊的宏名称`__LINE__`，它表示当前源代码行号。所以我们可以将`crReturn`重写为\n\n```c\n#define crReturn(x) do { state=__LINE__; return x; \\\n                         case __LINE__:; } while (0)\n```\n\n如果我们遵守第四条基本规则（永远不要将两个`crReturn`语句放在同一行），那么我们根本就不必担心那些状态参数。\n\n## Evaluation\n\n现在我们有了这个怪物，让我们用它重写我们原来的代码片段。\n\n```c\nint decompressor(void) {\n    static int c, len;\n    crBegin;\n    while (1) {\n        c = getchar();\n        if (c == EOF)\n            break;\n        if (c == 0xFF) {\n            len = getchar();\n            c = getchar();\n            while (len--)\n\t        crReturn(c);\n        } else\n\t    crReturn(c);\n    }\n    crReturn(EOF);\n    crFinish;\n}\n```\n\n```c\nvoid parser(int c) {\n    crBegin;\n    while (1) {\n        /* first char already in c */\n        if (c == EOF)\n            break;\n        if (isalpha(c)) {\n            do {\n                add_to_token(c);\n\t\tcrReturn( );\n            } while (isalpha(c));\n            got_token(WORD);\n        }\n        add_to_token(c);\n        got_token(PUNCT);\n\tcrReturn( );\n    }\n    crFinish;\n}\n```\n\n我们已经将解压缩器和解析器都重写为被调用者，完全不需要我们上次这样做时必须进行的大规模重组。**每个函数的结构完全反映了其原始形式的结构**。读者可以推断出解析器识别的语法或解压缩器使用的压缩数据格式，**这比阅读晦涩的状态机代码要容易得多**。一旦您全神贯注于新格式，控制流程就很直观：当解压缩程序有一个字符时，它会使用`crReturn`将其传回给调用者，并等待在需要另一个字符时再次调用。当解析器需要另一个字符时，它使用`crReturn`返回，并等待用参数`c`中的新字符再次调用。\n\n对代码进行了一个小的结构更改：`parser`现在在循环的末尾而不是开始处有它的`getchar`（嗯，相应的`crReturn`），因为当函数运行时第一个字符已经在`c`中进入。我们可以接受这个结构上的小变化，或者如果我们真的对此有强烈的感觉，我们可以指定`parser`需要一个“初始化”调用，然后才能开始向它提供字符。\n\n当然，和以前一样，我们不必使用协程宏重写这两个例程。一个就够了；另一个可以是它的调用者。\n\n我们已经实现了我们打算实现的目标：一种可移植的ANSI C方法，可以在生产者和消费者之间传递数据，而无需将其重写为显式状态机。我们通过将C预处理器与switch语句的一个很少使用的功能相结合来创建隐式状态机(*implicit* state machine)来完成此操作。\n\n## 编码标准问题\n\n当然，这个技巧违反了书中的所有编码标准。尝试在您公司的代码中这样做，可能会受到严厉的批评！在宏中嵌入了不匹配的大括号，在子块中嵌入了用例，以及`crReturn`宏及其可怕的破坏性内容......如果没有因为这种不负责任的编码行为当场被解雇真是个奇迹。应该为自己感到羞耻。\n\n这里的编码标准确实有问题，需要声明。在本文中展示的示例不是很长，也不是很复杂，并且在重写为状态机时仍然可以理解。 但是随着函数越来越长，需要重写的程度越来越大，清晰度的损失也越来越严重。\n\n考虑。 由以下形式的小块构建的函数\n\n```c\n    case STATE1:\n    /* perform some activity */\n    if (condition) state = STATE2; else state = STATE3;\n```\n\n对于读者来说，与由以下形式的小块构建的函数没有太大区别\n\n```c\n    LABEL1:\n    /* perform some activity */\n    if (condition) goto LABEL2; else goto LABEL3;\n```\n\n一个是调用者，另一个是被调用者，没错，但是函数的视觉结构是相同的，并且它们提供的对其底层算法的洞察力彼此一样小。 那些因为使用我的协程宏而解雇你的人也会因为你用 goto 语句连接的小块构建函数而大声解雇你！这一次他们是对的，因为布置这样的函数会可怕地掩盖算法的结构。\n\n编码标准旨在清晰。 通过将 switch、return 和 case 语句等重要内容隐藏在“混淆”宏中，编码标准会声称您已经模糊了程序的句法结构，并且违反了清晰度要求。但你这样做是为了揭示程序的算法结构，这更可能是读者想知道的！\n\n任何以牺牲算法清晰度为代价坚持句法清晰度的编码标准都应该被重写。 如果您的雇主因使用此技巧而解雇您，请在保安人员将您拖出大楼时反复告诉他们。\n\n# Refinements and Code\n\n在一个严肃的应用程序中，这个玩具协程实现不太可能有用，因为它依赖于静态变量，因此它无法重入或多线程。 理想情况下，在实际应用程序中，您可能希望能够在多个不同的上下文中调用相同的函数，并且在给定上下文中的每次调用中，控制在同一上下文中的最后一次返回之后立即恢复。\n\n这很容易完成。 我们安排了一个额外的函数参数，它是一个指向上下文结构的指针； 我们将所有本地状态和协程状态变量声明为该结构的元素。\n\n这有点难看，因为突然间你不得不使用`ctx->i`作为循环计数器，而你以前只会使用`i`； 实际上，您所有的重要变量都成为协程上下文结构的元素。 但它消除了重入的问题，并且仍然没有影响例程的结构。\n\n（当然，如果 C 只有 Pascal 的 with 语句，我们可以安排宏来使这个间接层也真正透明。遗憾的是，至少 C++ 用户可以通过让他们的协程成为类成员来管理它， 并将其所有局部变量保留在类中，以便范围是隐式的。）\n\n这里包含一个 C 头文件，它将这个协程技巧实现为一组预定义的宏。 文件中定义了两组宏，前缀为 scr 和 ccr。 scr 宏是该技术的简单形式，当您可以使用静态变量时； ccr 宏提供高级可重入表单。 完整文档在头文件本身的注释中给出。\n\n请注意，`Visual C++`版本 6 不喜欢这种协程技巧，因为它的默认调试状态（用于编辑和继续的程序数据库）对`__LINE__`宏做了一些奇怪的事情。 要使用`VC++6`编译使用协程的程序，必须关闭“编辑并继续”。 （在项目设置中，转到“C/C++”选项卡，类别“常规”，设置“调试信息”。选择“用于编辑和继续的程序数据库”以外的任何选项。）\n\n---\n\n参考文献：https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html\n","categories":["操作系统","多线程"]},{"title":"协程_Go语言协程实现","url":"/多线程/协程_Go语言协程/","content":"# 原理\n\n```go\nfunc main()\n{\n    go sayHello()\n    // continue doing other things\n}\nfunc sayHello()\n{\n    fmt.Println(\"hello\")\n}\n```\n\n","categories":["操作系统","多线程","Go"]},{"title":"Linux_升级工具软件以CMake为例","url":"/Linux/Linux_升级工具软件以Cmake为例/","content":"\n参考文章：[【安全|正确】Ubuntu升级CMake](https://blog.csdn.net/zzh516451964zzh/article/details/126373715)\n\n主要通过建立新的软链接来升级软件，同样适用于升级软件：无需卸载，通过建立软链接即可解决问题。很多教程会让你使用autoremove，但该操作会将之前编译过的许多文件连带删除。\n\n1. 下载CMake，[下载地址](https://cmake.org/files/)\n\n2. 下载压缩包，请注意无需编译，这是已经编译好的版本\n\n3. 解压\n\n4. 移动\n\n   `sudo mv cmake-3.22.1-linux-x86_64 /usr/share/camke-3.22.1`\n\n5. 建立软链接\n\n   `sudo ln -sf /usr/share/cmake-3.22.1/bin/cmake /usr/bin/cmake `\n\n6. 检查是否成功\n\n   `cmake --version`\n","categories":["Linux"]},{"title":"git_公钥私钥","url":"/git/git_公钥私钥/","content":"\n\n\n```\nusage: ssh-keygen [-q] [-a rounds] [-b bits] [-C comment] [-f output_keyfile]\n                  [-m format] [-N new_passphrase] [-O option]\n                  [-t dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa]\n                  [-w provider] [-Z cipher]\n       ssh-keygen -p [-a rounds] [-f keyfile] [-m format] [-N new_passphrase]\n                   [-P old_passphrase] [-Z cipher]\n       ssh-keygen -i [-f input_keyfile] [-m key_format]\n       ssh-keygen -e [-f input_keyfile] [-m key_format]\n       ssh-keygen -y [-f input_keyfile]\n       ssh-keygen -c [-a rounds] [-C comment] [-f keyfile] [-P passphrase]\n       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\n       ssh-keygen -B [-f input_keyfile]\n       ssh-keygen -D pkcs11\n       ssh-keygen -F hostname [-lv] [-f known_hosts_file]\n       ssh-keygen -H [-f known_hosts_file]\n       ssh-keygen -K [-a rounds] [-w provider]\n       ssh-keygen -R hostname [-f known_hosts_file]\n       ssh-keygen -r hostname [-g] [-f input_keyfile]\n       ssh-keygen -M generate [-O option] output_file\n       ssh-keygen -M screen [-f input_file] [-O option] output_file\n       ssh-keygen -I certificate_identity -s ca_key [-hU] [-D pkcs11_provider]\n                  [-n principals] [-O option] [-V validity_interval]\n                  [-z serial_number] file ...\n       ssh-keygen -L [-f input_keyfile]\n       ssh-keygen -A [-a rounds] [-f prefix_path]\n       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\n                  file ...\n       ssh-keygen -Q [-l] -f krl_file [file ...]\n       ssh-keygen -Y find-principals -s signature_file -f allowed_signers_file\n       ssh-keygen -Y match-principals -I signer_identity -f allowed_signers_file\n       ssh-keygen -Y check-novalidate -n namespace -s signature_file\n       ssh-keygen -Y sign -f key_file -n namespace file [-O option] ...\n       ssh-keygen -Y verify -f allowed_signers_file -I signer_identity\n                  -n namespace -s signature_file [-r krl_file] [-O option]\n```\n\n# 生成SSH Keys\n\n如果已经生存了ssh key，那就可以跳过这一步了。可以用以下命令查看：\n\n```bash\nls -l ~/.ssh\n```\n\n如果出现`id_rsa`和`id_rsa_pub`那就说明已经生成。\n\n如果没有，按以下步骤生成：\n\n```\nssh-keygen -t rsa -C “your_email@example.com”\n```\n\n## 示例\n\n`ssh-keygen -t rsa -C \"xing-cg@qq.com\"`\n\n其中，`-t`选项代表的是生成哪种密钥，`[-t dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa]`，选择rsa。\n\n`-C`选项代表注释，一般填写邮箱地址。\n\n# 拷贝现有的到新机器上\n\nclone github的项目时出问题，报以下错误。\n\n```\nPermission denied (publickey).\n  fatal: Could not read from remote repository.\n  Please make sure you have the correct access rights\n```\n\n## 解决方法\n\n1. 查看ssh-agent是否启用\n\n   ```\n   ssh-agent -s\n   ```\n\n   如果看到Agent pid xxxx说明已经启用。接下来把私钥添加到ssh-agent就可以了。\n\n2. 将`.Key`添加到`ssh-agent`\n\n   ```\n   ssh-add ~/.ssh/id_rsa\n   ```\n\n   可能会提示，`It is required that your private key files are NOT accessible by others`。\n\n   ```\n   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n   @         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\n   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n   Permissions 0664 for '/home/xcg/.ssh/id_rsa' are too open.\n   It is required that your private key files are NOT accessible by others.\n   This private key will be ignored.\n   ```\n\n   解决方法：`chmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub`\n\n3. 将ssh的公钥添加到git上\n\n   1. 查找公钥，一般在`~/.ssh`中的`id_rsa.pub`中\n   2. 打开github或gitlab，再依次进入settings、ssh keys、add ssh keys进行添加。\n","categories":["Linux","git"]},{"title":"协程_概述","url":"/多线程/协程_概述/","content":"# 多线程的缺陷\n\n1. 多线程是微秒级别。\n2. 线程数一多，CPU使用率会飙升。可扩展性比较差\n3. 编写异步逻辑、非阻塞事件时，函数回调方式只有编写程序的程序员才知道规则。\n# 协程的目的\n1. 描述异步逻辑\n    1. 比多线程更快\n    2. 比函数回调更美观\n# 协程的优势\n1. 性能强劲\n    1. 协程切换实验 - 一次协程切换的开销可以达到2到3纳秒之间，单线程协程切换的时间可以达到7到8纳秒，跨线程的协程切换也只需37纳秒左右。这些时间大大快于线程切换的时间。线程切换至少需要2000个时钟周期。假设CPU为4GHz，则至少需要500ns，若考虑cache失效问题，协程效率相对于线程将会是10、100倍的数量级。\n2. 语法优雅\n# 实验：测量协程切换开销\n\n写两个协程，使其不断切换。\n```cpp\nconstexpr uint32_t total_switch = 2e9; // 2 * 10^9\n\nint count = 0;\n\ntask<> f(const swtch &to)\n{\n    while (count++ < total_switch)\n    {\n        co_await to;\n    }\n}\nint main()\n{\n    swtch to[2];\n    task<> tasks[2] = {f(to[0]), f(to[1])};\n    to[0].target = task[1].get_handle();\n    to[1].target = task[0].get_handle();\n    \n    auto duration = hostTiming([&] {task[0].get_handle().resume(); });\n    \n}\n```\n\n循环对计数器累加，每次都切换一次协程。","categories":["操作系统","多线程"]},{"title":"05_mprpc_rpc框架","url":"/RPC/05_mprpc_rpc框架/","content":"# 无RPC的代码，怎么升级使用RPC框架\n在`/example/callee`中的代码\n```cpp\n#include <iostream>\nclass UserService\n{\npublic:\n    bool Login(std::string name, std::string pwd)\n    {\n        std::cout << \"doing local service: Login\" << std::endl;\n        std::cout << \"name: \" << name << \", pwd: \" << pwd << std::endl;\n    }\n};\nint main()\n{\n    UserService us;\n    us.Login(\"xcg\", \"123456\");\n}\n```\n如上，这是独立的代码，UserService可以进行Login处理。但是如果不使用RPC框架，则只能在本地被调用。\n需要想办法，能让远程调用。\n## 编写user.proto\n在`/example/`中的代码\n```protobuf\nsyntax = \"proto3\";\npackage xcg;\noption cc_generic_services = true;\nmessage ResultCode\n{\n    int32 errcode = 1;\n    bytes errmsg = 2;\n}\nmessage LoginRequest\n{\n    bytes name = 1;\n    bytes pwd = 2;\n}\nmessage LoginResponse\n{\n    ResultCode result = 1;\n    bool success = 2;\n}\nservice UserServiceRpc\n{\n    rpc Login(LoginRequest) returns(LoginResponse);\n}\n```\n使用protoc编译\n```bash\nprotoc user.proto --cpp_out=./\n```\n接下来，就是使用`user.pb.h`。\n## 服务提供者继承UserServiceRpc，实现rpc虚方法，业务处理，响应\n```cpp\n// userservice.cc\n#include <iostream>\n#include \"user.pb.h\"\n// 服务提供者\nclass UserService : public xcg::UserServiceRpc\n{\npublic:\n    bool Login(std::string name, std::string pwd)\n    {\n        std::cout << \"doing local service: Login\" << std::endl;\n        std::cout << \"name: \" << name << \", pwd: \" << pwd << std::endl;\n    }\n    // 重写基类UserServiceRpc的虚函数。这些方法都是框架直接调用的\n    void Login(::google::protobuf::RpcController* controller,\n                       const ::xcg::LoginRequest* request,\n                       ::xcg::LoginResponse* response,\n                       ::google::protobuf::Closure* done)\n    {\n        // 拿到了框架给上报的请求参数LoginRequest\n        // 需要取出相应数据做本地业务\n        std::string name = request->name();\n        std::string pwd = request->pwd();\n        // 取出数据后，调用本身已有的方法\n        bool login_result = Login(name, pwd);\n        // 填写响应消息\n        xcg::ResultCode * result_code = response->mutable_result();\n        result_code->set_errcode(0);\n        result_code->set_errmsg(\"ok!\");\n        response->set_success(login_result);\n        // 执行回调操作：由框架done->Run()处理消息的序列化、返回传输\n        done->Run();\n    }\n};\n```\n这些重写了的虚函数，在哪里被调用呢？见[`google::protobuf::NewCallback<>`生成回调函数](#`google%20protobuf%20NewCallback<>`生成回调函数)\n## 服务调用方调用UserServiceRpc_Stub里protobuf给我们自动实现好的rpc方法\n比如，`UserServiceRpc_Stub`的`Login`方法，是位于`user.pb.h`中的。\n\n而Login的调用最终会落到`UserServiceRpc_Stub`的`channel_`成员所含的方法`CallMethod`。\n\n要实例化`UserServiceRpc_Stub`，需要一个`MprpcChannel`对象来给它构造，并且这个`MprpcChannel`要实现`CallMethod`。\n\n见[Mprpcchannel类](#Mprpcchannel类)。\n## 服务调用者主程序（如calluserservice.cc）\n定义要调用的某个方法的request（如LoginRequest），填写参数。\n\n定义要调用的某个方法的response（如LoginResponse），不填写参数。\n\n定义`UserServiceRpc_Stub`，通过`MprpcChannel()`实例化。\n\n之后通过stub发起远程调用`Login`。\n```cpp\n#include <iostream>\n#include \"mprpcapplication.h\"\n#include \"user.pb.h\"\n#include \"mprpcchannel.h\"\nint main(int argc, char ** argv)\n{\n    // 整个程序启动以后，想使用mprpc框架来享受rpc服务调用，一定需要先调用框架的初始化函数（只初始化一次）\n    MprpcApplication::Init(argc, argv);\n\n    // 填写rpc方法的请求参数\n    xcg::LoginRequest request;\n    request.set_name(\"zhang san\");\n    request.set_pwd(\"123456\");\n    // 定义rpc方法的响应\n    xcg::LoginResponse response;\n\n    // 底层转到RpcChannel->CallMethod来做所有rpc方法调用的参数序列化和网络发送\n    xcg::UserServiceRpc_Stub stub(new MprpcChannel());\n\n    // 发起rpc方法的调用。\n    stub.Login(nullptr, &request, &response, nullptr);\n    \n    // 一次rpc调用完成，读调用的结果\n    if (response.result().errcode() == 0)\n    {\n        // 成功\n        std::cout << \"rpc login response success: \" << response.success() << std::endl;\n    }\n    else\n    {\n        std::cout << \"rpc login response error: \" << response.result().errmsg() << std::endl;\n    }\n    return 0;\n}\n```\n## rpc服务框架的启动入口？\nrpc服务框架由各个服务节点（服务提供者）启动。比如`UserService`，类外实现一个main函数，main函数中调用`MprpcApplication::Init(argc, argv)`进行框架相关的启动，比如读配置文件。\n之后，各个服务节点（服务提供者）可以NotifyService发布自己节点上的服务名、方法名。\n之后，各个服务节点调用`Run`，启动服务节点。\n\n# 模拟rpc框架的使用，以分析框架需要什么东西\n1. 框架需要一个基础类，进行Init初始化，使用argc、argv参数。因为rpc服务器本身有ip地址、端口号，需要zookeeper的ip地址、端口号。从配置文件读。\n2. 框架需要提供一个可以发布服务的RpcProvider。\n\n```cpp\n// userservice.cc的代码\n\n// class UserService的定义...\n// ...\n\n#include \"mprpcapplication.h\"\nint main(int argc, char ** argv)\n{\n    // 框架的初始化操作\n    MprpcApplication::Init(argc, argv);\n        \n    // provider是一个rpc网络服务对象，负责发布服务到rpc节点上\n    RpcProvider provider; \n    // 把UserService发布到rpc节点上\n    provider.NotifyService(new UserService());\n    \n    // 启动一个rpc服务发布节点\n    provider.Run();\n    // 之后，进程进入阻塞状态，等待远程的rpc调用请求\n}\n```\n## MprpcApplication类\n在`/src/include`中编写头文件\n```cpp\n#pragma once\n// mprpc 框架的基础类，用于初始化框架\n// 单例设计\nclass MprpcApplication\n{\npublic:\n    static void Init(int argc, char ** argv);\n    static MprpcApplication& GetInstance()\n    {\n        static MprpcApplication app;\n        return app;\n    }\nprivate:\n    MprpcApplication()\n    {\n\n    }\n    MprpcApplication(const MprpcApplication&) = delete;\n    MprpcApplication(MprpcApplication&&) = delete;\n};\n```\n## RpcProvider类\n在`/src/include`中编写头文件\n```cpp\n#pragma once\n#include \"google/protobuf/service.h\"\n// 框架提供的专门发布RPC服务的网络对象类\nclass RpcProvider\n{\npublic:\n    // 这里是框架提供给外部使用的，可以发布Service\n    void NotifyService(::google::protobuf::Service * service);\n    // 启动RPC服务节点\n    void Run();\n};\n```\n## CMakeLists.txt\n### 根目录\n```cmake\ncmake_minimum_required(VERSION 3.0)\nproject(mprpc)\n\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)\n\nset(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)\n\ninclude_directories(${PROJECT_SOURCE_DIR}/src/include)\ninclude_directories(${PROJECT_SOURCE_DIR}/example)\nlink_directories(${PROJECT_SOURCE_DIR}/lib)\n\n# 框架的代码\nadd_subdirectory(src)\n# 使用框架的实例代码\nadd_subdirectory(example)\n```\n\nsrc生成的代码就是框架的部分。需要生成一个对外的so库。\n### src目录\n```cmake\n# 当前文件夹中所有文件 别名 SRC_LIST\naux_source_directory(. SRC_LIST)\n# 生成动态库\nadd_library(mprpc SHARED ${SRC_LIST})\n```\n### example目录\n```cmake\nadd_subdirectory(callee)\n```\n### example/callee目录\n```cmake\nset(SRC_LIST userservice.cc ../user.pb.cc)\n\nadd_executable(provider ${SRC_LIST})\n# 声明编译时需要链接mprpc、protobuf动态库\ntarget_link_libraries(provider mprpc protobuf)\n```\n# 流程\n\n1. 编写protobuf文件，作为协议；\n2. 继承rpc服务类。实现rpc方法。\n    1. 获取请求体的参数\n    2. 本地处理业务\n    3. 写入响应体\n    4. 执行回调操作，完成响应数据的序列化，进行发送响应。\n3. 发布服务，启动服务\n    1. 初始化框架\n    2. 定义发布rpc服务的对象（provider）\n    3. 启动rpc服务发布节点。\n4. 服务程序进入等待状态，接受远程rpc调用请求。\n# rpc框架的编写\n\n## MprpcApplication类\n主要需要实现Init函数。\n主要用于使用外部命令行传入的参数，以及读取参数中的配置文件，进行初始化。\n\n1. 可以单独封装一个MprpcConfig类。MprpcApplication类使用它进行config的读取。\n2. Init只需要进行一次，所以将MprpcApplication设计为单例模式。\n3. 由于Init是静态方法，Init方法使用到了类内对象MprpcConfig，因此MprpcConfig成员需要声明为static。\n\n```cpp\n// mprpcapplication.h\n#pragma once\n#include \"mprpcconfig.h\"\n// mprpc 框架的基础类，用于初始化框架\n// 单例设计\nclass MprpcApplication\n{\npublic:\n    static void Init(int argc, char ** argv);\n    static MprpcApplication& GetInstance();\nprivate:\n    static MprpcConfig m_config;\n    MprpcApplication()\n    {\n\n    }\n    MprpcApplication(const MprpcApplication&) = delete;\n    MprpcApplication(MprpcApplication&&) = delete;\n};\n```\n### 实现\n1. ShowArgsHelp函数用于提示用户正确的命令行参数格式\n2. Init函数主要实现\n    1. 检查参数格式\n    2. 通过getopt拿到参数\n    3. 调用MprpcConfig成员的LoadConfigFile方法解析配置文件的信息，即获取rpc服务器和zookeeper的ip、端口\n\n```cpp\n// mprpcapplication.cc\n#include \"mprpcapplication.h\"\n#include <iostream>\n#include <unistd.h>\nMprpcConfig MprpcApplication::m_config;\nMprpcApplication& MprpcApplication::GetInstance()\n{\n    static MprpcApplication app;\n    return app;\n}\n\nvoid ShowArgsHelp()\n{\n    std::cout << \"format: commad -i <configfile>\" << std::endl;\n}\n// 类外实现静态方法，不用前面加static\nvoid MprpcApplication::Init(int argc, char ** argv)\n{\n    if (argc < 2)\n    {\n        ShowArgsHelp();\n        exit(EXIT_FAILURE);\n    }\n    int c = 0;\n    std::string config_file;\n    while((c = getopt(argc, argv, \"i:\")) != -1)\n    {\n        switch (c)\n        {\n        case 'i':\n            // 获取到配置文件的名字\n            config_file = optarg;\n            break;\n        case '?':\n            // std::cout << \"invalid args!\" << std::endl;\n            ShowArgsHelp();\n            exit(EXIT_FAILURE);\n        case ':':\n            // std::cout << \"need <configfile>!\" << std::endl;\n            ShowArgsHelp();\n            exit(EXIT_FAILURE);\n        default:\n            break;\n        }\n    }\n    // 开始加载配置文件 rpcserver_ip rpcserver_port zookeeper_ip zookeeper_port\n    m_config.LoadConfigFile(config_file.c_str());\n\n    std::cout << \"rpcserver_ip: \" << m_config.Load(\"rpcserver_ip\") << std::endl;\n    std::cout << \"rpcserver_port: \" << m_config.Load(\"rpcserver_port\") << std::endl;\n    std::cout << \"zookeeper_ip: \" << m_config.Load(\"zookeeper_ip\") << std::endl;\n    std::cout << \"zookeeper_port: \" << m_config.Load(\"zookeeper_port\") << std::endl;\n}\n```\n若测试的是[注意读取配置文件可能出现的空格、注释、无效信息问题](#注意读取配置文件可能出现的空格、注释、无效信息问题) 中的配置文件，正确结果：\n```bash\nmrcan@ubuntu:~/mprpc/bin$ ./provider -i test.conf \nrpcserver_ip: 127.0.0.1\nrpcserver_port: 8000\nzookeeper_ip: 127.0.0.1\nzookeeper_port: 5000\n```\n## MprpcConfig类\n1. 提供LoadConfigFile方法，负责解析加载配置文件，将key、value插入到自身的map中\n2. 提供Load方法，可以对外提供查询key读取value。\n3. 需要集成一个`unordered_map`记录key、value。\n4. Trim负责在解析配置文件过程中除去字符串前后的空格。\n\n```cpp\n#pragma once\n#include <unordered_map>\n#include <string>\nclass MprpcConfig\n{\npublic:\n    // 负责解析加载配置文件\n    void LoadConfigFile(const char * config_file);\n    // 查询配置项信息\n    std::string Load(const std::string& key);\nprivate:\n    std::unordered_map<std::string, std::string> m_configMap;\n    // 去掉字符串前后的空格\n    void Trim(std::string &str_buf);\n};\n```\n### 注意读取配置文件可能出现的空格、注释、无效信息问题\n```conf\n      # rpc node ip\n  \n   rpcserver_ip        =   127.0.0.1        \n\n\n        # rpc node port\n      rpcserver_port     =     8000  \n\n\n\n    # zookeeper ip\n            zookeeper_ip   =127.0.0.1       \n\n# zookeeper port\n  zookeeper_port= 5000    \n\n\n```\n如上，配置文件可能有：\n1. 注释\n2. 纯空行的换行符可以用gets过滤\n3. 配置项，以=分隔，前面是key，后面是value，可能前后各有空格\n    1. key前后的空格可通过Trim处理，后面肯定没有换行符。\n    2. value只能用Trim处理前面的空格，因为后面可能存在`空格或换行符`：\n        1. `5000\\n`：即没有空格，有一个换行符\n        2. `5000      \\n`：即有空格，有换行符\n        3. 所以需要先去掉末尾的换行符，再进行Trim处理。\n### 实现\n```cpp\n#include \"mprpcconfig.h\"\n#include <iostream>\nvoid MprpcConfig::Trim(std::string &str_buf)\n{\n    // 去掉字符串前面多余的空格\n    int idx = str_buf.find_first_not_of(' ');\n    if (idx > 0)\n    {\n        // 说明字符串前面有空格\n        str_buf = str_buf.substr(idx, str_buf.size() - idx);\n    }\n    // 去掉字符串后面多余的空格\n    idx = str_buf.find_last_not_of(' ');\n    str_buf = str_buf.substr(0, idx + 1);\n}\nvoid MprpcConfig::LoadConfigFile(const char * config_file)\n{\n    FILE *pf = fopen(config_file, \"r\");\n    if (nullptr == pf)\n    {\n        std::cout << config_file << \" not exist!\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    // 1. 注释\n    // 2. 多余的空格\n    // 3. 正确的配置项（以=分隔的）\n    while (!feof(pf))\n    {\n        char buf[512] = {0};\n        fgets(buf, 512, pf);\n        std::string str_buf(buf);\n        Trim(str_buf);\n\n        // 判断 # 开头的注释 或者纯空行\n        if (str_buf[0] == '#' || str_buf.empty())\n        {\n            continue;\n        }\n        int idx = str_buf.find('=');\n        if (idx == -1 || idx == 0)\n        {\n            // 配置项不合法\n            continue;\n        }\n        std::string key;\n        std::string value;\n        key = str_buf.substr(0, idx);\n        // 去掉前后的空格\n        Trim(key);\n\n\n        // 去掉末尾的换行符\n        int lineBreakIdx = str_buf.find('\\n', idx + 1);\n        value = str_buf.substr(idx + 1, lineBreakIdx - (idx + 1));\n        // 去掉前后的空格\n        Trim(value);\n\n        m_configMap.insert({key, value});\n    }\n}\nstd::string MprpcConfig::Load(const std::string& key)\n{\n    auto it = m_configMap.find(key);\n    if (it == m_configMap.end())\n    {\n        return \"\";\n    }\n    return it->second;\n}\n```\n## 修改MprpcApplication\n向其中添加一个公有static方法`GetConfig()`以便RpcProvider获得config对象\n```cpp\n#pragma once\n#include \"mprpcconfig.h\"\n// mprpc 框架的基础类，用于初始化框架\n// 单例设计\nclass MprpcApplication\n{\npublic:\n    static void Init(int argc, char ** argv);\n    static MprpcApplication& GetInstance();\n    // 以便RpcProvider获得config对象\n    static MprpcConfig& GetConfig();\nprivate:\n    static MprpcConfig m_config;\n    MprpcApplication()\n    {\n\n    }\n    MprpcApplication(const MprpcApplication&) = delete;\n    MprpcApplication(MprpcApplication&&) = delete;\n};\n```\n## RpcProvider类\n根据[[#模拟rpc框架的使用，以分析框架需要什么东西]]，框架需要提供一个可以发布服务的RpcProvider。\n主要实现：\n1. NotifyService，是框架提供给外部使用的，可以发布Service\n2. Run，启动RPC服务节点\n3. Stop，停止服务\n\n需要集成一个TcpServer，和搭配一个Eventloop（相当于epoll）。\n但是经过考虑，TcpServer没有必要写为RpcProvider的成员变量，因为只在Run方法中使用。而且我们提供的是一个对外的框架，最好不要把TcpServer的配置、复杂的参数暴露给用户，尽量让用户简单易用。\n而EventLoop可能不仅Run使用，Stop还需要调用它的quit。所以定义为成员变量。\n```cpp\n#pragma once\n#include \"google/protobuf/service.h\"\n#include <muduo/net/TcpServer.h>\n#include <muduo/net/EventLoop.h>\n#include <muduo/net/InetAddress.h>\n// 框架提供的专门发布RPC服务的网络对象类\nclass RpcProvider\n{\npublic:\n    // 这里是框架提供给外部使用的，可以发布Service\n    void NotifyService(::google::protobuf::Service * service);\n    // 启动RPC服务节点\n    void Run();\nprivate:\n    muduo::net::EventLoop m_eventLoop;\n    // 新的socket连接回调\n    void onConnection(const muduo::net::TcpConnectionPtr&);\n    // 已建立连接的用户的读写事件回调\n    // std::function<void (const TcpConnectionPtr&, Buffer*, Timestamp)>\n    void onMessage(const muduo::net::TcpConnectionPtr&, muduo::net::Buffer*, muduo::Timestamp);\n};\n```\n### Run实现\nRun主要实现TcpServer的配置、启动。\n这属于RpcProvider的网络模块。\n```cpp\n#include \"rpcprovider.h\"\n#include \"mprpcapplication.h\"\n#include <functional>\nvoid RpcProvider::Run()\n{\n    std::string ip = MprpcApplication::GetInstance().GetConfig().Load(\"rpcserver_ip\");\n    uint16_t port = atoi(MprpcApplication::GetInstance().GetConfig().Load(\"rpcserver_port\").c_str());\n    muduo::net::InetAddress address(ip, port);\n    // 创建TcpServer对象\n    muduo::net::TcpServer server(&m_eventLoop, address, \"RpcProvider\");\n    // 绑定连接回调和消息读写回调方法 - 分离网络代码和业务代码\n    // 需要给TcpServer提供一个返回值为void，参数有TcpConnectionPtr的函数\n    // 这个函数我们在RpcProvider的成员方法提供\n    // 实际上，onConnection到时候由muduo库进行调用\n    // 调用的就是this对象，然后需要一个_1以预留TcpConnectionPtr& conn这个参数的位置\n    // std::function<void (const TcpConnectionPtr&)>\n    server.setConnectionCallback(std::bind(&RpcProvider::onConnection, this, std::placeholders::_1));\n    // std::function<void (const TcpConnectionPtr&, Buffer*, Timestamp)>\n    server.setMessageCallback(std::bind(&RpcProvider::onMessage, this, \n        std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));\n\n    // 设置muduo库的线程数量\n    server.setThreadNum(4);\n\n    std::cout << \"RpcProvider Start Service at IP: \" << ip << \", port: \" << port << std::endl;\n\n    // 启动网络服务\n    server.start();\n    // 启动epoll_wait，以阻塞的方式等待远程的连接。\n    // 如果有连接请求，则muduo库会回调onConnection\n    // 如果有收发数据请求，则muduo库会回调onMessage\n    m_eventLoop.loop();\n}\n```\n### NotifyService的实现\n发布Rpc服务。\n是`/example/callee/`下的如UserService程序调用的。\n（集成的muduo网络库实现了：不光能调用本地的RpcProvider，而是可以远程调用网络上的任意一个RpcProvider）\n\n怎么做到“发布”？“发布”的本质是什么？其实是记录在案，方便远端查询，并且定位某个方法。\n那么我们就要在RpcProvider类中增加：`m_serviceMap`，记录注册的每一个service名字和这个service对应的所有（n个）method。\n```cpp\n#pragma once\n#include \"google/protobuf/service.h\"\n#include <unordered_map>\n// 框架提供的专门发布RPC服务的网络对象类\nclass RpcProvider\n{\npublic:\n    // ...\nprivate:\n    struct ServiceInfo\n    {\n        google::protobuf::Service * m_service;\n        std::unordered_map<std::string, const google::protobuf::MethodDescriptor*> m_methodMap;\n    };\n    std::unordered_map<std::string, ServiceInfo> m_serviceMap;\n\n    // ...\n};\n```\n当远端一个Service服务器（比如UserService）调用RpcProvider的NotifyService时，便在里面记录信息，这就是注册，就是发布。\n我们可以：\n1. 通过远端传入的Service指针，`service->GetDescriptor()`获得服务描述符`ServiceDescriptor *`，\n2. 从而获得服务的名字`name()`和方法的数量`method_count()`、每一个方法的描述符`MethodDescriptor*`，\n3. 从而获得每一个方法的名字`name()`。\n\n* 把所有方法的名字、方法的描述符记录在`m_methodMap`中。\n* 把服务描述符和`m_methodMap`封装在`ServiceInfo`结构体中。\n* 之后，把服务的名字和这个`ServiceInfo`作为键值对插入到`m_serviceMap`中。\n\n需要引入`<google/protobuf/descriptor.h>`\n```cpp\n#include \"rpcprovider.h\"\n#include \"mprpcapplication.h\"\n#include <functional>\n#include <google/protobuf/descriptor.h>\nvoid RpcProvider::NotifyService(::google::protobuf::Service * service)\n{\n    const google::protobuf::ServiceDescriptor * pserviceDesc = service->GetDescriptor();\n\n    ServiceInfo service_info;\n    service_info.m_service = service;\n    int methodCnt = pserviceDesc->method_count();\n    for(int i = 0; i < methodCnt; ++i)\n    {\n        // 该方法定义于ServiceDescriptor\n        // const MethodDescriptor* method(int index) const; \n        // 返回的是一个MethodDescriptor*\n        // 获取了服务对象指定下标的rpc服务方法的描述\n        const google::protobuf::MethodDescriptor* pmethodDesc = pserviceDesc->method(i);\n        std::string method_name = pmethodDesc->name();\n        std::cout << i << \". method_name: \" << method_name << std::endl;\n        service_info.m_methodMap.insert({method_name, pmethodDesc});\n    }\n    \n    std::string service_name = pserviceDesc->name();\n    std::cout << \"service_name: \" << service_name << std::endl;\n    m_serviceMap.insert({service_name, service_info});\n}\n```\n### OnConnection\n在有新的请求时，会触发OnConnection回调，用于处理连接后的操作。OnConnection的通知调用不是用户调用的，而是muduo库自动调用的。\n我们暂时不用处理什么工作。只是判断一下连接状态是否正常，如果断开了则主动close。\n```cpp\n// 新的socket连接回调\nvoid RpcProvider::onConnection(const muduo::net::TcpConnectionPtr& conn)\n{\n    if (!conn->connected())\n    {\n        conn->shutdown();\n    }\n}\n```\nrpc的连接是短连接，客户端请求、服务端响应之后，服务端就会主动关闭连接。\n### OnMessage\n消息是字节流的。\n```\n// 框架内部，RpcProvider和RpcConsumer协商好通信用的protobuf数据类型\n// 请求时需要提供 service_name method_name args\n// 需要处理包内的粘包问题，比如：UserService和Login以及args在一起，无法区分\n// 因此需要header_size + header_str + args，先把名字部分和参数部分区分开\n// 要注意需要区分args和下一个请求包的 包外粘包问题，需要在header_str中记录args_size\n// 可以通过protobuf定义这个RpcHeader的message类型，根据上述设计，包含了service_name、method_name、args_size\n// header_size指的是RpcHeader这个message包的字符串长度\n// header_size（uint32_t 大小个字节）\n```\n#### 定义rpcheader.proto\n在src下定义此文件（`rpcheader.proto`）\n```protobuf\nsyntax = \"proto3\";\n\npackage mprpc;\n\nmessage RpcHeader\n{\n    bytes service_name = 1;\n    bytes method_name = 2;\n    uint32 args_size = 3;\n}\n```\n之后在此目录下用protoc命令生成cc和h文件。\n```sh\nprotoc rpcheader.proto --cpp_out=./\n```\n\n#### rpcprovider.cc引入rpcheader.pb.h，做读取、解析工作\n1. 解析接收到的字符流`recv_buf`中的内容。\n    1. 取出前4个字节（`sizeof uint32_t`），即`header_size`。（`header_size`指的是RpcHeader这个message包的字符串长度，包含了`service_name`、`method_name`、`args_size`信息）。响应端通过string的`copy`方法读出（相应的写入方法是insert方法，是请求端填写的）。\n    2. 获取了`header_size`之后，在`recv_buf`取出4字节之后的`header_size`长度的字符串，存入`rpc_header_str`。\n    3. 用protobuf生成的RpcHeader的ParseFromString方法即可解析`rpc_header_str`，填入了RpcHeader对象。再调用RpcHeader对象方法`service_name()`、`method_name()`、`args_size()`即可读出解析到的数据。\n    4. 之后，recv_buf的`4字节 + header_size`之后的`args_size`长度的字符串就是args的数据。可以同上述方法解析出内容。\n\n需要引入`\"rpcheader.pb.h\"`\n```cpp\nvoid RpcProvider::onMessage(const muduo::net::TcpConnectionPtr& conn, muduo::net::Buffer* buffer, muduo::Timestamp timestamp)\n{\n    // 接收到的rpc调用请求的字符流\n    // 包含了方法名、参数\n    std::string recv_buf = buffer->retrieveAllAsString();\n    // 从字符流中读取前4个字节的header_size（即按内存中原来的2进制读取）\n    // 有相应的string方法：insert、copy，是按2进制写入、读取固定字节的数据，而不是直接把数字存为长度不一的字符串。\n    uint32_t header_size = 0;\n    // 从recv_buf的 0 位置开始，读取uint32_t 大小个字节，存入header_size。\n    recv_buf.copy((char*)&header_size, sizeof(uint32_t), 0);\n    // 根据header_size读取数据头的原始字符流\n    // substr表示，略过recv_buf的前uint32_t 大小个字节，返回之后的header_size长度的字符串\n    // rpc_header_str 目前保存了service_name method_name args_size\n    std::string rpc_header_str = recv_buf.substr(sizeof(uint32_t), header_size);\n    // 用rpcheader.pb.h生成的rpcHeader中的ParseFromString反序列化rpc_header_str\n    mprpc::RpcHeader rpcHeader;\n    std::string service_name;\n    std::string method_name;\n    uint32_t args_size;\n    if (rpcHeader.ParseFromString(rpc_header_str))\n    {\n        // header反序列化成功\n        service_name = rpcHeader.service_name();\n        method_name = rpcHeader.method_name();\n        args_size = rpcHeader.args_size();\n    }\n    else\n    {\n        // header反序列化失败\n        std::cout << \"rpc_header_str: \" << rpc_header_str << \"parse error!\" << std::endl;\n        return;\n    }\n\n    // 获取rpc方法参数的字符流数据\n    std::string args_str = recv_buf.substr(sizeof(uint32_t) + header_size, args_size);\n\n    // 打印调试信息\n    std::cout << \"==============================\" << std::endl;\n    std::cout << \"header_size: \" << header_size << std::endl;\n    std::cout << \"rpc_header_str: \" << rpc_header_str << std::endl;\n    std::cout << \"service_name: \" << service_name << std::endl;\n    std::cout << \"method_name: \" << method_name << std::endl;\n    std::cout << \"args_str: \" << args_str << std::endl;\n    std::cout << \"==============================\" << std::endl;\n    // ...\n}\n```\n#### 查表获取service对象和method对象\n```cpp\n    // ...\n\n    auto service_it = m_serviceMap.find(service_name);\n    if (service_it == m_serviceMap.end())\n    {\n        std::cout << service_name << \" not exist!\" << std::endl;\n        return;\n    }\n    auto method_it = service_it->second.m_methodMap.find(method_name);\n    if (method_it == service_it->second.m_methodMap.end())\n    {\n        std::cout << method_name << \" not exist in \" << service_name << std::endl;\n        return;\n    }\n    \n    google::protobuf::Service *service = service_it->second.m_service;\n    const google::protobuf::MethodDescriptor *method = method_it->second;\n    // ...\n```\n#### `service->GetRequestPrototype(method).New()`生成request和response\n```cpp\n    // ...\n\n    // 生成rpc方法调用的请求request和响应response\n    google::protobuf::Message *request = service->GetRequestPrototype(method).New();\n    if (!request->ParseFromString(args_str))\n    {\n        std::cout << \"request parse args_str error! args_str: \" << args_str << std::endl;\n        return;\n    }\n    google::protobuf::Message *response = service->GetResponsePrototype(method).New();\n    // ...\n```\n#### `google::protobuf::NewCallback<>`生成回调函数\n```cpp\n    // ...\n    \n    // 给下面的method方法的调用，绑定一个Closure的回调函数\n    google::protobuf::Closure* done = google::protobuf::NewCallback\n        <RpcProvider, const muduo::net::TcpConnectionPtr&, google::protobuf::Message*>\n            (this, &RpcProvider::SendRpcResponse, conn, response);\n\n    // 在框架上根据远端rpc请求，调用当前rpc节点上发布的方法\n    service->CallMethod(method, nullptr, request, response, done);\n}\n```\n#### 编写`RpcProvider::SendRpcResponse()`\n```cpp\nvoid RpcProvider::SendRpcResponse(const muduo::net::TcpConnectionPtr& conn, google::protobuf::Message* response)\n{\n    std::string response_str;\n    // 将response序列化为字符流\n    if (response->SerializeToString(&response_str))\n    {\n        // 序列化成功后，通过网络把rpc方法执行的结果发送回rpc的调用方\n        conn->send(response_str);\n    }\n    else\n    {\n        std::cout << \"Serialize response_str error!\" << std::endl;\n    }\n    conn->shutdown(); // 短连接效果，由rpcprovider主动断开连接，让出服务器资源。\n}\n```\n## Mprpcchannel类\n```cpp\n#pragma once\n#include <google/protobuf/service.h>\n#include <google/protobuf/descriptor.h>\n#include <google/protobuf/message.h>\nclass MprpcChannel : public google::protobuf::RpcChannel\n{\npublic:\n    // 所有通过stub代理对象调用的rpc方法，都走到这里了，统一做rpc方法调用的数据数据序列化和网络发送\n    void CallMethod(const google::protobuf::MethodDescriptor *method,\n                    google::protobuf::RpcController *controller, const google::protobuf::Message *request,\n                    google::protobuf::Message *response, google::protobuf::Closure *done);\n       \n};\n```\n在这个方法中，处理服务调用方的请求包。\n\n这个请求包只包含rpc调用的函数参数（args），不包含服务名、方法名。服务名、方法名可以用`method`参数查到。\n\n把请求包（只包含args）序列化，得到序列化之后的args字符流`args_str`长度`args_size`。\n\n填写 RpcHeader（`service_name`、`method_name`、`args_size`），序列化后得到 RpcHeader的字符流`rpc_header_str`长度`header_size`\n\n之后按照约定好的格式，把`header_size`、`rpc_header_str`、`args_str`格式化填充、拼接到`send_rpc_str`。\n\n之后便是TCP客户端编程，把`send_rpc_str`发送到配置文件中的远端ip、端口。\n\n等待远端响应的数据，解析响应数据。填入了response。\n\nCallMethod结束，Channel的使命结束，Stub的使命结束。\n\n调用栈就回到了服务调用方的主程序中，输出response。\n见[服务调用者主程序](#服务调用者主程序)\n\n>服务调用方是通过Channel得知远端服务提供方的ip、端口的。\n### 实现\n```cpp\n#include \"mprpcchannel.h\"\n#include \"rpcheader.pb.h\"\n#include \"mprpcapplication.h\"\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <error.h>\n// 约定好的包格式：（header_size)(service_name method_name args_size)(args)\nvoid MprpcChannel::CallMethod(const google::protobuf::MethodDescriptor *method,\n    google::protobuf::RpcController *controller, const google::protobuf::Message *request,\n    google::protobuf::Message *response, google::protobuf::Closure *done)\n{\n    const google::protobuf::ServiceDescriptor *sd = method->service();\n    std::string service_name = sd->name();\n    std::string method_name = method->name();\n    \n    // 序列化(args)，之后才能获取args的序列化字符串长度 args_size\n    uint32_t args_size = 0;\n    std::string args_str;\n    if (request->SerializeToString(&args_str))\n    {\n        args_size = args_str.size();\n    }\n    else\n    {\n        std::cout << \"serialize request error!\" << std::endl;\n        return;\n    }\n    // 填写rpc的请求header\n    mprpc::RpcHeader rpcHeader;\n    rpcHeader.set_service_name(service_name);\n    rpcHeader.set_method_name(method_name);\n    rpcHeader.set_args_size(args_size);\n    // 序列化（header_size)(service_name method_name args_size)\n    uint32_t header_size = 0;\n    std::string rpc_header_str;\n    if (rpcHeader.SerializeToString(&rpc_header_str))\n    {\n        header_size = rpc_header_str.size();\n    }\n    else\n    {\n        std::cout << \"serialize request error!\" << std::endl;\n        return;\n    }\n\n    std::string send_rpc_str;\n    send_rpc_str.insert(0, std::string((char*)&header_size, 4));\n    send_rpc_str += rpc_header_str;\n    send_rpc_str += args_str;\n\n    // 打印调试信息\n    std::cout << \"==============================\" << std::endl;\n    std::cout << \"header_size: \" << header_size << std::endl;\n    std::cout << \"rpc_header_str: \" << rpc_header_str << std::endl;\n    std::cout << \"service_name: \" << service_name << std::endl;\n    std::cout << \"method_name: \" << method_name << std::endl;\n    std::cout << \"args_str: \" << args_str << std::endl;\n    std::cout << \"==============================\" << std::endl;\n\n    // 使用tcp编程，完成rpc方法的远程调用\n    int cliendfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == cliendfd)\n    {\n        std::cout << \"Create Socket Error: \" << errno << std::endl;\n        exit(EXIT_FAILURE);\n    }\n\n    // 读取配置文件rpcserver的信息\n    std::string ip = MprpcApplication::GetInstance().GetConfig().Load(\"rpcserver_ip\");\n    uint16_t port = atoi(MprpcApplication::GetInstance().GetConfig().Load(\"rpcserver_port\").c_str());\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    if (-1 == inet_pton(AF_INET, ip.c_str(), &(server_addr.sin_addr.s_addr)))\n    {\n        std::cout << \"inet_pton Error: \" << errno << std::endl;\n        close(cliendfd);\n        exit(EXIT_FAILURE);\n    }\n    if (-1 == connect(cliendfd, (struct sockaddr*)&server_addr, sizeof(server_addr)))\n    {\n        std::cout << \"connect Error: \" << errno << std::endl;\n        close(cliendfd);\n        exit(EXIT_FAILURE);\n    }\n    if (-1 == send(cliendfd, send_rpc_str.c_str(), send_rpc_str.size(), 0))\n    {\n        std::cout << \"send Error: \" << errno << std::endl;\n        close(cliendfd);\n        exit(EXIT_FAILURE);\n    }\n    char recv_buff[1024] = {0};\n    int recv_size = 0;\n    if (-1 == (recv_size = recv(cliendfd, recv_buff, sizeof(recv_buff), 0)))\n    {\n        std::cout << \"recv Error: \" << errno << std::endl;\n        close(cliendfd);\n        exit(EXIT_FAILURE);\n    }\n    // 反序列化rpc调用的响应数据\n    // std::string response_str(recv_buff, 0, recv_size); // 如此构造有问题，如果recv_buff中存在\\0则断开。\n    // if (!response->ParseFromString(response_str))\n    if (!response->ParseFromArray(recv_buff, recv_size))\n    {\n        std::cout << \"parse response_str error! response_str: \" << recv_buff << std::endl;\n        close(cliendfd);\n        return;\n    }\n    close(cliendfd);\n}\n```\n## MprpcController 的作用\n用于记录rpc调用过程中的状态信息。\n试想，如果请求过程中，或者响应过程中，某一环节除了问题，那么服务调用方就拿不到response任何内容了，那么它去看了个寂寞？也不清楚是哪个环节出错了。这时候可以在参数中传入`mprpccontroller`的指针，让对应的MprpcController对象在内部记录状态信息。\n```cpp\n#pragma once\n#include <google/protobuf/service.h>\nclass MprpcController : public google::protobuf::RpcController\n{\npublic:\n    MprpcController();\n    void Reset();\n    bool Failed() const;\n    std::string ErrorText() const;\n    void SetFailed(const std::string& reason);\n\n    // 暂时空实现\n    void StartCancel();\n    bool IsCanceled() const;\n    void NotifyOnCancel(google::protobuf::Closure *callback);\nprivate:\n    // RPC方法执行过程中的状态\n    bool m_failed;\n    // RPC方法执行过程中的错误信息\n    std::string m_errText;\n};\n```\n### 实现\n```cpp\n#include \"mprpccontroller.h\"\nMprpcController::MprpcController()\n{\n    m_failed = false;\n    m_errText = \"\";\n}\nvoid MprpcController::Reset()\n{\n    m_failed = false;\n    m_errText = \"\";\n}\nbool MprpcController::Failed() const\n{\n    return m_failed;\n}\nstd::string MprpcController::ErrorText() const\n{\n    return m_errText;\n}\nvoid MprpcController::SetFailed(const std::string& reason)\n{\n    m_failed = true;\n    m_errText = reason;\n}\nvoid MprpcController::StartCancel(){}\nbool MprpcController::IsCanceled() const { return false; }\nvoid MprpcController::NotifyOnCancel(google::protobuf::Closure *callback){}\n```\n### 如何使用\n比如在`calluserservice.cc`下，可以：\n在stub调用某方法前，定义一个MprpcController对象，之后把其指针传到调用方法的函数参数内。\n在读取response前，先判断controller的状态信息。如果错误就不读了。\n\n```cpp\n#include \"mprpccontroller.h\"\n// ...\n    // 发起rpc方法的调用。\n    MprpcController controller;\n    stub.Login(&controller, &request, &response, nullptr);\n    \n    if (controller.Failed()) // rpc调用过程中有异常，response没有填入数据\n    {\n        std::cout << controller.ErrorText() << std::endl;\n    }\n    else // 一次rpc调用结束，返回了，读返回的response结果\n    {\n        if (response.result().errcode() == 0)\n        {\n            // 成功\n            std::cout << \"rpc login response success: \" << response.success() << std::endl;\n        }\n        else\n        {\n            std::cout << \"rpc login response error: \" << response.result().errmsg() << std::endl;\n        }\n    }\n    return 0;\n}\n```\n在`mprpcchannel.cc`中，有可能出现异常的地方，均用controller记录。\n\n别忘了在src下的CMakeLists中的`set(SRC_LIST ... )`后面添加上`mprpccontroller.cc`。\n## 日志类\n## 编译\n框架依赖muduo库，因此需要在src目录下的`CMakeLists.txt`添加：\n\n>如果忘记了库叫什么名字，可以在`/usr/lib`或`/usr/local/lib`下查找：\n\n```bash\nsudo find /usr -name \"libmuduo*\"\n```\n\n```bash\n/usr/local/lib/libmuduo_http.a\n/usr/local/lib/libmuduo_net.a\n/usr/local/lib/libmuduo_base.a\n/usr/local/lib/libmuduo_inspect.a\n```\n\n我们需要的muduo的库名：muduo_net、muduo_base\n```cmake\n# 当前文件夹中所有文件 别名 SRC_LIST\naux_source_directory(. SRC_LIST)\n# 生成动态库\nadd_library(mprpc SHARED ${SRC_LIST})\n# 依赖muduo库\ntarget_link_libraries(mprpc muduo_net muduo_base pthread)\n```\n由于我们在编译muduo时编译成了静态库，而我们现在CMake指定生成的是动态库（`add_library(mprpc SHARED ${SRC_LIST})`）。\n由于里面有静态库成分，所以编译链接时会报错，因此我们暂时先生成静态库。\n```cmake\n# 当前文件夹中所有文件 别名 SRC_LIST\naux_source_directory(. SRC_LIST)\n# 生成静态库\nadd_library(mprpc ${SRC_LIST})\n# 依赖muduo库\ntarget_link_libraries(mprpc muduo_net muduo_base pthread)\n```\n\n测试：\n```bash\nmrcan@ubuntu:~/mprpc/bin$ ./provider -i test.conf \nrpcserver_ip: 127.0.0.1\nrpcserver_port: 8000\nzookeeper_ip: 127.0.0.1\nzookeeper_port: 5000\nRpcProvider Start Service at IP: 127.0.0.1, port: 8000\n```\n\n### `aux_source_directory`存在的问题\n`~/mprpc/src`下的`CMakeLists.txt`原本是如下定义的：\n```cmake\n# 当前文件夹中所有文件 别名 SRC_LIST\naux_source_directory(. SRC_LIST)\n# 生成静态库\nadd_library(mprpc ${SRC_LIST})\n# 依赖muduo库\ntarget_link_libraries(mprpc muduo_net muduo_base pthread)\n```\n\n`aux_source_directory(. SRC_LIST)`表示给当前文件夹下的所有内容起了别名`SRC_LIST`。\n一开始构建、编译没什么问题，但后面发现如果我们给src目录增加`.cc`文件后再进行编译则无法找到这些新增的文件。\n\n说明build只记录了当时`src`目录下的旧文件，而没有记录新增的文件。\n所以我们还是这么写吧：\n```cmake\n# 当前文件夹中所有文件 别名 SRC_LIST\nset(SRC_LIST mprpcapplication.cc mprpcconfig.cc rpcheader.cc rpcprovider.cc)\n\n# 生成静态库\nadd_library(mprpc ${SRC_LIST})\n# 依赖muduo库\ntarget_link_libraries(mprpc muduo_net muduo_base pthread)\n```\n\n# 调试\n\n在顶级cmake写下：`set(CMAKE_BUILD_TYPE \"Debug\")`\n![](../../images/mprpc_rpc框架/image-20250713173928826.png)\n运行：\n```bash\ngdb ./provider\n```\n![](../../images/mprpc_rpc框架/image-20250713174142619.png)\nbreak加断点，由于我们是生成了so动态链接库，所以会有如下提示：\n```gdb\nbreak mprpcconfig.cc:第n行\n```\n![](../../images/mprpc_rpc框架/image-20250713174407071.png)\n加完断点后，run，运行程序。（gdb调试时，如果有参数，正确启动方式是：`run arg1 arg2`）\n```gdb\nrun -i test.conf\n```\n结果：\n![](../../images/mprpc_rpc框架/image-20250713174720348.png)\n调试过程中，可以敲入bt查看栈帧信息，l查看源代码信息。\nbt\n![](../../images/mprpc_rpc框架/image-20250713174846521.png)\nl\n![](../../images/mprpc_rpc框架/image-20250713174857557.png)\n敲入n可以单步执行。\n![](../../images/mprpc_rpc框架/image-20250713174922879.png)\np + 变量名，可以打印变量的值。\n![](../../images/mprpc_rpc框架/image-20250713174949860.png)\nq退出调试\n# zookeeper\nchannel一开始不知道服务节点的ip、port，需要先去查找。\n","categories":["项目","rpc"]},{"title":"Android_Handler","url":"/Android/Android_Handler/","content":"\n# 概念\n\nHandler、MessageQueue、Runnable、Looper。\n\n# Runnable和Message\n\nRunnable和Message可以被压入某个MessageQueue中，形成一个集合。\n\n注意，一般情况下某种类型的MessageQueue只允许保存相同类型的 Object。图中我们只是为了叙述方便才将它们混放在同一个MessageQueue中，实际源码中需要先对Runnable进行相应转换。\n\n# Looper循环地去做某件事\n\n比如在这个例子中，它不断地从MessageQueue中取出一个item，然后传给Handler进行处理，如此循环往复。假如队列为空，那么它会进入休眠。\n\n# Handler是真正处理事情的地方\n\n它利用自身的处理机制，对传入的各种Object进行相应的处理并产生最终结果。\n\n用一句话来概括它们，就是：Looper不断获取MessageQueue中的一个Message，然后由Handler来处理。\n\n可以看出，上面的几个对象是缺一不可的。它们各司其职，很像一台计算机中CPU的工作式：中央处理器（Looper）不断地从内存（MessageQueue）中读取指令（Message），执行指令（Handler），最终产生结果。当然，到目前为止我们还只是从逻辑的层面理清了它们的关系，接下来将从代码的角度来验证这些假设的真实可靠性。","categories":["Android"]},{"title":"Android_广播","url":"/Android/Android_广播/","content":"\n# 广播\n\nAndroid中的每个应用程序都可以对自己感兴趣的广播进行注册，这些广播可能是来自于系统的，也可能是来自于其他应用程序的。\n\nAndroid提供了一套完整的API，允许应用程序自由地发送和接收广播。\n\n广播主要可以分为两种类型：标准广播和有序广播。\n\n## 标准广播\n\n完全异步执行。广播发出之后，所有的BroadcastReceiver几乎会在同一时间收到这条广播消息。这种广播效率比较高，同时也意味着它是无法截断的。\n\n## 有序广播\n\n有序广播是一种同步执行的广播，广播发出之后，同一时刻只会有一个BroadcastReceiver能够收到这条广播消息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。\n\n优先级较高的BroadcastReceiver可以先收到广播消息，并且前面的BroadcastReceiver还可以截断正在传递的广播，这样后面的BroadcastReceiver就无法收到广播消息了。\n\n# 接收系统广播\n\nAndroid内置了很多系统级别的广播，可以在应用程序中通过监听这些广播来得到各种系统的状态信息。比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播，系统时间发生改变也会发出一条广播，等等。如果想要接收这些广播，就需要使用BroadcastReceiver。\n\n应用可以根据感兴趣的广播，自由地注册BroadcastReceiver，这样当有相应的广播发出时，相应的BroadcastReceiver就能够收到该广播，并可以在内部进行逻辑处理。\n\n注册BroadcastReceiver的方式一般有两种：在代码中注册和在AndroidManifest.xml中注册。其中前者也被称为动态注册，后者也被称为静态注册。\n\n## 动态注册监听时间变化\n\n创建一个BroadcastReceiver其实只需新建一个类，让它继承自BroadcastReceiver，并重写父类的onReceive方法就行了。这样当有广播到来时，onReceive方法就会得到执行，具体的逻辑就可以在这个方法中处理。\n\n下面先通过动态注册的方式编写一个能够监听时间变化的程序，体会BroadcastReceiver的基本用法。新建一个BroadcastTest项目，然后修改MainActivity中的代码。\n\n如下所示：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    inner class TimeChangeReceiver : BroadcastReceiver() {\n        override fun onReceive(context: Context, intent: Intent) {\n            Toast.makeText(context, \"Time has changed\", Toast.LENGTH_SHORT).show()\n        }\n    }\n    \n    lateinit var timeChangeReceiver: TimeChangeReceiver\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        val intentFilter = IntentFilter()\n        intentFilter.addAction(\"android.intent.action.TIME_TICK\")\n        timeChangeReceiver = TimeChangeReceiver()\n        registerReceiver(timeChangeReceiver, intentFilter)\n    }\n    \n    override fun onDestroy() {\n        super.onDestroy()\n        unregisterReceiver(timeChangeReceiver)\n    }\n}\n```\n\n在MainActivity中定义了一个内部类TimeChangeReceiver，这个类是继承自BroadcastReceiver的，并重写了父类的onReceive方法。这样每当系统时间发生变化时，onReceive方法就会得到执行，这里只是简单地使用Toast提示了一段文本信息。\n\n然后观察onCreate方法，首先我们创建了一个IntentFilter的实例，并给它添加了一个值为`android.intent.action.TIME_TICK`的action，每当系统时间发生变化时，系统发出此值的广播。BroadcastReceiver想要监听什么广播，就在这里添加相应的action。\n\n接下来创建了一个TimeChangeReceiver的实例，然后调用registerReceiver方法进行注册，将TimeChangeReceiver的实例和IntentFilter的实例都传了进去，这样TimeChangeReceiver就会收到所有值为`android.intent.action.TIME_TICK`的广播，也就实现了监听系统时间变化的功能。\n\n最后要记得，一定要注销动态注册的BroadcastReceiver才行，在onDestroy方法中通过调用unregisterReceiver方法来实现。\n\n现在运行一下程序，然后静静等待时间发生变化。系统每隔一分钟就会发出一条`android.intent.action.TIME_TICK`的广播，因此最多只需要等待一分钟就可以收到这条广播。\n\n### 总结\n\n接收其他系统广播的用法是一模一样的。Android 系统还会在亮屏熄屏、电量变化、网络变化等场景下发出厂播。完整的系统厂播列表到如下的路径中查看：`<Android SDK>/platforms/<任意android api版本>/data/broadcast_actions.txt`。\n\n## 静态注册实现开机启动\n\n动态注册的BroadcastReceiver可以自由地控制注册与注销，在灵活性方面有很大的优势。但是它存在着一个缺点，即必须在程序启动之后才能接收广播，因为注册的逻辑是写在onCreate方法中的。\n\n让程序在未启动的情况下也能接收广播需要使用静态注册的方式。从理论上来说，动态注册能监听到的系统广播，静态注册也应该能监听到，在过去的Android系统中确实是这样。但是由于大量恶意的应用程序利用这个机制在程序未启动的情况下监听系统广播，从而使任何应用都可以频繁地从后台被唤醒，严重影响了用户手机的电量和性能，因此Android系统几乎每个版本都在削减静态注册BroadcastReceiver的功能。\n\n## 隐式广播\n\n在Android 8.0系统之后，所有隐式广播都不允许使用静态注册的方式来接收了。隐式广播指的是那些没有具体指定发送给哪个应用程序的广播，大多数系统广播属于隐式广播，但是少数特殊的系统广播目前仍然允许使用静态注册的方式来接收。这些特殊的系统广播列表详见https://developer.android.google.cn/guide/components/broadcast-exceptions.html。\n\n在这些特殊的系统广播当中，有一条值为`android.intent.action.BOOT_COMPLETED`的广播，是一条开机广播，用它来举例。\n\n实现一个开机启动的功能。在开机的时候，应用程序肯定是没有启动的，因此这个功能显然不能使用动态注册的方式来实现，而应该使用静态注册的方式来接收开机广播，然后在onReceive方法里执行相应的逻辑，这样就可以实现开机启动的功能了。\n\n```kotlin\nclass BootCompleteReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        Toast.makeText(context, \"Boot Complete\", Toast.LENGTH_LONG).show()\n    }\n}\n```\n\n静态的BroadcastReceiver一定要在AndroidManifest.xml文件中注册才可以使用。\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.broadcasttest\">\n    <application android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        ...\n        <!-- + -->\n        <receiver\n            android:name=\".BootCompleteReceiver\"\n            android:enabled=\"true\"\n            android:exported=\"true\">\n        </receiver>\n    </appLication>\n</manifest>\n```\n\n可以看到，`<application>`标签内出现了一个新的标签`<receiver>`所有静态的BroadcastReceiver都是在这里进行注册的。它的用法其实和`<activity>`标签非常相似，也是通过`android:name`指定具体注册哪一个BroadcastReceiver，Exported属性表示是否允许这个BroadcastReceiver**接收本程序以外的广播**，Enabled属性表示是否启用这个BroadcastReceiver。\n\n不过目前的BootCompleteReceiver是无法收到开机广播的，还需要对AndroidManifest.xml文件进行修改才行，如下所示：\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.broadcasttest\">\n    <!-- + -->\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\n    <application android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        ...\n        <receiver\n            android:name=\".BootCompleteReceiver\"\n            android:enabled=\"true\"\n            android:exported=\"true\">\n            <!-- + -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n            </intent-filter>\n        </receiver>\n    </appLication>\n</manifest>\n```\n\n由于Android系统启动完成后会发出一条值为`android.intent.action.BOOT_COMPLETED`的广播，因此我们在`<receiver>`标签中又添加了一个`<intent-filter>`标签，并在里面声明了相应的action。\n\n另外，Android系统为了保护用户设备的安全和隐私，做了严格的规定：如果程序需要进行一些对用户来说比较敏感的操作，必须在AndroidManifest.xml文件中进行权限声明。否则程序将会直接崩溃。比如这里接收系统的开机广播就是需要进行权限声明的，所以我们在上述代码中使用`<uses-permission>`标签声明了`android.permission.RECEIVE_BOOT_COMPLETED`——接收系统开机广播的权限。Android 6.0系统中引入了更加严格的运行时权限，从而能够更好地保证用户设备的安全和隐私。\n\n重新运行程序，则程序已经可以接收开机广播了。重启设备，在启动完成之后就会收到开机广播。\n\n### 总结\n\n需要注意的是，不要在onReceive方法中添加过多的逻辑或者进行任何的耗时操作，因为BroadcastReceiver中是不允许开启线程的，当onReceive方法运行了较长时间而没有结束时，程序就会出现错误。\n\n# 发送自定义广播\n\n前面讲的是系统广播，现在看一下在应用程序中发送自定义的广播。\n\n## 发送标准广播\n\n在发送广播之前，我们还是需要先定义一个BroadcastReceiver来准备接收此广播，不然发出去也是白发。因此新建一个MyBroadcastReceiver，并在onReceive方法中加人如下代码：\n\n```kotlin\nclass MyBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceiver(context: Context, intent: Intent) {\n        Toast.makeText(context, \"received in MyBroadcastReceiver\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n\n当MyBroadcastReceiver收到自定义的广播时。就会弹出\"received in MyBroadcastReceiver\"的提示。然后在AndroidManifest.xml中对这个BroadcastReceiver进行修改：\n\n```xml\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n    <application\n        ...>\n        <receiver android:name=\".MyBroadcastReceiver\"\n            android:enabled=\"true\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"com.example.broadcasttest.MY_BROADCAST\"/>\n            </intent-filter>\n        </receiver>\n    </application>\n```\n\n可以看到，这里让MyBroadcastReceiver接收一条值为`com.example.broadcasttest.MY_BROADCAST`的广播，因此待会儿在发送广播的时候，我们就需要发出这样的一条广播。\n\n接下来修改`activity_main.xml`中的代码，如下：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n    <Button\n        android:id=\"@+id/button\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Send Broadcast\">\n    </Button>\n\n</LinearLayout>\n```\n\n这里在布局文件中定义了一个按钮。用于作为发送广播的触发点。\n\n然后修改MainActivity中的代码，如下所示：\n\n```kotlin\nclass MyBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        Toast.makeText(context, \"received in MyBroadcastReceiver\",\n            Toast.LENGTH_LONG).show()\n    }\n}\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        val button: Button = findViewById(R.id.button)\n        button.setOnClickListener {\n            val intent = Intent(\"com.example.broadcasttest.MY_BROADCAST\")\n            intent.setPackage(packageName)\n            sendBroadcast(intent)\n        }\n    }\n}\n```\n\n可以看到，我们在按钮的点击事件里面加入了发送自定义广播的逻辑。\n\n首先构建了一个Intent对象并把要发送的广播的值传入。然后调用Intent的setPackage方法，并传入当前应用程序的包名。packageName是getPackageName的语法糖写法，用于获取当前应用程序的包名。最后调用sendBroadcast方法将广播发送出去，这样所有监听`com.example.broadcasttest.MY_BROADCAST`这条广播的BroadcastReceiver就会收到消息了。\n\n此时发出去的广播就是一条**标准广播**。\n\n> 对setPackage方法进行更详细的说明：前面已经说过，在Android8.0系统之后，静态注册的BroadcastReceiver是无法接收隐式广播的，而**默认情况下我们发出的自定义广播恰恰都是隐式广播**。因此这里一定要调用setPackage方法，指定这条广播是发送给哪个应用程序的，从而让它变成一条显式广播，否则静态注册的BroadcastReceiver将无法接收到这条广播。\n\n现在重新运行程序并点击\"Send Broadcast\"按钮，即可看到效果。\n\n另外，由于广播是使用Intent来发送的、因此你还可以在Intent中携带一些数据传递给相应的BroadcastReceiver，这一点和Activity的用法是比较相似的。\n\n## 发送有序广播\n\n和标准广播不同，有序广播是一种同步执行的广播，并且是可以被截断的。为了验证这一点，我们需要再创建一个新的BroadcastReceiver。新建AnotherBroadcastReceiver，代码如下所示：\n\n```kotlin\nclass AnotherBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        Toast.makeText(context, \"received in AnotherBroadcastReceiver\",\n            Toast.LENGTH_SHORT).show()\n    }\n}\n```\n\n很简单，这里仍然是在onReceive方法中弹出了一段文本信息。\n\n然后在AndroidManifest.xml中对这个BroadcastReceiver的配置进行修改，代码如下所示：\n\n```xml\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n    <application\n        ...>\n        <receiver\n            android:name=\".AnotherBroadcastReceiver\"\n            android:enabled=\"true\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"com.example.broadcasttest.MY_BROADCAST\" />\n            </intent-filter>\n        </receiver>\n    </application>\n```\n\n可以看到，AnotherBroadcastReceiver同样接收的是`com.example.broadcasttest.MY_BROADCAST`这条广播。现在重新运行程序，并点击\"Send Broadcast\"按钮，就会分别弹出两次提示信息。\n\n不过，到目前为止，程序发出的都是标准广播。现在我们来尝试一下发送有序广播。重新回到BroadcastTest项目，然后修改MainActivity中的代码，如下所示：\n\n```kotlin\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        val button: Button = findViewById(R.id.button)\n        button.setOnClickListener {\n            val intent = Intent(\"com.example.broadcasttest.MY_BROADCAST\")\n            intent.setPackage(packageName)\n            // modify\n            sendOrderedBroadcast(intent, null)\n        }\n```\n\n可以看到，发送有序广播只需要改动一行代码，即将sendBroadcast方法改成sendOrderedBroadcast方法。send0rderedBroadcast方法接收两个参数：第一个参数仍然是Intent；第二个参数是一个**与权限相关的字符串**，这里传入null就行了。现在重新运行程序，并点击\"Send Broadcast\"按钮，你会发现，两个BroadcastReceiver仍然都可以收到这条广播。\n\n看上去好像和标准广播并没有什么区别。不过别忘了，这个时候的BroadcastReceiver是有先后顺序的，而且前面的BroadcastReceiver还可以将广播截断，以阻止其继续传播。\n\n设定BroadcastReceiver的先后顺序：在注册的时候进行设定。修改AndroidManifest.xml中的代码，如下所示：\n\n```xml\n<receiver\n    android:name=\".MyBroadcastReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\">\n                   <!-- + -->\n    <intent-filter android:priority=\"100\">\n        <action android:name=\"com.example.broadcasttest.MY_BROADCAST\"/>\n    </intent-filter>\n</receiver>\n```\n\n可以看到，我们通过`android:priority`属性给`BroadcastReceiver`设置了优先级，优先级比较高的BroadcastReceiver就可以先收到广播。这里将MyBroadcastReceiver的优先级设成了100。以保证它一定会在AnotherBroadcastReceiver之前收到广播。\n\n既然已经获得了接收广播的优先权，那么MyBroadcastReceiver就可以选择是否允许广播继续传递了。修改MyBroadcastReceiver中的代码，如下所示：\n\n```kotlin\nclass MyBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        Toast.makeText(context, \"received in MyBroadcastReceiver\",\n            Toast.LENGTH_SHORT).show()\n        // modify\n        abortBroadcast()\n    }\n}\n```\n\n如果在onReceive方法中调用了abortBroadcast方法，就表示将这条广播截断，后面的BroadcastReceiver将无法再接收到这条广播。\n\n现在重新运行程序，并点击\"Send Broadcast\"按钮，你会发现只有MyBroadcastReceiver中的Toast信息能够弹出，说明这条广播经过MyBroadcastReceiver之后确实终止传递了。","categories":["Android"]},{"title":"Linux_vim_\".\"命令","url":"/Linux/Linux_vim_.命令/","content":"\n# `.`命令\n\n`.`命令可以让我们重复上次的修改，它是vim中最为强大的多面手。\n\n首先我们要问∶\"究竟什么是修改？\"\n\n\"上次修改\"可以指很多东西，一次修改的单位可以是字符、整行，甚至是整个文件。\n\n# 例子：删除x、dd\n\n`x`命令会删除光标下的字符，在这种情况下使用。命令\"重复上次修改\"时，就会让Vim删除光标下的字符。\n\n![image-20220831180112530](../../images/Linux_vim_.命令/image-20220831180112530.png)\n\ndd命令也做删除操作，但它会把整行一起删掉。如果在dd后使用、命令，那么\"重复上次修改\"会让 Vim删除当前行。\n\n# 例子：缩进`>G`\n\n最后，`>G`命令会增加从当前行到文档末尾处的缩进层级。如果在此命令后使用命令，那么\"重复上次修改\"会让Vim增加从当前行到文档末尾的缩进层级。在下例中，让光标从第二行开始（vim中，`j`代表向下，`k`代表向上，`h`代表向左，`l`代表向右），以便一目了然地看出差别。\n\n![image-20220831201942872](../../images/Linux_vim_.命令/image-20220831201942872.png)\n\n## 总结\n\n`j`代表向下，`k`代表向上，`h`代表向左，`l`代表向右。\n\n# vim会记录每一个按键操作：`.`命令是一个微型的宏\n\n`x`、`dd`以及`>`命令都是在普通模式中执行的命令，不过，每次进入插入模式时，也会形成一次修改。从进入插入模式的那一刻起（例如，输入`i`），直到返回普通模式时为止（输入`<Esc>`），Vim会记录每一个按键操作。做出这样一个修改后再用命令的话，它将会重新执行所有这些按键操作（在插入模式中移动光标也会重置修改状态）。\n\nvim可以录制任意数目的按键操作，然后在以后重复执行它们。这让我们可以把最常重复的工作流程录制下来，并用一个按键重放它们。可以把`.`命令当成一个很小的宏（macro）。\n\n# 减少无关的移动\n\n在每行的结尾添加一个分号。要实现这一点，先得把光标移到行尾，然后切换到插入模式进行修改。`$`命令可以完成移动动作，接着就可以执行`a;<Esc>`完成修改了。\n\n要完成全部修改，需要对所有行做完全相同的操作，但是，由于命令可以重复上次的修改，因此不必重复之前的操作，而是执行两次`j$.`。一个`.`键顶3个`a;<Esc>`，虽然每次省得并不多，不过在重复操作时，累积效应可不小。\n\n`j`命令使光标下移一行，而`$`命令把光标移到行尾。我们用了两下按键，仅仅是为了把光标移到指定位置，以便可以用`.`命令。应该还有改进的余地。\n\n`a`命令在当前光标之后添加内容，`A`命令则在当前行的结尾添加内容。不管光标当前处于什么位置，输入`A`都会进入插入模式，并把光标移到行尾。换句话说，它把`$a`封装成了一个按键操作。Vim提供了不少这样的复合命令。\n\n![image-20220831210516363](../../images/Linux_vim_.命令/image-20220831210516363.png)\n\n用`A`来代替`$a`，大大提升了`.`命令的效率。不必再把光标移到行尾，只需保证它位于该行内就行了（可在任意位置）。现在可以重复执行足够多次的`j.`，完成对后续行的修改。\n\n一个键移动，另一个键操作，请留意这种应用模式，更多的例子中将看到它的身影。\n\n虽然这一模式对这个简短的例子来说很好用，但它不是万能的。试想一下，如果我们不得不给连续50行添加分号，即便每修改一次输一次`j`，看起来也是一项很繁重的工作。\n\n## 一箭双雕\n\n我们可以这样说，A命令把两个动作（`$a`）合并成了一次按键，不过它不是唯一一个这样的命令，很多Vim的单键命令都可以被看成两个或多个其他命令的组合，下表列出了类似的一些例子，找出它们之间别的共同点。\n\n| 复合命令 | 等效的长命令                                                 |\n| -------- | ------------------------------------------------------------ |\n| C        | `c$`                                                         |\n| s        | `cl`                                                         |\n| S        | `^C`                                                         |\n| `|`      | `^i`（`^`命令是移到行首，`i`是进入插入模式，其实也等效于`I`） |\n| A        | `$a`                                                         |\n| o        | `A<CR>`                                                      |\n| O        | `ko`                                                         |\n\n比如：输入`ko`，等于输入了`k$a<CR>`。\n\n它们全都会从普通模式切换到插入模式。这对`.`命令可能产生影响。\n\n# 使修改、移动可重复：`;`和`s`命令\n\n在一个字符前后各添加一个空格。以像下面这样在+号前后各添加一个空格，让肉眼更容易识别。\n\n```\nvar foo = \"method(\" + argument1 + \",\" + argument2 + \")\";\n```\n\n`s`命令把两个操作合并为一个：它先删除光标下的字符，然后进入插入模式。在删除＋号后，先输入`空格 + 空格`，然后退出插入模式。\n\n先后退一步，然后前进三步，这是个奇怪的小花招，看起来可能不够直接。但这样做最大的好处是：我们可以用`.`命令重复这一修改。我们所要做的只是把光标移到下一个+号处，然后用`.`命令重复这一操作即可。\n\n但是移动光标到指定位置还是太麻烦了。\n\n`f{char}`命令让Vim查找下一处指定字符出现的位置，如果找到了，就直接把光标移到那里。因此，输入`f+`时，光标会直接移到下一个+号所在的位置。\n\n完成第一处修改后，可以重复按`f+`命令跳到下一个+号所在的位置。不过，还有一种更好的方法可以用：`;`命令会重复查找上次`f`命令所查找的字符，因此不用输入4次`f+`，而是只输入一次，后面跟着再用3次`;`命令。\n\n`;`命令带我们到下一个目标字符上，`.`命令则重复上次的修改。因此，可以连续输入3次`;.`来完成全部修改。与其和Vim区分模式的编辑模型做斗争，倒不如与它一起协同工作。然后，就能把特定任务变得容易——在面对重复性工作时，我们需要让移动动作和修改都能够重复，这样就可以达到最佳编辑模式。\n\n## 总结\n\n1. `s`键先删除光标下的字符，然后进入插入模式\n2. `f{char}`命令查找下一处指定字符出现的位置，如果找到了，就直接把光标移到那里\n3. `;`命令会重复查找上次`f`命令所查找的字符\n4. `.`命令重复上次的修改\n\n# 几对儿重复和回退\n\n如果我们知道如何重复之前的操作，而无需每次都输入整条命令，那么就会获得更高的效率。可以先执行一次，随后只需重复即可。\n\n然而，这么少的按键就可以完成这么多的事情，需要很小心地操作才行，不然就很容易出错。当一遍又一遍地连续按`j.j.j.`（`j`，向下一行）时，那种感觉就像是在敲鼓。可是，如果不小心在一行上敲了两次`j`键，或敲了两次`.`键，就很麻烦。当Vim让一个操作或移动可以很方便地重复时，它总是会提供某种方式能回退回来。对命令而言，可以按`u`键撤销上次的修改。如果在使用`f{char}`命令后，不小心按了太多次`;`键，就会偏离我们的目标。不过可以再按`,`键跳回去，这个命令会反方向查找上次`f{char}`所查找的字符。\n\nVim中可重复执行的命令，以及相应的回退方式。\n\n| 目的                       | 操作                    | 重复 | 回退 |\n| -------------------------- | ----------------------- | ---- | ---- |\n| 做出一个修改               | `{edit}`                | `.`  | `u`  |\n| 在行内查找下一指定字符     | `f{char}`/`t{char}`     | `;`  | `,`  |\n| 在行内查找上一指定字符     | `F{char}`/`T{char}`     | `;`  | `,`  |\n| 文档中查找下一处匹配字符串 | `/pattern<CR>`          | `n`  | `N`  |\n| 文档中查找上一处匹配字符串 | `?pattern<CR>`          | `n`  | `N`  |\n| 执行替换                   | `:s/target/replacement` | `&`  | `u`  |\n| 执行一系列修改             | `qx{changes}q`          | `@x` | `u`  |\n\n# `.`范式\n\n我们想在一系列行的结尾添加分号。我们先用`A[进入插入模式] ;<Esc>`修改了第一行，做完这步准备后，就可以使用`.`命令对后续行重复此修改。我们使用了`j`命令在行间移动，要完成剩余的修改，只需简单地按足够多次`j.`就可以了。\n\n我们想为每个`+`号的前后各添加一个空格。先用`f+`命令跳到目标字符上，然后用`s`命令把一个字符替换成3个，做完这步准备后，就可以按若干次`;.`完成此任务。\n\n我们想把每处出现单词\"content\"的地方都替换成\"copy\"。使用`*`命令来查找目标单词，然后用`cw`命令修改第一处地方。做完这步准备后，就可以用`n`键跳到下一匹配项，然后用`.`键做相同的修改。要完成这项任务，只需简单地按足够多次`n.`就行了。\n\n理想模式：用一键移动，另一键执行\n\n所有这些例子都利用`.`命令重复上次的修改，不过这不是它们唯一的共同点，另外的共同点是它们都只需要按一次键就能把光标移到下一个目标上。\n\n用一次按键移动，另一次按键执行，再没有比这更好的了，这就是理想的解决方案。这一编辑模式，把它叫做\"`.`范式\"。\n\n## 总结\n\n| 按键      | 作用                                         |\n| --------- | -------------------------------------------- |\n| A         | 移到行尾并进入插入模式                       |\n| j         | 光标向下一行                                 |\n| `f{char}` | 光标移到下一个char字符                       |\n| s         | 把光标下一个字符删除，进入插入模式           |\n| `;`       | 找下一个指定的字符                           |\n| `*`       | 查找当前光标下的单词，并把光标移到下一个单词 |\n| cw        | 删除光标下的单词，进入插入模式               |\n\n`.`命令记录的是从进入插入模式后，到退出插入模式输入的命令\n","categories":["Linux","vim"]},{"title":"Linux_vim_\"*\"命令","url":"/Linux/Linux_vim_星号命令/","content":"\n# `@.`/`&`重复Ex命令\n\n`@:`可以用来重复任意Ex命令，或者也可以输入`&`来重复上次的`:substitute`命令（本身也是一条Ex命令）。\n\nVim提供了一个`:substitute`命令专门用于查找替换任务，不过用上面介绍的技术，也可以手动修改第一处地方，然后再一个个地查找替换其他匹配项。`.`命令可以把我们从繁重的工作中解放出来，而即将登场的另一个有用的单键命令，则能够让我们方使地在匹配项间跳转。\n\n在下面这段文本中，每一行都出现了单词\"content\"。\n\n```\n...We're waiting for content before the site can go live...\n...If you are content with this, let's go ahead with it...\n...We'll launch as soon as we have the content..\n```\n\n假设想用单词\"copy\"（意义同\"copywriting\"）来替代\"content\"。也许只要用替换命令就行了，像下面这样：`:%s/content/copy/g`。但是如果我们运行上面这条命令，就会出现\"If you are 'copy' with this,\"这样的句子，之所以会有这种问题，是因为\"content\"一词有两种含义，一个是\"copy\"的同义词，另一个是\"happy\"的同义词。用专业的话说，我们是在处理拼写相同，但含义和发音都不同的词。所以在替换时，一定要小心每一步操作。不能想当然地用\"copy\"替换每一个\"content\"，而是要时刻留神，对每个地\n方都要问\"这里要修改吗？\"，然后回答\"修改\"或者\"不改\"。`:substitute`命令能胜任这项工作。\n\n# `*`命令--查找当前光标下的单词\n\n可以先用`/content`，把光标移动到指定的单词上。然后按`*`键，就可以找到下一个同词。\n\n![image-20220901180716483](../../images/Linux_vim_星号命令/image-20220901180716483.png)\n\n刚开始，把光标移到单词\"content\"上，然后使用`*`命令对它进行查找。这会产生两个结果：一是光标跳到下一个匹配项的第一个字符上，二是所有出现这个词的地方都被高亮显示出来。如果没有看到高亮，运行一下 `:set hls`。执行过一次查找\"content\"的命令后，现在只需按`n`键就可以跳到下一个匹配项。在本例中，按一次`*`，两次`n`，会遍历完所有的匹配项，从而跳回到本次查找的起点。\n\n## 总结\n\n1. `*`命令的作用是光标跳到下一个匹配项的第一个字符上。本质上是先`/\\<content\\>`搜索匹配项，在点按`n`。\n2. 开启搜索匹配项同时高亮：`:set hls`\n\n# 使修改可重复\n\n当光标位于\"content\"的开头时，就可以着手修改它。这包括两步操作：首先要删除单词\"content\"，然后输入替代的单词。`cw`命令会删除从光标位置到单词结尾间的字符，并进入插入模式，接下来就可以输入单词\"copy\"了。**Vim会把我们离开插入模式之前的全部按键操作都记录下来**，因此整个`cw copy<Esc>`会被当成一个修改。也就是说，执行`.`命令会删除从光标到当前单词结尾间的字符，并把它修改为\"copy\"。\n\n# 合而为一\n\n每次按`n`键时，光标就会跳到下一个\"content\"单词所在之处，而按键时，它就会把光标下的单词改为\"copy\"。\n\n如果想替换所有地方，就可以不加思考地一直按`n.n.n.`以完成所有的修改（但是，这种情况下也可以用`:%s/content/copy/g`命令）。然而，由于我们需要留意不符合要求的匹配项，所以在按了`n`之后，要审视一下当前的匹配项，然后决定是否把它改为\"copy\"。如果需要修改的话，就按`.`命令，反之则不用。无论决定是什么，都可以再次按`n`移到下一个地方，如此循环往复，直到完成全部的修改。\n","categories":["Linux","vim"]},{"title":"Android_进程","url":"/Android/Android_进程/","content":"\n# Activity启动后生成几个Thread\n\nActivity启动后，除了main thread，还有两个Binder Thread。\n\n# 主线程是怎么产生的\n\n1. 由ZygoteInit启动，经由一系列系统调用后最终才执行Activity本身的onCreate函数，Zygote为Activity创建的主线程是ActivityThread。\n\n# Service的主线程是什么\n\n1. Service也是寄存于ActivityThread之中的，并且启动流程和Activity基本一致；即Activity和Service应用程序的主线程都是ActivityThread。\n2. 启动Service时，也同样需要两个Binder线程的支持。\n\n# 同一个程序包中有两个Acivity\n\n两个Activity之间是什么关系？需要有多少线程的支持？\n\nAndroidManifest.xml：\n\n```xml\n/* AndroidManifest.xml */\n<activity android:name=\"./ActivityThreadTest\"\n          android:label=\"@string/title_activity_activity_thread_test\" >\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n    </intent-filter>\n</activity>\n\n<activity android:name=\".ActivityThreadTest2\"\n          android:label=\"@string/title_activity_activity_thread_test\" >\n</activity>\n```\n\nActivityThreadTest.java\n\n```java\n/* ActivityThreadTest.java */\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    Log.i(\"ActivityThreadTest1\", \"We are in ThreadTest1\");\n    setContentView(R.layout.activity_activity_thread_test);\n    Intent intentThread2 = new Intent(this, ActivityThreadTest2.class);\n    startActivity(intentThread2);\n}\n```\n\n当断点停在ActivityThreadTest2的onCreate函数中时，线程的分布情况如下：\n\n![image-20220906104610197](../../images/Android_进程/image-20220906104610197.png)\n\n其中揭示了以下几个现象。\n> 当ActivityThreadTest2被执行时，主线程始终只有一个。\n> 此时ActivityThreadTest暂时退出了运行。\n> Binder线程数量有所变化。\n\n## 同一个AndroidManifest.xml中定义的组件都运行于同一个进程中\n\n对于同一个AndroidManifest.xml中定义的四大组件，除非有特别声明，否则它们都运行于同一个进程中（并且均由主线程来处理事件）。\n\n根据操作系统的基础知识，如果两个对象处于同一个进程空间中，那么内存区域应该是可共享访问的。可以利用这个原理来论证先后启动的同一个包里的两个Activity是否共存于同一个进程中。先让ActivityThreadTest拥有一个static的变量，如下所示。\n\n```java\n/* ActivityThreadTest.java */\npublic class ActivityThreadTest extends Activity {\n    static int TestForCoexist = -1;\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Log.i(\"ActivityThreadTest1\", \"We are in ThreadTest1\");\n        setContentView(R.layout.activity_activity_thread_test);\n        Intent intentThread2 = new Intent(this, ActivityThreadTest2.class);\n        TestForCoexist = 2;\n        startActivity(intentThread2);\n    }\n}\n```\n\nActivityThreadTest中有一个静态的变量TestForCoexist。其初始值为-1，并在Activity启动后（onCreate 中）被修改为2。\n\n接着看ActivityThreadTest2的源码实现：\n\n```java\n/* ActivityThreadTest2.java */\npublic class ActivityThreadTest2 extends Activity {\n    @override\n    public void onCreate(Bundle savedInstanceState)\n    super.onCreate(savedInstanceState);\n    Log.i(\"ActivityThreadTest2\",\"We are in ThreadTest2\");\n    setContentView(R.layout.activity_activity_thread_test);\n    Log.i(\"ActivityThreadTest2\",\"TestForCoexist=\"\n          + ActivityThreadTest.TestForCoexist);//实验结果将在这里呈现\n}\n```\n\n![image-20220906110131202](../../images/Android_进程/image-20220906110131202.png)\n\n运行这个应用程序，来看看最终的输出，TestForCoexist为2。\n\n这就足够证明两个 Activity 是在同一个进程空间中了。\n\n仔细观察，还会发现二者所处的应用程序PID和TID值是相同的。这都证明了一个结论，那就是同一个程序包里的两个Activity默认确实都运行于同一个进程中。\n\n# 让不同包的组件运行于相同的进程中\n\nAndroid提供了特殊的方式让不是同一个包里的组件也可以运行于相同的进程中。优势就是，它们可以非常方便地进行资源共享，而不用经过费时费力的进程间通信。分为两种情况：\n\n## 针对个别组件\n\n可以在`AndroidManifest.xml`文件中的`<activity>`、`<service>`、`<receiver>`和`<provider>`（四大组件都支持，可以根据需要来添加）标签中加入`android:process`属性来表明这一组件想要运行在哪个进程空间中。\n\n## 针对整个程序包\n\n可以直接在`<application>`标签中加入`android:process`属性来指明想要依存的进程环境。\n\n# 结论\n\n1. 四大组件并不是程序（进程）的全部，而只是它的\"零件\"。\n2. 应用程序启动后，将创建ActivityThread主线程。\n3. 同一个包中的组件将运行在相同的进程空间中。\n4. 不同包中的组件可以通过一定的方式运行在一个进程空间中。\n5. 一个Activity应用启动后至少会有3个线程：即一个主线程和两个Binder线程。","categories":["Android","操作系统"]},{"title":"git_config","url":"/git/git_config/","content":"\n# 解决git clone慢的问题\n\nhttps://zhuanlan.zhihu.com/p/148110705\n\n```\ngit config --global http.proxy 127.0.0.1:11112\ngit config --global https.proxy 127.0.0.1:11112\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n# 局域网配置代理脚本\n\n```sh\nMY_PROXY_IP_=\"172.20.83.70\" #有墙的主机ip\nMY_PROXY_PORT_=\"11113\"      #墙的端口号\nMY_PROXY_SECRET_=\"\"\nMY_PROXY_LOCATION_TEST_URL_=\"https://myip.ipip.net/\"\nfunction f_proxy_setup() {\n    if [ \"$#\" -eq \"2\" ];\n    then\n        MY_PROXY_IP_=\"$1\"\n        MY_PROXY_PORT_=\"$2\"\n    fi  \n    MY_PROXY_LOCATION_=socks5://${MY_PROXY_IP_}:${MY_PROXY_PORT_}\n    export all_proxy=\"$MY_PROXY_LOCATION_\"\n    echo $all_proxy\n}\n\nfunction f_proxy_down() {\n    echo \"($all_proxy)\" down.\n    export all_proxy=\"\"\n}\n\nfunction f_proxy_location() {\n    echo ALL_PROXY: $all_proxy\n    curl $MY_PROXY_LOCATION_TEST_URL_\n}\n```\n\n","categories":["Linux","git"]},{"title":"Linux_墙的配置","url":"/Linux/Linux_墙的配置/","content":"\n# 墙的配置\n\n```sh\n# filename: setProxy.sh\nMY_PROXY_IP_=\"192.168.2.249\"\nMY_PROXY_PORT_=\"10810\"\nMY_PROXY_SECRET_=\"\"\nMY_PROXY_LOCATION_TEST_URL_=\"myip.ipip.net/\"\nfunction f_proxy_setup() {\n    if [ \"$#\" -eq \"2\" ];\n    then\n        MY_PROXY_IP_=\"$1\"\n        MY_PROXY_PORT_=\"$2\"\n    fi  \n    MY_PROXY_LOCATION_=socks5://${MY_PROXY_IP_}:${MY_PROXY_PORT_}\n    export all_proxy=\"$MY_PROXY_LOCATION_\"\n    echo $all_proxy\n}\n\nfunction f_proxy_down() {\n    echo \"($all_proxy)\" down.\n    export all_proxy=\"\"\n}\n\nfunction f_proxy_location() {\n    echo ALL_PROXY: $all_proxy\n    curl $MY_PROXY_LOCATION_TEST_URL_\n}\n```\n\n使用：\n\n```\n$ . setProxy.h \"xxx.xxx.xxx.xxx\" \"xxxx\"\n$ f_proxy_setup\n$ f_proxy_location\n$ f_proxy_down\n$ f_proxy_location\n```\n\n","categories":["Linux"]},{"title":"git_commit","url":"/git/git_commit/","content":"\n# 用vim编辑commit\n\n1. 在git config中设置`core.editor`:\n   `git config --global core.editor \"vim\"`\n2. 在环境变量中设置`GIT_EDITOR`:\n   `export GIT_EDITOR=vim`\n\n# commit规约目标\n\n1. 规范、统一的Commit\n   1. 更加结构化的提交历史\n   2. 保证每次信息都有确切的含义\n2. 自动、清晰的ChangeLog\n3. 简单、方便的issue tracker\n   1. 方便信息搜索和过滤\n\n# Commit规范\n\n代码示意\n\n```\n[what][key][jira issue ID] describe[part1/n]\n[why] describe\n[how]\n1.describe\n2.\nn.\n```\n\n段落含义解释\n\n| 段落 | 含义                                                       | 备注                       |\n| :--- | :--------------------------------------------------------- | :------------------------- |\n| what | 描述提交（问题、改动、修改等调整）                         | 一句话结束。不超过80个字节 |\n| why  | 阐述提交（问题触发原理、改动缘由、修改理由等一切合理解释） |                            |\n| how  | 解释提交（问题解决办法、改动项、修改项等）                 | 分点分段                   |\n\n字段含义解释\n\n| 字段          | 含义                                     | 备注                                            |\n| :------------ | :--------------------------------------- | :---------------------------------------------- |\n| key           | 关键字，用于直接区分commit本质，极其重要 | 目的：过滤，筛选用途：可用于自动化生产ChangeLog |\n| Jira issue ID | jira问题ID，ARMR-666                     |                                                 |\n| describe      | 描述                                     |                                                 |\n| part 1/n      | 跨仓库提交                               | 一般用于repo等大型仓库使用                      |\n\nkey字段解释\n\n| key      | 解释     | 备注                                   |\n| :------- | :------- | :------------------------------------- |\n| feature  | 新特性   |                                        |\n| merge    | 合并     |                                        |\n| bugfix   | 修复问题 |                                        |\n| config   | 配置机型 | 在TV里面，config是提交最多的一个种类型 |\n| refactor | 重构     |                                        |\n\n## 针对 bug 修改\n\n```\n[bugfix][类型][jira 编号] bug 简述\n（添加一行空行）\n[what]bug 详细描述\n[why]原因\n[how]解决方法\n```\n\n## 针对功能添加的修改\n\n```\n[feature][类型][可选项] 功能简述\n（添加一行空行）\n[what]功能的详细描述\n实现方法\n```\n\n[可选项]——可考虑填写版本号（如果有的话）或者 jira 编号\n\n## 公共约定\n\n1. 第一行简述尽量用英文，可以使用中文\n2. bug 有 jira 编号，必须附上\n3. 第一行简述下必须空一行\n4. 审核人发现log不按照本文规范书写，需要打回\n","categories":["git"]},{"title":"微机原理_DOS环境搭建_Debug","url":"/微机原理/微机原理_DOS环境搭建_Debug/","content":"# Debug是什么\n\nDebug是DOS、Windows都提供的实模式（8086方式）程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。\n\n# 挂载磁盘\n\n下载masm文件夹，是四个可执行文件，放在宿主系统磁盘下的某个位置。\n\n需要在DosBox中进行挂载。\n\n即在dos中输入以下命令：参数1为要挂载到dos系统的某个位置，参数2为要挂载的宿主系统中的内容\n\n```\nmount C D:\\masm\n```\n\n输入后，成功时会显示：`Drive C is mounted as local directory D:\\masm\\`\n\n可以在dos中进入C盘进行执行文件了。\n\n# 调节窗口大小\n\n1. https://blog.51cto.com/sxhelijian/4895116\n2. https://blog.csdn.net/wxw1920/article/details/120716642\n\n# 基本命令\n\n1. 用Debug的R命令查看、改变CPU寄存器的内容；\n2. 用Debug的D命令查看内存中的内容；\n3. 用Debug的E命令改写内存中的内容；\n4. 用Debug的U命令将内存中的机器指令翻译成汇编指令；\n5. 用Debug的T命令执行一条机器指令；\n6. 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令。\n\n## R命令查看、改变CPU寄存器内容\n\n输入`r`，回车。可打印若干寄存器内容。在所有寄存器的下方，Debug还列出了CS:IP所指向的内存单元处所存放的机器码，并将它翻译为汇编指令。输出的右下角还有一个信息\"`DS:0000=CD`\"。\n\n![image-20220901141954968](../../images/微机原理_DOS环境搭建_Debug/image-20220901141954968.png)\n\n若要修改一个寄存器中的值，比如AX中的值，可用R命令后加寄存器名来进行，输入\"`r ax`\"后按Enter键，将出现\"`:`\"作为输入提示，在后面输入要写入的数据后按Enter键，即完成了对AX中内容的修改。若想看一下修改的结果，可再用R命令查看。\n\n## D命令查看内存中的内容\n\n`d 段地址:偏移地址`，可以来查看指定内存地址初的默认128个字节的内容。在使用\"`d 段地址:偏移地址`\"之后，接着再次使用D命令，可再次列出后续128字节的内容。\n\n可以指定D命令的查看范围，此时采用\"`d 段地址:起始偏移地址 结尾偏移地址`\"的格式。比如要看`1000:0~1000:9`中的内容，可以用\"`d1000:0 9`\"实现，如图所示。若结尾偏移地址小于起始偏移地址将会报错。\n\n![image-20220901145106731](../../images/微机原理_DOS环境搭建_Debug/image-20220901145106731.png)\n\n如果想看特定内存单元`10000H`中的内容，可以用图中任何一种方法看到。图中三种方式`段地址:偏移地址`都表示了`10000H`这一物理地址。（别忘了，8086下的段地址需要乘以16，相当于$1000H*10H=10000H$；$0FFFH*10H+10H=FFF0H+10H=10000H$）\n\n![image-20220901144739638](../../images/微机原理_DOS环境搭建_Debug/image-20220901144739638.png)\n\n## E命令修改内存中的内容\n\n比如要将内存`1000:0~1000:9`单元中的内容分别写为`0~9`。可以使用`e 起始地址 数据 数据 数据 ...`的格式来进行。\n\n![image-20220901143311569](../../images/微机原理_DOS环境搭建_Debug/image-20220901143311569.png)\n\n也可以用E命令以提问的方式来逐个地修改从某一地址开始的内存单元中的内容，以从`1000:10`单元开始为例，步骤如下。\n\n1. 输入`e 1000:10`，按 Enter键。\n2. Debug显示起始地址`1000:0010`，和第一单元（即`1000:0010`单元）的原始内容6D，然后光标停在\"`.`\"的后面提示输入想要写入的数据，此时可以有两个选择：\n   1. 输入数据，然后按`空格键`，即用输入的数据改写当前的内存单元\n   2. 不输入数据，直接按`空格键`，则不对当前内存单元进行改写。\n3. 当前单元处理完成后（不论是改写或没有改写，只要按了空格键，就表示处理完成），Debug将接着显示下一个内存单元的原始内容，并提示进行修改，可以用同样的方法处理。\n4. 所有希望改写的内存单元改写完毕后，按`Enter`键，E命令操作结束。\n\n![image-20220901144136193](../../images/微机原理_DOS环境搭建_Debug/image-20220901144136193.png)\n\n还可以用E命令向内存中写入字符，比如，用E命令从内存`1000:0`开始写入数值1、字符\"a\"、数值2、字符\"b\"、数值3、字符\"c\"，可采用图中所示的方法进行。\n\n![image-20220901143932131](../../images/微机原理_DOS环境搭建_Debug/image-20220901143932131.png)\n\n也可以用E命令向内存中写入字符串，比如，用E命令从内存`1000:0`开始写入数值1、字符串\"a+b\"、数值2、字符串\"c++\"、字符 3、字符串\"IBM\"。\n\n![image-20220901144327149](../../images/微机原理_DOS环境搭建_Debug/image-20220901144327149.png)\n\n## E命令写入机器码，用U命令查看机器码含义，T命令执行\n\n可以用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码。\n\n机器码也是数据，当然可以用E命令将机器码写入内存。比如我们要从内存`1000:0`单元开始写入这样一段机器码：\n\n| 机器码 | 对应的汇编指令 |\n| ------ | -------------- |\n| b80100 | mov ax, 0001   |\n| b90200 | mov cx, 0002   |\n| 01c8   | add ax, cx     |\n\n可以用E命令这样输入：\n\n```\ne 1000:0 b8 01 00 b9 02 00 01 c8\n```\n\n可以使用U命令查看写入的或内存中原有的机器码所对应的汇编指令。比如可以用U命令将从`1000:0`开始的内存单元中的内容翻译为汇编指令，并显示出来。\n\n下图：首先用E命令向从`1000:0`开始的内存单元中写入了8个字节的机器码；然后用D命令查看内存`1000:0~1000:1f`中的数据（从数据的角度看一下写入的内容）；最后用U命令查看从`1000:0`开始的内存单元中的机器指令和它们所对应的汇编指令。\n\n![image-20220901145701343](../../images/微机原理_DOS环境搭建_Debug/image-20220901145701343.png)\n\nU命令的显示输出分为3部分，每一条机器指令的地址、机器指令、机器指令所对应的汇编指令。\n\n内存中的数据和代码没有任何区别，关键在于如何解释。\n\n使用T命令执行写入的机器指令可以执行一条或多条指令。\n\n简单地使用T命令，可以执行`CS:IP`指向的指令。\n\n![image-20220901150147031](../../images/微机原理_DOS环境搭建_Debug/image-20220901150147031.png)\n\n先修改cs、ip，使下一条命令对准`1000:0`，即`mov ax, 1`。`t`命令执行后，发现，ax变为了1；ip改变为3（指向下一条）。\n\n## A命令以汇编指令的形式在内存中写入机器指令\n\nA命令使能直接以汇编指令的形式写入指令。\n\n首先用A命令，以汇编语言向从`1000:0`开始的内存单元中写入了几条指令，然后用D命令查看A命令的执行结果。可以看到，在使用A命令写入指令时，我们输入的是汇编指令，Debug将这些汇编指令翻译为对应的机器指令，将它们的机器码写入内存。\n\n不再继续写入时，直接按Enter键表示操作结束。\n\n![image-20220901150535967](../../images/微机原理_DOS环境搭建_Debug/image-20220901150535967.png)\n\n![image-20220901150726949](../../images/微机原理_DOS环境搭建_Debug/image-20220901150726949.png)\n","categories":["微机原理"]},{"title":"微机原理_寄存器_物理地址_段","url":"/微机原理/微机原理_寄存器_物理地址_段/","content":"# CPU\n\n一个典型的CPU（此处讨论的不是某一具体的CPU）由运算器、控制器、寄存器等构成，这些器件靠**内部总线**相连。内部总线实现CPU内部各个器件之间的联系；外部总线实现CPU和主板上其他器件的联系。简单地说，在CPU中：\n\n* **运算器**进行信息处理；\n* **寄存器**进行信息存储；\n* **控制器**控制各种器件进行工作；\n* **内部总线**连接各种器件，在它们之间进行数据的传送。\n\n对于一个汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制。不同的CPU，寄存器的个数、结构是不相同的。8086有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。\n\n# 通用寄存器--AX/BX/CX/DX\n\n8086的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。\n\n8086的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，8086的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用：\n\n1. AX可分为AH和AL\n2. BX可分为BH和BL\n3. CX可分为CH和CL\n4. DX可分为DH和DL\n\n![image-20220831145025668](../../images/微机原理_寄存器_物理地址_段/image-20220831145025668.png)\n\n# 字在寄存器中的存储\n\n出于对兼容性的考虑，8086可以一次性处理以下两种尺寸的数据。\n\n1. 字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。\n2. 字：记为word，一个字由两个字节组成，这两个字节分别称为这个**字的高位字**\n   **节和低位字节**。\n\n![image-20220831145223342](../../images/微机原理_寄存器_物理地址_段/image-20220831145223342.png)\n\n一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。如上图所示，一个字型数据20000，存在AX寄存器中，在AH中存储了它的高8位，在AL中存储了它的低8位。AH和AL中的数据，既可以看成是一个字型数据的高8位和低8位，这个字型数据的大小是20000；又可以看成是两个独立的字节型数据，它们的大小分别是78和32。\n\n# 几条汇编指令\n\n| 汇编指令   | 控制CPU完成的操作                  | 用高级语言的语法描述 |\n| ---------- | ---------------------------------- | -------------------- |\n| mov ax, 18 | 将18送入寄存器AX                   | AX=18                |\n| mov ah, 78 | 将78送入寄存器AH                   | AH=78                |\n| add ax, 8  | 将寄存器AX中的数值加上8            | AH=AX+8              |\n| mov ax, bx | 将寄存器BX中的数据送入寄存器AX     | AX=BX                |\n| add ax, bx | 将AX和BX中的数值相加，结果存在AX中 | AX=AX+BX             |\n\n在写一条汇编指令或一个寄存器的名称时不区分大小写。如mov ax, 18和MOV AX, 18的含义相同。\n\n## 越位的问题\n\n| 汇编指令    | AX中的数据 | BX中的数据 |\n| ----------- | ---------- | ---------- |\n| {start}     | 00C5H      | 4026H      |\n| add al, 93H | ?          | 4026H      |\n\n指令执行后AX中的数据为多少？\n\n分析：\n\n程序段中的最后一条指令`add al, 93H`，在执行前，`al`中的数据为`C5H`，相加后所得的值为`158H`，但是`al`为8位寄存器，只能存放两位十六进制的数据，所以最高位的`1`丢失，`ax`中的数据为`0058H`。（这里的丢失，指的是进位值不能在8位寄存器中保存，但是CPU并不是真的丢弃这个进位值）\n\n> 注意，此时al是作为一个独立的8位寄存器来使用的，和ah没有关系，CPU在执行这条指令时认为ah和al是两个不相关的寄存器。不要错误地认为add al, 93H的指令产生的进位会存储在ah中，add al, 93H进行的是8位运算。\n>\n> 如果执行add ax, 93H，低8位的进位会存储在ah中，CPU在执行这条指令时认为只有一个16位寄存器ax，进行的是16 位运算。指令`add ax, 93H`执行后，ax中的值为：0158H。此时，使用的寄存器是16位寄存器ax，`add ax, 93H`相当于将ax中的16位数据00C5H和另一个16位数据0093H相加，结果是16位的0158H。\n\n## 操作对象的位数应当是一致的\n\n在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的，例如：\n\n```x86asm\nmov ax, bx\nmov bx, cx\nmov ax, 18H\nmov al, 18H\nadd ax, bx\nadd ax, 20000\n```\n\n等都是正确的指令，而：\n\n```x86asm\nmov ax, bl    ; 在8位寄存器和16位寄存器之间传送数据\nmov bh, ax    ; 在16位寄存器和8位寄存器之间传送数据\nmov al, 20000 ; 8位寄存器最大可存放值为255的数据\nadd al, 100H  ; 将一个高于8位的数据加到一个8位寄存器中\n```\n\n\n等都是错误的指令，错误的原因都是指令的两个操作对象的位数不一致。\n\n# 物理地址\n\nCPU访问内存单元时，要给出内存单元的地址。即，CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。\n\n所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。\n\n在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。\n\n下面分析8086是如何在内部形成内存单元的物理地址的。\n\n# 16位CPU\n\n什么是16位结构（16位机、字长为16位等常见说法，与16位结构的含义相同）的CPU？概括地讲，16位结构描述了一个CPU具有下面几方面的结构特性。\n\n* 运算器一次最多可以处理16位的数据；\n* 寄存器的最大宽度为16位；\n* 寄存器和运算器之间的通路为16位。\n\n8086是16位结构的CPU，这也就是说，在8086内部，能够一次性处理、传输、暂时存储的信息的最大长度是16位的。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理、传输、暂时存储16位的“单位”地址。\n\n# 8086CPU给出物理地址的方法\n\n8086是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。但是8086有20位地址总线，可以传送20位地址，达到1MB寻址能力。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64K“单位”个地址。\n\n8086CPU采用一种在内部**用两个16位地址合成**的方法来形成一个20位的物理地址。\n\n当8086CPU要读写内存时：\n\n1. CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；\n2. 段地址和偏移地址通过**内部总线**送入一个称为**地址加法器**的部件；\n3. 地址加法器将两个16位地址合成为一个20位的物理地址；\n4. 地址加法器通过内部总线将20位物理地址送入输入/输出控制电路（可以看到，地址加法器到输入/输出控制电路之间的内部总线需要有20位）；\n5. 输入/输出控制电路将20位物理地址送上其与内存之间的地址总线；\n6. 20位物理地址被地址总线传送到存储器。\n\n地址加法器采用$物理地址=段地址×16(左移4位)+偏移地址$的方法用段地址和偏移地址合成物理地址。\n\n# 段\n\n其实，内存并没有分段，段的划分来自于CPU，由于8086CPU用“基础地址+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们在逻辑上可以用分段的方式来管理内存。可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。\n\n在8086机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。\"数据在21F60H内存单元中。\"这句话对于8086机一般不这样讲，取而代之的是两种类似的说法：1、数据存在内存2000:1F60单元中；2、数据存在内存的2000H段中的1F60H单元中。这两种描述都表示\"数据在内存21F60H单元中\"。\n\n# 段寄存器--CS为例\n\n我们前面讲到，8086在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。这里，需要看一下，是什么部件提供段地址。段地址在8086的段寄存器中存放。8086有4个段寄存器CS、DS、SS、ES。当8086要访问内存时由这4个段寄存器提供内存单元的段地址。看一下CS（CS，全拼为Code Segment）。\n\nCS和IP是8086中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器，从名称上可以看出它们和指令的关系。\n\n在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086将从内存M×16+N单元开始，读取一条指令并执行。\n\n也可以这样表述：8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。\n\n在内存中，指令和数据没有任何区别，都是二进制信息，CPU在工作的时候把有的信息看作指令，有的信息看作数据。现在，如果提出一个问题：**CPU根据什么将内存中的信息看作指令？可以说，CPU将CS:IP指向的内存单元中的内容看作指令**，因为，在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过。\n\n## 修改CS、IP的指令--转移指令\n\nCPU从何处执行指令是由CS、IP中的内容决定的，在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现控制CPU的执行目标指令。\n\n如何改变CS、IP的值呢？显然，8086必须提供相应的指令。我们如何修改AX中的值？可以用mov指令，如`mov ax, 123`将ax中的值设为123。显然，我们也可以用同样的方法设置其他寄存器的值，如`mov bx, 123`，`mov cx, 123`，`mov dx, 123`等。\n\n其实，**8086大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令**。\n\n但是，mov指令不能用于设置CS、IP的值，原因很简单，因为8086没有赋予mov这样的权限。8086为CS、IP提供了另外的指令来改变它们的值。能够改变CS、IP的内容的指令被统称为**转移指令**。看一个最简单的可以修改CS、IP的指令：`jmp`指令。\n\n### jmp 段地址:偏移地址\n\n若想同时修改CS、IP的内容，可用形如\"`jmp 段地址:偏移地址`\"的指令完成，如`jmp 2AE3:3`，执行后：`CS=2AE3H`，`IP=0003H`，CPU将从`2AE33H`处读取指令。`jmp 3:0B16`，执行后：`CS=0003H`，`IP=0B16H`，CPU将从`00B46H`处读取指令。\n\n\"`jmp 段地址:偏移地址`\"指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP。\n\n### jmp 某一合法寄存器\n\n若想仅修改IP的内容，可用形如\"`jmp 某一合法寄存器`\"的指令完成，如`jmp ax`，指令执行前：`ax=1000H`，`CS=2000H`，`IP=0003H`；指令执行后：`ax=1000H`，`CS=2000H`，`IP=1000H`。`jmp bx`，指令执行前：`bx=0B16H`，`CS=2000H`，`IP=0003H`。指令执行后：`bx=0B16H`，`CS=2000H`，`IP=0B16H`。\n\n\"jmp 某一合法寄存器\"指令的功能为：用寄存器中的值修改IP。\n\n`jmp ax`，在含义上好似：`mov IP, ax`。\n\n### 用汇编解释汇编\n\n\"用汇编解释汇编\"能更好地理解汇编指令的功能，要强调的是，是用\"已知的汇编指令的语法\"进行描述，并不是用\"已知的汇编指令\"来描述，比如，我们用`mov IP, ax`来描述`jmp ax`，并不是说真有`mov IP, ax`这样的指令，而是用mov指令的语法来说明`jmp`指令的功能。我们可以用同样的方法描述`jmp 3:01B6`的功能：`jmp 3:01B6`在含义上好似`mov CS, 3`, `mov IP, 01B6`。\n\n## 总结\n\n1. 段地址在8086的段寄存器中存放。当8086要访问内存时，由段寄存器提供内存单元的段地址。8086有4个段寄存器，其中CS用来存放指令的段地址。\n2. CS存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。\n3. 8086的工作过程\n   1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；\n   2. IP指向下一条指令；\n   3. 执行指令。（转到步骤1，重复这个过程。）\n4. 8086提供转移指令修改CS、IP的内容\n\n# 访问内存的角度\n\n","categories":["微机原理"]},{"title":"Linux_vim积累_vim实用技巧笔记","url":"/Linux/Linux_vim积累/","content":"\n# 命令行模式（普通模式）\n\n也称为交互模式，这是 `vim` 的默认模式，每次使用 `vim` 命令编辑文件的时候，就会先进入这个模式。\n- 在这个模式下，你不能输入文本；\n- 它可以让我们在文本间移动，删除一行文本，复制粘贴文本，跳转到指定行，撤销操作，等等。\n## 常用命令\n\n| 命令  | 作用                                                                   |\n| --- | -------------------------------------------------------------------- |\n| i   | 切换到输入模式，以输入字符                                                        |\n| x   | 删除当前光标所在处的字符                                                         |\n| X   | 删除当前光标前一个字符                                                          |\n| :   | 切换到底线命令模式，以在最底一行输入命令                                                 |\n| gg  | 跳转到文件开头                                                              |\n| G   | 跳转到文件末尾                                                              |\n| dd  | 剪切：删除光标所在一整行数据，且临时存储到缓存区                                             |\n| yy  | 复制：把整行文本到临时缓存区。                                                      |\n| p小写 | 粘贴：将指定缓存区内容放在光标位置之下：<br>如果是整行文本则放在当前的下一行，若是非整行文本则放在光标后面              |\n| P大写 | 粘贴：将指定缓冲区的内容放到当前光标的位置之上：<br>如果是整行文本则放在这一行并在最后换行，若是非整行文本则放在光标前面       |\n| u   | 撤销最近的修改，针对所有修改                                                       |\n| U   | 撤销对当前行上做的所有修改                                                        |\n| r   | 替换光标位置上的一个字符，但不会进入 `insert` 模式，先按 `r` 再按要替换成的字符，也可以 `2r` 把光标后面两个都替换掉 |\n| R   | 替换从光标位置开始的字符，同时改变 `vim` 到文本输入模式                                      |\n| .   | 重复上一次的修改 -- 注意该命令是英文符号点                                              |\n| >>  | 向右移动本行一段距离                                                           |\n| <<  | 向左移动本行一段距离                                                           |\n\n链接：https://juejin.cn/post/7070699702732783623  \n## 其他\ncopy word、delete word：\n\n与w有关的都会加上单词之后的空格。\n\n`cw`删除从光标位置到当前词结尾处的文本（一个单词+空格），并切换到插入模式\n`dw`删除光标下的单词+空格\n`yw`复制一个单词，`y2w`复制2个单词\n`y$`复制从当前光标到行结尾的所有单词\n`y0`复制从当前光标到行首的所有单词\n`yy`复制一整行\n`2yy`复制从当前光标所在行开始的 2 行\n# 笔记\n\n样式：**普通模式**所用的样式也用于**可视模式**；而**插入模式**的样式也用来表示**命令行模式**及**替换模式**下输入的按键。可以通过上下文清楚地知道当前处于哪个模式。\n\n![image-20220829205901688](../../images/Linux_vim积累/image-20220829205901688.png)\n\n## 命令行中操作\n\n![image-20220829210003288](../../images/Linux_vim积累/image-20220829210003288.png)\n\n# 如何激活查找的字符串所有都高亮\n\n# 可视模式\n\n可视模式允许在缓冲区内选择文本，然后在其上操作。在下例中，用`it`文本对象选中`<a>`标签内的文本。\n\n这会出现一种：高亮显示可视选区。样式与查找匹配项的样式相同。\n\n# 使用Vim原生配置\n\n```bash\nvim -u NONE -N\n```\n\n`-u NONE`标志让Vim在启动时不加载vimrc，这样，定制项就不会生效，插件也会被禁用。当不加载vimrc文件时，Vim会切换到vi兼容模式，这将导致很多有用的功能被禁用，`-N`标志则会使能`'nocompatible'`选项，防止进入vi兼容模式。\n\n有些Vim的内置功能是由Vim脚本实现的，也就是说，只有在激活插件时，它们才会工作。下面是包含了激活Vim内置插件的最小配置文件。\n\n```\nset nocompatible\nfiletype plugin on\n```\n\n在启动Vim时，可以执行如下命令，用该文件取代默认的vimrc。\n\n```\nvim -u code/essential.vim\n```\n\n> 激活Vim内置的插件功能后，可以使用诸如netrw、omni-completion，以及很多其他的功能。Vim的出厂配置，指的就是激活了内置的插件功能，并且禁用了vi兼容模式时的配置。\n\n# Vim版本\n\n有些Vim功能可以在编译期间被禁用。例如，在配置编译选项时，可以传入`--with-features=tiny`参数，这会禁用除最基本的功能外的其他所有功能（Vim的功能集还包括small、normal、big和huge）。\n\n可以查阅`:h+feature-list`，浏览完整的功能列表。如果发现Vim缺少某个功能，那么也许正在使用一个最小功能集的Vim发行版。可以用`:version`命令检查此功能是否可用。\n\n# 设置行号\n\n临时设置\n\n`:set number`（或`:set nu`）显示行号\n`:set nonumber`（或`:set nonu`）取消行号\n\n永久显示行号\n\n1. 查找Vim设定文件`sudo find / -name vimrc`\n2. 修改Vim设定文件`/etc/vimrc`，末尾添加`set number`（或`set nu`），保存即可。\n","categories":["Linux","vim"]},{"title":"git_换行符问题","url":"/git/git_换行符问题/","content":"\n# 问题\n\ngit diff时发现明明只改动了几行代码，但是对比时却显示全部文档都修改过了，而且到处都是`^M`字符，导致看不出修改点，达不到git diff的效果。\n\n# 解决方案\n\n- 分析原因\n  `^M`根据ASCII码表, 查出是`\\r`，即windows换行符`\\r\\n`的前一半。猜测可能是文件编写/查看操作系统不同导致，用`od -tc 文件`查看文件，确实是`\\r`换行符导致的。\n\n- 解决方案\n\n搜了一下，千遍一律的解决方案是加一个配置，忽略换行符的差异：\n\n```shell\ngit config --global core.whitespace cr-at-eol  \n```\n\n但是设置后并没有效果，可能和git版本有关。\n\n既然是`\\r`的问题，那把`\\r`去掉试试，用UE编辑器根据正则`$\\n`替换成`\\n`后，换行符变成了`\\n`。\n\n把内容贴到idea后，发现换行符还是`\\r`，这个时候发现可能是idea设置换行符的问题。遂百度了下idea换行符设置。\n\n# IDE换行符设置\n\n## idea全局换行符\n\n`file` -> `setting` -> `code style` -> `Line separator`\n\n默认是System-Dependent，就是根据当前操作系统进行设置。把它改成`\\n`。\n\n## 单个文件修改换行符\n\n修改为`\\n`，即LF。\n\n最后发现，内容里的`^M`没有了。`git diff`结果也正常了。\n","categories":["Linux","git"]},{"title":"Linux_地址映射","url":"/Linux/Linux_地址映射/","content":"\n# 内容\n\n* 实模式\n* 保护模式\n* 实模式下的地址映射\n* 保护模式下的地址映射\n* 内存的分段式映射\n* 内存的分页式映射\n\n# 引入\n\n在程序中打印变量的地址。此地址是什么地址？\n\n","categories":["操作系统","Linux"]},{"title":"FFmpeg_常用命令","url":"/一些工具的使用/FFmpeg_常用命令/","content":"# 内容\n\n* 常用参数选项\n* 抽取视频的音频，保存为单独的文件\n\n# 常用参数选项\n\n| 选项                       | 描述                 |\n| -------------------------- | -------------------- |\n| `-i`                       | 输入的文件           |\n| `-vn`                      | disable video        |\n| `-b:v`                     | 视频码率             |\n| `-b:a`                     | 音频码率             |\n| `-acodec`/`-vcodec` `copy` | 代表复用原音视频格式 |\n\n# 抽取音频\n\nhttps://superuser.com/questions/332347/how-can-i-convert-mp4-video-to-mp3-audio-with-ffmpeg\n\nThe basic command is:\n\n```\nffmpeg -i filename.mp4 filename.mp3\n```\n\nor\n\n```\nffmpeg -i video.mp4 -b:a 192K -vn music.mp3\n```\n\nCheck this URL: [MP4 Video to MP3 File Using ffmpeg (Ubuntu 9.10 Karmic Koala)](http://donnieknows.com/blog/mp4-video-mp3-file-using-ffmpeg-ubuntu-910-karmic-koala) link broken [Updated on 7th Dec 2021]\n\n**Note:** Ubuntu does not supply FFmpeg, but the fork named [Libav](http://libav.org/). The syntax is the same – just use `avconv` instead of `ffmpeg` for the above examples.\n\n---\n\nhttps://stackoverflow.com/questions/9913032/how-can-i-extract-audio-from-video-with-ffmpeg\n\nTo extract the audio stream without re-encoding:\n\n```\nffmpeg -i input-video.avi -vn -acodec copy output-audio.aac\n```\n\n- `-vn` is no video.\n- `-acodec copy` says use the same audio stream that's already in there.\n\nRead the output to see what codec it is, to set the right filename extension.\n\n# 按时间范围截取\n\nhttps://blog.csdn.net/u011573853/article/details/103221606\n\n* 截取一段音频\n\n  ```\n  ffmpeg -i lesson.mp3 -ss 6:17 -to 8:25 -c copy lessson4.mp3\n  ```\n\n* 把音频加入从头加入到视频\n  ```\n  ffmpeg -i lessson4.mp3 -i video.mp4 -map 0:0 -map 1:1 -c copy movie.mp4\n  ```\n\n* 截取一段视频\n  ```\n  ffmpeg -i '1.mp4' -ss 00:01:17 -t 00:10:45 -vcodec copy -acodec copy yundong.mp4\n  ffmpeg -ss 00:00:10 -i input.mp4 -c copy output.mp4 # 减去前面10秒\n  ```\n\n# 常用操作命令总结\n\nhttps://www.jianshu.com/p/341e0673bfe8\n\n## 截图\n\n```bash\nffmpeg -ss 00:43:55 -i video.mp4  -f image2  -vframes 1 -y frame.png\n```\n\n注意将`ss`放到最前面可以加快速度, `-y`代表覆盖文件 `-vframes`代表帧数 `-i`代表输入，即in；`-ss`也可以使用单个数字，代表秒数，从0开始计算。\n\n## 去固定水印\n\n```bash\nffmpeg -i video.mp4 -vf \"delogo=x=1680:y=60:w=160:h=55\"  -y  new_1.mp4\n```\n\n这里`-vf`表示`video filter`， 其中`delogo`的参数代表水印的坐标和大小，把视频左上角作为坐标原点，横向为x轴，纵向为y轴。这种情况除非预先知道水印的位置和大小，否则不是特别方便，当然，准确识别水印位置也是一个难点，不是很轻易能实现的。\n 可能根据某些`ffmpeg`版本不同，需要加`-strict experimental` 参数，一种情况是比较老的版本音频`ACC`属于实验阶段，可以按情况设置或者升级`ffmpeg`版本。\n\n## 获取视频时长\n\n```bash\nffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 new_out.mp4\n```\n\nffprobe 是ffmpeg 配套的一个工具，可以查看一些内容信息。上面的命令可以直接获得秒为单位的视频时长\n\n1. 获取视频信息并优化展示\n    `ffprobe -v quiet -print_format json -show_format -show_streams pianpian.mp4`\n    这里`-v`代表日志级别，可以使用`debug`用来分析某些异常；  上面的命令会以json格式输出`format`和`stream`两项的信息.\n2. 转码再生成m3u8\n    先转为ts格式:\n\n```bash\nffmpeg -y -i video.mp4 -c:v copy -c:a copy -vbsf h264_mp4toannexb output.ts\n```\n\n这里 `-c:v`, `-c:a`分别代表视频，音频格式，`copy`代表原视频格式， `-vbsf`或者`-bsf:v`(`-bsf:a`)，表示`bitstream filter`，转码格式。\n 转换m3u8：\n\n```bash\nffmpeg -i output.ts  -c copy -map 0 -f segment -segment_list index.m3u8 -segment_time 10 video_sgs/video-%03d.ts\n```\n\n中间参数没有太了解，功能是将视频分段并生成m3u8文件， 包括设置分段视频的长度。\n\n## 视频分帧\n\n```bash\nffmpeg -i src01.avi %d.jpg\n```\n\n将视频所有帧保存为图片。 注意整体内容可能比较大，实验中19MB的1280*720视频，分帧后的图片有3.8G。\n\n## 视频加文字水印\n\n```bash\nffmpeg -i input.mp4 -vf \"drawtext=fontfile=simhei.ttf:text='雷':x=100:y=10:fontsize=24:fontcolor=yellow:shadowy=2\" drawtext.mp4\n```\n\n可以给水印设置字体，大小，颜色等。 字体颜色可以用RGB代码，比如`fontcolor=#FFFF00`，如果要设置透明度可以这样写：`fontcolor=#FFFFFF@0.6`，表示0.6的透明度，取值为`0.1-1.0`。\n `shadowy`表示阴影。\n\n> 注意： 这里冒号`:`是关键字，如果是要加到水印里，需要转义，用四个\\下面是一个例子\n\n```bash\nffmpeg -i source.mp4 -vf \"drawtext=fontfile=MicroYaHei.ttf:text=By\\\\\\\\:三峡不好人:x=1240:y=44:fontsize=73:fontcolor=#FFFFFF@0.8\"  -y drawtext_out.mp4\n```\n\n## ffmpeg限制cpu数\n\n ffmpeg在去水印，加水印的时候，默认都是占满可用CPU的，某些情况下需要限制CPU数。网上文章乱七八糟，各种抄，很多说用`-threads` 参数，但说的不明不白。 以下亲测，`-threads`参数放到 -y 前面是可以生效的， Linux 可以用`top -H -p <pid>` 看运行线程数来验证， 同时可以用`uptime`比较限制线程和不限制的CPU使用率。 如下是限制为2个线程。\n\n```bash\nffmpeg -i source.mp4 -vf \"drawtext=fontfile=MicroYaHei.ttf:text=By\\\\\\\\:三峡不好人:x=1240:y=44:fontsize=73:fontcolor=#FFFFFF@0.8\"  -threads 2  -y drawtext_out.mp4\n```\n# 将多个TS文件批量转换为MP4格式\n批量转换脚本\n- ​**Windows（批处理脚本）​**：    \n    1. 新建文本文件，输入以下内容：        \n        ```bash\n        @echo off\n        for %%i in (*.ts) do (\n            ffmpeg -i \"%%i\" -c copy \"%%~ni.mp4\"\n        )\n        pause\n        ```\n    2. 保存为 `convert.bat`，放到TS文件所在文件夹，双击运行。\n- ​**Linux/macOS（Shell脚本）​**：\n    1. 新建脚本文件 `convert.sh`：\n        ```bash\n        #!/bin/bash\n        for file in *.ts; do\n            ffmpeg -i \"$file\" -c copy \"${file%.ts}.mp4\"\n        done\n        ```\n    2. 添加执行权限并运行：\n        ```bash\n        chmod +x convert.sh\n        ./convert.sh\n        ```\n## Windows\n在Windows批处理脚本中，`\"%%~ni.mp4\"` 是一个特殊的 ​**变量扩展语法**，用于处理文件名。具体含义分解如下：\n\n- 在批处理脚本中必须使用 ​**双百分号**​（`%%i`），而在命令行直接执行时用单百分号（`%i`）。\n\n| 符号          | 含义                                 |\n| ----------- | ---------------------------------- |\n| `%%i`       | 循环变量，表示当前处理的文件名（如 `video1.ts`）     |\n| `%~ni`      | 去掉文件名的扩展名（`.ts`），只保留主文件名（`video1`） |\n| `.mp4`      | 添加新的扩展名                            |\n| `%%~ni.mp4` | 组合后的完整新文件名（`video1.mp4`）           |\n其他常见变量扩展\n\n|语法|作用|示例（原文件名：`D:\\Videos\\test.ts`）|\n|---|---|---|\n|`%%~i`|完整路径+文件名|`D:\\Videos\\test.ts`|\n|`%%~di`|驱动器盘符|`D:`|\n|`%%~pi`|文件路径（不含文件名）|`\\Videos\\`|\n|`%%~ni`|主文件名（不含扩展名）|`test`|\n|`%%~xi`|扩展名（包含点号）|`.ts`|\n|`%%~fi`|完整绝对路径|`D:\\Videos\\test.ts`|\n- `-c copy`：直接复制音视频流，无需重新编码（速度快）。\n- 如需重新编码（兼容性更好，但速度慢）：\n\n```bash\nffmpeg -i input.ts -c:v libx264 -c:a aac output.mp4\n```","categories":["一些工具的使用"]},{"title":"x86体系历程","url":"/计算机知识体系/x86体系历程/","content":"# 内容\n\n比较著名的芯片体系：\n\n* Intel x86\n* AMD\n* ARM7/9\n* ppc\n* mips\n\nIntel和AMD多用于PC。现在的手机、平板用的大多是ARM9，可穿戴设备大多是ppc、mips。ARM、ppc、mips实时性非常好。\n\n> 读本文前需要明确：\n>\n> 1. CPU位数表示ALU宽度（数据总线条数）。所以要说CPU是多少位由ALU宽度（数据总线条数）决定。\n> 2. CPU可寻址能力由CPU芯片上的地址总线条数决定。\n> 3. CPU地址总线条数不等于CPU位数。\n\n# Intel 80x86家族发展历程\n\n每天所讲到的x86-32位体系指的是从Intel 80386芯片一直到后面所发展的一系列32位处理器。而x86并不是从32为起步，而是从1978年的8086（16位）开始发展，经过80186（16）、80286（伪32）。\n\n1. 1970年代\n   1. 4004 -- 4位\n   2. 8008 -- 8位\n2. 1974年代\n   1. 8080 -- 8位\n   1. 8085 -- 8位\n3. 1978年代\n   1. 8086 -- 16位\n   2. 80186 -- 16位\n4. 1983年代\n   1. 80286 -- 32位（伪）\n   2. 80386 -- 32位（真）\n   3. 80486 -- 32位\n5. 1993年代\n   1. Pentium -- 32位\n\n8位芯片如果只有8条地址总线，那么只能寻址256字节，这样的CPU局限性太高，因此早期的8位CPU（如8080、8085）的地址总线设计成了16条，可以寻址64KB。\n\n8位芯片的寄存器只有1个字节，但是寻找的地址是16位即2字节地址，不能全部放到一个寄存器中，需要分开存放。8位芯片导致数据位数和地址位数不对等，形成了历史包袱，所以在8080和8085中出现了很多16位的汇编指令以解决数据和地址位数不对等的问题。\n\n到了8086芯片，是16位CPU，地址总线设计为20条，可寻址1MB。虽然数据和地址位数不对等，但是巧妙的设计可以解决这个问题，当初设计师没有按照8080、8085那样设计20位汇编指令，而是让地址入寄存器时右移4位。\n\n# 开创x86体系--开始分段--实模式\n\n从8086开始，增加了4个段寄存器，CS、DS、SS、ES，分别是代码段寄存器、数据段寄存器、堆栈段寄存器、扩展段寄存器，都是16位，可存放2字节。另外还有一个IP寄存器，也是16位，名字含义为指令指针寄存器，可专门存放内存地址偏移量，即内存地址。\n\n此时，设计师把内存划分为分段体系，规定每个段的起始地址必须是16的倍数，所以每个段至少有16个字节，最大呢？是IP寄存器能最大支持存放的数字，即$2^{16}=64KB$。此时，每一段的内容都有其段起始地址和段范围。这就可以把每一段的起始地址写到相应的段寄存器中了。\n\n为啥规定每个段的起始地址必须是16的倍数？如果一个数字能被16整除，那么2进制下，这个数字的低四位均为0！因此可以右移四位已知的数据，把其余高位有效数据存放到16位段寄存器中！这就是巧妙之处。\n\n由此以来，之后的寻址方式就变成：取具体对应段的段寄存器为段基址，作为地址总线高16位，再加上具体数据在段中的相对偏移量（从IP寄存器中的值取）。\n\n如此推演：\n\n1. 段寄存器中的值，左移4位，对应的值就称为：段基址\n2. IP寄存器中的值，就称为一个内存段上的偏移量/偏移地址/相对地址/**逻辑地址**\n\n在8086芯片开创的年代，还没有虚拟地址映射的概念，因此寻址得到的数据地址直接对应了内存上的物理地址。这样的模式，称为**实地址模式**，也叫实模式。\n\n# 融合操作系统--保护模式\n\n实现保护机制，就要在保存段起始地址的同时，记录段的范围，确保不要越界。同时也要给每一个段记录其访问权限。\n\n1. 内存段起始地址\n2. 内存段长度 - 防止偏移量（逻辑地址）越界\n3. 内存的权限信息 - 确保他人访问时合法，避免任意读取、修改、执行\n\n虽然32位处理器是32位，但是其段寄存器的大小依旧是16位，肯定是无法存放这些全部内容的，即使有32位的寄存器也不够存储。\n\n但在80386这个处理器上，做出了变革，增加了GTDR和LDTR两个寄存器，分别是全局段描述符表寄存器、局部段描述符表寄存器，前者是所有进程共享的，后者是每个进程私有的。\n\n段描述符表实际上是一个数组，依次存放了每个段的信息。\n\n因此，从前的段寄存器则需要用来存储段描述符表中本段对应的下标值。\n\n段寄存器，共16位，低2位存储权限标志，00表示最高权限，11表示最低权限，表示当前段属于用户态/内核态下的空间。第3个低位表示当前段的信息存储在GDTR/LDTR中，0表示GDTR，1表示LDTR。剩下的高13位存储描述符表中对应的下标值。最大值为$2^{13}=8192$。其中内核代码占用了12个全局段描述符表项，因此可用的值有8180个。\n\n![image-20220828210620727](../../images/x86体系历程/image-20220828210620727.png)\n\n段描述符表的表项的结构：\n\n![image-20220828210941156](../../images/x86体系历程/image-20220828210941156.png)\n\n段描述表中的一个表项中记录了32位段基址，20位段长度大小及其单位。\n\n## 保护模式下内存分段的地址映射\n\n段寄存器存储的值，右移3位，得到段描述符中对应的下标值。再到段描述符（GDT）中取得该段的信息（基址、大小、权限属性）。\n\n则保护模式下内存分段的地址映射可以如下计算获得：（以取得DS数据段某地址为例）\n\n$GDT[DS>>3].BaseAddr+IP=线性地址$。其中，IP要和记录的段长度进行比较，判断是否越界。\n\n如果没有分页机制，则以上线性地址就是实际的物理地址。\n\n## 保护模式下内存分页的地址映射\n\n继续，判断内核是否打开内存页映射，标志位存储于CR0寄存器中的PG位，为0表示只分段，为1表示使用内存分页。\n\n| 寄存器 | 描述                         |\n| ------ | ---------------------------- |\n| CR0    | PG：内存是否开启分页机制     |\n| CR2    | 保存发生缺页异常时的虚拟地址 |\n| CR3    | 保存当前进程的页目录起始地址 |\n| CR4    | PAE是否开启物理地址扩展      |\n\n如果打开了内存分页机制，那么得到的该线性地址就称为虚拟地址，需要经过页面的多级映射，才能得到真正的物理地址。\n\n32位下，需要二级映射；36位下，需要三级映射；64位下，需要四级映射。\n\n拿32位举例子，分为三段，10、10、12。高10位表示页目录的下标值，次10位表示页表的下标值，低12位表示物理页面上的偏移量。\n\n10位限制了页目录最多有1024项，每一项都是4字节，32位，则页目录本身占4KB。页目录项中存储了页表的地址。\n\n10位限制了页表最多有1024项，每一项都是4字节，32位，则页表本身占4KB。页表项中存储了一个物理页面的起始地址。\n\n12位限制了地址偏移量最大为4K，刚好对应于一个页面的大小4KB，确保不会确界。\n\n因为一页是4KB，所以每一个页面的地址都是4K的整数倍，那么这些地址的低12位都为0，所以PT（页表）中的页表项的32位中只需高20位来存储物理页面号（也称作框号）。同样的道理，每个页表都是4KB，那么PG（页目录）中的页目录项的32位中只需高20位来存储页表的起始地址。剩下的12位存什么呢？权限信息（比如页有无分配？是否可访问？是否是脏页）。\n\n其中，PT项的最低1位是present位，为0表示页表项对应的物理页面在交换分区中，为1表示此页面就在物理内存中。换页算法中需要与这个位打交道。\n\n物理页面的结构体可在内核源码中`struct page`看到，命名为`mem_map_t`。\n\n物理页面实际上用动态开辟的数组来管理，是一个`mem_map_t * mem_map`。PT项的高20位即为物理页面数组的下标。\n\n最多有1024个PG，1个PG可以映射1024个PT，1个PT可以映射1024个物理页面，1个物理页面有4KB。由此，我们可以计算得到，$1024*1024*4KB=4GB$\n\n### 问题：每个进程如何确保页目录、页表地址不冲突\n\n我们可以想到，每个进程都分配了相同大小的虚拟地址空间。那么变量的地址也可能会存在相同的情况。而每个CPU都要同时执行多个进程，CR3寄存器（存放页目录地址）只有一个。每一个进程都有自己独立的地址空间，所以不同进程在切换的时候，要把自己的页目录地址更新到CR3寄存器中。\n\n可在内核代码中`switch_mm`函数中看到：\n\n```c\nstatic inline void switch_mm(struct mm_struct *prev, ...)\n{\n    {\n        ...\n        asm volatile(\"movl %0, %%cr3\": :\"r\" (__pa(next->pgd)));\n    }\n}\n```\n\n","categories":["操作系统","计算机知识体系"]},{"title":"Linux_vim_会话和viminfo","url":"/Linux/Linux_vim_会话和viminfo/","content":"\n所用命令涉及到的帮助入口：\n\n```\n:help mksession\n:help 'sessionoptions'\n:help source\n:help wviminfo\n:help rviminfo\n:help 'viminfo'\n```\n\n很多软件都具有这样一种功能：在你下一次启动该软件时，它会自动为你恢复到你上次退出的环境，恢复窗口布局、所打开的文件，甚至是上次的设置。\n\nvim有没有这种功能呢？答案当然是肯定的！这需要使用vim的会话(session)及viminfo的保存和恢复功能。\n\n使用会话(session)和viminfo，可以把编辑环境保存下来，然后在下次启动vim后，可以再恢复回这个环境。在开发项目或书写文档时，如果在中途退出了vim而不能恢复原先的编辑环境的话，又要重新打开你所打开的文件，重新定义你的映射(map)、缩写(abbreviate)，重新定位你所设定的标记的位置(mark)，重新设置项目相关设置(options)等等，不是一般的麻烦！\n\n要恢复上次的编辑环境，我们需要保存两种不同的信息，一种是会话(session)信息，另外一种是viminfo信息。\n\n- 会话信息中保存了所有窗口的视图，外加全局设置。\n- viminfo信息中保存了命令行历史(history)、搜索字符串历史(search)、输入行历史、非空的寄存器内容(register)、文件的位置标记(mark)、最近搜索/替换的模式、缓冲区列表、全局变量等信息。\n\n# 会话\n\n我们可以使用`:mksession [file]`命令来创建一个会话文件，如果省略文件名的话，会自动创建一个名为`Session.vim`的会话文件。\n\n会话文件，其本质上是一个**vim脚本**，你可以使用上述命令生成一个session文件，然后再查看其中的内容，就会对session文件有一个深入的认识。\n\n会话文件中保存哪些信息，是由`sessionoptions`选项决定的。缺省的`sessionoptions`选项包括：`blank`, `buffers`, `curdir`, `folds`, `help`, `options`, `tabpages`, `winsize`，也就是会话文件会恢复当前编辑环境的空窗口、所有的缓冲区、当前目录、折叠(fold)相关的信息、帮助窗口、所有的选项和映射、所有的标签页(tab)、窗口大小。\n\n如果你使用windows上的vim，并且希望你的会话文件可以同时被windows版本的vim和UNIX版本的vim共同使用的话，在`sessionoptions`中加入`slash`和`unix`，前者把文件名中的`\\`替换为`/`，后者会把会话文件的换行符保存成unix格式。\n\n如果你不希望在`session`文件中保存当前路径，而是希望`session`文件所在的目录自动成为当前工作目录，那么，需要在`sessionoptions`去掉`curdir`，加入`sesdir`，这样每次载入`session`文件时，此文件所在的目录就被设为vim的当前工作目录。在你通过网络访问其它项目的session文件时，或者你的项目有多个不同版本（位于不同的目录），而你想始终使用一个session文件时，这个选项比较有用：你只需要把session文件拷贝到不同的目录，然后使用就可以了。设置此选项后，session文件中保存的是文件的相对路径，而不是绝对路径。\n\n我们在上面使用`:mksession`命令创建了会话文件，那么怎么使用会话文件恢复编辑环境呢？很简单，你只需要使用`:source session-file`来导入会话文件。因为会话文件是一个脚本，里面保存的是Ex命令，所以`source`命令只是把会话文件中的Ex命令执行一遍。\n\n# viminfo\n\n使用`:wviminfo [file]`命令，可以手动创建一个`viminfo`文件。\n\n其实，在vim退出时，每次都会保存一个`.viminfo`文件在用户的主目录。我们使用`:wviminfo`命令则是手动创建一个`viminfo`文件，因为缺省的`.viminfo`文件会在每次退出vim时自动更新，谁知道你在关闭当前软件项目后，又使用vim做过些什么呢？这样的话，`.viminfo`中的信息，也许就与你所进行的软件项目无关了。还是手动保存一个保险。\n\n`:wviminfo`命令保存哪些内容，以及保存的数量，由`viminfo`选项决定，这个选项的值在windows上和在linux上的缺省值不同，具体含义参阅手册。\n\n要读入你所保存的`viminfo`文件，使用`:rviminfo [file]`命令。\n\n现在，先看一下我们当前目录，执行`:pwd`，显示`/home/xcg/vimtest`，接下来，执行下面的命令：\n\n```vim\n:cd src                            \"切换到/home/xcg/vimtest/src目录 需要先在外部创建该目录\n:set sessionoptions-=curdir        \"在session option中去掉curdir\n:set sessionoptions+=sesdir        \"在session option中加入sesdir\n:mksession vim90.vim               \"创建一个会话文件\n:wviminfo vim90.viminfo            \"创建一个viminfo文件\n:qa                                \"退出vim\n```\n\n退出vim后，在命令行下执行`vim`，再次进入vim，这时看到的是一个空白窗口。然后执行下面的命令：\n\n```\n:source ~/vimtest/src/vim90.vim    '载入会话文件\n:rviminfo vim90.viminfo            '读入viminfo文件\n```\n\n太棒了，又恢复到昨天退出时的状态了！继续工作。不过，每次都要手工修改`sessionoptions`或`viminfo`吗？多麻烦啊。别着急，现在是时候介绍vimrc了。","categories":["Linux","vim"]},{"title":"Linux_vimrc","url":"/Linux/Linux_vimrc/","content":"\n# vim安装\n\nLinux下的安装。\n\nThe Vim repository at GitHub: Vim is available through git. This is the most straightforward way to get Vim and keep it up-to-date.\n\nYou can obtain Vim for the first time with:\n\n```\ngit clone https://github.com/vim/vim.git\n```\n\nAnd, if you don't have local changes, update to the latest version with:\n\n```\ncd vim\ngit pull\n```\n\nIf you made some changes, e.g. to a makefile, you can keep them and merge with the latest version with:\n\n```\ncd vim\ngit stash\ngit pull\ngit stash pop\n```\n\nIf you have local changes you may need to merge. If you are sure you can discard local changes (e.g. if you were just trying a patch), you can use:\n\n```\ngit fetch --all\ngit reset --hard origin/master\n```\n\n## Building Vim\n\nBuild and install Vim as usual. If you are happy with the defaults:\n\n```\ncd src\nmake distclean  # if you build Vim before\nmake\nsudo make install\n```\n\n# vimrc在哪\n\nvimrc究竟在哪儿呢？这个问题对一个vim的入门用户来说，可能实在不是个问题，你可能回答：”不就是`$HOME/.vimrc`吗？”。是的，这个答案正确，不过不是全部。\n\n首先，在Linux下的Vim中输入`:version`命令(可能你是使用Linux下的vi命令打开编辑器，不过在大多数Linux中，vi命令打开的就是Vim)，我们略过不相关的内容，关于vimrc的显示如下(可能你的显示不完全和这里相同)：\n\n```\n# Linux下的vim\n:version\nVIM - Vi IMproved 8.0 (2016 Sep 12, compiled Jun 26 2017 11:44:34)\nIncluded patches: 1-678\n\n   system vimrc file: \"$VIM/vimrc\"\n     user vimrc file: \"$HOME/.vimrc\"\n 2nd user vimrc file: \"~/.vim/vimrc\"\n      user exrc file: \"$HOME/.exrc\"\n  system gvimrc file: \"$VIM/gvimrc\"\n    user gvimrc file: \"$HOME/.gvimrc\"\n2nd user gvimrc file: \"~/.vim/gvimrc\"\n...\n```\n\n在上面，我们看到列出了几个vimrc文件，有一个系统的vimrc文件，还有用户的vimrc文件，以及系统和用户gvimrc文件。出于和vi兼容的目的，vim也支持vi的exrc配置文件。\n\n接着，我们在Windows系统中输入`:version`命令，可以看到如下输出(使用的是预编译的Vim 8.0)：\n\n```\n# Windows下的vim\nVIM - Vi IMproved 9.0 (2022 Jun 28, compiled Jun 28 2022 12:46:00)\nMS-Windows 32-bit GUI version with OLE support\nCompiled by mool@tororo\n\n   system vimrc file: \"$VIM\\vimrc\"\n     user vimrc file: \"$HOME\\_vimrc\"\n 2nd user vimrc file: \"$HOME\\vimfiles\\vimrc\"\n 3rd user vimrc file: \"$VIM\\_vimrc\"\n      user exrc file: \"$HOME\\_exrc\"\n  2nd user exrc file: \"$VIM\\_exrc\"\n  system gvimrc file: \"$VIM\\gvimrc\"\n    user gvimrc file: \"$HOME\\_gvimrc\"\n2nd user gvimrc file: \"$HOME\\vimfiles\\gvimrc\"\n3rd user gvimrc file: \"$VIM\\_gvimrc\"\n       defaults file: \"$VIMRUNTIME\\defaults.vim\"\n    system menu file: \"$VIMRUNTIME\\menu.vim\"\n```\n\n比较一下上面两个`:version`命令的输出，我们发现：\n\n1. Vim启动时，会先尝试执行用户vimrc，并使用所找到的第一个用户vimrc中的配置，忽略其余的用户vimrc。其次才找系统的vimrc文件。\n2. 在Linux下使用的vimrc文件名为`.vimrc`，在Linux下，如果未找到名为`.vimrc`的文件，也会尝试查找名为`_vimrc`文件；在Windows下也是这样，只不过查找顺序颠倒一下，如果未找到名为`_vimrc`的文件，会去查找`.vimrc`。\n3. 在Windows下因为不支持以点`.`开头的文件名，vimrc文件的名字使用`_vimrc`。有两个可选的用户vimrc文件，一个是`$HOME\\_vimrc`，另外一个是`$VIM\\_vimrc`。\n4. 从这里可以看出，vimrc的执行先于gvimrc。所以我们可以把全部vim配置命令都放在vimrc中，不需要用gvimrc。\n\n对于vim初学者，如果不知道`$HOME`或者`$VIM`具体是哪个目录，可以在vim中用下面的命令查看：\n\n```vim\n:echo $VIM     # /usr/shared/vim\n:echo $HOME    # /home/xcg\n```\n\n分别打印的是`/usr/share/vim`（vim目录），`/ssd_b/xcg`（家目录）。\n\n## 选择vim配置\n\nWindows版本的Vim在安装时，缺省会安装一个`$VIM/_vimrc`，你可以直接修改这个`_vimrc`，加入你自己的配置(使用`:e $VIM/_vimrc`即可打开此文件)。或者，你也可以在Windows中增加一个名为`HOME`的环境变量(`控制面板` -> `系统` –> `高级` –> `环境变量`)，然后把你的vimrc放在HOME环境变量所指定的目录中。从上面`:version`命令的输出看到，`$HOME/_vimrc`如果存在，就会执行这个文件中的配置，从而跳过`$VIM/_vimrc`。\n\n1. 如果使用`vim -u filename`命令来启动Vim，则会用你指定的`filename`作为Vim的配置文件(在调试你的vimrc时有用)；\n2. 如果用`vim -u NONE`命令启动Vim，则不读取任何vimrc文件：当你怀疑你的vimrc配置有问题时，可以用这种方式跳过vimrc的执行。\n\n## 总结\n\nLinux和Windows下vim的启动优先寻找`$HOME/.vimrc`（Windows下是`_vimrc`），即用户自己的配置。用户配置文件不存在时，使用的是系统的配置文件`$VIM/vimrc`。\n\n# vimrc初步\n\n所用命令的帮助入口：\n\n```\n:help compatible\n:help mapleader\n:help map\n:help autocmd\n```\n\nvim的环境依赖会话(session)文件和viminfo文件，其中‘sessionoptions’选项和‘viminfo’选项的配置可能会根据需要进行调整。但如何保存所做的调整呢？需要vimrc文件。\n\n当vim在启动时，如果没有找到vimrc或gvimrc，它缺省为VI兼容的模式。这意味着，只能使用VI所具备的功能，而vim中的大量扩展功能将无法使用。\n\nvim中自带了一个vimrc例子，从这个例子开始分析。\n\n下面以Linux下的vim为例。\n\n示例的vimrc(名为`vimrc_example.vim`)通常位于`/usr/share/vim/vimXXX/`目录下，其中vimXXX与使用的vim版本有关。\n\n首先把这个示例的vimrc拷贝到相应的目录，在Linux下，应该把它拷贝到你的home目录下，名字为”.vimrc”。\n\n下面是shell命令：\n\n```\ncp /usr/share/vim/vim90/vimrc_example.vim ~/.vimrc \n```\n\n或者你在vim中执行下面的命令，和上面的shell命令完成相同的功能：\n\n```\n:!cp $vimRUNTIME/vimrc_example.vim ~/.vimrc \n```\n\n可以先读一下现在的vimrc，看看它都设定了什么：\n\n```\n:e ~/.vimrc \n```\n\n这是一个注释良好的文件，不需要多解释。\n\n> 对windows版本的vim，它已经默认的有了一个vimrc，可以在vim在使用下面的命令来查看它。\n>\n> ```\n> :e $vim/_vimrc \n> ```\n>\n> 在这个文件中，它包含了上面提到的`vimrc_example.vim`。同时，它会把vim设置的更符合windows的操作习惯。比如，支持CTRL-C拷贝，CTRL-V粘贴等等。Windows下的用户，可以使用`$vim/_vimrc`来做为第一个vimrc。\n>\n> 顺便提一句，在unix/linux中，文件名可以以”.”开头，表明此文件是隐藏的。而在windows中，不允许文件名以”.”开头，所以，windows版本的vim，将读取`_vimrc`来做为自己的配置文件。\n\n## 打开vimrc的快捷方式\n\n在今后使用vim的日子里，会频繁的更改vimrc。所以需要设置一些快捷方式，使我们能快速的访问vimrc。\n\n把下面这段内容拷贝到vimrc中：\n\n```\n1  \"Set mapleader\n2    let mapleader = \",\"\n3\n4  \"Fast reloading of the .vimrc\n5    map <silent> <leader>ss :source ~/.vimrc<cr>\n6  \"Fast editing of .vimrc\n7    map <silent> <leader>ee :e ~/.vimrc<cr>\n8  \"When .vimrc is edited, reload it\n9    autocmd! bufwritepost .vimrc source ~/.vimrc \n```\n\n- 在vimrc中，双引号开头的行，将被当作注释忽略。\n- 第2行，用来设置`mapleader`变量，当`mapleader`为未设置或为空时，使用缺省的”`\\`”来作为mapleader。\n\nmapleader变量是作用是什么呢？看下面的介绍。\n\n- 第5行定义了一个映射(map)，这个映射把`<leader>ss`，映射为命令`:source ~/.vimrc<cr>`。当定义一个映射时，可以使用`<leader>`前缀。而在映射生效时，vim会把`<leader>`替换成mapleader变量的值。也就是说，我们这里定义的`<leader>ss`在使用时就变成了”`,ss`“，当输入这一快捷方式时，就会source一次`~/.vimrc`文件(也就是重新执行一遍`.vimrc`文件)。\n- 第7行，定义了`<leader>ee`快捷键，当输入`,ee`时，会打开`~/.vimrc`进行编辑。\n- 第9行，定义了一个自动命令，每次写入`.vimrc`后，都会执行这个自动命令，source一次`~/.vimrc`文件。\n\n有了上面的快捷键，我们就能快速的打开vimrc文件编辑，快速重新source vimrc文件，方便多了。注意，`,ee`、`,ss`命令不是在冒号模式下输入，而是空悬模式下输入，在右下角可看到输入的命令。\n\n## 使用同一个vimrc文件\n\n为了实现无论在windows还是在linux中都能使用vim作为缺省编辑器。并且，想使用同一个vimrc文件。因此定义了一个`MySys()`函数，用来区分不同的平台，以进行不同的配置。\n\n另外，在编辑vimrc文件时，最好新开一个标签页来编辑，而不是在当前窗口中。因此，定义了`SwitchToBuf()`函数，它在所有标签页的窗口中查找指定的文件名，如果找到这样一个窗口，就跳到此窗口中；否则，它新建一个标签页来打开vimrc文件。\n\n> 注：标签页(tab)功能只有在vim 7.0版本以上才支持。\n\n下面是示例：\n\n```\n\" Platform\nfunction! MySys()\n  if has(\"win32\")\n    return \"windows\"\n  else\n    return \"linux\"\n  endif\nendfunction\n\nfunction! SwitchToBuf(filename)\n    \"let fullfn = substitute(a:filename, \"^\\\\~/\", $HOME . \"/\", \"\")\n    \" find in current tab\n    let bufwinnr = bufwinnr(a:filename)\n    if bufwinnr != -1\n        exec bufwinnr . \"wincmd w\"\n        return\n    else\n        \" find in each tab\n        tabfirst\n        let tab = 1\n        while tab <= tabpagenr(\"$\")\n            let bufwinnr = bufwinnr(a:filename)\n            if bufwinnr != -1\n                exec \"normal \" . tab . \"gt\"\n                exec bufwinnr . \"wincmd w\"\n                return\n            endif\n            tabnext\n            let tab = tab + 1\n        endwhile\n        \" not exist, new tab\n        exec \"tabnew \" . a:filename\n    endif\nendfunction\n\n\"Fast edit vimrc\nif MySys() == 'linux'\n    \"Fast reloading of the .vimrc\n    map <silent> <leader>ss :source ~/.vimrc<cr>\n    \"Fast editing of .vimrc\n    map <silent> <leader>ee :call SwitchToBuf(\"~/.vimrc\")<cr>\n    \"When .vimrc is edited, reload it\n    autocmd! bufwritepost .vimrc source ~/.vimrc\nelseif MySys() == 'windows'\n    \" Set helplang\n    set helplang=cn\n    \"Fast reloading of the _vimrc\n    map <silent> <leader>ss :source ~/_vimrc<cr>\n    \"Fast editing of _vimrc\n    map <silent> <leader>ee :call SwitchToBuf(\"~/_vimrc\")<cr>\n    \"When _vimrc is edited, reload it\n    autocmd! bufwritepost _vimrc source ~/_vimrc\nendif\n\n\" For windows version\nif MySys() == 'windows'\n    source $VIMRUNTIME/mswin.vim\n    behave mswin\nendif \n```\n\n注意：在windows中也定义了一个”HOME”环境变量，然后把`_vimrc`放在”HOME”环境变量所指向的目录中。这样才能在windows中使用。\n\n好了，现在我们知道如何永久更改`‘sessionoptions’`选项和`‘viminfo’`选项了，把对它们的配置放入vimrc即可。\n\nvim自带的示例vimrc中，只定义最基本的配置。\n\n在http://www.amix.dk/vim/vimrc.html有一个非常强大的vimrc，有人戏称为”史上最强的vimrc”，或许有些言过其实。不过，如果通读了这个vimrc，相信能从中学到很多。[这里](http://blog.csdn.net/redguardtoo/archive/2006/09/03/1172136.aspx)有一个redguardtoo修改过的版本，可以对照参考一下。但是不要照拷这两个vimrc，可能这个文件的设定并不符合你的习惯。另外，这个文件的设定，可能也不能在当前的工作环境中运行。\n","categories":["Linux","vim"]},{"title":"Linux_vim保存项目相关配置","url":"/Linux/Linux_vim保存项目相关配置/","content":"\n本节所用命令的帮助入口：\n\n```\n:help 'path'\n:help mksession\n:help find\n:help gf\n:help CTRL-W_f\n```\n\n# 引入：path\n\nvimrc定义了vim通常的行为。然而，每个项目都有其特殊的定义，虽然我们也可以在vimrc中对每个项目进行定制，但这样一来，vimrc会变得很大，使vim启动速度变慢；另外也会使vimrc变得难以维护。\n\n因此，使用其它的方法来保存项目相关的信息，将以*path*选项的设置为例进行。\n\npath选项定义了一个目录列表，在使用`gf`，`find`，以及`CTRL-W f`等vim命令时，如果使用的是相对路径，那么就会在path选项定义的目录列表中查找相应的文件。path选项以逗号分隔各目录名。我们以vim的源代码为例（源代码放在`~/src/vimXX/`目录中）。\n\n对于这个项目，我们的*path*选项设置如下：\n\n```\nset path=.,/usr/include,,~/src/vim90/**\n```\n\n稍微解释一下各项的含义，更详细的信息，请查看*path*选项的帮助页：\n\n- `.`：在当前文件所在目录中搜索\n- `/usr/include`：在`/usr/include`目录中搜索\n- `,,`：在当前工作路径中搜索\n- `~/src/vim90/**`：在`~/src/vim90`的所有子目录树中进行搜索\n\n设置了*path*选项后，怎么用呢？\n\n我们把光标定位到`src/main.c`文件第22行的`fcntl.h`单词上，然后在`Normal`模式下按`gf`。咦，`vim`打开了`/usr/include/fcntl.h`文件！\n\n现在我们按`CTRL-^`回到刚才的位置，光标仍旧定位在第22行的`fcntl.h`单词上，然后按`CTRL-W f`。啊哈，这次vim打开了一个水平分隔窗口，在此窗口中打开了`/usr/include/fcntl.h`。\n\n尽管在`src/main.c`中未指定`fcntl.h`的路径，但vim会在*path*选项定义的路径中搜索此文件，很方便。\n\n现在我们看一下`find`命令，输入：\n\n```\n:find netrw.vim\n```\n\nvim打开了`~/src/vim90/runtime/autoload/netrw.vim`文件。用这种方法打开文件真是太方便了，你不用输入文件的路径，vim会自动在*path*选项定义的路径中搜索。不过`find`命令也有缺陷，如果你只记得文件名的一部分，那么就没有办法用find命令打开这个文件了。而且find命令也不允许使用正则表达式。没关系，我们还有更好的方法来打开文件，要用到Lookupfile插件。\n\n*path*选项介绍完了，进入正题，如何把本项目相关的配置保存起来，下次打开本项目时自动恢复这些配置呢？\n\n我们有两种方法做到这一点。\n\n## 项目相关的配置保存起来：方法1\n\n我们在`~/src/vim90/`目录下建立一个文件，假定文件名为`workspace.vim`，文件内容为：\n\n```\n\"set project path\nset path+=~/src/vim70/** \n```\n\n这个文件中保存了项目相关的信息，例如选项值，键映射，函数定义，自动命令，等等。我们的例子中只定义的path选项，我们没有使用`set path=…`语句，在vim手册中建议使用`set path+=…`和`set path-=…`格式。\n\n接下来，在你的vimrc文件中加入下面的语句：\n\n```\n\" execute project related configuration in current directory\nif filereadable(\"workspace.vim\")\n    source workspace.vim\nendif\n```\n\n以后，每次在`~/src/vim90/`目录中启动vim时，vim都会自动载入`workspace.vim`，恢复项目的配置信息。\n\n## 方法2\n\n回顾会话(session)和viminfo的作用。使用session文件和viminfo也可以保存项目环境的方法。如果你使用了会话文件，那么选项值，键映射，和其它很多信息都已经保存了。但会话的功能毕竟有限，不能把项目相关的配置全部保存下来，怎么办呢？\n\nvim的作者已经想到了这个问题，并提供了解决办法。\n\n在vim载入会话文件的最后一步，它会查找一个额外的文件并执行其中的ex命令。查找的规则是，把会话文件名的后缀去掉，然后在后面加上`x.vim`。假设你的会话文件名为`example.session`，vim就会查找是否有`examplex.vim`，如果找到，就会执行此文件中的ex命令。\n\n好了，我们先创建我们的会话文件：\n\n```\n:cd ~/src/vim70\n:set sessionoptions-=curdir        '在session option中去掉curdir\n:set sessionoptions+=sesdir        '在session option中加入sesdir\n:mksession vim70s.vim              '创建一个会话文件 \n```\n\n然后再编辑一个名为~/src/vim70/vim70sx.vim的文件，文件的内容为（当然，你可以在这个文件中加入更多内容）：\n\n```\n\"set project path\nset path+=~/src/vim70/** \n```\n\n退出vim后，在命令行下执行”gvim &”，再次进入vim，这时看到的是一个空白窗口。然后执行下面的命令：\n\n```\n:source ~/src/vim70/vim70s.vim  '载入会话文件 \n```\n\n太棒了！原来的会话环境已经恢复，并且项目相关的配置也设置好了！\n","categories":["Linux","vim"]},{"title":"Linux_忘记root密码","url":"/Linux/Linux_忘记root密码/","content":"\n1. 重启ubuntu系统，启动时持续点按ESC，直到进入GRUB界面，选择Advanced option for ubuntu，按下回车键。\n   ![image-20220826170207222](../../images/Linux_忘记root密码/image-20220826170207222.png)\n2. 选择recovery mode，按回车，进入Recovery Menu，选择\"Root Drop to root shell prompt\"）\n3. 进入shell界面，使用`passwd`命令重新设定密码：`password root`，回车确认。\n4. 输入新密码，两次。\n5. sudo reboot，重启系统进入GUI界面。\n\n>可能会在其中很有可能会出现”Authentication token manipulation error“的错误。别先执行”`mount -rw -o remount /`“，然后再执行第3步就可以了。\n","categories":["Linux"]},{"title":"Linux_挂载","url":"/Linux/Linux_挂载/","content":"# Unix 挂载光盘\nVMware - 虚拟机设置：\n![](../../images/Linux_挂载/image-20250716174155893.png)\n\n在根目录下的dev中：`/dev/`（dev代表设备）\n![](../../images/Linux_挂载/image-20250716174257622.png)\n可以看到一个iso9660的目录。这是光盘设备在Unix系统上的存在形式。\n![](../../images/Linux_挂载/image-20250716174340480.png)\n进入，可以看到我们的光盘内容名称`Regular Expression`已经列在其中。\n![](../../images/Linux_挂载/image-20250716174436888.png)\n是c，代表字符形式的文件。（字符类文件代表可以像文件流一样读取）\n\n它实际只是一个驱动器，需要把它挂载到系统的一个文件夹下。\n使用mount指令，把它挂载到`/mnt`下。\n```sh\nmount -t cd9660 /dev/iso9660/REGULAR%20EXPRESSION /mnt\n```\n![](../../images/Linux_挂载/image-20250716174812838.png)\n![](../../images/Linux_挂载/image-20250716174848207.png)\n\n现在进入`/mnt`，可以看到光盘内实际的文件了。\n\n# VirtualBox\n\n下挂载共享文件夹\n参考：https://blog.csdn.net/qq_33827423/article/details/126019729\n\n1. 在Windows下创建一个文件夹方便作为一个**共享目录**，目录名随意，但尽量方便自己辨识。\n2. VirtualBox虚拟机共享文件夹的设置：\n   1. 选中需要建立共享的虚拟机并打开`设置-共享文件夹`\n      ![image-20220826171144159](../../images/Linux_VirtualBox下挂载共享文件夹/image-20220826171144159.png)\n   2. 添加共享文件夹\n      ![image-20220826171356245](../../images/Linux_VirtualBox下挂载共享文件夹/image-20220826171356245-1706720450168-1.png)\n","categories":["Linux"]},{"title":"计算机知识体系2022_0827","url":"/计算机知识体系/计算机知识体系2022_0827/","content":"# 一段代码\n\n```cpp\nint gdata1 = 10;\nint gdata2 = 0;\nint gdata3;\n\nstatic int gdata4 = 11;\nstatic int gdata5 = 0;\nstatic int gdata6;\n\nint main()\n{\n    int a = 12;\n    int b = 0;\n    int c;\n    \n    static int d = 13;\n    static int e = 0;\n    static int f;\n    \n    return 0;\n}\n```\n\n以上，有若干变量。\n\n有全局变量、静态全局变量，有局部变量、静态局部变量。\n\n# 代码和程序的关系\n\n1. 任何语言代码产生的程序，无非是产生了两种东西。——指令、数据。程序员应该对自己写的代码了解清楚，哪些是数据，哪些是指令。\n2. 指令和数据加载到内存之后，肯定要区分区域，怎么划分？\n\n## 计算机组成\n\n三大件：CPU、内存、I/O，每家厂商有每家独自的产品实现。\n\n为了在应用层屏蔽不同产品的差异：\n\n1. IO的屏蔽是VFS（虚拟文件系统）做的。\n2. 内存和IO一起作为一个资源分配的单位，用虚拟存储器（虚拟内存）屏蔽。\n3. CPU、内存、IO一起作为一个资源调度的单位，用进程来屏蔽。\n\n因此，我们写的程序代码是不可能直接加载到物理内存上的。而是先加载到虚拟内存上。\n\n## 虚拟内存\n\n虚拟的——不存在，却看得到。那么虚拟这个概念实际上是不存在的，只是逻辑层抽象出来的。\n\n每个程序进行运行时，系统都会给其分配虚拟内存。然后系统内部再去自动管理处理底层的物理内存。\n\n虚拟内存大小有多大？和系统的位数有关。也可以理解为和CPU的位数有关。CPU位数的含义是什么？\n\n### 系统的位数/CPU的位数——CPU位数!=地址总线位数\n\n位数可以衡量一个CPU的计算能力。\n\nCPU主要是用来运算数据。一句话来说**CPU的位数等于它一次性可以计算的数据的长度**。所以，CPU的位数实际上指的是CPU中ALU（算术逻辑单元）的宽度。\n\nALU运算的数据从何而来？从寄存器哪来，那么寄存器的数据从何而来？——数据总线。所以，CPU的位数=ALU宽度=数据总线的条数\n\n所以，CPU位数压根和地址总线没关系，比如说x86体系下的16位CPU，它的数据总线是16位，而地址总线是20位；8位CPU的数据总线是8位，地址总线是16位。\n\n虚拟内存有多大？和地址总线数有关，代表CPU的可寻址能力，假如CPU有32条地址总线，那么该CPU可寻址$2^{32}$bit即4G。每个程序都会有4G的虚拟地址空间。但是要注意，CPU位数不一定等于地址总线条数！比如8086，是16位CPU，但是地址总线有20条，所以可寻址能力是$2^{20}=1MB$。\n\n总结：\n\n1. CPU位数表示ALU宽度（数据总线条数）。所以要说CPU是多少位由ALU宽度（数据总线条数）决定。\n2. CPU可寻址能力由CPU芯片上的地址总线条数决定。\n3. CPU地址总线条数不等于CPU位数。\n\n### 程序虚拟地址空间的布局\n\n略，见“进程地址空间体系”一文。\n\n# 从编译到链接--从obj到可执行文件\n\n32位系统下，obj文件的地址是按4字节对齐的。\n\n可执行文件是按照页面对齐的，一页的默认大小是4096Byte，即4KB。\n\n## 第一步：合并、调整\n\n### 合并相同名字的段？\n\n多个obj文件在进行链接时，第一步，合并每一个obj文件相同的段。这样有利于充分利用每1页来存储信息。\n\n比如有3个obj文件，3个obj的text段合并在一起，若不超过4KB，则占1页。类似地，data段、bss段也合并并且各自占独立的页面。\n\n即，可执行文件的页面是按不同段来划分的，每一页上都有全部的obj的同一个段。\n\n### 优化：合并相同权限属性的段\n\n其实，可以进一步优化，即按照相同的权限属性去划分页。比如只读数据、可读可写数据、可读可执行等等。\n\n只读数据比如说：常量字符串就存在于`.rodata`段；另外代码段也是只读的。所以可以把这两者存在同一页中。\n\n可读可写数据比如说：data段和bss段合并，这样就节省了一个页面的空间。\n\n因此，**链接的第一步：所有相同属性的段进行合并，组织在同一个页面上**。\n\n### 调整段表中每一个段的起始偏移量和段的大小\n\n因为段进行了合并，因此需要调整段的起始偏移量。\n\n### 合并符号表\n\n每一个obj文件都有符号表，符号表也要合并。\n\n### 进行符号解析\n\n所有obj符号表中对符号引用的地方都要找到该符号在哪里、哪个文件中定义？\n\n也是在此步，进行强弱符号、符号重定义的判别、决策。\n\n### 分配内存地址\n\n之前obj符号表中对符号引用的地方的地址是空的，待填，现在要分配其地址。得到合法的虚拟空间的地址。\n\n## 第二步：链接的核心——符号的重定位\n\n已经做好了符号解析、内存地址的分配，现在要更新之前符号地址错误、待填的地址信息。即**在指令段里把没填的地址修改为正确的地址**。\n\n# 可执行文件的格式\n\n观察可执行文件其ELF Header，其中有一个Entry point address属性，存储了程序的入口地址，通常是main函数地址。\n\n其次，相比obj文件，其多了一个模块是program headers。\n\n而且program header有很多个，比如，这个可执行文件有3个program header。\n\n```\n# readelf -l <可执行文件名>\nProgram Headers:\n  Type      Offset      VirtAddr    PhysAddr    FileSiz MemSiz  Flg Align\n  LOAD      0x000000    0x08048000  0x08048000  0x000e2 0x00028\tR E\t0x1000\n  LOAD      0x0000e4    0x080490e4  0x080490e4  0x00010 0x00028 RW  0x1000\n  GNU_STACK 0x000000    0x00000000  0x00000000  0x00000 0x00000 RW  0x4\n  \n Section to Segment mapping:\n  Segment Sections...\n   00     .text\n   01     ,data .bss\n   02\n   \n```\n\n两个Load类型的header的Align是0x1000，说明其对齐方式是4KB，一页。\n\n没有这两个LOAD页操作系统将不知道这个可执行文件如何执行。\n\n下面的Section to Segment mapping说的是每一个header里面对应、包含着哪些段。\n\n我们可以看到，第一个说的是LOAD1，包含了.text段；第二个说的是LOAD2，包含了.data和.bss段；\n\n同时可以在Flg属性看到，第一个LOAD是RE，代表可读、可执行；第二个LOAD是RW，可读可写。也证实了，可执行文件的页面是按照之前obj文件中相同属性的段来合并到一页的。\n\nprogram headers包含的这两个LOAD页指示了操作系统，要把哪些东西加载到内存上。这是可执行文件和不可执行文件的本质区别。\n\n# 可执行文件加载/映射到虚拟地址空间\n\n可执行文件中的LOAD页，虚拟地址空间都是按页划分的。\n\n可执行文件加载/映射到虚拟地址空间这个过程是mmap。深入理解计算机系统第9章。\n\n# 虚拟地址空间加载/映射到物理内存\n\n物理内存也是按页面划分的。\n\n虚拟地址空间加载/映射到物理内存——多级页表映射方式实现。\n\n# 程序的运行\n\n1. 创建虚拟地址空间到物理内存的映射（创建内核地址映射结构体），创建页目录和页表。\n2. 加载代码段和数据段。\n3. 把可执行文件的入口地址写入CPU寄存器中。\n\n可以执行`strace <可执行文件名>`查看可执行文件运行后所做的动作。\n\n![image-20220828091756955](../../images/计算机知识体系2022_0827/image-20220828091756955.png)\n\n可以看到，执行了execve，可想而知和我们的常识相符，一个新的程序要执行，首先要fork，之后再exec替换进程地址空间。\n\n之后，进行若干次mmap。即完成可执行文件LOAD页加载到虚拟地址空间。\n\n再之后，最终程序肯定是要跑到物理内存上运行的，尚需完成虚拟地址空间到物理内存空间的映射。--请见“Linux_地址映射”一文。\n\n# 相关书籍\n\n1. 程序员的自我修养1、2、3、4、6、10章；\n2. 深入理解计算机系统5、6、7、8、9章。\n3. 现代操作系统/操作系统精髓与设计原理\n\n* 虚拟内存\n* 进程管理以及通信\n* 网络\n* 虚拟文件系统\n","categories":["计算机知识体系"]},{"title":"Android_远程抓取设备信息上报服务","url":"/Android/Android_远程抓取设备信息上报服务/","content":"\n# 需求\n\n远程诊断，诊断信息包括基础系统信息、硬件信息、容量信息、网络信息等，兼容旧平台远程诊断逻辑和旧版本固件。\n\n前端模拟效果：\n\n![image-20220825152733320](../../images/Android_设备信息抓取/image-20220825152733320.png)\n\n| 远程诊断属性                    | 备注                                                         |\n| ------------------------------- | ------------------------------------------------------------ |\n| 光线传感器                      | 当前数值，或异常                                             |\n| 色温传感器                      | 当前数值，或异常                                             |\n| 重力传感器                      | 当前数值（x，y，z），或异常                                  |\n| 麦克风                          | 正常或异常                                                   |\n| DNS                             | 可能有多个地址。                                             |\n| 网络诊断模块 - 抖动、丢包、延时 | 可能需要参考多个地址，如果只按希沃后台来诊断，则不能判断第三方是否有问题 |\n| 网络诊断模块 - 当前局域网设备数 | 获取局域网其他设备数可能不具有参考价值，重点需要判断设备本身的网络情况 |\n\n# 设备端主要任务\n\n1. 系统版本\n2. 获取时间\n   1. 系统当前时间\n   2. 已运行时间\n   3. 上次启动时间，无直接获取的API，系统当前时间减去已运行时间即可。\n3. 感知状态\n   1. 三个传感器，异步获取其即时值。\n   2. 麦克风状态，异步检测。\n4. 硬件负载\n   1. CPU负载计算\n   2. 内存、硬盘状态信息获取\n5. 网卡信息获取\n   1. 内网IP地址\n   2. 子网掩码\n   3. MAC地址\n   4. DNS配置地址\n6. 外网信息\n   1. 外网IP地址\n   2. 运营商名称\n\n# 链路\n\n设备端服务程序常运行，监听后端IOT下发指令。设备进行一系列信息抓取、硬件检查后，doput上报。\n\n# 框架设计\n\n```kotlin\n/**\n * 约定分发规则：\n * 服务类型: key = method\n * 属性类型: key = thing.property.get#属性名 或者 thing.property.get#属性名\n */\nobject ExtHandlerManager : CoroutineScope {\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Default\n    private val serviceMap = hashMapOf<String, IServiceHandler>()\n    private val propertyMap = hashMapOf<String, IPropertyHandler>()\n    var iotClient: ICIoTClient? = null\n    \n    init {\n        //service\n        serviceMap[\"thing.service.sendDiagnosisFetchMinder\"] = SendDiagnosisFetchMinderHandler()\n    }\n    fun registerHandlers(manger: IHandlerManager?) {\n        manger?.apply {\n            for ((k, v) in serviceMap) {\n                registerServiceHandler(k, v)\n            }\n            for ((k, v) in propertyMap) {\n                registerPropertyHandler(k, v)\n            }\n            startHandle()\n        }\n    }\n\n    fun unregisterHandlers(manger: IHandlerManager?) {\n        manger?.apply {\n            for ((k, v) in serviceMap) {\n                unregisterServiceHandler(k, v)\n            }\n            for ((k, v) in propertyMap) {\n                unregisterPropertyHandler(k, v)\n            }\n        }\n    }\n}\n```\n\n## Handler接口\n\nIOT下发指令，向设备请求。设备端收到请求后，用对应的handler进行请求参数的处理。即实现onRequest方法。其中，请求可带参数，约定为json串，可下发一个taskUid，方便后续设备发送响应时回传。\n\n```kotlin\ninterface IServiceHandler {\n    fun onRequest(topic: String?, method: String?, params: String?, traceId: String?)\n}\n```\n\n接到请求后，启一个Runnable线程，线程函数里执行`DiagnosisFetchListener().sendDiagnosisFetchMinder(taskUid)`，开始进行设备信息的抓取和诊断，之后整合为json串后响应给IOT后台。\n\n```kotlin\n/**\n * RemoteDetectSystemInfoHandler\n * @Author xingchenggong 2022/08/23\n */\nclass SendDiagnosisFetchMinderHandler : IServiceHandler, CoroutineScope {\n    private val TAG = \"SendDiagnosisFetchMinderHandler\"\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Default\n    private val handler = Handler(Looper.getMainLooper())\n\n    //{\n    //    \"uid\": \"text, 32字节\"\n    //}\n    override fun onRequest(topic: String?, method: String?, params: String?, traceId: String?) {\n        Log.i(TAG, \">>> topic: $topic, method:$method, params:$params, traceId:$traceId\")\n        var taskUid: String? = null\n        if(!params.isNullOrEmpty()) {\n            taskUid = JSONObject(params).get(\"taskUid\") as String\n            val paramsAvailable = checkParamsAvailable(taskUid)\n        } else {\n            Log.e(TAG, \"DiagnosisFetch error, cause params is empty\")\n            return\n        }\n        try {\n            val diagnosisFetchInfo = Runnable { DiagnosisFetchListener().sendDiagnosisFetchMinder(taskUid) }\n            handler.post(diagnosisFetchInfo)\n        } catch (e: IllegalStateException) {\n            Log.e(TAG, \">>> onRequest:java.lang.IllegalStateException\")\n        }\n    }\n    private fun checkParamsAvailable(uid: String): Boolean {\n        var paramsAvailable = true\n        if(uid.isBlank()) {\n            Log.e(TAG, \"checkParamsAvailable failed, uid is empty\")\n            paramsAvailable = false\n        }\n        return paramsAvailable\n    }\n\n}\n```\n\n# 设备信息抓取和诊断以及之后响应后台的实现\n\n## 数据模型\n\n```kotlin\ndata class DiagnosisReportInfo(\n    val taskUid: String,\n    val diagnosisResultBo: DiagnosisFetchInfo,\n    val taskStatus: Int\n)\ndata class OuterNetInfo(\n    val ip: String,         //外网ip\n    val netOperator: String //外网运营商\n)\ndata class InnerNetInfo(\n    val ip: String,         //内网ip\n    val subNetMask: String, //子网掩码\n    val mac: String,        //网卡地址\n    val dns: List<String>   //dns\n)\ndata class DiagnosisFetchInfo(\n    val version: String,\n    val systemTime: Long,\n    val lastStartTime: Long,\n    val runningTime: Long,\n    val lightSensorData: String,\n    val colorTemperatureSensorData: String,\n    val gravitySensorData: String,\n    val microphoneState: String,\n    val cpuInfo: Float,\n    val totalMemory: Float,\n    val usageMemory: Float,\n    val totalStorage: Float,\n    val usageStorage: Float,\n    val outerNetInfo: OuterNetInfo,\n    val innerNetInfoWifi: InnerNetInfo,\n    val innerNetInfoEth: InnerNetInfo\n)\n```\n\n## 时间获取\n\n```kotlin\nimport android.os.SystemClock\n/**\n * @author: xingchenggong 2022/08/22\n */\nobject SystemTimeUtils {\n\n    fun getCurrentSystemTimestamp(): Long{\n        try {\n            return System.currentTimeMillis()\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n        return 0\n    }\n    fun getElapsedTimeMillis(): Long {\n        try {\n            return SystemClock.elapsedRealtime()\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n        return 0\n    }\n    fun getLastStartTimestamp(): Long {\n        var timestamp = getCurrentSystemTimestamp() - getElapsedTimeMillis()\n        return if(timestamp >= 0) {\n            timestamp\n        } else {\n            0\n        }\n    }\n}\n```\n\n## 传感器状态获取\n\n```java\nimport android.content.Context;\nimport android.hardware.Sensor;\nimport android.hardware.SensorEvent;\nimport android.hardware.SensorEventListener;\nimport android.hardware.SensorManager;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.os.Looper;\nimport android.os.Message;\n\nimport androidx.annotation.NonNull;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SensorUtil {\n    private SensorResultCallback mSensorResultCallback;\n    private H mHandler;\n    private Looper mLooper;\n    private SensorManager mSensorManager = null;\n    private SensorEventListener mSensorEventListener;\n    private boolean mIsAlreadyGetResult = false;\n\n    private final static int MSG_GET_SENSOR_TIME_OUT = 100;\n    private final static int MSG_GET_SENSOR_NORMAL = 101;\n    private String mSensorName;\n    public SensorUtil(String name) {\n        mSensorName = name;\n    }\n\n    public Boolean startRegisterListener(Context context, int sensorType, SensorResultCallback callback) {\n        mSensorResultCallback = callback;\n        HandlerThread thread = new HandlerThread(mSensorName);\n        thread.start();\n        mLooper = thread.getLooper();\n        mHandler = new H(mLooper);\n\n        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);\n        Sensor sensor = mSensorManager.getDefaultSensor(sensorType);\n\n        if (sensor == null) {\n            return false;\n        }\n\n        mSensorEventListener = new SensorEventListener() {\n            @Override\n            public void onSensorChanged(SensorEvent event) {\n                if (!mIsAlreadyGetResult) {\n                    mIsAlreadyGetResult = true;\n                    mHandler.removeMessages(MSG_GET_SENSOR_TIME_OUT);\n                    mHandler.removeMessages(MSG_GET_SENSOR_NORMAL);\n                    List<Float> result = new ArrayList<Float>(3);  //TODO get result\n                    int i = event.values.length;\n                    for (float val : event.values) {\n                        result.add(val);\n                    }\n                    mHandler.obtainMessage(MSG_GET_SENSOR_NORMAL, 0, 0, result).sendToTarget();\n                }\n            }\n\n            @Override\n            public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n            }\n        };\n\n        mSensorManager.registerListener(mSensorEventListener, sensor, SensorManager.SENSOR_DELAY_NORMAL);\n\n        mHandler.removeMessages(MSG_GET_SENSOR_TIME_OUT);\n        mHandler.sendEmptyMessageDelayed(MSG_GET_SENSOR_TIME_OUT, 5000);\n        return true;\n    }\n\n    private void stopListener() {\n        if (mSensorManager != null && mSensorEventListener != null) {\n            mSensorManager.unregisterListener(mSensorEventListener);\n        }\n\n        if (mLooper != null) {\n            mLooper.quitSafely();\n        }\n    }\n\n    public interface SensorResultCallback {\n        void onDataCallBack(List<Float> result);\n        void onGetDataTimeout();\n    }\n\n    private class H extends Handler {\n        private H() {\n            super();\n        }\n\n        private H(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(@NonNull Message msg) {\n            super.handleMessage(msg);\n\n            if (mSensorResultCallback == null) {\n                return;\n            }\n\n            switch (msg.what) {\n                case MSG_GET_SENSOR_NORMAL:\n                    mSensorResultCallback.onDataCallBack((List<Float>)msg.obj);\n                    break;\n                case MSG_GET_SENSOR_TIME_OUT:\n                    mSensorResultCallback.onGetDataTimeout();\n                    break;\n            }\n            stopListener();\n            mSensorResultCallback = null;\n        }\n    }\n}\n```\n\n## 麦克风检测\n\n```kotlin\nobject DeviceInfoUtils {\n    /**\n     * 判断当前设备是否是XX15\n     */\n    @JvmStatic\n    fun isXX15Model(): Boolean {\n        // XX15\n        return Build.MODEL.contains(\"XX15\")\n    }\n\n    /**\n     * 判断当前设备是否是XX02\n     */\n    @JvmStatic\n    fun isXX02Model(): Boolean {\n        // XX02\n        return Build.MODEL.contains(\"XX02\")\n    }\n}\n\nclass DetectMicUtils {\n    private val audioRecordTest by lazy {\n        AudioRecordTest()\n    }\n    private fun detectMic(): Boolean {\n        // 不同设备型号不同的检测方式\n        return if (DeviceInfoUtils.isXX15Model()) {\n            audioRecordTest.beginTest()\n        } else {\n            SystemPropertiesUtils.set(\"mic.hw.test.req\", \"1\")\n            Thread.sleep(2000L)\n            SystemPropertiesUtils.get(\"mic.hw.test.ret\", \"0\") == \"11\"\n        }\n    }\n    fun getMicState(): String {\n        return if (detectMic()) {\n            \"正常\"\n        } else {\n            \"异常\"\n        }\n    }\n}\n```\n\n```kotlin\nimport android.media.AudioFormat\nimport android.media.AudioRecord\nimport android.media.MediaRecorder\n\nclass AudioRecordTest {\n\n    private val AUDIO_INPUT = MediaRecorder.AudioSource.VOICE_RECOGNITION\n    private val AUDIO_SAMPLE_RATE = 32000\n    private val AUDIO_CHANNEL = AudioFormat.CHANNEL_IN_MONO\n    private val AUDIO_ENCODING = AudioFormat.ENCODING_PCM_16BIT\n\n    private val MAX_ALLOW_DB_BETWEEN_VALUE = 5\n    private val MIN_DB_VALUE = 3 // 只有底噪时会有 0 ~ 2db值\n    private var recordBufSize = 0\n\n    private lateinit var recordBuffer: ByteArray\n    private var mAudioRecord: AudioRecord? = null\n    private lateinit var recordBufferMic: ByteArray\n    private lateinit var recordBufferMic1: ByteArray\n    private lateinit var recordBufferMic2: ByteArray\n\n    private var isRecording = false\n    private var mErrorCounts = 0\n    private var mInValidDataCounts = 0\n    private var mValidDataCounts = 0\n\n    fun isRecordTesting():Boolean {\n        return isRecording\n    }\n\n    fun beginTest():Boolean {\n        var result = false\n\n        if (isRecording) {\n            return result\n        }\n\n        recordBufSize =\n            AudioRecord.getMinBufferSize(AUDIO_SAMPLE_RATE, AUDIO_CHANNEL, AUDIO_ENCODING)\n\n        mAudioRecord = AudioRecord(AUDIO_INPUT, AUDIO_SAMPLE_RATE, AUDIO_CHANNEL,\n            AUDIO_ENCODING, recordBufSize)\n\n        recordBuffer = ByteArray(recordBufSize)\n\n        if (recordBufSize % 4 == 0) {\n            recordBufferMic = ByteArray(recordBufSize / 2)\n            recordBufferMic1 = ByteArray(recordBufSize / 4)\n            recordBufferMic2 = ByteArray(recordBufSize / 4)\n        }\n\n        isRecording = true\n        mValidDataCounts = 0\n        mInValidDataCounts = 0\n        mErrorCounts = 0\n\n        mAudioRecord!!.startRecording()\n\n        while (isRecording) {\n            val read = mAudioRecord!!.read(recordBuffer, 0, recordBufSize)\n\n            if (read > AudioRecord.SUCCESS) {\n                try {\n                    var i = 0\n                    while (i + 7 < read) {\n                        var index = i / 2\n                        recordBufferMic[index] = recordBuffer[i]\n                        recordBufferMic[index + 1] = recordBuffer[i + 1]\n                        recordBufferMic[index + 2] = recordBuffer[i + 2]\n                        recordBufferMic[index + 3] = recordBuffer[i + 3]\n\n                        index /= 2\n\n                        recordBufferMic1[index] = recordBuffer[i]\n                        recordBufferMic1[index + 1] = recordBuffer[i + 1]\n\n                        recordBufferMic2[index] = recordBuffer[i + 2]\n                        recordBufferMic2[index + 1] = recordBuffer[i + 3]\n\n                        i += 8\n                    }\n\n                    val origDb = getPcmDB(recordBufferMic, read / 2) // 获取原始mic的分贝值\n                    val mic1Db = getPcmDB(recordBufferMic1, read / 4) // 获取mic1的分贝值\n                    val mic2Db = getPcmDB(recordBufferMic2, read / 4) // 获取mic2的分贝值\n\n                    if (origDb < 0 && mic1Db < 0 && mic2Db < 0) {\n                        if (++mInValidDataCounts >= 100) { // 大约 1s\n                            stopRecordTest()\n                            result = false\n                            break\n                        }\n                    } else if (Math.abs(origDb - mic1Db) >= MAX_ALLOW_DB_BETWEEN_VALUE\n                        || Math.abs(origDb - mic2Db) >= MAX_ALLOW_DB_BETWEEN_VALUE\n                        || mic1Db <= MIN_DB_VALUE && mic2Db <= MIN_DB_VALUE) {\n                        if (++mErrorCounts >= 10) {\n                            stopRecordTest()\n                            result = false\n                            break\n                        }\n                    } else {\n                        mInValidDataCounts = 0\n                        mErrorCounts = 0\n                        if (++mValidDataCounts >= 100) {\n                            stopRecordTest()\n                            result = true\n                        }\n                    }\n                } catch (e: Exception) {\n                    stopRecordTest()\n                    result = false\n                    e.printStackTrace()\n                }\n            } else if (read < AudioRecord.SUCCESS) {\n                stopRecordTest()\n                result = false\n            }\n        }\n\n        return result\n    }\n\n    private fun getPcmDB(pcmData: ByteArray, size: Int): Int {\n        var sum = 0.0\n        var temp: Long\n        var i = 0\n        while (i < pcmData.size) {\n            temp = (pcmData[i + 1].toLong() shl 8) or (pcmData[i].toLong() and 0x000000FF.toLong())\n            sum += Math.abs(temp).toDouble()\n            i += 2\n        }\n        return (20 * Math.log10(sum / size.toDouble())).toInt()\n    }\n\n    private fun stopRecordTest() {\n        if (!isRecording) {\n            return\n        }\n        isRecording = false\n        if (null != mAudioRecord) {\n            mAudioRecord!!.stop()\n            mAudioRecord!!.release()\n            mAudioRecord = null\n        }\n    }\n}\n```\n\n## 硬件负载情况\n\n### CPU负载\n\n```java\n    @SuppressLint({\"DefaultLocale\", \"LongLogTag\"})\n    public static float getCpuTotalUsageFloat() {\n        try {\n            double cpuIdleTimePre;\n            double cpuOccupiedTimePre;\n            double cpuIdleTimeCur;\n            double cpuOccupiedTimeCur;\n\n            ShellCommandUtils.CommandResult cpuInfoResult = ShellCommandUtils.executeCommand(\"cat /proc/stat | head -n 1\");\n            if (cpuInfoResult.result == 0) {\n                String line = cpuInfoResult.successMsg;\n                String[] cpuTimeSubInfo = line.split(\" \");\n                cpuIdleTimePre = Double.parseDouble(cpuTimeSubInfo[5]);//5:idle\n                cpuOccupiedTimePre = Double.parseDouble(cpuTimeSubInfo[2]) +//2:user\n                        Double.parseDouble(cpuTimeSubInfo[3]) +//3:nice\n                        Double.parseDouble(cpuTimeSubInfo[4]) +//4:system\n                        Double.parseDouble(cpuTimeSubInfo[6]) +//6:iowait\n                        Double.parseDouble(cpuTimeSubInfo[7]) +//7:irq\n                        Double.parseDouble(cpuTimeSubInfo[8]);//8:softirq\n            } else {\n                Log.e(TAG, \"getCpuTotalUsage: \" + cpuInfoResult.errorMsg);\n                return 0.0f;\n            }\n            try {\n                Thread.sleep(360);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            cpuInfoResult = ShellCommandUtils.executeCommand(\"cat /proc/stat | head -n 1\");\n            if (cpuInfoResult.result == 0) {\n                String line = cpuInfoResult.successMsg;\n                String[] cpuTimeSubInfo = line.split(\" \");\n                cpuIdleTimeCur = Double.parseDouble(cpuTimeSubInfo[5]);//5:idle\n                cpuOccupiedTimeCur = Double.parseDouble(cpuTimeSubInfo[2]) +//2:user\n                        Double.parseDouble(cpuTimeSubInfo[3]) +//3:nice\n                        Double.parseDouble(cpuTimeSubInfo[4]) +//4:system\n                        Double.parseDouble(cpuTimeSubInfo[6]) +//6:iowait\n                        Double.parseDouble(cpuTimeSubInfo[7]) +//7:irq\n                        Double.parseDouble(cpuTimeSubInfo[8]);//8:softirq\n            } else {\n                Log.e(TAG, \"getCpuTotalUsage: \" + cpuInfoResult.errorMsg);\n                return 0.0f;\n            }\n            double deltaCpuOccupiedTime = 100 * (cpuOccupiedTimeCur - cpuOccupiedTimePre);\n            double deltaCpuTotalTime = (cpuOccupiedTimeCur + cpuIdleTimeCur) -\n                    (cpuOccupiedTimePre + cpuIdleTimePre);\n            BigDecimal deltaCpuOccupiedTimeBigDecimal = new BigDecimal(deltaCpuOccupiedTime);\n            BigDecimal deltaCpuTotalTimeBigDecimal = new BigDecimal(deltaCpuTotalTime);\n            float cpuUsageIntValue = deltaCpuOccupiedTimeBigDecimal.divide(deltaCpuTotalTimeBigDecimal,\n                    BigDecimal.ROUND_HALF_UP).intValue();\n            return cpuUsageIntValue;\n        } catch (Exception e) {\n            e.printStackTrace();\n            Log.e(TAG, \"getCpuTotalUsage: \" + e.getMessage());\n        }\n        return 0.0f;\n    }\n```\n\n### 获取存储信息\n\n```kotlin\nimport android.annotation.SuppressLint\nimport android.app.ActivityManager\nimport android.content.Context\nimport android.content.Context.ACTIVITY_SERVICE\nimport utils.FormatterUtils.formatFromByteToGB\n\nclass SystemMemoryUtils(context: Context) {\n\n    companion object {\n        const val TAG = \"SystemStorageUtils\"\n    }\n\n    private val mContext = context\n\n    @SuppressLint(\"ServiceCast\")\n    private val mActivityManager =\n        mContext.getSystemService(ACTIVITY_SERVICE) as ActivityManager\n\n    val instance by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {\n        getCurrentSystemMemoryUsage()\n    }\n\n    fun getSystemMemoryTotalFloat(): Float {\n        try {\n            val memoryInfo = ActivityManager.MemoryInfo()\n            mActivityManager.getMemoryInfo(memoryInfo)\n            return formatFromByteToGB(memoryInfo.totalMem)\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n        return 0.0f\n    }\n\n    fun getCurrentSystemMemoryUsageFloat(): Float {\n        try {\n            val memoryInfo = ActivityManager.MemoryInfo()\n            mActivityManager.getMemoryInfo(memoryInfo)\n            return formatFromByteToGB(memoryInfo.totalMem - memoryInfo.availMem)\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n        return 0.0f\n    }\n}\n```\n\n```kotlin\nimport android.app.usage.StorageStatsManager\nimport android.content.Context\nimport android.content.Context.STORAGE_STATS_SERVICE\nimport android.os.Build\nimport android.os.storage.StorageManager\nimport androidx.annotation.RequiresApi\nimport java.io.IOException\nimport java.text.DecimalFormat\n\n@RequiresApi(Build.VERSION_CODES.O)\nclass SystemStorageUtils(context: Context) {\n    companion object{\n        const val TAG = \"SystemStorageUtils\"\n    }\n    private val mContext = context\n    private val mStorageStatsManager =\n        mContext.getSystemService(STORAGE_STATS_SERVICE) as StorageStatsManager\n\n    fun getSystemTotalStorageFloat(): Float {\n        return FormatterUtils.formatFromByteToGB(mStorageStatsManager.getTotalBytes(StorageManager.UUID_DEFAULT))\n    }\n\n    fun getCurrentSystemStorageUsageFloat(): Float {\n        try {\n            val totalStorage = mStorageStatsManager.getTotalBytes(StorageManager.UUID_DEFAULT)\n            val availableStorage = mStorageStatsManager.getFreeBytes(StorageManager.UUID_DEFAULT)\n            return FormatterUtils.formatFromByteToGB(totalStorage - availableStorage)\n        } catch (e: IOException) {\n            e.printStackTrace()\n        }\n        return 0.0f\n    }\n}\n```\n\n## 内网网卡信息获取\n\n```java\n    public static String getDeviceSpecifiedMacAddress(String NICName) {\n        if(NICName == null || NICName.isEmpty())\n        {\n            return \"\";\n        }\n        try {\n            Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n            while (enumeration.hasMoreElements()) {\n                NetworkInterface networkInterface = enumeration.nextElement();\n                if (networkInterface != null && !TextUtils.isEmpty(networkInterface.getName())) {\n                    if (networkInterface.getName().equalsIgnoreCase(NICName)) {\n                        byte[] arrayOfByte = networkInterface.getHardwareAddress();\n                        if (arrayOfByte != null && arrayOfByte.length > 0) {\n                            StringBuilder deviceMacAddress = new StringBuilder();\n                            // format the mac address\n                            for (byte b : arrayOfByte) {\n                                deviceMacAddress.append(String.format(\"%02X:\", b));\n                            }\n                            if (deviceMacAddress.length() > 0) {\n                                deviceMacAddress.deleteCharAt(deviceMacAddress.length() - 1);\n                            }\n                            return deviceMacAddress.toString();\n                        }\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            e.printStackTrace();\n            Log.e(TAG, \"getDeviceSpecifiedMacAddress: \" + e.getMessage());\n        }\n        return \"\";\n    }\n    public static String getDeviceSpecifiedIPAddress(String NICName) {\n        if(NICName == null || NICName.isEmpty())\n        {\n            return \"\";\n        }\n        String IPAddress = \"\";\n        try {\n            Enumeration<NetworkInterface> enumeration = NetworkInterface.getNetworkInterfaces();\n            while (enumeration.hasMoreElements()) {\n                NetworkInterface networkInterface = enumeration.nextElement();\n                if (networkInterface != null) {\n                    if (networkInterface.getName().equalsIgnoreCase(NICName)) {\n                        Enumeration<InetAddress> ei = networkInterface.getInetAddresses();\n                        while (ei.hasMoreElements()) {\n                            InetAddress i = ei.nextElement();\n                            if(i instanceof Inet4Address)\n                                IPAddress = i.getHostAddress();\n                        }\n                    }\n                }\n            }\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n        return IPAddress;\n    }\n    /**\n     *  Masks a raw IP address byte array with the specified prefix length.\n     */\n    public static void maskRawAddress(byte[] array, int prefixLength) {\n        if (prefixLength < 0 || prefixLength > array.length * 8) {\n            throw new RuntimeException(\"IP address with \" + array.length +\n                    \" bytes has invalid prefix length \" + prefixLength);\n        }\n\n        int offset = prefixLength / 8;\n        int remainder = prefixLength % 8;\n        byte mask = (byte)(0xFF << (8 - remainder));\n\n        if (offset < array.length) array[offset] = (byte)(array[offset] & mask);\n\n        offset++;\n\n        for (; offset < array.length; offset++) {\n            array[offset] = 0;\n        }\n    }\n    /**\n     * Get InetAddress masked with prefixLength.  Will never return null.\n     * @param address the IP address to mask with\n     * @param prefixLength the prefixLength used to mask the IP\n     */\n    public static InetAddress getNetworkPart(InetAddress address, int prefixLength) {\n        byte[] array = address.getAddress();\n        maskRawAddress(array, prefixLength);\n\n        InetAddress netPart = null;\n        try {\n            netPart = InetAddress.getByAddress(array);\n        } catch (UnknownHostException e) {\n            throw new RuntimeException(\"getNetworkPart error - \" + e.toString());\n        }\n        return netPart;\n    }\n    private static String ipv4PrefixLengthToSubnetMask(int prefixLength) {\n        try {\n            InetAddress all = InetAddress.getByAddress(\n                    new byte[]{(byte) 255, (byte) 255, (byte) 255, (byte) 255});\n            return getNetworkPart(all, prefixLength).getHostAddress();\n        } catch (UnknownHostException e) {\n            return null;\n        }\n    }\n    public static String getDeviceSpecifiedSubNetMaskFromConnectionManager(Context context, String NICName) {\n        if(NICName == null || NICName.isEmpty())\n        {\n            return \"\";\n        }\n        String subnet = \"\";\n        if (Build.VERSION.SDK_INT >= 21 && context != null) {\n            ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(context.CONNECTIVITY_SERVICE);\n            if (connectivityManager != null) {\n                for (Network network : connectivityManager.getAllNetworks()) {\n                    LinkProperties lp = connectivityManager.getLinkProperties(network);\n                    if (lp.getInterfaceName().equals(NICName))\n                    {\n                        Log.w(\"SUBNETMASK\", NICName);\n                        for (LinkAddress addr : lp.getLinkAddresses()) {\n                            if (addr.getAddress() instanceof Inet4Address) {\n                                subnet = ipv4PrefixLengthToSubnetMask(addr.getPrefixLength());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return subnet;\n    }\n\n    public static List<String> getDeviceActiveNetWorkDnsFromConnectionManager(Context context, int type) {\n        ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(context.CONNECTIVITY_SERVICE);\n        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();\n        return getDeviceSpecifiedDnsFromConnectionManager(context, activeNetworkInfo.getType());\n    }\n\n    public static List<String> getDeviceSpecifiedDnsFromConnectionManager(Context context, int type) {\n        List<String> dnsServers = new ArrayList<>();\n        if (Build.VERSION.SDK_INT >= 21 && context != null) {\n            ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(context.CONNECTIVITY_SERVICE);\n            if (connectivityManager != null) {\n                for (Network network : connectivityManager.getAllNetworks()) {\n                    NetworkInfo networkInfo = connectivityManager.getNetworkInfo(network);\n                    if (networkInfo != null && networkInfo.getType() == type) {\n                        LinkProperties lp = connectivityManager.getLinkProperties(network);\n                        for (InetAddress addr : lp.getDnsServers()) {\n                            dnsServers.add(addr.getHostAddress());\n                        }\n                    }\n                }\n            }\n        }\n        return dnsServers;\n    }\n```\n\n## 外网信息获取\n\n```java\n    @SuppressLint(\"LongLogTag\")\n    public static String getEthernetIPFromJson(String ethernetJsonStr) {\n        try {\n            if (ethernetJsonStr.isEmpty()) {\n                Log.d(TAG, \"getEthernetIPFromJson: Analysis Json is empty!\");\n                return \"NA\";\n            }\n            JSONObject jsonObject = new JSONObject(ethernetJsonStr);\n            String msg = jsonObject.getString(\"msg\");\n            if (msg.isEmpty()) {\n                Log.d(TAG, \"getEthernetIPFromJson: Analysis Json no msg tag!\");\n                return \"NA\";\n            }\n            if (!msg.equals(\"ok\")) {\n                Log.d(TAG, \"getEthernetIPFromJson: Analysis Json TAG ok failed!\");\n                return \"NA\";\n            }\n            jsonObject = jsonObject.getJSONObject(\"data\");\n            String ethernetIPFromJson = jsonObject.getString(\"ip\");\n            if (ethernetIPFromJson == null || ethernetIPFromJson.isEmpty())\n                ethernetIPFromJson = \"NA\";\n            return ethernetIPFromJson;\n        } catch (JSONException e) {\n            e.printStackTrace();\n            Log.e(TAG, \"getEthernetIPFromJson: \" + e.getMessage());\n            return \"NA\";\n        }\n    }\n\n    @SuppressLint(\"LongLogTag\")\n    public static String getEthernetOperatorFromJson(String ethernetJsonStr) {\n        try {\n            if (ethernetJsonStr.isEmpty()) {\n                Log.d(TAG, \"getEthernetIPFromJson: Analysis Json is empty!\");\n                return \"NA\";\n            }\n            JSONObject jsonObject = new JSONObject(ethernetJsonStr);\n            String msg = jsonObject.getString(\"msg\");\n            if (msg.isEmpty()) {\n                Log.d(TAG, \"getEthernetIPFromJson: Analysis Json no msg tag!\");\n                return \"NA\";\n            }\n            if (!msg.equals(\"ok\")) {\n                Log.d(TAG, \"getEthernetOperatorFromJson: Analysis Json TAG ok failed!\");\n                return \"NA\";\n            }\n            jsonObject = jsonObject.getJSONObject(\"data\");\n            return jsonObject.getString(\"operator\");\n        } catch (JSONException e) {\n            e.printStackTrace();\n            Log.e(TAG, \"getEthernetOperatorFromJson: \" + e.getMessage());\n        }\n        return \"NA\";\n    }\n```\n\n## 汇总\n\n```kotlin\nclass DiagnosisFetchListener {\n    private var mSystemVersion : String? = null\n\n    private fun getSystemVersion():String {\n        if (mSystemVersion.isNullOrEmpty()) {\n            mSystemVersion = SystemPropertiesUtils.get(BuildConfig.SYSTEM_VERSION_PROP, \"xxxOS\")\n        }\n        return mSystemVersion as String\n    }\n    //方法：thing.event.sendDiagnosisFetchMinder.post\n    //{\n    //    \"method\": \"thing.event.sendDiagnosisFetchMinder.post\",\n    //}\n    fun sendDiagnosisFetchMinder(taskUid: String) {\n        GetEthernetInfoRequestJson().getEthernetRequest(object : GetEthernetInfoRequestJson.AnalysisEthernetJson {\n            @RequiresApi(Build.VERSION_CODES.O)\n            override fun analysisEthernetFromJson(json: String) {\n                if (json.isEmpty()){\n                    Log.e(\n                        DeviceReport.TAG,\n                        \">>> analysisEthernetFromJson(): origin json string is empty, return\")\n                    return\n                }\n                val ip: String = RemoteDetectSystemInfoUtil.getEthernetIPFromJson(json)\n                val netOperator: String = RemoteDetectSystemInfoUtil.getEthernetOperatorFromJson(json)\n\n                if (ip.isEmpty() || netOperator.isEmpty()) {\n                    Log.d(DeviceReport.TAG, \">>> CIot-ext-Handler sendDiagnosisFetchMinder!! ip or netOperator is null!\")\n                }\n                val version: String = getSystemVersion()\n                //systemTime, millis\n                val systemTime: Long = SystemTimeUtils.getCurrentSystemTimestamp()\n                //lastStartTime, millis\n                val lastStartTime: Long = SystemTimeUtils.getLastStartTimestamp()\n                //runningTime, millis\n                val runningTime: Long = SystemTimeUtils.getElapsedTimeMillis()\n\n                //lightSensor\n                val lightSensorUtil = SensorUtil(\"lightSensor\")\n                var lightSensorData: String = \"\"\n                if(! lightSensorUtil.startRegisterListener(\n                        ContextHelper.getApplicationContext(),\n                        Sensor.TYPE_LIGHT, object: SensorUtil.SensorResultCallback {\n                            override fun onDataCallBack(result: List<Float>) {\n                                lightSensorData = result[0].toString() + \"lux\"\n                            }\n                            override fun onGetDataTimeout() {\n                                lightSensorData = \"超时异常\"\n                            }\n\n                        }))\n                {\n                    lightSensorData = \"获取传感器失败，可能是硬件异常\"\n                }\n                //colorTemperatureSensor\n                val colorTemperatureSensorUtil = SensorUtil(\"colorTemperatureSensor\")\n                var colorTemperatureSensorData: String = \"\"\n                if(! colorTemperatureSensorUtil.startRegisterListener(\n                        ContextHelper.getApplicationContext(),\n                        36, object: SensorUtil.SensorResultCallback {\n                            override fun onDataCallBack(result: List<Float>) {\n                                colorTemperatureSensorData = result[0].toString() + \"k\"\n                            }\n                            override fun onGetDataTimeout() {\n                                colorTemperatureSensorData = \"超时异常\"\n                            }\n\n                        }))\n                {\n                    colorTemperatureSensorData = \"获取传感器失败，可能是硬件异常\"\n                }\n                //gravitySensorData\n                val gravitySensorUtil = SensorUtil(\"gravitySensor\")\n                var gravitySensorData: String = \"\"\n                if(! gravitySensorUtil.startRegisterListener(\n                        ContextHelper.getApplicationContext(),\n                        Sensor.TYPE_ACCELEROMETER, object : SensorUtil.SensorResultCallback {\n                            override fun onDataCallBack(result: List<Float>) {\n                                gravitySensorData = \"x:\" + result[0].toString() +\n                                                    \" y:\" + result[1].toString() +\n                                                    \" z:\" + result[2].toString()\n                            }\n                            override fun onGetDataTimeout() {\n                                gravitySensorData = \"超时异常\"\n                            }\n                        }))\n                {\n                    gravitySensorData = \"获取传感器失败，可能是硬件异常\"\n                }\n                //microphoneState\n                val microphoneState: String = DetectMicUtils().getMicState()\n                // 容量情况\n                val cpuInfo: Float = RemoteDetectSystemInfoUtil.getCpuTotalUsageFloat()\n                val totalMemory: Float = SystemMemoryUtils(ContextHelper.getApplicationContext()).getSystemMemoryTotalFloat()\n                val usageMemory: Float = SystemMemoryUtils(ContextHelper.getApplicationContext()).getCurrentSystemMemoryUsageFloat()\n                val totalStorage: Float = SystemStorageUtils(ContextHelper.getApplicationContext()).getSystemTotalStorageFloat()\n                val usageStorage: Float = SystemStorageUtils(ContextHelper.getApplicationContext()).getCurrentSystemStorageUsageFloat()\n\n                // 内网情况\n                // ip, 子网掩码, mac地址, DNS(可能有多个),\n                val wlan0ip: String = RemoteDetectSystemInfoUtil.getDeviceSpecifiedIPAddress(\"wlan0\")\n                val wlan0subnetmask: String = RemoteDetectSystemInfoUtil.\n                        getDeviceSpecifiedSubNetMaskFromConnectionManager(ContextHelper.getApplicationContext(),\"wlan0\")\n                val wlan0mac: String = RemoteDetectSystemInfoUtil.getDeviceSpecifiedMacAddress(\"wlan0\")\n                val wlan0dns: List<String> = RemoteDetectSystemInfoUtil.\n                        getDeviceSpecifiedDnsFromConnectionManager(getApplicationContext(), ConnectivityManager.TYPE_WIFI)\n\n                val eth0ip: String = RemoteDetectSystemInfoUtil.getDeviceSpecifiedIPAddress(\"eth0\")\n                val eth0subnetmask: String = RemoteDetectSystemInfoUtil.\n                        getDeviceSpecifiedSubNetMaskFromConnectionManager(ContextHelper.getApplicationContext(), \"eth0\")\n                val eth0mac: String = RemoteDetectSystemInfoUtil.getDeviceSpecifiedMacAddress(\"eth0\")\n                val eth0dns: List<String> = RemoteDetectSystemInfoUtil.\n                        getDeviceSpecifiedDnsFromConnectionManager(getApplicationContext(), ConnectivityManager.TYPE_ETHERNET)\n\n                var outerNetInfo: OuterNetInfo = OuterNetInfo(ip, netOperator)\n\n                var innerNetInfoWifi: InnerNetInfo = InnerNetInfo(wlan0ip,wlan0subnetmask, wlan0mac, wlan0dns)\n\n                var innerNetInfoEth: InnerNetInfo = InnerNetInfo(eth0ip,eth0subnetmask, eth0mac, eth0dns)\n\n                val diagnosisFetchInfo = DiagnosisFetchInfo(\n                    version,\n                    systemTime,\n                    lastStartTime,\n                    runningTime,\n                    lightSensorData,\n                    colorTemperatureSensorData,\n                    gravitySensorData,\n                    microphoneState,\n                    cpuInfo,\n                    totalMemory,\n                    usageMemory,\n                    totalStorage,\n                    usageStorage,\n                    outerNetInfo,\n                    innerNetInfoWifi,\n                    innerNetInfoEth\n                )\n                val diagnosisReportInfo = DiagnosisReportInfo(taskUid, diagnosisFetchInfo, 2)\n\n                HttpHelper.getInstance().doPut(HttpConstants.updateDiagnosisPutUrl(), diagnosisReportInfo, object: Callback {\n                    override fun onFailure(call: Call, e: IOException) {\n                        Log.e(DeviceReport.TAG, \"updateDiagnosisPutUrl:response onFailure\")\n                    }\n\n                    override fun onResponse(call: Call, response: Response) {\n                        val body = response.body!!.string()\n                        try {\n                            if (response.isSuccessful && isJsonAndGetCode(body) == 0) {\n                                Log.d(DeviceReport.TAG, \"updateDiagnosisPutUrl:response $body\")\n                            } else {\n                                Log.e(DeviceReport.TAG, \"updateDiagnosisPutUrl failed ${response.code}\")\n                            }\n                        } catch (e: Exception) {\n                            Log.e(DeviceReport.TAG, e.printStackTrace().toString())\n                        }\n                    }\n                })\n            }\n        })\n    }\n    private fun isJsonAndGetCode(str: String): Int {\n        try {\n            val jsonStr = JSONObject(str)\n            if (jsonStr.has(\"code\")) {\n                Log.d(DeviceReport.TAG, \"code = \" + jsonStr.getInt(\"code\"))\n                return jsonStr.getInt(\"code\")\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n        return -1\n    }\n}\n```\n\n# 响应：doPut方法\n\n实现于HttpHelper类。\n\n```java\n    private static final String TAG = \"HttpHelper\";\n    private static final MediaType MEDIA_TYPE = MediaType.parse(\"application/json; charset=UTF-8\");\n    private static final String KEY_HEADER_APP_CODE = \"x-app-code\";\n    private static final String KEY_HEADER_APP_VERSION = \"x-app-version\";\n    private static final String KEY_HEADER_CONTENT_TYPE = \"Content-Type\";\n    private static final String KEY_HEADER_REQ_IP = \"x-req-ip\";\n    public static final String KEY_HEADER_AUTH_TOKEN = \"x-auth-token\";\n    \n\n    private Request.Builder addHeaders() {\n        // todo fix version name to xxx.xxx.xxx\n        Request.Builder builder = new Request.Builder()\n                .addHeader(\"Connection\", \"keep-alive\")\n                .addHeader(KEY_HEADER_APP_CODE, BuildConfig.DEF_APP_CODE)\n                .addHeader(KEY_HEADER_APP_VERSION, \"3.0.0\");\n        if (mToken != null) {\n            builder.addHeader(KEY_HEADER_AUTH_TOKEN, mToken);\n        }\n        return builder;\n    }\n\n    public int doPut(String url, Object src, Callback callback) {\n        return localDoPut(url, src, callback);\n    }\n\n    private int localDoPut(String url, Object src, Callback callback) {\n        String json = new Gson().toJson(src);\n        Log.d(TAG, json);\n        RequestBody requestBody = RequestBody.create(MEDIA_TYPE, json);\n        Request request = addHeaders().addHeader(KEY_HEADER_CONTENT_TYPE, \"application/json\").url(url).put(requestBody).build();\n        Call call = mOkHttpClient.newCall(request);  // 开始调用请求put\n        if (callback != null) {\n            call.enqueue(callback);\n        }\n        mId++;\n        return mId;\n    }\n```\n\n# 最终后台收到的json串\n\n```json\n{\n    \"diagnosisResultBo\": {\n        \"colorTemperatureSensorData\": \"4652.254k\",\n        \"cpuInfo\": 4.0,\n        \"gravitySensorData\": \"x:9.122001 y:-0.162 z:0.722\",\n        \"innerNetInfoEth\": {\n            \"dns\": [],\n            \"ip\": \"\",\n            \"mac\": \"\",\n            \"subNetMask\": \"\"\n        },\n        \"innerNetInfoWifi\": {\n            \"dns\": [\n                \"10.254.254.254\",\n                \"10.21.41.2\"\n            ],\n            \"ip\": \"176.20.209.204\",\n            \"mac\": \"FA:04:1B:4C:E4:99\",\n            \"subNetMask\": \"255.255.240.0\"\n        },\n        \"lastStartTime\": 1661398955912,\n        \"lightSensorData\": \"219.675lux\",\n        \"microphoneState\": \"正常\",\n        \"outerNetInfo\": {\n            \"ip\": \"172.20.209.204\",\n            \"netOperator\": \"\"\n        },\n        \"runningTime\": 11675621,\n        \"systemTime\": 1661410631533,\n        \"totalMemory\": 6.1607113,\n        \"totalStorage\": 128.0,\n        \"usageMemory\": 1.7563075,\n        \"usageStorage\": 24.85746,\n        \"version\": \"20220805_1045_userdebug_V3.0.1\"\n    },\n    \"taskStatus\": 2,\n    \"taskUid\": \"123321\"\n}\n```\n\n","categories":["Android"]},{"title":"Android_onClick","url":"/Android/Android_onClick/","content":"\n# 不同的绑定点击回调方式\n\n第一种方式：匿名函数\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.button);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                // ...\n            }\n        });\n        \n        ImageView imageView = (ImageView) findViewById(R.id.image_view);\n        imageView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                // ...\n            }\n        });\n    }\n}\n```\n\n第二种方式：继承OnClickListener接口，实现onClick函数。使组件直接绑定this。每当被点击时，统一调用onClick，里面进行case逻辑分流。依据View的id与其R.id对比进行。\n\n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n    private EditText editText;\n    private ImageView imageView;\n    private ProgressBar progressBar;\n    private static int COUNT;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.button);\n        imageView = (ImageView) findViewById(R.id.image_view);\n        progressBar = (ProgressBar) findViewById(R.id.progress_bar);\n        button.setOnClickListener(this);\n        imageView.setOnClickListener(this);\n    }\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.button:\n                if (progressBar.getVisibility() == View.GONE) {\n                    progressBar.setVisibility(View.VISIBLE);\n                } else {\n                    progressBar.setVisibility(View.GONE);\n                }\n                break;\n            case R.id.image_view:\n                if(COUNT == 1) {\n                    imageView.setImageResource(R.drawable.img_2);\n                    COUNT = 0;\n                } else {\n                    imageView.setImageResource(R.drawable.img_1);\n                    COUNT = 1;\n                }\n                break;\n            default:\n                break;\n        }\n    }\n}\n```\n\n\n","categories":["Android"]},{"title":"04_protobuf","url":"/RPC/04_protobuf/","content":"protobuf（protocol buffer）是Google的一种数据交换的格式，独立于平台语言。\nprotobuf提供了多种语言的实现：Java、C#、C++、Go和Python等，每一种实现都包含了相应语言的编译器及库文件。\n# 安装\n见《mprpc_环境配置》一篇。\n\n安装成功后，可以在命令行输入`protoc`，这是protobuf的编译命令，可通过简单的配置文件生成相应的代码。\n比如命令行的可选项：\n```bash\n  --cpp_out=OUT_DIR           Generate C++ header and source.\n  --csharp_out=OUT_DIR        Generate C# source file.\n  --java_out=OUT_DIR          Generate Java source file.\n  --js_out=OUT_DIR            Generate JavaScript source.\n  --objc_out=OUT_DIR          Generate Objective C header and source.\n  --php_out=OUT_DIR           Generate PHP source file.\n  --python_out=OUT_DIR        Generate Python source file.\n  --ruby_out=OUT_DIR          Generate Ruby source file.\n```\n## VSCode插件\n可以安装一个vscode-proto3\n# 定义消息类型 - message\n本质上，message是生成了一个公有继承于`::google::protobuf::Message`的类。\n提供了message成员变量的读写方法、（反）序列化方法。\n![](../../images/mprpc_protobuf/image-20250713011107435.png)\n\n## 示例\n\n在项目目录下创建一个test文件夹，在其中再建一个protobuf文件夹。\n\n进入文件夹，新建一个`test.proto`、`main.cc`进行测试。\n\n```protobuf\nsyntax = \"proto3\";  //声明protobuf的版本\npackage xcg;        //声明代码所在的包，相当于cpp的namespace\n\n//定义登录请求消息类型\nmessage LoginRequest\n{\n    string name = 1;//数字1不代表字符串的值，而是声明此属性为第几个字段\n    string pwd = 2;\n}\n//定义登录响应消息类型\nmessage LoginResponse\n{\n    int32 errcode = 1;//错误码\n    string errmsg = 2;//错误消息\n    bool success = 3; //标志登录是否成功\n}\n```\n\n其中的string不代表具体的某一语言当中的字符串类型，而是protobuf中的字符串类型。也就是说，protobuf中的类型只是个抽象，具体实现则看你是用哪种语言编译。\n\n属性后面的` = 1`数字1不代表字符串的值，而是声明此属性为第几个字段。\n## protobuf给属性生成的方法\n1. `set_xxx(param)`\n2. `xxx()`\n\nprotobuf生成的类都会给每一个属性提供`set_xxx(param)`和`xxx()`的方法，分别是写入、读取。\n\n## 序列化方法\n\nprotobuf生成的类有一系列的序列化方法。返回值为bool，true表示序列化成功。调用时需要用一个protobuf类对象调用。\n\n如：\n1. SerializeToString - 序列化到字符串中\n   ```cpp\n   bool SerializeToString(std::string* output) const;\n   ```\n2. SerializeToArray - 序列化到字节数组中\n   ```cpp\n   bool SerializeToArray(void * data, int size) const;\n   ```\n3. SerializeToFileDescriptor - 序列化到文件描述符\n4. SerializeToOstream - 序列化到输出流\n\n## 反序列化方法\n\nprotobuf生成的类，相应地有一系列的反序列化方法。返回值为bool，true表示反序列化成功。调用时需要用一个protobuf类对象调用。\n\n如：\n1. ParseFromString\n   ```cpp\n   inline bool ParseFromString(const std::string& data)\n   {\n       return ParseFromArray(data.data(), static_cast<int>(data.size()));\n   }\n   ```\n# protobuf的“编译”--protoc生成相应语言的代码\n\n```\nprotoc test.proto --cpp_out=./\n```\n\n其中，`--cpp_out`选项是指明生成Cpp头文件和源文件，后面带的参数指明生成的目录。格式：`--cpp_out=OUT_DIR`。\n\n相应地，也会有其他语言的选项，如`--java_out`就是生成Java源文件（Java没有头文件）；`python_out`就是生成python源文件。\n\n执行该命令，当前目录下出现：`test.pb.cc`和`test.pb.h`。\n\n其中，`test.pb.h`包含`LoginRequest`和`LoginResponse`类的定义，而且它们已经自动包含到了`xcg`的namespace。\n\n# 编写cpp文件, 使用protobuf的生成类\n\n```cpp\n// main.cc\n#include\"test.pb.h\"\n#include<iostream>\n\n#include \"test.pb.h\"\n#include <iostream>\nusing namespace xcg;\nint main()\n{\n    // 封装了login请求对象的数据\n    LoginRequest req;\n    req.set_name(\"zhang san\");\n    req.set_pwd(\"123456\");\n    // 对象数据序列化 为 字符串\n    std::string send_str;\n    if(req.SerializeToString(&send_str))\n    {\n        std::cout << send_str << std::endl;\n    }\n    // 从一个字符串反序列化到login请求对象\n    LoginRequest req2;\n    if (req2.ParseFromString(send_str))\n    {\n        std::cout << req2.name() << std::endl;\n        std::cout << req2.pwd() << std::endl;\n    }\n    return 0;\n}\n```\n编译命令：注意需要链接protobuf的库。\n```bash\ng++ main.cc test.pb.cc -lprotobuf\n```\n运行结果：\n```\n\n        zhang san123456\nzhang san\n123456\n```\n\n\n# string和bytes\n\n在编写protobuf文件中的类型时，尽量不要用string类型，而是用bytes类型，可以避免中间传输、存储字符数据时，额外的字符、字节之间的转换。因为bytes存储意味着直接以原始二进制进行存储。如果使用string，中间过程存在着字符到字节码的相互转换。\n\n比如如果存在Unicode，则使用string可能会存在存储效率不高的问题。\n```protobuf\n//定义登录请求消息类型\nmessage LoginRequest\n{\n    bytes name = 1;//数字1不代表字符串的值，而是声明此属性为第几个字段\n    bytes pwd = 2;\n}\n```\n# 三种类型\n\n1. 数据\n2. 列表（数组）\n3. 映射表（map）\n# 嵌套类中的属性方法\n如果是嵌套类，比如我们定义的ResultCode，那么这个子类的每一个属性的方法是`mutable_xxx()`，这个返回的指针是非const的。普通的`xxx()`方法返回的是const值，不可修改。\n```cpp\n#include \"test.pb.h\"\n#include <iostream>\nusing namespace xcg;\nint main()\n{\n    LoginResponse rsp;\n    ResultCode *rc = rsp.mutable_result();\n    rc->set_errcode(0);\n    rc->set_errmsg(\"登陆处理失败\");\n    GetFriendListsResponse rsp2;\n    ResultCode *rc2 = rsp2.mutable_result();\n    rc2->set_errcode(0);\n    rc2->set_errmsg(\"成功\");\n\n    User * user1 = rsp2.add_friend_list();\n    user1->set_name(\"zhang san\");\n    user1->set_age(20);\n    user1->set_sex(User::MAN);\n    User * user2 = rsp2.add_friend_list();\n    user2->set_name(\"li si\");\n    user2->set_age(22);\n    user2->set_sex(User::WOMAN);\n\n    std::cout << rsp2.friend_list_size() << std::endl;\n\n}\n```\n# 列表 - repeated\n\n```protobuf\nmessage GetFriendListsRequest\n{\n    uint32 userid = 1;\n}\nmessage GetFriendListsResponse\n{\n    int32 errcode = 1;\n    bytes errmsg = 2;\n    bool success = 3;\n}\n```\n\n> 写到此，我们发现，不同的响应类可能用到重复的属性，即errcode和errmsg，可以抽象封装为一个ResultCode类型。\n\n```protobuf\nmessage ResultCode\n{\n    int32 errcode = 1;\n    bytes errmsg = 2;\n}\n```\n于是，响应类可以改为：\n```protobuf\nmessage LoginResponse\n{\n    ResultCode result = 1;\n    bool success = 2;\n}\nmessage GetFriendListResponse\n{\n    ResultCode result = 1;\n    // ...\n    bool success;\n}\n```\n\n## User\n\n其中枚举的0和1不代表字段的顺序，而是和普通语言一样的定义方法，从0开始。\n```protobuf\nmessage User\n{\n    bytes name = 1;\n    uint32 age = 2;\n    enum Sex\n    {\n        MAN = 0;\n        WOMAN = 1;\n    }\n    Sex sex = 3;\n}\n```\n\n## GetFriendListsResponse - 使用列表存储\n列表需要使用repeated关键字代表。\n\n```protobuf\nmessage GetFriendListResponse\n{\n    ResultCode result = 1;\n    repeated User friend_list = 2; // 列表（数组）类型\n}\n```\n\n## 列表类的属性方法\n## xxx_size() - 返回列表大小\n## add_xxx() - 添加、返回一个可写元素\n可以看到，对于`repeated`类型，即列表类型，都生成了`add_xxx()`方法。往列表里增加一个空元素，并返回该元素的地址。我们可以对其进行修改。\n\n```cpp\n::xcg::User* add_friend_list();\n```\n\n## xxx(int) - 返回某下标处的只读元素\n列表类型，有一个`xxx(int)`方法。可以返回只读数据。（返回一个const引用）\n\n```cpp\nconst ::xcg::User& friend_list(int index) const;\n```\n\n用此方法结合`friend_list_size`方法，可以遍历列表中的元素。\n\n## 修改protobuf自定义类型成员的方式\n\n前面自定义了ResultCode，但是在编写cpp代码时，发现其没有生成`set_result`方法，只有`result`方法，此方法返回的是对应类型的常引用。这说明自定义的类对象统一都视为const类型。幸亏的是，还提供了一个方法是`mutable_result`方法，返回的是普通指针，可用此指针写入数据。\n\n```cpp\nconst ::xcg::ResultCode& result() const;\n::xcg::ResultCode* mutable_result();\n```\n\n所以，修改自定义类型成员的正确方式：\n\n```cpp\nint main()\n{\n    LoginResponse rsp;\n    ResultCode * resultCode = rsp.mutable_result();\n    resultCode->set_errcode(1);\n    resultCode->set_errmsg(\"登录失败\");\n}\n```\n\n# 映射表 - map\n\n```protobuf\nmessage LoginRequest\n{\n    bytes name = 1;\n    bytes pwd = 2;\n    map<int32, string> test = 3;\n}\n```\n\n# 定义描述rpc方法的类型 - service\nservice本质上是继承了`::google::protobuf::Service`类，生成了service包含的rpc方法。还提供了一个返回服务描述符的方法。\n![](../../images/mprpc_protobuf/image-20250713011313148.png)\n生成的这个UserServiceRpc类不用填参数，有默认构造。此类属于服务提供者（callee）。其中的方法都是虚函数。\n还对应生成了带`_Stub`后缀的类。继承于上面这个不带后缀的类。需要填写一个`RpcChannel*`指针作为成员变量进行构造。没有默认构造。此类属于服务调用者（caller）。由于继承的是上面这个类，其中的方法也是虚函数。\n这个`_Stub`类中的方法实现都是通过调用channel的CallMethod方法进行的，第一个参数都是`descriptor()->method(n)`，n为rpc方法的顺序号。\n这个RpcChannel类是个抽象类，其中的CallMethod是纯虚方法。\n需要我们去实现一个MyRpcChannel，并实现具体的CallMethod。\n## 前言\n在分布式框架中，最主要解决的问题就是远程过程调用。\n直白一点，server1想要调用另一个主机上server2的方法。\n不仅仅需要传请求参数，server1还需要说明自己想要调用哪个方法。总之，需要传方法名字标识、请求参数。\nprotobuf的核心功能定位在于对参数的**序列化、反序列化**。\n第二个核心功能就是，帮我们区分调用哪个方法。但是要明白的是，protobuf本身不提供任何的RPC通信功能，它只是**对方法进行描述**。\n## rpc关键字：示例\n```protobuf\nrpc 方法名(message类型) returns(message类型);\n```\n\n```protobuf\nservice UserServiceRpc\n{\n    rpc Login(LoginRequest) returns(LoginResponse);\n    rpc GetFriendList(GetFriendListRequest) returns(GetFriendListResponse);\n}\n```\n## option关键字：示例\n\n如果只是写了上面的代码，用protoc编译，默认是不会生成我们声明的所有service服务类和rpc方法描述的。\n要生成，需要在proto文件中显式声明option语句。\n\n```protobuf\noption cc_generic_services = true;\n```\n\n上面这句表示：生成所有定义的service服务类和rpc方法描述。\n\n## 服务类和rpc方法描述类\n\n经过编译链接后，新生成的`pb.h`文件中：\n\n生成了`UserServiceRpc`类、`UserServiceRpc_Stub`类。\n\n服务类，此例为`UserServiceRpc`，继承于`::google::protobuf::Service`。\n\n并且其中生成了protobuf文件中定义的自定义方法：\n\n1. `virtual void Login(...)`\n2. `virtual void GetFriendList(...)`\n\n还有获取rpc方法描述的`GetDescriptor`方法：\n\n```cpp\nconst ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();\n```\n\n该描述包括：服务的名字、服务包含的方法（包括该方法是属于哪个类的）。\n\n实际上，类似于`UserServiceRpc`这个类，在分布式框架中是callee的角色，充当RPC Service Provider，即服务提供者。\n\n## Stub类 - 继承于Service类\n\n```cpp\nclass UserServiceRpc_Stub : public UserServiceRpc\n```\n\n实际上，Stub在分布式框架中是caller，充当Service Consumer，即服务消费者。\n\n1. 带参构造函数\n   ```cpp\n   UserServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel * channel);\n   ```\n\n2. 成员变量：`::PROTOBUF_NAMESPACE_ID::RpcChannel * channel_`\n\n其次，该类也生成了protobuf文件中定义的自定义方法：\n\n1. `void Login(...)`\n2. `void GetFriendList(...)`\n\n注意，虽然没写明virtual，但因为继承于UserServiceRpc，所以同样是虚函数，只不过生成Stub类时自动实现了该函数。\n\n```cpp\nvoid UserServiceRpc::Login(::PROTOBUF_NAMESPACE_ID::RpcController* controller,\n                           const ::xcg::LoginRequest*,\n                           ::xcg::LoginResponse*,\n                           ::google::protobuf::Closure* done)\n{\n  channel_->CallMethod(descriptor()->method(0),\n                       controller, request, response, done);\n}\n\nvoid UserServiceRpc::GetFriendList(::PROTOBUF_NAMESPACE_ID::RpcController* controller,\n                                   const ::xcg::GetFriendListRequest*,\n                                   ::xcg::GetFriendListResponse*,\n                                   ::google::protobuf::Closure* done)\n{\n  channel_->CallMethod(descriptor()->method(1),\n                       controller, request, response, done);\n}\n```\n\n## RpcChannel\n\n```cpp\nclass PROTOBUF_EXPORT RpcChannel\n```\n\n在上面的Stub类中的“生成函数”中可以看到，最终调的是其构造时传入的channel对象的CallMethod方法。而RpcChannel中的CallMethod是个纯虚函数：\n\n```cpp\nvirtual void CallMethod(const MethodDescriptor* method,\n                        RpcController* controller, const Message* request,\n                        Message* response, Closure* done) = 0;\n```\n\n说明，需要自定义一个MyRpcChannel，继承于RpcChannel，并实现具体的CallMethod。在构造Stub类对象时，传入此MyRpcChannel。\n\n## 总结\n\n整个RPC框架的流程：（以完成Login举例）\n\n1. User调用`UserServiceRpc_Stub`类中的`Login`。\n2. `UserServiceRpc_Stub`类就充当中间调用者，最终调用其RpcChannel成员的具体实现的CallMethod方法。\n3. 不同的Stub的成员函数，对应着一个特定的method ID，比如Login，对应`descriptor()->method(0)`，GetFriendList，对应`descriptor()->method(1)`。\n4. 具体的method，需要Rpc Service Provider来提供，即`UserServiceRpc`类。同时，Rpc方法的具体描述也会在此类中存储。描述包括：服务的名字、服务包含的方法（包括该方法是属于哪个类的）。\n5. 最终，在远端的Server上执行该method方法。\n6. User的调用请求在远端Server处理完成后，结果就从Server进行回传。\n\n# 本地服务发布为rpc服务\n\n远端，服务的提供方，本地服务类，如何对接到rpc框架？\n\n```cpp\n#include<iostream>\n\n#include\"user.pb.h\"\n\nclass UserService : public xcg::UserServiceRpc\n{\npublic:\n    bool Login(std::string name, std::string password)\n    {   \n        std::cout << \"doing local service: Login\" << std::endl;\n        std::cout << \"name: \" << name << \", password: \" << password << std::endl;\n        return true;\n    }   \n    // Override\n    void Login(::PROTOBUF_NAMESPACE_ID::RpcController* controller,\n               const ::xcg::LoginRequest* request,\n               ::xcg::LoginResponse* response,\n               ::google::protobuf::Closure* done)\n    {   \n        // local process\n        std::string name = request->name();\n        std::string password = request->password();\n\n        bool login_result = Login(name, password);\n    \n        // response content\n        xcg::Result * result = response->mutable_result();\n        result->set_errcode(0);\n        result->set_errmsg(\"ok\");\n        response->set_success(login_result);\n\n        // callback to response\n        done->Run();\n    }   \n};\n```\n\n本地服务类，继承于UserServiceRpc，需要实现其中的`Login(...)`方法，即protobuf中定义的rpc方法描述。\n\n1. 以此作为rpc远端调用的接口；\n2. 在此接口里，进行远端参数的获取；\n3. 然后对这些参数进行本地处理；\n4. 处理后，进行响应体的填充；\n5. 调用`done->Run()`。进行回调。主要完成响应体的序列化以及发送响应（由rpc框架完成）。\n\n## Closure\n\ndone是Closure类型，此类为抽象类，内容很简单，有一个Run纯虚函数：\n\n```cpp\nclass PROTOBUF_EXPORT Closure\n{\npublic:\n    Closure() {}\n    virtual ~Closure();\n    \n    virtual void Run() = 0;\n    \nprivate:\n    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Closure);\n};\n```\n\n说明，需要先自定义一个MyClosure，具体实现Run方法逻辑，再在外部调用Login时传入此Closure指针。\n\n","categories":["项目","rpc"]},{"title":"Android_Fragment","url":"/Android/Android_Fragment/","content":"\n# 碎片\n\n碎片（Fragment）是一种可以嵌入在活动当中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用得非常广泛。虽然碎片对是全新的概念，但它和活动实在是太像了，同样都能包含布局，有自己的生命周期。甚至可以将碎片理解成一个迷你型的活动，虽然这个迷你型的活动有可能和普通的活动是一样大的。\n\n那么究竟要如何使用碎片才能充分地利用平板屏幕的空间呢？想象我们正在开发一个新闻应用，其中一个界面使用RecyclerView展示了一组新闻的标题，当点击了其中一个标题时，就打开另一个界面显示新闻的详细内容。如果是在手机中设计，我们可以将新闻标题列表放在一个活动中，将新闻的详细内容放在另一个活动中。\n\n![image-20220819172155397](../../images/Android_Fragment/image-20220819172155397.png)\n\n可是如果在平板上也这么设计，那么新闻标题列表将会被拉长至填充满整个平板的屏幕，而新闻的标题一般都不会太长，这样将会导致界面上有大量的空白区域。\n\n![image-20220819172231085](../../images/Android_Fragment/image-20220819172231085.png)\n\n因此，更好的设计方案是将新闻标题列表界面和新闻详细内容界而分别放在两个碎片中，然后在同一个活动里引入这两个碎片，这样就可以将屏幕空间充分地利用起来了，如图所示。\n\n![image-20220819172306008](../../images/Android_Fragment/image-20220819172306008.png)\n\n# 碎片的使用方式\n\n新建一个FragmentTest项目。\n\n在一个活动当中添加两个碎片，使其平分活动空间。\n\n新建一个左侧Fragment的布局`left_fragment.xml`，此布局非常简单，只放置了一个按钮，水平居中显示，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button android:id=\"@+id/button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:text=\"Button\">\n\n    </Button>\n\n</LinearLayout>\n```\n\n然后新建右侧是Fragment的布局`right_fragment.xml`，将此布局背景色设置为绿色，放置了一个TextView用于显示一段文本，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:background=\"#00ff00\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:textSize=\"20sp\"\n        android:text=\"This is right fragment\">\n    </TextView>\n\n</LinearLayout>\n```\n\n接着新建一个LeftFragment类，并让他继承自Fragment。\n\n> 注意，这里可能会有两个不同包下的Fragment供你选择，一个是系统内置的`android.app.Fragment`，一个是AndroidX库中的`androidx.fragment.app.Fragment`。这里请一定使用AndoridX库中的Fragment，因为它可以让碎片的特性在所有Android系统版本中保持一致。而系统内置的fragment在Android 9.0中已被废弃。使用AndroidX库中的Fragment并不需要在build.gradle文件中添加额外的依赖，只需在创建新项目时勾选了`Use androidx.* artifacts`选项，Android Studio会自动帮你导入必要的AndroidX库。\n\n编写一下LeftFragment中的代码，如下所示：\n\n```java\npublic class LeftFragment extends Fragment {\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.left_fragment, container, false);\n        return view;\n    }\n    \n}\n```\n\n这里仅仅是重写了Fragment的onCreateView方法，然后在这个方法中通过Layoutlnflater的inflate方法将刚才定义的left_fragment布局动态加载进来，整个方法简单明了。接着用同样的方法再新建一个 RightFragment，代码如下所示：\n\n```java\npublic class RightFragment extends Fragment {\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.right_fragment, container, false);\n        return view;\n    }\n}\n```\n\n下来修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"horizontal\"> <!-- 水平排布 -->\n    <fragment android:id=\"@+id/leftFrag\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"match_parent\"\n        android:name=\"com.example.fragmenttest.LeftFragment\"\n        android:layout_weight=\"1\">\n\n    </fragment>\n    <fragment android:id=\"@+id/rightFrag\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"match_parent\"\n        android:name=\"com.example.fragmenttest.RightFragment\"\n        android:layout_weight=\"1\">\n\n    </fragment>\n</LinearLayout>\n```\n\n可以看到，我们使用了`<fragment>`标签在布局中添加碎片，需要通过`android:name`属性来显式指明要添加的碎片类名，注意一定要将类的包名也加上。\n\n现在运行一下程序，效果如图所示。\n\n![image-20220819181016143](../../images/Android_Fragment/image-20220819181016143.png)\n\n# 动态添加碎片\n\n已经实践在布局文件中添加碎片，不过碎片真正的强大之处在于，它可以在程序运行时动态地添加到活动当中。根据具体情况来动态地添加碎片，就可以将程序界面定制得更加多样化。\n我们还是在上一节代码的基础上继续完善，新建`another_right_fragment.xml`，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:background=\"#ffff00\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:textSize=\"24sp\"\n        android:text=\"This is another right fragment\">\n        \n    </TextView>\n\n</LinearLayout>\n```\n\n这个布局文件的代码和`right_fragment.xml`中的代码基本相同，只是将背景色改成了黄色，并将显示的文字改了改。然后新建`AnotherRightFragment`作为另一个右侧碎片，代码如下所示：\n\n","categories":["Android"]},{"title":"Android_Service","url":"/Android/Android_Service/","content":"\n# 服务\n\n服务是Android中实现程序后台运行的解决方案，适合不需要和用户交互而且长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。不过需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况。\n\n# 定义一个服务\n\n新建一个ServiceTest项目，然后点击`com.example.servicetest`，`New`，`Service`，`Service`。将服务命名为`MyService`，Exported属性表示是否允许其他程序访问这个服务，Enabled属性表示是否启用这个服务。\n\n观察MyService中的代码，如下所示：\n\n```java\npublic class MyService extends Service {\n    public MyService() {\n        \n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n```\n\n可见，MyService继承自Service类。\n\nonBind方法特别醒目。这是Service中唯一的抽象方法，必须在子类中实现。\n\n既然是定义一个服务，自然应该在服务中去处理一些事情，处理事情的逻辑应该写在哪里？这时，就要重写Service中的另外的一些方法。如下：\n\n```java\npublic class MyService extends Service {\n    ...\n    @Override\n    public void onCreate() {\n        super.onCreate();\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        return super.onStartCommand(intent, flags, startId);\n    }\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n}\n```\n\n可以看到，这里我们又重写了onCreate、onStartCommand和onDestroy这3个方法，它们是每个服务中最常用到的3个方法了。其中onCreate方法会在服务创建的时候调用，onStartCommand方法会在每次服务启动的时候调用，onDestroy方法会在服务销毁的时候调用。\n\n通常情况下，如果我们希望服务一旦启动就立刻去执行某个动作，就可以将逻辑写在onStartCommand方法里。而当服务销毁时，我们又应该在onDestroy方法中去回收那些不再使用的资源。\n\n另外需要注意，每一个服务都需要在AndroidManifest.xml文件中进行注册才能生效，这是Android四大组件共有的特点。打开AndroidManifest.xml文件瞧一瞧，代码如下所示：\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.servicetest\">\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        ...\n        <service\n            android:name=\".MyService\"\n            android:enabled=\"true\"\n            android:exported=\"true\">\n        </service>\n    </application>\n</manifest>\n```\n\n这样的话，就已经将一个服务完全定义好了。Exported属性表示是否允许其他程序访问这个服务，Enabled属性表示是否启用这个服务。\n\n# 启动和停止服务\n\n定义好了服务之后，接下来就应该考虑如何去启动以及停止这个服务。启动和停止主要是借助Intent来实现。在ServiceTest项目中尝试去启动以及停止MyService这个服务。\n\n首先，修改`activity_main.xml`中的代码。我们在布局文件中加入了两个按钮，分别是用于启动服务和停止服务的。如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button\n        android:id=\"@+id/start_service\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Start Service\"/>\n    <Button\n        android:id=\"@+id/stop_service\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Stop Service\"/>\n</LinearLayout>\n```\n\n然后修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button startServiceBtn = (Button) findViewById(R.id.start_service);\n        Button stopServiceBtn = (Button) findViewById(R.id.stop_service);\n        startServiceBtn.setOnClickListener(this);\n        stopServiceBtn.setOnClickListener(this);\n    }\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.start_service:\n                Intent startIntent = new Intent(this, MyService.class);\n                startService(startIntent);\n                break;\n            case R.id.stop_service:\n                Intent stopIntent = new Intent(this, MyService.class);\n                stopService(stopIntent);\n                break;\n            default:\n                break;\n        }\n    }\n}\n```\n\n可以看到，这里在onCreate方法中分别获取到了Start Service按钮和Stop Service按钮的实例并给它们注册了点击事件。然后在Start Service按钮的点击事件里，我们构建出了一个Intent对象，并调用startService方法来启动MyService这个服务。在Stop Serivce按钮的点击事件里，我们同样构建出了一个Intent对象，并调用stopService方法来停止MyService这个服务。\n\nstartService和stopService方法都是定义在Context类中的，所以我们在活动里可以直接调用这两个方法。注意，这里完全是由活动来决定服务何时停止的，如果没有点击Stop Service按钮，服务就会一直处于运行状态。那服务有没有什么办法让自已停止下来呢？当然可以，只需要在MyService的任何一个位置调用stopSelf方法就能让这个服务停止下来了。那么接下来又有一个问题需要思考了，如何证实服务已经成功启动或者停止了呢？最简单的方法就是在MyService的几个方法中加入打印日志，如下所示：\n\n```java\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Log.d(\"MyService\", \"onCreate executed\");\n    }\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        Log.d(\"MyService\", \"onStartCommand executed\");\n        return super.onStartCommand(intent, flags, startId);\n    }\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        Log.d(\"MyService\", \"onDestroy executed\");\n    }\n```\n\n点击一下Start Service按钮，观察logcat中的打印日志。\n\n```\ncom.example.servicetest D/MyService: onCreate executed\ncom.example.servicetest D/MyService: onStartCommand executed\n```\n\nMyService中的onCreate和onStartCommand方法都执行了，说明这个服务确实已经启动成功了，并且你还可以在`Settings`，`System`，`Developer options`，`Running services`中找到ServiceTest。可以在其中停止服务。则会看到日志：\n\n```\ncom.example.servicetest D/MyService: onDestroy executed\n```\n\n由此证明，MyService确实已经成功停止下来了。话说回来，虽然我们已经学会了启动服务以及停止服务的方法，有一个疑惑，那就是onCreate方法和onStartCommand方法到底有什么区别呢？因为刚刚点击Start Service按钮后两个方法都执行了。其实onCreate方法是在服务第一次创建的时候调用的，而onStartCommand方法则在每次启动服务的时候都会调用，由于刚才我们是第一次点击Start Service按钮，服务此时还未创建（Create）过，所以两个方法都会执行，之后再连续多点击几次Start Service按钮，会发现只有onStartCommand得到执行。\n\n# 活动和服务进行通信 - onBind\n\n了解了启动和停止服务的方法，虽然服务是在活动里启动的，但在启动了服务之后，活动与服务基本就没有什么关系了。之后服务会一直处于运行状态，但具体运行的是什么逻辑，活动就控制不了了。这就类似于活动通知了服务一下：你可以启动了！然后服务就去忙自己的事情了，但活动并不知道服务到底去做了什么事情，以及完成得如何。\n\n那么有没有什么办法能让活动和服务的关系更紧密一些呢，这就需要借助我们刚刚忽略的onBind方法了。\n\n比如说，目前我们希望在MyService里提供一个下载功能，然后在活动中可以决定何时开始下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的Binder对象来对下载功能进行管理，修改MyService中的代码，如下所示：\n\n```java\npublic class MyService extends Service {\n    \n    private DownloadBinder mBinder = new DownloadBinder();\n    class DownloadBinder extends Binder {\n        public void startDownload() {\n            Log.d(\"MyService\", \"startDownload executed\");\n        }\n        public int getProgress() {\n            Log.d(\"MyService\", \"getProgress executed\");\n            return 0;\n        }\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        return mBinder;\n    }\n    \n    ...\n}\n```\n\n可以看到，这里我们新建了一个DownLoadBinder类，并让它继承自Binder，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功能，我们在这两个方法中分别打印了一行日志。\n\n接着，MyService中创建了DownloadBinder的实例，然后在onBind方法里返回了这个实例，这样MyService中的工作就全部完成了。\n\n下面就要看一看，在活动中如何去调用服务里的这些方法了。首先需要在布局文件里新增两个按钮，修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n    <Button android:id=\"@+id/bind_service\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"match_parent\"\n        android:text=\"Bind Service\"/>\n    <Button android:id=\"@+id/unbind_service\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Unbind Service\"/>\n```\n\n这两个按钮分别是用于活动绑定服务和活动取消绑定服务的，当一个活动和服务绑定了之后，就可以调用该服务里的Binder提供的方法了。修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n\n    private MyService.DownloadBinder downloadBinder;\n    private ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            downloadBinder = (MyService.DownloadBinder) service;\n            downloadBinder.startDownload();\n            downloadBinder.getProgress();\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // ...\n        Button bindService = (Button) findViewById(R.id.bind_service);\n        Button unbindService = (Button) findViewById(R.id.unbind_service);\n        bindService.setOnClickListener(this);\n        unbindService.setOnClickListener(this);\n    }\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            // ...\n            case R.id.bind_service:\n                Intent bindIntent = new Intent(this, MyService.class);\n                bindService(bindIntent, connection, BIND_AUTO_CREATE);\n                break;\n            case R.id.unbind_service:\n                unbindService(connection);\n                break;\n            default:\n                break;\n        }\n    }\n}\n```\n\n这里首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected方法和onServiceDisconnected方法，这两个方法分别会在活动与服务成功绑定以及活动与服务的连接取消绑定的时候调用。在onServiceConnected方法中，我们又通过向下转型得到了DownloadBinder的实例，有了这个实例，活动和服务之间的关系就变得非常紧密了。现在我们可以在活动中根据具体的场景来调用DownloadBinder中的任何public方法，即实现了指挥服务干什么服务就去干什么的功能。这里仍然只是做了个简单的测试，在onServiceConnected方法中调用了DownloadBinder的startDownload和getProgress方法。\n\n当然，现在活动和服务其实还没进行绑定呢，这个功能是在Bind Service按钮的点击事件里完成的。可以看到，这里我们仍然是构建出了一个Intent对象，然后调用bindService方法将MainActivity和 MyService进行绑定。\n\nbindService方法接收3个参数，第一个参数就是构建出的Intent对象，第二个参数是前面创建出的ServiceConnection的实例，第三个参数则是一个标志位，这里传入`BIND_AUTO_CREATE`表示在活动和服务进行绑定后自动创建服务。这会使得MyService中的onCreate方法得到执行，**但onStartCommand方法不会执行**。\n\n然后如果我们想解除活动和服务之间的绑定，调用一下unbindService方法就可以了，这也是Unbind Service按钮的点击事件里实现的功能。但是解除绑定不会结束服务。\n\n点击一下 Bind Service按钮，然后观察logcat中的打印日志。\n\n```\ncom.example.servicetest D/MyService: onCreate executed\ncom.example.servicetest D/MyService: startDownload executed\ncom.example.servicetest D/MyService: getProgress executed\n```\n\n可以看到，首先是MyService的onCreate方法得到了执行，然后startDownload和getProgress方法都得到了执行，说明确实已经在活动里成功调用了服务里提供的方法了。\n\n另外需要注意，任何一个服务在整个应用程序范围内都是通用的，即MyService不仅可以和MainActivity绑定，还可以和任何一个其他的活动进行绑定，而且在绑定完成后它们都可以获取到相同的DownloadBinder实例。\n\n# 服务的生命周期\n\n前面使用到的onCreate、onStartCommand、onBind和onDestroy等方法都是在服务的生命周期内可能回调的方法。\n\n一旦在项目的任何位置调用了Context的startService方法，相应的服务就会启动起来，并回调onStartCommand方法。如果这个服务之前还没有创建过，onCreate方法会先于onStartCommand方法执行。服务启动了之后会一直保持运行状态，直到 stopService或stopSelf方法被调用。\n\n注意，虽然每调用一次startService方法，onStartCommand就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次startService方法，只需调用一次stopService或stopSelf方法，服务就会停止下来了。\n\n另外，还可以调用Context的bindService来获取一个服务的持久连接，这时就会回调服务中的onBind方法。类似地，如果这个服务之前还没有创建过，onCreate方法会先于onBind方法执行。之后，调用方可以获取到onBind方法里返回的IBinder对象的实例，这样就能自由地和服务进行通信了。只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态。\n\n当调用了startService方法后，又去调用stopService方法，这时服务中的onDestroy方法就会执行，表示服务已经销毁了。\n\n但是需要注意，我们是完全有可能对一个服务既调用了startService方法，又调用了bindService方法的，这种情况下该如何才能让服务销毁掉呢？根据Android系统的机制，一个服务只要被启动或者被绑定了之后，就会一直处于运行状态，**必须要让以上两种条件同时不满足，服务才能被销毁**。所以，这种情况下要同时调用stopService和unbindService方法，onDestroy方法才会执行。\n\n实测，当bind之后，直接点击stopservice不会调用destroy。如果点击了stopservice之后，只要unbind，就会立即destroy。可参阅：https://blog.csdn.net/qq_30591155/article/details/105200843\n\n这样就已经把服务的生命周期完整地走了一遍。\n\n# 前台服务\n\n","categories":["Android"]},{"title":"03_mprpc_环境配置","url":"/RPC/03_mprpc_环境配置/","content":"环境：Linux、muduo库安装、protobuf库安装、XShell（远程连接）、VSCode\n# 项目目录组织\n\n略\n# protobuf简介\n\nprotobuf是Google创始的一种数据交换的格式，独立与平台语言。\n\n提供了多种语言的实现。每一种实现都包含了相应语言的编译器以及库文件。\n\n由于它是一种二进制的格式，比xml、json快。\n\n很适合用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于网络传输、配置文件、数据存储等诸多领域。\n\n# 安装配置\n\n在github源代码下载地址：https://github.com/google/protobuf\n\n源码包中的`src/README.md`，有详细的安装说明，安装过程如下：\n\n1. 解压压缩包：`unzip protobuf-master.zip`\n2. 进入解压后的文件夹：`cd protobuf-master`\n3. 安装所需工具：`sudo apt install autoconf automake libtool curl`\n4. 自动生成configure配置文件：`./autogen.sh`\n5. 配置环境：`./configure`\n6. 编译源代码(时间比较长)：make\n7. 安装：sudo make install\n8. 刷新动态库：sudo ldconfig\n\n安装成功后，命令行输入protoc，能出来信息。\n# 远程连接SSH\n见其他篇。\n# git管理\n在代码目录中，git init。从0开始就用git管理。\n```bash\ngit init\ngit checkout -b dev #创建一个新分支并切换到它\n```\ndev表示开发分支，不是成熟的代码，可当作练习的环境。\n","categories":["项目","rpc"]},{"title":"Android_UI","url":"/Android/Android_UI/","content":"\n# 如何编写程序界面\n\nAndroid中有多种编写程序界面的方式可供选择。Android Studio和Eclipse中都提供了相应的可视化编辑器，允许使用拖放控件的方式来编写布局，并能在视图上直接修改控件的属性。不过并不推荐使用这种方式来编写界面，因为可视化编辑工具并不利于去真正了解界面背后的实现原理。通过这种方式制作出的界面通常不具有很好的屏幕适配性，而且当需要编写较为复杂的界面时可视化编辑工具将很难胜任。\n\n因此所有的界面都将通过最基本的方式去实现，即编写XML代码。完全掌握了使用XML来编写界面的方法之后，不管是进行高复杂度的界面实现，还是分析和修改当前现有界面，都将是手到擒来。讲了这么多理论的东西，也是时候学习一下到底如何编写程序界面了，下面就从Android中几种常见的控件开始。\n\n# 常用控件的使用方法\n\nAndroid提供了大量的UI控件，合理地使用这些控件就可以非常轻松地编写出相当不错的界面，下面我们就挑选几种常用的控件，详细介绍一下它们的使用方法。\n\n首先新建一个UIWidgetTest项目，简单起见，我们还是允许Android Studio自动创建活动。活动名和布局名都使用默认值。\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/text_view\"\n        android:gravity=\"center\"\n        android:textSize=\"24sp\"\n        android:textColor=\"#00ff00\"\n        android:text=\"This is TextView\">\n\n    </TextView>\n    <Button android:id=\"@+id/button\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:textAllCaps=\"false\"\n        android:text=\"Button\">\n\n    </Button>\n    <EditText android:id=\"@+id/edit_text\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\">\n\n    </EditText>\n</LinearLayout>\n```\n\nAndroid控件的使用规律：用法基本上都很相似，给控件定义一个id，再指定控件的宽度和高度，然后再适当加入一些控件特有的属性就差不多了。所以使用XML来编写界面其实一点都不难，完全可以不用借助任何可视化工具来实现。\n\n一些做得比较人性化的软件会在输入框里显示一些提示性的文字，然后一旦用户输入了任何内容，这些提示性的文字就会消失。这种提示功能在Android里是非常容易实现的，我们甚至不需要做任何的逻辑控制，因为系统已经帮我们都处理好了。修改`activity_main.xml`，如下所示：\n\n```xml\n    <EditText android:id=\"@+id/edit_text\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"Type something here\">\n        <!-- 这里使用android:hint 属性指定了一段提示性的文本 -->\n    </EditText>\n```\n\n# 3种基本布局\n\n一个丰富的界面总是要由很多个控件组成的，那如何才能让各个控件都有条不紊地摆放在界面上，而不是乱糟糟的呢？这就需要借助**布局**来实现了。布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面。当然，布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套，我们就能够完成一些比较复杂的界面实现。\n\n准备工作：新建一个UILayoutTest项目。\n\n## 线性布局\n\nLinearLayout又称作线性布局。\n\n这个布局会将他所包含的控件在线性方向上依次排列。\n\n### 排列方向：orientation\n\n`android:orientation`属性指定了排列方向。若指定`vertical`则会在垂直方向排列，如果指定的是horizontal则会在水平方向排列。如果不指定`android:orientation`属性的值，默认的排列方向就是`horizontal`。\n\n如果LinearLayout的排列方向是horizontal，内部的控件就绝对不能将`宽度`指定为`match_parent`，因为这样的话，单独一个控件就会将整个水平方向占满，其他的控件就没有可放置的位置了。同样的道理，如果LinearLayout的排列方向是vertical，内部的控件就不能将`高度`指定为`match_parent`。\n\n### 对齐方式：layout_gravity\n\n`android:layout_gravity`属性，和`android:gravity`属性看起来有些相似，这两个属性有什么区别呢？其实从名字就可以看出，`android:gravity`用于指定文字在控件中的对齐方式，而`android:layout_gravity`用于指定控件在布局中的对齐方式。`android:layout_gravity`的可选值和`android:gravity`差不多，但是需要注意，当LinearLayout的排列方向是`horizontal`时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同样的道理，当LinearLayout的排列方向是`vertical`时，只有水平方向上的对齐方式才会生效。`layout_gravity`支持的选项：`center_vertical`、`center`、`bottom`、`center_horizontal`、`clip_horizontal`、`clip_vertical`、`end`、`fill`、`fill_horizontal`、`fill_vertical`、`left`、`right`、`start`、`top`。\n\n修改`activity_main.xml`中的代码：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button android:id=\"@+id/button1\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_gravity=\"top\"\n        android:text=\"Button 1\">\n    </Button>\n    <Button android:id=\"@+id/button2\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_gravity=\"center_vertical\"\n        android:text=\"Button 1\">\n    </Button>\n    <Button android:id=\"@+id/button3\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_gravity=\"bottom\"\n        android:text=\"Button 1\">\n    </Button>\n\n</LinearLayout>\n```\n\n![image-20220816142157513](../../images/Android_UI/image-20220816142157513.png)\n\n### 比例占位：layout_weight\n\n此属性允许我们使用比例的方式来指定控件的大小，它在手机屏暮的适配性方面可以起到非常重要的作用。比如我们正在编写一个消息发送界面、需要一个文本编辑框和一个发送按钮，修改`activity_main.xml`中的代码、如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <EditText android:id=\"@+id/input_message\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:hint=\"Type something\">\n        \n    </EditText>\n    <Button android:id=\"@+id/send\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:text=\"Send\">\n        \n    </Button>\n\n</LinearLayout>\n```\n\n这里将EditText和Button的宽度都指定成了`0dp`，这样文本编辑框和按钮还能显示出来吗？不用担心，由于使用了`android:layout_weight`属性，此时控件的宽度就不应该再由`android:layout_width`来决定，这里指定成`0dp`是一种比较规范的写法。在EditText和Button里都将`android:layout_weight`属性的值指定为1。这表示EditText和Button将在水平方向平分宽度。\n\n> dp是Android中用于指定控件大小、间距等属性的单位。\n\n为什么将`android:layout_weight`属性的值同时指定为1就会平分屏幕宽度呢？其实原理也很简单，系统会先把LinearLayout下所有控件指定的`layout_weight`值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的`layout_weight`值除以刚才算出的总值。因此如果想让EditText占据屏幕宽度的3/5。Button占据屏幕宽度的2/5，只需要将EditText的`layout_weight`改成3，Button的`layout_weight`改成2就可以了。\n\n![image-20220816143444781](../../images/Android_UI/image-20220816143444781.png)\n\n我们还可以通过指定部分控件的`layout_weight`值来实现更好的效果。修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <EditText android:id=\"@+id/input_message\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:hint=\"Type something\">\n    </EditText>\n    <Button android:id=\"@+id/send\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Send\">        \n    </Button>\n        \n</LinearLayout>\n```\n\n这里我们仅指定了EditText的`android:layout_weight`属性，并将Button的宽度改回`wrap_content`。这表示Button的宽度仍然按照`wrap_content`来计算，而EditText则会占满屏幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且看起来也更加舒服。\n\n![image-20220816144347201](../../images/Android_UI/image-20220816144347201.png)\n\n## 相对布局\n\nRelativeLayout又称作相对布局，也是一种非常常用的布局。和LinearLayout的排列规则不同，RelativeLayout显得更加随意一些，它可以通过相对定位的方式让控件出现在布局的任何位置。也正因为如此，RelativeLayout中的属性非常多，不过这些属性都是有规律可循的，其实并不难理解和记忆。\n\n### 相对于parent\n\n修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:text=\"Button 1\">\n\n    </Button>\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentLeft=\"true\"\n        android:layout_alignParentBottom=\"true\"\n        android:text=\"Button 2\">\n\n    </Button>\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\"\n        android:text=\"Button 3\">\n\n    </Button>\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentRight=\"true\"\n        android:layout_alignParentTop=\"true\"\n        android:text=\"Button 4\">\n\n    </Button>\n    <Button\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentRight=\"true\"\n        android:layout_alignParentBottom=\"true\"\n        android:text=\"Button 5\">\n\n    </Button>\n</RelativeLayout>\n```\n\n以上代码已经不需要再做过多解释了，因为实在是太好理解了。我们让`Button1`和父布局的左上角对齐，`Button2`和父布局的右上角对齐，`Button3`居中显示，`Button4`和父布局的左下角对齐，`Button5`和父布局的右下角对齐。虽然`android:layout_alignParentLeft`、`android:Layout alignParentTop`、`android:layout_alignParentRight`、`android:layout_alignParentBottom`、`android:layout_centerInParent`这几个属性我们之前都没接触过，可是它们的名字已经完全说明了它们的作用。\n\n![image-20220816145421370](../../images/Android_UI/image-20220816145421370.png)\n\n### 相对于控件\n\n上面例子中的每个控件都是相对于父布局进行定位的，那控件可不可以相对于控件进行定位呢？当然是可以的，修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button android:id=\"@+id/button3\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\"\n        android:text=\"Button 3\">\n    </Button>\n    <Button android:id=\"@+id/button1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_above=\"@id/button3\"\n        android:layout_toLeftOf=\"@id/button3\"\n        android:text=\"Button 1\">\n    </Button>\n    <Button android:id=\"@+id/button2\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_above=\"@id/button3\"\n        android:layout_toRightOf=\"@id/button3\"\n        android:text=\"Button 2\">\n    </Button>\n    <Button android:id=\"@+id/button4\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@id/button3\"\n        android:layout_toLeftOf=\"@id/button3\"\n        android:text=\"Button 4\">\n    </Button>\n    <Button android:id=\"@+id/button5\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@id/button3\"\n        android:layout_toRightOf=\"@id/button3\"\n        android:text=\"Button 5\">\n    </Button>\n</RelativeLayout>\n```\n\n这次的代码稍微复杂一点，不过仍然是有规律可循的。`android:layout_above`属性可以让一个控件位于另一个控件的上方，需要为这个属性指定相对控件id的引用，这里我们填入了`@id/button3`，表示让该控件位于Button3的上方。其他的属性也都是相似的，`android:layout_below`表示让一个控件位于另一个控件的下方，`android:layout_toLeftOf`表示让一个控件位于另一个控件的左侧，`android:layout_toRightOf`表示让一个控件位于另一个控件的右侧。\n\n> 注意，当一个控件去引用另一个控件的id时，该控件一定要定义在引用控件的后面，不然会出现找不到id的情况。\n\n![image-20220816152848133](../../images/Android_UI/image-20220816152848133.png)\n\nRelativeLayout中还有另外一组相对于控件进行定位的属性，`android:layout_alignLeft`表示让一个控件的左边缘和另一个控件的左边缘对齐，`android:layout_alignRight`表示让一个控件的右边缘和另一个控件的右边缘对齐。此外，还有`android:layout_alignTop`和`android:layout_alignBottom`，道理都是一样的。\n\n## 帧布局\n\nFrameLayout又称作帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景也少了很多。这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"This is Text View\">\n    </TextView>\n    <ImageView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:src=\"@mipmap/ic_launcher\">\n    </ImageView>\n\n</FrameLayout>\n```\n\nFrameLayout中只是放置了一个TextView和一个ImageView。需要注意的是，当前项目我们没有准备任何图片，所以这里ImageView直接使用了mipmap来访问`ic_launcher`这张图。\n\n![image-20220816153957404](../../images/Android_UI/image-20220816153957404.png)\n\n可以看到，文字和图片都是位于布局的左上角。由于ImageView是在 TextView之后添加的，因此图片压在了文字的上面。当然除了这种默认效果之外，我们还可以使用`layout_gravity`属性来指定控件在布局中的对齐方式，这和LinearLayout中的用法是相似的。修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"left\"\n        android:text=\"This is Text View\">\n    </TextView>\n    <ImageView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"right\"\n        android:src=\"@mipmap/ic_launcher\">\n    </ImageView>\n\n</FrameLayout>\n```\n\n我们指定TextView在FrameLayout中居左对齐，指定ImageView在FrameLayout中居右对齐。\n\n![image-20220816154415718](../../images/Android_UI/image-20220816154415718.png)\n\n总体来讲，FrameLayout由于定位方式的欠缺，导致它的应用场景也比较少，不过在用碎片的时候我们还是可以用到它的。\n\n# 自定义控件\n\n前面没有关注控件和布局的继承结构。\n\n我们所用的所有**控件**都是直接或间接继承自View的，所用的所有**布局**都是直接或间接继承自ViewGroup的。View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础之上又添加了各自特有的功能。而ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup。是一个用于放置控件和布局的容器。\n\n当系统自带的控件并不能满足我们的需求时，可以利用上面的继承结构来创建自定义控件呢。有两种简单方法创建自定义控件。\n\n先将准备工作做好，创建一个UICustomViews项目。\n\n## 引入布局\n\n如果用过iPhone应该会知道，几乎每一个iPhone应用的界面顶部都会有一个标题栏，标题栏上会有一到两个按钮可用于返回或其他操作（iPhone没有实体返回键）。现在很多Android程序也都喜欢模仿iPhone的风格，在界面的顶部放置一个标题栏。虽然Android系统已经给每个活动提供了标题栏功能，但这里我们决定先不使用它，而是创建一个自定义的标题栏。\n\n经过前面的知识，创建一个标题栏布局不是什么困难的事情了，只需要加入两个Button和一个TextView，然后在布局中摆放好就可以了。可是这样做却存在着一个问题，一般我们的程序中可能有很多个活动都需要这样的标题栏，如果在每个活动的布局中都编写一遍同样的标题栏代码，明显就会导致代码的大量重复。这个时候我们就可以使用**引入布局**的方式来解决这个问题，新建一个布局`title.xml`，代码如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"@drawable/title_bg\">\n    <Button\n        android:id=\"@+id/title_back\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_margin=\"5dp\"\n        android:background=\"@drawable/back_bg\"\n        android:text=\"Back\"\n        android:textColor=\"#fff\">\n        \n    </Button>\n    <TextView\n        android:id=\"@+id/title_text\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_weight=\"1\"\n        android:gravity=\"center\"\n        android:text=\"Title Text\"\n        android:textColor=\"#fff\"\n        android:textSize=\"24sp\">\n        \n    </TextView>\n    <Button\n        android:id=\"@+id/title_edit\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:layout_margin=\"5dp\"\n        android:background=\"@drawable/edit_bg\"\n        android:text=\"Edit\"\n        android:textColor=\"#fff\">\n        \n    </Button>\n</LinearLayout>\n```\n\n可以看到，我们在LinearLayout中分别加入了两个Button和一个TextView，左边的Button可用于返回，右边的Button可用于编辑，中间的TextView则可以显示一段标题文本。上面代码中的大多数属性都是你已经见过的，下面我来说明一下几个之前没有讲过的属性。`android:background`用于为布局或控件指定一个背景，可以使用颜色或图片来进行填充，这里提前准备3张图片`title_bg.png`、`back_bg.png`和`edit_bg.png`，分别用于作为标题栏、返回按钮和编辑按钮的背景。另外，在两个Button中都使用 `android:layout_marqin`这个属性，它可以指定控件在上下左右方向上偏移的距离，当然也可以使用`android:layout_marginLeft`或`android:layout_marginTop`等属性来单独指定控件在某个方向上偏移的距离。现在标题栏布局已经编写完成了，剩下的就是如何在程序中使用这个标题栏了，修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    \n    <include layout=\"@layout/title\"/>\n    \n</LinearLayout>\n```\n\n只需要通过一行include语句将标题栏布局引入进来就可以了。\n\n最后别忘了在MainActivity中将系统自带的标题栏隐藏掉，代码如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            actionbar.hide();\n        }\n    }\n}\n// 这里调用了getSupportActionBar方法来获得ActionBar的实例，然后再调用ActionBar的hide方法将标题栏隐藏起来。\n```\n\n![image-20220816163052927](../../images/Android_UI/image-20220816163052927.png)\n\n## 创建自定义控件\n\n引入布局的技巧确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。新建TitleLayout继承自LinearLayout，让它成为我们自定义的标题栏控件，代码如下所示：\n\n```java\npublic class TitleLayout extends LinearLayout {\n    public TitleLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        LayoutInflater.from(context).inflate(R.layout.title, this);\n    }\n}\n```\n\n首先我们重写了LinearLayout中带有两个参数的构造函数，在布局中引入TitleLayout控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借助`LayoutInflater`来实现了。通过Layoutlnflater的from方法可以构建出一个LayoutInflater对象，然后调用inflate方法就可以动态加载一个布局文件，inflate方法接收两个参数，第一个参数是要加载的布局文件的id，这里我们传入 `R.layout.titel`，第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为TitleLayout，于是直接传入this。现在自定义控件已经创建好了，然后我们需要在布局文件中添加这个自定义控件，修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <com.example.uicustomviews.TitleLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"/>\n\n</LinearLayout>\n```\n\n添加自定义控件和添加普通控件的方式基本是一样的，只不过**在添加自定义控件的时候需要指明控件的完整类名**，包名在这里是不可以省略的。重新运行程序，会发现此时效果和使用引入布局方式的效果是一样的。下面尝试为标题栏中的按钮注册点击事件，修改TitleLayout中的代码，如下所示：\n\n```java\npublic class TitleLayout extends LinearLayout {\n    public TitleLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        LayoutInflater.from(context).inflate(R.layout.title, this);\n        Button titleBack = (Button) findViewById(R.id.title_back);\n        Button titleEdit = (Button) findViewById(R.id.title_edit);\n        titleBack.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                ((Activity) getContext()).finish();\n            }\n        });\n        titleEdit.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Toast.makeText(getContext(), \"You clicked Edit button\",\n                        Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n}\n```\n\n如此一来，原有的标题栏布局在MainActivity中隐藏，后来的自定义标题栏在TitleLayout.java中动态加载。\n\n![image-20220816170200744](../../images/Android_UI/image-20220816170200744.png)\n\n首先还是通过`findViewById`方法得到按钮的实例，然后分别调用setOnClickListener方法给两个按钮注册了点击事件，当点击返回按钮时销毁掉当前的活动，当点击编辑按钮时弹出一段文本。\n\n这样的话，每当我们在一个布局中引入TitleLayout时，返回按钮和编辑按钮的点击事件就已经自动实现好了，这就省去了很多编写重复代码的工作。\n","categories":["Android"]},{"title":"02_RPC通信原理","url":"/RPC/02_RPC通信原理/","content":"# RPC通信原理\n\nremote procedure call，远程过程调用。分布式通信靠此实现。也是分布式通信底层要解决的问题。\n\n# 整体流程\n\nrpc方法名字，参数。参数一般需要打包。\n\n从caller端的User到RPCRuntime，中间需要序列化的流程，即把参数打包的流程。序列化之后就可以通过网络传到远端另外的机器。网络可以选用muduo网络库。\n\ncaller端\n\n1. User - **用户可见**\n   1. local call - **用户可见**\n2. User-stub\n   1. pack argument\n3. RPCRuntime\n   1. transmit\n   2. wait\n\n远端callee端接收到RPC请求之后，从网络底层上报上来，需要把打包的参数进行解析，即反序列化为具体的信息，比如方法的标识、参数。传递到进程中执行某个函数。\n\ncallee端\n\n1. RPCRuntime\n   1. receive\n2. Server-stub\n   1. unpack argument\n3. Server - **服务器可见**\n   1. call - **服务器可见**\n   2. work（执行函数） - **服务器可见**\n   3. return - **服务器可见**\n\n远端callee返回结果时，需要pack result，给结果内容打包，序列化。传送给caller。\n\n1. Server\n   1. return\n2. Server-stub\n   1. pack result\n3. RPCRuntime\n   1. transmit\n\ncaller端收到返回包后，唤醒，反序列化，解析为unpack result，生成本地对象。\n\n1. RPCRuntime\n   1. receive\n2. User-stub\n   1. unpack result\n3. User - **用户可见**\n   1. local return - **用户可见**\n\n我们RPC框架要实现的东西，除了标识的用户可见、服务器可见的地方之外，都要实现并封装。\n\n![image-20220815205906401](../../images/RPC通信原理/image-20220815205906401.png)\n\n黄色部分：设计rpc方法参数的打包和解析， 也就是数据的序列化和反序列化， **使用Protobuf**。此部分称之为stub，意思是桩，是一个代理类的角色。\n\n绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，**使用muduo网络库和zookeeper服务配置中心**（专门做服务发现）。\n\nmprpc框架主要包含以上两个部分的内容。\n\n# 序列化、反序列化工具\n\n用protobuf。\n\nprotobuf是二进制存储的。相比于xml、json的文本存储形式来说，\n1. 二进制存储有节省空间的优点。在同等网络环境下，性能更优。\n2. protobuf不需要存储额外的信息，而json存储的是key-value。protobuf只存储值数据。\n\n可能的形式：\nJson：\n```json\nname: \"zhang san\",\npwd: \"123456\"\n```\nProtobuf：\n```protobuf\n\"zhangsan\"\"123456\"\n```","categories":["项目","rpc"]},{"title":"git_各种切换分支_回退","url":"/git/git_各种切换分支_回退/","content":"\n参考文章：一文讲透 Git 底层数据结构和原理 - 阿里开发者的文章 - 知乎 https://zhuanlan.zhihu.com/p/142289703\n\n![image-20220815154815483](../../images/Linux_git_add/image-20220815154815483.png)\n\n# 简要说明\n\n| 命令     | 描述                                          |\n| -------- | --------------------------------------------- |\n| checkout | Switch branches or restore working tree files |\n| reset    | Reset current HEAD to the specified state     |\n| revert   | Revert some existing commits                  |\n| rebase   | Reapply commits on top of another base tip    |\n| switch   | Switch branches                               |\n| restore  | Restore working tree files                    |\n\n可以看出，checkout实际上是switch和restore的结合。\n\n# 对应的场景\n\n## checkout\n\n两个作用，一是切换分支，二是恢复工作区代码。如果checkout相同分支，则作用就是恢复工作区代码。因此，可以作用于，想要把未add的代码恢复到最新commit的状态。\n\n## reset\n\n1. `git reset --mixed`：此为默认方式，等同于不带任何参数的git reset。这种方式，只保留源码，回退commit和index信息\n2. `git reset --soft`：回退到某个版本，只回退了commit的信息，如果还要提交，直接commit即可（修改的内容变成未add的状态），索引（暂存区）和工作目录的内容是不变的，在三个命令中对现有版本库状态改动最小。\n3. `git reset --hard`：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，所有修改的内容都会丢失， (修改的代码 不会变成未add的状态)。索引（暂存区）内容和工作目录内容都会变给定提交时的状态。\n\n## revert\n\nrevert我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西\n\n参考链接：https://www.jianshu.com/p/ef34fa4c8bf8\n\n## rebase\n\nhttps://blog.csdn.net/weixin_42310154/article/details/119004977\n\n# git回退\n\n## 只回退单个文件\n\nhttps://zhuanlan.zhihu.com/p/267141048\n\nGit在2.17中新增两个命令，restore和switch，分担checkout的职责；\n\n```\n# 放弃工作区的内容，使保持与暂存区一致\ngit restore src/index.js src/images/file.png\n```\n\n> 这里的默认参数是`--worktree`（工作区）\n\n暂存区单个文件放弃修改：\n\n```\n# 放弃暂存区的内容，使与最近一次提交保持一致（HEAD）\ngit restore --stage src/index.js src/images/file.png\n```\n\n> 这里是暂存区的内容发生了变化，工作区的内容不会受影响\n\n工作区单个文件恢复到某个提交版本\n\n```\n# 恢复工作区的某个文件到指定的某个版本，如果文件有修改也会被覆盖\ngit restore --source HEAD src/index.js src/images/file.png\ngit restore --source d68fsdf68s6df src/index.js src/images/file.png\n```\n\n> 恢复操作执行后需要add\n\n暂存区单个文件恢复到某个提交版本\n\n```\n# 恢复暂存区的某个文件到指定的某个版本，如果暂存区文件有未提交也会被覆盖\ngit reset HEAD src/index.js src/images/file.png\ngit reset d68fsdf68s6df src/index.js src/images/file.png\n```\n\n如果需要将工作区与暂存区的某个文件都恢复到之前某个提交版本，则使用checkout来操作，简称co\n\n```\n# 同时将工作区与暂存区的某个文件恢复到指定版本\ngit co HEAD src/index.js src/images/file.png\ngit co d68fsdf68s6df src/index.js src/images/file.png\n```\n\n","categories":["git"]},{"title":"分布式和集群之间的对比","url":"/项目/分布式和集群之间的对比/","content":"\n# 单机服务器\n\n业务系统做了模块化设计，每一个模块都包含很多特定的业务。\n\n拿聊天服务器举例子，一个server上，有若干个模块构成，比如，用户管理、好友管理、群组管理、消息管理、后台管理模块。每一个模块都包含特定的业务，比如用户管理模块就包含用户的登录（通常用一个方法来做登录业务），再如用户的注册、用户的注销。好友管理模块包含添加好友、删除好友；群组管理包含加群、创建群、删除群成员等等；消息管理包含离线消息、一对一聊天消息、群聊消息；后台管理包含广播消息等。\n\n## 问题：单机服务器在性能、设计上有何瓶颈？\n\n1. 聊天服务器所能承受的用户的并发量**受限于硬件资源**。比如32位服务器，最多支持2w多人同时在线聊天，即直接受限于socket资源。\n2. 所有模块耦合在一个单体服务器上，如果修改任意一个模块，哪怕是几行代码，都会导致整个项目代码重新编译、部署。\n3. 各模块对于硬件资源的需求不一样。有些模块属于CPU密集型（计算量大），有些是属于IO密集型的。CPU密集型模块应当部署在CPU性能高的机器上，IO密集型则对CPU性能要求不高，而是需要内存资源多、带宽大的机器。\n\n# 集群服务器\n\n现在，把同一个服务器程序，独立地运行在三个服务器上，分别是server1、server2、server3，每一台服务器都是一套独立的聊天系统。\n\n解决了单机服务器的问题1，提升了用户的并发量。但是没有解决问题2，如果需要修改代码，仍需重新编译，只不过只需要编译1份，但是仍需重新部署在多台服务器上。针对问题3，单纯的集群只是水平地扩展硬件机器，每一台机器上的程序并没有分模块去针对性地分配硬件资源。\n\n比如，后台管理使用的用户并不多，只有极个别的管理员才能使用，因此此模块根本不需要高并发。如果将后台管理部署在每一台服务器上，可能会浪费硬件资源。\n\n因此，可以想到，如果不能很好地分配集群环境中的机器资源，可能不能把整体系统的性能发挥到最大，即不分模块进行部署则不能充分利用全部资源。\n\n优点是，部署很简单，因为没有过多的设计，每台机器的部署方式是一样的，直接运行同一个程序即可。\n\n# 分布式服务器\n\n现有三台服务器，server1部署用户管理、消息管理模块；server2部署好友管理、群组管理模块；server3部署后台管理模块。\n\n相对于集群服务器，如果server2失效，整个系统仍可以正常运行。而如果分布式系统中，任何一个服务器失效，都会造成整个系统的失效。因此，分布式系统是所有服务器共同构成一个聊天系统，给客户端提供服务。因此也把每个服务器称为分布式节点。\n\n解决了问题2，因为分模块部署，如果只修改了某一模块的代码，只需要部分编译，只需要对某一节点进行单独的部署。\n\n解决了问题3，比如节点3后台管理模块包含CPU密集型业务，则其对应的机器可以针对性增加CPU性能，相对地减少内存资源、网络带宽资源。相反的，节点1的用户管理、消息管理模块对应的机器增加内存资源、网络带宽资源，而不需要过高的CPU性能。如此，可以有利于硬件资源的合理分配。\n\n# 分布式+集群服务器\n\n根据节点的并发要求，可以针对某一节点再做节点模块集群部署。\n\n分布式节点1主要负责用户连接、信息传递的处理，对并发量要求大，所以此时我们需要针对此节点进行扩容，即增加服务器同样部署用户管理、消息管理模块。\n\n而且，也可以灵活的调整不同节点的职责，比如，可以同样在节点2上部署用户管理模块，当节点1失效时，可以启用节点2的用户管理模块。\n\n## 带来的挑战\n\n1. 软件设计：需要设计整个系统的软件模块划分，否则各模块可能会实现大量重复的代码\n2. 框架设计：各模块之间如何访问、通信？各模块都运行在不同的进程里，比如好友管理模块、群组管理模块。需要一个机制使函数调用透明化。\n\n## 分布式系统框架解决的问题\n\n比如，节点1负责完用户的登录后，需要获取好友列表，则需要一个机制访问节点2上的好友管理模块。节点1上的模块怎么调用机器2上的模块的一个业务方法？机器1上的一个模块进程1怎么调用机器1上的模块进程2里面的一个业务方法？\n\n需要在网络上传递函数的标识，函数复杂的参数的数据给其他机器。其他机器执行完毕后，返回数据的过程也是需要在网络上传递给调用方机器。\n\n这个过程很复杂，因为有可能每个传递过程都会存在网络异常问题，需要有机制去告诉调用方传输状态。所以，需要把整个过程封装到分布式网络通信框架之中。则在用户看来，调用远端的方法就和调用本地进程内的方法一样简单，不用关注具体细节。\n\n总的来说，分布式是为了克服部署解耦化、资源分配最大化而生。而实现分布式框架需要封装网络通信的具体细节，尤其是，一，传递函数的标识，函数复杂的参数的数据给其他机器，二，需要有机制去告诉调用方每一个传递过程中的传输状态。\n\n","categories":["项目","rpc"]},{"title":"Android_应用初体验","url":"/Android/Android_应用初体验/","content":"\n# 介绍\n\n本文将介绍如何构建简单的Android应用。首先，了解如何通过Android Studio创建`“Hello, World!”`项目并运行它。然后，为应用创建一个新界面，该界面会接受用户输入，并切换到应用中的一个新屏幕以显示用户输入内容。\n\n开始之前，需要了解有关Android应用的两个基本概念：它们如何提供多个入口点，以及它们如何适应不同的设备。\n\n## 应用提供多个入口点\n\nAndroid应用都是将各种可单独调用的组件加以组合构建而成。例如，activity是提供界面(UI)的一种应用组件。\n\n“主”activity在用户点按您的应用图标时启动。还可以将用户从其他位置（例如，从通知中，甚至从其他应用中）引导至某个activity。\n\n其他组件（如`WorkManager`）可使应用能够在没有界面的情况下执行后台任务。\n\n## 应用可适应不同的设备\n\nAndroid允许您为不同的设备提供不同的资源。例如，您可以针对不同的屏幕尺寸创建不同的布局。系统会根据当前设备的屏幕尺寸确定要使用的布局。\n\n如果应用的任何功能需要使用特定的硬件（例如摄像头），您可以在运行时查询该设备是否具有该硬件，如果没有，则停用相应的功能。您可以指定应用需要使用特定的硬件，这样，Google Play就不会允许在没有这些硬件的设备上安装应用。\n\n# 界面布局\n\nAndroid应用的界面（UI）以**布局**和**微件**的层次结构形式构建而成。布局是`ViewGroup`对象，即控制其子视图在屏幕上的放置方式的容器。微件是`View`对象，即按钮和文本框等界面组件。\n\n![ViewGroup对象如何在布局中形成分支并包含View对象的图示](https://developer.android.com/static/images/viewgroup_2x.png)\n\nAndroid提供了ViewGroup和View类的XML词汇表，因此界面的大部分内容都在XML文件中定义。\n\nAndroid Studio的布局编辑器会在开发者拖放视图构建布局时自动编写XML代码，如何使用布局编辑器创建布局呢？\n\n# 构建简单的界面 - 布局编辑器\n\n左下方的Component Tree面板显示布局的视图层次结构。在本例中，根视图是`ConstraintLayout`，它仅包含一个`TextView`对象。\n\n`ConstraintLayout`是一种布局，它根据同级视图和父布局的约束条件定义每个视图的位置，这样一来，使用扁平视图层次结构既可以创建简单布局，又可以创建复杂布局。这种布局无需嵌套布局。嵌套布局是布局内的布局，会增加绘制界面所需的时间。\n\n例如可以声明以下布局。\n\n* 视图A距离父布局顶部16dp\n* 视图A距离父布局左侧16dp\n* 视图B距离视图A右侧16dp\n* 视图B与视图A顶部对齐\n\n![ConstraintLayout内放有两个视图的图示](https://developer.android.com/static/training/basics/firstapp/images/constraint-example_2x.png)\n\n## 添加文本框\n\n按照下面的步骤添加文本框：\n\n1. 首先，需要移除布局中已有的内容。在Componrnt Tree面板中点击TextView，然后按Delete键。\n2. 在Palette面板中，点击Text以显示可用的文本控件。\n3. 将Plain Text拖动到设计编辑器中，并将其放在靠近布局顶部的位置。这是一个接受纯文本输入的`EditText`微件。\n4. 点击设计编辑器中的视图。现在，可以在每个角上看到调整视图大小的正方形手柄，并在每个边上看到圆形约束锚点。为了更好地控制，可能需要放大编辑器。\n5. 点击并按住顶边上的锚点，将其向上拖动，直至其贴靠到布局顶部，然后将其释放。这是一个约束条件：它会将视图约束在已设置的默认外边距内。在本例中，将其设置为距离布局顶部16dp。\n6. 使用相同的过程创建一个从视图左侧到布局左侧的约束条件。\n\n结果如图。\n\n![按照到父布局顶部和左侧的距离约束文本框](https://developer.android.com/static/images/training/basics/firstapp/building-ui-constrained-top-left.png)\n\n## 添加按钮\n\n1. 在Palette面板中，点击Buttons\n2. 将Button微件拖到设计编辑器中，并将其放在靠近右侧的位置。\n3. 创建一个从按钮左侧到文本框右侧的约束条件。\n4. 如需按水平对齐约束视图，请创建一个文本基线之间的约束条件。为此，请右键点击按钮，然后选择`Show Baseline`。基线锚点显示在按钮内部。点击并按住此锚点，然后将其拖动到相邻文本框中显示的基线锚点上。（也可以右键点击文本框，从文本框内部发出基线锚点，拖动到相邻按钮中显示的基线锚点上。）\n\n结果应如图所示。\n\n![按照到文本框右侧的距离以及文本框基线来约束按钮](https://developer.android.com/static/images/training/basics/firstapp/building-ui-constrained-baseline.png)\n\n> 还可以根据顶边或底边实现水平对齐。但按钮的图片周围有内边距，因此如果以这种方式对齐，那么它们看上去是没有对齐的。\n\n## 更改界面字符串\n\n若要预览界面，点击工具栏中的`Select Design Surface`，然后选择`Design`。文本输入和按钮标签应设置为默认值。\n\n若要更改界面字符串，按以下步骤操作：\n\n1. Project窗口，打开`app > res > values > strings.xml`。这是一个字符串资源文件，可以在此文件中指定所有界面字符串。可以利用该文件在一个位置管理所有界面字符串，使字符串的查找、更新和本地化变得更加容易。\n\n2. 点击窗口顶部的`Open editor`。此时将打开`Translations Editor`，它提供了一个可以添加和修改默认字符串的简单界面。还有助于让所有已翻译的字符串井然有序。\n\n3. 点击加号Add Key可以创建一个新字符串作为文本框的“提示文本”。此时会打开如图所示的窗口。\n   ![用于添加新字符串的对话框](https://developer.android.com/static/training/basics/firstapp/images/add-string.png)\n\n   在Add Key对话框中，完成以下步骤：\n\n   1. 在`Key`字段中输入“`edit_message`”。\n   2. 在`Default Value`字段中输入“`Enter a message`”。\n   3. 点击`OK`。\n\n4. 再添加一个名为\"`button_send`\"且值为\"`Send`\"的键。\n\n现在，您可以为每个视图设置这些字符串。若要返回布局文件，请点击标签页栏中的`activity_main.xml`。然后，添加字符串，如下所示：\n\n1. 点击布局中的文本框。如果右侧还未显示`Attributes`窗口，请点击右侧边栏上的 `Attributes`。\n2. 找到`text`属性（当前设为“`Name`”）并删除相应的值。\n3. 找到`hint`属性，然后点击文本框右侧的![img](https://developer.android.com/static/studio/images/buttons/pick-resource.png)(`Pick a Resource`)。在显示的对话框中，双击列表中的`edit_message`。\n4. 点击布局中的按钮，找到其`text`属性（当前设为“`Button`”）。然后点击![img](https://developer.android.com/static/studio/images/buttons/pick-resource.png)(`Pick a Resource`)，并选择`button_send`。\n\n## 让文本框大小可灵活调整\n\n若要创建一个适应不同屏幕尺寸的布局，需要**让文本框拉伸**以填充去除按钮和外边距后**剩余的所有水平空间**。\n\n继续操作之前，点击工具栏中的`Select Design Surface`，然后选择`Blueprint`。\n\n若要让文本框大小可灵活调整，请按以下步骤操作：\n\n1. 选择两个视图。若要执行此操作，请点击一个视图，在按住`Shift`键的同时点击另一个视图，然后右键点击任一视图并依次选择`Chains > Create Horizontal Chain`。布局随即显示出来，如图所示。\n   ![选择Create Horizontal Chain后所得到的结果](https://developer.android.com/static/images/training/basics/firstapp/building-ui-horizontal-chain.png)\n\n   链是两个或多个视图之间的双向约束条件，可让您采用一致的方式安排链接的视图。\n\n2. 选择按钮并打开`Attributes`窗口。然后使用`Constraint Widget`将右外边距设为`16 dp`。\n\n3. 点击文本框以查看其属性。然后，点击宽度指示器（途中红框框住的地方）两次，确保将其设置为锯齿状线(Match Constraints)，如图中的`标注1`所示。\n   ![点击以将宽度更改为Match Constraints](https://developer.android.com/static/images/training/basics/firstapp/building-ui-match-constraints-2x.png)\n\n   “Match constraints”表示宽度将延长以符合水平约束条件和外边距的定义。因此，文本框将拉伸以填充去除按钮和所有外边距后剩余的水平空间。\n\n现在，布局已经完成，如图。\n\n![文本框现在拉伸以填充剩余空间](https://developer.android.com/static/images/training/basics/firstapp/building-ui-constraint-fill.png)\n\n最终布局XML应为以下内容：将其与**Code**标签页中看到的内容进行比较看看错了没。属性顺序不同没影响。\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.example.myfirstapp.MainActivity\">\n\n    <EditText\n        android:id=\"@+id/editText\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginStart=\"16dp\"\n        android:layout_marginLeft=\"16dp\"\n        android:layout_marginTop=\"16dp\"\n        android:ems=\"10\"\n        android:hint=\"@string/edit_message\"\n        android:inputType=\"textPersonName\"\n        app:layout_constraintEnd_toStartOf=\"@+id/button\"\n        app:layout_constraintHorizontal_bias=\"0.5\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <Button\n        android:id=\"@+id/button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginEnd=\"16dp\"\n        android:layout_marginStart=\"16dp\"\n        android:text=\"@string/button_send\"\n        app:layout_constraintBaseline_toBaselineOf=\"@+id/editText\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintHorizontal_bias=\"0.5\"\n        app:layout_constraintStart_toEndOf=\"@+id/editText\" />\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n此时可以测试运行一下。\n\n下面构建在点按按钮后启动的另一个activity。\n\n# 启动另一个Activity\n\n将向MainActivity添加一些代码，以便在用户点按Send按钮时启动一个显示消息的新activity。\n\n## 响应“Send”按钮\n\n向`MainActivity`类添加一个在用户点按Send按钮时调用的方法：\n\n1. 在`app > java > com.example.myfirstapp > MainActivity`文件中，添加以下`sendMessage()`方法桩，这个方法将在某个事件发生后被回调。\n   ```java\n   public class MainActivity extends AppCompatActivity\n   {\n       // ...\n       \n       /* Called when the user taps the Send Button */\n       public void sendMessage(View view)\n       {\n           // Do something in response to button\n       }\n   }\n   ```\n\n   >可能会看到一条错误，因为Android Studio无法解析用作方法参数的View类。若要清除错误，点击View声明，将光标置于其上，然后按Alt+Enter（在 Mac 上则按Option+Enter）进行快速修复。如果出现一个菜单，选择Import class。\n\n2. 返回到activity_main.xml文件，并从该按钮调用此方法：\n\n   1. 选择布局编辑器中的相应按钮。\n   2. 在Attributes窗口中，找到`onClick`属性，并从其下拉列表中选择`sendMessage[MainActivity]`；或者在`activity_main.xml`中的`Button`标签中加入`android:onClick=\"sendMessage\"`属性。\n\n   现在，当用户点按该按钮时，系统将调用`sendMessage()`方法。\n\n   >请注意此方法中提供的详细信息。系统需要这些信息来识别此方法是否与`android:onClick`属性兼容。具体来说，此方法具有以下特性：\n   >\n   >1. public。\n   >2. 返回值为空，或在`Kotlin`中为隐式`Unit`。\n   >3. `View`是唯一的参数。这是在第1步结束时点击的`View`对象。\n\n3. 接下来，填写此方法，以读取文本字段的内容，并将该文本传递给另一个activity。\n\n## 构建一个intent\n\n`Intent`是在相互独立的组件（如两个`activity`）之间提供运行时绑定功能的对象。`Intent`表示应用执行某项操作的意图。可以使用`intent`执行多种任务，但在本例中，`intent`将用于启动另一个`activity`。\n\n在`MainActivity`中，添加`EXTRA_MESSAGE`常量和`sendMessage()`代码，如下所示：\n```java\npublic class MainActivity extends AppCompatActivity {\n    public static final String EXTRA_MESSAGE = \"com.example.myfirstapp.MESSAGE\";\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Called when the user taps the Send button */\n    public void sendMessage(View view) {\n        Intent intent = new Intent(this, DisplayMessageActivity.class);\n        EditText editText = (EditText) findViewById(R.id.editText);\n        String message = editText.getText().toString();\n        intent.putExtra(EXTRA_MESSAGE, message);\n        startActivity(intent);\n    }\n}\n```\n\n`DisplayMessageActivity`仍有错误，但没有关系，下一部分中将修复错误。\n\n`sendMessage()`将发生以下情况：\n\n* `Intent`构造函数会获取两个参数：`Context`和`Class`。\n  `Context`参数首先会被使用，因为`Activity`类是`Context`的子类，在构造activity时，则先构造context父模块。\n  在本例中，系统将`Intent`传递到的应用组件的`class`参数是要启动的activity。\n* `putExtra()`方法将`editText`的值添加到intent。`Intent`能够以称为`\"extra\"`的键值对形式携带数据。\n  key是一个公共常量`EXTRA_MESSAGE`，因为下一个activity将使用该键检索文本值。为intent extra定义键时，最好使用应用的软件包名称作为前缀。这样可以确保这些键是独一无二的，这在应用需要与其他应用进行交互时很重要。\n  value是message，即为editText的内容。将在下一个activity中获取。\n* `startActivity()`方法将启动一个由`Intent`指定的`DisplayMessageActivity`实例，接下来需要创建该类。\n\n# 创建第二个activity\n\n1. 在Project窗口中，右键点击app文件夹，然后依次选择`New > Activity > Empty Activity`。\n2. 在`Configure Activity`窗口中，输入“`DisplayMessageActivity`”作为`Activity Name`。将所有其他属性保留为默认设置，然后点击`Finish`。\n\nAndroid Studio会自动执行下列三项操作：\n\n* 创建`DisplayMessageActivity`文件。\n* 创建`DisplayMessageActivity`文件对应的布局文件 `activity_display_message.xml`。\n* 在`AndroidManifest.xml`中添加所需的`<activity>`元素。\n\n如果您运行应用并点按第一个`activity`上的按钮，将启动第二个`activity`，但它为空。这是因为第二个`activity`使用模板提供的空布局。\n\n## 添加文本视图\n\n新activity包含一个空白布局文件。请按以下步骤操作，在显示消息的位置添加一个文本视图：\n\n1. 打开`app > res > layout > activity_display_message.xml`文件。\n2. 点击工具栏中的![img](https://developer.android.com/static/studio/images/buttons/layout-editor-autoconnect-on.png)`Enable Autoconnection to Parent`。系统将启用`Autoconnect`。\n3. 在`Palette`面板中，点击`Text`，将`TextView`拖动到布局中，然后将其放置在靠近布局顶部中心的位置，使其贴靠到出现的垂直线上。`Autoconnect`将添加左侧和右侧约束条件，以便将该视图放置在水平中心位置。\n4. 再创建一个从文本视图顶部到布局顶部的约束条件，使该视图如图1中所示。\n\n或者，您可以对文本样式进行一些调整，方法是在`Attributes`窗口的`Common Attributes`面板中展开`textAppearance`，然后更改`textSize`和`textColor`等属性。\n\n## 显示消息\n\n在此步骤中，修改第二个activity以显示第一个activity传递的消息。\n\n在`DisplayMessageActivity`中，将以下代码添加到`onCreate()`方法中：\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_display_message);\n    \n    // Get the Intent that started this activity and extract the string\n    Intent intent = getIntent();\n    String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE);\n\n    // Capture the layout's TextView and set the string as its text\n    TextView textView = findViewById(R.id.textView);\n    textView.setText(message);\n}\n```\n\n## 添加向上导航功能\n\n应用中，不是主入口点的每个屏幕（所有不是主屏幕的屏幕）都必须提供导航功能，以便将用户引导至应用层次结构中的逻辑父级屏幕。为此，请在应用栏中添加向上按钮。\n\n若要添加向上按钮，需要在`AndroidManifest.xml`文件中声明哪个activity是逻辑父级。打开`app > manifests > AndroidManifest.xml`文件，找到`DisplayMessageActivity`的`<activity>`标记，然后将其替换为以下代码：\n\n```xml\n<activity android:name=\".DisplayMessageActivity\"\n          android:parentActivityName=\".MainActivity\">\n    <!-- The meta-data tag is required if you support API level 15 and lower -->\n    <meta-data\n        android:name=\"android.support.PARENT_ACTIVITY\"\n        android:value=\".MainActivity\" />\n</activity>\n```\n\nAndroid系统现在会自动向应用栏添加向上按钮。","categories":["Android"]},{"title":"Android_架构","url":"/Android/Android_架构/","content":"\n# 分层\n\nAndroid大致可以分为四层架构：Linux内核层、系统运行库层、应用框架层和应用层。\n\n![](../../images/Android_架构/image-20250820060459795.png)\n1. 应用层。系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互，通常都是用Java开发。\n\n2. 应用框架层。这一层是由Java代码编写的，可以称为Java API Framework。这一层主要提供了构建应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，开发者也可以通过这些API来构建自己的应用程序。开发者API可以直接映射到底层HAL接口，并可提供与实现驱动程序相关的实用信息。这一层所提供的主要组件有：\n\n   1. Activity Manager，活动管理器。管理各个应用程序生命周期，以及常用的导航回退功能。\n   2. Location Manager，位置管理器。提供地理位置及定位功能服务。\n   3. Package Manager，包管理器。管理所有安装在Android系统中的应用程序。\n   4. Notification Manager，通知管理器。使得应用程序可以在状态栏中显示自定义的提示信息。\n   5. Resource Manager，资源管理器。提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等。\n   6. Telephony Manager，电话管理器。管理所有的移动设备功能。\n   7. Window Manager，窗口管理器。管理所有开启的窗口程序。\n   8. Content Provider，内容提供器。使得不同应用程序之间可以共享数据。\n   9. View System，视图系统。构建应用程序的基本组件。\n\n   ![image-20220812120406746](../../images/Android_架构/image-20220812120406746.png)\n\n3. Binder IPC。Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用Android系统服务代码，这使得高级框架API能与Android系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。\n\n4. 系统服务层。系统服务是专注于特定功能的模块化组件，例如窗口管理器、搜索服务或通知管理器。应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（涉及播放和录制媒体的服务）。\n   1. 这一层通过一些`C/C++`库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，`OpenGL|ES`库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。\n   2. 这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用。另外，Android运行时库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程当中，并且拥有一个自己的Dalvik虚拟机实例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。\n\n5. 硬件抽象层。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。借助 HAL，您可以顺利实现相关功能，而不会影响或更改更高级别的系统。HAL 实现会被封装成模块，并会由 Android 系统适时地加载。如需了解详情，请参阅[硬件抽象层 (HAL)](https://source.android.com/devices/architecture/hal)。\n\n6. Linux内核。Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含一些特殊的补充功能，例如低内存终止守护进程（一个内存管理系统，可更主动地保留内存）、唤醒锁定（一种 [`PowerManager`](https://developer.android.com/reference/android/os/PowerManager.html) 系统服务）、Binder IPC 驱动程序，以及对移动嵌入式平台来说非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。您可以使用任意版本的内核，只要它支持所需功能（如 Binder 驱动程序）即可。不过，我们建议您使用 Android 内核的最新版本。如需了解详情，请参阅[构建内核](https://source.android.com/setup/building-kernels)一文。\n\n# HIDL(HAL接口定义语言) - AIDL\n\nHAL Interface Definition Language。\n\nAndroid 8.0 重新设计了 Android 操作系统框架（在一个名为“Treble”的项目中），以便让制造商能够以更低的成本更轻松、更快速地将设备更新到新版 Android 系统。在这种新架构中，HAL 接口定义语言（HIDL，发音为“hide-l”）**指定了 HAL 和其用户之间的接口，让用户无需重新构建 HAL，就能替换 Android 框架**。在 Android 10 中，HIDL 功能已整合到 AIDL(Android Interface Definition Language, 即Android接口定义语言)中。此后，HIDL 就被废弃了，并且仅供尚未转换为 AIDL 的子系统使用。\n\n# Android进阶解密中的分层\n\nAndroid系统架构分为5层，从上到下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。\n\n![image-20220812144626701](../../images/Android_架构/image-20220812144626701.png)\n\n1. 应用层（System Apps）\n\n   1. 系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互，通常都是用Java进行开发的。\n\n2. 应用框架层（Java API Framework）\n\n   1. 应用框架层为开发人员提供了开发应用程序所需要的API，我们平常开发应用程序都是调用这一层所提供的API，当然也包括系统应用。这一层是由Java代码编写的，可以称为Java Framework。下面来看这一层所提供的主要组件。\n\n   2. | 名称                               | 功能描述                                                     |\n      | ---------------------------------- | ------------------------------------------------------------ |\n      | Activity Manager（活动管理器）     | 管理各个应用程序生命周期。以及常用的导航回退功能             |\n      | Location Manager（位置管理器）     | 提供地理位置及定位功能服务                                   |\n      | Package Manager（包管理器）        | 管理所有安装在Android系统中的应用程序                        |\n      | Notification Manager（通知管理器） | 使得应用程序可以在状态栏中显示自定义的提示信息               |\n      | Resource Manager（资源管理器）     | 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、 颜色文件等 |\n      | Telephony Manager（电话管理器）    | 管理所有的移动设备功能                                       |\n      | Window Manager（窗口管理器）       | 管理所有开启的窗口程序                                       |\n      | Content Provider（内容提供器）     | 使得不同应用程序之间可以共享数据                             |\n      | View System（视图系统）            | 构建应用程序的基本组件                                       |\n\n3. 系统运行库层（Native）。系统运行库层分为两部分，分别是`C/C++`程序库和Android运行时库\n\n   1. `C/C++`程序库能被Android系统中的不同组件所使用，并通过应用程序框架为开发者提供服务，表列出了主要的`C/C++`程序库。\n\n      | 功能描述        | 名称                                                         |\n      | --------------- | ------------------------------------------------------------ |\n      | OpenGL ES       | 3D绘图函数库                                                 |\n      | Libc            | 从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制 |\n      | Media Framework | 多媒体库。支持多种常用的音频。视频格式录制和回放             |\n      | SQLite          | 轻型的关系型数据库引擎                                       |\n      | SGL             | 底层的2D图形渲染引擎                                         |\n      | SSL             | 安全套接层，是一种为网络通信提供安全及数据完整性的安全协议   |\n      | FreeType        | 可移植的字体引擎，它提供统一的接口来访问多种字体格式文件     |\n\n   2. Android运行时库又分为核心库和ART（Android 5.0系统之后，Dalvik虚拟机被ART取代）。\n\n      1. 核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。\n      2. 与JVM相比，Dalvik虚拟机（DVM）是专门为移动设备定制的，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。DVM中的应用每次运行时，字节码都需要通过即时编译器（Just In Time，JIT）转换为机器码，这会使得应用的运行效率降低。而ART的机制与DVM不同，在ART中，系统在安装应用时会进行一次预编译（Ahead Of Time，AOT），将字节码预先编译成机器码并存储在本地，这样应用每次运行时就不需要执行编译了，运行效率也大大提高。\n\n4. 硬件抽象层（HAL）\n\n   1. 硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。\n\n5. Linux内核层（Linux Kernel）\n\n   1. Android的核心系统服务基于Linux内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。\n","categories":["Android"]},{"title":"Android_项目目录结构","url":"/Android/Android_项目目录结构/","content":"\n# 项目目录结构\n\n1. `.gradle`和`.idea`：这两个目录都是Android Studio自动生成的文件。无须关心，不要手动编辑。\n2. app：项目中的代码、资源等内容几乎都是放置在这个目录下，开发工作也基本都是在这个目录下进行。\n3. build：这个目录主要包含了一些在编译时自动生成的文件。\n4. gradle：这个目录下包含了`gradle wrapper`的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启用gradle wrapper的方式，如果需要打开，可以点击`File, Settings, Build, Execution, Deployment, Gradle`，进行配置更改。\n5. `.gitignore`：这个文件用来将指定的目录或文件排除在版本控制之外。\n6. `build.gradle`：项目全局的gradle构建脚本，文件内容通常不需要修改。\n7. `gradle.properties`：项目全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。\n8. gradlew和`gradlew.bat`：这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统使用，`gradlew.bat`是在Windows系统中使用。\n9. `项目名.iml`：iml文件是所有IntelliJ IDEA项目都会自动生成的一个文件（Android Studio是基于IntelliJ IDEA开发的），用于标识这是一个IntelliJ IDEA项目，我们不需要修改这个文件中的任何内容。\n10. `local.properties`：这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，并不需要修改。除非本机中的Android SDK位置发生了变化，那么就将这个文件中的路径改成新的位置即可。\n11. `settings.gradle`：用于指定项目中所有引入的模块。由于此时项目中只有一个app模块，因此文件中只引入了app这一个模块。通常情况下，模块的引入是自动完成的，很少去手动修改此文件。\n\n发现，基本上除了app目录之外，大多数目录、文件都是自动生成的。下面对app内容进行更为详细的分析。\n\n1. build：这个目录和外层的build目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容更多更杂，不需要过多关心。\n2. libs：如果你的项目中使用到了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。\n3. androidTest：此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。\n4. java：java目录是放置所有Java代码的地方，展开该目录，将看到刚才创建的HelloWorldActivity文件就在里面。\n5. res：这个目录下的内容有点多。简单点说，就是在项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下，所以不用担心会把整个res目录弄得乱糟糟的。\n\n6. `AndroidManifest.xml`：这是整个Android项目的配置文件，在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。\n7. test：此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。\n8. `.gitignore`：这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的`.gitignore`文件类似。\n9. `app.iml`：IntelliJ IDEA项目自动生成的文件，不需要关心或修改这个文件中的内容。\n10. `build.gradle`：这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置。\n11. `proguard-rules.pro`：这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。\n\n# AndroidManifest.xml\n\n```xml\n<activity anroid:name=\".HelloWorldActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\"></action>\n        <category android:name=\"android.intent.category.LAUNCHER\"></category>\n    </intent-filter>\n</activity>\n```\n\n这段代码表示对HelloWorldActivity这个活动进行注册， 没有在AndroidManifest.xml里注册的活动是不能使用的。其中intent-filter里的两行代码非常重要，`<action android:name=\"android.intent.action.MAIN\"/>`和\t`<category android:name=\"android.intent.category.LAUNCHER\"/>`表示HelloWorldActivity是这个项目的主活动，在手机上点击应用图标， 首先启动的就是这个活动。\n\nActivity是Android应用程序的门面，凡是在应用中看得到的东西，都是放在活动中的。因此看到的界面，其实就是HelloWorldActivity这个活动。打开HelloWorldActivity，代码如下所示：\n\n```java\npublic class HelloWorldActivity extends AppCompatActivity{\n    @Override\n    protected void onCreate(Bundle savedInstanceState){\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.hello_world_layout);\n    }\n}\n```\n\n可以看到，HelloWorldActivity是继承自AppCompatActivity的，这是一种向下兼容的Activity，可以将Activity在各个系统版本中增加的特性和功能最低兼容到Android2.1系统。\n\nActivity是Android系统提供的一个活动基类，我们项目中所有的活动都必须继承它或者它的子类才能拥有活动的特性（AppCompatActivity是Activity的子类）。然后可以看到HelloWorldActivity中有一个`onCreate()`方法，这个方法是一个活动被创建时必定要执行的方法，其中只有两行代码，并且没有`Hello World!`的字样。那么显示的`Hello World!`是在哪里定义的呢？\n\n其实Android程序的设计讲究逻辑和视图分离，因此是**不推荐在活动中直接编写界面的，更加通用的一种做法是，在布局文件中编写界面，然后在活动中引入进来**。可以看到，在onCreate方法的第二行调用了setContentView方法，就是这个方法给当前的活动引入了一个`hello_world_layout`布局，`Hello World!`就是在这里定义的。\n\n布局文件都是定义在`res/layout`目录下的，展开layout目录，会看到`hello_world_layout.xml`这个文件。打开该文件并切换到Text视图，代码就出来了：\n\n# 项目中的资源\n\n1. 所有以drawable开头的文件夹都是用来放图片的；\n2. 所有以mipmap开头的文件夹都是用来放应用图标的；\n3. 所有以values开头的文件夹都是用来放字符串、样式、颜色等配置的；\n4. layout文件夹是用来放布局文件的。\n\nmipmap开头的文件夹有很多，主要是为了兼容各种设备。drawable文件夹也是相同的道理，虽然Android Studio没有自动生成，但应该自己创建drawable-hdpi、drawable-xhdpi、drawable-xxhdpi等文件夹。在制作程序的时候最好能够给同一张图片提供几个不同分辨率的版本，分别放在对应的文件夹下。当程序运行的时候，会自动根据当前运行设备分辨率的高低选择加载。如果只有一份图片，那就都放在drawable-xxhdpi文件夹下。\n\n## values\n\n打开`res/values/strings.xml`文件，内容如下所示：\n\n```xml\n<resources>\n    <string name=\"app_name\">HelloWorld</string>\n</resources>\n```\n\n这里定义了一个应用程序名的字符串，有以下两种方式来引用它。\n\n* 在代码中通过`R.string.app_name`可以获得该字符串的引用\n* 在XML中通过`@string/app_name`可以获得该字符串的引用\n\n其中string部分可以替换，如果引用的是图片资源可以替换成drawable，如果引用的是应用图标可以替换成mipmap，如果引用的是布局文件可以替换成layout\n\n打开`AndroidManifest.xml`文件，找到如下代码：\n\n```xml\n<application>\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:supportRtl=\"true\"\n    android:theme=\"@style/AppTheme\"\n    ...\n</application>\n```\n\n其中，HelloWorld项目的应用图标是通过`android:icon`来指定的，应用的名称则是通过`android:label`属性指定的。\n\n# build.gradle文件\n\nAndroid Studio采用Gradle来构建项目。Gradle使用一种基于Groovy的领域特定预言（DSL）来声明项目设置，摒弃了传统基于XML（如Ant和Maven）的烦琐配置。\n\nHelloWorld项目中有两个`build.gradle`文件，一个是在最外层目录下，一个是在app目录下。\n\n# Android系统源码目录\n\n## 整体结构\n\n各个版本的源码目录基本是类似的，如果是编译后的源码目录，会多一个out文件夹，用来存储编译产生的文件。\n\n| Android源码根目录 | 描述                                                 |\n| ----------------- | ---------------------------------------------------- |\n| art               | ART运行环境                                          |\n| bionic            | 系统C库                                              |\n| bootable          | 启动引导相关代码                                     |\n| build             | 存放系统编译规则及generic等基础开发包配置            |\n| cts               | Android兼容性测试套件标准                            |\n| dalvik            | Dalvik虚拟机                                         |\n| developers        | 开发者目录                                           |\n| development       | 与应用程序开发相关                                   |\n| device            | 设备相关配置                                         |\n| external          | 开源模组相关文件                                     |\n| frameworks        | 应用程序框架，Android系统核心部分，由Java和`C++`编写 |\n| hardware          | 主要是硬件抽象层的代码                               |\n| libcore           | 核心库相关文件                                       |\n| libnativehelper   | 动态库，实现JNI库的基础                              |\n| out               | 编译完成后代码在此目录输出                           |\n| packages          | 应用程序包                                           |\n| pdk               | Plug Development Kit的缩写，本地开发套件             |\n| platform_testing  | 平台测试                                             |\n| prebuilts         | X86和ARM架构下预编译的一些资源                       |\n| sdk               | SDK和模拟器                                          |\n| system            | 底层文件系统库、应用和组件                           |\n| toolchain         | 工具链文件                                           |\n| tools             | 工具文件                                             |\n| Makefile          | 全局Makefile文件，用来定义编译规则                   |\n\n## packages目录结构\n\n应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置的应用程序都在应用层。源码根目录中的packages目录对应着系统应用层，它的目录结构如表所示。\n\n| packages目录 | 描述           |\n| ------------ | -------------- |\n| apps         | 核心应用程序   |\n| experimental | 第三方应用程序 |\n| inputmethods | 输入法目录     |\n| providers    | 内容提供者目录 |\n| screensavers | 屏幕保护       |\n| services     | 通信服务       |\n| wallpapers   | 墙纸           |\n\n## 应用框架层部分\n\n应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与`C/C++`程序库及硬件抽象层等进行衔接。应用框架层的主要实现代码在`frameworks/base`和`frameworks/av`目录下，其中`frameworks/base`目录结构如表所示。\n\n| frameworks/base目录 | 描述                    |\n| ------------------- | ----------------------- |\n| api                 | 定义API                 |\n| cmds                | 重要命令：am、app_proce |\n| core                | 核心库                  |\n| data                | 字体和声音等数据文件    |\n| graphics            | 与图形图像相关          |\n| keystore            | 与数据签名证书相关      |\n| libs                | 库                      |\n| location            | 地理位置相关库          |\n| media               | 多媒体相关库            |\n| native              | 本地库                  |\n| nfc-extras          | 与NFC相关               |\n| obex                | 蓝牙传输                |\n| opengl              | 2D/3D图形API            |\n| packages            | 设置、TTS、VPN程序      |\n| sax                 | XML解析器               |\n| services            | 系统服务                |\n| telephony           | 电话通信管理            |\n| test-runner         | 测试工具相关            |\n| tests               | 与测试相关              |\n| tools               | 工具                    |\n| wifi                | WiFi无线网络            |\n\n## `C/C++`程序库部分\n\n系统运行库层（Native）中的`C/C++`程序库的类型繁多，功能强大，`C/C++`程序库并不完全在一个目录中，这里给出几个常用且比较重要的`C/C++`程序库所在的目录位置，如表所示。\n\n| 目录位置                                    | 描述                                             |\n| ------------------------------------------- | ------------------------------------------------ |\n| bionic                                      | Google开发的系统C库，以BSD许可形式开源           |\n| `frameworks/av/media`                       | 系统媒体库                                       |\n| `frameworks/native/opengl`                  | 第三方图形渲染库                                 |\n| `frameworks/native/services/surfaceflinger` | 图形显示库，主要负责图形的渲染、叠加和绘制等功能 |\n| `external/sqlite`                           | 轻量级关系型数据库SQLite的`C++`实现              |\n\nAndroid运行时库的代码在`art/`目录中；硬件抽象层的代码在`hardware/`目录中，这是手机厂商改动最大的部分，根据手机终端所采用的硬件平台不同会有不同的实现。\n\n# 源码阅读\n\n系统源码的阅读有很多种方式，总的来说分为两种：一种是在线阅读，另一种是下载源码到本地用软件工具阅读。\n\n1. 在线阅读\n   1. Android 在线阅读源码的网站有很多，比如www.grepcode.com、www.androidxref.com，www.androidos.net.cn等，这里推荐使用www.androidxref.com进行在线阅读。\n2. 使用本地工具，本地阅读源码可以采用Android Studio、Eclipse、Sublime和Source Insight等软件。\n","categories":["Android"]},{"title":"Android_repo和编译_烧录","url":"/Android/Android_repo和编译_烧录/","content":"# git\n\n参考文章：[Git三大特色之Stage](https://blog.csdn.net/qq_32452623/article/details/78417609)\n\n## 三个区\n\nGit本地数据管理，大概可以分为三个区，工作区、暂存区、版本库。\n\n1. 工作区（Working Directory）是我们直接编辑的地方，例如 Android Studio 打开的项目，记事本打开的文本等，肉眼可见，直接操作。\n2. 暂存区（Stage 或 Index）是数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。\n3. 版本库（commit History）存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。\n\n## Stage（暂存区）赋予Git更多灵活性\n\n* 修改了4个文件，在不放弃任何修改的情况下，其中一个文件不想提交，如何操作？（没add: `git add`；已经add: `git reset --soft`）\n* 修改到一半的文件，突然间不需要或者放弃修改了，怎么恢复未修改前文件？ (`git checkout`)\n* 代码写一半，被打断去做其他功能开发，未完成代码保存？(`git stash`)\n* 代码写一半，发现忘记切换分支了？(`git stash & git checkout`)\n* 代码需要回滚了？（`git reset`）\n\n上面提到的 checkout & stash & reset 等命令，通过不同的参数搭配使用，可以在工作区，暂存区和版本库之间，轻松进行数据的来回切换。\n\n## stash的使用场景\n\n此时我在`feature_666`分支，非常聚精会神加持高专注地实现一个功能666模块，简直键盘如飞的编写代码。然后这时，客户反馈出一个bug，非常严重，必须立马解决，优先级为0！于是，我需要去到release分支去checkout新的分支去工作了，但是666功能还没完成怎么办？\n\n此时面临着一个选择题：\n\nA：提交后切换，代码保存到分支`feature_666`，却产生一个无意义的提交。\n\nB：不提交直接切换，然而这个选项根本没人会选。\n\n是不是很难选，此时，别忘记还有C选项！\n\nC：使用`git stash`，将当前修改(未提交的代码)存入缓存区，切换分支修改`bug`，回来再通过`git stash pop`取出来。\n\n# repo\n\n```\nusage: repo COMMAND [ARGS]\nThe most commonly used repo commands are:\n  abandon        Permanently abandon a development branch\n  branch         View current topic branches\n  branches       View current topic branches\n  checkout       Checkout a branch for development\n  cherry-pick    Cherry-pick a change.\n  diff           Show changes between commit and working tree\n  diffmanifests  Manifest diff utility\n  download       Download and checkout a change\n  gitc-delete    Delete a GITC Client.\n  gitc-init      Initialize a GITC Client.\n  grep           Print lines matching a pattern\n  info           Get info on the manifest branch, current branch or unmerged branches\n  init           Initialize a repo client checkout in the current directory\n  list           List projects and their associated directories\n  overview       Display overview of unmerged project branches\n  prune          Prune (delete) already merged topics\n  rebase         Rebase local branches on upstream branch\n  smartsync      Update working tree to the latest known good revision\n  stage          Stage file(s) for commit\n  start          Start a new branch for development\n  status         Show the working tree status\n  sync           Update working tree to the latest revision\n  upload         Upload changes for code review\nSee 'repo help <command>' for more information on a specific command.\nSee 'repo help --all' for a complete list of recognized commands.\n```\n\n## repo init\n\n`repo init -u git@gitlab.gz.cvte.cn:tc02_mtk_android10_0/manifest.git -m mtk8788_s..wo_tc02a_sys828.xml -b develop_dt15`\n\nrepo init：Initialize a repo client checkout in the current directory，选项：（可通过`repo help init`查看）\n\n| 选项                                        | 含义                                                |\n| ------------------------------------------- | --------------------------------------------------- |\n| `-u URL`, `--manifest-url=URL`              | manifest repository location                        |\n| `-m NAME.xml`, `--manifest-name=NAME.xml`   | initial manifest file                               |\n| `-b REVISION`, `--manifest-branch=REVISION` | manifest branch or revision (use HEAD for  default) |\n\n## repo sync\n\nrepo sync：Update working tree to the latest revision。可带`-j10`指定并行数量。\n\n### 描述\n\n```\nUpdate working tree to the latest revision\n\nUsage: repo sync [<project>...]\n\nOptions:\n  -h, --help            show this help message and exit\n  -j JOBS, --jobs=JOBS  number of jobs to run in parallel (default: 1; based\n                        on number of CPU cores)\n  --jobs-network=JOBS   number of network jobs to run in parallel (defaults to\n                        --jobs)\n  --jobs-checkout=JOBS  number of local checkout jobs to run in parallel\n                        (defaults to --jobs)\n  -f, --force-broken    obsolete option (to be deleted in the future)\n  --fail-fast           stop syncing after first error is hit\n  --force-sync          overwrite an existing git directory if it needs to\n                        point to a different object directory. WARNING: this\n                        may cause loss of data\n  --force-remove-dirty  force remove projects with uncommitted modifications\n                        if projects no longer exist in the manifest. WARNING:\n                        this may cause loss of data\n  -l, --local-only      only update working tree, don't fetch\n  --no-manifest-update, --nmu\n                        use the existing manifest checkout as-is. (do not\n                        update to the latest revision)\n  -n, --network-only    fetch only, don't update working tree\n  -d, --detach          detach projects back to manifest revision\n  -c, --current-branch  fetch only current branch from server\n  --no-current-branch   fetch all branches from server\n  -m NAME.xml, --manifest-name=NAME.xml\n                        temporary manifest to use for this sync\n  --clone-bundle        enable use of /clone.bundle on HTTP/HTTPS\n  --no-clone-bundle     disable use of /clone.bundle on HTTP/HTTPS\n  -u MANIFEST_SERVER_USERNAME, --manifest-server-username=MANIFEST_SERVER_USERNAME\n                        username to authenticate with the manifest server\n  -p MANIFEST_SERVER_PASSWORD, --manifest-server-password=MANIFEST_SERVER_PASSWORD\n                        password to authenticate with the manifest server\n  --fetch-submodules    fetch submodules from server\n  --use-superproject    use the manifest superproject to sync projects;\n                        implies -c\n  --no-use-superproject\n                        disable use of manifest superprojects\n  --tags                fetch tags\n  --no-tags             don't fetch tags (default)\n  --optimized-fetch     only fetch projects fixed to sha1 if revision does not\n                        exist locally\n  --retry-fetches=RETRY_FETCHES\n                        number of times to retry fetches on transient errors\n  --prune               delete refs that no longer exist on the remote\n                        (default)\n  --no-prune            do not delete refs that no longer exist on the remote\n  -s, --smart-sync      smart sync using manifest from the latest known good\n                        build\n  -t SMART_TAG, --smart-tag=SMART_TAG\n                        smart sync using manifest from a known tag\n\n  Logging options:\n    -v, --verbose       show all output\n    -q, --quiet         only show errors\n\n  Multi-manifest options:\n    --outer-manifest    operate starting at the outermost manifest\n    --no-outer-manifest\n                        do not operate on outer manifests\n    --this-manifest-only\n                        only operate on this (sub)manifest\n    --no-this-manifest-only, --all-manifests\n                        operate on this manifest and its submanifests\n\n  repo Version options:\n    --no-repo-verify    do not verify repo source code\n\nDescription\n\nThe 'repo sync' command synchronizes local project directories with the remote\nrepositories specified in the manifest. If a local project does not yet exist,\nit will clone a new local directory from the remote repository and set up\ntracking branches as specified in the manifest. If the local project already\nexists, 'repo sync' will update the remote branches and rebase any new local\nchanges on top of the new remote changes.\n\n'repo sync' will synchronize all projects listed at the command line. Projects\ncan be specified either by name, or by a relative or absolute path to the\nproject's local directory. If no projects are specified, 'repo sync' will\nsynchronize all projects listed in the manifest.\n\nThe -d/--detach option can be used to switch specified projects back to the manifest revision. This option is especially helpful if the project is currently on a topic branch, but the manifest revision is temporarily needed.\n\nThe -s/--smart-sync option can be used to sync to a known good build as\nspecified by the manifest-server element in the current manifest. The\n-t/--smart-tag option is similar and allows you to specify a custom tag/label.\n\nThe -u/--manifest-server-username and -p/--manifest-server-password options can\nbe used to specify a username and password to authenticate with the manifest\nserver when using the -s or -t option.\n\nIf -u and -p are not specified when using the -s or -t option, 'repo sync' will\nattempt to read authentication credentials for the manifest server from the\nuser's .netrc file.\n\n'repo sync' will not use authentication credentials from -u/-p or .netrc if the\nmanifest server specified in the manifest file already includes credentials.\n\nBy default, all projects will be synced. The --fail-fast option can be used to\nhalt syncing as soon as possible when the first project fails to sync.\n\nThe --force-sync option can be used to overwrite existing git directories if\nthey have previously been linked to a different object directory. WARNING: This\nmay cause data to be lost since refs may be removed when overwriting.\n\nThe --force-remove-dirty option can be used to remove previously used projects\nwith uncommitted changes. WARNING: This may cause data to be lost since\nuncommitted changes may be removed with projects that no longer exist in the\nmanifest.\n\nThe --no-clone-bundle option disables any attempt to use $URL/clone.bundle to\nbootstrap a new Git repository from a resumeable bundle file on a content\ndelivery network. This may be necessary if there are problems with the local\nPython HTTP client or proxy configuration, but the Git binary works.\n\nThe --fetch-submodules option enables fetching Git submodules of a project from\nserver.\n\nThe -c/--current-branch option can be used to only fetch objects that are on the\nbranch specified by a project's revision.\n\nThe --optimized-fetch option can be used to only fetch projects that are fixed\nto a sha1 revision if the sha1 revision does not already exist locally.\n\nThe --prune option can be used to remove any refs that no longer exist on the\nremote.\n\nSSH Connections\n\nIf at least one project remote URL uses an SSH connection (ssh://, git+ssh://,\nor user@host:path syntax) repo will automatically enable the SSH ControlMaster\noption when connecting to that host. This feature permits other projects in the\nsame 'repo sync' session to reuse the same SSH tunnel, saving connection setup\noverheads.\n\nTo disable this behavior on UNIX platforms, set the GIT_SSH environment variable\nto 'ssh'. For example:\n\n  export GIT_SSH=ssh\n  repo sync\n\nCompatibility\n\nThis feature is automatically disabled on Windows, due to the lack of UNIX\ndomain socket support.\n\nThis feature is not compatible with url.insteadof rewrites in the user's\n~/.gitconfig. 'repo sync' is currently not able to perform the rewrite early\nenough to establish the ControlMaster tunnel.\n\nIf the remote SSH daemon is Gerrit Code Review, version 2.0.10 or later is\nrequired to fix a server side protocol bug.\n```\n\n### `-d`, `--detach`\n\n参考文章：https://segmentfault.com/a/1190000021005727\n\n使用repo sync命令来同步远端服务器的Android代码，如果本地修改了代码但还没有commit，会提示无法sync：`error: android/frameworks/base/: contains uncommitted changes`。此时，可以使用git reset命令丢弃本地修改（如果没有git add到暂存区，其实git checkout也可以），然后再执行repo sync来同步代码。如果想要不丢失本地修改，强制同步远端服务器代码，可以加上-d选项，`repo sync -d`命令会将HEAD强制指向repo manifest版本，而忽略本地的改动。\n\n**注意**：加上`-d`选项只表示忽略本地改动，可以强制同步远端服务器的代码，但是**本地修改的文件还是保持改动不变，不会强制覆盖掉本地修改**。而且同步之后，本地的分支指向会发生变化，不再指向原来的分支。具体举例如下。\n\n1. 执行`repo sync -d`之前的分支信息：\n   ```\n   $ git branch\n   * curent_branch_xxx\n   ```\n\n2. 执行`repo sync -d`之后的分支信息：\n   ```\n   $ git branch\n   * (detached from 715faf5)\n     curent_branch_xxx\n   ```\n\n   即，从远端服务器同步的代码，是同步到跟踪远端服务器的分支，还没有从git仓库把代码checkout到本地，而当前本地修改的代码处在未命名分支下，是不同的分支，互不干扰，才能在不丢弃本地修改的情况下，强制同步远端服务器代码。\n\n3. 执行`git status`命令，可以看到本地还是有修改过且还没有 commit 的文件，同步远端服务器代码后，并不会强制覆盖本地文件的修改：\n   ```\n   $ git status\n   HEAD detached at 715faf5\n   Changes not staged for commit:\n     (use \"git add <file>...\" to update what will be committed)\n     (use \"git checkout -- <file>...\" to discard changes in working directory)\n           modified:   vendor/chioverride/default/g_pipelines.h\n           modified:   vendor/topology/g_usecase.xml\n   ```\n\n即，如果想要丢弃本地修改、让本地代码跟同步后的 git 仓库代码一致，`repo sync -d`命令达不到这个效果。\n\n另外，repo sync有一个`--force-sync`选项，具体说明如下：\n\n> **--force-sync**\n> overwrite an existing git directory if it needs to point to a different object directory. WARNING: this may cause loss of data\n\n从说明来看，像是可以强制同步，且可能丢失本地改动。但是实际测试发现，这个选项并不能强制覆盖本地的改动。如果本地文件发生改动，加上这个选项也是会 sync 报错：\n\n```bash\n$ repo sync --force-sync .\nFetching project tools/\nerror: tools/: contains uncommitted changes\n```\n\n如果想要覆盖本地修改的代码，则需要继续：\n\n```bash\n# 将HEAD强制指向manifest库，忽略本地的改动\nrepo sync -d\n# Remove all working directory (and staged) changes\nrepo forall -c 'git reset --hard'\n# Clean untracked files\nrepo forall -c 'git clean -f -d'\n# 拉代码\nrepo sync -c # fetch only current branch from server\n```\n\n> forall的作用：Run a shell command in each project\n```\nUsage: repo forall [<project>...] -c <command> [<arg>...]\nrepo forall -r str1 [str2] ... -c <command> [<arg>...]\n\nOptions:\n  -h, --help            show this help message and exit\n  -j JOBS, --jobs=JOBS  number of jobs to run in parallel (default: 8; based\n                        on number of CPU cores)\n  -r, --regex           execute the command only on projects matching regex or\n                        wildcard expression\n  -i, --inverse-regex   execute the command only on projects not matching\n                        regex or wildcard expression\n  -g GROUPS, --groups=GROUPS\n                        execute the command only on projects matching the\n                        specified groups\n  -c, --command         command (and arguments) to execute\n  -e, --abort-on-errors\n                        abort if a command exits unsuccessfully\n  --ignore-missing      silently skip & do not exit non-zero due missing\n                        checkouts\n  --interactive         force interactive usage\n\n  Logging options:\n    -v, --verbose       show all output\n    -q, --quiet         only show errors\n    -p                  show project headers before output\n\n  Multi-manifest options:\n    --outer-manifest    operate starting at the outermost manifest\n    --no-outer-manifest\n                        do not operate on outer manifests\n    --this-manifest-only\n                        only operate on this (sub)manifest\n    --no-this-manifest-only, --all-manifests\n                        operate on this manifest and its submanifests\n\nRun `repo help forall` to view the detailed manual.\n\nDescription\n\nExecutes the same shell command in each project.\n\nThe -r option allows running the command only on projects matching regex or\nwildcard expression.\n\nBy default, projects are processed non-interactively in parallel. If you want to\nrun interactive commands, make sure to pass --interactive to force --jobs 1.\nWhile the processing order of projects is not guaranteed, the order of project\noutput is stable.\n```\n因此，`repo forall -c 'git reset --hard'`表示，在每一个repo下属的git仓库目录中都执行`git reset --hard`指令。\n\n## repo start\n\nrepo start：Start a new branch for development。选项：`--all`, begin branch in all projects。\n\n# 编译\n\n参考文章：[android编译分析之2—envsetup.sh](https://blog.51cto.com/u_15147256/2792451)\n\n总的来说，android编译分两部分：\n\n1. 编译前的准备工作，主要是在shell环境中提前设置了很多变量和函数；\n2. 执行make进行编译，产生各种镜像文件。\n\n## 流程\n\n1. `source build/envsetup.sh`\n2. `lunch`\n3. pick a combo\n\n```\n$ . build/envsetup.sh\nincluding device/mediatek/build/vendorsetup.sh\n$ lunch\nYou're building on Linux\n\nLunch menu... pick a combo:\n     1. aosp_arm-eng\n     2. aosp_arm64-eng\n     3. aosp_blueline-userdebug\n     4. aosp_bonito-userdebug\n     5. aosp_car_arm-userdebug\n     6. aosp_car_arm64-userdebug\n     7. aosp_car_x86-userdebug\n     8. aosp_car_x86_64-userdebug\n     9. aosp_cf_arm64_phone-userdebug\n     10. aosp_cf_x86_64_phone-userdebug\n     11. aosp_cf_x86_auto-userdebug\n     12. aosp_cf_x86_phone-userdebug\n     13. aosp_cf_x86_tv-userdebug\n     14. aosp_crosshatch-userdebug\n     15. aosp_marlin-userdebug\n     16. aosp_sailfish-userdebug\n     17. aosp_sargo-userdebug\n     18. aosp_taimen-userdebug\n     19. aosp_walleye-userdebug\n     20. aosp_walleye_test-userdebug\n     21. aosp_x86-eng\n     22. aosp_x86_64-eng\n     23. beagle_x15-userdebug\n     24. fuchsia_arm64-eng\n     25. fuchsia_x86_64-eng\n     26. full_tb8321p2_bsp-eng\n     27. full_tb8321p2_bsp-user\n     28. full_tb8321p2_bsp-userdebug\n     29. full_tb8321p2_bsp_2g-eng\n     30. full_tb8321p2_bsp_2g-user\n     31. full_tb8321p2_bsp_2g-userdebug\n     32. full_tb8765ap1_64_bsp-eng\n     33. full_tb8765ap1_64_bsp-user\n     34. full_tb8765ap1_64_bsp-userdebug\n     35. full_tb8765ap1_bsp-eng\n     36. full_tb8765ap1_bsp-user\n     37. full_tb8765ap1_bsp-userdebug\n     38. full_tb8765ap1_bsp_1g-eng\n     39. full_tb8765ap1_bsp_1g-user\n     40. full_tb8765ap1_bsp_1g-userdebug\n     41. full_tb8766p1_64_bsp-eng\n     42. full_tb8766p1_64_bsp-user\n     43. full_tb8766p1_64_bsp-userdebug\n     44. full_tb8766p1_bsp_1g-eng\n     45. full_tb8766p1_bsp_1g-user\n     46. full_tb8766p1_bsp_1g-userdebug\n     47. full_tb8768p1_64_bsp-eng\n     48. full_tb8768p1_64_bsp-user\n     49. full_tb8768p1_64_bsp-userdebug\n     50. full_tb8768p2_64_bsp_sp-eng\n     51. full_tb8768p2_64_bsp_sp-user\n     52. full_tb8768p2_64_bsp_sp-userdebug\n     53. full_tb8768tp1_64_bsp-eng\n     54. full_tb8768tp1_64_bsp-user\n     55. full_tb8768tp1_64_bsp-userdebug\n     56. full_tb8788m1_64_wifi-eng\n     57. full_tb8788m1_64_wifi-user\n     58. full_tb8788m1_64_wifi-userdebug\n     59. full_tb8788p1_64_bsp-eng\n     60. full_tb8788p1_64_bsp-user\n     61. full_tb8788p1_64_bsp-userdebug\n     62. full_tb8788p1_64_wifi-eng\n     63. full_tb8788p1_64_wifi-user\n     64. full_tb8788p1_64_wifi-userdebug\n        ...\n     \nWhich would you like? [aosp_arm-eng] full_tb8788p1_64_wifi-userdebug\nEnter customer product(default: s..wo):\nnot specific S..WO_CUSTOMER_PRODUCT, reset to s..wo.\ndevice/mediateksample/tb8788p1_64_wifi/device.mk:196: warning: \"---------Including s..wo apps---------\"\n```\n\nlunch提示你做选择，可以直接回车，可以输入序号，也可以输入序号后的字符串。\n\n编译时，直接执行make即可。AOSP代码的根目录下有一个`Makefile`，但是内容只有一句，包含了`build/core`目录下的`main.mk`，正如名字所示，`main.mk`是android编译系统中最主要的makefile。\n\n```shell\n### DO NOT EDIT THIS FILE ###\ninclude build/make/core/main.mk\n### DO NOT EDIT THIS FILE ###\n```\n\n## m、mm、mmm的区别\n\n首先，使用这三个编译命令，需要提前在源码目录下执行如下命令，否则会提示命令找不到：\n\n```bash\n$ . build/envsetup.sh # 或者 source build/envsetup.sh\nincluding device/mediatek/build/vendorsetup.sh\n```\n\nbuild/envsetup.sh这个脚本包含了很多的shell函数，有些函数是非常有用的，envsetup.sh中的第一个函数为hmm，类似于`-help`的功能，提示当执行完source后，android系统目前能干些什么，执行hmm。\n\n```\n~/myProject/DT15/alps$ hmm\nRun \"m help\" for help with the build system itself.\n\nInvoke \". build/envsetup.sh\" from your shell to add the following functions to your environment:\n- lunch:      lunch <product_name>-<build_variant>\n              Selects <product_name> as the product to build, and <build_variant> as the variant to\n              build, and stores those selections in the environment to be read by subsequent\n              invocations of 'm' etc.\n- tapas:      tapas [<App1> <App2> ...] [arm|x86|mips|arm64|x86_64|mips64] [eng|userdebug|user]\n- croot:      Changes directory to the top of the tree, or a subdirectory thereof.\n- m:          Makes from the top of the tree.\n- mm:         Builds all of the modules in the current directory, but not their dependencies.\n- mmm:        Builds all of the modules in the supplied directories, but not their dependencies.\n              To limit the modules being built use the syntax: mmm dir/:target1,target2.\n- mma:        Builds all of the modules in the current directory, and their dependencies.\n- mmma:       Builds all of the modules in the supplied directories, and their dependencies.\n- provision:  Flash device with all required partitions. Options will be passed on to fastboot.\n- cgrep:      Greps on all local C/C++ files.\n- ggrep:      Greps on all local Gradle files.\n- jgrep:      Greps on all local Java files.\n- resgrep:    Greps on all local res/*.xml files.\n- mangrep:    Greps on all local AndroidManifest.xml files.\n- mgrep:      Greps on all local Makefiles files.\n- sepgrep:    Greps on all local sepolicy files.\n- sgrep:      Greps on all local source files.\n- godir:      Go to the directory containing a file.\n- allmod:     List all modules.\n- gomod:      Go to the directory containing a module.\n- pathmod:    Get the directory containing a module.\n- refreshmod: Refresh list of modules for allmod/gomod.\n\nEnvironment options:\n- SANITIZE_HOST: Set to 'true' to use ASAN for all host modules. Note that\n                 ASAN_OPTIONS=detect_leaks=0 will be set by default until the\n                 build is leak-check clean.\n- ANDROID_QUIET_BUILD: set to 'true' to display only the essential messages.\n\nLook at the source to view more functions. The complete list is:\naddcompletions add_lunch_combo allmod build_build_var_cache cgrep check_product check_type check_variant choosecombo chooseproduct choosetype choosevariant _complete_android_module_names core coredump_enable coredump_setup cproj croot _croot destroy_build_var_cache enable_zsh_completion findmakefile get_abs_build_var getbugreports get_build_var getlastscreenshot get_make_command getprebuilt getscreenshotpath getsdcardpath gettargetarch gettop ggrep godir gomod hmm is isviewserverstarted jgrep key_back key_home key_menu lunch _lunch m make mangrep mgrep mm mma mmm mmma pathmod pez printconfig print_lunch_menu provision qpid rcgrep refreshmod resgrep runhat runtest sepgrep setpaths set_sequence_number set_stuff_for_environment sgrep should_add_completion smoketest source_s..wo_setup source_vendorsetup startviewserver stopviewserver systemstack tapas tracedmdump treegrep validate_current_shell _wrap_build\n\n```\n\n- m：Makes from the top of the tree. 编译整个安卓源码树。即找到最顶层目录编译android。\n- mm：Builds all of the modules in the current directory, but not their dependencies. 编译当前目录下的模块，当前目录下需要有Android.mk这个makefile文件，否则就往上找最近的Android.mk文件。\n- mmm：Builds all of the modules in the supplied directories, but not their dependencies. To limit the modules being built use the syntax: `mmm dir/:target1,target2`. 编译指定路径下的模块，指定的路径下面需要有Android.mk这个文件。\n\n```\n~/myProject/DT15/alps$\nmmm vendor/mediatek/proprietary/packages/apps/MtkSettings/\n```\n\n# adb push\n\n项目开发中需要向安卓的目录下传输一些文件，因此记录一下adb pull的使用方式和adb push的使用。摸索完毕后，做一个记录。\n\n首先声明一下，这两种使用方式都仅能在adb device列表里只有一个设备的时候使用，否则需要带上ip。\n\n由于adb push表示向设备传输，adb pull表示向设备外传输。但是二者的用法都是从地址1向地址2传输因此，只介绍adb push。\n\n## 传输文件\n\n可以指定目标地点文件的名字，此时会对该文件进行覆盖，不要求传输的目标文件后缀和待传输文件一致，例如：`adb push C:\\Users\\Administrator\\Desktop\\123.txt /sdcard/test/321.c`，相当于传输到目的后进行了一次重命名。\n\n也可以省略目标地点的名字，此时会在目标地点生成一个和传输文件同名的文件，同样会对目的地同名文件进行覆盖，例如：`adb push C:\\Users\\Administrator\\Desktop\\123.txt /sdcard/test/`\n\n## 传输文件夹\n\n传输文件夹时，只会在目的目录下生成一个同名的子目录，不论传输前是否包含斜杠作为结尾，例如：`adb push C:\\Users\\Administrator\\Desktop\\video\\ /sdcard/test/`。上面这个语句在video后面或者是test后面不论加不加斜杠，都会在test目录下创建一个叫video的文件夹，并且包含vidio内原本的内容。\n\n如果希望传输文件夹内的文件而不是传输文件夹，那么需要加上`.`，例如：`adb push C:\\Users\\Administrator\\Desktop\\video\\. /sdcard/test/`，此时就会在test文件夹下放置video文件夹内的内容了。\n\n`/drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb push . /product/priv-app/;adb shell stop;adb shell start`\n\n## Android Q remount步骤\n\n1. `adb shell am start com.android.settings/.Settings`\n2. 关于，版本号，快速连续点击，进入开发者模式\n3. `adb shell am start -a com.android.settings.APPLICATION_DEVELOPMENT_SETTINGS`\n4. 打开OEM解锁\n5. adb reboot bootloader\n6. fastboot flashing unlock\n7. press volume up-key（按音量上键）\n8. fastboot reboot\n9. adb root\n10. adb disable-verity\n11. adb reboot\n12. adb root\n13. adb remount\n\n# 总结\n\n大致测试了以上内容，基本够简单的使用了，如果连接了多个设备又想指定一台进行传输，那么指令上需要在adb和push直接加入`-s deviceId`，其中deviceId需要替换成用adb devices命令查看到的设备的名称（有可能是ip地址+端口）。例如：`adb -s 192.168.10.12:5432 push`\n\n# 额外\n\n```\n  11/08/2022   11:04.56   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb root;adb remount product\nadbd is already running as root\nE Skipping /product\nW No partitions to remount\n/system/bin/remount exited with status 7\nremount failed\n                                                                                                                                                                                                 ✓\n\n  11/08/2022   11:05.14   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb root;adb remount vendor\nadbd is already running as root\nE Skipping /vendor\nW No partitions to remount\n/system/bin/remount exited with status 7\nremount failed\n                                                                                                                                                                                                 ✓\n\n  11/08/2022   11:05.21   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb reboot bootloader\n                                                                                                                                                                                                 ✓\n\n  11/08/2022   11:06.07   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  fastboot devices\nS..WOS202110120008      fastboot\n                                                                                                                                                                                                 ✓\n\n  11/08/2022   11:06.26   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  fastboot flashing unlock\n(bootloader) Start unlock flow\n\nOKAY [  6.276s]\nFinished. Total time: 6.276s\n                                                                                                                                                                                                 ✓\n\n  11/08/2022   11:07.02   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  fastboot reboot\nRebooting                                          OKAY [  0.003s]\nFinished. Total time: 0.003s\n                                                                                                                                                                                                 ✓\n  11/08/2022   11:08.03   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb connect 192.168.137.230\nconnected to 192.168.137.230:5555\n                                                                                                                                                                                                 ✓\n  11/08/2022   11:09.42   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb root\nrestarting adbd as root\n                                                                                                                                                                                                 ✓\n  11/08/2022   11:09.45   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb disable-verity\nusing overlayfs\nSuccessfully disabled verity\nNow reboot your device for settings to take effect\n                                                                                                                                                                                                 ✓\n\n  11/08/2022   11:09.51   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb reboot\n                                                                                                                                                                                                 ✓\n  11/08/2022   11:10.37   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb root;adb remount\nremount succeeded\n                                                                                                                                                                                                 ✓\n  11/08/2022   11:10.48   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb root;adb remount ;adb push product/priv-app/MtkSettings/ /product/priv-app/\nadbd is already running as root\nremount succeeded\nproduct/priv-app/MtkSettings/: 3 files pushed, 0 skipped. 11.3 MB/s (34525797 bytes in 2.918s)\n                                                                                                                                                                                                 ✓\n  11/08/2022   11:11.11   /drives/q/myProject/DT15/alps/out/target/product/tb8788p1_64_wifi  adb root;adb remount ;adb push product/priv-app/MtkSettings/ /product/priv-app/;adb shell stop;adb shell start\nadbd is already running as root\nremount succeeded\nproduct/priv-app/MtkSettings/: 3 files pushed, 0 skipped. 11.2 MB/s (34525817 bytes in 2.945s)\n```\n\n# MTK烧录\n\n## 准备流程\n\n软件：Windows系统、MTK烧录工具及驱动包 - `mtk_SP_Flash_Tool_+_Driver.zip`\n\n解压MTK烧录工具及驱动包，有以下文件：\n\n![image-20220815091907230](../../images/Android_repo和编译_烧录/image-20220815091907230.png)\n\n驱动安装：\n\n1. 打开SP驱动安装程序：\n   `Driver_Auto_Installer_EXE_v5.1632.00\\Driver_Auto_Installer_SP_Drivers_20160804\\DriverInstall.exe`。\n2. 打开USB驱动安装程序：`usb_driver\\setup.exe`\n\n烧录工具程序：`SP_Flash_Tool_exe_Windows_v5.1916.00.000\\flash_tool.exe`\n\n1. 点击Download-Agent右边的choose按钮，选择当前烧录工具目录下的`MTK_AllInOne_DA.bin`文件；\n2. 点击Scatter-loading File栏右边的choose按钮，选择系统固件包里的`MT6771_Android_scatter.txt`。\n3. 选择三种模式之一，最后点击Download准备烧录。\n4. 重启设备，进行烧录写入。\n5. 烧录完成后，拔插设备电源，开机即可进入系统。\n\n## 三种模式的差异\n\n1. Format All + Download，对应的是全擦升级，会把各种标识擦除，比如写标识位、机器SN码。\n2. Firmware Upgrade，也会重写各种标识，常在不同开发版本之间转换时使用，如user和userdebug之间转换。\n3. Download Only，一般是同一开发版本下新旧版本号的切换，或者同版本号不同代码的调试使用。\n","categories":["Android"]},{"title":"Android_原生设置入口问题","url":"/Android/Android_原生设置入口问题/","content":"\n# 问题引入\n\n> 某沃学习机上面，出现几次系统的动画时长缩放被设置为0，导致应用动画异常。\n\n某沃学习机Android版本：10。\n\n>transition_animation_scale 0.5\n>window_animation_scale 0.5\n>animator_duration_scale 1.0\n\n实际上，这个是开发者选项中才能调整的参数，而且这个设置的入口在定制版系统上屏蔽掉了，不介入第三方应用或者开发工具不会直接打开，所以可能的原因有：\n\n1. 通过开发工具或者第三方应用进入了开发者选项，手动调整参数。\n2. 第三方应用修改了动画时长缩放配置；\n\n针对第一种可能：网上下载了一个[Open Settings(shortcut to settings)](https://apkpure.com/open-settings-shortcut-to-settings/dxidev.openhiddensettings)APK。尝试在某度学习机和某沃学习机上打开，发现，某度进入了厂家定制的设置中，而某沃却轻松地进入了Android的原生设置程序中。\n\n实际上学习机这类产品是不想把原生设置的机会让度给普通用户的，所以，某沃的学习机进不去实属没有周全考虑系统安全性。\n\n经自己模拟开发第三方应用设置参数，排除了第三方应用直接设置的可能，见下文。\n\n# Android Settings中System/Global/Secure\n\nhttps://blog.csdn.net/qq_37580586/article/details/122327215\n\n来电铃声、锁屏时间、日期格式等等这些属性的设置通常有Settings为入口，通过SettingsProvider来进行。SettingsProvider也是所有系统设置的管理者。\n\n在Android 5.0版本之前，SettingsProvider中系统设置是存储在settings.db数据库中；但是在Android 6.0之后，SettingsProvider中系统设置改为由xml存储在data分区。\n\n为何要从settings.db改为xml存储？\n\n1. 这次修改主要涉及到`global`, `secure`, `system`三个表。改为了`settings_global.xml`、`settings_secure.xml`、`settings_system.xml`，对应`/frameworks/base/core/java/android/provider/Settings.java`中的三个内部类：Global、Secure、System。其实还有两个xml，`settings_config.xml`、`settings_ssaid.xml`。\n   1. Global：所有的偏好设置对系统的所有用户公开，第三方APP只读；\n   2. System：包含各种各样的用户偏好系统设置，第三方APP只读；\n   3. Secure：安全性的用户偏好系统设置，第三方APP只读。\n2. 实现方式从之前的数据库，改为异步性能更加优良的xml。\n3. 这次修改主要是基于性能的考量（写入一条耗时从400ms降低为10ms），同时也能够使得保存数据的过程更加可信。\n4. 实际上，使保存数据过程更加可信这一条并不是问题的关键，写入失败的情况非常罕见，而且上层应用修改SettingsProvider设置都是通过SettingsProvider来实现的。所以当上层APP下次再次启动的时候，并不知道数据写入失败。\n5. 从db改为xml以及相应逻辑，可以有效的防止某些恶意APP监听某些设置选项，进而频繁的进行操作。\n6. 每个用户都有自己的一份SettingsProvider设置xml文档。通常位于`/data/system/users/userid/`。\n7. 控制APP针对SettingsProvider的写入，即合法性判断\n8. 控制SettingsProvider的大小（数据量大小，占用内存大小）\n\n其实主要原因就是因为性能、安全两个原因。\n\n# 与SystemProperties对比\n\n`settings_global.xml`、`settings_secure.xml`、`settings_system.xml`，对应`/frameworks/base/core/java/android/provider/Settings.java`中的三个内部类。\n\n它们三个都继承了`NameValueTable`，而NameValueTable都继承了`BaseColumns`。查看`/frameworks/base/core/java/android/provider/BaseColumns.java`可以看到：\n```java\npackage android.provider;\npublic interface BaseColumns {\n    /**\n     * The unique ID for a row.\n     * <P>Type: INTEGER (long)</P>\n     */\n    public static final String _ID = \"_id\";\n\n    /**\n     * The count of rows in a directory.\n     * <P>Type: INTEGER</P>\n     */\n    public static final String _COUNT = \"_count\";\n}\n```\n\nSettings中不论是Global、System还是Secure的数据都由键值对组成的。\n\nSettingsProvider有点类似Android的properties系统（Android属性系统）：SystemProperties。但是SettingsProvider和SystemProperties有以下不同点：\n\n1. 数据保存方式不同：SystemProperties的数据保存属性文件中（`/system/build.prop`等），开机后会被加载到`system properties store`；SettingsProvider的数据保存在文件`/data/system/users/0/settings_***.xml`和数据库`settings.db`中；\n2. 作用范围不同：SystemProperties可以实现跨进程、跨层次调用，即底层的`c/c++`可以调用，java层也可以调用；SettingsProvider只能能在java层（APP）使用；\n3. 公开程度不同：SystemProperties有部分功能上层第三方APP可以使用（对于加了`@hide`标记的第三方APP仅可读，不可修改）；SettingsProvider上层第三方APP不可以使用；\n\n# Settings的修改方式\n\n## adb shell\n\n通过adb shell进行修改，格式为：\n\n```bash\nadb shell settings get [global/system/secure] [key]\nadb shell settings put [global/system/secure] [key] [value]\nadb shell settings list [global/system/secure]\n```\n\n```\nPS C:\\Users\\ThinkPad> adb shell\ntb8788p1_64_wifi:/ # settings put global transition_animation_scale 0.5\ntb8788p1_64_wifi:/ # settings get global transition_animation_scale\n0.5\ntb8788p1_64_wifi:/ # settings list system\naccelerometer_rotation=0\nalarm_alert=content://media/internal/audio/media/35?title=Cesium&canonical=1\nalarm_alert_set=1\nbackground_power_saving_enable=1\ndim_screen=1\ndisplay_paper_mode_activated=0\ndisplay_paper_mode_texture=255\ndtmf_tone=1\ndtmf_tone_type=0\nend_button_behavior=2\nethernet_state=1\ngsensor_change_all_process=0\nhaptic_feedback_enabled=0\nhearing_aid=0\nhide_rotation_lock_toggle_for_accessibility=0\nimport_remove_running=false\nisEthernetOpen=0\nis_ambient_sensor_adjust=1\nis_gravity_sensor_adjust=1\nis_light_sensor_adjust=1\nis_proximity_sensor_adjust=1\nlockscreen_sounds_enabled=0\nmachine_serial_number=62210304000055\nmode_ringer_streams_affected=166\nmute_streams_affected=111\nnotification_light_pulse=1\nnotification_sound=content://media/internal/audio/media/56?title=Pixie%20Dust&canonical=1\nnotification_sound_set=1\nnotification_vibration_intensity=0\npointer_speed=0\nradio.data.stall.recovery.action=0\nring_vibration_intensity=0\nringtone=content://media/internal/audio/media/177?title=Flutey%20Phone&canonical=1\nringtone_set=1\nscreen_brightness=204\nscreen_brightness_for_vr=86\nscreen_brightness_mode=0\nscreen_off_timeout=600000\ns..wo_close_voice_call=1\nshow_password=0\nsound_effects_enabled=1\nstu_fingerprint=.........\nsystem_s..wo_sensor_value_report=1\nsystem_user_login_state=1\ntime_12_24=24\ntty_mode=0\nuser_rotation=0\nvibrate_when_ringing=0\nvoice_trigger_active_command_id=1\nvoice_wakeup_mode=1\nvolume_alarm=5\nvolume_bluetooth_sco=5\nvolume_music=5\nvolume_music_speaker=1\nvolume_music_usb_headset=2\nvolume_notification=5\nvolume_ring=5\nvolume_system=5\nvolume_voice=3\nwebsite_control_state=0\n```\n\n## 应用修改\n\n```java\n// 示例\nimport android.provider.Settings;//需要通过提供器中的settings类修改\nSettings.Global.putString(mContext.getContentResolver(), \"audio_test_result\", value);//修改\nSettings.Global.getString(mContext.getContentResolver(), \"audio_test_result\");//查询\n```\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button\n        android:id=\"@+id/change_button\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"ChangeAppArgs\">\n    </Button>\n</LinearLayout>\n```\n\n```java\nimport android.provider.Settings;\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.change_button);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Settings.Global.putString(getContentResolver(), \"animator_duration_scale\", \"1.0\");\n                String ads = Settings.Global.getString(getContentResolver(), \"animator_duration_scale\");\n                Log.d(\"MainActivity\", \"animator_duration_scale: \" + ads);\n            }\n        });\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.appchangeargtest\">\n    <!-- error: This Permission is only granted to system apps -->\n    <uses-permission android:name=\"android.permission.WRITE_SECURE_SETTINGS\"/>\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.AppChangeArgTest\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n```\n\n提示：`error: This Permission is only granted to system apps`。说明第三方App肯定是无法修改这个动画缩放的，而是系统应用才有权修改，因此也排除了三方应用直接修改动画时长缩放参数。\n\n# 推测如何找到原生设置入口\n\n通过Intent来测试\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.intenttosetting\">\n    <application ...>\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n```\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_height=\"match_parent\"\n    android:layout_width=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/settings\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"SETTINGS\">\n    </Button>\n    <Button\n        android:id=\"@+id/develop_settings\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"APPLICATION_DEVELOPMENT_SETTINGS\">\n    </Button>\n    <Button\n        android:id=\"@+id/accessibility_settings\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"ACCESSIBILITY_SETTINGS\">\n    </Button>\n    <Button\n        android:id=\"@+id/device_info\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"DEVICE_INFO\">\n    </Button>\n    <Button\n        android:id=\"@+id/top_settings\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"top_settings\">\n    </Button>\n\n    <EditText\n        android:id=\"@+id/editText\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:ems=\"10\"\n        android:inputType=\"textPersonName\"\n        android:text=\"packageName\" />\n\n    <EditText\n        android:id=\"@+id/editText2\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:ems=\"10\"\n        android:inputType=\"textPersonName\"\n        android:text=\"className\" />\n\n    <Button\n        android:id=\"@+id/package_class\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"package_class\" />\n\n    <EditText\n        android:id=\"@+id/editText3\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:ems=\"10\"\n        android:inputType=\"textPersonName\"\n        android:text=\"actionName\" />\n\n    <Button\n        android:id=\"@+id/action\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"ACTION\" />\n</LinearLayout>\n```\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button b1 = (Button) findViewById(R.id.settings);\n        b1.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent intent = new Intent(\"android.settings.SETTINGS\");\n                startActivity(intent);\n            }\n        });\n        Button b2 = (Button) findViewById(R.id.develop_settings);\n        b2.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent intent = new Intent(\"com.android.settings.APPLICATION_DEVELOPMENT_SETTINGS\");\n                startActivity(intent);\n            }\n        });\n        Button b3 = (Button) findViewById(R.id.accessibility_settings);\n        b3.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent intent = new Intent(\"android.settings.ACCESSIBILITY_SETTINGS\");\n                startActivity(intent);\n            }\n        });\n        Button b4 = (Button) findViewById(R.id.device_info);\n        b4.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent intent = new Intent(\"android.settings.DEVICE_INFO_SETTINGS\");\n                startActivity(intent);\n            }\n        });\n        Button b5 = (Button) findViewById(R.id.top_settings);\n        b5.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent intent = new Intent();\n                intent.setClassName(\"com.android.settings\", \"com.android.settings.SubSettings\");\n                startActivity(intent);\n            }\n        });\n        Button b_package_class = (Button) findViewById(R.id.package_class);\n        b_package_class.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                EditText t1 = (EditText) findViewById(R.id.editText);\n                EditText t2 = (EditText) findViewById(R.id.editText2);\n                Intent intent = new Intent();\n                intent.setClassName(t1.getText().toString(), t2.getText().toString());\n                startActivity(intent);\n            }\n        });\n        Button b_action = (Button) findViewById(R.id.action);\n        b_action.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                EditText t3 = (EditText) findViewById(R.id.editText3);\n                Intent intent = new Intent(t3.getText().toString());\n                startActivity(intent);\n            }\n        });\n    }\n}\n```\n\n情况如下：\n\n| intent                                                     | 某沃                                                         | 某度                                                         |\n| ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| `android.settings.SETTINGS`                                | 直接进原生设置。                                             | 进厂家设置。                                                 |\n| `com.android.settings.APPLICATION_DEVELOPMENT_SETTINGS`    | 提示请先启用开发者选项。如果处于开发者模式，则直接进。       | 提示请先启用开发者选项。如果处于开发者模式，则直接进。       |\n| `android.settings.ACCESSIBILITY_SETTINGS`                  | 直接进无障碍设置。                                           | 直接进无障碍设置。                                           |\n| `android.settings.DEVICE_INFO_SETTINGS`                    | 直接进关于本机信息，下拉菜单点击若干次版本号，可以进入开发者模式。 | 直接进关于本机信息，下拉菜单点击若干次版本号，可以进入开发者模式。 |\n| `com.android.settings`, `com.android.settings.SubSettings` | 崩溃，日志报错，permission denial, id = 1000。疑似是此操作只有系统应用才可操作。 | 直接进原生设置顶层界面！                                     |\n| 某一子设置项目的左上角返回按键流向                         | 可以返回到设置顶层界面                                       | 经过处理，统一返回到桌面，即不可返回到设置顶层界面。         |\n\n由以上实验，推测，某沃用户可以通过各种第三方应用先转到原生设置下点按版本号进入开发者模式，后进入开发者选项调整动画时长缩放。\n\n由此，为了避免用户进入原生设置进行配置，造成不可预测的异常现象，需要定制一个设置程序，屏蔽掉原生设置的活动入口。有以下几个方向：\n\n1. 把原来action指向的原生设置程序指向厂家定制设置程序。\n\n   ```xml\n   // 以下信息来自.../vendor/mediatek/proprietary/packages/apps/MtkSettings/AndroidManifest.xml\n           <activity android:name=\".homepage.SettingsHomepageActivity\"\n                     android:label=\"@string/settings_label_launcher\"\n                     android:theme=\"@style/Theme.Settings.Home\"\n                     android:launchMode=\"singleTask\">\n               <intent-filter android:priority=\"1\">\n                   <action android:name=\"android.settings.SETTINGS\" />\n                   <category android:name=\"android.intent.category.DEFAULT\" />\n               </intent-filter>\n               <meta-data android:name=\"com.android.settings.PRIMARY_PROFILE_CONTROLLED\"\n                          android:value=\"true\" />\n           </activity>\n   ```\n\n\n# 拦截进入开发者模式\n\n进入版本号界面后，快速连续点按版本号，会显示信息：“现在只需再执行n步操作即可进入开发者模式”。以此为入口，检索这个字符串的代号。\n\n```xml\n~/myProject/DT15/alps/vendor/mediatek/proprietary/packages/apps/MtkSettings/src$ rg \"步操作即可进入开发者模式\" ..\n../res/values-zh-rCN/strings.xml\n26:      <item quantity=\"other\">现在只需再执行 <xliff:g id=\"STEP_COUNT_1\">%1$d</xliff:g> 步操作即可进入开发者模式。</item>\n27:      <item quantity=\"one\">现在只需再执行 <xliff:g id=\"STEP_COUNT_0\">%1$d</xliff:g> 步操作即可进入开发者模式。</item>\n```\n\n可以看到，这个信息的字符串在`.../res/values-zh-rCN/strings.xml`中定义。\n\n```xml\n25     <plurals name=\"show_dev_countdown\" formatted=\"false\" msgid=\"7201398282729229649\">\n26       <item quantity=\"other\">现在只需再执行 <xliff:g id=\"STEP_COUNT_1\">%1$d</xliff:g> 步操作即可进入开发者模式。</item>\n27       <item quantity=\"one\">现在只需再执行 <xliff:g id=\"STEP_COUNT_0\">%1$d</xliff:g> 步操作即可进入开发者模式。</item>\n28     </plurals>\n```\n\n这个字符串的name为`show_dev_countdown`，顺藤摸瓜。\n\n```\n~/myProject/DT15/alps/vendor/mediatek/proprietary/packages/apps/MtkSettings/src/com$ rg show_dev_countdown\nandroid/settings/deviceinfo/BuildNumberPreferenceController.java\n196:                                R.plurals.show_dev_countdown, mDevHitCountdown,\n```\n\n可以看到，输出此字符串的代码文件只有一个，`BuildNumberPreferenceController.java`，拦截进入开发者模式的解决之道则聚焦在了此文件上。\n\n# 原生设置入口跳转\n\n```java\npublic class SettingsHomepageActivity extends FragmentActivity {\n    private static final String TAG = SettingsHomepageActivity.class.getSimpleName();\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        String password = getIntent().getStringExtra(\"password\");\n        if(password != null && password.equals(\".........\")) {\n            Log.w(TAG, \"Origin Action\");\n            setContentView(R.layout.settings_homepage_container);\n            final View root = findViewById(R.id.settings_homepage_container);\n            root.setSystemUiVisibility(\n                    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\n\n            setHomepageContainerPaddingTop();\n\n            final Toolbar toolbar = findViewById(R.id.search_action_bar);\n            FeatureFactory.getFactory(this).getSearchFeatureProvider()\n                    .initSearchToolbar(this /* activity */, toolbar, SettingsEnums.SETTINGS_HOMEPAGE);\n\n            final ImageView avatarView = findViewById(R.id.account_avatar);\n            final AvatarViewMixin avatarViewMixin = new AvatarViewMixin(this, avatarView);\n            getLifecycle().addObserver(avatarViewMixin);\n\n            if (!getSystemService(ActivityManager.class).isLowRamDevice()) {\n                // Only allow contextual feature on high ram devices.\n                showFragment(new ContextualCardsFragment(), R.id.contextual_cards_content);\n            }\n            showFragment(new TopLevelSettings(), R.id.main_content);\n            ((FrameLayout) findViewById(R.id.main_content))\n                    .getLayoutTransition().enableTransitionType(LayoutTransition.CHANGING);\n        } else {\n            Log.w(TAG, \"s..wo's Action\");\n            Intent intent = new Intent();\n            intent.setClassName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\");\n            startActivity(intent);\n            finish();\n        }\n    }\n    // ...\n}\n```\n\n# 版本信息入口屏蔽\n\n目的是隐藏设置主页面最下面的“关于平板电脑”子项目。\n\n在源码目录中检索“关于平板电脑”一词。发现此属性名为\"`about_settings`\"\n\n```\n<string name=\"about_settings\" product=\"tablet\" msgid=\"593457295516533765\">\"关于平板电脑\"</string>\n<string name=\"about_settings\" product=\"default\" msgid=\"1743378368185371685\">\"关于手机\"</string>\n<string name=\"about_settings\" product=\"device\" msgid=\"6717640957897546887\">\"关于设备\"</string>\n```\n\n在源码目录中检索“`about_settings`”一词。发现在AndroidManifest.xml中被引用\n\n```\nvendor/mediatek/proprietary/packages/apps/MtkSettings/AndroidManifest.xml\n1009:                  android:label=\"@string/about_settings\"\n```\n\nAndroidManifest.xml中涉及关于设备信息的完整部分：\n\n```xml\n        <activity android:name=\".Settings$MyDeviceInfoActivity\"\n                  android:label=\"@string/about_settings\"\n                  android:icon=\"@drawable/ic_homepage_about\">\n            <intent-filter android:priority=\"1\">\n                <action android:name=\"android.settings.DEVICE_INFO_SETTINGS\" />\n                <action android:name=\"android.settings.DEVICE_NAME\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n            <intent-filter android:priority=\"71\">\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"com.android.settings.SHORTCUT\" />\n            </intent-filter>\n            <meta-data android:name=\"com.android.settings.FRAGMENT_CLASS\"\n                       android:value=\"com.android.settings.deviceinfo.aboutphone.MyDeviceInfoFragment\" />\n            <meta-data android:name=\"com.android.settings.PRIMARY_PROFILE_CONTROLLED\"\n                       android:value=\"true\" />\n        </activity>\n```\n\n说明，屏蔽版本信息入口后，依然可以通过“`adb shell am start -a android.settings.DEVICE_INFO_SETTINGS`”进入版本信息界面。\n\n接着检索`android.settings.DEVICE_INFO_SETTINGS`。\n\n```\nframeworks/base/core/java/android/provider/Settings.java\n\n    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)\n    public static final String ACTION_DEVICE_INFO_SETTINGS =\n        \"android.settings.DEVICE_INFO_SETTINGS\";\n```\n\n检索`ACTION_DEVICE_INFO_SETTINGS`。\n\n```\nframeworks/base/core/java/android/provider/Settings.java\n1177:    public static final String ACTION_DEVICE_INFO_SETTINGS =\n\ndevelopment/apps/BuildWidget/src/com/android/buildwidget/BuildWidget.java\n69:                    new Intent(android.provider.Settings.ACTION_DEVICE_INFO_SETTINGS),\n\nframeworks/base/core/tests/coretests/src/android/provider/SettingsProviderTest.java\n339:        assertCanBeHandled(new Intent(Settings.ACTION_DEVICE_INFO_SETTINGS));\n\ncts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/IntentFiltersTestHelper.java\n73:                new Intent(Settings.ACTION_DEVICE_INFO_SETTINGS),\n\ncts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/UserRestrictions.java\n125:            Settings.ACTION_DEVICE_INFO_SETTINGS,\n127:            Settings.ACTION_DEVICE_INFO_SETTINGS,\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/uitests/src/com/android/settings/ui/AboutPhoneSettingsTests.java\n76:        launchAboutPhoneSettings(Settings.ACTION_DEVICE_INFO_SETTINGS);\n```\n\n```\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/core/gateway/SettingsGateway.java\n```\n\n\n\n# 应用信息打开按钮屏蔽\n\n全局搜索“打开”。\n\n1. `mtk_strings.xml: vendor/mediatek/proprietary/packages/apps/Mms/res/values-zh-rCN`\n2. `strings.xml: vendor/mediatek/proprietary/frameworks/base/res/res/values-zh-rCN`\n\n```\n<string name=\"launch_instant_app\" msgid=\"391581144859010499\">\"打开\"</string>\n```\n\n全局搜索“强行停止”\n\n1. `strings.xml: vendor/mediatek/proprietary/frameworks/apps/MtkSettings/res/values-zh-rCN`\n   1. 649958863744041872\n   2. 7435006169872876756\n\n# 修改的文件\n\n`DT15/alps/vendor/mediatek/proprietary/packages/apps/MtkSettings`\n\n进入android.settings.SETTINGS时会判断调用者或校验extra参数；进入设备信息页面时会判断调用者；去除应用信息页面中“打开”的按钮；\n\n```git\n[feature][SettingsEntryBlock] Intercept the entry of AOSP config\n\n[what] 1. when intent to AOSP settings page, it will judge the caller or verify extra parameters; 2. when intent to the AOSP device info page, it will judge the caller; 3. remove the \"Open\" button in the ASOP app info page;\n[why] avoid user mistakenly or deliberately configure parameters to cause exceptions\n[how] modify intent logic; hide entries\n```\n\n## AppButtonsPreferenceController.java\n\n`src/com/android/settings/applications/appinfo/AppButtonsPreferenceController.java`\n\n```java\n@@ -169,9 +169,10 @@ public class AppButtonsPreferenceController extends BasePreferenceController imp\n         if (isAvailable()) {\n             mButtonsPref = ((ActionButtonsPreference) screen.findPreference(\n                     KEY_ACTION_BUTTONS))\n-                    .setButton1Text(R.string.launch_instant_app)\n-                    .setButton1Icon(R.drawable.ic_settings_open)\n-                    .setButton1OnClickListener(v -> launchApplication())\n+                    //.setButton1Text(R.string.launch_instant_app)\n+                    //.setButton1Icon(R.drawable.ic_settings_open)\n+                    //.setButton1OnClickListener(v -> launchApplication())\n+                    .setButton1Visible(false)\n                     .setButton2Text(R.string.uninstall_text)\n                     .setButton2Icon(R.drawable.ic_settings_delete)\n                     .setButton2OnClickListener(new UninstallAndDisableButtonListener())\n```\n\n## SettingsGateway.java【去除版本号入口】\n\n`src/com/android/settings/core/gateway/SettingsGateway.java`\n\n```java\n@@ -190,7 +190,7 @@ public class SettingsGateway {\n             UserDictionaryList.class.getName(),\n             UserDictionarySettings.class.getName(),\n             DisplaySettings.class.getName(),\n-            MyDeviceInfoFragment.class.getName(),\n+            //MyDeviceInfoFragment.class.getName(),\n             ModuleLicensesDashboard.class.getName(),\n             ManageApplications.class.getName(),\n             FirmwareVersionSettings.class.getName(),\n```\n\n## SettingsHomepageActivity.java\n\n`src/com/android/settings/homepage/SettingsHomepageActivity.java`\n\n```java\nimport android.util.Log;\n\n@@ -37,33 +39,42 @@ import com.android.settings.homepage.contextualcards.ContextualCardsFragment;\n import com.android.settings.overlay.FeatureFactory;\n \n public class SettingsHomepageActivity extends FragmentActivity {\n-\n+    private static final String TAG = SettingsHomepageActivity.class.getSimpleName();\n     @Override\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n-\n-        setContentView(R.layout.settings_homepage_container);\n-        final View root = findViewById(R.id.settings_homepage_container);\n-        root.setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\n-\n-        setHomepageContainerPaddingTop();\n-\n-        final Toolbar toolbar = findViewById(R.id.search_action_bar);\n-        FeatureFactory.getFactory(this).getSearchFeatureProvider()\n-                .initSearchToolbar(this /* activity */, toolbar, SettingsEnums.SETTINGS_HOMEPAGE);\n-\n-        final ImageView avatarView = findViewById(R.id.account_avatar);\n-        final AvatarViewMixin avatarViewMixin = new AvatarViewMixin(this, avatarView);\n-        getLifecycle().addObserver(avatarViewMixin);\n-\n-        if (!getSystemService(ActivityManager.class).isLowRamDevice()) {\n-            // Only allow contextual feature on high ram devices.\n-            showFragment(new ContextualCardsFragment(), R.id.contextual_cards_content);\n+        String password = getIntent().getStringExtra(\"password\");\n+        if(password != null && password.equals(\".........\")) {\n+            Log.w(TAG, \"Origin Action\");\n+            setContentView(R.layout.settings_homepage_container);\n+            final View root = findViewById(R.id.settings_homepage_container);\n+            root.setSystemUiVisibility(\n+                    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);\n+\n+            setHomepageContainerPaddingTop();\n+\n+            final Toolbar toolbar = findViewById(R.id.search_action_bar);\n+            FeatureFactory.getFactory(this).getSearchFeatureProvider()\n+                    .initSearchToolbar(this /* activity */, toolbar, SettingsEnums.SETTINGS_HOMEPAGE);\n+\n+            final ImageView avatarView = findViewById(R.id.account_avatar);\n+            final AvatarViewMixin avatarViewMixin = new AvatarViewMixin(this, avatarView);\n+            getLifecycle().addObserver(avatarViewMixin);\n+\n+            if (!getSystemService(ActivityManager.class).isLowRamDevice()) {\n+                // Only allow contextual feature on high ram devices.\n+                showFragment(new ContextualCardsFragment(), R.id.contextual_cards_content);\n+            }\n+            showFragment(new TopLevelSettings(), R.id.main_content);\n+            ((FrameLayout) findViewById(R.id.main_content))\n+                    .getLayoutTransition().enableTransitionType(LayoutTransition.CHANGING);\n+        } else {\n+            Log.w(TAG, \"s..wo's Action\");\n+            Intent intent = new Intent();\n+            intent.setClassName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\");\n+            startActivity(intent);\n+            finish();\n         }\n-        showFragment(new TopLevelSettings(), R.id.main_content);\n-        ((FrameLayout) findViewById(R.id.main_content))\n-                .getLayoutTransition().enableTransitionType(LayoutTransition.CHANGING);\n     }\n```\n\n## MyDeviceInfoFragment.java\n\n`com/android/settings/deviceinfo/aboutphone/MyDeviceInfoFragment.java`\n\n```java\nimport android.widget.Toast;\n    @Override\n    public void onAttach(Context context) {\n        super.onAttach(context);\n        if(\"android-app://com.android.settings\".equals(this.getActivity().getReferrer().toString()))\n        {\n            use(ImeiInfoPreferenceController.class).setHost(this /* parent */);\n            use(DeviceNamePreferenceController.class).setHost(this /* parent */);\n            mBuildNumberPreferenceController = use(BuildNumberPreferenceController.class);\n            mBuildNumberPreferenceController.setHost(this /* parent */);\n        } else {\n            Toast.makeText(context, R.string.cannot_into_device_info, Toast.LENGTH_SHORT).show();\n            finish();\n        }\n    }\n```\n\n## strings.xml\n\n`vendor/mediatek/proprietary/packages/apps/MtkSettings/res/values/strings.xml`\n\n```\n<string name=\"cannot_into_device_info\">Only debuggers can access the Device-Info Page</string>\n```\n\n`vendor/mediatek/proprietary/packages/apps/MtkSettings/res/values-zh-rCN/strings.xml`\n\n```\n<string name=\"cannot_into_device_info\" msgid=\"2196318436963951285\">非调试者无法进入版本信息页面</string>\n```\n\n## 编译冲突\n\n`vendor/mediatek/proprietary/packages/apps/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java`\n\n# 日志\n\n```\ndevelopment/apps/Fallback/AndroidManifest.xml\n55:                             <action android:name=\"android.settings.SETTINGS\" />\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/AndroidManifest.xml\n160:                <action android:name=\"android.settings.SETTINGS\" />\n\nframeworks/base/core/java/android/provider/Settings.java\n122:    public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\ncts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java\n633:            executeShellCommand(\"am start -a android.settings.SETTINGS\");\n\ndevelopment/samples/MultiWindow/src/com/example/android/multiwindow/LaunchingAdjacentActivity.java\n53:                Intent intent = new Intent(\"android.settings.SETTINGS\");\n\nvendor/mediatek/proprietary/operator/packages/apps/Browser/OP07/src/com/mediatek/op07/browser/OP07NetworkStateHandlerExt.java\n158:                Intent intent = new Intent(\"android.settings.SETTINGS\");\n```\n\n\n\n\n\n```\nframeworks/base/api/current.txt\n38705:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\ndevelopment/apps/Fallback/AndroidManifest.xml\n55:                             <action android:name=\"android.settings.SETTINGS\" />\n\nprebuilts/sdk/5/public/api/android.txt\n11335:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/7/public/api/android.txt\n11389:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/2/public/api/android.txt\n7654:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/6/public/api/android.txt\n11342:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/12/public/api/android.txt\n15925:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/10/public/api/android.txt\n13613:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/22/public/api/android.txt\n25214:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/22/system/api/android.txt\n26813:    field public static final java.lang.String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/25/public/api/android.txt\n32341:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/25/system/api/android.txt\n35173:    field public static final java.lang.String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/8/public/api/android.txt\n12573:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/11/public/api/android.txt\n15541:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/17/public/api/android.txt\n18754:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/20/public/api/android.txt\n21186:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/28/public/api/android.txt\n36463:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/15/public/api/android.txt\n17382:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/21/public/api/android.txt\n25141:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/14/public/api/android.txt\n17255:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/3/public/api/android.txt\n8708:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/1/public/api/android.txt\n7650:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/13/public/api/android.txt\n16020:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/19/public/api/android.txt\n21028:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/18/public/api/android.txt\n19874:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/4/public/api/android.txt\n9945:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/27/public/api/android.txt\n34744:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/24/public/api/android.txt\n32236:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/27/system/api/android.txt\n37925:    field public static final java.lang.String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/23/public/api/android.txt\n26448:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/24/system/api/android.txt\n35019:    field public static final java.lang.String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/23/system/api/android.txt\n28511:    field public static final java.lang.String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/29/public/api/android.txt\n38674:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/9/public/api/android.txt\n13384:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/16/public/api/android.txt\n18326:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/26/public/api/android.txt\n34646:    field public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nprebuilts/sdk/26/system/api/android.txt\n37772:    field public static final java.lang.String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nframeworks/opt/setupwizard/tools/docs/android-22.txt\n25229:    field public static final java.lang.String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/AndroidManifest.xml\n160:                <action android:name=\"android.settings.SETTINGS\" />\n\nexternal/autotest/client/common_lib/cros/arc.py\n657:    output = adb_shell('am start -W -a android.settings.SETTINGS')\n\nframeworks/base/core/java/android/provider/Settings.java\n122:    public static final String ACTION_SETTINGS = \"android.settings.SETTINGS\";\n\nout/target/common/obj/APPS/MtkSettings_intermediates/manifest/AndroidManifest.xml.fixed\n141:                <action android:name=\"android.settings.SETTINGS\"/>\n\nout/target/common/obj/APPS/MtkSettings_intermediates/manifest/AndroidManifest.xml\n168:                <action android:name=\"android.settings.SETTINGS\" />\n\ncts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java\n633:            executeShellCommand(\"am start -a android.settings.SETTINGS\");\n\ndevelopment/samples/MultiWindow/src/com/example/android/multiwindow/LaunchingAdjacentActivity.java\n53:                Intent intent = new Intent(\"android.settings.SETTINGS\");\n\nvendor/mediatek/proprietary/operator/packages/apps/Browser/OP07/src/com/mediatek/op07/browser/OP07NetworkStateHandlerExt.java\n158:                Intent intent = new Intent(\"android.settings.SETTINGS\");\n\n```\n\n```\nxurui@ubuntu:~/myProject/DT15/alps$\nrg 'package com.android.settings;' . -j56\n./external/flatbuffers/.gitignore: line 114: error parsing glob '.corpus**': invalid use of **; must be one path component\n./external/flatbuffers/.gitignore: line 115: error parsing glob '.seed**': invalid use of **; must be one path component\nout/target/common/R/com/android/settings/Manifest.java\n8:package com.android.settings;\n\nout/target/common/R/com/android/settings/R.java\n8:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ProgressCategoryBase.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/CustomListPreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SummaryPreference.java\n15:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/DateTimeSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/LinkifyUtils.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/CancellablePreference.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/TestingSettingsBroadcastReceiver.java\n1:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/EncryptionInterstitial.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/AccessiblePreferenceCategory.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SettingsDumpService.java\n15:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ProgressCategory.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/DisplaySettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/BrightnessPreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/TestingSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/BandMode.java\n1:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/HelpTrampoline.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SetFullBackupPassword.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/MasterClearConfirm.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SettingsLicenseActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/MonitoringCertInfoActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/AirplaneModeEnabler.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ResetNetworkConfirm.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ResetNetwork.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/TrustedCredentialsDialogBuilder.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ActivityPicker.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/IccLockSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/FallbackHome.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SetupWizardUtils.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ManualDisplayActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RingtonePreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/DialogCreatable.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RestrictedCheckBox.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SetupRedactionInterstitial.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RadioInfo.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/MasterClear.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/CryptKeeper.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RegulatoryInfoDisplayActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SelfAvailablePreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/AirplaneModeVoiceActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/Utils.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RestrictedSettingsFragment.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/TetherSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/DefaultRingtonePreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SetupEncryptionInterstitial.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/UsageStatsActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/AppWidgetLoader.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/TouchBlockingFrameLayout.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RestrictedRadioButton.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SubSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/EditPinPreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/Settings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/UserCredentialsSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SeekBarDialogPreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SettingsInitialize.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/PointerSpeedPreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SettingsActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/BugreportPreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/AllowBindAppWidgetActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/CheckableLinearLayout.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/CryptKeeperConfirm.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ButtonBarHandler.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SettingsPreferenceFragment.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/SettingsTutorialDialogWrapperActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RestrictedListPreference.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/RemoteBugreportActivity.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/LegalSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/TrustedCredentialsSettings.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/AppWidgetPickActivity.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/ProxySelector.java\n17:package com.android.settings;\n\nout/target/common/obj/APPS/MtkSettings_intermediates/srcjars/com/android/settings/Manifest.java\n8:package com.android.settings;\n\nout/target/common/obj/APPS/MtkSettings_intermediates/srcjars/com/android/settings/R.java\n8:package com.android.settings;\n\nout/target/common/obj/APPS/MtkSettings_intermediates/aapt2/com/android/settings/Manifest.java\n8:package com.android.settings;\n\nout/target/common/obj/APPS/MtkSettings_intermediates/aapt2/com/android/settings/R.java\n8:package com.android.settings;\n\nout/target/common/obj/JAVA_LIBRARIES/settings-logtags_intermediates/logtags/src/com/android/settings/EventLogTags.java\n5:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/HelpTrampolineTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/TetherSettingsTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/unit/src/com/android/settings/UserCredentialsTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/unit/src/com/android/settings/UtilsTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/RestrictedSettingsFragmentTest.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/unit/src/com/android/settings/RegulatoryInfoDisplayActivityTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SettingsDumpServiceTest.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SetupWizardUtilsTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/RestrictedListPreferenceTest.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/UtilsTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SettingsActivityTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/TestUtils.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/LegalSettingsTest.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/ResetNetworkConfirmTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SettingsPreferenceFragmentTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/RegulatoryInfoDisplayActivityTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SettingsDialogFragmentTest.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/MasterClearConfirmTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/DisplaySettingsTest.java\n1:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/ResetNetworkTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SettingsLicenseActivityTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SummaryPreferenceTest.java\n16:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/SettingsInitializeTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/MasterClearTest.java\n17:package com.android.settings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/unit/src/com/android/settings/notification/ZenModeSettingsIntegrationTest.java\n1:package com.android.settings;\n\n```\n\n```\nxurui@ubuntu:~/myProject/DT15/alps$\nrg 'com.s..wo.eclass.settings' . -j56\n./external/flatbuffers/.gitignore: line 114: error parsing glob '.corpus**': invalid use of **; must be one path component\n./external/flatbuffers/.gitignore: line 115: error parsing glob '.seed**': invalid use of **; must be one path component\nframeworks/base/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java\n624:                                      \"com.s..wo.eclass.settings\",\n\nvendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/custom/UtilsAc.java\n37:                new ComponentName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\"));\n49:                new ComponentName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\"));\n61:                new ComponentName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\"));\n88:                new ComponentName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\"));\n98:                new ComponentName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\"));\n161:            intent.setClassName(\"com.s..wo.eclass.settings\", \"com.s..wo.eclass.settings.SettingsActivity\");\n\n```\n\n```\nout/target/common/obj/APPS/MtkSettings_intermediates/proguard_dictionary\n21825:com.android.settings.SubSettings -> com.android.settings.SubSettings:\n\nout/target/common/obj/APPS/MtkSettings_intermediates/manifest/AndroidManifest.xml\n216:            android:name=\"com.android.settings.SubSettings\"\n\nvendor/mediatek/proprietary/hardware/power/config/mt6739/app_list/power_app_cfg.xml\n25:            <Activity name=\"com.android.settings.SubSettings\">\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/location/LocationSlice.java\n38:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/core/SubSettingLauncher.java\n31:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/core/SettingsBaseActivity.java\n42:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/bluetooth/BluetoothSliceBuilder.java\n37:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/panel/NfcPanel.java\n25:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/search/SearchResultTrampoline.java\n27:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/panel/WifiPanel.java\n25:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/slices/SliceBuilderUtils.java\n47:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/notification/ZenModeSliceBuilder.java\n38:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/wifi/slice/WifiSlice.java\n49:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/biometrics/fingerprint/FingerprintSettings.java\n51:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/homepage/contextualcards/deviceinfo/DataUsageSlice.java\n37:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/homepage/contextualcards/slices/NotificationChannelSlice.java\n49:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/homepage/contextualcards/slices/BatteryFixSlice.java\n45:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/homepage/contextualcards/slices/LowStorageSlice.java\n34:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/homepage/contextualcards/deviceinfo/DeviceInfoSlice.java\n37:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/homepage/contextualcards/slices/BluetoothDevicesSlice.java\n37:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/src/com/android/settings/homepage/contextualcards/deviceinfo/StorageSlice.java\n34:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/datausage/DataUsageSummaryPreferenceTest.java\n45:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/deviceinfo/storage/UserProfileControllerTest.java\n39:import com.android.settings.SubSettings;\n\nvendor/mediatek/proprietary/packages/apps/MtkSettings/tests/robotests/src/com/android/settings/deviceinfo/storage/StorageItemPreferenceControllerTest.java\n52:import com.android.settings.SubSettings;\n\n```\n\n","categories":["Android"]},{"title":"Android_多线程和异步编程","url":"/Android/Android_多线程和异步编程/","content":"\n# 服务\n\n服务是Android中实现程序后台运行的解决方案，适合不需要和用户交互而且长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。不过需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况。\n\n# Android多线程编程\n\n当我们需要执行一些耗时操作，比如说发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求，如果不将这类操作放在子线程里去运行，就会导致主线程被阻塞住，从而影响用户对软件的正常使用。\n\n## 线程的基本用法\n\n### 继承Thread\n\nAndroid多线程编程其实并不比Java多线程编程特殊，基本都是使用相同的语法。比如说，定义一个线程只需要新建一个类继承自Thread，然后重写父类的run方法，并在里面编写耗时逻辑即可，如下所示：\n\n```java\nclass MyThread extends Thread {\n    @Override\n    public void fun() {\n        // 处理具体的逻辑\n    }\n}\n```\n\n那么该如何启动这个线程呢？其实很简单，只需要new出MyThread的实例，然后调用它的start方法，这样run方法中的代码就会在子线程当中运行了，如下所示：\n\n```java\nnew MyThread().start();\n```\n\n### 实现接口Runnable\n\n当然，使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现Runnable接口的方式来定义一个线程，如下所示：\n\n```java\nclass MyThread implements Runnable {\n    @Override\n    public void run() {\n        // 处理具体的逻辑\n    }\n}\n```\n\n如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示：\n\n```java\nMyThread myThread = new MyThread();\nnew Thread(myThread).start();\n```\n\n可以看到，Thread的构造函数接收一个Runnable参数，而我们new出的MyThread正是一个实现了Runnable接口的对象，所以可以直接将它传人到Thread的构造函数里。接着调用Thread的start方法，run方法中的代码就会在子线程当中运行了。\n\n### 匿名类\n\n如果你不想专门再定义一个类去实现Runnable接口，也可以使用匿名类的方式，这种写法更为常见。如下所示：\n\n```java\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        // 处理具体的逻辑\n    }\n}).start();\n```\n\n以上几种线程的使用方式在Java中创建和启动线程也是使用同样的方式。了解线程的基本用法后，下面我们来看一下Android多线程编程与Java多线程编程不同的地方。\n\n# 子线程中更新UI\n\n和许多其他的GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，则必须在主线程中进行，否则就会出现异常。眼见为实，通过一个具体的例子来验证一下。新建一个AndroidThreadTest项目，然后修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button\n        android:id=\"@+id/change_text\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Change Text\">\n    </Button>\n    <TextView\n        android:id=\"@+id/text\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\"\n        android:text=\"Hello world\"\n        android:textSize=\"20sp\">\n    </TextView>\n</RelativeLayout>\n```\n\n布局文件中定义了两个控件，TextView用于在屏幕的正中央显示一个Hello world字符串，Button用于改变TextView中显示的内容，我们希望在点击Button后可以把TextView中显示的字符串改成Nice to meet you。\n\n接下来修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private TextView text;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        text = (TextView) findViewById(R.id.text);\n        Button changeText = (Button) findViewById(R.id.change_text);\n        changeText.setOnCLickListener(this);\n    }\n    @Override\n    public void onCLick(View v) {\n        switch(v.getId()) {\n            case R.id.change_text:\n                new Thread(new Runnable() {\n                    @Override\n                    public void run(){\n                        text.setText(\"Nice to meet you\");\n                    }\n                }).start();\n                break;\n            default:\n                break;\n        }\n    }\n}\n```\n\n可以看到，我们在Change Text按钮的点击事件里面开启了一个子线程，然后在子线程中调用TextView的setText方法将显示的字符串改成Nice to meet you。代码的逻辑非常简单，只不过我们是在子线程中更新UI的。现在运行一下程序并点击Change Text按钮，程序果然崩溃。\n\nlogcat错误日志：\n\n```\nandroid.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.\n```\n\n# 安卓异步消息处理机制\n\n由此证实了Android确实是不允许在子线程中进行UI操作的。但是有些时候必须在子线程里去执行一些耗时任务，然后根据任务的执行结果来更新相应的UI控件。对于这种情况，Android提供了一套异步消息处理机制，完美地解决了在子线程中进行UI操作的问题。\n\n修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    public static final int UPDATE_TEXT = 1;\n    private TextView text;\n    private Handler handler = new Handler() {\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case UPDATE_TEXT:\n                    // 可以在这里进行UI操作\n                    text.setText(\"Nice to meet you\");\n                    break;\n                default:\n                    break;\n            }\n        }\n    };\n    ...\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.change_text:\n                new Thread(new Runnable() {\n                    @Override\n                    public void run() {\n                        Message message = new Message();\n                        message.what = UPDATE_TEXT;\n                        handler.sendMessage(message); // 将Message对象发送出去\n                    }\n                }).start();\n                break;\n            default:\n                break;\n        }\n    }\n}\n```\n\n这里我们先是定义了一个整型常量`UPDATE_TEXT`，用于表示更新TextView这个动作。然后新增一个Handler对象，并重写父类的`handleMessage`方法，在这里对具体的Message进行处理。如果发现Message的what字段的值等于UPDATE_TEXT，就将TextView显示的内容改成Nice to meet you。\n\n下面再来看一下Change Text按钮的点击事件中的代码。可以看到，这次我们并没有在子线程里直接进行UI操作，而是创建了一个Message( android.os.Message)对象，并将它的what字段的值指定为`UPDATE_TEXT`，然后调用Handler的sendMessage方法将这条Message发送出去。很快，Handler就会收到这条Message，并在handleMessage方法中对它进行处理。注意此时handleMessage方法中的代码就是在主线程当中运行的了，所以我们可以放心地在这里进行UI操作。接下来对Message携带的what字段的值进行判断，如果等于UPDATE_TEXT，就将TextView显示的内容改成Nice to meet you。\n\n这样就已经掌握了Android异步消息处理的基本用法，使用这种机制就可以出色地解决掉在子线程中更新UI的问题（其实本质上是子线程发消息给主线程，主线程更新UI）。下面我们就来分析一下Android异步消息处理机制到底是如何工作的。\n\n## 原理\n\nAndroid中的异步消息处理主要由4个部分组成：Message、Handler、MessageQueue和Looper。\n1. Message\n  1. Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。上一小节中我们使用到了Message的what字段，除此之外还可以使用arg1和arg2字段来携带一些整型数据，使用obj字段携带一个Object对象。\n2. Handler\n  1. Handler顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用Handler的sendMessage方法，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage方法中。\n3. MessageQueue\n  1. MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。\n4. Looper\n  1. Looper是每个线程中的MessageQueue的管家，调用Looper的Loop方法后，就会进入到一个无限循环当中，然后每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage方法中。每个线程中也只会有一个Looper对象。\n\n了解了Message、Handler、MessageOueue以及Looper的基本概念后，我们再来把异步消息处理的整个流程梳理一遍。首先需要在主线程当中创建一个Handler对象，并重写handLeMessage方法。然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler将这条消息发送出去。之后这条消息会被添加到MessageQueue的队列中等待被处理，而Looper则会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler的handleMessage方法中。由于Handler是在主线程中创建的，所以此时handleMessage方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行UI操作了。整个异步消息处理机制的流程如图所示。\n\n![image-20220817202437951](../../images/Android_Service/image-20220817202437951.png)\n\n# 使用AsyncTask\n\n不过为了更加方便我们在子线程中对UI进行操作，Android还提供了另外一些好用的工具，比如AsyncTask。借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask背后的实现原理也是基于异步消息处理机制的，只是Android帮我们做了很好的封装而已。首先来看一下AsyncTask的基本用法，由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定3个泛型参数，这3个参数的用途如下。\n\n1. Params。在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。\n2. Progress。后台任务执行时、如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。\n3. Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。\n\n因此，一个最简单的自定义AsyncTask就可以写成如下方式：\n\n```java\nclass DownloadTask extends AsyncTask<Void, Integer, Boolean> {\n    ...\n}\n```\n\n这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。\n\n当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下4个。\n\n1. `onPreExecute()`\n   1. 这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。\n2. `doInBackground(Params...)`\n   1. 这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Void就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用`publishProgress(Progress...)`方法来完成。\n3. `onProgressUpdate(Progress...)`\n   1. 当在后台任务中调用了`publishProgress(Progress...)`方法后，`onProgressUpdate(Progress...)`方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。\n4. `onPostExecute(Result)`\n   1. 当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 U操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。\n\n因此，一个比较完整的自定义AsyncTask就可以写成如下方式：\n\n```java\nclass DownloadTask extends AsyncTask<Void, Integer, Boolean> {\n    @Override\n    protected void onPreExecute() {\n        progressDialog.show(); // 显示进度对话框\n    }\n    @Override\n    protected Boolean doInBackground(Void... params) {\n        try {\n            while (true) {\n                int downloadPercent = doDownload();\n                publishProgress(downloadPercent);\n                if(downloadPercent >= 100) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n    @Override\n    protected void onProgressUpdate(Integer... values) {\n        // 在这里更新下载进度\n        progressDialog.setMessage(\"Download \" + values[0] + \"%\");\n    }\n    @Override\n    protected void onPostExecute(Boolean result) {\n        progressDialog.dismiss(); // 关闭进度对话框\n        // 在这里提示下载结果\n        if (result) {\n            Toast.makeText(context, \"Download succeeded\", Toast.LENGTH_SHORT).show();\n        } else {\n            Toast.makeText(context, \"Download failed\", Toast.LENGTH_SHORT).show();\n        }\n    }\n}\n```\n\n在这个DownloadTask中，我们在doInBackground方法里去执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响到主线程的运行。注意这里虚构了一个doDownload方法，这个方法用于计算当前的下载进度并返回，我们假设这个方法已经存在了在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上了，由于doInBackground方法是在子线程中运行的，在这里肯定不能进行UI操作，所以我们可以调用publishProgress方法并将当前的下载进度传进来，这样onProgressUpdate方法就会很快被调用，在这里就可以进行UI操作了。\n\n当下载完成后，doInBackground方法会返回一个布尔型变量，这样onPostExecute方法就会很快被调用，这个方法也是在主线程中运行的。然后在这里我们会根据下载的结果来弹出相应的Toast提示，从而完成整个DownloadTask任务。\n\n简单来说，使用AsyncTask的诀窍就是，在doInBackground方法中执行具体的耗时任务。在onProgressUpdate方法中进行UI操作，在onPostExecute方法中执行一些任务的收尾工作。\n\n如果想要启动这个任务，只需编写以下代码即可：\n\n```java\nnew DownLoadTask().execute();\n```\n\n\n以上就是AsyncTask的基本用法，我们并不需要去考虑什么异步消息处理机制，也不需要专门使用一个Handler来发送和接收消息。只需要调用一下publishProgress方法，就可以轻松地从子线程切换到UI线程了。\n","categories":["Android","操作系统","多线程"]},{"title":"Android_ContentProvider","url":"/Android/Android_ContentProvider/","content":"\n# 为了跨程序共享数据\n\n对于Android数据持久化技术，包括文件存储、SharedPreferences存储以及数据库存储，这些持久化技术所保存的数据都只能在当前应用程序中访问。虽然文件和SharedPreferences存储中提供了 `MODE_WORLD_READABLE`和`MODE_WORLD_WRITEABLE`这两种操作模式，用于供给其他的应用程序访问当前应用的数据，但这两种模式在Android 4.2版本中都已被废弃了。因为Android官方已经不再推荐使用这种方式来实现跨程序数据共享的功能，而是应该使用更加安全可靠的**内容提供器(ContentProvider)**技术。\n\n为什么要将我们程序中的数据共享给其他程序呢？当然，这个是要视情况而定的，比如说账号和密码这样的隐私数据显然是不能共享给其他程序的，不过一些可以让其他程序进行二次开发的基础性数据，我们还是可以选择将其共享的。例如系统的电话簿程序，它的数据库中保存了很多的联系人信息，如果这些数据都不允许第三方的程序进行访问的话，恐怕很多应用的功能都要大打折扣了。除了电话簿之外，还有短信、媒体库等程序都实现了跨程序数据共享的功能，而使用的技术当然就是内容提供器了，下面就来对这一技术进行深入的探讨。\n\n# 运行时权限\n\n内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。\n\n目前，使用内容提供器是Android实现跨程序共享数据的标准方式。\n\n不同于文件存储和SharedPreferences存储中的两种全局可读写操作模式，内容提供器可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不会有泄漏的风险。\n\n在正式开始学习内容提供器之前，需要先掌握另外一个非常重要的知识——Android运行时权限，因为内容提供器会使用到运行时权限的功能。当然不光是内容提供器用到。\n\nAndroid的**权限机制**从第一个版本开始就已经存在了。但其实之前Android的权限机制在保护用户安全和隐私等方面起到的作用比较有限，尤其是一些大家都离不开的常用软件，非常容易“店大欺客”。为此，Android开发团队在Android 6.0系统中引用了**运行时权限**这个功能，从而更好地保护了用户的安全和隐私。\n\n## Android权限机制详解\n\n首先来看一下过去Android的权限机制是什么样的。比如为了要访问系统的网络状态以及监听开机广播，于是在`AndroidManifest.xml`文件中添加了这样两句权限声明：\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.broadcasttest\">\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\">\n    </uses-permission>\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\">\n    </uses-permission>\n    ...\n</manifest>\n```\n\n因为访问系统的网络状态以及监听开机广播涉及了用户设备的安全性，因此必须在AndroidManifest.xml中加入权限声明，否则程序就会崩溃。\n\n那么现在问题来了，加入了这两句权限声明后，对于用户来说到底有什么影响呢？为什么这样就可以保护用户设备的安全性了呢?\n\n其实用户主要在以下两个方面得到了保护，一方面，如果用户在低于6.0系统的设备上安装该程序，会在安装界面给出提醒——“此应用将获得以下权限：查看网络连接、开机启动”。这样用户就可以清楚地知晓该程序一共申请了哪些权限，从而决定是否要安装这个程序。\n\n另一方面，用户可以随时在应用程序管理界面查看任意一个程序的权限申请情况。这样该程序申请的所有权限就尽收眼底，什么都瞒不过用户的眼睛，以此保证应用程序不会出现各种滥用权限的情况。\n\n这种权限机制的设计思路其实非常简单，就是用户如果认可你所申请的权限，那么就会安装程序，如果不认可申请的权限，那么拒绝安装就可以了。\n\n但是理想是美好的，现实却很残酷，因为很多我们所离不开的常用软件普遍存在着滥用权限的情况，不管到底用不用得到，反正先把权限申请了再说。比如说微信所申请的权限。\n\nAndroid开发团队当然也意识到了这个问题，于是在6.0系统中加入了运行时权限功能。也就是说，用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限申请进行授权。比如说一款相机应用在运行时申请了地理位置定位权限，就算我拒绝了这个权限，但是我应该仍然可以使用这个应用的其他功能，而不是像之前那样直接无法安装它。\n\n当然，并不是所有权限都需要在运行时申请，对于用户来说，不停地授权也很烦琐。Android现在将所有的权限归成了两类，一类是普通权限，一类是危险权限。准确地讲，其实还有第三类特殊权限，不过这种权限使用得很少，因此不在讨论范围之内。普通权限指的是那些不会直接威胁到用户的安全和隐私的权限，对于这部分权限申请，系统会自动帮我们进行授权，而不需要用户再去手动操作了。危险权限则表示那些可能会触及用户隐私或者对设备安全性造成影响的权限，如获取设备联系人信息、定位设备的地理位置等，对于这部分权限申请，必须要由用户手动点击授权才可以，否则程序就无法使用相应的功能。\n\n但是Android中有一共有上百种权限，怎么从中区分哪些是普通权限，哪些是危险权限？其实不难，危险权限很少，除了危险权限之外，剩余的就是普通权限。下表为到Android 10为止所有的危险权限。\n\n| 权限组名             | 权限名                                                       |\n| -------------------- | ------------------------------------------------------------ |\n| CALENDAR             | `READ_CALENDAR`<br />`WRITE_CALENDAR`                        |\n| CALL_LOG             | `READ_CALL_LOG`<br />`WRITE_CALL_LOG`<br />`PROCESS_OUTGOING_CALLS` |\n| CAMERA               | CAMERA                                                       |\n| CONTACTS             | `READ_CONTACTS`<br />`WRITE_CONTACTS`<br />`GET_ACCOUNTS`    |\n| LOCATION             | `ACCESS_FINE_LOCATION`<br />`ACCESS_COARSE_LOCATION`<br />`ACCESS_BACKGROUND_LOCATION` |\n| MICROPHONE           | `RECORD_AUDIO`                                               |\n| PHONE                | `READ_PHONE_STATE`<br />`READ_PHONE_NUMBERS`<br />`CALL_PHONE`<br />`ANSWER_PHONE_CALLS`<br />`ADD_VOICEMAIL`<br />`USE_SIP`<br />`ACCEPT_HANDOVER` |\n| SENSORS              | `BODY_SENSORS`                                               |\n| ACTIVITY_RECOGNITION | `ACTIVITY_RECOGNITION`                                       |\n| SMS                  | `SEND_SMS`<br />`RECEIVE_SMS`<br />`READ_SMS`<br />`RECEIVE_WAP_PUSH`<br />`RECEIVE_MMS` |\n| STORAGE              | `READ_EXTERNAL_STORAGE`<br />`WRITE_EXTERNAL_STORAGE`<br />`ACCESS_MEDIA_LOCATION` |\n\n每当要使用一个权限时，可以先到这张表中来查一下，如果是属于这张表中的权限，那么就需要进行运行时权限处理，如果不在这张表中，那么只需要在AndroidManifest.xml文件中添加一下权限声明就可以了。\n\n另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。但是谨记，不要基于此规则来实现任何功能逻辑，因为Android系统随时可能调整权限的分组。\n\n## 在程序运行时申请权限\n\n首先新建一个RuntimePermissionTest项目。先以`CALL_PHONE`这个权限作为示例。\n\n`CALL_PHONE`这个权限是编写拨打电话功能的时候需要声明的，因为拨打电话会涉及用户手机的资费问题，因而被列为了危险权限。在Android 6.0系统出现之前，拨打电话功能的实现非常简单，修改`activity_main.xml`布局文件，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <Button\n        android:id=\"@+id/make_call\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Make Call\">\n    </Button>\n</LinearLayout>\n```\n\n修改MainActivity中的代码，如下：\n\nJava版：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button makeCall = (Button) findViewById(R.id.make_call);\n        makeCall.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                try {\n                    Intent intent = new Intent(Intent.ACTION_CALL);\n                    intent.setData(Uri.parse(\"tel:10086\"));\n                    startActivity(intent);\n                } catch (SecurityException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n}\n```\n\nkotlin版：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        makeCall.setOnClickListener {\n            try {\n                val intent = Intent(Intent.ACTION_CALL)\n                intent.data = Uri.parse(\"tel:10086\")\n                startActivity(intent)\n            } catch (e: SecurityException) {\n                e.printStackTrace()\n            }\n        }\n    }\n}\n```\n\n可以看到，在按钮的点击事件中，构建了一个隐式Intent，Intent的action指定为`Intent.ACTION_CALL`，这是一个系统内置的打电话的动作，然后在data部分指定了协议是tel，号码是10086。要注意区分，`Intent.ACTION_DIAL`表示打开拨号界面，这个是不需要声明权限的，而`Intent.ACTION_CALL`则可以直接拨打电话，因此必须声明权限。\n\n另外为了防止程序崩溃，将所有操作都放在了异常捕获代码块当中。那么接下来修改`AndroidManifest.xml`文件，在其中声明如下权限：\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.filetest\">\n    <uses-permission android:name=\"android.permission.CALL_PHONE\">\n    </uses-permission>\n    ...\n</manifest>\n```\n\n这样拨打电话的功能成功实现了，在低于Android 6.0系统的手机上都是可以正常运行的，但是如果在6.0或者更高版本系统的手机上运行，点击Make Call按钮就没有任何效果，这时观察logcat中的打印日志，会看到错误信息中提醒我们“Permission Denial”，可以看出，这是权限被禁止所导致，因为Android 6.0及以上系统在使用危险权限时必须进行运行时权限处理。\n\n修改MainActivity中的代码，如下：\n\nJava代码：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button makeCall = (Button) findViewById(R.id.makeCall);\n        makeCall.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                if(ContextCompat.checkSelfPermission(MainActivity.this,\n                        Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {\n                    ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission.CALL_PHONE }, 1);\n                } else {\n                    call();\n                }\n            }\n        });\n    }\n    private void call() {\n        try {\n            Intent intent = new Intent(Intent.ACTION_CALL);\n            intent.setData(Uri.parse(\"tel:10086\"));\n            startActivity(intent);\n        } catch (SecurityException e) {\n            e.printStackTrace();\n        }\n    }\n    // 用户选择同意或拒绝后，会回调到此方法中，授权的结果会封装在grantResults参数中。\n    @Override\n    public void onRequestPermissionsResult(int requestCode, String[] permissions,\n                                          int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        switch (requestCode) {\n            case 1:\n                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    call();\n                } else {\n                    Toast.makeText(this, \"You denied the permission\", Toast.LENGTH_SHORT).show();\n                }\n                break;\n            default:\n\n        }\n    }\n}\n```\n\nkotlin版：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        makeCall.setOnClickListener {\n            if(ContextCompat.checkSelfPermission(this,\n                    Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {\n                ActivityCompat.requestPermissions(this,\n                arrayOf(Manifest.permission.CALL_PHONE), 1)\n            }\n            else {\n                call()\n            }\n        }\n    }\n    override fun onRequestPermissionsResult(requestCode: Int,\n                                            permissions: Array<String>,\n                                            grantResults； IntArray) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n        when (requestCode) {\n            1 -> {\n                if (grantResults.isNotEmpty() &&\n                    grantResults[0] == PackManager.PERMISSION_GRANTED) {\n                    call()\n                } else {\n                    Toast.makeText(this, \"You denied the permission\",\n                                   Toast.LENGTH_SHORT).show()\n                }\n            }\n        }\n    }\n    private fun call() {\n        try {\n            val intent = Intent(Intent.ACTION_CALL)\n            intent.data = Uri.parse(\"tel:10086\")\n            startActivity(intent)\n        } catch (e: SecurityException) {\n            e.printStackTrace()\n        }\n    }\n}\n```\n\n上面的代码将运行时权限的完整流程都覆盖了，下面来具体解析一下。说白了，运行时权限的核心就是在程序运行过程中由用户授权去执行某些危险操作，程序是不可以擅自做主去执行这些危险操作的。因此，第一步就是要先判断用户是不是已经给过授权了，借助的是ContextCompat.checkSelfPermission方法。checkSelfPermission方法接收两个参数，第一个参数是Context，第二个参数是具体的权限名，比如打电话的权限名就是`Manifest.permission.CALL_PHONE`，然后我们使用方法的返回值和`PackageManager.PERMISSION_GRANTED`做比较，相等就说明用户已经授权，不等就表示用户没有授权。\n\n如果已经授权的话就简单了，直接去执行拨打电话的逻辑操作就可以了，这里我们把拨打电话的逻辑封装到了call方法当中。如果没有授权的话，则需要调用`ActivityCompat.requestPermissions`方法来向用户申请授权，`requestPermissions`方法接收3个参数，第一个参数要求是Activity的实例，第二个参数是一个String数组，我们把要申请的权限名放在数组中即可，第三个参数是请求码，只要是唯一值就可以了，这里传入了1。\n\n调用完了`requestPermissions`方法之后，系统会弹出一个权限申请的对话框，然后用户可以选择同意或拒绝我们的权限申请，不论是哪种结果，最终都会回调到`onRequestPermissionsResult`方法中，而授权的结果则会封装在`grantResults`参数当中。这里我们只需要判断一下最后的授权结果，如果用户同意的话就调用call方法来拨打电话，如果用户拒绝的话我们只能放弃操作，并且弹出一条失败提示。\n\n现在重新运行一下程序，并点击Make Call按钮。由于用户还没有授权过我们拨打电话权限，因此第一次运行会弹出一个权限申请的对话框，用户可以选择同意或者拒绝。\n\n如果选择同意，就成功进入到拨打电话界面了，由于用户已经完成了授权操作，之后再点击Make Call按钮就不会再弹出权限申请对话框了，而是可以直接拨打电话。那可能你会担心，万一以后我又后悔了怎么办？没有关系，用户随时都可以将授予程序的危险权限进行关闭，进入`Settings/Apps/RuntimePermissionTest/Permissions`。在这里我们就可以对任何授予过的危险权限进行关闭了。\n\n# 访问其他程序中的数据\n\n内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据，另一种是创建自己的内容提供器给程序的数据提供外部访问接口。\n\n如果一个应用程序通过内容提供器对其数据提供了外部访问接口，那么任何其他的应用程序就都可以对这部分数据进行访问。Android系统中自带的电话簿、短信、媒体库等程序都提供了类似的访问接口，这就使得第三方应用程序可以充分地利用这部分数据来实现更好的功能。\n\n## ContentResolver的基本用法\n\n对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助`ContentResolver`类，可以通过Context中的getContentResolver方法获取到该类的实例。\n\nContentResolver中提供了一系列的方法用于对数据进行CRUD操作，其中insert方法用于添加数据，update方法用于更新数据，delete方法用于删除数据，query方法用于查询数据。SQLiteDatabase中也是使用这几个方法来进行CRUD操作的，只不过它们在方法参数上稍微有一些区别。\n\n不同于SQLiteDatabase，ContentResolver中的增删改查方法不接收表名参数，而是使用一个Uri参数代替，这个参数被称为**内容URI**。内容URI给内容提供器中的数据建立了唯一标识符，它主要由两部分组成：authority和path。（其实还有一个固定的部分，是头部协议声明）\n\nauthority是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。比如某个程序的包名是`com.example.app`，那么该程序对应的`authority`就可以命名为`com.example.app.provider`。\n\npath则是用于对**同一应用程序中不同的表**做区分的，通常都会添加到authority的后面。比如某个程序的数据库里存在两张表：tablel和table2，这时就可以将path分别命名为`/tablel`和`/table2`，然后把`authority`和`path`进行组合，内容`URI`就变成了`com.example.app.provider/table1`和`com.example.app.provider/table2`。不过，目前还很难辨认出这两个字符串就是两个内容URI，我们还需要**在字符串的头部加上协议声明**。因此，内容URI最标准的格式写法如下：\n\n`content://com.example.app.provider/tablel`，`content://com.example.app.provider/table2`\n\n发现，内容URI可以非常清楚地表达出我们想要访问哪个程序中哪张表里的数据。也正是因此，ContentResolver中的增删改查方法才都接收Uri对象作为参数，因为如果使用表名的话，系统将无法得知我们期望访问的是哪个应用程序里的表。\n\n在得到了内容URI字符串之后，我们还需要将它**解析成Uri对象**才可以作为参数传入。解析的方法也相当简单，只需要调用`Uri.parse`方法，代码如下所示：`Uri uri = Uri.parse(\"content://com.example.app.provider/table1\")`。现在我们就可以使用这个Uri对象来查询table1表中的数据了，代码如下所示：\n\n```java\nCursor cursor = getContentResolver().query(\n    uri,\n    projection,\n    selection,\n    selectionArgs,\n    sortOrder);\n```\n\n这些参数和SQLiteDatabase中query方法里的参数很像，但总体来说要简单一些，毕竟这是在访问其他程序中的数据，没必要构建过于复杂的查询语句。\n\nquery方法的参数说明：\n\n| query方法参数 | 对应SQL部分               | 描述                             |\n| ------------- | ------------------------- | -------------------------------- |\n| uri           | from table_name           | 指定查询某个应用程序下的某一张表 |\n| projection    | select column1, column2   | 指定查询的列名                   |\n| selection     | where column = value      | 指定where的约束条件              |\n| selectionArgs | -                         | 为where中的占位符提供具体的值    |\n| sortOrder     | order by column1, column2 | 指定查询结果的排序方式           |\n\n查询完成后返回的仍然是一个Cursor对象，这时我们就可以将数据从Cursor对象中逐个读取出来了。读取的思路仍然是通过移动游标的位置来遍历Cursor的所有行，然后再取出每一行中相应列的数据，代码如下所示：\n\n```java\nif(cursor != null) {\n    while (cursor.moveToNext()) {\n        String column1 = cursor.getString(cursor.getColumnIndex(\"column1\"));\n        int column2 = cursor.getInt(cursor.getColumnIndex(\"column2\"));\n    }\n    cursor.close();\n}\n```\n\n向table1表添加数据，代码如下：\n\n```java\nContentValues values = new ContentValues();\nvalues.put(\"column1\", \"text\");\nvalues.put(\"column2\", 1);\ngetContentResolver().insert(uri, values);\n```\n\n可以看到，仍然是将待添加的数据组装到ContentValues中，然后调用ContentResolver的insert方法，将Uri和ContentValues作为参数传入即可。\n\n现在如果我们想要更新这条新添加的数据，把column1的值清空，可以借助ContentResolver的update方法实现。代码如下所示：\n\n```java\nContentValues values = new ContentValues();\nvalues.put(\"column1\", \"\");\ngetContentResolver().update(uri, values, \"column1 = ? and column2 = ?\",\n                            new String[] {\"text\", \"1\"});\n```\n\n注意上述代码使用了selection和selectionArgs参数来对想要更新的数据进行约束，以防止所有的行都会受影响。最后，可以调用ContentResolver的delete方法将这条数据删除掉，代码如下所示：\n\n```java\ngetContentResolver().delete(uri, \"column2 = ?\", new String[] {\"1\"});\n```\n\n到这里为止，我们就把ContentResolver中的增删改查方法全部学完了。这些知识其实和SQLiteDatabase很类似，需要特别注意的只有uri这个参数而已。那么接下来，我们就利用目前所学的知识，看一看如何读取系统电话簿中的联系人信息。\n\n## 示例：读取电话簿联系人\n\n新建一个ContactsTest项目。\n\n`activity_main.xml`：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <ListView\n        android:id=\"@+id/contacts_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n    </ListView>\n</LinearLayout>\n```\n\nMainActivity：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    ArrayAdapter<String> adpter;\n    List<String> contactsList = new ArrayList<>();\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 首先获取ListView控件的实例\n        ListView contactsView = (ListView) findViewById(R.id.contacts_view);\n        adapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, contactsList);\n        // 设置配置器\n        contactsView.setAdapter(adapter);\n        \n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {\n            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, 1);          \n        } else {\n            readContacts();\n        }\n    }\n    \n    private void readContacts() {\n        Cursor cursor = null;\n        try {\n            // 查询联系人数据\n            // ContactsContract.CommonDataKinds.Phone类已经做好了封装，提供了一个CONTENT_URI常量\n            cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);\n            if(cursor != null) {\n                while (cursor.moveToNext()) {\n                    // 获取联系人姓名\n                    // DISPLAY_NAME 对应联系人名字这一列\n                    String displayName = cursor.getString(cursor.getColumnIndex(ContactContract.CommonDataKinds.Phone.DISPLAY_NAME));\n                    // 获取联系人手机号\n                    // NUMBER 对应联系人手机号这一列\n                    String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\n                    // 添加到ListView的数据源List容器中\n                    contactsList.add(displayName + \"\\n\" + number);\n                }\n                // 通知刷新一下ListView\n                adapter.notifyDataSetChanged();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (cursor != null) {\n                // 千万不要忘记关闭Cursor对象\n                cursor.close();\n            }\n        }\n    }\n    @Override\n    public void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResults) {\n        switch (requestCode) {\n            case 1:\n                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    readContacts();\n                } else {\n                    Toast.makeText(this, \"You denied the permission\", Toast.LENGTH_SHORT).show();\n                }\n                break;\n            default:\n        }\n    }\n}\n```\n\n读取系统联系人的权限千万不要忘记在AndroidManifest.xml中声明\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.contactstest\">\n    <uses-permission android:name=\"android.permission.READ_CONTACTS\" />\n    ...\n</manifest>\n```\n\n# 创建自己的内容提供器\n\n在自己的程序中访问其他应用程序的数据，总体来说思路还是非常简单的，只需要获取到该应用程序的内容URI，然后借助ContentResolver进行CRUD操作就可以了。可是那些提供外部访问接口的应用程序都是如何实现这种功能的呢？它们又是怎样保证数据的安全性使得隐私数据不会泄漏出去？\n\n## 创建内容提供器的步骤\n\n前面已经提到过，如果想要实现跨程序共享数据的功能，官方推荐的方式是使用内容提供器，可以通过新建一个类去继承ContentProvider的方式来创建一个自己的内容提供器。ContentProvider类中有6个抽象方法，我们在使用子类继承它的时候，需要将这6个方法全部重写。新建MyProvider继承自ContentProvider，代码如下所示：\n\n```java\npublic class MyProvider extends ContentProvider {\n    @Override\n    public boolean onCreate() {\n        return false;\n    }\n    @Override\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\n        return null;\n    }\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        return null;\n    }\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n        return 0;\n    }\n    @Override\n    public int delete(Uri uri, String selection, String[] selectionArgs) {\n        return 0;\n    }\n    @Override\n    public String getType(Uri uri) {\n        return null;\n    }\n}\n```\n\n1. onCreate()\n   1. 初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false则表示失败。注意，只有当存在ContentResolver尝试访问我们程序中的数据时，内容提供器才会被初始化。\n2. query()\n   1. 从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。\n3. insert()\n   1. 向内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的URI。\n\n4. update()\n   1. 更新内容提供器中已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。\n\n5. delete()\n   1. 从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs 参数用于约束删除哪些行，被删除的行数将作为返回值返回。\n\n6. getType()\n   1. 根据传入的内容URI来返回相应的MIME类型。\n\n\n可以看到，几乎每一个方法都会带有Uri这个参数，这个参数也正是调用ContentResolver的增删改查方法时传递过来的。而现在，我们需要对传入的Uri参数进行解析，从中分析出调用方期望访问的表和数据。回顾一下，一个标准的内容URI写法是这样的：`content://com.example.app.provider/table1`。这就表示调用方期望访问的是`com.example.app`这个应用的table1表中的数据。除此之外，我们还可以在这个内容URI的后面加上一个`id`，如下所示：`content://com.example.app.provider/tablel/1`。这就表示调用方期望访问的是`com.example.app`这个应用的`table1`表中id为1的数据。内容URI的格式主要就只有以上两种，以路径结尾就表示期望访问该表中所有的数据，以id结尾就表示期望访问该表中拥有相应id的数据。我们可以使用通配符的方式来分别匹配这两种格式的内容URI，规则如下：\n\n* `*`，表示匹配任意长度的任意字符；\n* `#`，表示匹配任意长度的数字。\n\n所以，一个能够匹配任意表的内容URI格式就可以写成：`content://com.example.app.provider/*`，而一个能够匹配`table1`表中任意一行数据的内容URI格式就可以写成：`content://com.example.app.provider/table1/#`。\n\n接着，我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。UriMatcher中提供了一个addURI方法，这个方法接收3个参数，可以分别把authority、path和一个自定义代号传进去。这样，当调用UriMatcher的match方法时，就可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代号，利用这个代号，就可以判断出调用方期望访问的是哪张表中的数据了。修改`MyProvider`中的代码，如下所示：\n\n```java\npublic class MyProvider extends ContenProvider {\n    public static final int TABLE1_DIR = 0;\n    public static final int TABLE1_ITEM = 1;\n    public static final int TABLE2_DIR = 2;\n    public static final int TABLE2_ITEM = 3;\n    private static UriMatcher uriMatcher;\n    static {\n        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n        uriMatcher.addURI(\"com.example.app.provider\", \"table1\", TABLE1_DIR);\n        uriMatcher.addURI(\"com.example.app.provider \", \"table1/#\", TABLE1_ITEM);\n        uriMatcher.addURI(\"com.example.app.provider \", \"table2\", TABLE2_DIR);\n        uriMatcher.addURI(\"com.example.app.provider \", \"table2/#\", TABLE2_ITEM);\n    }\n    ...\n    @Override\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\n        switch (uriMatcher.match(uri)) {\n            case TABLE1_DIR:\n                break;\n            case TABLE1_ITEM:\n                break;\n            case TABLE2_DIR:\n                break;\n            case TABLE2_ITEM:\n                break;\n            default:\n                break;\n        }\n    }\n    ...\n}\n```\n\n可以看到，MyProvider中新增了4个整型常量，其中`TABLE1_DIR`表示访问`table1`表中的所有数据，`TABLE1_ITEM`表示访问`table1`表中的单条数据，`TABLE2_DIR`表示访问`table2`表中的所有数据，`TABLE2_ITEM`表示访问`table2`表中的单条数据。接着在静态代码块里我们创建了UriMatcher的实例，并调用addURI方法，将期望匹配的内容URI格式传递进去，注意这里传入的路径参数是可以使用通配符的。然后当query方法被调用的时候，就会通过UriMatcher的match方法对传入的Uri对象进行匹配，如果发现UriMatcher中某个内容URI格式成功匹配了该Uri对象，则会返回相应的自定义代号，然后我们就可以判断出调用方期望访问的到底是什么数据了。\n\n上述代码只是以query方法为例做了个示范，其实insert、update、delete这几个方法的实现也是差不多的，它们都会携带Uri这个参数，然后同样利用UriMatcher的match方法判断出调用方期望访向的是哪张表，再对该表中的数据进行相应的操作就可以了。\n\n除此之外，还有一个方法会比较陌生，即getType方法。它是所有的内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。一个内容URI所对应的MIME字符串主要由3部分组成，Android对这3个部分做了如下格式规定：\n\n1. 必须以vnd开头。\n2. 如果内容URI以路径结尾，则后接`android.cursor.dir/`，如果内容URI以id结尾，则后接 `android.cursor.item/`。\n3. 最后接上`vnd.<authority>.<path>`。\n\n所以，对于`content://com.example.app.provider/table1`这个内容URI，它所对应的MIME类型就可以写成：`vnd.android.cursor.dir/vnd.com.example.app.provider.table1`。对于`content://com.example.app.provider/table1/1`这个内容URI，它所对应的MIME类型就可以写成：`vnd.android.cursor.item/vnd.com.example.app.provider.table1`。\n\n现在可以继续完善MyProvider中的内容了，这次来实现`getType()`方法中的逻辑，代码如下：\n\n```java\npublic class MyProvider extends ContentProvider {\n    ...\n    @Override\n    public String getType(Uri uri) {\n        switch (uriMatcher.match(uri)) {\n            case TABLE1_DIR:\n                return \"vnd.android.cursor.dir/vnd.com.example.app.provider.table1\";\n            case TABLE1_ITEM:\n                return \"vnd.android.cursor.item/vnd.com.example.app.provider.table1\";\n            case TABLE2_DIR:\n                return \"vnd.android.cursor.dir/vnd.com.example.app.provider.table2\";\n            case TABLE2_ITEM:\n                return \"vnd.android.cursor.item/vnd.com.example.app.provider.table2\";\n            default:\n                break;\n        }\n        return null;\n    }\n}\n```\n\n到这里，一个完整的内容提供器就创建完成了，现在任何一个应用程序都可以使用ContentResolver来访问我们程序中的数据。那么前面所提到的，如何才能保证隐私数据不会泄漏出去呢？其实多亏了内容提供器的良好机制，这个问题在不知不觉中已经被解决了。因为**所有的CRUD操作都一定要匹配到相应的内容URI格式才能进行**，而我们当然不可能向UriMatcher中添加隐私数据的URI，所以这部分数据根本无法被外部程序访问到，安全问题也就不存在了。下面就来实战一下，真正体验一回跨程序数据共享的功能。\n\n## 实现跨程序数据共享\n\n简单起见，还是在DatabaseTest项目的基础上继续开发，通过内容提供器来给它加入外部访问接口。打开DatabaseTest项目，首先将MyDatabaseHelper中使用Toast弹出创建数据库成功的提示去除掉，因为跨程序访问时不能直接使用Toast。接下来，创建一个内容提供器，右击`com.example.databasetest`包，new，other，Content Provider。可以看到，这里我们将内容提供器命名为`DatabaseProvider.authority`指定为`com.example.databasetest.provider`，`Exported`属性表示是否允许外部程序访问我们的内容提供器，`Enabled`属性表示是否启用这个内容提供器。将两个属性都勾中，点击Finish完成创建。\n\n接着修改DatabaseProvider中的代码，如下：\n\n```java\npublic class DatabaseProvider extends ContentProvider {\n    public static final int BOOK_DIR = 0;\n    public static final int BOOK_ITEM = 1;\n    public static final int CATEGORY_DIR = 2;\n    public static final int CATEGORY_ITEM = 3;\n    public static final String AUTHORITY = \"com.example.sqlitetest.provider\";\n    private static UriMatcher uriMatcher;\n    private MyDatabaseHelper dbHelper;\n    static {\n        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n        uriMatcher.addURI(AUTHORITY, \"book\", BOOK_DIR);\n        uriMatcher.addURI(AUTHORITY, \"book/#\", BOOK_ITEM);\n        uriMatcher.addURI(AUTHORITY, \"category\", CATEGORY_DIR);\n        uriMatcher.addURI(AUTHORITY, \"category/#\", CATEGORY_ITEM);\n    }\n    @Override\n    public boolean onCreate() {\n        dbHelper = new MyDatabaseHelper(getContext(), \"Bookstore.db\", null, 2);\n        return true;\n    }\n    @Override\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\n        // 查询数据\n        SQLiteDatabase db = dbHelper.getReadableDatabase();\n        Cursor cursor = null;\n        switch (uriMatcher.match(uri)) {\n            case BOOK_DIR:\n                cursor = db.query(\"Book\", projection, selection, selectionArgs, null, null, sortOrder);\n                break;\n            case BOOK_ITEM:\n                String bookId = uri.getPathSegments().get(1);\n                cursor = db.query(\"Book\", projection, \"id = ?\", new String[] {bookId}, null, null, sortOrder);\n                break;\n            case CATEGORY_DIR:\n                cursor = db.query(\"Category\", projection, selection, selectionArgs, null, null, sortOrder);\n                break;\n            case CATEGORY_ITEM:\n                String categoryId = uri.getPathSegments().get(1);\n                cursor = db.query(\"Category\", projection, \"id = ?\", new String[] {categoryId}, null, null, sortOrder);\n                break;\n            default:\n                break;\n        }\n        return cursor;\n    }\n    @Override\n    public Uri insert(Uri uri, ContentValues values) {\n        // 添加数据\n        SQLiteDatabase db = dbHelper.getWritableDatabase();\n        Uri uriReturn = null;\n        switch (uriMatcher.match(uri)) {\n            case BOOK_DIR:\n            case BOOK_ITEM:\n                long newBookId = db.insert(\"Book\", null, values);\n                uriReturn = Uri.parse(\"content://\" + AUTHORITY + \"/book/\" + newBookId);\n                break;\n            case CATEGORY_DIR:\n            case CATEGORY_ITEM:\n                long newCategoryId = db.insert(\"Category\", null, values);\n                uriReturn = Uri.parse(\"content://\" + AUTHORITY + \"/category/\" + newCategoryId);\n                break;\n            default:\n                break;\n        }\n        return uriReturn;\n    }\n    @Override\n    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {\n        // 更新数据\n        SQLiteDatabase db = dbHelper.getWritableDatabase();\n        int updateRows = 0;\n        switch (uriMatcher.match(uri)) {\n            case BOOK_DIR:\n                updateRows = db.update(\"Book\", values, selection, selectionArgs);\n                break;\n            case BOOK_ITEM:\n                String bookId = uri.getPathSegments().get(1);\n                updateRows = db.update(\"Book\", values, \"id = ?\", new String[]{bookId});\n                break;\n            case CATEGORY_DIR:\n                updateRows = db.update(\"Category\", values, selection, selectionArgs);\n                break;\n            case CATEGORY_ITEM:\n                String categoryId = uri.getPathSegments().get(1);\n                updateRows = db.update(\"Category\", values, \"id = ?\", new String[]{categoryId});\n                break;\n            default:\n                break;\n        }\n        return updateRows;\n    }\n    @Override\n    public int delete(Uri uri, String selection, String[] selectionArgs) {\n        // 删除数据\n        SQLiteDatabase db = dbHelper.getWritableDatabase();\n        int deleteRows = 0;\n        switch (uriMatcher.match(uri)) {\n            case BOOK_DIR:\n                deleteRows = db.delete(\"Book\", selection, selectionArgs);\n                break;\n            case BOOK_ITEM:\n                String bookId = uri.getPathSegments().get(1);\n                deleteRows = db.delete(\"Book\", \"id = ?\", new String[]{bookId});\n                break;\n            case CATEGORY_DIR:\n                deleteRows = db.delete(\"Category\", selection, selectionArgs);\n                break;\n            case CATEGORY_ITEM:\n                String categoryId = uri.getPathSegments().get(1);\n                deleteRows = db.delete(\"Category\", \"id = ?\", new String[]{categoryId});\n                break;\n            default:\n                break;\n        }\n        return deleteRows;\n    }\n    @Override\n    public String getType(Uri uri) {\n        switch (uriMatcher.match(uri)) {\n            case BOOK_DIR:\n                return \"vnd.android.cursor.dir/vnd.com.example.sqlitetest.provider.book\";\n            case BOOK_ITEM:\n                return \"vnd.android.cursor.item/vnd.com.example.sqlitetest.provider.book\";\n            case CATEGORY_DIR:\n                return \"vnd.android.cursor.dir/vnd.com.example.sqlitetest.provider.category\";\n            case CATEGORY_ITEM:\n                return \"vnd.android.cursor.item/vnd.com.example.sqlitetest.provider.category\";\n        }\n        return null;\n    }\n}\n```\n\n代码虽然很长，但是这些内容都非常容易理解，因为使用到的全部都是上面的知识。首先在类的一开始，同样是定义了4个常量，分别用于表示访问Book表中的所有数据、访问Book表中的单条数据、访问Category表中的所有数据和访问Category表中的单条数据。然后在静态代码块里对UriMatcher进行了初始化操作，将期望匹配的几种URI格式添加了进去。\n\n接下来就是每个抽象方法的具体实现了，先来看下onCreate方法，这个方法的代码很短，就是创建了一个MyDatabaseHelper的实例，然后返回true表示内容提供器初始化成功，这时数据库就已经完成了创建或升级操作。\n\n接着看一下query方法，在这个方法中先获取到了SQLiteDatabase的实例，然后根据传入的Uri参数判断出用户想要访问哪张表，再调用SQLiteDatabase的query进行查询，并将Cursor对象返回就好了。注意当访问单条数据的时候有一个细节，这里调用了Uri对象的getPathSegments方法，它会将内容URI权限之后的部分以`\"/\"`符号进行分割，并把分割后的结果放入到一个字符串列表中，那这个列表的第0个位置存放的就是路径，第1个位置存放的就是id了。得到了id之后，再通过selection和selectionArgs参数进行约束，就实现了查询单条数据的功能。\n\n再往后就是 insert方法，同样它也是先获取到了SQLiteDatabase的实例、然后根据传入的Uri参数判断出用户想要往哪张表里添加数据。再调用SQLiteDatabase的insert方法进行添加就可以了。注意insert方法要求返回一个能够表示这条新增数据的URI，所以我们还需要调用`Uri.parse`方法来将一个内容URI解析成Uri对象，当然这个内容URI是以新增数据的id结尾的。\n\n接下来就是update方法了，也是先获取SQLiteDatabase的实例。然后根据传入的Uri参数判断出用户想要更新哪张表里的数据，再调用SQLiteDatabase的update方法进行更新就好了，受影响的行数将作为返回值返回。\n\n下面是delete方法，仍然是先获取到SQLiteDatabase的实例，然后根据传入的Uri参数判断出用户想要删除哪张表里的数据，再调用SQLiteDatabase的delete方法进行删除就好了，被删除的行数将作为返回值返回。\n\n最后是getType方法。这样我们就将内容提供器中的代码全部编写完了。另外还有一点需要注意，内容提供器一定要在AndroidManifest.xml文件中注册才可以使用。不过幸运的是，由于我们是使用Android Studio的快捷方式创建的内容提供器，因此注册这一步已经被自动完成了。打开AndroidManifest.xml文件瞧一瞧，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.sqlitetest\">\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.SQLiteTest\">\n        <provider\n            android:name=\".DatabaseProvider\"\n            android:authorities=\"com.example.sqlitetest.provider\"\n            android:enabled=\"true\"\n            android:exported=\"true\"></provider>\n\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n```\n\n可以看到，`<application>`标签内出现了一个新的标签`<provider>`，我们使用它来对`DatabaseProvider`这个内容提供器进行注册。`android:name`属性指定了`DatabaseProvider`的类名，`android:authorities`属性指定了DatabaseProvider的authority，而enabled和exported属性则是根据我们刚才勾选的状态自动生成的，这里表示允许DatabaseProvider被其他应用程序进行访问。\n\n现在DatabaseTest这个项目就已经拥有了跨程序共享数据的功能了，我们赶快来尝试一下。首先需要将DatabaseTest程序删除掉，以防止遗留数据对我们造成干扰。然后运行一下项目，将DatabaseTest程序重新安装在模拟器上了。接着关闭掉DatabaseTest这个项目并创建一个新项目ProviderTest我们就将通过这个程序去访问DatabaseTest中的数据。\n\n先来编写一下布局文件，修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n    <Button\n        android:id=\"@+id/add_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Add To Book\">\n    </Button>\n    <Button\n        android:id=\"@+id/update_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Update Book\">\n    </Button>\n    <Button\n        android:id=\"@+id/delete_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Delete From Book\">\n    </Button>\n    <Button\n        android:id=\"@+id/query_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Query From Book\">\n    </Button>\n</LinearLayout>\n```\n\n布局文件很简单、里面放置了4个按钮，分别用于添加、查询、修改和删除数据。然后修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private String newId;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button addData = (Button) findViewById(R.id.add_data);\n        addData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Uri uri = Uri.parse(\"content://com.example.sqlitetest.provider/book\");\n                ContentValues values = new ContentValues();\n                values.put(\"name\", \"A Clash of Kings\");\n                values.put(\"author\", \"George Martin\");\n                values.put(\"pages\", 1040);\n                values.put(\"price\", 22.85);\n                Uri newUri = getContentResolver().insert(uri, values);\n                newId = newUri.getPathSegments().get(1);\n            }\n        });\n\n        Button updateData = (Button) findViewById(R.id.update_data);\n        updateData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Uri uri = Uri.parse(\"content://com.example.sqlitetest.provider/book\");\n                ContentValues values = new ContentValues();\n                values.put(\"name\", \"A Storm of Swords\");\n                values.put(\"pages\", 1216);\n                values.put(\"price\", 24.05);\n                getContentResolver().update(uri, values, null, null);\n            }\n        });\n\n        Button deleteData = (Button) findViewById(R.id.delete_data);\n        deleteData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Uri uri = Uri.parse(\"content://com.example.sqlitetest.provider/book\");\n                getContentResolver().delete(uri, null, null);\n            }\n        });\n\n        Button queryData = (Button) findViewById(R.id.query_data);\n        queryData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Uri uri = Uri.parse(\"content://com.example.sqlitetest.provider/book\");\n                Cursor cursor = getContentResolver().query(uri, null, null, null, null, null);\n                if(cursor != null) {\n                    while(cursor.moveToNext()) {\n                        String name = cursor.getString(cursor.getColumnIndex(\"name\"));\n                        String author = cursor.getString(cursor.getColumnIndex(\"author\"));\n                        int pages = cursor.getInt(cursor.getColumnIndex(\"pages\"));\n                        double price = cursor.getDouble(cursor.getColumnIndex(\"price\"));\n                        Log.d(\"MainActivity\", \"book name is \" + name);\n                        Log.d(\"MainActivity\", \"book author is \" + author);\n                        Log.d(\"MainActivity\", \"book pages is \" + pages);\n                        Log.d(\"MainActivity\", \"book price is \" + price);\n                    }\n                    cursor.close();\n                }\n            }\n        });\n    }\n}\n```\n\n可以看到，我们分别在这4个按钮的点击事件里面处理了增删改查的逻辑。添加数据的时候，首先调用了Uri.parse方法将一个内容URI解析成Uri对象，然后把要添加的数据都存放到ContentValues对象中，接着调用ContentResolver的insert方法执行添加操作就可以了。注意insert方法会返回一个Uri对象，这个对象中包含了新增数据的id，我们通过getPathSegments方法将这个id取出，稍后会用到它。\n\n查询数据的时候，同样是调用了Uri.parse方法将一个内容URI解析成Uri对象，然后调用ContentResolver的query方法去查询数据，查询的结果当然还是存放在Cursor对象中的。之后对Cursor进行遍历，从中取出查询结果，并打印出来。\n\n更新数据的时候，也是先将内容URI解析成Uri对象，然后把想要更新的数据存放到ContentValues对象中，再调用ContentResolver的update方法执行更新操作就可以了。\n\n注意这里我们为了不想让Book表中的其他行受到影响，在调用Uri.parse方法时，给内容URI的尾部增加了一个id，而这个id正是添加数据时所返回的。这就表示我们只希望更新刚刚添加的那条数据，Book表中的其他行都不会受影响。\n\n删除数据的时候，也是使用同样的方法解析了一个以id结尾的内容URI，然后调用ContentResolver的delete方法执行删除操作就可以了。由于我们在内容URI里指定了一个id，因此只会删掉拥有相应id的那行数据，Book表中的其他数据都不会受影响。\n","categories":["Android"]},{"title":"Android_数据和文件存储","url":"/Android/Android_数据和文件存储/","content":"\n# 数据和文件存储概览\n\nAndroid使用的文件系统类似于其他平台上基于磁盘的文件系统，提供了以下几种保存应用数据的选项：\n\n- **应用专属存储空间**：存储仅供应用使用的文件，可以存储到内部存储卷中的专属目录或外部存储空间中的其他专属目录。使用内部存储空间中的目录保存其他应用不应访问的敏感信息。\n- **共享存储**：存储与其他应用共享的文件，包括媒体、文档和其他文件。\n- **偏好设置**：以键值对形式存储私有原始数据。\n- **数据库**：使用Room持久性库将结构化数据存储在专用数据库中。\n\n下表汇总了这些选项的特点：\n\n||内容类型|访问方法|所需权限|其他应用是否可访问| 卸载应用时是否移除文件 |\n|-|-|-|-|-|-|\n|应用专属文件|仅供应用使用的文件|从内部存储空间访问，可以使用`getFilesDir()`或`getCacheDir()`方法；从外部存储空间访问，可以使用`getExternalFilesDir()`或`getExternalCacheDir()`方法 | 从内部存储空间访问不需要任何权限。如果应用在搭载Android 4.4（API级别19）或更高版本的设备上运行，从外部存储空间访问不需要任何权限 |否|是|\n| 媒体 | 可共享的媒体文件（图片、音频文件、视频） | `MediaStore` API                                             | 在Android 11（API级别30）或更高版本中，访问其他应用的文件需要`READ_EXTERNAL_STORAGE`在Android 10（API级别29）中，访问其他应用的文件需要`READ_EXTERNAL_STORAGE`或`WRITE_EXTERNAL_STORAGE`在Android 9（API级别28）或更低版本中，访问所有文件均需要相关权限 | 是，但其他应用需要`READ_EXTERNAL_STORAGE`权限 | 否                       |\n| 文档和其他文件 | 其他类型的可共享内容，包括已下载的文件   | 存储访问框架                                                 | 无                                                           | 是，可以通过系统文件选择器访问                  | 否                       |\n| 应用偏好设置 | 键值对                                   | Jetpack Preferences库 | 无                                                           | 否                                              | 是                       |\n| 数据库                                                       | 结构化数据                               | Room持久性库 | 无                                                           | 否                                              | 是                       |\n\n应根据自己的具体需求选择解决方案：\n\n- 数据需要占用多少空间？\n\n  内部存储空间中用于存储应用专属数据的空间有限。如果需要保存大量数据，应使用其他类型的存储空间。\n\n- 数据访问需要达到怎样的可靠程度？\n\n  如果应用的基本功能需要某些数据（例如应用启动时需要的数据），可以将相应数据存放到内部存储目录或数据库中。存储在外部存储空间中的应用专属文件并非一直可以访问，因为有些设备允许用户移除外部存储实体设备。\n\n- 需要存储哪类数据？\n\n  如果数据仅供您的应用使用，应使用应用专属存储空间。对于可分享的媒体内容，应使用共享的存储空间，以便其他应用可以访问相应内容。对于结构化数据，应使用偏好设置（适合键值对数据）或数据库（适合包含2个以上列的数据）。\n\n- 数据是否应仅供你的应用使用？\n\n  在存储敏感数据（不可通过任何其他应用访问的数据）时，应使用内部存储空间、偏好设置或数据库。内部存储空间的一个额外优势是用户无法看到相应数据。\n\n# 存储位置的类别\n\nAndroid提供两类物理存储位置：内部存储空间和外部存储空间。在大多数设备上，内部存储空间小于外部存储空间。不过，所有设备上的内部存储空间都是始终可用的，因此在存储应用所依赖的数据时更为可靠。\n\n可移除卷（例如SD卡）在文件系统中属于外部存储空间。Android使用路径（例如`/sdcard`）表示这些存储设备。\n\n>注意：可用于保存文件的确切位置可能因设备而异。因此，请勿使用硬编码的文件路径。\n\n默认情况下，应用本身存储在内部存储空间中。不过，如果APK非常大，也可以在应用的清单文件中指明偏好设置，以便将应用安装到外部存储空间：\n\n```xml\n<manifest ...\n    android:installLocation=\"preferExternal\" >\n    ...\n</manifest>\n```\n\n# 对外部存储空间的访问和所需权限\n\nAndroid定义了以下与存储相关的权限：`READ_EXTERNAL_STORAGE`、`WRITE_EXTERNAL_STORAGE`和 `MANAGE_EXTERNAL_STORAGE`。\n\n在较低版本的Android系统中，应用需要声明`READ_EXTERNAL_STORAGE`权限才能访问位于外部存储空间中应用专属目录之外的任何文件。此外，应用需要声明`WRITE_EXTERNAL_STORAGE`权限才能向应用专属目录以外的任何文件写入数据。\n\nAndroid系统的版本越新，就越依赖于文件的用途而不是位置来确定应用对特定文件的访问和写入能力。特别是，如果应用以Android 11（API级别30）或更高版本为目标平台，`WRITE_EXTERNAL_STORAGE`权限完全不会影响应用对存储的访问权限。这种基于用途的存储模型可增强用户隐私保护，因为应用只能访问其在设备文件系统中实际使用的区域。\n\nAndroid 11引入了`MANAGE_EXTERNAL_STORAGE`权限，该权限提供对应用专属目录和`MediaStore`之外文件的写入权限。此权限使大多数应用无需声明此权限即可实现其用例，参阅有关如何[管理存储设备上所有文件](https://developer.android.com/training/data-storage/manage-all-files?hl=zh-cn)的指南。\n\n# 分区存储\n\n为了让用户更好地管理自己的文件并减少混乱，以Android 10（API级别29）及更高版本为目标平台的应用在默认情况下被授予了对外部存储空间的分区访问权限（即分区存储）。此类应用只能访问外部存储空间上的应用专属目录，以及本应用所创建的特定类型的媒体文件。\n\n> 注意：如果应用在运行时请求与存储空间相关的权限，面向用户的对话框会表明应用正在请求对外部存储广泛的访问，即使启用分区存储也是如此。\n\n除非应用需要访问存储在应用专属目录和`MediaStore` API可以访问的目录之外的文件，否则请使用分区存储。如果将应用专属文件存储在外部存储空间中，则可以将这些文件存放在外部存储空间中的应用专属目录内，以便更加轻松地采用分区存储。这样，在启用分区存储后，应用将可以继续访问这些文件。\n\n如需应用适合分区存储，参阅[存储用例和最佳实践](https://developer.android.com/training/data-storage/use-cases?hl=zh-cn)指南。如应用有其他用例未包含在分区存储范围内，请[提交功能请求](https://source.android.com/setup/contribute/report-bugs?hl=zh-cn)。可以[暂时选择停用分区存储](https://developer.android.com/training/data-storage/use-cases?hl=zh-cn#opt-out-scoped-storage)。\n\n# 文件存储\n\n文件存储不对存储的内容进行任何格式化处理，所有数据原封不动地保存到文件当中，因而比较适合存储一些简单的文本数据或二进制数据。如果想使用文件存储的方式来保存一些较为复杂的结构化数据，需要定义一套自己的格式规范，方便之后将数据从文件中重新解析出来。\n\n## 写入到文件中\n\n`Context`类中提供了一个`openFileOutput()`方法，可以用于将数据存储到指定的文件中。此方法接受两个参数：第一个参数是文件名，在文件创建的时候使用，注意此文件名不可包含路径，因为所有的文件都默认存储到`/data/data/<package name>/files/`目录下；第二个参数是文件的操作模式，主要有`MODE_PRIVATE`和`MODE_APPEND`两种模式可选。默认是`MODE_PRIVATE`，表示当指定相同文件名时，直接覆盖原文件内容。`MODE_APPEND`则表示追加内容。`MODE_WORLD_READABLE`和`MODE_WORLD_WRITEABLE`表示允许其他应用程序对程序的文件进行读写操作，由于这两种模式过于危险，容易引起应用的安全漏洞，已在Android 4.2版本中废弃。\n\n`openFileOutput()`方法返回一个`FileOutputStream`对象，得到这个对象之后借助它构建出OutputStreamWriter对象，再使用OutputStreamWriter对象构建出BufferedWriter对象，如此就可以使用通过BufferedWriter将文本内容写入文件。这就是用Java流的方式将数据写入文件中。\n\njava代码示例：\n\n```java\npublic void save() {\n    String somedata = \"Data to save\";\n    FileOutputStream out = null;\n    BufferedWriter writer = null;\n    try {\n        out = openFileOutput(\"data\", Context.MODE_PRIVATE);\n        writer = new BufferedWriter(new OutputStreamWriter(out));\n        writer.write(somedata);\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (writer != null) {\n                writer.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nkotlin代码示例：\n\n```kotlin\nfun save(inputText: String) {\n    // kotlin没有异常检查机制，意味着使用kotlin编写的所有代码不会强制要求你进行异常捕获或异常抛出；\n    // 此处的try catch代码块是参照Java的编程规范添加的，即使不写依然可以编译通过\n    try {\n        val output = openFileOutput(\"data\", Context.MODE_PRIVATE)\n        val writer = BufferedWriter(OutputStreamWriter(output))\n        // kotlin提供的一个内置扩展函数，保证在lambda表达式中的代码全部执行完之后自动将外层的流关闭，\n        // 这样就不用再编写一个finally语句手动去关闭流了。\n        writer.use {\n            it.write(inputText)\n        } catch (e: IOException) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### 实例\n\n创建一个FilePersistenceTest项目，修改activity_main.xml中的代码，如下：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n    <EditText\n        android:id=\"@+id/editText\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:hint=\"Type something here\" >\n    </EditText>\n</LinearLayout>\n```\n\n这里是在布局中加入了一个EditText，用于输入文本内容。\n\n此时运行程序，街面上有一个文本输入框，输入内容后，按下Back键，输入的内容就丢失了，因为此时它是一个瞬时数据，在Activity销毁后会被回收。现在要做的是，在数据被回收之前将它存储到文件中。修改MainActivity代码：\n\njava版：\n\n```java\npublic class MainActivity extends AppCompatActivity() {\n    private EditText edit;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        edit = (EditText) findViewById(R.id.edit);\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestory();\n        String inputText = edit.getText().toString();\n        save(inputText);\n    }\n    public void save(String inputText) {\n        FileOutputStream out = null;\n        BufferedWriter writer = null;\n        try {\n            out = openFileOutput(\"data\", Context.MODE_PRIVATE);\n            writer = new BufferedWriter(new OutputStreamWriter(out));\n            writer.write(inputText);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (writer != null) {\n                    writer.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\nkotlin版：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState : Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n    override fun onDestroy() {\n        super.onDestroy()\n        val inputText = editText.text.toString()\n        save(inputText)\n    }\n    private fun save(inputText: String) {\n        try {\n            val output = openFileOutput(\"data\", Context.MODE_PRIVATE)\n            val writer = BufferedWriter(OutputStreamWriter(output))\n            writer.use {\n                it.write(inputText)\n            }\n        } catch (e: IOException) {\n            e.printStackTrace()\n        }\n    }\n}\n```\n\n进入`/data/data/com.example.filetest/files/`目录，即可以看到有一个data文件。\n\n需要想办法在下次启动程序时让这些数据能够还原到EditText中。\n\n## 从文件中读取数据\n\n类似于将数据存储到文件中，Context类中还提供了一个`openFileInput`方法，用于从文件中读取数据，只接收一个参数，即要读取的文件名，然后系统会自动到`/data/data/<package name>/files/`目录下去加载这个文件，并返回一个FileInputStream对象，得到了这个对象之后再通过Java流的方式就可以将数据读取出来了。\n\nJava版：\n\n```java\npublic String load() {\n    FileInputStream in = null;\n    BufferedReader reader = null;\n    StringBuilder content = new StringBuilder();\n    try {\n        in = openFileInput(\"data\");\n        reader = new BufferedReader(new InputStreamReader(in));\n        String line = \"\";\n        while((line = reader.readLine()) != null) {\n            content.append(line);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if (reader != null) {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return content.toString();\n}\n```\n\nkotlin版：\n\n```kotlin\nfun load(): String {\n    val content = StringBuilder()\n    try {\n        val input = openFileInput(\"data\")\n        val reader = BufferedReader(InputStreamReader(input))\n        reader.use {\n            // 此处使用了一个forEachLine函数，是Kotlin提供的一个内置扩展函数，它会将读到的每行内容都回调到lambda表达式中，在lambda表达式中完成拼接逻辑即可\n            reader.forEachLine {\n                content.append(it)\n            }\n        }\n    } catch (e: IOException) {\n        e.printStackTrace()\n    }\n    return content.toString()\n}\n```\n\n在这段代码中，首先通过`openFileInput`方法获取到了一个`FileInputStream`对象，然后借助它又构建出了一个`InputStreamReader`对象，接着再使用`InputStreamReader`构建出一个`BufferedReader` 对象，这样我们就可以通过`BufferedReader`进行一行行地读取，把文件中所有的文本内容全部读取出来，并存放在一个`StringBuilder`对象中，最后返回StringBuilder的toString就可以了。\n\n修改MainActivity中的代码，使得重新启动程序时EditText中能够保留我们上次输入的内容。如下所示：\n\nJava版\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private EditText edit;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        edit = (EditText) findViewById(R.id.edit);\n        String inputText = load();\n        if (!TextUtils.isEmpty(inputText)) {\n            edit.setText(inputText);\n            edit.setSelection(inputText.length());\n            Toast.makeText(this, \"Restoring succeeded\", Toast.LENGTH_SHORT).show();\n        }\n    }\n    ...\n    public String load() {\n        FileInputStream in = null;\n        BufferedReader reader = null;\n        StringBuilder content = new StringBuilder();\n        try {\n            in = openFileInput(\"data\");\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            while((line = reader.readLine()) != null) {\n                content.append(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return content.toString();\n    }\n}\n```\n\nkotlin版：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        val inputText = load()\n        if(inputText.isNotEmpty()) {\n            editText.setText(inputText)\n            editText.setSelection(inputText.length)\n            Toast.makeText(this, \"Restoring succeeded\", Toast.LENGTH_SHORT).show()\n        }\n    }\n    private fun load(): String {\n        val content = StringBuilder()\n        try {\n            val input = openFileInput(\"data\")\n            val reader = BufferedReader(InputStreamReader(input))\n            reader.use {\n                reader.forEachLine {\n                    content.append(it)\n                }\n            }\n        } catch (e: IOException) {\n            e.printStackTrace()\n        }\n        return content.toString()\n    }\n    ...\n}\n```\n\n可以看到，在onCreate方法中调用load方法来读取文件中存储的文本内容，如果读到的内容不为null，就调用EditText的setText方法将内容填充到EditText里，并调用setSelection方法将输入光标移动到文本的末尾位置以便于继续输入，然后弹出一句还原成功的提示。\n\n注意，上述代码在对字符串进行非空判断的时候使用了TextUtils.isEmpty方法，这是一个非常好用的方法，它可以一次性进行两种空值的判断。当传入的字符串等于null或者等于空字符串的时候，这个方法都会返回true，从而使得我们不需要先单独判断这两种空值再使用逻辑运算符连接起来了。\n\n现在重新运行一下程序，刚才保存的Content字符串肯定会被填充到EditText中，然后编写一点其他的内容，比如在EditText中输入Hello，接着按下Back键退出程序，再重新启动程序，这时刚才输入的内容并不会丢失，而是还原到了EditText中。\n\n## 总结\n\n文件存储的核心技术就是Context类中提供的openFileInput和openFileOutput方法，之后就是利用Java的各种流来进行读写操作。\n\n但是文件存储的方式并不适合用于保存一些较为复杂的文本数据。\n\n# SQLite数据库存储\n\nAndroid系统内置了SQLite数据库。SQLite是一款轻量级的关系型数据库，运算速度快，占用资源少，通常只需要几百KB的内存就够了，因而特别适合在移动设备上使用。\n\nSQLite不仅支持标准的SQL语法，还遵循了数据库的ACID事务。\n\n前面的文件存储只适用于保存一些简单的数据和键值对，当需要存储大量复杂的关系型数据的时候就需要用到数据库。比如短信程序中可能会有很多个会话，每个会话中又包含了很多条信息内容，并且大部分会话还可能各自对应了电话簿中的某个联系人。\n\n## 创建数据库\n\nAndroid为了让我们能够更加方便地管理数据库，专门提供了一个SQLiteOpenHelper帮助类，借助这个类就可以非常简单地对数据库进行创建和升级。\n\nSQLiteOpenHelper是一个抽象类，这意味着要创建一个自己的帮助类继承它。SQLiteOpenHelper中有两个抽象方法，分别是onCreate和onUpgrade，必须重写这两个方法，然后分别在这两个方法中去实现创建、升级数据库的逻辑。\n\nSQLiteOpenHelper中还有两个非常重要的实例方法：getReadableDatabase和getWritableDatabase。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库）并返回一个**可对数据库进行读写操作的对象**。不同的是，当数据库不可写入的时候（如磁盘空间已满），getReadableDatabase方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase方法则将出现异常。\n\nSQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少的那个构造方法即可。这个构造方法中接收4个参数，第一个参数是Context，必须要有它才能对数据库进行操作。第二个参数是数据库名，创建数据库时使用的就是这里指定的名称。第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入null。第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。构建出SQLiteOpenHelper的实例之后，再调用它的getReadableDatabase或getWritableDatabase方法就能够创建数据库了，数据库文件会存放在`/data/data/<package name>/databases/`目录下。此时，重写的onCreate方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑。\n\n示例：我们希望创建一个名为BookStore.db的数据库，然后在这个数据库中新建一张Book表，表中有id（主键）、作者、价格、页数和书名等列。Book表建表语句：\n\n```sqlite\ncreate table Book (\n    id     integer primary key autoincrement,\n    author text,\n    price  real,\n    pages  integer,\n    name   text)\n```\n\nSQLite的数据类型很简单，integer表示整型，real表示浮点型，text表示文本类型，blob表示二进制类型。另外，上述建表语句中还使用了`primary key`将`id`列设为主键，并用`autoincrement`关键字表示id列是自增长的。然后需要在代码中去执行这条SQL语句，才能完成创建表的操作。新建MyDatabaseHelper类继承SQLiteOpenHelper，代码如下所示：\n\n```java\npublic class MyDatabaseHelper extends SQLiteOpenHelper {\n    public static final String CREATE_BOOK = \"create table Book (\"\n        + \"id integer primary key autoincrement, \"\n        + \"author text, \"\n        + \"price real, \"\n        + \"pages integer, \"\n        + \"name text)\";\n    private Context mContext;\n    public MyDatabaseHelper(Context context, String name,\n                            SQLiteDatabase.CursorFactory factory, int version) {\n        super(context, name, factory, version);\n        mContext = context;\n    }\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        db.execSQL(CREATE_BOOK);\n        Toast.makeText(mContext, \"Create succeeded\", Toast.LENGTH_SHORT).show();\n    }\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        \n    }\n}\n```\n\n建表语句定义成了一个字符串常量，然后在onCreate方法中又调用了SQLiteDatabase的execSQL方法去执行这条建表语句，并弹出一个Toast提示创建成功，这样就可以保证在数据库创建完成的同时还能成功创建Book表。\n\n修改`activity_main.xml`中的代码：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n    <Button\n        android:id=\"@+id/create_database\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Create database\">\n    </Button>\n</LinearLayout>\n```\n\n布局文件很简单，就是加入了一个按钮，用于创建数据库最后修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyDatabaseHelper dbHelper;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        dbHelper = new MyDatabaseHelper(this, \"BookStore.db\", null, 1);\n        Button createDatabase = (Button) findViewById(R.id.create_database);\n        createDatabase.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                dbHelper.getWritableDatabase();\n            }\n        });\n    }\n}\n```\n\n在onCreate方法中构建了一个MyDatabaseHelper对象，并且通过构造函数的参数将数据库名指定为 \"BookStore.db\"，版本号指定为1，然后在按钮的点击事件里调用了getWritableDatabase方法。这样当第一次点击按钮时，就会检测到当前程序中并没有BookStore.db数据库，于是会创建该数据库并调用MyDatabaseHelper中的onCreate方法，这样Book表也就得到了创建，然后会弹出一个Toast提示创建成功。再次点击按钮时，会发现此时已经存在BookStore.db数据库了，因此不会再创建一次。\n\n怎样才能证实数据库的确创建成功了？如果还是使用File Explorer，那么最多只能看到databases目录下出现了一个BookStore.db文件，Book表是无法通过File Explorer看到的。因此换一种查看方式：使用adb shell来对数据库和表的创建情况进行检查。\n\nadb是Android SDK中自带的一个调试工具，使用这个工具可以直接对连接在电脑上的手机或模拟器进行调试操作。它存放在sdk的platform-tools目录下，如果想要在命令行中使用这个工具，就需要先把它的路径配置到环境变量里。\n\n如果使用的是Windows系统，在系统变量里找到Path并点击编辑，将platform-tools目录配置进去；如果使用的是Linux或Mac系统，可以在home路径下编辑`.bash`文件，将platform-tools目录配置进去即可。\n\n打开命令行界面，输人adb shell，就进入到设备的控制台，输入su命令切换成超级管理员，接下来使用cd命令进入到`/data/data/com.example.databasetest/databases/`目录下，并使用ls命令查看到该目录里的文件。\n\n![image-20220808112149277](../../images/Android_数据和文件存储/image-20220808112149277.png)\n\n这个目录下出现了两个数据库文件，一个正是我们创建的BookStore.db而另一个BookStore.db-journal则是为了让数据库能够支持事务而产生的临时日志文件，通常情况下这个文件的大小都是0字节。\n\n![image-20220808112213683](../../images/Android_数据和文件存储/image-20220808112213683.png)\n\n接下来借助`sqlite`命令打开数据库，只需要键入`sqlite3`，后面加上数据库名即可。\n\n首先来看一下目前数据库中有哪些表，键入`.table`命令，可以看到此时数据库中有两张表，`android_metadata`表是每个数据库中都会自动生成的，而另外一张Book表就是我们在MyDatabaseHelper中创建的。这里还可以通过`.schema`命令来查看它们的建表语句。\n\n由此证明，BookStore.db数据库和Book表确实已经创建成功了。之后键入`.exit`或`.quit`命令可以退出数据库的编辑，再键入`exit`命令就可以退出设备控制台了。\n\n![image-20220808113854180](../../images/Android_数据和文件存储/image-20220808113854180.png)\n\n## 升级数据库\n\nonUpgrade方法是用于对数据库进行升级的。\n\n目前项目中已经有一张Book表用于存放书的各种详细数据，如果我们想再添加一张Category表用于记录图书的分类，该怎么做呢？比如Category表中有id（主键）、分类名和分类代码这几个列，那么建表语句就可以写成：\n```sqlite\ncreate table Category (\n    id            integer primary key autoincrement,\n    category_name text,\n    category_code integer)\n```\n\n接下来我们将这条建表语句添加到MyDatabaseHelper中，代码如下所示：\n\n```java\npublic class MyDatabaseHelper extends SQLiteOpenHelper {\n    public static String CREATE_BOOK = \"create table Book (\"\n        + \"id integer primary key autoincrement, \"\n        + \"author text, \"\n        + \"price real, \"\n        + \"pages integer, \"\n        + \"name text)\";\n    public static final String CREATE_CATEGORY = \"create table Category (\"\n        + \"id integer primary key autoincrement, \"\n        + \"category_name text, \"\n        + \"category_code integer)\";     //+\n    private Context mContext;\n    public MyDatabaseHelper(Context context, String name,\n                            SQLiteDatabase.CursorFactory factory, int version) {\n        super(Context, name, factory, version);\n        mContext = context;\n    }\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        db.execSQL(CREATE_BOOK);\n        db.execSQL(CREATE_CATEGORY);    //+\n        Toast.makeText(mContext, \"Create succeeded\", Toast.LENGTH_SHORT).show();\n    }\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        \n    }\n}\n```\n\n可见，此程序企图通过MyDatabaseHelper构造时自动调用onCreate来创建Category数据库，但是现在我们重新运行一下程序并点击按钮，没有弹出创建成功的提示。当然，可以通过adb工具到数据库中再去检查一下，这样会更加地确认Category表没有创建成功。因为按钮绑定的点击事件回调是`dbHelper.getWritableDatabase();`，而此时BookStore.db数据库已经存在了，之后不管我们怎样点击按钮，`getWritableDatabase()`都不会使MyDatabaseHelper中的onCreate方法再次执行，因此新添加的表也就无法得到创建了。可以看出，`getWritableDatabase()`只能用于创建一次数据库，之后只是单纯地打开现有的数据库并返回一个可对数据库进行读写操作的对象。\n\n正确的做法是运用SQLiteOpenHelper的升级功能，修改MyDatabaseHelper类中的代码：\n\n```java\npublic class MyDatabaseHelper extends SQLiteOpenHelper {\n    ...\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        db.execSQL(\"drop table if exists Book\");\n        db.execSQL(\"drop table if exists Category\");\n        onCreate(db);\n    }\n}\n```\n\n可以看到，我们在onUpgrade方法中执行了两条DROP语句，如果发现数据库中已经存在Book表或Category表了，就将这两张表删除掉。然后再调用onCreate方法重新创建。这里先将已经存在的表删除掉。接下来的问题就是如何让onUpgrade方法能够执行了，还记得SQLiteOpenHelper的构造方法里接收的第四个参数表示当前数据库的版本号，之前我们传人的是1，现在只要传入一个比1大的数，就可以让 onUpgrade方法得到执行了。修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyDatabaseHelper dbHelper;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        dbHelper = new MyDatabaseHelper(this, \"BookStore.db\", null, 2);\n        Button createDatabase = (Button) findViewById(R.id.create_database);\n        createDatabase.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                dbHelper.getWritableDatabase();\n            }\n        });\n    }\n}\n```\n\n这里将数据库版本号指定为2，表示我们对数据库进行升级了。现在重新运行程序，并点击按钮，这时就会再次弹出创建成功的提示。为了验证Category表已经创建成功，在adb shell中打开BookStore.db数据库，然后键入`.table`命令，接着键入`.schema`命令查看一下建表语句。由此可以看出，Category表已经创建成功了，同时也说明我们的升级功能的确起到了作用。\n\n![image-20220808144646963](../../images/Android_数据和文件存储/image-20220808144646963.png)\n\n## 添加数据\n\n如果你比较熟悉SQL语言的话，一定会知道添加数据时使用insert，查询数据时使用select，更新数据时使用update，删除数据时使用delete。但是开发者的水平总会是参差不齐的，未必每一个人都能非常熟悉地使用SQL语言，因此Android也提供了一系列的辅助性方法，使得在Android中即使不去编写SQL语句，也能轻松完成所有的CRUD操作。\n\n前面我们已经知道，调用SQLiteOpenHelper的getReadableDatabase或getwritableDatabase方法是可以用于创建和升级数据库的，不仅如此，这两个方法还都会返回一个`SQLiteDatabase`对象，借助这个对象就可以对数据进行CRUD操作了。\n\n首先向数据库的表添加数据。SQLiteDatabase中提供了一个`insert`方法：这个方法就是专门用于添加数据的。它接收3个参数，第一个参数是表名；第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可。第三个参数是一个`ContentValues`对象，它提供了一系列的`put`方法重载，用于向ContentValues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。这就是基本用法，接下来通过例子测试。修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n    \n    ...\n    \n    <Button\n        android:id=\"@+id/add_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Add data\">\n    </Button>\n</LinearLayout>\n```\n\n在布局文件中又新增了一个按钮，稍后就会在这个按钮的点击事件里编写添加数据的逻辑。接着修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyDatabaseHelper dbHelper;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        dbHelper = new MyDatabaseHelper(this, \"BookStore.db\", null, 2);\n        ...\n        Button addData = (Button) findViewById(R.id.add_data);\n        addData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                SQLiteDatabase db = dbHelper.getWritableDatabase();\n                ContentValues values = new ContentValues();\n                // 开始组装第一条数据\n                values.put(\"name\", \"The Da Vinci Code\");\n                values.put(\"author\", \"Dan Brown\");\n                values.put(\"pages\", 454);\n                values.put(\"price\", 16.96);\n                db.insert(\"Book\", null, values); // 插入第一条数据\n                values.clear();\n                // 组装第二条\n                values.put(\"name\", \"The Lost Symbol\");\n                values.put(\"author\", \"Dan Brown\");\n                values.put(\"pages\", 510);\n                values.put(\"price\", 19.95);\n                db.insert(\"Book\", null, values); // 插入第一条数据\n                values.clear();\n            }\n        });\n    }\n}\n```\n\n这里只对Book表里其中四列的数据进行了组装，id那一列没并没给它赋值。这是因为在前面创建表的时候，我们就将id列设置为自增长了，它的值会在入库的时候自动生成。接下来使用ContentValues分别组装了两次不同的内容，并调用了两次insert方法。\n\n![image-20220808151332330](../../images/Android_数据和文件存储/image-20220808151332330.png)\n\n## 更新数据\n\n接下来看看怎样修改表中已有的数据。SQLiteDatabase中也提供了一个非常好用的update方法，用于对数据进行更新，这个方法接收4个参数，第一个参数和insert方法一样是表名。第二个参数是ContentValues对象，要把更新数据在这里组装进去。第三、第四个参数用于约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行。\n\n比如说修改第一本书的价格。应该怎么操作呢？首先修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n    ...\n    <Button\n        android:id=\"@+id/update_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Update data\">\n    </Button>\n</LinearLayout>\n```\n\n添加了一个用于更新数据的按钮。然后修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyDatabaseHelper dbHelper;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        dbHelper = new MyDatabaseHelper(this, \"BookStore.db\", null, 2);\n        ...\n        Button updateData = (Button) findViewById(R.id.update_data);\n        updateData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                SQLiteDatabase db = dbHelper.getWritableDatabase();\n                ContentValues values = new ContentValues();\n                values.put(\"price\", 10.99);\n                db.update(\"Book\", values, \"name = ?\", new String[]{\"The Da Vinci Code\"});\n            }\n        });\n    }\n}\n```\n\n这里在更新数据按钮的点击事件里面构建了一个ContentValues对象，并且只给它指定了一组数据，说明只是想把价格这一列的数据更新成10.99。然后调用了SQLiteDatabase的update方法去执行具体的更新操作，可以看到，这里使用了第三、第四个参数来指定具体更新哪几行。**第三个参数对应的是SQL语句的where部分**，表示更新所有`name`等于`?`的行，而`?`是一个占位符，可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应的内容。因此上述代码想表达的意图是将名字是The Da Vinci Code的这本书的价格改成10.99。\n\n![image-20220808152812798](../../images/Android_数据和文件存储/image-20220808152812798.png)\n\n## 删除数据\n\nSQLiteDatabase中提供了一个delete方法，专门用于删除数据，这个方法接收3个参数。第一个参数仍然是表名，这个已经没什么好说的了，第二、第三个参数又是用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行。修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n    ...\n    <Button\n        android:id=\"@+id/delete_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Delete data\">\n    </Button>\n</LinearLayout>\n```\n\n修改MainActivity代码：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyDatabaseHelper dbHelper;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        dbHelper = new MyDatabaseHelper(this, \"BookStore.db\", null, 2);\n        ...\n        Button deleteData = (Button) findViewById(R.id.delete_data);\n        deleteData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                SQLiteDatabase db = dbHelper.getWritableDatabase();\n                db.delete(\"Book\", \"pages > ?\", new String[]{\"500\"});\n            }\n        });\n    }\n}\n```\n\n可以看到，我们在删除按钮的点击事件里指明去删除Book表中的数据，并且通过第二、第三个参数来指定仅删除那些页数超过500页的书。当然这个需求很奇怪，这里也仅仅是为了做个测试。你可以先查看一下当前Book表里的数据，其中The Lost Symbol这本书的页数超过了500页，也就是说当我们点击删除按钮时，这条记录应该会被删除掉。\n\n![image-20220808153356471](../../images/Android_数据和文件存储/image-20220808153356471.png)\n\n## 查询数据\n\n此处只介绍Android上的查询功能。\n\nSQLiteDatabase中还提供了一个query方法用于对数据进行查询。这个方法的参数非常复杂、最短的一个方法重载也需要传人7个参数。第一个参数还是表名；第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列；第三、第四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据；第五个参数用于指定需要去group by的列，不指定则表示不对查询结果进行group by操作；第六个参数用于对group by之后的数据进行进一步的过滤，不指定则表示不进行过滤；第七个参数用于指定查询结果的排序方式，不指定则表示使用默认的排序方式。更多详细的内容可以参考下表。其他几个query方法的重载其实也大同小异，这里就不再进行介绍了。\n\n| query方法参数 | 对应SQL部分               | 描述                            |\n| ------------- | ------------------------- | ------------------------------- |\n| table         | from table_name           | 指定表名                        |\n| columns       | select column1, column2   | 指定列名                        |\n| selection     | where column = value      | 指定where约束条件               |\n| selectionArgs | -                         | 为where条件中的占位符提供具体值 |\n| groupBy       | group by column           | 指定需要group by的列            |\n| having        | having column = value     | 对group by后的结果进一步约束    |\n| orderBy       | order by column1, column2 | 指定查询结果的排序方式          |\n\n虽然query方法的参数非常多，但是不要对它产生畏惧，因为我们不必为每条查询语句都指定所有的参数，多数情况下只需要传入少数几个参数就可以完成查询操作了。调用query方法后会返回一个Cursor对象，查询到的所有数据都将从这个对象中取出。\n\n修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n    ...\n    <Button\n        android:id=\"@+id/query_data\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Query data\">\n    </Button>\n</LinearLayout>\n```\n\n修改MainActivity中的代码：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyDatabaseHelper dbHelper;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        dbHelper = new MyDatabaseHelper(this, \"BookStore.db\", null, 2);\n        ...\n        Button queryData = (Button) findViewById(R.id.query_data);\n        queryData.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                SQLiteDatabase db = dbHelper.getWritableDatabase();\n                Cursor cursor = db.query(\"Book\", null, null, null, null, null, null);\n                if(cursor.moveToFirst()) {\n                    do {\n                        // 遍历Cursor对象，取出数据并打印\n                        String name = cursor.getString(cursor.getColumnIndex(\"name\"));\n                        String author = cursor.getString(cursor.getColumnIndex(\"author\"));\n                        int pages = cursor.getInt(cursor.getColumnIndex(\"pages\"));\n                        double price = cursor.getDouble(cursor.getColumnIndex(\"price\"));\n                        Log.d(\"MainActivity\", \"book name is \" + name);\n                        Log.d(\"MainActivity\", \"book author is \" + author);\n                        Log.d(\"MainActivity\", \"book pages is \" + pages);\n                        Log.d(\"MainActivity\", \"book price is \" + price);\n                    } while (cursor.moveToNext());\n                }\n                cursor.close();\n            }\n        });\n    }\n}\n```\n\n我们首先在查询按钮的点击事件里面调用了SQLiteDatabase的query方法去查询数据。这里的query方法非常简单，只是使用了第一个参数指明去查询Book表，后面的参数全部为null。这就表示希望查询这张表中的所有数据，虽然这张表中目前只剩下一条数据了。查询完之后就得到了一个Cursor对象，接着我们调用它的moveToFirst方法将数据的指针移动到第一行的位置，然后进入了一个循环当中，去遍历查询到的每一行数据。在这个循环中可以通过Cursor的getColumnIndex方法获取到某一列在表中对应的位置索引，然后将这个索引传入到相应的取值方法中，就可以得到从数据库中读取到的数据了。接着我们使用Log的方式将取出的数据打印出来，借此来检查一下读取工作有没有成功完成。最后别忘了调用close方法来关闭Cursor。\n\n点击一下Querydata按钮后，查看logcat的打印内容。\n\n![image-20220808160134432](../../images/Android_数据和文件存储/image-20220808160134432.png)\n\n## 使用SQL操作数据库\n\n虽然Android已经给我们提供了很多非常方便的API用于操作数据库，不过有一些人不习惯去使用这些辅助性的方法，而是更加青睐于直接使用SQL来操作数据库。这种人一般都属于SQL大牛，Android充分考虑到了这些人的编程习惯，同样提供了一系列的方法，使得可以直接通过SQL来操作数据库。下面就来简略使用SQL来完成前面的CRUD操作。\n\n* 添加数据的方法如下：\n  ```java\n  db.execSQL(\"insert into Book (name, author, pages, price) values(?, ?, ?, ?)\",\n             new String[]{\"The Da Vinci Code\", \"Dan Brown\", \"454\", \"16.96\"});\n  db.execSQL(\"insert into Book (name, author, pages, price) values(?, ?, ?, ?)\",\n             new String[]{\"The Lost Symbol\", \"Dan Brown\", \"510\", \"19.95\"});\n  ```\n\n* 更新数据的方法如下：\n  ```java\n  db.execSQL(\"update Book set price = ? where name = ?\",\n             new String[]{\"10.99\", \"The Da Vinci Code\"});\n  ```\n\n* 删除数据的方法如下：\n  ```java\n  db.execSQL(\"delete from Book where pages > ?\", new String[]{\"500\"});\n  ```\n\n* 查询数据的方法如下：\n  ```java\n  db.rawQuery(\"select * from Book\", null);\n  ```\n\n可以看到，除了查询数据的时候调用的是SQLiteDatabase的rawQuery方法，其他的操作都是调用的execSQL方法。选择使用哪一种方式就看你个人的喜好了。\n","categories":["Android"]},{"title":"Android_Intent","url":"/Android/Android_Intent/","content":"\n# 简介\n\nIntent主要解决活动之间的相互跳转。\n\n# FirstActivity\n\n从Add No Activity手动创建活动。\n\n右击`com.example.activitytest`包，新建一个Empty Activity，命名为`FirstActivity.java`。\n\n创建和加载布局：\n\n1. 右击`app/src/main/res`目录，新建一个目录，名为`layout`，对着`layout`目录右键新建一个Layout resource file，会弹出一个新建布局资源文件的窗口，将此布局文件命名为`first_layout.xml`，根元素写成LinearLayout。\n\n2. 编辑`first_layout.xml`。\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n       android:layout_width=\"match_parent\"\n       android:layout_height=\"match_parent\"\n       android:orientation=\"vertical\">\n   \n       <Button\n           android:id=\"@+id/button_1\"\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"wrap_content\"\n           android:text=\"Button 1\"></Button>\n   </LinearLayout>\n   <!-- 这里添加了一个Button元素，并在Button元素的内部增加了几个属性。\n   android:id是给当前的元素定义一个唯一标识符，之后可以在代码中对这个元素进行操作。\n   @+id/button_1这种语法可能比较陌生，但如果把加号去掉，变成@id/button_1就成为了在xml中引用资源的语法。\n   只不过是把string替换成了id。这说明，如果你需要在xml中引用一个id，就使用@id/id_name这种语法。\n   而如果需要在xml中定义一个id则要使用@+id/id_name这种语法。\n   随后android:layout_width指定了当前元素的宽度；\n   使用match_parent表示让当前元素和父元素一样宽。\n   android:layout_height指定了当前元素的高度。\n   这里使用wrap_content表示当前元素的高度只要能刚好包含里面的内容就行。\n   android:text指定了元素中显示的文字内容 -->\n   ```\n\n3. 重新回到FirstActivity,java，在onCreate方法中加入一行代码\n\n   ```java\n   public class FirstActivity extends AppCompatActivity {\n       @Override\n       protected void onCreate(Bundle savedInstanceState) {\n           super.onCreate(savedInstanceState);   //默认有这行\n           /**\n            * 这里调用了setContentView方法来给当前活动加载一个布局，\n            * 一般传入一个布局文件的id。\n            * 项目中添加的任何资源都会在R文件中生成一个相应的资源id，\n            * 因此创建的first_layout.xml布局的id已添加到R文件中。\n            * 只需要调用R.layout.first_layout就可以得到first_layout.xml布局的id\n            */\n           setContentView(R.layout.first_layout);//加入此行\n       }\n   }\n   ```\n\n4. 所有的活动都要在AndroidManifest.xml文件中注册才能生效。在`application`标签内通过添加`activity`标签来对活动进行注册。但是仅仅注册活动还是不够的，因为还没为程序配置主活动。也就是说程序运行起来后不知道首先要启动哪个活动。配置主活动的方法就是在`<activity>`标签的内部加入`<intent-filter>`标签，并在此标签里添加`<action android:name=\"android.intnet.action.MAIN\" />`和`<category android:name=\"android.intent.category.LAUNCHER\" />`这两句声明即可。\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n       package=\"com.example.intenttest\">\n   \n       <application\n           android:allowBackup=\"true\"\n           android:icon=\"@mipmap/ic_launcher\"\n           android:label=\"@string/app_name\"\n           android:roundIcon=\"@mipmap/ic_launcher_round\"\n           android:supportsRtl=\"true\"\n           android:theme=\"@style/Theme.IntentTest\">\n           <!-- 此处定义程序的主活动，即点击桌面应用程序图标时首先打开的就是这个活动\n                如果没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装，\n                只是无法在启动器中看到或者打开此程序。这种程序一般是作为第三方服务供其他应用在内部进行调用，\n                如支付宝快捷支付服务。-->\n           <!-- 在<activity>中使用了android:name来指定具体注册哪一个活动。\n                .FirstAcitivty表示com.example.activitytest.FirstActivity的缩写。\n                由于最外层的<manifest>标签中已经通过package属性指定了程序的包名是com.example.activitytest，因此在注册活动时这一部分可以省略，直接使用.FirstActivity。-->\n               <!-- android:label可指定活动中标题栏的内容，标题栏是显示在活动最顶部。\n                    给主活动指定的label不仅会成为标题栏中的内容，还会成为启动器(Launcher)\n                    中应用程序显示的名称。-->\n           <activity\n               android:name=\".FirstActivity\"\n               android:label=\"This is FirstActivity\"\n               android:exported=\"true\">\n               <intent-filter>\n                   <action android:name=\"android.intent.action.MAIN\" />\n                   <category android:name=\"android.intent.category.LAUNCHER\" />\n               </intent-filter>\n           </activity>\n       </application>\n   </manifest>\n   ```\n\n销毁活动：\n\n1. 如何销毁一个活动？最简单的方法是按一下Back键就可以销毁当前的活动。如果不想通过按键的方式，而是希望在程序中通过代码来销毁活动，则调用Activity类提供的finish方法，就可以销毁当前活动了。\n\n2. 修改按钮监听器中的代码：\n\n   ```java\n   button1.setOnClickListener(new View.OnClickListener() {\n       @Override\n       public void onClick(View v) {\n           finish();\n       }\n   });\n   ```\n\n3. 重新运行程序，点击一下按钮，当前的活动就被销毁了。效果和按下back键是一样的。\n\n# Intent\n\n编写第二个活动。创建一个Empty Activity，活动的对话框中，不要勾选Launcher Activity选项。\n\n由于SecondActivity不是主活动，因此不需要配置`<intent-filter>`标签里的内容，注册活动的代码也简单了很多。\n\n剩下的问题是如何去启动此SecondActivity活动。\n\n需要引入一个概念——Intent。\n\nIntent是Android程序中各组件之间进行交互的一种重要方式，不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。\n\nIntent一般可被用于启动活动、启动服务以及发送广播等场景。\n\nIntent大致可以分为两种：显式Intent和隐式Intent。\n\n# 显式Intent\n\n意图很明显的Intent，称之为显式Intent。\n\nIntent有多个构造函数的重载，其中一个是`Intent(Context packageContext, Class<?> cls)`。这个构造函数接受两个参数，第一个参数`Context`要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动。\n\n如何使用此Intent？\n\nActivity类中提供了一个`startActivity()`方法，此方法是专门用于启动活动的，接收一个Intent参数。可把构建好的Intent传入startActivity方法就可以启动目标活动了。\n\nFirstActivity中按钮的点击事件，代码如下：\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener(){\n    @Override\n    public void onClick(View v){\n        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);\n        startActivity(intent);\n    }\n});\n```\n\n首先构建出了一个Intent，传入`FirstActivity.this`作为上下文，传入`SecondActivity.class`作为目标活动。这个Intent意图即为在FirstActivity这个活动的基础上打开SecondActivity这个活动。通过startActivity()方法来执行这个Intent。\n\n# 隐式Intent\n\n相比于显式Intent，隐式Intent则含蓄了许多，它并不明确指出要启动哪一个活动，而是指定了一系列抽象的action和category等信息。然后交由系统去分析这个Intent，帮忙找出合适的活动来启动。\n\n何为合适的活动？简单来说是可以响应我们这个隐式Intent的活动。目前SecondActivity还不能响应隐式Intent。\n\n通过在`<activity>`标签下配置`<intent-filter>`的内容，可以指定当前活动能够响应的`action`和`category`，打开`AndroidManifest.xml`，添加如下代码：\n\n```xml\n<activity android:name=\".SecondActivity\" >\n    <intent-filter>\n        <action android:name=\"com.example.activitytest.ACTION_START\"></action>\n        <category android:name=\"android.intent.category.DEFAULT\"></category>\n    </intent-filter>\n</activity>\n```\n\n在`<action>`这个标签中我们指明了当前活动可以响应`com.example.activity.ACTION_START`这个action，而`<category>`标签则包含了一些附加信息，更精确地指明了当前的活动能够响应的Intent中还可能带有的category。只有`<action>`和`<category>`中的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。\n\n修改FirstActivity中按钮的点击事件，代码如下所示：\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener(){\n    @Override\n    public void onClick(View v){\n        Intent intent = new Intent(\"com.example.activitytest.ACTION_START\");\n        startActivity(intent);\n    }\n});\n```\n\n此处使用到了Intent的另一个构造函数，直接将action的字符串传了进去，表明想要启动能够响应`com.example.activitytest.ACTION_START`这个action的活动。为何没有指定category？因为`android.intent.category.DEFAULT`是一种默认的category，在调用startActivity方法的时候会自动将这个category添加到Intent中。\n\n## 指定多个category\n\n每个Intent中只能指定一个action，但却能指定多个category。\n\n最开始Intent只有一个默认的category。现在来增加一个。可以调用Intent中的`addCategory`方法来添加一个category。\n\n修改FirstActivity中按钮的点击事件，代码如下所示：\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener(){\n    @Override\n    public void onClick(View v){\n        Intent intent = new Intent(\"com.example.activity.ACTION_START\");\n        intent.addCategory(\"com.example.activitytest.MY_CATEGORY\");\n        startActivity(intent);\n    }\n});\n```\n\n这里我们指定了一个自定义的category，值为`com.example.activitytest.MY_CATEGORY`。调用Intent中的`addCategory`方法来添加一个category。\n\n这时，工作还没完毕，SecondActivity的`<intent-filter>`标签中并没有声明可以响应这个category，所以此时没有任何活动可以响应该Intent。现在我们在`<intent-filter>`中再添加一个category的声明，如下：\n\n```xml\n<activity android:name=\".SecondActivity\">\n    <intent-filter>\n        <action android:name=\"com.example.activitytest.ACTION_START\"></action>\n        <category android:name=\"android.intent.category.DEFAULT\"></category>\n        <category android:name=\"com.example.activitytest.MY_CATEGORY\"></category>\n    </intent-filter>\n</activity>\n```\n\n## 更多用法\n\n使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得Android多个应用程序之间的功能可以共享。比如你的应用程序需要展示一个网页，没必要自己去实现一个浏览器，只需要调用系统的浏览器来打开这个网页。\n\n修改FirstActivity中按钮点击事件的代码，如下：\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View view) {\n        /**\n         * 这里首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统\n         * 内置的动作，其常量值为android.intent.action.VIEW。然后通过Uri.parse()方法\n         * 将一个网址字符串解析成一个Uri对象，再调用Intent的setData()方法将这个Uri对象传递进去\n         */\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(Uri.parse(\"http://www.baidu.com\"));\n        startActivity(intent);\n    }\n});\n```\n\n与此对应，我们还可以在`<intent-filter>`标签中再配置一个`<data>`标签，用于更精确地指定当前活动能够响应什么类型的数据。`<data>`标签中主要可以配置以下内容。\n\n* `android:scheme`用于指定数据的协议部分，如上例中的http部分。\n* `android:host`用于指定数据的主机名部分，如上例中`www.baidu.com`部分。\n* `android:port`用于指定数据的端口部分，一般紧随在主机名之后。\n* `android:path`用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容\n* `android:mimeType`用于指定可以处理的数据类型，允许使用通配符的方式进行指定。\n\n只有data标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该Intent。一般在`<data>`标签中不会指定过多的内容，如上面浏览器示例中，其实只要指定`android:scheme`为http就可以响应所有的http协议的Intent了。\n\n为了理解，建立ThirdActivity，布局文件起名为`third_layout`。\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    <Button>\n        android:id=\"@+id/button_3\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button 3\"\n    </Button>\n</LinearLayout>\n```\n\nThirdActivity.java中的代码保持不变就可以了。\n\n在AndroidManifest.xml中修改ThirdActivity的注册信息：\n\n```xml\n<activity android:name=\".ThirdActivity\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\"></action>\n        <category android:name=\"android.intent.category.DEFAULT\"></category>\n        <data android:scheme=\"http\"></data>\n    </intent-filter>\n</activity>\n```\n\n我们在ThirdActivity的`<intent-filter>`中配置了当前活动能够响应的action是`Intent.ACTION_VIEW`的常量值，而category则毫无疑问指定了默认的category值，另外在`<data>`标签中我们通过`android:scheme`指定了数据的协议必须是http协议，这样ThirdActivity应该就和浏览器一样，能够响应一个打开网页的Intent了。运行一下程序试试，在FirstActivity的界面点击一下按钮，结果应该可以看到系统自动弹出一个列表，显示了目前能够响应这个Intent的所有程序。可响应的程序有两个：一是Broswer，会打开浏览器并显示网页；二是这个app名字，会启动ThirdActivity，但是实际上这个活动并没有加载、显示网页的功能。\n\n# 向活动传递数据\n\n## 向下一个活动传递\n\nIntent不仅可以启动一个活动，还可以在启动活动的时候传递数据。\n\nIntent中提供了一系列`putExtra`方法的重载，可以把我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出就可以了。比如FirstActivity中有一个字符串，现在想把这个字符串传递到SecondActivity中，可以这样编写：\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        String data = \"Hello SecondActivity\";\n        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);\n        intent.putExtra(\"extra_data\", data);\n        startActivity(intent);\n    }\n});\n```\n\n这里我们使用显示Intent的方式来启动SecondActivity，并通过`putExtra()`方法传递了一个字符串。注意这里putExtra方法接收两个参数，第一个参数是键，用于后面从Intent中取值，第二个参数才是真正要传递的数据。\n\n然后在SecondActivity中将传递的数据取出，并打印出来，代码如下：\n\n```java\npublic class SecondActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.second_layout);\n        Intent intent = getIntent();\n        String data = intent.getStringExtra(\"extra_data\");\n        Log.d(\"SecondActivity\", data);\n    }\n}\n```\n\n首先可以通过`getlntent`方法获取到用于启动`SecondActivity`的`Intent`，然后调用`getStringExtra`方法，传入相应的键值，就可以得到传递的数据了。这里由于我们传递的是字符串，所以使用`getStringExtra`方法来获取传递的数据。如果传递的是整型数据，则使用`getlntExtra`方法；如果传递的是布尔型数据，则使用`getBooleanExtra`方法，以此类推。\n\n重新运行程序，在FirstActivity的界面点击一下按钮会跳转到SecondActivity，査看logcat打印的信息。\n\n```\n507-24507/com.example.intenttest D/SecondActivity: Hello SecondActivity\n```\n\n## 向上一个传递\n\n既然可以传递数据给下一个活动，那么能不能够返回数据给上一个活动呢？答案是肯定的。不过不同的是，返回上一个活动只需要按一下Back键就可以了，并没有一个用于启动活动的Intent来传递数据。通过查阅文档发现，Activity中还有一个`startActivityForResult()`方法也是用于启动活动的，但这个方法期望在**活动销毁的时候能够返回一个结果给上一个活动**。毫无疑问，这就是我们所需要的。\n\n`startActivityForResult`方法接收两个参数，第一个参数还是Intent，第二个参数是**请求码**，用于在之后的回调中判断数据的来源。我们修改FirstActivity中按钮的点击事件，代码如下所示∶\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View view) {\n        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);\n        startActivityForResult(intent, 1);\n    }\n});\n```\n\n这里我们使用了startActivityForResult方法来启动SecondActivity，请求码只要是一个唯一值就可以了，这里传入了1。接下来我们在SecondActivity中给按钮注册点击事件，并在点击事件中添加返回数据的逻辑，代码如下所示：\n\n```java\npublic class SecondActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.second_layout);\n        Button button2 = (Button) findViewById(R.id.button_2);\n        button2.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent();\n                intent.putExtra(\"data_return\", \"Hello FirstActivity\");\n                setResult(RESULT_OK, intent);\n                finish();\n            }\n        });\n    }\n}\n```\n\n可以看到，我们还是构建了一个Intent，只不过这个Intent仅仅是用于传递数据而已，它没有指定任何的“意图”。紧接着把要传递的数据存放在Intent中，然后调用了setResult方法。这个方法非常重要，是专门用于向上一个活动返回数据的。setResult方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这两个值，第二个参数则把带有数据的Intent传递回去，然后调用了finish方法来销毁当前活动。\n\n由于我们是使用startActivityForResult方法来启动SecondActivity的，在SecondActivity被销毁之后会回调上一个活动的onActivityResult方法，因此我们需要在FirstActivity中重写这个方法来得到返回的数据，如下所示∶\n\n```java\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n    switch (requestCode) {\n        case 1:\n            if(resultCode == RESULT_OK) {\n                String returnedData = data.getStringExtra(\"data_return\");\n                Log.d(\"FirstActivity\", returnedData);\n            }\n            break;\n        default:\n    }\n}\n```\n\nonActivityResult方法带有三个参数，第一个参数requestCode，即我们在启动活动时传入的请求码。第二个参数resultCode，即我们在返回数据时传入的处理结果。第三个参数data，即携带着返回数据的Intent。由于在一个活动中有可能调用startActivityForResult方法去启动很多不同的活动，每一个活动返回的数据都会回调到onActivityResult这个方法中，因此我们首先要做的就是通过检查requestCode的值来判断数据来源。确定数据是从SecondActivity返回的之后，我们再通过resultCode的值来判断处理结果是否成功。最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作。\n\n重新运行程序，在FirstActivity的界面点击按钮会打开SecondActivity，然后在SecondActivity界面点击Button2按钮会回到FirstActivity，这时查看logcat的打印信息。\n\n```\n31184-31184/com.example.intenttest D/FirstActivity: Hello FirstActivity\n```\n\n但是可能会存在缺陷。如果用户在SecondActivity中并不是通过点击按钮，而是通过按下back键回到FirstActivity，这样数据就无法返回到上一个活动。可以在SecondActivity中重写onBackPressed方法来解决：\n\n```java\n@Override\npublic void onBackPressed() {\n    Intent intent = new Intent();\n    intent.putExtra(\"data_return\", \"Hello FirstActivity\");\n    setResult(RESULT_OK, intent);\n    finish();\n}\n```\n\n如此，当用户按下back键，就会去执行onBackPressed方法中的代码。\n\n","categories":["Android"]},{"title":"Cpp_创建目录","url":"/Cpp/Cpp_创建目录/","content":"\n参考文章：https://blog.csdn.net/guotianqing/article/details/109823501\n\n# system调用\n\n简单粗野，适用于Linux系统。\n\n```cpp\nint main(int argc, char **argv)\n{\n    if(argc != 2)\n    {\n        cout << \"Usage: \" << argv[0] << \" dir\" << endl;\n        return -1;\n    }\n    string path(argv[1]);\n    string cmd(\"mkdir -p \" + path);\n    int ret = system(cmd.c_str());\n    if(ret)\n    {\n        cout << \"create dir error: \" << ret << \", :\" << stderror(errno) << endl;\n        return -1;\n    }\n    cout << \"system cmd create dir ok: \" << argv[1] << endl;\n    return 0;\n}\n```\n\n此方式，直接使用系统命令执行Linux下mkdir命令创建目录，缺点是system系统调用时，要处理各种返回值情况。\n\n# mkdir函数\n\n`C++`中提供了用于创建目录的函数，原型如下：\n\n```cpp\nint mkdir(const char * path, mode_t mode);\n// The file permission bits of the new directory shall be initialized from mode\n// If path names a symbolic link, mkdir() shall fail and set errno to [EEXIST].\n// Upon successful completion, mkdir() shall return 0. Otherwise, -1 shall be returned, no directory shall be created, and errno shall be set to indicate the error.\n```\n\n可能的错误如下：\n\n* EACCES - 访问错误\n  * Search permission is denied on a component of the path prefix, or write permission is denied on the parent directory of the directory to be created.\n* EEXIST - 已存在\n  * The named file exists.\n* ELOOP - 链接错误\n  * A loop exists in symbolic links encountered during resolution of the path argument.\n* EMLINK - 链接达到上限\n  * The link count of the parent directory would exceed `LINK_MAX`.\n* ENAMETOOLONG - 名字太长\n  * The length of the path argument exceeds `PATH_MAX` or a pathname component is longer than `NAME_MAX`.\n* ENOENT - 目录前缀有部分不存在\n  * A component of the path prefix specified by path does not name an existing directory or path is an empty string.\n* ENOSPC - 没有足够空间\n  * The file system does not contain enough space to hold the contents of the new directory or to extend the parent directory of the new directory.\n* ENOTDIR - 目录前缀有一部分不是目录\n  * A component of the path prefix is not a directory.\n* EROFS - 文件系统只读\n  * The parent directory resides on a read-only file system.\n\n目录的权限如下：\n\n```\nUser:   S_IRUSR (read), S_IWUSR (write), S_IXUSR (execute)\nGroup:  S_IRGRP (read), S_IWGRP (write), S_IXGRP (execute)\nOthers: S_IROTH (read), S_IWOTH (write), S_IXOTH (execute)\n```\n\n\n它们组合在一起，形成了如下快捷方式：\n\n```\nRead + Write + Execute: S_IRWXU (User), S_IRWXG (Group), S_IRWXO (Others)\nDEFFILEMODE: Equivalent of 0666 = rw-rw-rw-\nACCESSPERMS: Equivalent of 0777 = rwxrwxrwx\n```\n\n使用mkdir函数，替换上面程序中的核心代码：\n\n```cpp\nret = mkdir(path.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\nif(ret && errno == EEXIST)\n{\n    cout << \"dir: \" << path << \" already exist\" << endl;\n}\nelse if(ret)\n{\n    cout << \"create dir error: \" << ret << \", :\" << strerror(errno) << endl;\n    return -1;\n}\nelse\n{\n    cout << \"mkdir create dir succ: \" << path << endl;\n}\n```\n\n# boost库create_directory\n\n```cpp\n#include<boost/filesystem.hpp>\nif(!boost::filesystem::is_directory(path))\n{\n    cout << \"begin create path: \" << path << endl;\n    if(!boost::filesystem::create_directory(path))\n    {\n        cout << \"create_directories failed: \" << path << endl;\n        return -1;\n    }\n}\nelse\n{\n    cout << path << \" already exist\" << endl;\n}\n```\n\n编译时增加`-lboost_system -lboost_filesystem`选项。\n\n注意，以上函数只能用于创建单个目录，不能创建多级目录，否则会抛异常\n\n```\nbegin create signal_dir: ./c/d\nterminate called after throwing an instance of 'boost::filesystem::filesystem_error'\n  what():  boost::filesystem::create_directory: No such file or directory: \"./c/d\"\n[1]    16669 abort (core dumped)  ./a.out ./c/d\n```\n\n如果需要一次创建多级目录，需要调用`create_directories`\n\n# C++17库create_directory\n\n原型如下：\n\n```cpp\n// 以所有权限创建单个目录，父目录必须存在，如果目录已经存在，不会报错\nbool create_directory(const std::filesystem::path& p);\nbool create_directory(const std::filesystem::path& p, std::error_code& ec) noexcept;\n// 与上面一样，只不过创建的目录的权限是从已经存在的目录属性拷贝过来的。这个特性依赖操作系统\nbool create_directory(const std::filesystem::path& p, const std::filesystem::path& existing_p);\nbool create_directory(const std::filesystem::path& p, const std::filesystem::path& existing_p, std::error_code& ec) noexcept;\n// 创建层级目录，为每级不存在的目录调用第一个函数，如果目录已经存在，它什么也不做，且不会报错\nbool create_directories(const std::filesystem::path& p);\nbool create_directories(const std::filesystem::path& p, std::error_code& ec);\n// 创建成功返回true，否则false\n```\n\n使用与boost类似，示例代码如下：\n\n```cpp\n#include <filesystem>\nif (std::filesystem::create_directories(path))\n{\n\tcout << \"fs create dir succ: \" << path << endl;\n}\n```\n","categories":["Cpp"]},{"title":"Linux_环境配置","url":"/Linux/Linux_环境配置/","content":"# `.profile`\n`.profile` 文件在 Linux/Unix 系统中扮演着重要的角色，它是位于用户家目录 (`~/`) 下的一个​**​隐藏文件​**​（以点开头）。它主要用于在​**​登录 shell​**​ 的初始化过程中为特定用户设置​**​环境变量​**​和​**​启动程序​**​。\n\n以下是关于 `.profile` 文件的详细说明：\n\n1. ​**​主要目的：用户环境定制​**​\n    \n    - ​**​设置环境变量：​**​ 这是 `.profile` 最常见的用途。你可以在这里设置 `PATH`（决定系统去哪里查找可执行命令）、`EDITOR`（默认文本编辑器）、`LANG`（系统语言和区域设置）、`JAVA_HOME`、`PYTHONPATH` 等等。这些变量定义了你的工作环境。\n    - ​**​运行启动命令：​**​ 你可以在登录时自动运行某些命令或小脚本。例如：\n        - 显示欢迎信息或系统状态 (`uptime`, `fortune`, `echo \"Welcome back, $USER\"`)\n        - 设置命令别名 (`alias ll='ls -l'`)\n        - 设置 shell 选项 (`set -o noclobber` - 防止覆盖文件)\n        - 启动代理或后台服务（以前更常见，现在可能有更好的方法）\n2. ​**​执行时机：登录时​**​\n    \n    - 当你通过​**​登录 shell​**​ 进入系统时，`.profile` 文件会被自动读取和执行。\n    - 什么是登录 shell？\n        - 通过控制台（文本登录界面）登录。\n        - 使用 `ssh username@hostname` 远程登录。\n        - 使用 `su - username` 或 `sudo -i`（切换用户并模拟完整登录）。\n        - 图形界面登录后启动的​**​第一个​**​终端（取决于桌面环境和终端模拟器的配置，有时是登录 shell，有时不是）。\n    - ​**​重要：​**​ 并非所有终端会话都是登录 shell。如果你只是打开一个新的终端窗口（标签页），它通常是​**​非登录 shell​**​，不会读取 `.profile`，而是读取 `.bashrc`（对于 bash）或类似的文件。\n3. ​**​与系统级配置的关系​**​\n    \n    - ​**​`/etc/profile`​**​: 这是一个系统级别的全局配置文件，在用户登录时，​**​最先​**​被执行。\n    - ​**​`/etc/profile.d/*.sh`​**​: `/etc/profile` 通常会调用执行这个目录下所有的 `.sh` 脚本文件，用于存放系统级别的额外配置。\n    - ​**​`~/.profile`​**​: 在 `/etc/profile` 之后执行。它是用户​**​定制自己登录环境​**​的主要地方，可以覆盖或补充系统级别的设置。\n    - ​**​`~/.bash_profile` 或 `~/.bash_login` (bash 特有)​**​: 如果 `.profile` 所在的 shell 是 bash，并且用户家目录下存在 `~/.bash_profile` 或 `~/.bash_login`，那么 bash 会​**​优先执行它们​**​，而​**​跳过​**​ `~/.profile`（除非这些文件显式地 `source ~/.profile`）。\n    - ​**​`~/.bashrc` (bash 特有)​**​: 主要用于​**​非登录的交互式 shell​**​ (即大部分新打开的终端窗口)。在登录 shell 中，如果 `~/.bash_profile` 存在，它通常会去调用 `~/.bashrc`，这样登录 shell 也能获得其中的设置（别名、函数等）。\n4. ​**​文件命名与位置​**​\n    \n    - ​**​路径：​**​ 位于用户的家目录下，即 `~/.profile` 或 `/home/username/.profile`。\n    - ​**​兼容性：​**​ `.profile` 是一个比较通用的名字，被 Bourne Shell (`sh`)、Bash、Korn Shell (`ksh`) 等广泛支持。它为不同 shell 提供了一个公共的配置点。\n    - ​**​Shell 专属文件：​**​ 许多用户（尤其是 bash 用户）更喜欢或习惯使用 `~/.bash_profile`（用于登录 bash）和 `~/.bashrc`（用于交互式非登录 bash），并将 `.profile` 用作备用或兼容配置。\n5. ​**​查看与编辑​**​\n    \n    - 查看：`cat ~/.profile` 或 `less ~/.profile`\n    - 编辑：使用你喜欢的文本编辑器（如 `nano ~/.profile`, `vim ~/.profile`）。确保你编辑的是你自己的家目录下的文件。\n6. ​**​重要注意事项​**​\n    \n    - ​**​生效需要：​**​ 修改 `.profile` 后，这些更改​**​不会​**​立即在当前已经打开的会话中生效（因为你修改时，登录过程已经完成）。要让修改生效，你需要：\n        - ​**​方法一 (推荐)：​**​ 重新登录（logout 后再 login）。\n        - ​**​方法二：​**​ 在当前的登录 shell 中执行 `source ~/.profile` 或 `. ~/.profile` 命令来强制重新加载该文件。\n    - ​**​谨慎修改：​**​ 错误的语法（比如引号不匹配、错误的变量赋值）或执行有问题的命令可能导致你登录时出错，甚至无法登录。在修改重要文件前最好备份。\n    - ​**​`~/.bash_profile` vs `~/.profile` (bash 用户):​**​ 如果 `~/.bash_profile` 存在，bash 会忽略 `~/.profile`。因此，很多系统默认创建的是 `.profile`，但如果用户创建了 `.bash_profile`，它就会接管。推荐做法是让 `~/.bash_profile` 里简单地包含 `source ~/.profile`，然后再包含 `source ~/.bashrc`，这样可以同时兼容登录配置和交互配置。\n\n## ​总结​\n`.profile` 是个人 Linux/Unix 环境的核心配置文件之一。它在你通过登录 shell 进入系统时自动运行，其主要任务是为你定义个性化的环境变量（如 `PATH`, `EDITOR`）和登录时需要运行的命令或脚本。理解它与 `/etc/profile`、`~/.bash_profile`、`~/.bashrc` 等文件的关系和执行顺序，对于有效管理和定制你的 shell 环境至关重要。\n# Linux配置相关\n\n[bashrc source后长期有效](https://www.csdn.net/tags/MtTaEg0sMDg4NTIyLWJsb2cO0O0O.html)","categories":["Linux"]},{"title":"Android_应用基础知识","url":"/Android/Android_应用基础知识/","content":"\n# Android应用\n\n可以使用Kotlin、Java和`C++`语言编写Android应用。Android SDK工具会将代码连同任何数据和资源文件编译成一个APK（Android package, Android软件包），即带有`.apk`后缀的归档文件；或者Android App Bundle。\n\n* 一个APK文件包含Android应用在运行时的必需内容，它也是Android设备用来安装应用的文件。\n* 一个AAB文件包含一个Android应用程序项目，包括一些在运行时不需要的附加元数据。ABB是一种发布格式，是不可安装到Android设备上的，它推迟(defer)APK的生成、签名到更晚的阶段。在Google Play分发应用程序时，Google Play的服务器才生成优化后的APK，仅包含特定设备安装应用所需要的资源和代码。\n\n每个 Android 应用都处于各自的安全沙盒中，并受以下 Android 安全功能的保护：\n\n- Android 操作系统是一种多用户 Linux 系统，其中每个应用都是一个不同的用户；\n- 默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID（该 ID 仅由系统使用，应用并不知晓）。系统会为应用中的所有文件设置权限，使得只有被分配给该应用的用户id对应的用户才能访问这些文件；\n- 每个进程都拥有自己的虚拟机 (VM)，因此应用代码独立于其他应用而运行。\n- 默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 系统会在需要执行任何应用组件时启动该进程，然后当不再需要该进程或系统必须为其他应用恢复内存时，其便会关闭该进程。\n\nAndroid系统实现了**应用最少特权**的原则。也就是说，默认情况下，每个应用程序只能访问其工作所需的组件，没有更多。这创造了一个非常安全的环境，在该环境中，应用程序无法访问未经许可的系统部分。但是，一个应用程序可以通过其他方法与其他应用程序共享数据，并且应用程序可以访问系统服务：\n\n* 可以安排两个app共享相同的Linux用户ID。在这种情况下，他们可以访问彼此的文件。为了节省系统资源，具有相同用户ID的app也可以安排在相同的Linux进程中运行并共享相同的VM。这些app还必须被签署相同的证书签名。\n* 一个app可以请求许可来访问设备数据，比如设备的定位、摄像头、蓝牙连接。用户必须明确地授予这些许可。\n\n# 应用程序组件（App components）\n\n应用程序组件是Android应用程序的重要构件模块。系统或用户可以通过每个组件来进入app。有些组件依赖其他组件。\n\n有四大类应用程序组件：\n\n1. Activity\n2. Service\n3. Broadcast receiver\n4. Content provider\n\n每种类型都有一个独特的目的，并且具有独特的生命周期，可以定义组件的创建和破坏方式。\n\n## Activity\n\nActivity是与用户交互的切入点，代表着具有用户界面的一个屏幕。比如，一个邮箱app可能有一个activity，展示了一列新邮件，另一个activity用于撰写邮件，以及另一activity在阅读邮件。尽管这些activity共同工作去形成凝聚的用户体验，但每个activity独立于其他activity。例如，如果电子邮件app允许，其他的app可以从任意一个activity启动。比如，拍照app可以启动邮箱app的activity，以撰写一个新的邮件，由此允许用户来分享照片。\n\nActivity促进着系统和app之间的以下关键交互：\n\n* 持续跟踪用户当前关心什么（屏幕上有什么），来确保系统继续运行在托管着activity的进程。\n* 了解先前使用的进程包含用户可能返回的内容（已停止的activity），因此更优先地保持这些进程。\n* 帮助app处理终止其进程的情况，便于用户返回到已恢复其之前状态的activity。\n* 为app提供一种用户流交互的实现，并让系统协调这些流。（最经典的示例是共享）\n\n>An *activity* is the entry point for interacting with the user. It represents a single screen with a user interface. For example, an email app might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. Although the activities work together to form a cohesive user experience in the email app, each one is independent of the others. As such, a different app can start any one of these activities if the email app allows it. For example, a camera app can start the activity in the email app that composes new mail to allow the user to share a picture. An activity facilitates the following key interactions between system and app:\n>\n>- Keeping track of what the user currently cares about (what is on screen) to ensure that the system keeps running the process that is hosting the activity.\n>- Knowing that previously used processes contain things the user may return to (stopped activities), and thus more highly prioritize keeping those processes around.\n>- Helping the app handle having its process killed so the user can return to activities with their previous state restored.\n>- Providing a way for apps to implement user flows between each other, and for the system to coordinate these flows. (The most classic example here being share.)\n\n# 异步消息Intent启动组件\n\n在四种组件类型中，有三种类型（Activity, Service, Broadcast Receiver）均通过**异步消息Intent**进行启动，Intent会在运行时对各个组件进行互相绑定。可以将Intent视为请求其他组件做出动作的信使，无论这个组件是属于你的app还是其他app。\n\n需要使用Intent对象创建Intent，该对象通过定义消息来启动特定组件（显式Intent）或特定的**组件类型**（隐式Intent）。\n\n对于Activity和服务，Intent 会定义要执行的操作（例如，`view`或`send`某内容），并且可指定待操作数据的`URI`，以及正在启动的组件可能需要了解的信息。例如，Intent可能会传达对Activity的请求，以便显示图像或打开网页。在某些情况下，可以通过启动Activity来接收结果，这样Activity还会返回`Intent`中的结果。例如，您可以发出一个Intent，让用户选取某位联系人并将其返回给您。返回的Intent包含指向所选联系人的URI。\n\n每种组件都有独特的启动方法：\n\n1. 可以通过传递一个`Intent`调用`startActivity()`启动一个activity或给这个activity新的事情去做。（或者`startActivityForResult()`，当你想让activity返回一个结果时）\n2. \n\n# 清单文件（AndroidManifest.xml）\n\n在Android系统启动应用组件之前，系统必须通过读取应用的清单文件(`AndroidManifest.xml`)确认组件存在。应用必须在此文件中声明其所有组件，该文件必须**位于应用项目目录的根目录**中。\n\n除了声明应用的组件外，清单文件还有许多其他作用，如：\n\n- 确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限。\n- 根据应用使用的API，声明应用所需的最低[API级别](https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels)。\n- 声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕。\n- 声明应用需要链接的API库（Android框架API除外），如[Google地图库](http://code.google.com/android/add-ons/google-apis/maps-overview.html)。\n\n## 声明组件\n\n清单文件的主要任务是告知系统应用组件的相关信息。例如，清单文件可按如下所示声明Activity：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest ... >\n    <application android:icon=\"@drawable/app_icon.png\" ... >\n        <activity android:name=\"com.example.project.ExampleActivity\"\n                  android:label=\"@string/example_label\" ... >\n        </activity>\n        ...\n    </application>\n</manifest>\n```\n\n在`<application>`元素中，`android:icon`属性指向标识应用的图标所对应的资源。\n\n在`<activity>`元素中，`android:name`属性指定`Activity`子类的完全限定类名，`android:label`属性指定用作Activity的用户可见标签的字符串。\n\n您必须使用以下元素声明所有应用组件：\n\n- Activity的`<activity>`元素。\n- 服务的`<service>`元素。\n- 广播接收器的`<receiver>`元素。\n- 内容提供程序的`<provider>`元素。\n\n如果未在清单文件中声明源代码中包含的Activity、服务和内容提供程序，则这些组件对系统不可见，因此不会运行。不过，可以`BroadcastReceiver`对象的形式，在清单中声明或在代码中动态创建广播接收器；以及通过调用`registerReceiver()`，在系统中注册广播接收器。\n\n## 声明组件功能\n\n如上文启动组件中所述，可以使用`Intent`来启动Activity、服务和广播接收器。您可以通过在Intent中显式命名目标组件（使用组件类名）来使用`Intent`。还可使用隐式Intent，通过它来描述要执行的操作类型和待操作数据（可选）。借助隐式 Intent，系统能够在设备上找到可执行该操作的组件，并启动该组件。如果有多个组件可以执行Intent所描述的操作，则**由用户选择使用哪一个组件**。\n\n>注意：如果使用Intent来启动`Service`，需要使用显式Intent来确保应用的安全性。使用隐式Intent启动服务存在安全隐患，因为无法确定哪些服务将响应Intent，且用户无法看到哪些服务已启动。从Android 5.0（API级别21）开始，如果使用隐式Intent调用`bindService()`，系统会抛出异常。所以勿为服务声明Intent过滤器。\n\n通过将收到的Intent与设备上其他应用的清单文件中提供的**Intent过滤器**进行比较，系统便可识别能响应Intent的组件。\n\n在应用的清单文件中声明Activity时，您可以选择性地加入声明Activity功能的Intent过滤器，以便响应来自其他应用的 Intent。可以将`<intent-filter>`元素作为组件声明元素的子项进行添加，从而为组件声明Intent过滤器。\n\n例如，如果构建的电子邮件应用包含用于撰写新电子邮件的Activity，则可通过声明Intent过滤器来响应`“send”`Intent（目的是发送新电子邮件），如下方示例所示：\n\n```xml\n<manifest ... >\n    ...\n    <application ... >\n        <activity android:name=\"com.example.project.ComposeEmailActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.SEND\" />\n                <data android:type=\"*/*\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n```\n\n如果另一个应用创建包含`ACTION_SEND`操作的Intent并将其传递到`startActivity()`，则系统可能会启动您的Activity，以便用户能够草拟并发送电子邮件。\n\n## 声明应用要求\n\nAndroid设备多种多样，但并非所有设备都提供相同的特性和功能。以防将应用安装在缺少应用所需特性的设备上，必须通过在清单文件中声明设备和软件要求，为该应用支持的设备类型明确定义一个配置文件。其中的大多数声明只是为了提供信息，系统并不会读取它们，但Google Play等外部服务会读取它们，以便在用户通过其设备搜索应用时为用户提供过滤功能。\n\n例如，如果应用需要相机功能，并使用Android 2.1（API级别7）中引入的 API，必须在清单文件中声明以下要求，如下方示例所示：\n\n```xml\n<manifest ... >\n    <uses-feature android:name=\"android.hardware.camera.any\"\n                  android:required=\"true\" />\n    <uses-sdk android:minSdkVersion=\"7\" android:targetSdkVersion=\"19\" />\n    ...\n</manifest>\n```\n\n通过示例中所述的声明，没有相机且Android版本低于2.1的设备将无法从Google Play安装您的应用。不过，可以声明应用使用相机，但并不要求必须使用。在此情况下，`required`属性设置为`false`，并在运行时检查设备是否拥有相机，然后根据需要停用任何相机功能。\n\n# 应用资源\n\nAndroid应用并非仅包含代码，它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。例如，可以通过XML文件定义Activity界面的动画、菜单、样式、颜色和布局。借助应用资源，无需修改代码即可轻松更新应用的各种特性。通过提供备用资源集，可以针对各种设备配置（如不同的语言和屏幕尺寸）优化应用。\n\n对于在Android项目中加入的每一项资源，SDK构建工具均会定义唯一的整型ID，可以利用此ID来引用资源，这些资源或来自应用代码，或来自XML中定义的其他资源。例如，如果您的应用包含名为`logo.png`的图像文件（保存在`res/drawable/`目录中），则SDK工具会生成名为`R.drawable.logo`的资源ID。此ID映射到应用特定的整型数，您可以利用它来引用该图像，并将其插入您的界面。\n\n如果提供与源代码分离的资源，则其中最重要的一个优点在于，可以提供适用于不同设备配置的备用资源。例如，通过在XML中定义界面字符串，可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。然后，Android系统会根据向资源目录名称追加的语言限定符（如为法语字符串值追加`res/values-fr/`）和用户的语言设置，对界面应用相应的语言字符串。\n\nAndroid支持许多不同的备用资源限定符。限定符是资源目录名称中加入的短字符串，用于定义这些资源适用的设备配置。例如，您应根据设备的屏幕方向和尺寸为Activity创建不同的布局。当设备屏幕为纵向（长型）时，可能想要一种垂直排列按钮的布局；但当屏幕为横向（宽型）时，可以按水平方向排列按钮。如要根据方向更改布局，可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。然后，系统会根据当前设备方向自动应用相应的布局。\n","categories":["Android"]},{"title":"Linux_三剑客","url":"/Linux/Linux_三剑客/","content":"\n# 内容\n\n1. grep\n2. awk\n3. sed\n\n# awk\n\n是按`{域 分隔符 域}`生成报表的工具。\n\n经典应用有：把（文本）文件中浮点数的整数部分解析出来。\n\n```sh\n# file.txt\n1.7\n12.89\n23.9\n```\n\n```sh\nawk -F. '{print $1}' file.txt\n# 执行结果\n\t# 1\n\t# 12\n\t# 23\n```\n\n重定向：\n\n```sh\nawk -F. '{print $1}' file.txt > newfile\ncat newfile\n# 执行结果(来自newfile)\n\t# 1\n\t# 12\n\t# 23\n```\n\n小改动：把（文本）文件**中浮点数的**小数**部分解析出来。\n\n```sh\nawk -F. '{print $2}' file.txt > newfile\ncat newfile\n# 执行结果(来自newfile)\n\t# 7\n\t# 89\n\t# 9\n```\n\n```sh\ncp /etc/passwd .\nawk -F: '{print $1,$3}' passwd\nawk -F: '{if($3 >= 1000) print $1,$3}' passwd\nawk -F: 'BEGIN{print \"name\\t uid\"}{print $1\"\\t\"$3}END{print\"----end----\"}' passwd\n```\n\n## 场景--对命令执行输出的信息进行处理\n\n### 编写脚本杀死全部当前正在睡眠的进程\n\n```sh\n# some shells are sleeping...\nps -ef | grep sleep | grep -v \"grep\"\n# xcg\t4168\t4162\t0\t......\nps -ef | grep sleep | grep -v \"grep\" | awk '{print $2}' # 4168\n```\n\n```sh\n#!/usr/bin/bash\nPIDS=`ps -ef | grep sleep | grep -v \"grep\" | awk '{print $2}'`\nif [ -z \"$PIDS\" ]\nthen\n\techo \"没有sleeping进程在运行\"\n\texit 0\nfi\nfor pid in $PIDS\t\t# PIDS不要加双引号，如果加了，那么pid会一次接收整个PIDS。虽然也能(kill xxx xxx,而不是kill xxx,kill xxx)。但是echo只echo一次，输出出现问题。\ndo\n\tkill $pid\n\techo \"进程:$pid 被杀死了\"\ndone\n```\n\n### 结合netstat -natp命令\n\n获取端口、地址信息、状态信息去处理\n\n### 结合free命令\n\n# sed\n\n是对文件进行编辑的工具。在某行增删内容。\n\n示例：对文件文本进行简单处理\n\n```sh\n# file.txt\n1.7\n12.89\n23.9\n```\n\n```sh\nsed '2i\\3.3' file.txt > newfile # 在第二行之前插入3.3，之后的行下移一行、\n# 1.7\n# 3.3\n# 12.89\n# 23.9\n```\n\n```sh\nsed '2a\\3.3' file.txt > newfile # 在第二行下面附加3.3，之后的行下移一行\n# 1.7\n# 12.89\n# 3.3\n# 23.9\n```\n\n```sh\nsed '2,3d' file.txt > newfile # 删除第2、3行\n# 1.7\n```\n\n```sh\nsed '1,2p' file.txt # 打印1~2行，但是默认会重复打印\n# 1.7\n# 1.7\n# 12.89\n# 12.89\n# 23.9\nsed '1,3p' file.txt # 打印1~3行，但是默认会重复打印\n# 1.7\n# 1.7\n# 12.89\n# 12.89\n# 23.9\n# 23.9\nsed -n '1,2p' file.txt # 只打印1~2行\n# 1.7\n# 12.89\n```\n\n# 三剑客结合\n\n要灵活运用三剑客，应对两种结合方式：\n\n1. 结合，对文件操作\n2. 结合，对命令操作\n\n```sh\nnetstat -natp\t\t\t      # 未过滤\nnetstat -natp | grep tcp      # 注意，此时 \"|\" 这个管道只能用来 过滤 标准输出(1)的信息，如果前面的信息有标准错误输出stderr(2)则无法过滤。\nnetstat -natp 2>&1 | grep tcp # 此时已把标准错误输出2重定向到1,这时再过滤时将会一视同仁。\n```\n\n未过滤的结果：\n![image-20220222015642539](../../images/Linux_三剑客/image-20220222015642539.png)\n\n标准错误输出未重定向时：\n`|`管道默认只传输标准输出1的内容，因此grep只对标准输出1进行了过滤。第一行括号的提示内容是标准错误输出2的东西。\n![image-20220222015307603](../../images/Linux_三剑客/image-20220222015307603.png)\n\n标准错误输出重定向后（过滤掉上面的提示信息）：\n`netstat -natp 2>&1 | grep tcp`\n其中，`2>&1`表示的是：标准输出2重定向到1，其中，`>&`必须同时使用，表示：把2重定向到1并且一起传输给管道。\n`2>1`不能：创建名为 \"1\" 的文件并写入错误信息。\n`2&1`不能：误认为`&`是后台执行命令\n\n>因此，我们想在命令行把程序执行后的输出结果输出到文件中时，可以这样：`./cmpxz DCE 20250709 >log.txt 2>&1`\n\n![image-20220222015341443](../../images/Linux_三剑客/image-20220222015341443.png)\n\nsed剔除前n行后（过滤掉上面的提示信息做法2）：\n\n```sh\nnetstat -natp | sed -n '4,$p' # 输出4行及之后的全部行\n```\n\n![image-20220222015940913](../../images/Linux_三剑客/image-20220222015940913.png)\n\n结合awk提取第4列（Local Address）：\n\n```sh\nnetstat -natp | sed -n '4,$p' | awk 'print $4'\n```\n\n![image-20220222020120370](../../images/Linux_三剑客/image-20220222020120370.png)\n\n接上一步，提取地址信息中的端口号。\n\n```sh\nnetstat -natp | sed -n '4,$p' | awk 'print $4' | awk -F: '{print $2}'\n```\n\n![image-20220222020238848](../../images/Linux_三剑客/image-20220222020238848.png)\n\n但是出现问题，最后的\":::22\"和\"::1:631\"被忽略了。需要另分一类特殊处理。\n\n然后，我们用上面这个命令，可以做以下工作：查询某个端口是否被打开？\n\n```sh\n#!/usr/bin/bash\nif [ \"$#\" -ne 1 ]\nthen\n\techo \"请输入查询的端口\"\n\texit 0\nfi\n\ntest_port=$1\n\nPORTS=`netstat -natp 2>&1 | sed -n '4,$p' | awk '{print $4}' | awk -F: '{print $2}'`\nif [ -z \"$PORTS\" ]\nthen\n\techo \"没有打开的端口\"\n\texit 0\nfi\n\nport=\"\"\nfor i in $PORTS\ndo\n\tif [ \"$i\" -eq \"$test_port\" ]\n\tthen\n\t\tport=$i\n\tfi\ndone\nif [ -n \"$port\" ]\nthen\n\techo \"端口:$port 是打开的\"\nelse\n\techo \"端口:$port 未打开\"\nfi\n```\n\n![image-20220222020743625](../../images/Linux_三剑客/image-20220222020743625.png)\n\n# 日积月累\n\n## awk从指定列打印到最后一列\n\nhttps://stackoverflow.com/questions/1602035/how-to-print-third-column-to-last-column\n\n![image-20220801103120355](../../images/Linux_三剑客/image-20220801103120355.png)\n\n![image-20220801103359029](../../images/Linux_三剑客/image-20220801103359029.png)\n\n其中，涉及了两个awk内置变量：NF和FS。\n\n![image-20220801103601475](../../images/Linux_三剑客/image-20220801103601475.png)\n","categories":["Linux"]},{"title":"git_stash","url":"/git/git_stash/","content":"\n参考文章：https://blog.csdn.net/qq_32452623/article/details/76100140\n\n# 一句话解释stash的工作\n\n将修改存储到暂存区，工作区会删除这些修改。\n\n总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，**stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上**。\n\ngit stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。\n\n# 为什么我们需要它\n\n使用这个命令的场景：\n\n此时我在`feature_666`分支非常聚精会神加持高专注地实现一个功能`666`模块，简直键盘如飞的编写代码。\n\n然后这时，客户反馈出一个bug，非常严重，必须立马解决，优先级为0！\n\n于是，需要去到`release`分支去checkout新的分支去工作了，但是`666`功能还没完成怎么办？\n\n此时面临着一个选择题：\n\nA：提交后切换，代码保存到分支`feature_666`，却产生一个无意义的提交\n\nB：不提交直接切换，然而这个选项根本没人会选。\n\n是不是很难选，此时，别忘记还有C选项！\n\nC：使用`git stash`，将当前修改(未提交的代码)存入缓存区，切换分支修改bug，回来再通过`git stash pop`取出来。\n\n```bash\ngit stash save \"本地缓存内容标识\" # 把本地当前改动暂存起来，此时master分支就恢复到了上次拉取时的状态\ngit checkout test # 切换到需要改动的分支\ngit stash pop　　　 # 将改动pop到自己当前的分支\n```\n\n\n\n## 还有一种场景 - 代码冲突\n\n我在本地修改好后，发现远程分支已经被改动了，此时我本地也被改动了就造成了冲突，**无法push或者pull**。\n\n此时可以使用`git stash`：\n\n```bash\ngit stash save \"本地缓存内容标识\" # 把本地的改动暂存起来;\ngit pull # 拉取远端分支（此时本地分支会回滚到上次commit的情况，新的改动都已保存在了stash中）;\ngit stash pop # 将栈顶改动内容重新加回本地分支，就可以继续修改了，当然，如果改好了就是add,commit,push操作。\n```\n\n# 例子\n\n## 存储修改\n\nOK， 上一个commit的时候，代码快照是这个样子的\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String s = \"大家好，我是xcg\";\n    }\n}\n```\n\n此时的我在写代码如下：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String s = \"大家好，我是xcg\";\n        String s1 = \"我现在在写一个超级厉害的功能，但是我还没写完,甚至还有点地方在报错\";\n    }\n}\n```\n代码到此处，紧急bug出现了，一秒都不能等， 选择下列操作。\n\n```bash\ngit stash #将修改存储到暂存区，工作区会删除这些修改\ngit checkout <bug_branch>\n```\n\n![image-20220815152311937](../../images/Linux_git/image-20220815152311937.png)\n\n暂存后的工作区代码会恢复到最后一次提交时的代码：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String s = \"大家好，我是xcg\";\n    }\n}\n```\n\n## 查看修改\n\n如果你有丢失代码的经历，肯定会对这个之前没接触的新命令不放心，那么怎么确定你操作成功了呢？\n\n```bash\ngit stash show #查看刚才暂存的修改\n```\n\n![image-20220815152500609](../../images/Linux_git/image-20220815152500609.png)\n\n## 取出修改\n\n现在bug改完了，要重新回来开发了，取出修改\n\n```bash\ngit checkout <feture_branch> # 切换刚才功能开发的分支\ngit stash pop # 取出修改\n```\n\n![image-20220815152542661](../../images/Linux_git/image-20220815152542661.png)\n\n取出修改后的工作区代码为：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String s = \"大家好，我是段小憨\";\n        String s1 = \"我现在在写一个超级厉害的功能，但是我还没写完,甚至还有点地方在报错\";\n    }\n}\n```\n\n# 关于stash更多的细节\n\n通过上面的例子，已经知道如何使用git stash了，但是，如果理解它的一些细节的话，会使用得更加灵活和得心应手。\n\n## 修改存储到什么位置了?\n\n当我们使用`git init`给项目添加版本控制的时候，会在项目路径下生成一个`.git`隐藏文件夹。`.git`中存储着版本管理的所有信息。`.git/refs/stash`中，存储的是最后一个`stash`对应的节点指针。\n\n![image-20220815152613130](../../images/Linux_git/image-20220815152613130.png)\n\n同样，在`.git/log/refs/stash`中可以看到我们全部的stash记录信息。\n\n## 存储多个stash的情况\n\n我们来尝试一下修改文件，然后再次使用`git stash`，此时我们有个两个暂存修改，那么怎么查看呢？\n\n```bash\ngit stash list # 查看暂存区的所有暂存修改记录\n```\n\n![image-20220815152651571](../../images/Linux_git/image-20220815152651571.png)\n\n此时你有没有发现，这两个的名称是一样，这是个什么鬼？\n\n别怕，名称是一样的，但是指向的修改是不一样的，我们从`.git/log/refs/stash`中可以看到两者的对应的节点指针是不一样的。\n\n### 增删查\n\n如果再次执行git stash，新的改动将会出现在栈顶，栈中元素会越来越多，此时可以使用`git stash list`命令查看栈中元素，此时每个栈中元素会有自己对应的编号。\n\n使用`git stash apply stash@{0}`（0可以换成对应编号），来添加不同改动。同样，也可以`git stash drop stash@{0}`来删除对应改动。`git stash clear`可以清空。\n\n## stash的存储的名称是怎么来的，可以修改吗？\n\n当使用`git stash`创建stash的时候，会给stash一个默认的名称。\n\n![image-20220815152721588](../../images/Linux_git/image-20220815152721588.png)\n\n之前有说，stash存储的内容就是，当前工作区距当前分支最后一次提交时的修改。所以，stash的默认命名规则就是：\n`WIP on <branch_name> : <latest_commit_id> <latest_commit_message>`。\n\n其中WIP解释如下：`Work In Progess`的简称，说明代表了工作区进度。\n\n同样的还有Index，代表的是已经被add但是还未被提交的进度。\n\n如果在未提交的情况下，执行`git stash`两次，就如上图，无法准确分辨两个`stash`具体修改的是哪些内容，这样用，显的伟大的Git一点都不智能，怎么可以！\n\n所以，在这种情况下，给stash存储的修改起个名字，显然非常重要，方式如下：`git stash save <message>`。\n\n## 取出也有好几种方式\n\n上面的演示中，取出stash的方式都是\n\n```bash\ngit stash pop  # 取出最近一次暂存并删除记录列表中对应记录\n```\n\n\n这是一个非常好用的取出方式，一般使用的频率最高，但并非适用所有情况。\n\n因为`git stash pop`是弹出栈顶的一个`stash`，也就是最后一次存储的`stash`。在存储多个stash ，想**取出非栈顶**的一个的情况下，是不适用的。\n\n这个时候要使用：\n\n```bash\ngit stash list # 查看暂存区的所有暂存修改\ngit stash apply stash@{X} # 取出相应的暂存\ngit stash drop stash@{X} # 将记录列表中取出的对应暂存记录删除\n```\n\n# git stash与add关系\n\ngit add只是把文件加到git版本控制里，并不等于就被stash起来了，git add和git stash没有必然关系，但是执行git stash能正确存储的前提是文件必须在git版本控制中才行。\n\n常规git stash的一个限制是它会暂存所有的文件。有时，只备份某些文件更为方便，让另外一些与代码库保持一致。一个非常有用的技巧，用来备份部分文件：\n\n1. add那些你不想备份的文件（例如：`git add file1.js, file2.js`）；\n2. 调用`git stash –keep-index`。只会备份那些没有被add的文件。\n3. 调用`git reset`取消已经add的文件的备份，继续自己的工作。\n","categories":["git"]},{"title":"Ubuntu20.04安装MySQL8.0","url":"/数据库/Ubuntu20.04安装MySQL8.0/","content":"\n### 下载安装\n\n下载mysql命令：\n\n```bash\nsudo apt-get update  #更新软件源\nsudo apt-get install mysql-server  #安装mysql\n```\n\n### 服务启动/停止\n\n启动/关闭mysql服务：\n\n```bash\nservice mysql start\nservice mysql stop\n```\n\n### 修改root用户密码\n\n查看默认用户名及密码：\n\n```bash\n# 首先，切换到管理员身份\nsu\nsudo cat /etc/mysql/debian.cnf\n```\n\n使用显示的默认user及password登录：\n\n```bash\nmysql -u debian-sys-maint -pXXX\n```\n\n执行下列命令：\n\n```sql\nuse mysql;\nselect user, plugin from mysql.user;\n```\n\n![image-20220724225357816](../../images/Ubuntu20.04安装MySQL8.0/image-20220724225357816.png)\n\n```sql\nupdate user set plugin='caching_sha2_password' where user='root';\n```\n\n![image-20220724225327069](../../images/Ubuntu20.04安装MySQL8.0/image-20220724225327069.png)\n\n设置`mysql root`账户密码：\n\n```sql\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123';\nFLUSH PRIVILEGES;\nExit;\n```\n\n使用`mysql -u root -p`尝试登录：\n\n```bash\nmysql -u root -p123\n```\n\n### 用户管理（Navicat远程登录配置）\n\nMySQL8.0后的登录方式分为了两种。\n\n```sql\nselect user, host, plugin from mysql.user;\n```\n\n![image-20220724225534065](../../images/Ubuntu20.04安装MySQL8.0/image-20220724225534065.png)\n\n`localhost`表示本地登录的用户。\n`%`表示可以远程登录的用户。默认是没有的，需要手动创建。\n\n**创建用户示例**\n\n```sql\ncreate user 'xcg'@'localhost' identified by '123'; #创建名为xcg的本地用户，密码为123\ncreate user 'root'@'%' identified WITH mysql_native_password by '123'; #创建名为root的远程用户，密码为123，指定加密方式。\n```\n\n**修改用户密码，指定加密方式。示例**\n\n```sql\nALTER user 'root'@'localhost' IDENTIFIED WITH mysql_native_password by '123456';\n```\n\n**授权用户对哪些数据库的哪些表可以进行操作**\n\n```sql\ngrant all privileges on *.* to root@'%' with grant option; # *.* 表示所有数据库的所有表\n```\n\n**删除用户**\n\n```sql\ndrop user 'name'@'localhost';\n```\n\n### 导入数据库sql脚本\n\n在登录mysql之后，用`source`命令+sql脚本文件路径导入脚本命令。\n可以用vscode远程登录后，将sql文件拖进一个容易找到的位置。\n导入之前需要提前创建好数据库，并且use。\n\n```sql\ncreate database test;\nuse test;\nsource /home/xcg/vscode/chat.sql #不用带分号\n```\n\n导入后，可以`show tables;`查看是否成功。","categories":["数据库","MySQL"]},{"title":"分布式系统的中间件选型和日志模块","url":"/项目/分布式系统的中间件选型和日志模块/","content":"# 项目软件结构\n\n* 网络层\n    * 多线程+`reactor+one loop per thread`+`socket api`\n    * 同步/异步/阻塞/非阻塞\n    * `select`/`poll`/`epoll`\n    * 池化技术\n    * IO模型\n    * 网络数据包的收发过程\n* 业务层\n    * 状态机/MVC模式\n* 缓存层\n    * 为了存储过程的高效性，使用内存型数据库 - `redis`/`memcached`，其中`redis`可以持久化\n* 存储层\n    * 关系型数据库 - `mysql`/`oracle`/`sql server`/`maridb`/`mongodb`\n\n# 环境配置\n\n主要是云服务器的购买、远程登录配置、vscode ssh remote配置，git配置，远程仓库配置。\n\n# 日志组件\n\n```\n[时间戳][带颜色 日志级别][文件名][函数名][行号] - [日志msg]\n```\n\n## 组成部分\n\n分为两个部分，前面的部分封装为一个日志头部，记为Message类。后面的具体信息内容拼接在头部之后即可。\n\n* 日志级别\n\n1、重要程度；2、日志级别越细，打印的信息就越多，会对磁盘IO造成影响，影响性能。一般来说，有这些类别：info、debug、error、fatal。我们分别设置为白色、绿色、黄色、红色。\n\n* 文件名、函数名、行号可以用C语言内置的宏。\n\n```c\nint main()\n{\n    printf(\"[file:%s] [function:%s] [lineNumber:%d]\\n\", __FILE__, __FUNCTION__, __LINE__);\n}\n```\n\n## 时间戳类Timestamp\n\n```mermaid\nclassDiagram\nclass Timestamp{\n\t-secondSinceEpoch : uint64_t\n\t+TimeStamp()\n\t+TimeStamp(uint64_t)\n\t+ToString() string\n\t+Now()\n}\n```\n\n## 日志类Logger\n\n### 消息类Message\n\n由两大部分组成，一部分是消息头，显示信息发生的位置，二是消息体，是具体内容。\n\n```mermaid\nclassDiagram\nclass Message{\n\t-m_coloredHeader //带颜色的日志头 输出到terminal\n\t-m_commonHeader //不带颜色的日志头 输出到logfile\n\t-m_msg 日志消息\n\t-formatFieldWithColor(COLOR_NUMBER, bool dark, string delimiter, string fieldName, bool colored) string\n\t+Message(LOG_LEVEL, string fileName, string functionName, int lineNumber)\n\t+FormatHeader(LOG_LEVEL, string fileName, string functionName, int lineNumber, bool colored) string\n\t+ToString(bool colored) string\n\t+operator<<(constT& t)\n}\n```\n\n### 日志类Logger\n\n```mermaid\nclassDiagram\nclass Logger{\n\t-m_level : LOG_LEVEL\n\t-m_logToTerminal : bool\n\t-m_logToFile : bool\n\t-m_logFile : std::fstream\n\t-Logger()\n\t+getInstance()\n\t+SetLogToTerminal(bool logToTerminal)\n\t+GetLogToTerminal() bool\n\t+SetLogToFile(bool logToFile)\n\t+GetLogToFile(const string& logFileName) bool\n\t+SetLogFile(const std::string & logFileName)\n\t+OffLogFile()\n\t+SetLogLevel(LOG_LEVEL level)\n\t+GetLogLevel() LOG_LEVEL\n\t+operator+=(constMessage& msg)\n}\n```\n\n日志类的设计模式为单例模式，把构造函数私有化，提供生成对象的静态方法。\n\n## Linux errno\n\n系统调用抛出的错误信息首先是一个错误码，如果要和我们自己实现的日志类结合的话，需要知道Linux errno的含义。\n\nLinux中系统调用的错误都存储于errno中，errno由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。\n\n对errno的测试\n\n```c\n#include<stdio.h>\nint main()\n{\n    int res = open(\"./a.txt\", O_RDONLY, 0664);\n    if(-1 == res)\n    {\n        perror(\"open()\");\n    }\n}\n-------------\n/* 输出结果\n * \topen(): No such file or directory\n */\n说明，perror括号里的内容只是错误信息前面的开头部分，后面的部分才是刚刚发生的错误的errno所对应的错误信息内容。\n```\n\n看open的帮助手册，在return value部分，手册写到：\n`open(), openat(), and creat() return the new file descriptor, or -1 if an error occurred (in which case, errno is set appropriately).`\n\n可见，返回值和errno是相互独立的，返回值为-1说明此系统调用出错，而具体的错误类型需要用errno来标识，由内核标识。\n\n### perror和strerror\n\n* perror\n\n手册中对perror的描述(`man 3 perror`)\n`The perror() function produces a message on standard error describing the last error encountered during a call to a system or library function.`\n\n关键信息：perror描述的是最后一次错误，是由系统调用产生的错误，将输出到标准错误输出中。\n\n* strerror\n\n我们想要的效果是：通过errno找到对应的msg消息。这个工作可以通过strerror找到。\n\n```cpp\n#include<string.h>\nint main()\n{\n    int res = open(\"./a.txt\", O_RDONLY, 0664);\n    if(-1 == res)\n    {\n        LOG_ERROR << strerror(errno);\n    }\n}\n```\n\n### errno与Logger类的结合使用\n\n```cpp\nint main()\n{\n    int res = open(\"./a.txt\", O_RDONLY, 0664);\n    if(-1 == res)\n    {\n        LOG_ERROR << strerror(errno);\n    }\n}\n```\n\n### 系统中errno的位置及含义\n\n查看系统中所有的errno所代表的含义，可以采用如下的代码：\n\n```c\n#include <stdio.h>\n#include <string.h>     //for strerror()\n//#include <errno.h>\nint main()\n{\n    for(int tmp = 0; tmp <=256; tmp++)\n    {\n        printf(\"errno: %2d\\t%s\\n\", tmp, strerror(tmp));\n    }\n    return 0;\n}\n/* 最后的效果\n * \t[2022/04/17 09:42:40][ERROR][logger.cc][main][61]: No such file or directory\n */\n```\n\nLinux中，在头文件 `/usr/include/asm-generic/errno-base.h` 对基础常用errno进行了宏定义：\n\n```c\nifndef _ASM_GENERIC_ERRNO_BASE_H\n#define _ASM_GENERIC_ERRNO_BASE_H\n\n#define EPERM            1      /* Operation not permitted */\n#define ENOENT           2      /* No such file or directory */\n#define ESRCH            3      /* No such process */\n#define EINTR            4      /* Interrupted system call */\n#define EIO              5      /* I/O error */\n#define ENXIO            6      /* No such device or address */\n#define E2BIG            7      /* Argument list too long */\n#define ENOEXEC          8      /* Exec format error */\n#define EBADF            9      /* Bad file number */\n#define ECHILD          10      /* No child processes */\n#define EAGAIN          11      /* Try again */\n#define ENOMEM          12      /* Out of memory */\n#define EACCES          13      /* Permission denied */\n#define EFAULT          14      /* Bad address */\n#define ENOTBLK         15      /* Block device required */\n#define EBUSY           16      /* Device or resource busy */\n#define EEXIST          17      /* File exists */\n#define EXDEV           18      /* Cross-device link */\n#define ENODEV          19      /* No such device */\n#define ENOTDIR         20      /* Not a directory */\n#define EISDIR          21      /* Is a directory */\n#define EINVAL          22      /* Invalid argument */\n#define ENFILE          23      /* File table overflow */\n#define EMFILE          24      /* Too many open files */\n#define ENOTTY          25      /* Not a typewriter */\n#define ETXTBSY         26      /* Text file busy */\n#define EFBIG           27      /* File too large */\n#define ENOSPC          28      /* No space left on device */\n#define ESPIPE          29      /* Illegal seek */\n#define EROFS           30      /* Read-only file system */\n#define EMLINK          31      /* Too many links */\n#define EPIPE           32      /* Broken pipe */\n#define EDOM            33      /* Math argument out of domain of func */\n#define ERANGE          34      /* Math result not representable */\n\n#endif\n```\n\n其他错误码定义在 `/usr/include/asm-generic/errno.h`中。\n\n```c\n#ifndef _ASM_GENERIC_ERRNO_H\n#define _ASM_GENERIC_ERRNO_H\n\n#include <asm-generic/errno-base.h>\n\n#define\tEDEADLK\t\t35\t/* Resource deadlock would occur */\n#define\tENAMETOOLONG\t36\t/* File name too long */\n#define\tENOLCK\t\t37\t/* No record locks available */\n#define\tENOSYS\t\t38\t/* Function not implemented */\n#define\tENOTEMPTY\t39\t/* Directory not empty */\n#define\tELOOP\t\t40\t/* Too many symbolic links encountered */\n#define\tEWOULDBLOCK\tEAGAIN\t/* Operation would block */\n#define\tENOMSG\t\t42\t/* No message of desired type */\n#define\tEIDRM\t\t43\t/* Identifier removed */\n#define\tECHRNG\t\t44\t/* Channel number out of range */\n#define\tEL2NSYNC\t45\t/* Level 2 not synchronized */\n#define\tEL3HLT\t\t46\t/* Level 3 halted */\n#define\tEL3RST\t\t47\t/* Level 3 reset */\n#define\tELNRNG\t\t48\t/* Link number out of range */\n#define\tEUNATCH\t\t49\t/* Protocol driver not attached */\n#define\tENOCSI\t\t50\t/* No CSI structure available */\n#define\tEL2HLT\t\t51\t/* Level 2 halted */\n#define\tEBADE\t\t52\t/* Invalid exchange */\n#define\tEBADR\t\t53\t/* Invalid request descriptor */\n#define\tEXFULL\t\t54\t/* Exchange full */\n#define\tENOANO\t\t55\t/* No anode */\n#define\tEBADRQC\t\t56\t/* Invalid request code */\n#define\tEBADSLT\t\t57\t/* Invalid slot */\n\n#define\tEDEADLOCK\tEDEADLK\n\n#define\tEBFONT\t\t59\t/* Bad font file format */\n#define\tENOSTR\t\t60\t/* Device not a stream */\n#define\tENODATA\t\t61\t/* No data available */\n#define\tETIME\t\t62\t/* Timer expired */\n#define\tENOSR\t\t63\t/* Out of streams resources */\n#define\tENONET\t\t64\t/* Machine is not on the network */\n#define\tENOPKG\t\t65\t/* Package not installed */\n#define\tEREMOTE\t\t66\t/* Object is remote */\n#define\tENOLINK\t\t67\t/* Link has been severed */\n#define\tEADV\t\t68\t/* Advertise error */\n#define\tESRMNT\t\t69\t/* Srmount error */\n#define\tECOMM\t\t70\t/* Communication error on send */\n#define\tEPROTO\t\t71\t/* Protocol error */\n#define\tEMULTIHOP\t72\t/* Multihop attempted */\n#define\tEDOTDOT\t\t73\t/* RFS specific error */\n#define\tEBADMSG\t\t74\t/* Not a data message */\n#define\tEOVERFLOW\t75\t/* Value too large for defined data type */\n#define\tENOTUNIQ\t76\t/* Name not unique on network */\n#define\tEBADFD\t\t77\t/* File descriptor in bad state */\n#define\tEREMCHG\t\t78\t/* Remote address changed */\n#define\tELIBACC\t\t79\t/* Can not access a needed shared library */\n#define\tELIBBAD\t\t80\t/* Accessing a corrupted shared library */\n#define\tELIBSCN\t\t81\t/* .lib section in a.out corrupted */\n#define\tELIBMAX\t\t82\t/* Attempting to link in too many shared libraries */\n#define\tELIBEXEC\t83\t/* Cannot exec a shared library directly */\n#define\tEILSEQ\t\t84\t/* Illegal byte sequence */\n#define\tERESTART\t85\t/* Interrupted system call should be restarted */\n#define\tESTRPIPE\t86\t/* Streams pipe error */\n#define\tEUSERS\t\t87\t/* Too many users */\n#define\tENOTSOCK\t88\t/* Socket operation on non-socket */\n#define\tEDESTADDRREQ\t89\t/* Destination address required */\n#define\tEMSGSIZE\t90\t/* Message too long */\n#define\tEPROTOTYPE\t91\t/* Protocol wrong type for socket */\n#define\tENOPROTOOPT\t92\t/* Protocol not available */\n#define\tEPROTONOSUPPORT\t93\t/* Protocol not supported */\n#define\tESOCKTNOSUPPORT\t94\t/* Socket type not supported */\n#define\tEOPNOTSUPP\t95\t/* Operation not supported on transport endpoint */\n#define\tEPFNOSUPPORT\t96\t/* Protocol family not supported */\n#define\tEAFNOSUPPORT\t97\t/* Address family not supported by protocol */\n#define\tEADDRINUSE\t98\t/* Address already in use */\n#define\tEADDRNOTAVAIL\t99\t/* Cannot assign requested address */\n#define\tENETDOWN\t100\t/* Network is down */\n#define\tENETUNREACH\t101\t/* Network is unreachable */\n#define\tENETRESET\t102\t/* Network dropped connection because of reset */\n#define\tECONNABORTED\t103\t/* Software caused connection abort */\n#define\tECONNRESET\t104\t/* Connection reset by peer */\n#define\tENOBUFS\t\t105\t/* No buffer space available */\n#define\tEISCONN\t\t106\t/* Transport endpoint is already connected */\n#define\tENOTCONN\t107\t/* Transport endpoint is not connected */\n#define\tESHUTDOWN\t108\t/* Cannot send after transport endpoint shutdown */\n#define\tETOOMANYREFS\t109\t/* Too many references: cannot splice */\n#define\tETIMEDOUT\t110\t/* Connection timed out */\n#define\tECONNREFUSED\t111\t/* Connection refused */\n#define\tEHOSTDOWN\t112\t/* Host is down */\n#define\tEHOSTUNREACH\t113\t/* No route to host */\n#define\tEALREADY\t114\t/* Operation already in progress */\n#define\tEINPROGRESS\t115\t/* Operation now in progress */\n#define\tESTALE\t\t116\t/* Stale file handle */\n#define\tEUCLEAN\t\t117\t/* Structure needs cleaning */\n#define\tENOTNAM\t\t118\t/* Not a XENIX named type file */\n#define\tENAVAIL\t\t119\t/* No XENIX semaphores available */\n#define\tEISNAM\t\t120\t/* Is a named type file */\n#define\tEREMOTEIO\t121\t/* Remote I/O error */\n#define\tEDQUOT\t\t122\t/* Quota exceeded */\n\n#define\tENOMEDIUM\t123\t/* No medium found */\n#define\tEMEDIUMTYPE\t124\t/* Wrong medium type */\n#define\tECANCELED\t125\t/* Operation Canceled */\n#define\tENOKEY\t\t126\t/* Required key not available */\n#define\tEKEYEXPIRED\t127\t/* Key has expired */\n#define\tEKEYREVOKED\t128\t/* Key has been revoked */\n#define\tEKEYREJECTED\t129\t/* Key was rejected by service */\n\n/* for robust mutexes */\n#define\tEOWNERDEAD\t130\t/* Owner died */\n#define\tENOTRECOVERABLE\t131\t/* State not recoverable */\n\n#define ERFKILL\t\t132\t/* Operation not possible due to RF-kill */\n#define EHWPOISON\t133\t/* Memory page has hardware error */\n\n#endif\n```\n\n# TcpC/S\n\nTcpClient/TcpServer类对资源的利用一定要遵循RAII规则。即构造时申请系统资源，析构时归还系统资源。\n\n## TcpClient\n\n```mermaid\nclassDiagram\nclass TcpClient{\n\t-m_sfd : int //serverfd\n\t+TcpClient(const IpAddressPort &)\n\t+~TcpClient()\n\t+SendMsg(const string& msg) int\n\t+RecvMsg() Msg\n}\n```\n\n## TcpServer\n\n```mermaid\nclassDiagram\nclass TcpServer{\n\t-m_lfd : int //listenfd\n\t+TcpServer(const IpAddressPort&)\n\t+~TcpServer()\n\t+SendMsg(const string& msg) int\n\t+RecvMsg() Msg\n\t+GetLfd() int\n}\n```\n\n\n\n### RAII\n\nRAII: Resource Acquisition is Initialization。\n\n希望C++对象的生命周期和资源的生命周期是一致的。\n\n堆内存：易失性\n\n# 业务层 - MVC模式\n\n## View\n\n```cpp\n#include<string>\n/* 接口类 */\nclass View\n{\npublic:\n    virtual void process(int fd, std::string &data) = 0;\n};\nclass LoginView : public View\n{\npublic:\n    void process(int fd, std::string &data)\n    {\n        \n    }\n}\n```\n\n\n\n## Controller\n\n```cpp\n#include<unordered_map>\n#include<view.h>\nclass Controller\n{\nprivate:\n    std::unordered_map<BIZTYPE, View*> bizTypeMap = \n\npublic:\n    Controller();\n    ~Controller();\n    void ControllerProcess(int fd, std::string &data)\n    {\n        /* string -> json */\n        bizTypeMap[data[\"biztype\"]]\n    }\n};\n```\n\n```cpp\n# public.h\nenum BIZTYPE\n{\n    \n};\n```\n\n# MySQL\n\n```cpp\n// mysqldb.h\n#ifndef __MYSQLDB_H__\n#define __MYSQLDB_H__\n#include <mysql/mysql.h>\n#include <string>\n// 设计成一个线程安全的mysql单例类   因为mysql是可以被多线程看到的\n// raii\nclass MySQLDB\n{\nprivate:\n    MYSQL* m_mysqlClient;\n    MySQLDB();\npublic:\n    static MySQLDB* GetInstance();\n    // mysql -h x.x.x.x -P 3307 -u root -p\n    void Connect(const std::string& ip,\n                 unsigned short port,\n                 const std::string& user,\n                 const std::string& password,\n                 const std::string& db);\n    int Query(std::string&& sql);\n    bool Insert(std::string&& sql);\n    ~MySQLDB();\n};\n#endif\n```\n\n\n\n```cpp\nMySQLDB::MySQLDB()\n{\n    m_mysqlClient = NULL;\n}\nMySQLDB::~MySQLDB()\n{\n    if(m_mysqlClient != nullptr)\n    {\n        mysql_close(m_mysqlClient);\n    }\n}\nMySQLDB::MySQLDB* GetInstance()\n{\n    static MySQLDB res;\n    return &res;\n}\nvoid MySQLDB::Connect(const std::string & ip,\n             unsigned short port,\n             const std::string& user,\n             const std::string& password,\n             const std::string& db)\n{\n    if(!mysql_real_connect(m_mysqlClient,\n                           ip.c_str(), user.c_str(), password.c_str(), db.c_str(), 3306, nullptr, 0))\n    {\n        LOG_ERROR << \"mysql_real_connect() failed!\";\n    }\n    LOG_INFO << \"mysql connect success!\";\n}\nint MySQLDB::Query(std::string&& sql)\n{\n    LOG_INFO << \"sql:\" << sql;\n    if(mysql_query(m_mysqlClient, sql.c_str()))\n    {\n        LOG_ERROR << mysql_error(m_mysqlClient);\n        return 0;\n    }\n    return mysql_num_rows(mysql_store_result(m_mysqlClient));\n}\nbool MySQLDB::Insert(std::string&& sql)\n{\n    LOG_INFO << \"sql:\" << sql;\n    if(mysql_query(m_mysqlClient, sql.c_str()))\n    {\n        LOG_ERROR << mysql_error(m_mysqlClient);\n        return false;\n    }\n    return true;\n}\n```\n\n# Redis\n\n## 安装\n\n```bash\nwget https://github.com/redis/hiredis/archive/refs/tags/v1.0.2.tar.gz\ntar -zxvf v1.0.2.tar.gz\ncd hiredis-1.0.2\nmake\nmake install\nldconfig\n```\n\n","categories":["Cpp","项目","集群"]},{"title":"Linux_守护进程","url":"/Linux/Linux_守护进程/","content":"\n# 内容\n\n本节将说明守护进程结构，以及如何编写守护进程程序。因为守护进程没有控制终端，我们需要了解在出现问题时，守护进程如何报告出错情况。\n\n1. 守护进程的特点\n2. 进程组、控制终端、会话\n3. 守护进程编程流程\n\n# 守护进程\n\n守护进程(daemon)是生存期长的一种进程。常常在系统引导装入时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以说它们是在后台运行的。UNIX系统有很多守护进程，它们执行日常事务活动。\n\n在基于BSD的系统下执行`ps -axj`：\n\n选项`-a`显示由其他用户所拥有的进程的状态，`-x`显示没有控制终端的进程状态，`-j`显示与作业有关的信息：会话ID、进程组ID、控制终端以及终端进程组ID。\n\n类似的命令，在基于System V的系统中，与此相类似的命令是`ps -efj`（为了提高安全性，某些UNIX系统不允许用户使用`ps`命令查看不属于自己的进程）。\n\n有以下比较关键的列：UID（用户ID）、PID（进程ID）、PPID（父进程ID）、PGID（进程组ID）、SID（session ID, 会话ID）、终端名称（TTY）、命令字符串（CMD）。\n\n此`ps`命令在支持会话ID的系统上运行（Linux 3.2.0），`setsid`函数中的sid即会话ID。简单地说，它就是会话首进程的进程ID。\n\n> 系统进程历程\n>\n> 系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。（`init`是个例外，它是一个由内核在引导装入时启动的用户层次的命令。）内核进程是特殊的，通常存在于系统的整个生命期中。它们以超级用户特权运行，无控制终端，无命令行。\n\n在`ps`的输出实例中，内核守护进程的名字出现在方括号中，如`[sshd]`该版本的Linux使用一个名为kthreadd的特殊内核进程来创建其他内核进程，所以kthreadd表现为其他内核进程的父进程。对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件，通常有它自己的内核守护进程。例如，在Linux中：\n\n1. `kswapd`守护进程，内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面。\n2. `flush`守护进程在可用内存达到设置的最小阈值时将脏页面冲洗至磁盘。它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可以同时存在，每个写回的设备都有一个冲洗守护进程。比如一个名为`flush-8:0`的冲洗守护进程。从名字中可以看出，写回设备是通过主设备号（8）和副设备号（0）来识别的。\n3. `sync_supers`守护进程定期将文件系统元数据冲洗至磁盘。\n4. `jbd`守护进程帮助实现了`ext4`文件系统中的日志功能。\n\n进程1通常是`init`，它是一个系统守护进程，除了其他工作外，主要负责启动各运行层次特定的系统服务。这些服务通常是在它们自己拥有的守护进程的帮助下实现的。\n\n`netd`守护进程。它侦听系统网络接口，以便取得来自网络的对各种网络服务进程的请求。`nfsd`、`nfsiod`、`lockd`、`rpciod`、`rpe.idmapd`、`rpc.statd`和`rpc.mountd`守护进程提供对网络文件系统（Network File System，NFS）的支持。注意，前4个是内核守护进程，后3个是用户级守护进程。\n\n注意，大多数守护进程都以超级用户（root）特权运行。所有的守护进程都没有控制终端，其终端名设置为**问号**。**内核守护进程**以无控制终端方式启动。**用户层守护进程**缺少控制终端可能是守护进程调用了`setsid`的结果。**大多数用户层守护进程都是进程组的组长进程以及会话的首进程**，而且**是这些进程组和会话中的唯一进程**（`rsyslogd`是一个例外）。最后，应当引起注意的是用户层守护进程的父进程是`init`进程。\n\n# 特点\n\n运行周期长，在后台执行，不需要和用户交互。\n\n# 概念\n\n1. 会话：每当打开一个终端，就相当于和内核建立了一个会话。再打开一个终端就会创建一个新会话，与第一个会话不同。即会话是伴随终端的打开而建立的。用**会话首进程的pid**来作为整个会话的sid。即使该进程结束了，会话id依然不变。\n2. 会话首进程：在该会话中运行的第一个进程。一般来讲会话首进程就是bash。\n3. 进程组：在会话中每运行一个命令，比如执行ls，会创建一个进程组，同时会创建一个进程。用该进程组的首进程pid作为整个进程组的pgid，即组长进程。进程组中有可能会有多个进程，是组内进程fork产生的。如果父进程（组长进程）结束了，pgid不会改变。只有进程组中一个进程都没有时该进程组才消失。进程组可以便于系统进行管理，比如给组长进程发一个信号，其他人都可以收到。\n4. 组长进程\n\n如果关闭终端，则会话里的进程会全部结束。\n\n我们要想办法使会话中的进程与终端断绝关系，独立起来。\n\n思路：可以新建另一个会话，把终端中的进程组挪出来到这个会话里，然后就可以放心地关闭终端了。这就叫做守护进程。\n\n创建新会话可调用`setsid`。但是是有条件的，调用该函数的进程不能是一个组长进程，因为这会引起组长id冲突。即必须是非组长才可创建新会话。\n\n# 编程流程\n\n1. `fork()`：父进程创建子进程，退出父进程，这样就保证了子进程不是组长id。\n2. `setsid()`\n3. `fork()`：子进程再创建孙子进程，保证孙子进程不是组长id，保证不和终端再关联。但不必要。\n4. `chdir(\"/\")`：把工作目录改变到根目录，保险，为长时间的运行做好准备。但不一定能用的到。这么做是防止被卸载。\n5. `unmask()`：清空掩码，保证创建文件时创建出应有的权限。\n6. `close()`：关闭用不到的文件描述符，如0、1、2\n7. 如果可能产生子进程，还需要注意处理僵死进程。\n\n在编写守护进程程序时需遵循一些基本规则，以防止产生不必要的交互作用。 下面先说明这些规则，然后给出一个按照这些规则编写的函数`daemonize`。\n\n1. 首先要做的是调用`umask`将文件模式创建屏蔽字设置为一个已知值（通常是0）。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件，那么它可能要设置特定的权限。例如，若守护进程要创建组可读、组可写的文件，继承的文件模式创建屏蔽字可能会屏蔽上述两种权限中的一种，而使其无法发挥作用。另一方面，如果守护进程调用的库函数创建了文件，那么将文件模式创建屏蔽字设置为一个限制性更强的值（如007）可能会更明智，因为库函数可能不允许调用者通过一个显式的函数参数来设置权限。\n\n2. 调用fork，然后使父进程exit。这样做实现了下面几点。第一，如果该守护进程是作为一条简单的shell命令启动的，那么父进程终止会让shell认为这条命令已经执行完毕。第二，虽然子进程继承了父进程的进程组ID，但获得了一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这是下面将要进行的`setsid`调用的先决条件。\n\n3. 调用`setsid`创建一个新会话。然后执行9.5节中列出的3个步骤，使调用进程∶（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端。\n   >在基于System V的系统中，有些人建议在此时再次调用fork，终止父进程，继续使用子进程中的守护进程。这就保证了该守护进程不是会话首进程，于是按照System V规则（见UNIX环境高级编程9.6节）可以防止它取得控制终端。为了避免取得控制终端的另一种方法是，无论何时打开一个终端设备，都一定要指定`O_NOCTTY`。\n\n4. 将当前工作目录更改为根日录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。或者，某些守护进程还可能会把当前工作目录更改到某个指定位置，并在此位置进行它们的全部工作。例如，行式打印机假脱机守护进程就可能将其工作目录更改到它们的spool目录上。\n\n5. 关闭不再需要的文件描述符。这使守护进程不再持有从其父进程继承来的任何文件描述符（父进程可能是shell进程，或某个其他进程）。可以使用`open_max`函数（见2.17节）或`getrlimit`函数（见 7.11节）来判定最高文件描述符值，并关闭直到该值的所有描述符。\n\n6. 某些守护进程打开`/dev/null`使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以其输出无处显示，也无处从交互式用户那里接收输入。即使守护讲程是从交互式会话启动的，但是守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。如果其他用户在同一终端设备上登录，我们不希望在该终端上见到守护进程的输出，用户也不期望他们在终端上的输入被守护进程读取。\n\n# 实例\n\n```cpp\n#include\"apue.h\"\n#include<syslog.h>\n#include<fcntl.h>\n#include<sys/resource.h>\nvoid daemonize(const char * cmd)\n{\n    int              i, fd0, fd1, fd2;\n    pid_t            pid;\n    struct rlimit    rl;\n    struct sigaction sa;\n    \n    /* Clear file creation mask. */\n    umask(0);\n    \n    /* Get maximum number of file descriptions. */\n    if(getrlimit(RLIMIT_NOFILE, &rl) < 0)\n    {\n        err_quit(\"%s: can't get file limit\", cmd);\n    }\n    /* Become a session leader to lose controlling TTY. */\n    if((pid = fork()) < 0)\n    {\n        err_quit(\"%s: can't fork\", cmd);\n    }\n    else if(pid != 0)//parent\n    {\n        exit(0);\n    }\n    setsid();\n    /* Ensure future opens won't allocate controlling TTYs. */\n    sa.sa_handler = SIG_IGN;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    if(sigaction(SIGHUP, &sa, NULL) < 0)\n    {\n        err_quit(\"%s: can't ignore SIGHUP\", cmd);\n    }\n    if((pid = fork()) < 0)\n    {\n        err_quit(\"%s: can't fork\", cmd);\n    }\n    else if(pid != 0)//parent\n    {\n        exit(0);\n    }\n    /* change the current working directory to the root, \n    so we won't prevent file systems from being unmounted. */\n    if(chdir(\"/\") < 0)\n    {\n        err_quit(\"%s: can't change directory to /\", cmd);\n    }\n    /* close all open file descriptors */\n    if(rl.rlim_max == RLIM_INFINTY)\n    {\n        rl.rlim_max = 1024;\n    }\n    for(i = 0; i < rl.rlim_max; ++i)\n    {\n        close(i);\n    }\n    /* attach file descriptors 0, 1, and 2 to /dev/null */\n    fd0 = open(\"/dev/null\", O_RDWR);\n    fd1 = dup(0);\n    fd2 = dup(0);\n    /* initialize the log file. */\n    openlog(cmd, LOG_CONS, LOG_DAEMON);\n    if(fd0 != 0 || fd1 != 1 || fd2 != 2)\n    {\n        syslog(LOG_ERR, \"unexpected file descriptors %d %d %d\", fd0, fd1, fd2);\n        exit(1);\n    }\n}\n```\n\n若`daemonize`函数由`main`程序调用，然后`main`程序进入休眠状态，那么可以用`ps`命令检查该守护进程的状态：\n\n```\n$ ./a.out\n$ ps -efj\nUID    PID  PPID  PGID   SID TTY CMD\nsar 13800      1 13799 13799  ?  ./a.out\n$ ps -efj | grep 13799\nsar 13800      1 13799 13799  ?  ./a.out\n```\n\n我们也可用`ps`命令验证，没有活动进程存在的ID是`13799`。这意味着，守护进程在一个孤儿进程组中（见9.10节），它不是会话首进程，因此没有机会被分配到一个控制终端。这一结果是在`daemonize`函数中执行第二个`fork`造成的。可以看出，守护进程已经被正确地初始化了。\n\n","categories":["Linux"]},{"title":"数据库理论_事务","url":"/数据库/数据库理论_事务/","content":"事务就像是批处理一样，可以有多条SQL语句、函数等等，按照流程进行操作。比如公司引进一个新人，事务不仅是简单的插入一个表，而是插入存在依赖关系的部门员工表、工资表、人事表等等。事务完成后，才完成了数据的持久化。如果中间除了问题，可以进行选择性的回退、或完全回退。\n\n实际上事务一直都有，每次我们提交SQL语句时，数据库就默认提交了一个事务。\n\n# 关键字\n\n## Transaction\nTransaction(Read, Write, Commit, Abort)\n事务（读取、写入、提交、中止）\n\n从程序角度来说，事务就是一组原子性的SQL语句，或者说是一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该语句，那么就执行；如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句要么全部执行成功，要么全部执行失败。\n\n事务并非总能成功地执行完成。这种事务称为**中止(aborted)**。我们如果要确保原子性，中止事务必须对数据库的状态不造成影响。因此，中止事务对数据库所做的任何改变必须撤销。一旦中止事务造成的变更被撤销，我们就说事务**已回滚(rolledback)**。恢复机制负责管理事务中止。典型的方法是维护一个日志(log)。每个事务对数据库的修改都首先会记录到日志中。我们记录执行修改的事务标识符、修改的数据项标识符以及数据项的旧值（修改前的）和新值（修改后的）。然后数据库才会修改。维护日志提供了重做修改以保证原子性和持久性的可能，以及撤销修改以保证在事务执行发生故障时的原子性的可能。\n\n成功完成执行的事务称为**已提交(committed)**。一个对数据库进行过更新的已提交事务使数据库**进入一个新的一致状态**，即使出现系统故障，这个状态也必须保持。\n\n一旦事务已提交，我们不能通过中止它来撤销其造成的影响。撤销已提交事务所造成影响的唯方法是执行一个**补偿事务(compensating transaction)**。例如，如果一个事务给一个账户加上了`$20`，其补偿事务应当从该账户减去`$20`。然而，我们不总是能够创建这样的补偿事务。因此，书写和执行一个补偿事务的责任就留给了用户，而不是通过数据库系统来处理。\n\n我们需要更准确地定义一个事务成功完成的含义。为此我们建立了一个简单的抽象事务模型。事务必须处于以下状态之一。\n\n1. 活动的(active)：初始状态，事务执行时处于这个状态。\n2. 部分提交的(partially committed)：最后一条语句执行后。\n3. 失败的(failed)：发现正常的执行不能继续后。\n4. 中止的(aborted)：事务回滚并且数据库已恢复到事务开始执行前的状态后。\n5. 提交的(committed)：成功完成后。\n\n事务相应的状态图如图所示。只有在事务已进入提交状态后，我们才说事务已提交。类似地，仅当事务已进入中止状态，我们才说事务已中止。如果事务是提交的或中止的，它称为已经结束的(terminated)。\n\n![image-20220724215039732](../../images/数据库理论_事务/image-20220724215039732.png)\n\n事务从活动状态开始。**当事务完成它的最后一条语句后就进入了部分提交状态。此刻，事务已经完成执行，但由于实际输出可能仍临时驻留在主存中，因此一个硬件故障可能阻止其成功完成，于是事务仍有可能不得不中止。**\n\n接着数据库系统往磁盘上**写入**(write)足够的信息，确保即使出现故障时事务所做的更新也能在系统重启后重新创建。当最后一条这样的信息写完后，事务就进入提交状态。\n\n系统判定事务不能继续正常执行后（例如，由于硬件或逻辑错误），事务就进入失败状态。这种事务必须回滚。这样，事务就进人中止状态。此刻，系统有两种选择。\n\n1. 它可以重启(restart)事务，但仅当引起事务中止的是硬件错误或不是由事务的内部逻辑所产生的软件错误时。重启的事务被看成是一个新事务。\n2. 它可以杀死(kill)事务，这样做通常是由于事务的内部逻辑造成的错误，只有重写应用程序才能改正，或者由于输入错误，或所需数据在数据库中没有找到。\n\n在处理可见的外部写(observable external write)，比如写到用户屏幕，或者发送电子邮件时，我们必须要小心。由于写的结果可能已经在数据库系统之外看到，因此一旦发生这种写操作，就不能再抹去。大多数系统只允许这种写操作在事务进入提交状态后发生。实现这种模式的一种方法是在非易失性存储设备中临时写下与外部写相关的所有数据，然后在事务进入提交状态后再执行真正的写操作。\n\n如果在事务已进入提交状态而外部写操作尚未完成之时，系统出现了故障，数据库系统就可以在重启后（用存储在非易失性设备中的数据）执行外部写操作。\n\n在某些情况下处理外部写操作会更复杂，例如，我们假设外部动作是在自动取款机上支付现金，并且系统恰好在支付现金之前发生故障（我们假定现金能自动支付），当系统重新启动时再执行现金支付将毫无意义，因为用户可能已经离开。在这种情况下，重新启动时系统应该执行一个补偿事务，比如将现金存回用户的账户。\n\n## Serializability\n\n如果并发执行的控制完全由操作系统负责，许多调度都是可能的，包括像上述调度那样使数据库处于不一致状态的调度。保证所执行的任何调度都能使数据库处于一致状态，这是数据库系统的任务，数据库系统中负责完成此任务的是并发控制(concurrency-control)部件。\n\n在并发执行中，**通过保证所执行的任何调度的效果都与没有并发执行的调度效果一样，我们可以确保数据库的一致性**。也就是说，调度应该在某种意义上等价于一个串行调度。这种调度称为**可串行化**(serializable)调度。\n\n事务处理系统通常允许多个事务并发地执行。正如我们先前看到的，允许多个事务并发更新数据引起许多数据一致性的复杂问题。在存在事务并发执行的情况下保证一致性需进行额外工作；如果我们强制事务串行地(serially)执行将简单得多次执行一个事务，每个事务仅当前一事务执行完后才开始。\n\n在我们考虑数据库系统并发控制部件如何保证串行化之前，我们考虑如何确定一个调度是可串行化的。显然，串行调度是可串行化的，但是如果许多事务的步骤交错执行，则很难确定一个调度是否是可串行化的。由于事务就是程序，因此要确定一个事务有哪些操作、多个事务的操作如何相互作用是有困难的。由于这个缘故，我们将不会考虑一个事务对某一数据项可执行的各种不同类型的操作， 而只考虑两种操作：**read和write**。\n\n我们这样假设， 在数据项Q上的read(Q)和write(Q)指令之间，事务可以对驻留在事务局部缓冲区中的Q的拷贝执行任意操作序列。按这种模式， 从调度的角度来看， 事务唯一重要的操作是read与write指令。commit操作尽管相关， 但是我们后面才考虑它。因此，我们在调度中通常只显示read与write指令，正如图所示。\n\n![image-20220724223733635](../../images/数据库理论_事务/image-20220724223733635.png)\n\n## History\n\n## Schedule\n\n执行顺序称为调度(schedule)。它们表示指令在系统中执行的时间顺序。显然，一组事务的一个**调度必须包含这一组事务的全部指令**，并且必须保持指令在各个事务中出现的顺序。例如，在任何一个有效的调度中，事务T1中指令write(A)必须在指令read(B)之前出现。请注意，我们在调度中包括了commit操作来表示事务已经进入提交状态。在下面的讨论中，我们将称第一种执行顺序为调度1（T2跟在T1之后），称第二种执行顺序为调度2（T1跟在T2之后）。\n\n![image-20220724223100988](../../images/数据库理论_事务/image-20220724223100988.png)\n\n这两个调度是串行的(serial)。每个串行调度由来自各事务的指令序列组成，其中属于同一事务的指令在调度中紧挨在一起。回顾组合数学中一个众所周知的阶乘公式，我们知道，对于有n个事务的事务组，共有`n!`个不同的有效串行调度。\n\n## Conflict graph\nConflict graph(WW, WR, RW)\n\n为确定一个调度是否冲突可串行化，我们这里给出了一个简单有效的等价的一个串行调度方法。设S是一个调度，我们由S构造一个有向图，称为**优先图**(precedence graph)。该图由两部分组成`G=(V,E)`，其中V是顶点集，E是边集，顶点集由所有参与调度的事务组成，边集由满足下列三个条件之一的边`Ti -> Tj`组成。\n\n1. 在Tj执行read(Q)之前，Ti执行write(Q)。\n2. 在Tj执行write(Q)之前，Ti执行read(Q)。\n3. 在Tj执行write(Q)之前，Ti执行write(Q)。\n\n## Isolation levels\nIsolation levels(Serializable, Snapshot Isolation, Repeatable Read, Read Committed, Read Uncommitted)\n\n可串行性是一个有用的概念，因为当程序员对事务编码时，它允许程序员忽略与并发性相关的问题。如果事务在独立执行时保证数据库一致性，那么可串行性就能确保并发执行时也具有一致性。然而，对于某些应用，保证可串行性的那些协议可能只允许极小的并发度。\n\n在这种情况下,我们采用较弱级别的一致性。为了保证数据库的正确性，使用较弱级别一致性给程序员增加了额外负担。\n\nSQL标准也允许一个事务这样规定：它可以以一种与其他事务不可串行化的方式执行。例如，一个事务可能在未提交读级别上操作，这里允许事务读取甚至还未提交的记录。SQL为那些不要求精确结果的长事务提供这种特征。如果这些事务要在可串行化的方式下执行，它们就会干扰其他事务，造成其他事务执行的延迟。\nSQL标准规定的隔离性级别如下。\n\n1. **可串行化(serializable)**：通常保证可串行化调度。然而，正如我们将要解释的，一些数据库系统对该隔离性级别的实现在某些情况下允许非可串行化执行。\n2. **可重复读(repeatable read)**：只允许读取已提交数据， 而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据。但该事务不要求与其他事务可串行化。例如：当一个事务在查找满足某些条件的数据时，它可能找到一个已提交事务插入的一些数据，但可能找不到该事务插入的其他数据。\n3. **已提交读(read committed)**：只允许读取已提交数据， 但不要求可重复读。比如， 在事务两次读取一个数据项期间，另一个事务更新了该数据并提交。\n4. **未提交读(read uncommitted)**：允许读取未提交数据。这是SQL允许的最低一致性级别。\n\n许多数据库系统运行时的默认隔离性级别是已提交读。\n\n## Anomalies\nAnomalies(Dirty Write, Dirty Read, Non-repeatable Read, Phantom Read)\n\n以上所有隔离性级别都不允许**脏写(dirty write)**，即如果一个数据项已经被另外一个尚未提交或中止的事务写人，则不允许对该数据项执行写操作。\n\n根据违反可串行化的三种现象，SQL标准定义了不同的隔离性级别。这三种现象称作：读脏数据不可重复读和读幻象，定义如下：\n\n1. **读脏数据(dirty read)**。事务读了由另一个尚未提交事务所写的值。\n2. **不可重复读(non-repeatable read)**。一个事务在执行过程中对同一对象读了两次，第二次得到了不同的值，尽管在此期间该事务并没有改变其值。\n3. **读幻象(phantom read)**。事务重新执行返回结果为满足某搜索条件的行集合的查询，发现满足条件的行集合已经改变，这是由于另一个事务最近提交了。\n\n很显然上述每种现象都破坏了事务的隔离性，因此违反了可串行化。\n# ACID原则\nSQL Transaction\n这些原则只是指导性意见。而不是强制、实际的。这是给程序员遵循的，而不是数据库本身的能力。\n\nAtomicity ensures that all operations within the work unit are completed successfully. Otherwise, the transaction is aborted at the point of failure and all the previous\noperations are rolled back to their former state.\n要么是操作完毕的，要么是没动过的（恢复原样的）。\n\nConsistency ensures that the database properly changes states upon a successfully committed transaction.\n在事务提交后，数据库要有合理地改变。（中文翻译为一致性，比英文的定义要狭义）\n\nIsolation **enables** transactions to operate independently of and transparent to each other.\n事务彼此独立、透明。即要达到可以同时执行，如果有人读，有人写，要达到隔离，就要用锁来同步。\n\nDurability ensures that the result or effect of a committed transaction persists in case of a system failure.\n以防系统崩溃，提交事务之后的结果应该持久地保存下来。\n\n\nSQL语句、存储过程、函数等那么死板的语法，熟练了就会了。\n而数据库开发的难点，就在于，ACID原则这4个原则下，如何在不同的应用场景去设计、平衡。\n# 事务 SQL操作\n![](../../images/数据库理论_事务/image-20250730195325800.png)\n开启事务\n```mysql\nbegin;\n```\n![](../../images/数据库理论_事务/image-20250730195415786.png)\nSQL操作\n```mysql\ninsert into score values(3, 3, 56);\n```\n![](../../images/数据库理论_事务/image-20250730195502555.png)\n\n![](../../images/数据库理论_事务/image-20250730195532002.png)\n回滚事务操作\n```mysql\nrollback;\n```\n![](../../images/数据库理论_事务/image-20250730195547285.png)\n![](../../images/数据库理论_事务/image-20250730195620999.png)\n结束事务\n```mysql\ncommit;\n```\n\n事务主要是记录了中间的操作步骤，相当于可以do、undo。\n\n事务兼容了性能和关键的操作。\n\n事务还能生成子任务，在begin之后可以建立还原点，而不是回滚全部操作。\n# 事务并发存在的问题\n事务处理不经隔离，并发执行事务时通常会发生以下的问题：\n## 脏读（Dirty Read）\n一个事务读取了另一个事务未提交的数据。\n例如当事务A和事务B并发执行时，当事务A更新后，事务B查询读取到A尚未提交的数据，此时事务A回滚，则事务B读到的数据就是无效的脏数据。\n（事务B读取了事务A尚未提交的数据）\n\n## 不可重复读（NonRepeatable Read）\n一个事务的操作导致另一个事务前后两次读取到不同的数据。\n例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A更改事务B查询到的数据，此时事务B再次去读该数据，发现前后两次读的数据不一样。\n（事务B读取了事务A已提交的数据）\n\n## 幻读（Phantom Read）（虚读）\n一个事务的操作导致另一个事务前后两次查询的结果数据量不同。\n例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A新增或者删除了一条满足事务B查询条件的记录，此时事务B再去查询，发现查询到前一次不存在的记录，或者前一次查询的一些记录不见了。\n（事务B读取了事务A新增加的数据或者读不到事务A删除的数据）\n# 事务的隔离级别\nMySQL支持的四种隔离级别是：\n1. TRANSACTION_READ_UNCOMMITTED。未提交读。说明在提交前一个事务可以看到另一个事务的变化。这样会读到脏数据，不可重复读和幻读都是被允许的。\n2. TRANSACTION_READ_COMMITTED。已提交读。说明读取未提交的数据是不允许的。不会读到脏数据，但这个级别仍然允许不可重复读和幻读产生。\n3. TRANSACTION_REPEATABLE_READ。**可重复读**。保证能够再次读取相同的数据而不会失败，但幻读仍然会出现。\n4. TRANSACTION_SERIALIZABLE。串行化。最高的事务级别，防止读脏数据，防止不可重复读，防止幻读。\n\n事务隔离级别越高，为避免冲突所花费的性能也就越多。\nOracle默认工作在“已提交读”级别。\nMySQL默认工作在\"可重复读\"级别，实际上可以解决部分的幻读问题，但是不能防止update更新产生的幻读问题，要禁止虚读产生，还是需要设置串行化隔离级别。\n","categories":["数据库","理论"]},{"title":"Cpp_浅谈形参中const和引用的作用","url":"/Cpp/Cpp_浅谈形参中const和引用的作用/","content":"\n1、可以确定的是，如果你想修改传入的引用对象，不可以加const修饰。不管是指针还是引用，前面加const之后，比如`const A *`或`const A &`，都会导致A只可读、只能调用其常方法，常方法一般不可以修改其成员属性。\n因此，针对于《流类对象》，99%的情况下不加const。\n2、const的目的在于两方面，字面意思是修饰其不可修改，还有一个很重要的目的在于使可接收的对象属性范围更大。如果形参定义为const属性，既可接收“非const对象”，也可接收“const对象”。所以，如果在函数中不涉及到对传入的对象进行修改时，都尽量加const。\n比如，形参是`const string str`。如果外部传入的是字符串常量`\"aaa\"`，照常接收，如果形参是`string str`，无法接收，实参的通用性收到限制。\n3、接下来就是富含争议的引用修饰了。\n在C++中，语义上，引用是一个变量的别名；调用效果上，如果是按引用传递，则被调用者和调用者操作的是同一个对象。\n在语法上，C++的普通引用本质上是一个“指针指向的地址信息不可变，而指向的内容可变”。\n\n```cpp\nTypename t;\n\t\t Typename & p = t;\n    <==> Typename * const p = &t;\n```\n\n在程序中，编译器会自动处理对其进行解引用。\n\n用在参数传递中，如果要修改对象，可视为语法糖，隐含了指针的解引用操作。\n如果用在参数传递中，却不涉及到修改对象，引用有时可视为对性能的优化，有时可以避免对象在传递过程中产生不必要的临时对象拷贝、析构。但是，在实际生产项目中，此举尚需要论证其必要性。因为有时即使你是按引用传递的，但是避免不了会出现隐式构造临时对象。比如字符串常量\"aaa\"传给一个const string & str。\n\n要注意的是，传递引用是有风险的，程序员必须明确对象在程序中完整的生命周期，需要保证被引用的对象的生命期要长于函数的调用点。要明确对象在堆栈上的产生时机、析构时机，才能安全地传递引用。\n\n如果从代码规范上角度来考虑，尽量向安全、统一的形式靠拢，即统一的按值传递。这也是Java规范按值传递的一大优势，避免了C++程序设计的复杂性，但是某时会有一定的性能损耗。\n\n总之，函数接收参数的类型设计没有一个统一的方法论，要设计出一个优秀的代码程序，你必须清楚你整个程序的生命周期及其所存在的风险，要时刻搞清楚你的代码中传参的目的是什么。最后在此基础上，在代码规范和性能调优上做出平衡。","categories":["Cpp"]},{"title":"Android_Activity","url":"/Android/Android_Activity/","content":"\n# 简介\n\n`Activity`类是Android应用的关键组件，而Activity的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过`main()`方法启动的，而Android系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动`Activity`实例中的代码。\n\n# Activity的概念\n\n移动应用体验与桌面体验不同之处在于，用户与应用的互动并不总是在同一位置开始，而是经常以不确定的方式开始。例如，如果从主屏幕打开电子邮件应用，可能会看到电子邮件列表，如果通过社交媒体应用启动电子邮件应用，则可能会直接进入电子邮件应用的邮件撰写界面。\n\n`Activity`类的目的就是促进这种范式的实现。当一个应用调用另一个应用时，调用方应用会调用另一个应用中的Activity，而不是整个应用。通过这种方式，Activity充当了应用与用户互动的入口点。可以将Activity实现为`Activity`类的子类。\n\nActivity提供窗口供应用在其中绘制界面。此窗口通常会填满屏幕，但也可能比屏幕小，并浮动在其他窗口上面。通常，一个Activity实现应用中的一个屏幕。例如，应用中的一个Activity实现“偏好设置”屏幕，而另一个Activity实现“选择照片”屏幕。\n\n大多数应用包含多个屏幕，这意味着它们包含多个Activity。通常，应用中的一个Activity会被指定为**主Activity，这是用户启动应用时出现的第一个屏幕**。然后，**每个Activity可以启动另一个Activity，以执行不同的操作**。例如，一个简单的电子邮件应用中的主Activity可能会提供显示电子邮件收件箱的屏幕。主Activity可能会从该屏幕启动其他Activity，以提供执行写邮件和打开邮件这类任务的屏幕。\n\n虽然应用中的各个Activity协同工作形成凝聚的用户体验，但每个Activity与其他Activity之间只存在松散的关联，应用内不同Activity之间的依赖关系通常很小。事实上，Activity经常会启动属于其他应用的Activity。例如，浏览器应用可能会启动社交媒体应用的“分享”Activity。\n\n要在应用中使用Activity，您必须在应用的清单中注册关于Activity的信息，并且必须适当地管理Activity的生命周期。\n\n# 配置清单\n\n要使应用能够使用Activity，必须在清单中声明Activity及其特定属性。\n\n## 声明Activity\n\n要声明Activity，请打开清单文件，并添加`<activity>`元素作为`<application>`元素的子元素。例如：\n\n```xml\n    <manifest ... >\n      <application ... >\n          <activity android:name=\".ExampleActivity\" />\n          ...\n      </application ... >\n      ...\n    </manifest >\n```\n\n此元素唯一的必要属性是`android:name`，该属性用于指定Activity的类名称。除了name，还可以添加用于定义标签、图标或界面主题等Activity特征的属性。\n\n>注意：发布应用后，就不应再更改 Activity 名称，否则可能会破坏某些功能，例如应用快捷方式。如需详细了解发布后应避免的更改，参阅[不可更改的内容](http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html)。\n\n## 声明intent过滤器\n\nIntent过滤器是Android平台的一项非常强大的功能。借助这项功能，不但可以根据显式请求启动Activity，还可以根据隐式请求启动Activity。例如，显式请求可能会告诉系统“在Gmail应用中启动`发送电子邮件Activity`”；而隐式请求可能会告诉系统“在任何能够完成此工作的Activity中启动`发送电子邮件屏幕`”。当**系统界面询问用户使用哪个应用来执行任务**时，这就是intent过滤器在起作用。\n\n要使用此功能，需要在`<activity>`元素中声明`<intent-filter>`属性。此元素的定义包括`<action>`元素，以及可选的`<category>`元素和/或`<data>`元素。这些元素组合在一起，可以指定`Activity`能够响应的`intent`类型。例如，以下代码段展示了如何配置一个发送文本数据并接收其他Activity的文本数据发送请求的Activity：\n\n```xml\n    <activity android:name=\".ExampleActivity\" android:icon=\"@drawable/app_icon\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.SEND\" />\n            <category android:name=\"android.intent.category.DEFAULT\" />\n            <data android:mimeType=\"text/plain\" />\n        </intent-filter>\n    </activity>\n```\n\n在此示例中，`<action>`元素指定该Activity会发送数据。将`<category>`元素声明为`DEFAULT`可使`Activity`能够接收启动请求。`<data>`元素指定此Activity可以发送的数据类型。以下代码段展示了如何调用上述`Activity`：\n\n```java\n    // Create the text message with a string\n    Intent sendIntent = new Intent();\n    sendIntent.setAction(Intent.ACTION_SEND);\n    sendIntent.setType(\"text/plain\");\n    sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);\n    // Start the activity\n    startActivity(sendIntent);\n```\n\n如果打算构建一个独立的应用，不允许其他应用激活其Activity，则不需要任何其他intent过滤器。不想让其他应用访问的Activity不应包含intent过滤器，可以自己使用显式intent启动它们。\n\n## 声明权限\n\n您可以使用清单的`<activity>`标记来控制哪些应用可以启动某个Activity。**父Activity和子Activity必须在其清单中具有相同的权限，前者才能启动后者**。如果您为父Activity声明了`<uses-permission>`元素，则每个子Activity都必须具有匹配的`<uses-permission>`元素。\n\n例如，假设您的应用想要使用一个名为`SocialApp`的应用在社交媒体上分享文章，则SocialApp本身必须定义调用它的应用所需具备的权限：\n\n```xml\n    <manifest>\n    <activity android:name=\"....\"\n       android:permission=”com.google.socialapp.permission.SHARE_POST”\n\n    />\n```\n\n然后，为了能够调用SocialApp，应用必须匹配SocialApp清单中设置的权限：\n\n```xml\n    <manifest>\n       <uses-permission android:name=\"com.google.socialapp.permission.SHARE_POST\" />\n    </manifest>\n```\n\n# Activity生命周期\n\n一个Activity在其生命周期中会经历多种状态。可以使用一系列回调来处理状态之间的转换。下面将介绍这些回调。\n\n![Activity生命周期的简化图示](https://developer.android.com/guide/components/images/activity_lifecycle.png)\n\n## 返回栈\n\nAndroid中的活动是可以层叠的。每启动一个新的活动，就会覆盖在原活动之上，点击Back键会销毁最上面的活动，下面的一个活动就会重新显示出来。\n\n其实Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下Back键或调用finish方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。\n\n## onCreate()\n\n必须实现此回调，它会在系统创建Activity时触发。\n\nActivity会在创建后进入“**已创建**”状态。在`onCreate()`方法中，需执行基本应用启动逻辑，该逻辑在Activity的整个生命周期中只应发生一次。例如，`onCreate()`的实现可能会将数据绑定到列表，将Activity与ViewModel相关联，并实例化某些类作用域变量。此方法会接收`savedInstanceState`参数，后者是包含Activity先前保存状态的`Bundle`对象。如果Activity此前未曾存在，`Bundle`对象的值为null。\n\n如果有一个生命周期感知型组件与Activity生命周期相关联，该组件将收到`ON_CREATE`事件。系统将调用带有`@OnLifecycleEvent`注释的方法，以使生命周期感知型组件可以执行已创建状态所需的任何设置代码。\n\n应该初始化Activity的基本组件：例如，应用应该在此处创建视图并将数据绑定到列表。最重要的是，必须在此处调用`setContentView()`来定义Activity界面的布局。\n\n`onCreate()`方法的以下示例显示执行Activity某些基本设置的一些代码，例如声明界面（在XML布局文件中定义）、定义成员变量，以及配置某些界面。在本示例中，系统通过将文件的资源ID`R.layout.main_activity`传递给`setContentView()`来指定XML布局文件。\n\n```java\nTextView textView;\n// some transient state for the activity instance\nString gameState;\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    // call the super class onCreate to complete the creation of activity like\n    // the view hierarchy\n    super.onCreate(savedInstanceState);\n    // recovering the instance state\n    if (savedInstanceState != null) {\n        gameState = savedInstanceState.getString(GAME_STATE_KEY);\n    }\n    // set the user interface layout for this activity\n    // the layout file is defined in the project res/layout/main_activity.xml file\n    setContentView(R.layout.main_activity);\n    // initialize member TextView so we can manipulate it later\n    textView = (TextView) findViewById(R.id.text_view);\n}\n// This callback is called only when there is a saved instance that is previously saved by using\n// onSaveInstanceState(). We restore some state in onCreate(), while we can optionally restore\n// other state here, possibly usable after onStart() has completed.\n// The savedInstanceState Bundle is same as the one used in onCreate().\n@Override\npublic void onRestoreInstanceState(Bundle savedInstanceState) {\n    textView.setText(savedInstanceState.getString(TEXT_VIEW_KEY));\n}\n// invoked when the activity may be temporarily destroyed, save the instance state here\n@Override\npublic void onSaveInstanceState(Bundle outState) {\n    outState.putString(GAME_STATE_KEY, gameState);\n    outState.putString(TEXT_VIEW_KEY, textView.getText());\n    // call superclass to save any view hierarchy\n    super.onSaveInstanceState(outState);\n}\n```\n\n除了定义XML文件，然后将其传递给`setContentView()`，还可以在Activity代码中新建View对象，并将新建的View插入到`ViewGroup`中，以构建视图层次结构。然后，将根`ViewGroup`传递给`setContentView()`以使用该布局。\n\nActivity并未处于“已创建”状态。`onCreate()`方法完成执行后，Activity进入“**已开始**”状态，系统会相继调用`onStart()`和`onResume()`方法。\n\n`onCreate()`完成后，下一个回调将是`onStart()`。\n\n## onStart()\n\n`onCreate()`退出后，Activity将进入“**已开始**”状态（Started state），并对用户可见。此回调包含**Activity进入前台与用户进行互动之前的最后准备工作**。\n\n当Activity进入“**已开始**”状态时，系统会调用此回调。`onStart()`调用使Activity对用户可见，因为应用会为Activity进入前台并支持互动做准备。例如，应用通过此方法来初始化保持界面的代码。（initializes the code that maintains the UI.）\n\n当Activity进入已开始状态时，与Activity生命周期相关联的所有生命周期感知型组件都将收到`ON_START`事件。\n\n`onStart()`方法会非常快速地完成。一旦此回调结束，Activity便会进入“**已恢复**”状态（Resumed state），系统将调用`onResume()`方法。\n\n## onResume()\n\n系统会在Activity开始与用户互动之前调用此回调。此时，该Activity位于Activity堆栈的顶部，并会**捕获所有用户输入**。应用的大部分核心功能都是在`onResume()`方法中实现的。\n\n`onResume()`回调后面总是跟着`onPause()`回调。\n\nActivity会在进入“已恢复”状态时来到前台，然后系统调用`onResume()`回调。这是应用与用户互动的状态。应用会一直保持这种状态，直到某些事件导致焦点远离应用，此类事件包括接到来电、用户导航到另一个Activity，或设备屏幕关闭。\n\n当Activity进入已恢复状态时，与Activity生命周期相关联的所有生命周期感知型组件都将收到 `ON_RESUME`事件。这时，生命周期组件可以启用在组件可见且位于前台时需要运行的任何功能，例如启动相机预览。\n\n当发生中断事件时，Activity进入“**已暂停**”状态，系统调用`onPause()`回调。\n\n如果Activity从“已暂停”状态返回“已恢复”状态，系统将再次调用`onResume()`方法。因此，`onResume()`负责初始化在`onPause()`期间释放的组件，并执行每次Activity进入“已恢复”状态时必须完成的任何其他初始化操作。\n\n以下是生命周期感知型组件的示例，该组件在收到`ON_RESUME`事件时访问相机：\n\n```java\npublic class CameraComponent implements LifecycleObserver {\n    ...\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    public void initializeCamera() {\n        if (camera == null) {\n            getCamera();\n        }\n    }\n    ...\n}\n```\n\n`LifecycleObserver`收到`ON_RESUME`事件后，上述代码便会初始化相机。然而，在多窗口模式下，即使处于“已暂停”状态，Activity也可能完全可见。例如，当用户处于多窗口模式，并点按另一个不包含Activity的窗口时，Activity将进入“已暂停”状态。如果希望相机仅在应用处于“已恢复”（可见且在前台运行）状态时可用，应在收到上述`ON_RESUME`事件后初始化相机。如果希望在Activity 处于“已暂停”状态但可见时（例如在多窗口模式下）保持相机可用，应在收到`ON_START`事件后初始化相机。但注意，若要让相机在Activity处于“已暂停”状态时可用，可能会导致系统在多窗口模式下拒绝其他处于“已恢复”状态的应用访问相机。有时可能有必要让相机在Activity处于“已暂停”状态时保持可用，但这样做实际可能会降低整体用户体验。生命周期的哪个阶段更适合在多窗口环境下控制共享系统资源需要仔细考虑。\n\n无论选择在哪个构建事件中执行初始化操作，都务必使用相应的生命周期事件来释放资源。如果在收到`ON_START`事件后初始化某些内容，需在收到`ON_STOP`事件后释放或终止相应内容。如果在收到`ON_RESUME`事件后初始化某些内容，需在收到`ON_PAUSE`事件后将其释放。\n\n注意，上述代码段将相机初始化代码放置在生命周期感知型组件中。可以直接将此代码放入Activity生命周期回调（例如`onStart()`和`onStop()`），但不建议这样做。通过将此逻辑添加到独立的生命周期感知型组件中，可以对多个Activity重复使用该组件，而无需复制代码。\n\n## onPause()\n\n当Activity失去焦点并进入“**已暂停**”状态时，系统就会调用`onPause()`。例如，当用户点按“`返回`”或“`最近使用的应用`”按钮时，就会出现此状态。当系统为Activity调用`onPause()`时，从技术上来说，这意味着Activity仍然部分可见，但大多数情况下，这表明用户正在离开该Activity，该Activity很快将进入“**已停止**”或“**已恢复**”状态。\n\n如果用户希望界面继续更新，则处于“**已暂停**”状态的Activity也可以继续更新界面。例如，显示导航地图屏幕或播放媒体播放器的Activity就属于此类Activity。即使此类Activity失去了焦点，用户仍希望其界面继续更新。\n\n不应使用`onPause()`来保存应用或用户数据、进行网络呼叫或执行数据库事务。\n\n`onPause()`执行完毕后，下一个回调为`onStop()`或`onResume()`，具体取决于Activity进入“**已暂停**”状态后发生的情况。\n\n---\n\n系统将此方法视为用户将要离开Activity的第一个标志（尽管这并不总是意味着Activity会被销毁）；此方法表示Activity不再位于前台（尽管在用户处于多窗口模式时Activity仍然可见）。使用`onPause()`方法以暂停或调整当`Activity`处于“已暂停”状态时不应继续（或应有节制地继续）的操作，以及你希望很快恢复的操作。Activity进入此状态的原因有很多。例如：\n\n- 如`onResume()`部分所述，某个事件会中断应用执行。这是最常见的情况。\n- 在Android 7.0（API 级别 24）或更高版本中，有多个应用在多窗口模式下运行。无论何时，都只有一个应用（窗口）可以拥有焦点，因此系统会暂停所有其他应用。\n- 有新的半透明Activity（例如对话框）处于开启状态。只要Activity仍然部分可见但并未处于焦点之中，它便会一直暂停。\n\n当Activity进入已暂停状态时，与Activity生命周期相关联的所有生命周期感知型组件都将收到 `ON_PAUSE`事件。这时，生命周期组件可以停止在组件未位于前台时无需运行的任何功能，例如停止相机预览。\n\n还可以使用`onPause()`方法释放系统资源、传感器（例如GPS）手柄，或当Activity暂停且用户不需要它们时仍然可能影响电池续航时间的任何资源。然而，正如上文的onResume()部分所述，如果处于多窗口模式，“已暂停”的Activity仍完全可见。因此，应该考虑使用onStop()而非onPause()来完全释放或调整与界面相关的资源和操作，以便更好地支持多窗口模式。\n\n响应`ON_PAUSE`事件的以下`LifecycleObserver`示例与上述`ON_RESUME`事件示例相对应，会释放在收到`ON_RESUME`事件后初始化的相机：\n```java\npublic class JavaCameraComponent implements LifecycleObserver {\n    ...\n    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)\n    public void releaseCamera() {\n        if (camera != null) {\n            camera.release();\n            camera = null;\n        }\n    }\n    ...\n}\n```\n\n请注意，上述代码段是在LifecycleObserver收到`ON_PAUSE`事件后释放相机。\n\n`onPause()`的执行非常简短，不一定有足够的时间来执行保存操作。因此，不应使用 `onPause()`来保存应用或用户数据、进行网络调用或执行数据库事务。而应在`onStop()`期间执行高负载的关闭操作。\n\n`onPause()`方法的完成**并不意味着Activity离开“已暂停”状态。相反，Activity会保持此状态**，直到其恢复或变成对用户完全不可见。如果Activity恢复，系统将再次调用`onResume()`回调。如果Activity从“已暂停”状态返回“已恢复”状态，系统会让Activity实例继续驻留在内存中，并会在系统调用`onResume()`时重新调用该实例。在这种情况下，无需重新初始化在任何回调方法导致Activity进入“已恢复”状态期间创建的组件。如果Activity变为完全不可见，系统会调用`onStop()`。\n\n## onStop()\n\n当Activity对用户不再可见时，系统会调用`onStop()`。出现这种情况的原因可能是Activity被销毁，新的Activity启动，或者现有的Activity正在进入“**已恢复**”状态并覆盖了已停止的Activity。在所有这些情况下，停止的Activity都将完全不再可见。\n\n系统调用的下一个回调将是`onRestart()`（如果Activity重新与用户互动）或者`onDestroy()`（如果Activity彻底终止）。\n\n---\n\n如果Activity不再对用户可见，说明其已进入“已停止”状态，因此系统将调用`onStop()`回调。例如，当新启动的Activity覆盖整个屏幕时，可能会发生这种情况。系统也可能在Activity已结束运行并即将终止时调用`onStop()`。\n\n当Activity进入已停止状态时，与Activity生命周期相关联的所有生命周期感知型组件都将收到`ON_STOP`事件。这时，生命周期组件可以停止在组件未显示在屏幕上时无需运行的任何功能。\n\n在`onStop()`方法中，应用应释放或调整在应用对用户不可见时的无用资源。例如，应用可以暂停动画效果，或从精确位置更新切换到粗略位置更新。使用`onStop()`而非`onPause()`可确保与界面相关的工作继续进行，即使用户在多窗口模式下查看Activity也能如此。\n\n应使用`onStop()`执行CPU相对密集的关闭操作。例如，如果您无法找到更合适的时机来将信息保存到数据库，可以在`onStop()`期间执行此操作。以下示例展示了`onStop()`的实现，它将草稿笔记内容保存到持久性存储空间中：\n\n```java\n@Override\nprotected void onStop() {\n    // call the superclass method first\n    super.onStop();\n\n    // save the note's current draft, because the activity is stopping\n    // and we want to be sure the current note progress isn't lost.\n    ContentValues values = new ContentValues();\n    values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText());\n    values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle());\n\n    // do this update in background on an AsyncQueryHandler or equivalent\n    asyncQueryHandler.startUpdate (\n            mToken,  // int token to correlate calls\n            null,    // cookie, not used here\n            uri,    // The URI for the note to update.\n            values,  // The map of column names and new values to apply to them.\n            null,    // No SELECT criteria are used.\n            null     // No WHERE columns are used.\n    );\n}\n```\n\n注意，上述代码示例直接使用SQLite。但应该改用Room，这是一个通过SQLite提供抽象层的持久性库。\n\n当Activity进入“已停止”状态时，Activity对象会继续驻留在内存中：**该对象将维护所有状态和成员信息，但不会附加到窗口管理器**（It maintains all state and member information, but is not attached to the window manager.）。Activity恢复后，Activity会重新调用这些信息。无需重新初始化在任何导致Activity进入“已恢复”状态的回调方法中创建的组件。系统还会追踪布局中每个View对象的当前状态，比如用户在`EditText`微件中输入文本，系统将保留文本内容，因此无需保存和恢复文本。\n\n> 注意：Activity停止后，如果系统需要恢复一些内存，可能会销毁包含该Activity的进程。即使系统在Activity停止后销毁相应进程，系统仍会保留`Bundle`（键值对的blob）中View对象的状态，并在用户返回Activity时恢复这些对象。请参阅[保存和恢复 Activity 状态](https://developer.android.com/guide/components/activities/activity-lifecycle#saras)。\n\n进入“已停止”状态后，Activity要么返回与用户互动，要么结束运行并消失。如果Activity返回，系统将调用`onRestart()`；如果Activity结束运行，系统将调用`onDestroy()`。\n\n## onRestart()\n\n当处于“**已停止**”状态的Activity即将重启时，系统就会调用此回调。`onRestart()`会从Activity停止时的状态恢复Activity。\n\n此回调后面总是跟着`onStart()`。\n\n## onDestroy()\n\n系统会在销毁Activity之前调用此回调。\n\n此回调是Activity接收的最后一个回调。通常，实现`onDestroy()`是为了确保在销毁Activity或包含该Activity的进程时释放该Activity的所有资源。\n\n---\n\n销毁Activity之前，系统会先调用`onDestroy()`。系统调用此回调的原因有：\n\n1. Activity即将结束（由于用户彻底关闭Activity或由于系统为Activity调用`finish()`），或\n2. 由于配置变更（例如设备旋转或多窗口模式），系统暂时销毁Activity。\n\n当Activity进入已销毁状态时，与Activity生命周期相关联的所有生命周期感知型组件都将收到`ON_DESTROY`事件。这时，生命周期组件可以在Activity被销毁之前清理所需的任何数据。\n\n应使用`ViewModel`对象来包含Activity的相关视图数据，而不是在Activity中加入逻辑来确定Activity被销毁的原因。如果因配置变更而重新创建Activity，ViewModel不必执行任何操作，因为系统将保留ViewModel并将其提供给下一个Activity实例。如果不重新创建Activity，ViewModel将调用`onCleared()`方法，以便在Activity被销毁前清除所需的任何数据。\n\n可以使用`isFinishing()`方法区分这两种情况。\n\n如果Activity即将结束，onDestroy()是Activity收到的最后一个生命周期回调。如果由于配置变更而调用onDestroy()，系统会立即新建Activity实例，然后在新配置中为新实例调用`onCreate()`。\n\n`onDestroy()`回调应释放先前的回调，例如`onStop()`尚未释放的所有资源。\n\n# Activity状态和从内存中弹出(ejection)\n\n系统会在需要释放RAM时终止进程；系统终止给定进程的可能性取决于当时进程的状态，然而，**进程状态取决于在进程中运行的Activity的状态**。表1展示了进程状态、Activity状态以及系统终止进程的可能性之间的关系。\n\n| 系统终止进程的可能性 | 进程状态                   | Activity状态           |\n| -------------------- | -------------------------- | ---------------------- |\n| 较小                 | 前台（拥有或即将得到焦点） | 已创建、已开始、已恢复 |\n| 较大                 | 后台（失去焦点）           | 已暂停                 |\n| 最大                 | 后台（不可见）、空         | 已停止、已销毁         |\n\n系统永远不会直接终止Activity以释放内存，而是会终止Activity所在的进程。系统不仅会销毁Activity，还会销毁在该进程中运行的所有其他内容。如需了解如何在系统启动的进程被终止时保留和恢复Activity的界面状态，参阅[保存和恢复Activity状态](https://developer.android.com/guide/components/activities/activity-lifecycle#saras)。\n\n用户还可以使用“设置”下的“应用管理器”来终止进程，以终止相应的应用。\n\n了解一般进程，参阅[进程和线程](https://developer.android.com/guide/components/processes-and-threads)。如需详细了解进程生命周期如何与其中Activity的状态相关联，参阅[进程生命周期](https://developer.android.com/guide/components/processes-and-threads#Lifecycle)部分。\n\n## 保存和恢复瞬时界面状态\n\n用户期望Activity的界面状态在整个配置变更（例如旋转或切换到多窗口模式）期间保持不变。但是，**默认情况下，系统会在发生此类配置更改时销毁Activity，从而清除存储在Activity实例中的任何界面状态**。同样，如果用户暂时从应用切换到其他应用，并在稍后返回应用，用户希望界面状态保持不变。但是，当用户离开应用且Activity停止时，系统可能会销毁该应用的进程。\n\n当Activity因系统限制而被销毁时，应组合使用`ViewModel`、`onSaveInstanceState()`和/或本地存储来保留用户的瞬时界面状态。可以在进一步详细了解用户期望与系统行为，以及如何在系统启动的Activity和进程被终止后最大程度地保留复杂的界面状态数据，参阅[保存界面状态](https://developer.android.com/topic/libraries/architecture/saving-states)。\n\n下面概述实例状态的定义，以及如何实现onSaveInstance()方法，该方法是Activity本身的回调。如果界面数据简单且轻量，例如原始数据类型或简单对象（比如String），可以单独使用onSaveInstanceState()使界面状态在配置更改和系统启动的进程被终止时保持不变。但在大多数情况下，应使用ViewModel和onSaveInstanceState()（如[保存界面状态](https://developer.android.com/topic/libraries/architecture/saving-states)中所述），因为 onSaveInstanceState()会产生序列化/反序列化费用。\n\n## 实例状态\n\n在某些情况下，Activity会因正常的应用行为而被销毁，例如当用户按下返回按钮或Activity通过调用`finish()`方法发出销毁信号时，此时系统和用户对该Activity实例的概念将永远消失。在这些情况下，用户的期望与系统行为相匹配，无需完成任何额外工作。\n\n但是，如果系统因系统限制（例如配置变更或内存压力）而销毁Activity，虽然实际的Activity实例会消失，但系统会记住它曾经存在过。如果用户尝试回退到该Activity，系统将**使用已保存的一组描述Activity销毁时状态的数据**重建该Activity实例。\n\n系统用于恢复先前状态的已保存数据称为**实例状态**，是存储在**Bundle对象中的键值对集合**。默认情况下，系统使用`Bundle`实例状态来保存**Activity布局中每个View对象的相关信息**（例如在`EditText`微件中输入的文本值）。这样，如果Activity实例被销毁并重新创建，布局便会恢复为其先前的状态，且无需编写代码。但是，Activity可能包含你想要恢复的更多状态信息，例如追踪用户在Activity中的进程的成员变量。\n\n> 注意：为了使Android系统恢复Activity中视图的状态，每个视图必须具有`android:id`属性提供的唯一ID。\n\n`Bundle`对象并不适合保留大量数据，因为它需要在主线程上进行序列化处理并占用系统进程内存。如需保存大量数据，应组合使用持久性本地存储、`onSaveInstanceState()`方法和`ViewModel`类来保存数据，正如[保存界面状态](https://developer.android.com/topic/libraries/architecture/saving-states)中所述。\n\n## 使用onSaveInstanceState()保存简单轻量的界面状态\n\n当Activity开始停止时，系统会调用`onSaveInstanceState()`方法，以便Activity可以将状态信息保存到实例状态Bundle中。此方法的默认实现保存有关Activity视图层次结构状态的瞬时信息，例如`EditText`微件中的文本或`ListView`微件的滚动位置。\n\n如需保存Activity的其他实例状态信息，必须替换`onSaveInstanceState()`，并将键值对添加到Activity意外销毁时事件中所保存的`Bundle`对象中。替换onSaveInstanceState()时，如果希望默认实现保存视图层次结构的状态，必须调用父类实现。例如：\n\n```java\nstatic final String STATE_SCORE = \"playerScore\";\nstatic final String STATE_LEVEL = \"playerLevel\";\n// ...\n@Override\npublic void onSaveInstanceState(Bundle savedInstanceState) {\n    // Save the user's current game state\n    savedInstanceState.putInt(STATE_SCORE, currentScore);\n    savedInstanceState.putInt(STATE_LEVEL, currentLevel);\n\n    // Always call the superclass so it can save the view hierarchy state\n    super.onSaveInstanceState(savedInstanceState);\n}\n```\n\n> 注意：当用户显式关闭Activity时，或者在其他情况下调用`finish()`时，系统不会调用onSaveInstanceState()。\n\n如需保存持久性数据（例如用户首选项或数据库中的数据），应在Activity位于前台时抓住合适机会。如果没有这样的时机，应在执行`onStop()`方法期间保存此类数据。\n\n## 使用保存的实例状态恢复Activity界面状态\n\n重建先前被销毁的Activity后，可以从系统传递给Activity的`Bundle`中恢复保存的实例状态。`onCreate()`和 `onRestoreInstanceState()`回调方法均会收到包含实例状态信息的相同`Bundle`。\n\n因为无论系统是新建Activity实例还是重新创建之前的实例，都会调用`onCreate()`方法，所以在尝试读取之前，必须检查状态Bundle是否为null。如果为null，系统将新建Activity实例，而不会恢复之前销毁的实例。\n\n例如，以下代码段显示如何在`onCreate()`中恢复某些状态数据：\n\n```java\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState); // Always call the superclass first\n\n    // Check whether we're recreating a previously destroyed instance\n    if (savedInstanceState != null) {\n        // Restore value of members from saved state\n        currentScore = savedInstanceState.getInt(STATE_SCORE);\n        currentLevel = savedInstanceState.getInt(STATE_LEVEL);\n    } else {\n        // Probably initialize members with default values for a new instance\n    }\n    // ...\n}\n```\n\n可以选择实现系统在`onStart()`方法之后调用的`onRestoreInstanceState()`，而不是在`onCreate()`期间恢复状态。仅当存在要恢复的已保存状态时，系统才会调用`onRestoreInstanceState()`，因此您无需检查`Bundle`是否为 null：\n\n```java\npublic void onRestoreInstanceState(Bundle savedInstanceState) {\n    // Always call the superclass so it can restore the view hierarchy\n    super.onRestoreInstanceState(savedInstanceState);\n\n    // Restore state members from saved instance\n    currentScore = savedInstanceState.getInt(STATE_SCORE);\n    currentLevel = savedInstanceState.getInt(STATE_LEVEL);\n}\n```\n\n>注意：应始终调用`onRestoreInstanceState()`的父类实现，以便默认实现可以恢复视图层次结构的状态。\n\n# 处理Activity状态更改\n\n用户触发和系统触发的不同事件会导致Activity从一个状态转换到另一个状态。下面介绍发生此类转换的一些常见情况，以及如何处理这些转换。\n\n有关Activity状态的详情，参阅Activity生命周期。要了解如何借助ViewModel类来管理Activity生命周期，参阅了解ViewModel类。\n\n## 配置发生了更改\n\n有很多事件会触发配置更改。最显著的例子或许是横屏和竖屏之间的屏幕方向变化。其他情况，如语言或输入设备的改变等，也可能导致配置更改。\n\n当配置发生更改时，Activity会被销毁并重新创建。原始Activity实例将触发`onPause()`、`onStop()`和`onDestroy()`回调。系统将创建新的Activity实例，并触发`onCreate()`、`onStart()`和`onResume()`回调。\n\n结合使用ViewModels、onSaveInstanceState()方法和/或持久性本地存储，可使Activity的界面状态在配置发生更改后保持不变。在决定这些选项的组合方式时，需要考虑界面数据的复杂程度、应用的用例以及检索速度与内存使用的权衡。有关保存Activity界面状态的详情，请参阅[保存界面状态](https://developer.android.com/topic/libraries/architecture/saving-states)。\n\n## 处理多窗口模式的情况\n\n一旦应用进入多窗口模式（适用于Android 7.0（API级别24）及更高级别），系统会向当前运行的Activity发送配置更改通知，从而完成上述生命周期转换。如果已经处于多窗口模式的应用调整了大小，也会出现这种行为。Activity可以自行处理配置更改，也可以让系统销毁Activity并使用新维度重新创建。\n\n有关多窗口模式生命周期的详情，参阅[多窗口模式支持](https://developer.android.com/guide/topics/ui/multi-window)页的[多窗口模式生命周期](https://developer.android.com/guide/topics/ui/multi-window#lifecycle)部分。\n\n在多窗口模式下，虽然用户可以看到两个应用，但只有与用户交互的应用位于前台且具有焦点。该Activity处于“已恢复”状态，而另一个窗口中的应用则处于“已暂停”状态。\n\n当用户从应用A切换到应用B时，系统会对应用A调用`onPause()`，对应用B调用`onResume()`。每当用户在应用之间切换时，系统就会在这两种方法之间切换。\n\n有关多窗口模式的详情，参阅[多窗口模式支持](https://developer.android.com/guide/topics/ui/multi-window)。\n\n## Activity或对话框显示在前台\n\n如果有新的Activity或对话框出现在前台，并且**局部覆盖**了正在进行的Activity，则被覆盖的Activity会失去焦点并进入“已暂停”状态。然后，系统会调用`onPause()`。\n\n当被覆盖的Activity返回到前台并重新获得焦点时，会调用`onResume()`。\n\n如果有新的Activity或对话框出现在前台，夺取了焦点且**完全覆盖**了正在进行的Activity，则被覆盖的Activity会失去焦点并进入“已停止”状态。然后，系统会快速地接连调用`onPause()`和`onStop()`。\n\n当被覆盖的Activity的同一实例返回到前台时，系统会对该Activity调用`onRestart()`、`onStart()`和`onResume()`。如果被覆盖的Activity的新实例进入后台，则系统不会调用`onRestart()`，而只会调用`onStart()`和`onResume()`。\n\n>注意：当用户点按“概览（Overview）”或主屏幕按钮时，系统的行为就好像当前Activity已被完全覆盖一样。\n\n## 用户点按“返回”按钮\n\n如果Activity位于前台，并且用户点按了返回按钮，Activity将依次经历`onPause()`、`onStop()`和`onDestroy()`回调。活动不仅会被销毁，还会从返回堆栈中移除。\n\n需要注意的是，在这种情况下，默认不会触发`onSaveInstanceState()`回调。此行为基于的假设是，用户点按返回按钮时不期望返回Activity的同一实例。不过，可以通过替换`onBackPressed()`方法实现某种自定义行为，例如“confirm-quit”对话框。\n\n如果替换`onBackPressed()`方法，强烈建议从被替换的方法调用`super.onBackPressed()`。否则，返回按钮的行为可能会让用户感觉突兀。\n\n## 系统终止应用进程\n\n如果某个应用处于后台并且系统需要为前台应用释放额外的内存，则系统可能会终止后台应用以释放更多内存。要详细了解系统如何确定要销毁哪些进程，参阅[Activity状态和从内存中弹出](https://developer.android.com/guide/components/activities/activity-lifecycle#asem)以及[进程和应用生命周期](https://developer.android.com/guide/components/activities/process-lifecycle)。\n\n要了解如何在系统终止应用进程时保存Activity界面状态，请参阅[保存和恢复Activity 状态](https://developer.android.com/guide/components/activities/activity-lifecycle#saras)。\n\n# 在Activity之间导航\n\n在应用的生命周期中，应用很可能会多次进入和退出Activity。例如，用户可以点按设备的返回按钮，或者Activity可能需要启动不同的Activity。本部分介绍如何实现Activity转换，包括从另一个Activity启动Activity、保存Activity状态，以及恢复Activity状态。\n\n## 从一个Activity启动另一个Activity\n\nActivity通常需要在某个时刻启动另一个Activity。例如，当应用需要从当前屏幕移动到新屏幕时，就会出现这种需求。\n\n根据Activity是否希望从即将启动的新Activity中获取返回结果，可以使用`startActivity()`或`startActivityForResult()`方法启动新Activity。这两种方法都需要传入一个`Intent`对象。\n\n`Intent`对象指定要启动的具体Activity，或描述要执行的操作类型（系统选择相应的Activity，该Activity甚至可以来自不同应用）。`Intent`对象还可以携带已启动的Activity的少量数据。如需详细了解`Intent`类，参阅[Intent 和 Intent 过滤器](https://developer.android.com/guide/components/intents-filters)。\n\n> Intent对象的作用：\n>\n> 1. 指定要启动的具体Activity\n> 2. 可以携带已启动的Activity的少量数据\n\n## startActivity()\n\n如果新启动的Activity不需要返回结果，当前Activity可以通过调用`startActivity()`方法来启动它。\n\n在自己的应用本身中工作时，通常只需启动已知Activity。例如，以下代码段显示如何启动一个名为`SignInActivity`的 Activity。\n\n```java\nIntent intent = new Intent(this, SignInActivity.class);\nstartActivity(intent);\n```\n\n应用可能还希望使用Activity中的数据执行某些操作，例如发送电子邮件、短信或状态更新。在这种情况下，应用自身可能不具有执行此类操作所需的Activity，因此可以改为利用设备上其他应用提供的Activity来执行这些操作，这便是intent的真正价值所在。可以创建一个intent，对想执行的操作进行描述，系统会从其他应用启动相应的Activity。如果有多个Activity可以处理intent，用户可以选择要使用哪一个。例如，如果想允许用户发送电子邮件，可以创建以下intent：\n\n```java\nIntent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_EMAIL, recipientArray);\nstartActivity(intent);\n```\n\n添加到intent中的`EXTRA_EMAIL`extra是一个字符串数组，其中包含电子邮件的收件人电子邮件地址。当电子邮件应用响应此intent时，该应用会读取extra中提供的字符串数组，并将该数组放入电子邮件撰写表单的“收件人”字段。在这种情况下，电子邮件应用的Activity会启动，并且当用户完成操作时，你的Activity会继续运行。\n\n## startActivityForResult()\n\n有时，希望在Activity结束时从Activity中获取返回结果。例如，可以启动一项Activity，让用户在联系人列表中选择收件人；当Activity结束时，系统将返回用户选择的收件人。为此，可以调用`startActivityForResult(Intent, int)`方法，其中整数参数会标识该调用。此标识符用于消除来自同一Activity的多次`startActivityForResult(Intent, int)`调用之间的歧义。这不是全局标识符，不存在与其他应用或Activity冲突的风险。结果通过`onActivityResult(int, int, Intent)`方法返回。\n\n当子级Activity退出时，它可以调用`setResult(int)`将数据返回到其父级。子级Activity必须始终提供结果代码，该结果代码可以是标准结果`RESULT_CANCELED`、`RESULT_OK`，也可以是从`RESULT_FIRST_USER`开始的任何自定义值。此外，子级Activity可以根据需要返回包含它所需的任何其他数据的`Intent`对象。父级Activity使用`onActivityResult(int, int, Intent)`方法，以及父级Activity最初提供的整数标识符来接收信息。\n\n如果子级Activity由于任何原因（例如崩溃）而失败，父级Activity将收到代码为`RESULT_CANCELED`的结果。\n\n```java\npublic class MyActivity extends Activity {\n     // ...\n     static final int PICK_CONTACT_REQUEST = 0;\n     public boolean onKeyDown(int keyCode, KeyEvent event) {\n         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {\n             // When the user center presses, let them pick a contact.\n             startActivityForResult(\n                 new Intent(Intent.ACTION_PICK,\n                 new Uri(\"content://contacts\")),\n                 PICK_CONTACT_REQUEST);\n            return true;\n         }\n         return false;\n     }\n     protected void onActivityResult(int requestCode, int resultCode,\n             Intent data) {\n         if (requestCode == PICK_CONTACT_REQUEST) {\n             if (resultCode == RESULT_OK) {\n                 // A contact was picked.  Here we will just display it\n                 // to the user.\n                 startActivity(new Intent(Intent.ACTION_VIEW, data));\n             }\n         }\n     }\n }\n```\n\n## 协调Activity\n\n当一个Activity启动另一个Activity时，它们都会经历生命周期转换。第一个Activity停止运行并进入“已暂停”或“已停止”状态，同时创建另一个Activity。如果这些Activity共享保存到磁盘或其他位置的数据，必须要明确第一个Activity在创建第二个Activity之前并未完全停止。相反，启动第二个Activity的过程与停止第一个Activity的过程重叠。\n\n生命周期回调的顺序已有明确定义，特别是当两个Activity在同一个进程（应用）中，并且其中一个要启动另一个时。以下是Activity A启动Activity B时的操作发生顺序：\n\n1. Activity A的`onPause()`方法执行。\n2. Activity B的`onCreate()`、`onStart()`和`onResume()`方法依次执行（Activity B现在具有用户焦点）。\n3. 然后，如果Activity A在屏幕上不再显示，其`onStop()`方法执行。\n\n可以利用这种可预测的生命周期回调顺序管理从一个Activity到另一个Activity的信息转换。\n","categories":["Android"]},{"title":"Android_ListView","url":"/Android/Android_ListView/","content":"\nListView称得上是Android中最常用的控件之一，几乎所有应用都会用到它。因为手机屏幕空间比较有限，当程序中有大量的数据需要展示的时候，可以借助ListView来实现。ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。\n\n# 简单用法\n\n首先新建一个ListViewTest项目，并让Android Studio自动帮我们创建好活动。然后修改`activity_main.xml`中的代码，如下所示：\n\n```xml\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <ListView\n        android:id=\"@+id/list_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n    </ListView>\n</LinearLayout>\n```\n\nMainActivity代码\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private String[] data = {\"Apple\", \"Banana\", \"Orange\", \"Watermelon\",\n        \"Pear\", \"Grape\", \"Pineapple\", \"Strawberry\", \"Cherry\", \"Mango\",\n        \"Apple\", \"Banana\", \"Orange\", \"Watermelon\", \"Pear\", \"Grape\",\n        \"Pineapple\", \"Strawberry\", \"Cherry\", \"Mango\"};\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ArrayAdapter<String> adapter = new ArrayAdapter<>(\n            MainActivity.this, android.R.layout.simple_list_item_1, data);\n        ListView listView = (ListView) findViewById(R.id.list_view);\n        listView.setAdapter(adapter);\n    }\n}\n```\n\n","categories":["Android"]},{"title":"软件体系结构","url":"/设计模式/软件体系结构/","content":"参考书籍：张友生编著 - 软件体系结构原理、方法与实践（第2版）\n\n# 第1章 软件体系结构概论\n\n## 构件\n\n一般认为，构件是指语义完整、语法正确和有可重用价值的单位软件，是软件重用过程中可以明确辨识的系统；结构上，它是语义描述、通信接口和实现代码的复合体。\n\n有的可以独立工作，有的需要与其他配合工作；使用和开发生产无关，只要按照标准来生产；\n\n## 构件模型\n\n构件模型是对构件本质的抽象描述，主要是为构件的制作与构件的重用提供依据。\n\n### 青鸟构件模型\n\n青鸟构件模型由外部接口和内部结构两部分组成；\n\n外部接口说明了构件所提供的服务（消息、操作、变量）；\n\n内部结构分为内部成员以及内部成员之间的关系。其中内部成员包括具体成员与虚拟成员；而成员关系包括内部成员之间的互联，以及内部成员与外部接口之间的互联\n\n## 构件获取\n\n1. 从现有构件中获得符合要求的构件，直接使用或作适应性修改，得到可重用的构件。\n2. 通过遗留工程，将具有潜在重用价值的构件提取出来，得到可重用的构件。\n3. 从市场上购买现成的商业构件， 即COTS(Commercial Off-The-Shell)构件。\n4. 开发新的符合要求的构件。\n\n## 构件管理\n\n### 构件描述\n\n从管理角度出发，也需要对构件进行描述，例如：实现方式、实现体、注释、生产者、生产日期、大小、价格、版本和关联构件等信息，它们与构件模型共同组成了对构件的完整描述。\n\n### 构件分类与组织\n\n为了给用户在查询构件时提供方便，同时也为了更好地重用组件，必须对收集和开发的构件进行分类并置于构件库的适当位置。构件库的组织应方便构件的存储和检索；\n\n可重用技术对构件库组织方法的要求：\n\n1. 支持构件库的各种维护动作，如增加、删除、修改构件，尽量不要影响构件库的结构。\n2. 不仅支持精确匹配，还要支持相似构件的查找。\n3. 不仅能进行简单的语法匹配，而且能够查找在功能或行为方面等价或相似的构件。\n4. 对应用领域具有较强的描述能力和较好的描述精度。\n5. 库管理员和用户容易使用。\n\n### 构件分类三大方法\n\n1. 关键字分类法 - 分层逐次树状图\n2. 刻面分类法 - 定义若干用于刻画构件特征的\"面\"\n3. 超文本组织方法\n\n### 人员及权限管理\n\n有必要对不同使用者的访问权限进行限制，保证数据安全；\n\n构件库系统可包括5类用户，即注册用户、公共用户、构件提交者、一般系统管理员、超级系统管理员。\n\n## 理解与评价构件\n\n1. 构件的功能与行为\n2. 相关的领域知识\n3. 可适应性约束条件与例外情形\n4. 可以预见的修改部分及修改方法\n\n理解构件的另一种重要手段：逆向工程，试图通过对构件的分析，结合领域知识，半自动地生成相应的设计信息，然后借助设计信息完成对构件的理解和修改。\n\n对构件可重用的评价：是通过收集并分析构件的用户在实际重用该构件的历史过程中的各种反馈信息来完成的。这些信息包括：重用成功的次数，对构件的修改量，构件的健壮性度量，性能度量等等。\n\n## 软件体系结构含义\n\n软件体系结构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。\n\n软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理。\n\n## 软件体系结构设计的方法\n\n两大类方法：过程驱动方法和问题列表驱动方法。\n\n过程驱动方法又分为：\n\n1. 面向对象方法，与OOA/OOD相似，但更侧重接口与交互。\n2. “4+1”模型方法。\n3. 基于场景的迭代方法。\n\n基于过程驱动的体系结构设计方法适用范围广, 易于裁剪, 具备动态特点, 通用性与实践性强。\n\n问题列表驱动法适用于特定领域, 是静态的, 可以实现量化体系结构设计空间。其基本思想是枚举设计空间, 并考虑设计维的相关性, 以此来选择体系结构的风格。\n\n## 软件体系结构发展史\n\n1. 无体系结构设计阶段\n   1. 以汇编语言进行小规模应用程序开发为特征\n2. 萌芽阶段\n   1. 出现了程序结构设计主题，以控制流图和数据流图构成软件结构为特征\n3. 初期阶段\n   1. 出现了从不同侧面描述系统的结构模型，以UML为典型代表。\n4. 高级阶段\n   1. 以描述系统的高层抽象结构为中心，不关心具体的建模细节，划分了体系结构模型与传统软件结构的界限，该阶段以Kruchten提出的“4+1”模型为标志\n\n# 第2章 软件体系结构建模\n\n## 4+1视图\n\n4指的是逻辑、开发、进程、物理视图，1指的是场景视图。每一个视图只关心系统的一个侧面，5个视图结合在一起才能反映系统的软件体系结构的全部内容。\n\n![2022-06-19_222151](../../images/软件体系结构/4plus1.png)\n\n### 逻辑视图\n\n逻辑视图：是从最终用户的角度来看的，关注点是功能需求；\n\n逻辑视图主要支持系统的功能需求，即系统提供给最终用户的服务。\n在逻辑视图中，系统分解成一系列的功能抽象，这些抽象主要来自问题领域。这种分解不但可以用来进行功能分析，而且可用作标识在整个系统的各个不同部分的通用机制和设计元素。\n在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图。\n\n### 开发视图\n\n开发视图（也叫模块视图）：是从程序员的角度来看的，主要侧重软件模块的组织和管理；\n\n开发视图也称模块视图，主要侧重于软件模块的组织和管理。\n开发视图要考虑软件内部的需求，如软件开发的容易性、软件的重用和软件的通用性，要充分考虑由于具体开发工具的不同而带来的局限性。\n开发视图通过系统输入输出关系的模型图和子系统图来描述。\n\n### 进程视图\n\n进程视图（也叫并发视图）：是从系统集成人员的角度来看的，主要侧重系统的运行特性（非功能型的），性能和可用性、吞吐量，性能可扩充性。\n\n进程视图侧重于系统的运行特性，主要关注一些非功能性的需求。\n进程视图强调并发性、分布性、系统集成性和容错能力，以及从逻辑视图中的主要抽象如何适合进程结构。它也定义逻辑视图中的各个类的操作具体是在哪一个线程中被执行的。\n进程视图可以描述成多层抽象，每个级别分别关注不同的方面。在最高层抽象中，进程结构可以看作是构成一个执行单元的一组任务。\n它可看成一系列独立的，通过逻辑网络相互通信的程序。它们是分布的，通过总线或局域网、广域网等硬件资源连接起来。\n\n### 物理视图\n\n物理视图：是从系统工程人员的角度来看的，主要考虑系统拓扑结构、设备安装、通信等\n\n物理视图主要考虑如何把软件映射到硬件上，它通常要考虑到系统性能、规模、可靠性等。解决系统拓扑结构、系统安装、通讯等问题。\n当软件运行于不同的节点上时，各视图中的构件都直接或间接地对应于系统的不同节点上。因此，从软件到节点的映射要有较高的灵活性，当环境改变时，对系统其他视图的影响最小。\n\n### 场景视图\n\n场景可以看作是那些重要系统活动的抽象，它使四个视图有机联系起来，从某种意义上说场景是最重要的需求抽象。在开发体系结构时，它可以帮助设计者找到体系结构的构件和它们之间的作用关系。\n同时，也可以用场景来分析一个特定的视图，或描述不同视图构件间是如何相互作用的。\n场景可以用文本表示，也可以用图形表示。\n\n## 软件体系结构的核心模型\n\n![2022-06-19_222211](../../images/软件体系结构/core-model.png)\n\n5个元素构成，配置、连接件、构件、端口、角色。\n\n其中，配置、构件、连接件是最基本的元素。\n\n构件是具有某种功能的可重用的软件模板单元，表示了系统中主要的计算元素和数据存储。构件有两种：复合构件和原子构件。复合构件由其他复合构件和原子构件通过连接组成。\n\n连接件表示了构件之间的交互，简单的连接件如管道、过程调用、事件广播等，更为复杂的交互如客户-服务器通信协议，数据库和应用之间的SQL连接等。\n\n配置表示构件和连接件的拓扑逻辑和约束；\n\n构件的接口由1组端口组成；每个端口表示了构件和外部环境的交互点。\n\n连接件作为建模软件体系结构的主要实体，同样也有接口，连接件的接口由1组角色构成；每一个角色定义了该连接件表示的交互的参与者。\n\n# 第3章 软件体系结构风格\n\n1. 管道/过滤器\n2. 面向对象风格（数据抽象）\n3. 基于事件的系统\n4. 分层系统（层次结构）\n5. 黑板系统（仓库系统、知识库）\n6. C2系统\n\n## 管道/过滤器\n\n### 优点\n\n1. 使得软构件具有良好的隐蔽性和高内聚、低耦合的特点；\n2. 允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成；\n3. 支持软件重用。只要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来\n4. 系统维护和增强系统性能简单。新的过滤器可以添加到现有系统中来；旧的可以被改进的过滤器替换掉允许对一些如吞吐量、死锁等属性的分析；\n5. 支持并行执行。每个过滤器是作为一个单独的任务完成，因此可与其它任务并行执行。\n\n### 缺点\n\n1. 通常导致进程成为批处理的结构。这是因为虽然过滤器可增量式地处理数据，但它们是独立的，所以设计者必须将每个过滤器看成一个完整的从输入到输出的转换；\n2. 不适合处理交互的应用。当需要增量地显示改变时，这个问题尤为严重；\n3. 因为在数据传输上没有通用的标准，每个过滤器都增加了解析和合成数据的工作，这样就导致了系统性能下降，并增加了编写过滤器的复杂性。\n\n## 数据抽象和面向对象组织\n\n### 优点\n\n1. 因为对象对其它对象隐藏它的表示，所以可以改变一个对象的表示，而不影响其它的对象；\n2. 设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。\n\n### 缺点\n\n1. 为了使一个对象和另一个对象通过过程调用等进行交互,必须知道对象的标识。只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象;\n2. 必须修改所有显式调用它的其它对象，并消除由此带来的一些副作用。例如，如果A使用了对象B,C也使用了对象B,那么,C对B的使用所造成的对A的影响可能是料想不到的。\n\n## 基于事件的系统（隐式调用风格）\n\n这种风格的主要特点是事件的触发者并不知道哪些构件会被哪些事件影响。\n\n这样不能假定构件的处理顺序，甚至不知道哪些过程会被调用，因此，许多隐式调用的系统也包含显式调用作为构件交互的补充形式。\n\n### 优点\n\n1. 为软件重用提供了强大的支持。当需要将一个构件加入现存系统中时，只需将它注册到系统的事件中。\n2. 为改进系统带来了方便。当用一个构件代替另一个构件时，不会影响到其它构件的接口。\n\n### 缺点\n\n1. 构件放弃了对系统计算的控制。一个构件触发一个事件时，不能确定其它构件是否会响应它。而且即使它知道事件注册了哪些构件的构成，它也不能保证这些过程被调用的顺序。\n2. 数据交换的问题。有时数据可被一个事件传递，但另一些情况下基于事件的系统必须依靠一个共享的仓库进行交互。在这些情况下全局性能和资源管理便成了问题。\n3. 既然过程的语义必须依赖于被触发事件的上下文约束，关于正确性的推理存在问题。\n\n## 分层系统\n\n什么是层？层是一个具有相同属性的集合；\n\n分层是理解问题的一种方法论，可以把复杂软件从大问题分为小问题，从视图的角度看可以降低问题复杂度。\n\n### 优点\n\n1. 支持基于抽象程度递增的系统设计，使设计者可以把一个复杂系统按递增的步骤进行分解\n2. 支持功能增强，因为每一层至多和相邻的上下层交互，因此功能的改变最多影响相邻的上下层；\n3. 支持重用。只要提供的服务接口定义不变，同一层的不同实现可以交换使用。这样，就可以定义一组标准的接口，而允许各种不同的实现方法\n\n### 缺点\n\n1. 并不是每个系统都可以很容易地划分为分层的模式，甚至即使一个系统的逻辑结构是层次化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来；\n2. 很难找到一个合适的、正确的层次抽象方法。\n\n## 仓库系统及知识库\n\n在仓库（repository)风格中，有两种不同的构件：中央数据结构说明当前状态，独立构件在中央数据存储上执行，仓库与外构件间的相互作用在系统中会有大的变化。\n\n控制原则的选取产生两个主要的子类。若输入流中某类时间触发进程执行的选择，则仓库是一传统型数据库；另外，若中央数据结构的当前状态触发进程执行的选择，则仓库是一黑板系统。\n\n黑板系统的传统应用是信号处理领域，如语音和模式识别，另一应用是松藕合代理数据共享存取。\n\n黑板系统主要由三部分组成：\n\n1. 知识源。知识源中包含独立的、与应用程序相关的知识，知识源之间不直接进行通信，它们之间的交互只通过黑板来完成。\n2. 黑板数据结构。黑板数据是按照与应用程序相关的层次来组织的解决问题的数据，知识源通过不断地改变黑板数据来解决问题。\n3. 控制。控制完全由黑板的状态驱动，黑板状态的改变决定使用的特定知识。\n\n## C2风格\n\nC2体系结构风格可以概括为：通过连接件绑定在一起的按照一组规则运作的并行构件网络。C2风格中的系统组织规则如下：\n\n1. 系统中的构件和连接件都有一个顶部和一个底部。\n2. 构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部，而构件与构件之间的直接连接是不允许的。\n3. 一个连接件可以和任意数目的其他构件和连接件连接。\n4. 当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。\n\n### 特点\n\n1. 系统中的构件可实现应用需求,并能将任意复杂度的功能封装在一起;\n2. 所有构件之间的通讯是通过以连接件为中介的异步消息交换机制来实现的;\n3. 构件相对独立,构件之间依赖性较少。系统中不存在某些构件将在同一地址空间内执行,或某些构件共享特定控制线程之类的相关性假设。\n\n# 二层C/S - 客户/服务器风格\n\nC/S软件体系结构是基于资源不对等，且为实现共享而提出来的，是20世纪90年代成熟起来的技术，C/S体系结构定义了工作站如何与服务器相连，以实现数据和应用分布到多个处理机上。\n\nC/S体系结构有三个主要组成部分：数据库服务器、客户应用程序和网络。\n\n前台主要是数据的显示和分析，完成与用户的交互，后台主要是数据的管理。\n\n## 一般处理流程\n\n1. 分为两部分，即一共两层，前台/后台；前台即为客户端，后台即为服务器端；\n2. 前台：表示层，即界面，输入数据，提交请求，业务处理开始，数据存取请求发给后台；\n3. 后台：后台的数据存取程序收到前台提交的请求，数据处理开始，对后台的数据层进行数据存取请求，SQL请求开始，DBMS执行SQL，SQL请求结束，数据处理结束，运行结果返回给前台；\n4. 前台：接收到运行结果，业务处理结束，处理结果输出到界面\n\n## 客户端\n\n1. 要有逻辑计算能力，即对客户端的硬件有要求，如果客户端效率低，会影响整体系统效率；\n\n## 服务器端\n\n后台主要是数据的管理。要有数据库以及相应的操作；\n\n## 优点\n\n主要在于，客户应用程序和服务器构件分别运行在不同的计算机上，系统中每台服务器都可以适合各构件的要求，这对于硬件和软件的变化显示出极大的适应性和灵活性，而且易于对系统进行扩充和缩小。\n\n系统中的功能构件充分隔离，客户应用程序的开发集中于数据的显示和分析；而数据库服务器的开发则集中于数据的管理，不必在每一个新的应用程序都要对一个DBMS进行编码。将大的应用处理任务分布到许多通过网络连接的低成本计算机上，以节约大量费用。\n\n## 缺点\n\n1. 开发成本较高。对客户端软硬件配置要求较高，尤其是软件的不断升级，对硬件要求不断提高，增加了整个系统的成本，客户端变得臃肿。\n2. 客户端程序设计复杂。\n3. 信息内容和形式单一\n4. 用户界面风格不一，使用繁杂，不利于推广使用；\n5. 软件移植困难，不同平台互不兼容。\n6. 软件维护和升级困难，每个客户机都需要升级、维护。\n7. 新技术不能轻易应用。\n\n# 三层C/S - 客户/服务器风格\n\n与二层的区别就是在中间加了一个应用服务器（功能层），而不是和数据库服务器直接相连；\n\n这样，降低了客户机的负担，把数据的计算任务交给了中间的功能层，现在，客户机的表示层只是作为数据的显示了。\n\n1. 表示层\n   1. 表示层是应用的用户接口部分,它担负着用户与应用间的对话功能。它用于检查用户从键盘等输入的数据,显示应用输出的数据。为使用户能直观地进行操作,一般要使用图形用户界面(Graphic User Interface,GUI),操作简单、易学易用。在变更用户界面时,只需改写显示控制和数据检查程序,而不影响其他两层。检查的内容也只限于数据的形式和取值的范围,不包括有关业务本身的处理逻辑\n2. 功能层\n   1. 功能层相当于应用的本体,它是将具体的业务处理逻辑编人程序中。例如,在制作订购合同时要计算合同金额,按照定好的格式配置数据、打印订购合同,而处理所需的数据则要从表示层或数据层取得。表示层和功能层之间的数据交往要尽可能简捷。例如,用户检索数据时,要设法将有关检索要求的信息一次性地传送给功能层,而由功能层处理过的检索结果数据也一次性地传送给表示层。\n   2. 通常,在功能层中包含确认用户对应用和数据库存取权限的功能以及记录系统处理日志的功能。功能层的程序多半是用可视化编程工具开发的,也有使用COBOL和C语言的\n3. 数据层\n   1. 数据层就是数据库管理系统,负责管理对数据库数据的读写。数据库管理系统必须能迅速执行大量数据的更新和检索。现在的主流是关系型数据库管理系统(RDBMS),因此,般从功能层传送到数据层的要求大都使用SQL。\n   2. 三层C/S的解决方案是:对这三层进行明确分割,并在逻辑上使其独立。原来的数据层作为数据库管理系统已经独立出来,所以,关键是要将表示层和功能层分离成各自独立的程序,并且还要使这两层间的接口简洁明了。\n\n## 优点\n\n根据三层C/S的概念及使用实例可以看出，与两层C/S结构相比，三层C/S结构具有以下优点：\n\n1. 允许合理地划分三层结构的功能，使之在逻辑上保持相对独立性，从而使整个系统的逻辑结构更为清晰，能提高系统和软件的可维护性和可扩展性。\n2. 允许更灵活有效地选用相应的平台和硬件系统，使之在处理负荷能力上与处理特性上分别适应于结构清晰的三层；并且这些平台和各个组成部分可以具有良好的可升级性和开放性。例如，最初用一台UNIX工作站作为服务器，将数据层和功能层都配置在这台服务器上。随着业务的发展，用户数和数据量逐渐增加，这时，就可以将UNIX工作站作为功能层的专用服务器，另外追加一台专用于数据层的服务器。若业务进一步扩大，用户数进一步增加，则可以继续增加功能层的服务器数目，用以分割数据库。清晰、合理地分割三层结构并使其独立，可以使系统构成的变更非常简单。因此，被分成三层的应用基本上不需要修正。\n3. 三层C/S结构中，应用的各层可以并行开发，各层也可以选择各自最适合的开发语言。使之能并行地而且是高效地进行开发，达到较高的性能价格比；对每一层的处理逻辑的开发和维护也会更容易些。\n4. 允许充分利用功能层有效地隔离开表示层与数据层，未授权的用户难以绕过功能层而利用数据库工具或黑客手段去非法地访问数据层，这就为严格的安全管理奠定了坚实的基础；整个系统的管理层次也更加合理和可控制。\n\n# B/S - 浏览/服务器风格\n\n是从三层C/S体系结构变化而来，但不是C/S的加强版，而是一种新的体系结构。\n\n组成：浏览器/Web服务器/数据库服务器\n\n## 优点\n\nB/S体系结构主要是利用不断成熟的WWW浏览器技术，结合浏览器的多种脚本语言，用通用浏览器就实现了原来需要复杂的专用软件才能实现的强大功能，并节约了开发成本。从某种程度上来说，B/S结构是一种全新的软件体系结构。\n\n在B/S结构中， 除了数据库服务器外，应用程序以网页形式存放于Web服务器上，用户运行某个应用程序时只须在客户端上的浏览器中输人相应的网址，调用Web服务器上的应用程序并对数据库进行操作完成相应的数据处理工作，最后将结果通过浏览器显示给用户。可以说，在B/S模式的计算机应用系统中，应用(程序)在一定程度上具有集中特征基于B/S体系结构的软件，系统安装、修改和维护全在服务器端解决。用户在使用系统时，仅需要一个浏览器就可运行全部的模块，真正达到了“零客户端”的功能，很容易在运行时自动升级。B/S体系结构还提供了异种机、异种网、异种应用服务的联机、联网、统一服务的最现实的开放性基础。\n\n## 缺点\n\n与C/S体系结构相比，B/S体系结构也有许多不足之处，例如：\n\n1. B/S体系结构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能。\n2. B/S体系结构的系统扩展能力差，安全性难以控制。\n3. 采用B/S体系结构的应用系统，在数据查询等响应速度上，要远远低于C/S体系结构\n4. B/S体系结构的数据提交一般以页面为单位，数据的动态交互性不强，不利于在线事务处理(OnLine Transaction Processing,OLTP)应用。\n\n因此，虽然B/S结构的计算机应用系统有如此多的优越性，但由于C/S结构的成熟性且C/S结构的计算机应用系统网络负载较小，因此，未来一段时间内，将是B/S结构和C/S结构共存的情况。但是，很显然，计算机应用系统计算模式的发展趋势是向B/S结构转变。\n\n# 正交软件体系结构\n\n什么是正交？在线性代数中表示内积为0。在软件中表示的是两者独立性高，相互的影响最小。相比于低耦合的概念，更加低耦合，甚至于零耦合。\n\n## 概念\n\n正交软件体系结构由组织层和线索的构件构成。层是由一组具有相同抽象级别的构件构成。线索是子系统的特例,它是由完成不同层次功能的构件组成(通过相互调用来关联),每一条线索完成整个系统中相对独立的一部分功能。每一条线索的实现与其他线索的实现无关或关联很少,在同一层中的构件之间是不存在相互调用的。\n\n如果线索是相互独立的,即不同线索中的构件之间没有相互调用,那么这个结构就是完全正交的。\n\n## 特征\n\n1. 正交软件体系结构由完成不同功能的n(n>1)个线索（子系统）组成；\n2. 系统具有m(m&gt;1)个不同抽象级别的层；\n3. 线索之间是相互独立的（正交的）;\n4. 系统有一个公共驱动层（一般为最高层）和公共数据结构（一般为最低层）。\n\n## 优点\n\n1. 结构清晰，易于理解\n2. 易修改，可维护性强\n3. 可移植性强，重用粒度大\n\n# 基于层次消息总线的体系结构风格（HMB）\n\n是个复合体系结构，用到了前面的6种经典体系结构风格，进行了一个组合。\n\n首先，它是个**分层系统**。\n\n其次，它用到了**C2风格**。通过连接件把若干构件绑定在一起，按照一组规则运行，是一组并行的构件网络。\n\n系统里的构件和连接件，都有一个顶部和底部。构件和构件之间的直接连接是不允许的，只能是构件的顶部连接到连接件的底部，或构件的底部连接到连接件的顶部。连接件可以和任何数目的其他构件连接。\n\n第三，用到了**数据抽象/面向对象**。连接的构件都是通过接口去进行连接的，构件的内部对于外部是不可见的。外部只能看到接口而看不到内部。\n\n## 流程\n\n1. HMB风格的构件接口是一种基于消息的互联接口，可以较好地支持体系结构设计。构件之间通过消息进行通讯，接口定义了构件发出和接收的消息集合。\n2. 当某个事件发生后，系统或构件发出相应的消息，消息总线负责把该消息传递到此消息感兴趣的构件。\n3. 按照响应方式的不同，消息可分为同步消息和异步消息。\n\n# 异构结构风格\n\n一句话：多采用了不同体系风格的优点，淡化了这些体系风格的缺点。\n\n内外有别：外网使用B/S，内网使用C/S。外部提供给用户B/S，适合处理简单的显示输出、交互少场景，而且软件升级时直接在web服务器升级即可。在内部多是对数据库进行修改，直接用二层C/S执行速度快。\n\n查改有别：维护和修改 - C/S结构；查询和浏览 - B/S结构。\n\n# 第8章 基于服务的体系结构（SOA）\n\nSOA是一种架构模型和一套设计方法学，其目的是最大限度地重用应用程序中立型的服务以提高IT适应性和效率。它可以根据需求通过网络对松散耦合的粗粒度应用组件(细粒度对应的是类、函数)进行分布式部署、组合和使用。\n\n服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。\n\nW3C将服务定义为: “服务提供者完成一组工作, 为服务使用者交付所需的最终结果。最终结果通常会使使用者的状态发生变化, 但也可能使提供者的状态改变, 或者双方都产生变化”。\n\nSOA不是一种语言, 也不是一种具体的技术而是种软件系统架构, 它尝试给出在特定环境下推荐采\n用的一种架构, 从这个角度上来说, 它更像一种模式。\n\nSOA是面向服务的体系结构，他实际上是组件的模型，把应用程序不同的功能单元可称作服务，可以通过定义服务与服务之间良好的接口和契约，很好地把它们联系起来。因为是一种松耦合的理念，是一种可以替代传统的面向对象模型的模型。但不是说没有面向对象了，单个服务内部仍需要用面向对象来设计。\n\n## SOA的特征\n\n1. **松散耦合**，服务是位置透明的\n2. **粗粒度服务**\n3. 服务是封装的，通过**标准化接口**交互，服务是自治的功能实体，自包含和模块化\n4. 服务的重用\n5. 服务的互操作性、兼容性\n\n## SOA的概念\n\nW3C：SOA是一种应用程序体系结构，在这种体系结构中，所有功能都定义为独立的服务，这些服务带有定义明确的可调用接口，能够以定义好的顺序调用这些服务来形成业务流程。\n\nService-architecture.com：服务是精确定义、封装完整、独立于其它服务所处环境和状态的函数。SO A本质上是服务的集合， 服务之间彼此通信，这种通信可能是简单的数据传送，也可能是两个或更多的服务协调进行某些活动。服务之间需要某些方法进行连接。\n\nGartner：SOA是一种C/S体系结构的软件设计方法，应用由服务和服务使用者组成， SO A与大多数通用的C/S体系结构模型不同之处， 在于它着重强调构件的松散耦合，并使用独立的标准接口。\n\n## SOA的关键技术\n\n![2022-06-19_221030](../../images/软件体系结构/soa-key-tech.png)\n\n## SOA的实现方法1 -WebService\n\n能够在一个分布式的计算环境中动态地描述、发布、发现和调用服务Web上的对象访问技术。\n\n在WebService的解决方案中，一共有三种工作角色，其中服务提供者和服务请求者是必需的，服务注册中心是一个可选的角色。它们之间的交互和操作构成了SOA的一种实现体系结构。\n\n![2022-06-19_221721](../../images/软件体系结构/webservice.png)\n\n1. 服务提供者。服务提供者是服务的所有者，该角色负责定义并实现服务，使用WSDL对服务进行详细、准确、规范的描述，并将该描述发布到服务注册中心，供服务请求者查找并绑定使用。\n2. 服务请求者。服务请求者是服务的使用者，虽然服务面向的是程序，但程序的最终使用者仍然是用户。从体系结构的角度看,服务请求者是查找、绑定并调用服务,或与服务进行交互的应用程序。服务请求者角色可以由浏览器来担当,由人或程序(例如,另外一个服务)来控制\n3. 服务注册中心。服务注册中心是连接服务提供者和服务请求者的纽带,服务提供者在此发布他们的服务描述,而服务请求者在服务注册中心查找他们需要的服务。不过,在某些情况下,服务注册中心是整个模型中的可选角色。例如,如果使用静态绑定的服务,服务提供者则可以把描述直接发送给服务请求者。\n\nWeb Service模型中的操作包括**发布、查找和绑定**，这些操作可以单次或反复出现。\n\n1. 发布。为了使用户能够访问服务，服务提供者需要发布服务描述，以便服务请求者可以查找它。\n2. 查找。在查找操作中,服务请求者直接检索服务描述或在服务注册中心查询所要求的服务类型。对服务请求者而言，可能会在生命周期的两个不同阶段中涉及查找操作,首先是在设计阶段，为了程序开发而查找服务的接口描述；其次是在运行阶段，为了调用而查找服务的位置描述。\n3. 绑定。在绑定操作中，服务请求者使用服务描述中的绑定细节来定位、联系并调用服务，从而在运行时与服务进行交互。绑定可以分为动态绑定和静态绑定。在动态绑定中服务请求者通过服务注册中心查找服务描述，并动态地与服务交互；在静态绑定中，服务请求者已经与服务提供者达成默契,通过本地文件或其他方式直接与服务进行绑定。\n\n在采用Web Service作为SOA的实现技术时,应用系统大致可以分为6个层次，分别是底层传输层、服务通信协议层、服务描述层、服务层、业务流程层和服务注册层。\n\n## SOA的实现方法2 - 服务注册表\n\n服务注册表（service registry）虽然也具有运行时的功能，但主要在SOA设计时使用。\n\n它提供一个策略执行点（Policy Enforcement Point，PEP)，在这个点上，服务可以在SOA中注册，从而可以被发现和使用。服务注册表可以包括有关服务和相关构件的配置、依从性和约束文件。从理论上来说，任何帮助服务注册、发现和查找服务合约、元数据和策略的信息库、数据库、目录或其他结点都可以被认为是一个注册表。大多数商用服务注册产品支持服务注册、服务位置和服务绑定功能。\n\n## SOA的实现方法3 - 企业服务总线（ESB）\n\nESB的概念是从SOA发展而来的，它是一种为进行连接服务提供的标准化的通信基础结构，基于开放的标准，为应用提供了一个可靠的、可度量的和高度安全的环境，并可帮助企业对业务流程进行设计和模拟，对每个业务流程实施控制和跟踪、分析并改进流程和性能。\n\n企业服务总线（Enterprise Service Bus，ESB） 它使用许多可能的消息传递协议来负责适当的控制、流甚至还可能是服务之间所有消息的传输。\n\nESB本身可以是单个引擎，甚至还可以是由许多同级和下级ESB组成分布式系统，这些ESB一起工作，以保持SOA系统的运行。\n\n## 服务描述语言 - WSDL\n\nWSDL是对服务进行描述的语言,它有一套基于XML的语法定义。WSDL描述的重点是服务, 它包含 Service Implementation Definition(服务实现定义)和 Service interface Definition(服务接口定义)\n\n## 统一描述、发现和集成协议（UDDI）\n\nUDDI是一种用于描述、发现、集成Web服务的技术，它是Web服务协议栈的一个重要部分。通过UDDI，企业可以根据自己的需要动态查找并使用Web服务，也可以将自己的Web服务动态地发布到UDDI注册中心，供其他用户使用。\n\n## 消息封装协议 - 简单对象访问协议 - SOAP\n\nSOAP是在分散或分布环境中以XML形式提供的一个简单、轻量的**交换结构化和类型信息**的机制。\n\nSOAP本身并没有定义任何应用程序语义（如编程模型或特定语义的实现），实际上，它通过提供一个有标准构件的包模型和在模块中编码数据的机制，定义了一个简单的表示应用程序语义的机制。这使SOAP能够被用于从消息传递到RPC的各种系统。","categories":["设计模式"]},{"title":"高级数据结构_2-3-4树","url":"/高级数据结构/高级数据结构_2-3-4树/","content":"# 内容\n\n# 2-3-4树\n\n在计算机科学中，2-3-4 树（也称为 2-4 树）是一种可用于实现字典的自平衡数据结构。 这些数字(2/3/4)表示的是一棵树中: 每个有1个/2个/3个元素的节点分别有2个/3个/4个子节点：\n\n- a 2-node has one data element, and if internal has two child nodes;\n  ![2-3-4-tree-2-node](../../images/高级数据结构_2-3-4树/2-3-4-tree-2-node.svg)\n- a 3-node has two data elements, and if internal has three child nodes;\n  ![2-3-4-tree-3-node](../../images/高级数据结构_2-3-4树/2-3-4-tree-3-node.svg)\n- a 4-node has three data elements, and if internal has four child nodes;\n  ![2-3-4-tree-4-node](../../images/高级数据结构_2-3-4树/2-3-4-tree-4-node.svg)\n\n## 与B树的关系\n\n1. 2-3-4树是4阶的B树；\n2. 和一般的B树一样，它们可以在$O(\\log n)$时间内搜索、插入和删除。 \n3. 2-3-4树的一个特性是所有外部节点都处于相同的深度。\n\n## 与红黑树的关系\n\n2-3-4树与红黑树同构，这意味着它们是等效的数据结构。换言之，对于每棵2-3-4树，至少存在一棵数据元素顺序相同的红黑树。此外，对2-3-4树的插入和删除操作会导致节点扩展、拆分和合并，相当于红黑树中的颜色翻转和旋转。\n\n红黑树的介绍通常首先介绍2-3-4树，因为它们在概念上更简单。然而，2-3-4 树在大多数编程语言中可能难以实现，因为树上的操作涉及大量特殊情况。 红黑树更容易实现，因此倾向于使用。\n\n# 性质\n\n1. 叶节点, 每个子节点都是2节点、3节点或4节点，父节点分别保存一个、两个或三个数据元素。\n2. 所有叶子都在相同的深度（底层）。\n3. 所有数据都按排序顺序保存。\n","categories":["高级数据结构","树"]},{"title":"高级数据结构_Bplus树","url":"/高级数据结构/高级数据结构_Bplus树/","content":"\n# B+\n\nB+树可以看作是B树的一种变形，在实现文件索引结构方面比B树使用得更普遍。\n\n## B+树与B树区别\n\nm阶`B+`树与m阶B树区别: \n\n1. 所有叶子节点包含全部关键字信息, 及指向含有这些关键字记录的指针, 且叶子节点中关键字进行有序链接; \n2. 非叶子节点相当于是叶子节点的索引, 叶子节点相当于是存储(关键字)数据的数据层; \n\n## B+树\n\n一棵m阶B+树可以定义如下：\n\n* 树中每个非叶结点最多有m棵子树;\n* 根结点（非叶结点）至少有2棵子树。除根结点外，其它的非叶结点至少有${\\lceil}m/2{\\rceil}$棵子树;有n棵子树的非叶结点有n-1个关键码。\n* 所有的叶结点都处于同一层次上，包含了全部关键码及指向相应数据对象存放地址的指针，且叶结点本身按关键码从小到大顺序链接;\n\n# B+树的优势\n\n## 读写代价更低\n\nB+树的磁盘读写代价更低, B+树的内部节点没有指向具体数据的指针, 因此内部节点相对B树更小, 如果把同一内部节点的关键字放在同一块磁盘中, 盘块所能容纳的关键字数量也就越多, 一次性读入内存中的需要查找的关键字也就越多, 相对IO读写次数减少, 性能更高;\n\n## 查询效率更加稳定\n\n非叶节点并不是最终指向文件内容的节点, 只作为叶子节点中关键字的索引; 所以任何关键字的查找必须走一条从根节点到叶子节点的路; 所有关键字查询的路径长度相同, 于是每一个数据的查询效率基本等同; \n\n## 统计数据手段更灵活\n\n由于B+树把数据都放到了最底一层, 可以很方便的把这些数据一个个链接起来形成链表, 加上B+树数据本来就是按序存放的, 这样的话有利于整表搜索或区间查找, 比B树的区间搜索快很多;\n\n## 举个例子\n\n假设磁盘中的一个盘块容纳16bytes, 而一个关键字2bytes, 一个关键字具体信息指针2bytes; 一棵9阶BTree的内部节点需要2个盘块; 而B+Tree内部节点只需要1个盘块, 当需要把内部节点读入内存的时候, B树就比B+树多一次盘块查找时间, 在磁盘中就是盘片旋转的时间; (这就是省了指针, 只存索引项的好处)\n\n# B+树节点结构\n\n```cpp\n#define M 5\n#define MAXSIZE (M-1)\n#define MINSIZE (M/2)\ntypedef char KeyType;\ntypedef struct Record {} Record;\ntypedef enum{BRCH = 1, LEAF = 2}NodeType;\ntypedef struct BNode\n{\n\tint num;\t\t\t\t\t//包含元素的个数\n    BNode * parent;\n\tNodeType utype;\t\t\t\t//LEAF, BRCH\n    KeyType key[M + 1];\n/*\n    //LEAF\n    Record * recptr[M + 1];\n    BNode * prev, *next;\n    //BRCH\n    BNode * sub[M + 1];\n*/\n    union\n    {\n        struct\t//LEAF\n        {\n        \tRecord * recptr[M + 1];\n            BNode * prev, * next;\n        };\n        //BRCH\n        BNode * sub[M + 1];\n    };\n    struct BNode* parent;\t\n\tElemType data[M + 1];\n\tstruct BNode* sub[M + 1];\n}BNode;\n```\n\nB+树和B树的分支结构一样，但叶子结构不一样。\n\n除了上述结构。还有一些规定\n\n```cpp\n#define BRCHMAX (M-1)\n#define BRCHMIN (M/2)\n#define LEAFMAX (M)\n#define LEAFMIN (M/2+1)\n```\n\n# B+树的Insert\n\n```cpp\n#include<iostream>\nusing namespace std;\n#define M 5\n#define BRCHMAX (M-1)\n#define BRCHMIN (M/2)\n#define LEAFMAX (M)\n#define LEAFMIN (M/2+1)\ntypedef char KeyType;\ntypedef struct Record {} Record;\ntypedef enum{BRCH = 1, LEAF = 2}NodeType;\ntypedef struct BNode\n{\n\tint num;\t\t\t\t\t//包含元素的个数\n    BNode * parent;\n\tNodeType utype;\t\t\t\t//LEAF, BRCH\n    KeyType key[M + 1];\n/*\n    //LEAF\n    Record * recptr[M + 1];\n    BNode * prev, *next;\n    //BRCH\n    BNode * sub[M + 1];\n*/\n    union\n    {\n        struct\t//LEAF\n        {\n        \tRecord * recptr[M + 1];\n            BNode * prev, * next;\n        };\n        //BRCH\n        BNode * sub[M + 1];\n    };\n    struct BNode* parent;\t\n\tElemType data[M + 1];\n\tstruct BNode* sub[M + 1];\n}BNode;\n\nBNode* Buynode()\n{\n\tBNode* s = (BNode*)malloc(sizeof(BNode));\n\tif (nullptr == s)exit(1);\n\tmemset(s, 0, sizeof(BNode));\n\treturn s;\n}\nBNode* BuyLeaf()\n{\n    BNode * s = Buynode();\n    s->parent = nullptr;\n    s->utype = LEAF;\n    return s;\n}\nvoid Init_BTree(BTree& tree)\n{\n\ttree.root = nullptr;\n    tree.first = nullptr;\n\ttree.cursize = 0;\n}\nResult FindRoot(BNode * ptr, KeyType kx)\n{\n    Result res = {nullptr, -1, false};\n    BNode * p = ptr;\n    while(p!=nullptr&&p->utype==BRCH)\n    {\n        p->key[0] = kx;\n        int i = p->num;\n        while(kx < p->key[i]) --i;\n        p = p->sub[i];\n    }\n    res = FindLeaf(p, kx);\n    return res;\n}\nResult FindLeaf(BNode * ptr, KeyType kx)\n{\n    Result res = {nullptr, -1, false};\n    BNode * p = ptr;\n    while(p!=nullptr&&p->next!=nullptr && kx > p->key[p->num -1])\n    {\n        p = p->next;\n    }\n    if(p == nullptr)return res;\n    int pos = p->num -1;\n    while(pos >= 0 && kx < p->key[pos])\n    {\n        --pos;\n    }\n    res.pnode = p;\n    res.index = pos;\n    if(pos < 0 && p->prev != nullptr)\n    {\n        res.pnode = p->prev;\n        res.index = p->prev->num -1;\n    }else if(pos >= 0 && kx == p->key[pos])\n    {\n        res.tag = true;\n    }\n    return res;\n}\nResult FindKey(BTree& tree, KeyType kx)\n{\n\tResult res = { nullptr, -1,false };\n\tstruct BNode* ptr = tree.root;\n\twhile (ptr != nullptr)\n\t{\n\t\tptr->data[0].key = kx;\n\t\tint i = ptr->num;\n\t\twhile (i>=0 && ptr->data[i].key)\n\t\t{\n\t\t\t--i;\n\t\t}\n\t\tres.pnode = ptr;\n\t\tres.index = i;\n\t\tif (i > 0 && kx == ptr->data[i].key) \n\t\t{ \n\t\t\tres.tag = true;\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr->sub[i];\n\t}\n\treturn res;\n}\nBNode* MakeRoot(const KeyType kx, BNode* left, BNode* right)\n{\n\tBNode* s = Buynode();\n\ts->num = 1;\n\ts->parent = nullptr;\n\ts->key[1] = kx;\t\t//\n\ts->sub[0] = left;\n\tif (left != nullptr)left->parent = s;\n\ts->sub[1] = right;\n\tif (right != nullptr)right->parent = s;\n\treturn s;\n}\nvoid Insert_Item(BNode* ptr, int pos, const ElemType& item, BNode* right)\n{\n\tfor (int i = ptr->num; i > pos; --i)\n\t{\n\t\tptr->data[i + 1] = ptr->data[i];\n\t\tptr->sub[i + 1] = ptr->sub[i];\n\t}\n\tptr->data[pos + 1] = item;\t//?\n\tptr->sub[pos + 1] = right;\t//?\n\tptr->num += 1;\n}\nElemType Move_Item(BNode* s, BNode* ptr, int pos)\n{\n\tfor (int i = 0, j = pos + 1; j <= ptr->num; ++i, ++j)\n\t{\n\t\ts->data[i] = ptr->data[j];\n\t\ts->sub[i] = ptr->sub[j];\n\t\tif (s->sub[i] != nullptr)\n\t\t{\n\t\t\ts->sub[i]->parent = s;\n\t\t}\n\t}\n\ts->num = MINSIZE;\n\tptr->num = MINSIZE;\n\ts->parent = ptr->parent;\n\treturn s->data[0];\n}\nBNode* Splice(BNode* ptr)\n{\n\tBNode* s = Buynode();\n\tElemType item = Move_Item(s, ptr, MINSIZE);\n\tif (ptr->parent == nullptr)\n\t{\n\t\treturn MakeRoot(item, ptr, s);\n\t}\n\tBNode* pa = ptr->parent;\n\tint pos = pa->num;\n\tpa->data[0] = item;\n\twhile (pos > 0 && item.key < pa->data[pos].key) { --pos; }\n\tInsert_Item(pa, pos, item, s);\n\tif (pa->num > MAXSIZE)\n\t{\n\t\treturn Splice(pa);\n\t}\n\telse\n\t{\n\t\treturn nullptr;\n\t}\n}\nvoid Insert_Leaf_Item(BNode * ptr, int pos, KeyType kx, Record *rec)\n{\n    for(int i = ptr->num-1; i>pos; --i)\n    {\n        ptr->key[i+1] = ptr->key[i];\n        ptr->recptr[i+1] = ptr->recptr[i];\n    }\n    ptr->key[pos+1] = kx;\n    ptr->recptr[pos+1] = rec;\n    ptr->num+=1;\n}\nKeyType Move_Leaf_Item(BNode *s, BNode* ptr)\n{\n    for(int i = 0;j = LEAFMIN;j<ptr->num;++i,++j)\n    {\n        s->key[i] = key[j];\n        s->recptr[i] = ptr->recptr[j];\n    }\n    s->num = LEAFMIN;\n    ptr->num = LEAFMIN;\n    s->parent = ptr->parent;\n    s->next = ptr->next;\n    s->prev = ptr;\n    ptr->next = s;\n    if(s->next != nullptr)\n    {\n        s->next->prev = s;\n    }\n    return s->key[0];\n}\nBNode* Splice_Leaf(BNode * ptr)\n{\n    BNode * s = BuyLeaf();\n    KeyType kx = Move_Leaf_Item(s, ptr);\n    if(ptr->parent == nullptr)\n    {\n        return MakeRoot(kx, ptr, s);\n    }\n    //\n}\nbool Insert(BTree& tree, KeyType kx, Record * rec)\n{\n\tif (tree.root == nullptr)\n\t{\n\t\tBNode *s = BuyLeaf();\n\t\ts->key[0] = kx;\n        s->recptr[0] = rec;\n        s->num = 1;\n        tree.root = tree.first = s;\n        return true;\n\t}\n\t//不为空\n\tResult resr = FindRoot(tree.root, kx);\n\tResult resf = FindLeaf(tree.first, kx);\n\tif(resf.pnode == nullptr){cout << \"BTree struct err\"<<endl;return false;}\n    if (resf.tag){cout << \"exist\"<<endl;return false;}\n\t//在res.pnode处插入\n\tBNode* ptr = resf.pnode;\n\tint pos = resf.index;\n\tInsert_Leaf_Item(ptr, pos, kx, rec);\n\t\n\tif (ptr->num > LEAFMAX)\n\t{\n\t\tBNode* newroot = Splice_Leaf(ptr);\t//分裂\n\t\tif (newroot != nullptr)\n\t\t{\n\t\t\ttree.root = newroot;\n\t\t}\n\t}\n\ttree.cursize += 1;\n\treturn true;\n}\n\nint main()\n{\n\tBTree myt;\n\tInit_BTree(myt);\n\tchar ch[] = { \"qwertyuiopasdfghjklzxcvbnm\" };\n\tint i = 0;\n\twhile (ch[i] != '\\0')\n\t{\n\t\tElemType item = { ch[i],nullptr };\n\t\tcout << Insert(myt, item);\n\t\ti++;\n\t}\n\tcout << endl;\n}\n```\n\n# 总结\n\nB树的每一个节点, 存了关键字和对应的数据地址, 而B+树的非叶子节点只存关键字, 不存数据地址。因此B+树的每一个非叶子节点存储的关键字是远远多于B树的; B+树的叶子节点存放关键字和数据, 因此从树的高度上来说B+树的高度要小于B树, 使用的磁盘IO次数少, 因此查询会更快一些。\n\n由于B树每个节点都存储关键字和数据, 因此离根节点近的数据, 查询的就快, 离根节点远的数据, 查询的就慢; B+树所有的数据都存在叶子节点上, 因此在B+树上搜索关键字, 找到对应数据的时间是比较平均的, 没有快慢之分。\n\n如果在B树上做区间查找, 遍历的节点是非常多的; B+树所有叶子节点被连接成了有序链表结构, 因此做整表遍历和区间查找是非常容易的。","categories":["高级数据结构","树"]},{"title":"高级数据结构_Bstar树","url":"/高级数据结构/高级数据结构_Bstar树/","content":"# `B*`\n\n是B+树的变种, 在B+树的非根和非叶子结点再增加指向兄弟节点的指针。\n\n# 定义\n\n`B*`树定义了非叶子节点关键字个数至少为$(2/3)*M$, 即块的最低使用率为$2/3$, 代替了B+树的$1/2$; \n\n# `B*`和`B+`节点分裂的对比\n\n## B+\n\n当一个结点满时，分配一个新的结点，并将原结点中$1/2$的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针; \n\n## `B*`\n\n`B*`树的分裂当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制$1/3$的数据到新结点，最后在父结点增加新结点的指针;\n\n所以，`B*`树分配新结点的概率比`B+`树要低，空间使用率更高，在`B+`树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从$1/2$提高到$2/3$。","categories":["高级数据结构","树"]},{"title":"32位和64位区别","url":"/计算机知识体系/32位和64位区别/","content":"# 范彬\n\n链接：https://www.zhihu.com/question/23408154/answer/24499675\n\n64bit软件和32bit软件最大的区别是64bit的软件可以同时操作大于4GB的内存。注意这里的内存指的是地址空间，而不是物理内存。比如现在有一个10GB的数据库需要进行排序。64bit的软件可以malloc一个10GB的空间把整个数据库“放进”内存然后使用任意经典排序算法，而32bit的软件在malloc时就会崩溃（out-of-memory）。所以32位软件的程序员只能使用复杂的算法显式的分块读入，局部排序，写回数据库，然后重复。这样不仅程序复杂难写，程序员swap内存和文件的算法效率可能也不如OS自动处理来的高效。\n\n另一方面，64bit软件巨大的内存空间也可能加速物理内存的消耗，增加寻址的开销，因此未必总是能够提高性能。\n\n当然最终系统的效率还是取决于物理内存的大小，64bit只是解决了地址空间的瓶颈。\n\n# 补佳林的回答\n\n64 位软件和 32 位有什么具体区别？ - 补佳林的回答 - 知乎 https://www.zhihu.com/question/23408154/answer/24537270\n\n我来说个不好的地方，64位下指针变成8字节，很多c结构体占用空间加大，相当于cpu的缓存变小了。\n\n# gggxxx\n\n链接：https://www.zhihu.com/question/23408154/answer/24527239\n\n除了内存访问更重要的还有64位指令集运算。理论上64位运算强于32位运算，但是这依赖于代码优化。\n\n对普通用户来说有2点。\n\n1. 现在主流的比较新的桌面操作系统都是同时兼容64位程序和32位程序，包括ios也是同时兼容32位和64位。也就是说，用户不管安装32位还是64位程序都没有问题。\n\n2. 软件编译成64位后并不一定比32位程序运行速度快，很多时候64位程序都慢于32位程序。事实上很多开发者把程序从32位转化成64位，只是做兼容64位而已，根本没有针对64位特性做优化。\n\n很多流行软件的32位版本其实更加稳定和速度快。\n\n# 匿名用户\n\n链接：https://www.zhihu.com/question/23408154/answer/30793420\n\n多少位是指cpu的寄存器宽度不同，比如16位通用寄存器有一个叫ax，这意味着ax寄存器能存储16bit数据, 在32位中这个寄存器是eax，能存储32bit数据。64位中叫rax。\n\n寻址能力是指cpu寻址总线的宽度。比如16位的x86的u寻址能力是20位，因为寄存器只有16位，所以用seg x16 + offset的方式表示，这就是教科书上所说的逻辑地址。实际上逻辑地址可能产生21位的地址，但是因为寻址总线的宽度只有20所以溢出的一位都会被抛弃。在计算机开机的过程中，bootloader就会读写keyboard controller的60和64端口判断是否开启大于20位的寻址模式。\n\n# 周全\n\n64 位软件和 32 位有什么具体区别？ - 周全的回答 - 知乎 https://www.zhihu.com/question/23408154/answer/24542634\n\n1、对os来说，64位和32位指虚拟地址空间，32位最大4GB，64位理论上16TB，且目前有16TB的\n\n2、对硬件来说，64位和32位指数据宽度，64位一次取8字节，32取4字节\n\n3、对应用程序来说，指使用的指令宽度，基于OS和硬件\n","categories":["操作系统","计算机知识体系"]},{"title":"MySQL数据库连接池","url":"/项目/MySQL数据库连接池/","content":"\n# 内容\n\nC++实现的小型项目, MySQL数据库连接池, 属于常用组件;\n\n约400到500行代码, 代码不多, 麻雀虽小, 五脏俱全: \n\n1. 涉及到数据库编程;\n2. 单例模式\n3. queue队列容器\n4. `C++11`多线程编程, 线程互斥, 线程同步通信, `unique_lock`\n5. 基于CAS的原子类型\n6. 智能指针`shared_ptr`\n7. lambda表达式\n8. 生产者-消费者线程模型\n\n# 项目背景\n\n为了提高MySQL数据库（需要特别注意的, 它是基于C/S设计的）的访问瓶颈，除了在服务器端增加缓存服务器缓存常用的数据之外（例如Redis），还可以增加连接池，来提高MySQL Server的访问效率，在高并发情况下，大量的TCP三次握手、MySQL Server连接认证、MySQL Server关闭连接回收资源和TCP四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。\n\n在市场上比较流行的连接池包括阿里的druid，c3p0以及apache dbcp连接池，它们对于短时间内大量的数据库增删改查操作性能的提升是很明显的，但是它们全部由Java实现。那么本项目就是为了在`C/C++`语言下，提供MySQL Server的访问效率，实现基于`C++`代码的数据库连接池模块。\n\n# 连接池功能介绍\n\n该项目是基于C++语言实现的连接池，主要实现若干个通用基础功能。\n\n连接池一般包含了数据库连接所用的ip地址、port端口号、用户名和密码以及其它的性能参数，例如初\n始连接量，最大连接量，最大空闲时间、连接超时时间等;\n\n1. **初始连接量(initSize)**\n    1. 表示连接池事先会和MySQL Server创建initSize个数的connection连接;\n    2. 当应用发起MySQL访问时，不用再创建和MySQL Server新的连接，直接从连接池中获取一个可用的连接就可以;\n    3. 使用完成后，并不去释放connection，而是把当前connection再归还到连接池当中。\n2. **最大连接量(maxSize)**\n    1. 总的连接数量上限是maxSize;\n    2. 当并发访问MySQL Server的请求增多时，初始连接量已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用;\n    3. 但是，不能无限制的创建连接，因为每一个连接都会占用一个socket资源，一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的socket资源，那么服务器就不能接收太多的客户端请求了;\n    4. 当这些连接使用完成后，再次归还到连接池当中来维护。\n3. **最大空闲时间(maxIdleTime)**\n    1. 当访问MySQL的并发请求多了以后，连接池里面的连接数量会动态增加，上限是maxSize个;\n    2. 当这些连接用完再次归还到连接池当中;\n    3. 如果在指定的maxIdleTime里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接量initSize个连接就可以了。\n4. **连接超时时间(connectionTimeout)**\n    1. 当MySQL的并发请求量过大，连接池中的连接数量已经到达maxSize了，而此时没有空闲的连接可供使用，那么此时应用从连接池获取连接需要通过阻塞的方式获取连接;\n    2. 阻塞时间如果超过connectionTimeout时间，那么获取连接失败，无法访问数据库;\n\n该项目主要实现上述的连接池四大功能，其余连接池更多的扩展功能，可以在该框架的基础上进行很好的拓展;\n\n# 设计思路\n\n1. 需要抽象出两个类\n    1. ConnectionPool - 连接池\n    2. Connection - 封装数据库操作, 增删改查\n2. 连接池只需要一个实例, 则ConnectionPool设计为单例模式\n3. ConnectionPool需要提供获取MySQL连接Connection的接口\n4. 空闲连接Connection全部维护在一个Connection队列中, 使用互斥锁保证队列的线程安全\n5. 如果在获取连接时发现空闲连接队列空, 则需要动态创建新连接, 但是上限数量是maxSize, 在创建新连接的过程中, 消费者线程需要**忙等待**connectionTimeout时长, 直到队列中不空; 若时长一到仍获取未果则认定为连接失败; 可以使用带超时时间的mutex互斥锁来实现连接超时时间;\n6. 使用量下降后, 如果队列中的空闲连接保持空闲超过maxIdleTime, 需要释放连接, 直到减少到initSize个连接; 这个释放的过程需要放在独立线程做 - **定时线程**, 清理队列多余的空闲连接;\n7. 用户获取的连接用`shared_ptr`智能指针来管理，用lambda表达式定制连接释放的功能（不真正释放连接，而是把连接归还到连接池中）\n8. 连接的生产和连接的消费采用`生产者-消费者`线程模型来设计，使用了线程间的同步通信机制条件变量和互斥锁;\n\n# MySQL数据库编程\n\n## 公共代码\n简易日志工具 - 向标准输出设备输出\n\n```cpp\n#include<iostream>\n#define LOG(str)                                            \\\n    do {                                                    \\\n    std::cout << __FILE__ << \":\" << __LINE__ << \":\"         \\\n              << __TIMESTAMP__ << \":\" << str << std::endl;  \\\n    } while(0)\n```\n\n## MySQLConnection - 封装MySQL数据库操作\n\n### 成员变量\n\n`MYSQL *m_conn` - 记录MYSQL类型的指针, 以获取这个mysql连接\n\n```cpp\nprivate:\n    MYSQL *m_conn;\n```\n\n### 成员函数\n\n1. 构造/析构 - 初始化/释放数据库连接\n\n```cpp\npublic:\n    /* 初始化数据库连接 */\n    MySQLConnection();\n    /* 释放数据库连接资源 */\n    ~MySQLConnection();\n```\n\n2. getConnection - 获取连接, 即获取成员`m_conn`\n\n```cpp\npublic:\n    /* 获取连接 */\n    MYSQL * getConnection();\n```\n\n3. connect - 连接数据库, 返回值为bool, 说明连接成功与否\n\n```cpp\npublic:\n    /* 连接数据库 */\n    bool connect(std::string ip, unsigned short port,\n                std::string user, std::string password, std::string dbname);\n```\n\n4. query - 查询操作, 参数是string类型的sql语句, 返回值为`MYSQL_RES`, 即MySQL结果集类型\n\n```cpp\npublic:\n    /* 查询操作 */\n    MYSQL_RES * query(std::string sql);\n```\n\n5. update - 更新操作, 参数是string类型的sql语句, 返回值为bool, 说明更新成功与否\n\n```cpp\npublic:\n    /* 更新操作 */\n    bool update(std::string sql);\n```\n\n### 代码实现\n\n1. 构造 - 调用`mysql_init`, 实际上只是对mysql连接进行空间资源的开辟, 返回一个指针赋给`m_conn`成员, 没有真正连接, 因此传入nullptr\n\n```cpp\n/* 初始化数据库连接 */\nMySQLConnection::MySQLConnection()\n{\n    m_conn = mysql_init(nullptr);\n}\n```\n\n2. 析构 - 调用`mysql_close(m_conn)`, 对MySQL连接资源进行释放\n\n```cpp\n/* 释放数据库连接资源 */\nMySQLConnection::~MySQLConnection()\n{\n    if(m_conn != nullptr)\n    {\n       mysql_close(m_conn);\n    }\n}\n```\n\n3. connect - 连接数据库, 内部调用`mysql_real_connect`, 传入`m_conn`, 以及server ip地址, user号, 密码, 要连接的数据库name, 服务器端口;\n\n```cpp\n/* 连接数据库 */\nbool MySQLConnection::connect(std::string ip, unsigned short port,\n                              std::string user, std::string password,\n                              std::string dbname)\n{\n    MYSQL *p = mysql_real_connect(m_conn, ip.c_str(), user.c_str(),\n                                  password.c_str(), dbname.c_str(),\n                                  port, nullptr, 0);\n    if(p != nullptr)\n    {\n        /**\n         * C/C++代码默认的编码字符是ASCII, \n         * 如果不设置, 则从MySQL上拉下来的中文无法正常显示\n         */\n        mysql_query(m_conn, \"set name gbk\");\n        LOG(\"connect mysql success!\");\n    }\n    else\n    {\n       LOG(\"connect mysql failed!\");\n    }\n    return p != nullptr;\n}\n```\n\n4. query - 查询操作\n    1. 内部调用`mysql_query`, 传入`m_conn`, `sql-string`的C风格字符串首址;\n        1. `mysql_query`的返回值:\n            1. 如果查询成功，返回0;\n            2. 如果出现错误，返回非0值。\n    2. 返回值需要调用`mysql_use_result(m_conn)`获取结果集, 再return;\n\n```cpp\n/* 查询操作 */\nMYSQL_RES * MySQLConnection::query(std::string sql)\n{\n    if(mysql_query(m_conn, sql.c_str()) == 0)\n    {\n        LOG(\"select failed: \" + sql);\n        return nullptr;\n    }\n    return mysql_use_result(m_conn);\n}\n```\n\n7. update - 更新操作\n    1. 内部调用`mysql_query`, 传入`m_conn`, `sql-string`的c风格字符串首址;\n    2. 判断`mysql_query`的返回值, 若为非0则更新失败; 若为0则更新成功;\n\n```cpp\n/* 更新操作 */\nbool MySQLConnection::update(std::string sql)\n{\n    if(mysql_query(m_conn, sql.c_str()) == 0)\n    {\n        LOG(\"update failed: \" + sql);\n        return false;\n    }\n    return true;\n}\n```\n\n# 连接池\n\n## MySQLConnectionPool\n\n### 成员变量\n\n### 成员函数\ngetConnection\n```cpp\n/* 获取连接 */\nMYSQL * MySQLConnection::getConnection()\n{\n    return m_conn;\n}\n```\n### 代码实现\n# 压力测试\n\n建个表\n\n```mysql\nCREATE TABLE user(\n    id INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    name VARCHAR(50) NOT NULL,\n    age TINYINT NOT NULL,\n    sex ENUM('male', 'female') NOT NULL\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\n```\n","categories":["项目","数据库","连接池"]},{"title":"重写muduo库","url":"/项目-muduo/重写muduo库/","content":"# 内容\n1. muduo库的主要板块\n    1. base：公共的代码文件\n    2. net：网络相关的，如TcpServer、EventLoop、poller、protobuf、protorpc等等\n        1. 我们主要写网络模块\n# 目标\n主要编写muduo库的网络模块代码，以及改进muduo库在使用上的不便。\nmuduo库原本属于静态库，且需要依赖boost库。我们改进它，使他与原生C++标准库结合，并把它生成为`.so`动态库。\n# muduo库核心组件职责与关系\n## Reactor模式的核心\n1. EventLoop事件循环\n    1. 职责：每个线程一个EventLoop。不断地”询问 - 处理“事件\n    2. 关系：\n        1. 拥有一个`Poller`：EventLoop通过Poller来获取当前活跃的事件\n        2. 拥有一个`Channel`：EventLoop管理所有在其上注册的Channel\n2. Poller：I/O多路复用接口\n    1. 职责：阻塞地等待文件描述符上的事件，并将活跃的事件返回给EventLoop\n    2. 具体实现是`EPollPoller`。是Linux下基于epoll的具体实现。通过`epoll_wait`返回活跃的事件。\n3. Channel：通道\n    1. 职责：是事件分发器。每个Channel负责一个文件描述符。\n    2. 内部保存了该fd关注的事件，以及对应的回调函数\n    3. 关系：\n        1. 是Poller和回调之间的桥梁。Poller返回一个事件，EventLoop找到对应的Channel，调用Channel的`handleEvent()`方法\n## 接受新连接：Acceptor\n1. 职责：Acceptor是一个特殊的Channel。专门负责处理监听套接字（listening socket）上的可读事件，即新连接。\n2. 关系：\n    1. 继承自Channel。同样需要向EventLoop注册。\n    2. 被TcpServer拥有：TcpServer在初始化时会创建Acceptor\n    3. 持有newConnectionCallback：当有新连接到来时，最终会调用TcpServer预先设置好的回调函数\n## 表示连接：TcpConnection\n1. 职责：代表了一个已建立的TCP连接。整个连接的生命周期（建立、断开、收发数据）都由该对象管理。\n2. 关系：\n    1. 每个TcpConnection对象都有一个自己的Channel。用于监控其描述符上的事件。\n    2. 被TcpServer管理：记录在TcpServer的map表中。\n    3. 持有各种用户回调：如连接建立回调`ConnectionCallback`，消息到达回调`MessageCallback`。这些是由用户通过`TcpServer`设置的。\n    4. 隶属于某个EventLoop。每个TcpConnection对象都只属于一个特定的`EventLoop`线程。其所有IO操作都在这个线程中进行。保证线程安全。\n## 服务器门面：TcpServer\n1. 职责：提供给用户使用的、易于理解的**服务器类**。用户只需关注其提供的几个回调函数（如连接回调、消息回调）即可编写网络程序。\n2. 关系：\n    - **拥有一个 `Acceptor`**：用于接受新连接。\n    - **拥有一个 `TcpConnection` 的映射表**：管理所有活跃的连接。\n    - **拥有一个 `EventLoopThreadPool`**：管理线程池。\n    - **设置回调**：用户通过 `TcpServer` 设置的各种回调（`onConnection`, `onMessage`），最终会“传递”给每一个新创建的 `TcpConnection` 对象。\n## 线程模型：`EventLoopThread`和`EventLoopThreadPool`\n- **`EventLoopThread` (IO 线程)：\n    - **职责**：封装了一个线程（`std::thread`），该线程的**唯一工作**就是运行一个 `EventLoop::loop()`。**“one loop per thread”** 的理念在此体现。\n    - **关系**：它**创建并拥有**一个 `EventLoop` 对象（在其内部线程中）。\n- **`EventLoopThreadPool` (线程池)：\n    - **职责**：管理多个 `EventLoopThread`，即管理一个 `EventLoop` 池子。它提供了一种轮询（round-robin）算法来为新的 `TcpConnection` 分配一个 `EventLoop`。\n    - **关系**：\n        - **被 `TcpServer` 所拥有**：`TcpServer` 通过线程池来实现多线程 Reactor。\n        - **拥有多个 `EventLoopThread`**：管理着多个 IO 线程。\n        - **为 `Acceptor` 提供 `getNextLoop()`**：当 `Acceptor` 接受到一个新连接时，它会从线程池中取出下一个 `EventLoop`，将这个新连接分配给这个 `EventLoop` 来监控和处理。\n\n# cmake\n```cmake\ncmake_minimum_required(VERSION 2.5)\nproject(mymuduo)\n\n#mymuduo 最终编译成so动态库，设置动态库的路径\nset(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)#注意不是OUTPUT_DIRECTORY.这两者有区别\n#设置为调试模式 以及 声明C++11语言标准\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g -std=c++11 -fPIC\")#在较新的编译器后需要加-fPIC，以示生成的是动态库\n#定义参与编译的源文件 起一个别名\naux_source_directory(. SRC_LIST)\n#编译生成动态库mymuduo\nadd_library(mymuduo SHARED ${SRC_LIST})\n```\n# 辅助类\n## noncopyable\n```cpp\n// noncopyable.h\n#pragma once\n/**\n * noncopyable 被继承以后，\n * 派生类对象无法拷贝构造、相互赋值。\n * 无参构造、析构是默认处理。\n */\nclass noncopyable\n{\npublic:\n    noncopyable(const noncopyable&) = delete;\n    noncopyable & operator=(const noncopyable &) = delete;\nprotected:\n    noncopyable() = default;\n    ~noncopyable() = default;\n};\n```\n## copyable\n\n```cpp\nclass copyable\n{\nprotected:\n    copyable() = default;\n    ~copyable() = default;\n};\n```\n# TcpServer概览\n需要封装以下属性：\n1. `EventLoop`对象指针：多路分发器，相当于epoll\n2. `InetAddress`：打包IP地址和端口号\n## InetAddress\n1. 允许拷贝\n2. 成员变量是`sockaddr_in m_addr`，也可选择支持IPv6的`sockaddr_in6 m_addr6`。可用联合体表示。在本项目中，只使用IPv4的`m_addr`。\n\n```cpp\n#include<netinet/in.h>\t\t//sockaddr_in / sockaddr_in6都在此文件下定义\nunion\n{\n    struct sockaddr_in  m_addr;\n    struct sockaddr_in6 m_addr6;\n};\n```\n## EventLoop概览\n1. 不允许拷贝\n2. 主要包含的成员\n    1. poller（相当于epoll），存储了一个unorderedMap，有sockfd及其上面绑定的事件\n    2. channel，属性有fd、events、revents等等\n\nEventLoop就是要完成事件循环，事件循环最重要的几个动作：epoll（**由poller负责**）、epoll监听的fd及感兴趣的事件、实际`epoll_wait`后发生的事件。\n这些sockfd、感兴趣的事件、发生的事件都**记录在channel中**。\n\n要写EventLoop就要理清楚EventLoop、Channel、Poller之间的关系。Reactor模型中，这三个组件整体对应着Demultiplex。\n## Channel\n通道，封装了sockfd和其感兴趣的event，如EPOLLIN、EPOLLOUT事件。还绑定了poller返回的具体事件。\n### 公有别名\n定义通用事件回调函数、只读事件回调函数的函数对象类型别名。\n```cpp\nclass Channel : noncopyable\n{\npublic:\n    using EventCallback = std::function<void()>;\n    using ReadEventCallback = std::function<void(Timestamp)>;\n}\n```\n### 成员函数\n#### 构造 / 析构函数\n```cpp\npublic:\n    Channel(EventLoop * loop, int fd);\n    ~Channel();\n```\n#### `handleEvent`\nfd得到poller的通知后，处理事件\n```cpp\npublic:\n    void handleEvent(Timestamp receiveTime);\n```\n#### `setXxxCallback(EventCallback cb)`\n对外提供的设置回调函数对象的接口\n```cpp\npublic:\n    void setReadCallback(ReadEventCallback cb)\n    {\n        m_readCallback = std::move(cb);\n    }\n    void setWriteCallback(EventCallback cb)\n    {\n        m_writeCallback = std::move(cb);\n    }\n    void setCloseCallback(EventCallback cb)\n    {\n        m_closeCallback = std::move(cb);\n    }\n    void setErrorCallback(EventCallback cb)\n    {\n        m_errorCallback = std::move(cb);\n    }\n```\n#### `void tie(const std::shared_ptr<void>&)`\n防止channel被手动remove后，还在执行回调操作\n```cpp\npublic:\n    void tie(const std::shared_ptr<void>&);\n```\n#### `fd`、`events`、`revents`相关\n1. `int fd()`\n2. `int events()`\n3. `void set_revents(int revt)`：向poller提供的设置revents的接口\n\n```cpp\npublic:\n    int fd() const { return m_fd; }\n    int events() const { return m_events; }\n    int set_revents(int revt)\n    {\n        m_revents = revt;\n    }\n```\n#### 判断函数：判断有没有注册事件等等\n```cpp\npublic:\n    bool isNoneEvent() const\n    {\n        return m_events == kNoneEvent;\n    }\n    bool isWriting() const\n    {\n        return m_events & kWriteEvent;\n    }\n    bool isReading() const\n    {\n        return m_events & kReadEvent;\n    }\n```\n#### 使能、使不能函数\n设置fd相应的事件状态\n对`m_events`进行位操作之后调用`update()`，即`epoll_ctl`。\n```cpp\npublic:\n    void enableReading()\n    {\n        m_events |= kReadEvent;\n        update();\n    }\n    void disableReading()\n    {\n        m_events &= ~kReadEvent;\n        update();\n    }\n    void enableWriting()\n    {\n        m_events |= kWriteEvent;\n        update();\n    }\n    void disableWriting()\n    {\n        m_events &= ~kWriteEvent;\n    }\n    void disableAll()\n    {\n        m_events = kNoneEvent;\n        update();\n    }\n```\n#### 与EventLoop相关\n获取所属的Loop\n```cpp\npublic:\n    EventLoop * ownerLoop() {return m_loop;}\n```\n#### 删除：remove()\n```cpp\npublic:\n    void remove();\n```\n#### update()：相当于调用`epoll_ctl`\n```cpp\nprivate:\n    void update();\n```\n#### handleEventWithGuard\n受保护地处理事件\n```cpp\nprivate:\n    void HandleEventWithGuard(Timestamp receiveTime);\n```\n#### for poller的index\n```cpp\npublic:\n    int index() {return m_index;}\n    void set_index(int idx) {m_index = idx;}\n```\n### 成员变量\n1. `kXxxEvent`：以下三个变量描述当前fd的状态，没有感兴趣的事件or对读事件感兴趣or对写事件感兴趣？\n\n```cpp\nprivate:\n    static const int kNoneEvent;\n    static const int kReadEvent;\n    static const int kWriteEvent;\n```\n\n2. `m_xxxCallback`：四个函数对象，可以绑定外部传入的相关操作。因为channel知道发生了哪些事情（revents记录），所以channel负责调用具体事件的回调函数。\n\n```cpp\nprivate:\n    ReadEventCallback m_readCallback;\n    EventCallback\t  m_writeCallback;\n    EventCallback\t  m_closeCallback;\n    EventCallback\t  m_errorCallback;\n```\n\n3. `EventLoop *m_loop`：事件循环\n4. `m_fd`：fd，即Poller监听的对象\n5. `m_events`：fd感兴趣的事件注册信息\n6. `m_revents`：Poller操作的fd上具体发生的事件\n7. `m_index`：？\n8. `std::weak_ptr<void> m_tie`：防止手动调用remove channel后仍使用此channel，用于监听跨线程的对象生存状态。\n    1. `shared_ptr`和`weak_ptr`配合使用可以发挥两个能力：\n        1. 解决shread_ptr循环引用问题\n        2. weak_ptr在多线程程序中可监听资源的生存状态，方法是尝试提升为强指针，若提升成功，则可以访问；若提升失败说明则资源被释放掉了。\n    2. tie的意思是绑定，那么m_tie要和谁绑定呢？——自己。\n    3. 绑定自己的工具还可以用另一个工具，`shared_from_this`，可以尝试得到当前对象的强智能指针。\n9. `bool m_tied`：配合`m_tie`使用\n## Poller\n### 成员变量\n成员变量中包含一个存储`<int, Channel*>`的map。\n\n>poller监听的channel从何而来？EventLoop中有ChannelList以及Poller，则poller监听的肯定是EventLoop中所保存的channel。即这些channel在poller中也被保存了。\n\n```cpp\nprotected:\n    using ChannelMap = std::unordered_map<int, Channel*>;\n    ChannelMap m_channels;\n```\n还有一个成员变量，`m_ownerLoop`，指明了从属于哪个loop。\n```cpp\nprivate:\n    EventLoop * m_ownerLoop;\n```\n### 成员函数\n#### 构造 / 析构函数\n```cpp\npublic:\n    Poller(EventLoop *loop);\n    virtual ~Poller() = default;\n```\n#### `poll`：提供给系统的统一的一个IO复用接口\n```cpp\npublic:\n    using ChannelList = std::vector<Channel*>;\n    virtual Timestamp poll(int timeoutMs, ChannelList * activeChannels) = 0;\n```\n参数：\n1. timeoutMs：超时时间，毫秒为单位\n2. activeChannels：当前激活的、对事件注册好的channel列表\n#### 与事件的注册、注销有关的\n```cpp\npublic:\n    /* 当fd注册的事件有变更时, channel调用update, 函数内包含updateChannel(this) */\n    virtual void updateChannel(Channel * channel) = 0;\n    /* 当fd注册的事件要注销时，channel调用remove，函数内包含removeChannel(this) */\n    virtual void removeChannel(Channel * channel) = 0;\n```\n参数：channel 均为`外部channel传入的this指针`\n#### `newDefaultPoller(EventLoop * loop)`\n提供给EventLoop的接口，以获取默认的IO复用具体实现。\n\n>注意：我们最好不要实现到`poller.cc`文件中，不大妥当。因为`Poller`类是基类，而把获取具体实现写到抽象类文件实现中是不好的。可以单独把实现代码写到`defaultpoller.cc`中。\n\n```cpp\npublic:\n    static Poller* newDefaultPoller(EventLoop *loop);\n```\n#### `hasChannel`\n判断poller是否拥有某一channel\n```cpp\npublic:\n    virtual bool hasChannel(Channel * channel) const;\n```\n## EpollPoller\n是Poller抽象基类的一个具体实现类。\n### 成员函数\n#### 构造/析构\n构造相当于`epoll_create`，记录在`m_epollfd`成员变量中。析构时close该fd。\n```cpp\npublic:\n    EpollPoller(EventLoop *loop);\n    ~EpollPoller() override;\n```\n#### `poll`：重写Poller基类方法，相当于`epoll_wait`\n```cpp\npublic:\n    Timestamp poll(int timeoutMs, ChannelList *activeChannels) override;\n```\n#### `update/removeChannel`：重写Poller基类方法，相当于`epoll_ctl add/mod/del`\n```cpp\npublic:\n    void updateChannel(Channel *channel) override;\n    void removeChannel(Channel *channel) override;\n```\n#### `fillActiveChannels`：填写活跃的channels连接\n```cpp\nprivate:\n    void fillActiveChannels(int numEvents, ChannelList *activeChannels) const;\n```\n#### `update`：更新channel通道\n```cpp\nprivate:\n    void update(int operation, Channel * channel);\n```\n### 成员属性\n1. `m_epollfd` - epoll相关的方法都需要用到fd，通过epoll_create来创建。映射的是epoll底层的文件系统红黑树。\n2. `m_events` - 是一个`vector<struct epoll_event`容器。\n\n```cpp\nprivate:\n    int m_epollfd;\n    using std::vector<struct epoll_event> EventList;\n    EventList m_events;\n```\n\n3. `kInitEventListSize` - `EventList`初始的长度。\n\n```cpp\nprivate:\n    static const int kInitEventListSize = 16;\n```\n\n4. 从Poller继承而来，拥有poller包含的`ChannelMap m_channels`。\n\n```cpp\nclass Poller\n{\n// ...\nprotected:\n    using ChannelMap = std::unordered_map<int, Channel*>;\n    ChannelMap m_channels;\n// ...\n}\n```\n### 实现代码\n首先声明了三个全局常量，表示channel的状态\n```cpp\nconst int kNew      = -1;    //从未添加到epoll的channel\nconst int kAdded    = 1;     //已经添加到epoll的channel\nconst int kDeleted  = 2;     //已把该channel从epoll中删除\n```\n#### 构造函数\n```cpp\n#include\"logger.h\"      //LOG_FATAL\n#include<errno.h>       //errno\n#include<sys/epoll.h>\n\nEpollPoller::EpollPoller(EventLoop * loop)\n  : Poller(loop),\n    m_epollfd(epoll_create1(EPOLL_CLOEXEC)),\t// epoll_create\n    m_events(kInitEventListSize)  // vector<epoll_event>\n{\n    if(m_epollfd < 0)\n    {\n        LOG_FATAL(\"epoll_create error: %d\\n\", errno);\n    }\n}\n```\n#### 析构\n```cpp\n#include<unistd.h>      //close\nEpollPoller::~EpollPoller()\n{\n    close(m_epollfd);\n}\n```\n## CurrentThread：主要用于获取tid\n`__thread`相当于C++11标准中的`thread_local`修饰符。用于修饰全局变量。\n修饰之前，全局变量只能被若干线程共享。修饰之后，此全局变量变成每个线程专有的属性。\n```cpp\n#pragma once\n#include<unistd.h>          //pid_t  syscall\n#include<sys/syscall.h>     //SYS_gettid\nnamespace CurrentThread\n{\n    /**\n     * @brief 此变量被__thread修饰, 相当于C++11标准中的thread_local修饰符, \n     * 用于修饰全局变量。修饰之前, 全局变量只能被若干线程共享; \n     * 修饰之后, 此全局变量变成每个线程专有的属性。\n     */\n    extern __thread int t_cachedTid;\n    /* 通过Linux系统调用SYS_gettid, 加载当前线程的tid值到t_cachedTid */\n    void cacheTid()\n    {\n        if(t_cachedTid == 0)\n        {\n            t_cachedTid = static_cast<pid_t>(syscall(SYS_gettid));\n        }\n    }\n    /* 返回当前线程的tid, 若加载过则直接返回存储过的值 */\n    inline int tid()\n    {\n        /* 若t_cachedTid为0说明是第一次加载, 需要调用cacheTid */\n        if(__builtin_expect(t_cachedTid == 0, 0))\n        {\n            cacheTid();\n        }\n        return t_cachedTid;\n    }\n}\n```\n# EventLoop\n前面的EventLoop概览中提到：\n1. 不允许拷贝\n2. 主要包含的成员之一：poller（相当于epoll），属性有sockfd及其上面绑定的事件\n3. 另一个主要的成员是channel，属性有fd、events、revents等等\n\nEventLoop就是要完成事件循环，事件循环最重要的几个动作：epoll（**由poller负责**）、epoll监听的fd及感兴趣的事件、实际`epoll_wait`后发生的事件。\n这些sockfd、感兴趣的事件、发生的事件都**记录在channel中**。\n要写EventLoop就要理清楚EventLoop、Channel、Poller之间的关系。Reactor模型中，这三个组件整体对应着Demultiplex。\n\n由上述约束，在`.h`文件中，我们可以首先写出：\n\n```cpp\n#pragma once\n#include\"noncopyable.h\"\nclass Channel;\nclass Poller;\nclass EventLoop : noncopyable\n{\npublic:\nprivate:\n}\n```\n\n要用到函数对象。\n```cpp\n#include<functional>\npublic:\n    using Functor = std::function<void()>;\n```\n\n## 成员变量\n\n1. `ChannelList m_activeChannels` - EventLoop管理的所有的Channel的List；\n   `Channel * m_currentActiveChannel` - 主要用于断言\n\n   ```cpp\n   private:\n       using ChannelList = std::vector<Channel*>;\n       ChannelList m_activeChannels;\n   \n       Channel * m_currentActiveChannel;\n   ```\n\n2. 标志(最好为atomic)\n\n   1. `m_looping` - 事件循环状态标志 - 真则正在循环，假则将要退出循环\n\n   2. `m_quit` - 标识退出loop循环\n\n   3. `m_eventHandling` - \n\n   4. `m_callingPendingFunctors` - 标识当前loop当前是否有需要执行的回调操作\n\n      ```cpp\n      private:\n          std::atomic_bool m_looping;\n          std::atomic_bool m_quit;\n          std::atomic_bool m_callingPendingFunctors;\n      ```\n\n3. `m_threadId` - 记录当前Loop所在线程的ID\n\n   ```cpp\n   private:\n       const pid_t m_threadId;\n   ```\n\n4. `std::unique<Poller> m_poller` - EventLoop所管理的poller，去轮询监听channels上发生的事件。用`std::unique_ptr`管理\n\n   ```cpp\n   private:\n       std::unique_ptr<Poller> m_poller;\n   ```\n\n5. `Timestamp m_pollReturnTime` - poller返回发生事件的channels的时间点\n\n   ```cpp\n   private:\n       Timestamp m_pollReturnTime;\n   ```\n\n6. `int m_wakeupFd` - mainLoop获取到一个新用户的channel后，搭配轮询算法选择一个等待任务的subLoop，通过wakeupFd对其进行唤醒来处理channel。用`eventfd`创建。`eventfd`使用线程间的`wait/notify`事件通知机制，直接在内核唤醒，效率较高。与此处理相似的是，`libevent`使用的是`socketpair`的双向通信机制，相当于网络通信层面的机制，效率较低。\n\n   ```cpp\n   private:\n       int m_wakeupFd;\n   ```\n\n7. `std::unique_ptr<Channel> m_wakeupChannel` - 把wakeupFd封装起来和其Channel关联，因为操作的往往不是fd而是其channel\n\n   ```cpp\n   private:\n       std::unique_ptr<Channel> m_wakeupChannel;\n   ```\n\n8. `std::vector<Functor> m_pendingFunctors` - 存储loop需要执行的所有的回调操作。与`callingPendingFunctors`标识结合使用，如果此标识显示当前loop有需要执行的回调操作，则这些回调操作将在此vector容器中存放。**需要用mutex保护其线程安全**。\n\n   ```cpp\n   private:\n       std::vector<Functor> m_pendingFunctors;\n       mutable std::mutex m_mutex;\n   ```\n\n## 成员函数\n\n1. 构造/析构\n   ```cpp\n   public:\n       EventLoop();\n       ~EventLoop();\n   ```\n\n2. `loop`/`quit` - 开始/结束事件循环\n\n   ```cpp\n   public:\n       void loop();\n       void quit();\n   ```\n\n3. `Timestamp pollReturnTime() const`\n\n   ```cpp\n   public:\n       Timestamp pollReturnTime() const\n       {\n           return m_pollReturnTime;\n       }\n   ```\n\n4. `runInLoop` - 在当前loop中执行cb\n\n   ```cpp\n   public:\n       void runInLoop(Functor cb);\n   ```\n\n5. `queueInLoop` - 把cb放入队列中，唤醒loop所在的线程，执行cb\n\n   ```cpp\n   public:\n       void queueInLoop(Functor cb);\n   ```\n\n6. `wakeup` - mainLoop唤醒subLoop所在的线程\n\n   ```cpp\n   public:\n       void wakeup();\n   ```\n\n7. 更新Channel相关 - EventLoop的方法调用Poller的方法\n   ```cpp\n   public:\n       void updateChannel(Channel *channel);\n       void removeChannel(Channel *channel);\n       bool hasChannel(Channel *channel);\n   ```\n\n8. `isInLoopThread` - 判断EventLoop对象是否在自己的线程里面\n\n   ```cpp\n   #include\"currentthread.h\"\n   public:\n       bool isInLoopThread() const\n       {\n           return m_threadId == CurrentThread::tid();\n       }\n   ```\n\n9. handleRead - 处理wakeup唤醒相关的逻辑\n   ```cpp\n   private:\n       void handleRead();\n   ```\n\n10. doPendingFunctors - 执行回调\n    ```cpp\n    private:\n        void doPendingFunctors();\n    ```\n\n## 实现代码\n\n### 全局变量\n\n1. 防止一个线程创建多个loop\n   ```cpp\n   //__thread修饰表示这个全局变量转为了每个线程私有的属性\n   __thread EventLoop *t_loopInThisThread = nullptr;\n   ```\n\n2. 默认的超时时间\n   ```cpp\n   const int kPollTimeMs = 10000;\n   ```\n\n### 全局函数\n\n1. createEventfd() - 创建wakeupfd，用来通知等待任务的subLoop，处理新的Channel事件。\n\n   ```cpp\n   #include<sys/eventfd.h>\n   int createEventfd()\n   {\n       int evtfd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);\n       if(evtfd < 0)\n       {\n           LOG_FATAL(\"Failed in eventfd: %d\\n\", errno);\n       }\n       return evtfd;\n   }\n   ```\n\n\n# EventLoopThread\n\nEventLoop组件及其内部的Chennel、Poller已经在上文讨论。要和thread结合达成最终的\"one loop per thread\"模型，较好的办法就是将EventLoop与thread组合封装。\n## Thread\n\n```cpp\nclass Thread : noncopyable\n```\n\n### 线程函数\n线程最主要的组成部分就是线程函数。\n```cpp\npublic:\n    using ThreadFunc = std::function<void()>;\n```\n\n> 使用无返回值+无参数是为了便于统一线程函数的形式，具体绑定回调则使用函数对象绑定器。\n### 成员变量\n用C++线程库、智能指针。\nThread对象刚创建不会执行线程函数，而是在成员函数`start()`被调用时，用智能指针创建C++ 11的thread线程才开始真正执行。\n1. `m_started` - 表示\n2. `m_joined`\n3. `std::shared_ptr<std::thread> m_thread`\n4. `pid_t m_tid`\n5. `ThreadFunc m_func` - 存储线程函数\n6. `std::string m_name`\n7. `static std::atomic_int m_numCreated` - 目前产生了线程对象的计数值\n### 成员方法\n#### setDefaultName\n构造函数中如果没有传入name则赋\"Thread %d \"，%d为已创建的线程对象数目。\n```cpp\nprivate:\n    void setDefaultName();\n```\n#### 构造 / 析构函数\n```cpp\npublic:\n    explicit Thread(ThreadFunc, const std::string & name = std::string());\n    ~Thread();\n```\n#### start\n```cpp\npublic:\n    void start();\n```\n#### join\n```cpp\npublic:\n    void join();\n```\n#### 获取线程状态相关的标志、信息\n1. started\n2. tid\n3. name\n4. numCreated\n\n```cpp\npublic:\n    bool started() const {return m_started;}\n    pid_t tid() const {return m_tid;}\n    const std::string & name() const {return m_name;}\n    static int numCreated() {return m_numCreated;}\n```\n### 代码实现\n```cpp\n#include\"thread.h\"\n#include\"currentthread.h\"\n#include<semaphore.h>\nstd::atomic_int Thread::m_numCreated(0);\nvoid Thread::setDefaultName(int numCreated)\n{\n    char buf[32] = {0};\n    snprintf(buf, sizeof buf, \"Thread%d\", numCreated);\n    m_name = buf;\n}\nThread::Thread(ThreadFunc func, const std::string & name)\n    : m_started(false), m_joined(false), m_tid(0),\n      m_func(std::move(func)), m_name(name)\n{\n    int num = ++m_numCreated;\n    if(m_name.empty())\n    {\n        setDefaultName(num);\n    }\n}\nThread::~Thread()\n{\n    /* 线程要么join, 要么detach */\n    if(m_started && !m_joined)\n    {\n        m_thread->detach();\n    }\n}\nvoid Thread::start()\n{\n    m_started = true;\n    /* 为了tid初始化时期的线程安全, 保证tid有效 */\n    sem_t sem;\n    sem_init(&sem, false, 0);   //地址, 是否进程间共享, 初始值0\n    //下面这句才是真正去创建一个立即执行的子线程。而且下面这个语句是子线程的生命周期。\n    //从创建完m_thread后主线程、子线程分离, 主线程需要等待子线程执行完毕, 可以用信号量来控制。\n    m_thread = std::make_shared<std::thread>([&](){\n        m_tid = CurrentThread::tid();\n        \n        sem_post(&sem);\n        \n        m_func();\n    });\n\t//这里是主线程的代码，只有sem的值变为>0时才能往下走。\n    sem_wait(&sem);\n}\nvoid Thread::join()\n{\n    m_joined = true;\n    m_thread->join();\n}\n```\n## EventLoopThread\n```cpp\nclass EventLoopThread : noncopyable\n```\n封装的目标：在thread线程对象上运行一个loop。\n### 线程初始化时回调函数\n```cpp\npublic:\n    using ThreadInitCallback = std::function<void(EventLoop*)>;\n```\n### 成员变量\n1. `m_loop` - 存储Eventloop对象指针\n\n```cpp\nprivate:\n    EventLoop * m_loop;\n```\n\n2. `m_thread` - 存储线程对象\n\n```cpp\nprivate:\n    Thread m_thread;\n```\n\n3. `bool m_exiting` - 线程正在退出的标志\n\n```cpp\nprivate:\n    bool m_exiting;\n```\n\n4. `ThreadInitCallback m_callback` - 线程初始化调用的回调操作，在EventLoopThread构造时在第1个参数传入，默认是一个空操作。\n\n```cpp\nprivate:\n    ThreadInitCallback m_callback;\n```\n### 成员函数\n#### 构造 / 析构函数\n构造函数参数：可以传入一个线程初始化回调函数对象；还有name。其中，回调函数对象默认构造为空操作。\n```cpp\npublic:\nEventLoopThread(const ThreadInitCallback &cb = ThreadInitCallback(),\n                const std::string & name = std::string());\n~EventLoopThread();\n```\n#### startLoop - 开启循环\n```cpp\npublic:\n    EventLoop * startLoop();\n```\n#### threadFunc - 线程函数\n```cpp\nprivate:\n    void threadFunc();\n```\n### 代码实现\n1. 构造函数\n    1. 主要的工作就是构造EventLoopThread中的Thread对象即`m_thread`成员。Thread对象`m_thread`绑定的线程函数是用`std::bind`绑定的函数，用的是EventLoopThread类中的threadFunc函数，并且绑定了其this指针。EventLoopThread构造函数的第2个参数name将作为`m_thread`的名字。\n    2. 第1个参数指定的是`线程初始化时的回调函数`，**与线程start后执行的线程函数无关**。第1个参数的默认值和第2个参数的默认值在`.h`文件中已指出。`ThreadInitCallback()`是指创建一个默认函数对象，函数执行空操作。\n    3. Thread对象构造完成后，不会立即执行`线程函数threadFunc`，因为Thread构造并不意味着C++11标准库的thread创建完毕。只有调用`m_thread.start()`才会真正执行`线程函数threadFunc`。\n    4. 构造函数还把传入的`线程初始化时回调函数cb`保存到了`m_callback`成员。\n\n```cpp\n#include\"eventloopthread.h\"\n#include\"eventloop.h\"\nEventLoopThread::EventLoopThread(const ThreadInitCallback &cb,\n                const std::string &name)\n  : m_loop(nullptr), m_exiting(false),\n    m_thread(std::bind(&EventLoopThread::threadFunc, this), name),\n    m_mutex(), m_cond(), m_callback(cb)\n{\n\n}\nEventLoopThread::~EventLoopThread()\n{\n    m_exiting = true;\n    if(m_loop != nullptr)\n    {\n        m_loop->quit();\n        m_thread.join();\n    }\n}\nEventLoop * EventLoopThread::startLoop()\n{\n    m_thread.start();   //启动底层新线程，执行回调函数，\n    \n    EventLoop * loop = nullptr;\n    {/* 临界区m_loop */\n        std::unique_lock<std::mutex> lock(m_mutex);\n        while(m_loop == nullptr)\n        {\n            m_cond.wait(lock);\n        }\n        loop = m_loop;\n    }/* 临界区m_loop */\n    return loop;\n}\n/**\n* @brief Thread对象实际执行的线程函数，在单独的子线程中执行\n*/\nvoid EventLoopThread::threadFunc()\n{\n    EventLoop loop; //构造一个独立的eventloop, 和m_thread一对一, one loop per thread的证据\n    if(m_callback)\t//如果m_callback(即ThreadInitCallback)不为空则执行此函数\n    {\n        m_callback(&loop);\n    }\n    {/* 临界区m_loop */\n        std::unique_lock<std::mutex> lock(m_mutex);\n        m_loop = &loop;\n        m_cond.notify_one();\t//通知主线程的startLoop(), loop已经在子线程创建好了。\n    }/* 临界区m_loop */\n    loop.loop();    //EventLoop loop => Poller.poll\n    \n    /* 执行到此处说明loop已经结束 退出循环 */\n    std::unique_lock<std::mutex> lock(m_mutex);\n    m_loop = nullptr;\n}\n```\n# EventLoopThreadPool\n```cpp\nclass EventLoopThreadPool : noncopyable\n```\n## 线程初始化时回调函数\n\n```cpp\npublic:\n    using ThreadInitCallback = std::function<void(EventLoop*)>;\n```\n## 成员变量\n1. `m_baseLoop` - 用户最开始创建的loop\n2. 标志相关\n    1. `std::string m_name`\n    2. `bool m_started`\n    3. `int m_numThreads`\n    4. `int m_next`\n3. `std::vector<std::unique_ptr<EventLoopThread>> m_threads` - 包含了所有创建的线程\n4. `std::vector<EventLoop*> m_loops` - 包含了所有管理着的loop的指针，通过`m_threads`中的某个thread进行`startLoop()`返回loop的指针。\n## 成员函数\n### 构造/析构函数\n```cpp\npublic:\n    EventLoopThreadPool(EventLoop * baseLoop, const std::string &nameArg);\n    ~EventLoopThreadPool();\n```\n#### `setThreadNum(int)` - 供TcpServer调用\n```cpp\npublic:\n    void setThreadNum(int numThreads)\n    {\n        m_numThreads = numThreads;\n    }\n```\n#### `start` - 开启事件循环线程\n```cpp\npublic:\n    void start(const ThreadInitCallback &cb = ThreadInitCallback());\n```\n#### `getNextLoop` - 如果工作在多线程中，baseLoop默认以轮询的方式分配channel给subLoop\n```cpp\npublic:\n    EventLoop * getNextLoop();\n```\n#### `getAllLoops` - 获取所有管理着的loop，存到vector中，相当于拷贝了`m_loops`\n\n```cpp\npublic:\n    std::vector<EventLoop*> getAllLoops();\n```\n#### 获取各种状态、信息\n1. started\n2. name\n\n```cpp\npublic:\n    bool started() const {return m_started;}\n    const std::string name() const {return m_name;}\n```\n## 代码实现\n```cpp\n#include\"eventloopthreadpool.h\"\n#include\"eventloopthread.h\"\nEventLoopThreadPool::EventLoopThreadPool(EventLoop *baseLoop, const std::string &nameArg)\n    : m_baseLoop(baseLoop),\n      m_name(nameArg),\n      m_started(false),\n      m_numThreads(0),\n      m_next(0)\n{\n\n}\nEventLoopThreadPool::~EventLoopThreadPool()\n{\n    /**\n     * nothing to do, bacause evey loop is on the thread stack,\n     * that will destruct automatically.\n     */\n}\nvoid EventLoopThreadPool::start(const ThreadInitCallback &cb)\n{\n    m_started = true;\n    for(int i = 0; i < m_numThreads; ++i)\n    {\n        char buf[m_name.size() + 32];\n        /* 以线程池name + 下标序列号 作为thread线程的名字 */\n        snprintf(buf, sizeof buf, \"%s%d\", m_name.c_str(), i);\n        std::string threadName(buf);\n        m_threads.push_back(std::make_unique<EventLoopThread>(cb, threadName));\n        m_loops.push_back(m_threads.back()->startLoop());\n    }\n    /* m_numThreads == 0时, 上面for循环不会执行, 执行下面的操作 */\n    if(m_numThreads == 0 && cb != nullptr)\n    {\n        cb(m_baseLoop);\n    }\n}\n/* 体现了对subLoop的轮询算法 */\nEventLoop* EventLoopThreadPool::getNextLoop()\n{\n    EventLoop * loop = m_baseLoop;\n    if(!m_loops.empty())\n    {\n        loop = m_loops[m_next];\n        ++m_next;\n        if(m_next >= m_loops.size())\n        {\n            m_next = 0;\n        }\n    }\n    return loop;\n}\nstd::vector<EventLoop*> EventLoopThreadPool::getAllLoops()\n{\n    if(m_loops.empty())\n    {\n        return std::vector<EventLoop*>(1, m_baseLoop);\n    }\n    else\n    {\n        return m_loops;\n    }\n}\n```\n# Acceptor\nmainReactor主要的工作是处理客户端的连接请求，然后把sockfd轮询分配给subReactors。\n\n这个工作由mainReactor中的acceptor处理。处理的流程和TCP socket编程流程基本一致。需要有一个listenfd，即监听套接字，去其中的监听队列取可用的连接。即Acceptor主要就是对若干sockfd的封装。\n## socket\n### .h文件\n\n```cpp\n#pragma once\n#include\"noncopyable.h\"\nclass InetAddress;\nclass Socket : noncopyable\n{\npublic:\n    explicit Socket(int sockfd)\n        : m_sockfd(sockfd)\n    {\n\n    }\n    ~Socket();\n    int fd() const {return m_sockfd;}\n    void bindAddress(const InetAddress &localAddr);\n    void listen();\n    int accept(InetAddress *peerAddr);\npublic:\n    void shutdownWrite();\n    /* 更改TCP选项, 直接交付, 不进行缓存 */\n    void setTcpNoDelay(bool on);\n    /* 更改TCP选项 */\n    void setReuseAddr(bool on);\n    /* 更改TCP选项 */\n    void setReusePort(bool on);\n    /* 更改TCP选项 */\n    void setKeepAlive(bool on);\nprivate:\n    const int m_sockfd;\n};\n```\n### .cc文件\n```cpp\n#include\"socket.h\"\n#include\"logger.h\"\n#include\"inetaddress.h\"\n#include<unistd.h>  //close\n#include<sys/socket.h>  //bind\n#include<strings.h> //bzero\n#include<netinet/tcp.h> //TCP_NODELAY\nSocket::~Socket()\n{\n    close(m_sockfd);\n}\nvoid Socket::bindAddress(const InetAddress &localAddr)\n{\n    /* bind return 0 when success */\n    if(0 != ::bind(m_sockfd, (sockaddr*)localAddr.getSockAddr(), sizeof(sockaddr_in)))\n    {\n        LOG_FATAL(\"bind sockfd: %d fail, createNonblocking or Die\\n\", m_sockfd);\n    }\n}\nvoid Socket::listen()\n{\n    if(0 != ::listen(m_sockfd, 1024))\n    {\n        LOG_FATAL(\"listen sockfd: %d fail\\n\", m_sockfd);\n    }\n}\nint Socket::accept(InetAddress * peerAddr)\n{\n    struct sockaddr_in addr;\n    socklen_t len;\n    bzero(&addr, sizeof addr);\n    int connfd = ::accept(m_sockfd, (sockaddr*)&addr, &len);\n    if(connfd >= 0)\n    {\n        peerAddr->setSockAddr(addr);\n    }\n    return connfd;\n}\nvoid Socket::shutdownWrite()\n{\n    if(::shutdown(m_sockfd, SHUT_WR) < 0)\n    {\n        LOG_ERROR(\"shutdown Write error\\n\");\n    }\n}\nvoid Socket::setTcpNoDelay(bool on)\n{\n    int optval = on ? 1 : 0;\n    ::setsockopt(m_sockfd, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof optval);\n}\nvoid Socket::setReuseAddr(bool on)\n{\n    int optval = on ? 1 : 0;\n    ::setsockopt(m_sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof optval);\n}\nvoid Socket::setTcpNoDelay(bool on)\n{\n    int optval = on ? 1 : 0;\n    ::setsockopt(m_sockfd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof optval);\n}\nvoid Socket::setKeepAlive(bool on)\n{\n    int optval = on ? 1 : 0;\n    ::setsockopt(m_sockfd, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof optval);\n}\n```\n## Acceptor\n```cpp\nclass Acceptor : noncopyable\n```\n### 收到新连接时的回调\n\n```cpp\npublic:\n    using NewConnectionCallback = std::function<void(int fd, const InetAddress&)>;\n```\n### 成员变量\n1. `m_loop`\n2. `m_acceptSocket`\n3. `m_acceptChannel`\n4. `m_newConnectionCallback` - 把fd打包为channel，getNextLoop唤醒一个subLoop，把channel分发给subLoop。\n5. `m_listening`\n```cpp\nprivate:\n    EventLoop * m_loop;\n    Socket m_acceptSocket;\n    Channel m_acceptChannel;\n    NewConnectionCallback m_newConnectionCallback;\n    bool m_listenning;\n```\n### 成员函数\n#### 构造/析构\n```cpp\npublic:\n    /* 此构造的三个参数本身也是TcpServer的三个参数 */\n    Acceptor(EventLoop * loop, const InetAddress & listenAddr, bool reusePort);\n    ~Acceptor();\n```\n#### listen\n```cpp\npublic:\n    void listen();\n```\n#### get/set\n1. setNewConnectionCallback\n2. listening\n\n```cpp\npublic:\n    void setNewConnectionCallback(const NewConnectionCallback &cb)\n    {\n        m_newConnectionCallback = cb;\n    }\n    bool listenning() const {return m_listenning;}\n```\n#### handleRead\n```cpp\nprivate:\n    void handleRead();\n```\n### 代码实现\n#### 构造\n1. 由传入的`loop`对`m_loop`初始化；创建一个NonBlock的Tcp socketfd并用于构造`m_acceptSocket`；把loop和刚才创建好的socketfd打包构造`m_acceptChannel`；设置各种标志。\n2. 根据传入的第2个参数`listenAddr`，`bindAddress`绑定地址到socket上。\n3. TcpServer调用start()后，意味着acceptor要对listen sockfd进行listen。如果接收到了新用户的连接，需要执行一个回调（具体操作是把connfd->channel->subloop）。所以还要设置一个ReadCallback。\n\n```cpp\nstatic int createNonblockingSocket()\n{\n    int sockfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);\n    if(sockfd < 0)\n    {\n        LOG_FATAL(\"%s:%s:%d listen socketfd create err: %d\\n\", __FILE__, __FUNCTION__, __LINE__, errno);\n    }\n    return sockfd;\n}\nAcceptor::Acceptor(EventLoop *loop, const InetAddress &listenAddr, bool reusePort)\n  : m_loop(loop),\n    m_acceptSocket(createNonblockingSocket()),    //create socket\n    m_acceptChannel(loop, m_acceptSocket.fd()),\n    m_listenning(false)\n{\n    m_acceptSocket.setReuseAddr(true);\n    m_acceptSocket.setReusePort(true);\n    m_acceptSocket.bindAddress(listenAddr);         //bind addr to socket\n    // TcpServer::start() Acceptor::listen(), 如果有新连接需要执行回调 connfd->channel->subloop\n    //baseLoop -> m_acceptChannel(listenfd) -> \n    m_acceptChannel.setReadCallback(std::bind(&Acceptor::handleRead, this));\n}\n```\n\n#### handleRead - listenfd有事件发生, 即有新用户链接时的回调操作\n\n#### accept一个connfd\n把fd和peerAddr交给newConnectionCallback处理。newConnectionCallback是TcpServer中编写的。主要工作是**轮询找到subLoop, 唤醒, 分配当前新客户端的channel**。\n\n```cpp\n/* listenfd有事件发生, 即有新连接 */\nvoid Acceptor::handleRead()\n{\n   InetAddress peerAddr;\n   int connfd = m_acceptSocket.accept(&peerAddr);\n   if(connfd > 0)\n   {\n       if(m_newConnectionCallback)\n       {\n           /* 轮询找到subLoop, 唤醒, 分配当前新客户端的channel */\n           m_newConnectionCallback(connfd, peerAddr);\n       }\n       else\n       {\n           close(connfd);\n       }\n   }\n   else\n   {\n       LOG_ERROR(\"%s:%s:%d accept err: %d\", __FILE__, __FUNCTION__, __LINE__, errno);\n       if(errno == EMFILE)\n       {\n           LOG_ERROR(\"(sockfd reached max limit)\");\n       }\n       LOG_ERROR(\"\\n\");\n   }\n}\n```\n#### 析构\n```cpp\nAcceptor::~Acceptor()\n{\n    m_acceptChannel.disableAll();\n    m_acceptChannel.remove();\n}\n```\n#### listen\n1. 设置listenning标志\n2. 调用`m_acceptSocket`的listen\n3. 调用`m_acceptChannel`的enableReading，即把`m_acceptChannel`注册到Poller中。\n\n```cpp\nvoid Acceptor::listen()\n{\n    m_listenning = true;\n    m_acceptSocket.listen();                        //listen\n    m_acceptChannel.enableReading();                //m_acceptChannel -> poller\n}\n```\n# TcpServer\n\n考虑一个问题：用户使用muduo库编写服务器程序时，为了避免用户再去困惑引入哪些头文件，我们在tcpserver.h中把该引入的头文件全引入进去，而不再只是对类前置声明了。\n```cpp\n#pragma once\n#include\"eventloop.h\"\n#include\"acceptor.h\"\n#include\"inetaddress.h\"\n#include\"noncopyable.h\"\nclass TcpServer : noncopyable\n```\n## 回调\n\n所有的回调，都是用户设置到TcpServer后，TcpServer再自己设置到EventLoop中的。\n\n以下是TcpServer类中包含的回调操作属性。（成员变量）\n\n```cpp\nprivate:\n    ThreadInitCallback\t    m_threadInitCallback;\n    ConnectionCallback \t    m_connectionCallback;\n    MessageCallback\t        m_messageCallback;\n    WriteCompleteCallback   m_writeCompleteCallback;\n    HighWaterMarkCallback   m_highWaterMarkCallback;\n```\n\n### 线程初始化时的回调\n直接声明在TcpServer class中。\n```cpp\npublic:\n    using ThreadInitCallback = std::function<void(EventLoop*)>;\n```\n\n### 连接、读写事件的回调 - 单独写到callbacks.h文件中\n\n>为了对各种回调函数进行管理，写到单独的头文件`callbacks.h`中。\n\n1. ConnectionCallback - 有关连接的回调。\n2. CloseCallback - 关闭连接的回调\n3. WriteCompleteCallback - 消息发送完成后的回调\n4. MessageCallback - 已连接用户有读写事件发生时的回调\n5. HighWaterMarkCallback - 高水位回调，为了控制收发流量稳定\n\n```cpp\n#pragma once\n#include<memory>\n#include<functional>\nclass Buffer;\nclass TcpConnection;\n\nusing TcpConnectionPtr = std::shared_ptr<TcpConnection>;\n\nusing ConnectionCallback = std::function<void(const TcpConnectionPtr&)>;\nusing CloseCallback = std::function<void(const TcpConnectionPtr&)>;\nusing WriteCompleteCallback = std::function<void(const TcpConnectionPtr&)>;\nusing HighWaterMarkCallback = std::function<void(const TcpConnectionPtr&, size_t)>;\n\nusing MessageCallback = std::function<void(const TcpConnectionPtr &,\n                                           Buffer *, Timestamp)>;\n```\n\n## 枚举声明\n\nOption枚举类，直接声明在TcpServer类中。\n\n`Option.kReusePort`/`Option.kNoReusePort`表示端口是否可重用。\n\n```cpp\npublic:\n    enum Option\n    {\n        kNoReusePort,\n        kReusePort\n    };\n```\n\n## 成员变量\n\n其中，回调函数属性已经在上面给出。\n1. `ConnectionMap m_connections` - 保存所有的连接\n\n   ```cpp\n   private:\n       using ConnectionMap = std::unoredered_map<std::string, TcpConnectionPtr>;\n       ConnectionMap m_connections;\n   ```\n\n2. `EventLoop *m_loop` - 用户实现定义的baseLoop\n\n   ```cpp\n   private:\n       EventLoop * m_loop;\n   ```\n\n3. `m_IPport` - 存储IP和端口的字符串\n\n   ```cpp\n   private:\n       const std::string m_IPport;\n   ```\n\n4. `std::unique_ptr<Acceptor> m_acceptor` - 运行在mainLoop，任务是监听新连接事件。\n\n5. `std::unique_ptr<EventLoopThreadPool> m_threadPool` - \n\n6. 标识\n\n   1. `std::string m_name` - TcpServer的易记忆名字\n   2. `atomic_bool started` - 是否已启动\n\n   ```cpp\n   private:\n       std::string m_name;\n       atomic_bool started;\n   ```\n\n7. `m_nextConnId`\n\n   ```cpp\n   private:\n       int m_connId;\n   ```\n\n\n## 成员函数\n\n1. 构造/析构\n\n   ```cpp\n   public:\n       TcpServer(EventLoop * loop, const InetAddress &listenAddr,\n                 const std::string &nameArg, Option option = kNoReusePort);\n       ~TcpServer();\n   ```\n\n2. 设置回调\n   ```cpp\n   public:\n       void setThreadInitCallback(const ThreadInitCallback &cb)\n       {\n           m_threadInitCallback = cb;\n       }\n       void setConnectionCallback(const ConnectionCallback &cb)\n       {\n           m_connectionCallback = cb;\n       }\n       void setMessageCallback(const MessageCallback &cb)\n       {\n           m_messageCallback = cb;\n       }\n       void setWriteCompleteCallback(const WriteCompleteCallback &cb)\n       {\n           m_writeCompleteCallback = cb;\n       }\n   ```\n\n3. start - 开启服务器监听，即mainLoop的acceptor的listen\n   ```cpp\n   public:\n       void start();\n   ```\n\n4. 关于Connection\n   ```cpp\n   private:\n       void newConnection(int sockfd, const InetAddress& peerAddr);\n       void removeConnection(const TcpConnectionPtr& conn);\n       void removeConnectionInLoop(const TcpConnectionPtr& conn);\n   ```\n\n## 代码实现\n\n1. 构造，有三个参数，loop指针，InetAddress，标识名称name，端口是否重用Option\n\n   1. 对`m_loop`进行赋值，需要做非空检查\n\n      ```cpp\n      EventLoop* CheckLoopNotNull(EventLoop* loop)\n      {\n          if(loop == nullptr)\n          {\n              LOG_FATAL(\"%s:%s:%d mainLoop is null\\n\", __FILE__, __FUNCTION__, __LINE__);\n          }\n          return loop;\n      }\n      ```\n\n   2. 对`m_IPport`进行赋值，值是调用参数`listenAddr`中的函数`toIPport()`获得的\n\n   3. 对`m_name`赋值\n\n   4. 对`m_acceptor`进行构造(unique_ptr)。传入参数`loop`，`listenAddr`，`option`\n\n      1. 创建socket\n      2. socket的fd和loop指针封装为Channel - `m_acceptChannel(loop, m_acceptSocket.fd())`\n      3. 设置channel的ReadCallback回调\n      4. 当TcpServer调用start时，acceptor将会调用listen，将调用`m_acceptChannel`的`enableReading()`函数，往其相应的loop中进而在poller中注册事件。\n      5. loop等待事件，如果发生事件，调用channel的handleEvent，进而执行readCallBack。acceptor的readCallBack在构造时绑定为handleRead，工作是对channel的socket进行accept。\n\n   5. 对`m_threadPool`进行构造(shared_ptr)。传入参数`loop`，`m_name`\n\n   6. 设置回调\n\n      1. `m_connectionCallBack`\n      2. `m_messageCallBack`\n\n   7. `m_nextConnId`\n\n   ```cpp\n   #include<functional>\n   using namespace std::placeholders;\n   \n   TcpServer::TcpServer(EventLoop *loop, const InetAddress &listenAddr,\n                        const std::string &nameArg, Option option = kNoReusePort)\n       : m_loop(CheckLoopNotNull(loop)),\n         m_IPport(listenAddr.toIPport()),\n         m_name(nameArg),\n         m_acceptor(new Acceptor(loop, listenAddr, option == kReusePort)),\n         m_threadPool(new EventLoopThreadPool(loop, m_name)),\n         m_connectionCallback(),\n         m_messageCallback(),\n         m_nextConnId(1)\n   {\n       m_acceptor->setNewConnectionCallback(std::bind(&TcpServer::newConnection,\n                                                      this, _1, _2));//connfd, peerAddr\n   }\n   ```\n\n2. newConnection - 运行在主线程当中，主线程的mainLoop调用此函数，选择了一个ioLoop，**在非子loop的线程中（即当前是在mainThread）执行cb，就需要唤醒子loop所在线程（subThread），执行cb**，即调用subLoop的`queueInLoop(cb)`。\n\n   1. 根据轮询算法选择一个subLoop，即调用`m_threadPool->getNextLoop()`\n   2. 唤醒subLoop\n   3. 把当前connfd封装成channel分发给subloop\n\n3. setThreadNum - 设置底层subLoop的个数\n   ```cpp\n   void TcpServer::setThreadNum(int numThreads)\n   {\n       m_threadPool->setThreadNum(numThreads);\n   }\n   ```\n\n4. start - 开启服务器监听\n   ```cpp\n   void TcpServer::start()\n   {\n       //防止一个TcpServer对象被start多次;\n       if(m_started++ == 0)//即使bool为1，bool++后的值也还是1\n       {\n           m_threadPool->start(m_threadInitCallback);\n           m_loop->runInLoop(std::bind(&Acceptor::listen, m_acceptor.get()));\n       }\n   }\n   ```\n\n\n# TcpConnection\n\n顾名思义，此类对象表示的是tcp通信中，客户端和服务器之间成功建立的一条连接。主要封装用户在服务端的数据。\n\n1. mainLoop通过acceptor接收到新的连接时，将会把fd和loop封装到channel，继而封装到TcpConnection中，再通过轮询算法交给subLoop。\n2. 更重要的是，TcpConnection中存储了一些连接事件、读写事件发生时的回调。\n3. 最后，TcpConnection还还封装了Buffer。\n\n## Buffer\n\n基于非阻塞IO的服务端编程，Buffer是必不可少的。比如解决TCP粘包问题。\n\n### 成员变量\n\n1. `std::vector<char> m_buffer` - 数据数组。\n2. `size_t m_readerIndex` - 数据可读的位置下标\n3. `size_t m_writerIndex` - 数据可写的位置下标\n\n```cpp\nprivate:\n    std::vector<char> m_buffer;\n    size_t m_readerIndex;\n\tsize_t m_writerIndex;\n```\n\n除此之外，还有两个静态常量。\n\n1. `kCheapPrepend` - 记录数据包的长度\n2. `kInitialSize` - 数据包的初始大小值。\n\n```cpp\npublic:\n    static const size_t kCheapPrepend = 8;\n    static const size_t kInitialSize = 1024;\n```\n\n### 成员函数\n\n1. 构造/析构\n   ```cpp\n   public:\n       explicit Buffer(size_t initialSize = kInitialSize)\n           : m_buffer(kCheapPrepend + initialSize),\n             m_readerIndex(kCheapPrepend),\n             m_writerIndex(kCheapPrepend)\n       {\n       }\n       ~Buffer() = default;\n   ```\n\n2. readableBytes、writableBytes、prependableBytes\n   ```cpp\n   public:\n       size_t readableBytes() const\n       {\n           return m_writerIndex - m_readerIndex;\n       }\n       size_t writableBytes() const\n       {\n           return m_buffer.size() - m_writerIndex;\n       }\n       size_t prependableBytes() const\n       {\n           return m_readerIndex;\n       }\n   ```\n\n3. 返回指针\n\n   1. begin - 获取buffer实际首部指针\n   2. peek - 返回缓冲区数据包中可读数据起始位置\n   3. beginWrite - 返回可写的数据起始位置\n\n   ```cpp\n   private:\n       char * begin()\n       {\n           return &*m_buffer.begin();\n       }\n       const char * begin() const\n       {\n           return &*m_buffer.begin();\n       }\n   public:\n       const char * peek() const\n       {\n           return begin() + m_readerIndex;\n       }\n       char * beginWrite()\n       {\n           return begin() + m_writerIndex;\n       }\n       const char * beginWrite() const\n       {\n           return begin() + m_writerIndex;\n       }\n   ```\n\n4. `retrieve`/`retrieveAll`/`retrieveAsString`/`retrieveAllAsString` - 后两个是把buffer中的数据转为string类型，多与onMessage配合使用；前两个是将`m_readerIndex`和`m_writerIndex`调整位置。\n\n   ```cpp\n   public:\n       void retrieve(size_t len)\n       {\n           if(len < readableBytes())//只读取了可读缓冲区数据的一部分\n           {\n               m_readerIndex += len;\n           }\n           else\n           {\n               retrieveAll();\n           }\n       }\n       void retrieveAll()\n       {\n           m_readerIndex = m_writerIndex = kCheapPrepend;\n       }\n       std::string retrieveAsString(size_t len)\n       {\n           std::string result(peek(), len);\n           retrieve(len);\n           return result;\n       }\n       std::string retrieveAllAsString()\n       {\n           return retrieveAsString(readableBytes());\n       }\n   ```\n\n5. ensureWritableByte - 确保buffer可写空间大小足够len，不足则扩容\n   ```cpp\n   public:\n       void ensureWritableBytes(size_t len)\n       {\n           if(writableBytes() < len)\n           {\n               makeSpace(len);\n           }\n       }\n   ```\n\n6. makeSpace - 扩容\n   ```cpp\n   private:\n       void makeSpace(size_t len)\n       {\n           if(writableBytes()+prependableBytes()-kCheapPrepend < len)\n           {\n               m_buffer.resize(m_writerIndex + len);\n           }\n           else//move readable data to the front to make space\n           {\n               size_t readable = readableBytes();\n               //将m_readerIndex到m_writerIndex的内容复制到kCheapPrepend处\n               std::copy(begin() + m_readerIndex, begin() + m_writerIndex, begin() + kCheapPrepend);\n               m_readerIndex = kCheapPrepend;\n               m_writerIndex = m_readerIndex + readable;\n           }\n       }\n   ```\n\n7. append\n   ```cpp\n   public:\n       void append(const char * data, size_t len)\n       {\n           ensureWritableBytes(len);\n           std::copy(data, data+len, beginWrite());\n           m_writerIndex += len;\n       }\n   ```\n\n8. readFd - 从fd上读取数据\n   ```cpp\n   public:\n       ssize_t readFd(int fd, int * saveErrno);\t//在.cc文件中实现\n   ```\n   \n\n### 代码实现\n\n1. readFd - 从fd上读取数据\n\n   1. Poller默认工作在LT模式\n\n   2. Buffer缓冲区是有大小的，但从fd上读数据却不清楚数据有多少。\n\n   3. 此函数使用了系统调用`readv`。\n\n   4. struct iovec结构 - `iov_base`指向缓冲区首址；`iov_len`是缓冲区的长度。网络编程中可以使用此工具，创建一个`struct iovec iov[2]`，第一个的`iov_base`指向tcp连接底层的缓冲区，第二个的`iov_base`指向额外的缓冲区，以备使用。如果使用到额外的缓冲区，在readv完毕后，把额外缓冲区内容拼接到tcp底层缓冲区尾部即可。\n      ```cpp\n      struct iovec\n      {\n          void * iov_base;\n          size_t iov_len;\n      }\n      ```\n\n   \n   ```cpp\n   #include\"buffer.h\"\n   #include<sys/uio.h>\n   ssize_t Buffer::readFd(int fd, int * savedErrno)\n   {\n       char extrabuf[65536] = {0};\t//栈上内存空间\n       struct iovec iov[2];\n       const size_t writable = writableBytes();//buffer底层缓冲区剩余的可写空间大小\n       iov[0].iov_base = begin() + m_writerIndex;\n       iov[0].iov_len = writable;\n       iov[1].iov_base = extrabuf;\n       iov[1].iov_len = sizeof extrabuf;\n       const int iovcnt = (writable < sizeof extrabuf) ? 2 : 1;\n       //如果可写空间大小少于64kb则可以按需写到vec[0]/vec[1];\n       //如果可写空间大小大于等于64kb则只能写到vec[0]。\n       //说明, 可收到的数据大小限制至少为64kb。\n       const ssize_t n = ::readv(fd, iov, iovcnt);\n       if(n < 0)\n       {\n           *savedErrno = errno;\n       }\n       else if(n <= writable)\n       {\n           m_writerIndex += n;\n       }\n       else// n > writable, 需要拼接extrabuf\n       {\n           m_writerIndex = m_buffer.size();\n           append(extrabuf, n-writable);\n       }\n       return n;\n   }\n   ```\n   \n\n## TcpConnection\n\n```cpp\nclass TcpConnection : noncopyable, public std::enable_shared_from_this<TcpConnection>\n```\n\n### 成员变量\n\n1. `m_loop` - subLoop\n\n   ```cpp\n   private:\n       EventLoop *m_loop;\n   ```\n\n2. `m_socket`/`m_channel` - `unique_ptr`管理\n\n   ```cpp\n   private:\n       std::unique_ptr<Socket>  m_socket;\n       std::unique_ptr<Channel> m_channel;\n   ```\n\n3. `m_localAddr`/`m_peerAddr` - 本地/对端地址信息\n\n   ```cpp\n   private:\n       const InetAddress m_localAddr;\n       const InetAddress m_peerAddr;\n   ```\n\n4. `m_inputBuffer`/`m_outputBuffer` - 读写缓冲区\n\n   ```cpp\n   private:\n       Buffer m_inputBuffer;\n       Buffer m_outputBuffer;\n   ```\n\n5. 各种标志\n\n   1. `m_name`\n   2. `m_state` - atomic，用枚举类变量赋值\n   3. `m_reading`\n   4. `m_highWaterMark` - 高水位阈值\n\n   ```cpp\n   private:\n       const std::string m_name;\n       \n       enum StateE {kDisconnected, kConnecting, kConnected, kDisconnecting};\n       std::atomic_int m_state;\n       \n       bool m_reading;\n       \n       size_t m_highWaterMark;\n   ```\n\n6. 各种回调\n   ```cpp\n   private:\n       ConnectionCallback\t    m_connectionCallback;\n       MessageCallback\t        m_messageCallback;\n       WriteCompleteCallback   m_writeCompleteCallback;\n       HighWaterMarkCallback   m_highWaterMarkCallback;\n       CloseCallback           m_closeCallback;\n   ```\n\n\n### 成员函数\n\n1. 构造/析构\n   ```cpp\n   public:\n       TcpConnection(EventLoop *loop, const std::string& name, int sockfd,\n                     const InetAddress& localAddr, const InetAddress& peerAddr);\n       ~TcpConnection();\n   ```\n\n2. 建立/销毁连接\n   ```cpp\n   public:\n       void connectEstablished();\n       void connectDestoryed();\n   ```\n\n3. send - 发送数据\n\n   ```cpp\n   private:\n       void send(const std::string &buf);\n       void send(const void * data, int len);\n   ```\n\n4. shutdown - 关闭连接\n   ```cpp\n   public:\n       void shutdown();\n   private:\n       void shutdownInLoop();\n   ```\n   \n5. 设置回调\n   ```cpp\n   public:\n       void setConnectionCallback(const ConnectionCallback & cb)\n       {\n           m_connectionCallback = cb;\n       }\n       void setMessageCallback(const MessageCallback & cb)\n       {\n           m_messageCallback = cb;\n       }\n       void setWriteCompleteCallback(const WriteCompleteCallback & cb)\n       {\n           m_writeCompleteCallback = cb;\n       }\n       void setCloseCallback(const CloseCallback &cb)\n       {\n           m_closeCallback = cb;\n       }\n       void setHighWaterMarkCallback(const HighWaterMarkCallback & cb, size_t highWaterMark)\n       {\n           m_highWaterMarkCallback = cb;\n           m_highWaterMark = highWaterMark;\n       }\n   ```\n   \n6. 设置、判断标志\n\n   ```cpp\n   public:\n       bool connected() const {return m_state == kConnected;}\n       void setState(StateE state) {m_state = state;}\n   ```\n\n7. 获取属性\n\n   ```cpp\n   public:\n       EventLoop * getLoop() const {return m_loop;}\n       const std::string& name() const {return m_name;}\n       const InetAddress& localAddress() const {return m_localAddr;}\n       const InetAddress& peerAddress() const {return m_peerAddr;}\n   ```\n\n8. handleRead/handleWrite/handleClose/handleError\n   ```cpp\n   private:\n       void handleRead(Timestamp receiveTime);\n       void handleWrite();\n       void handleClose();\n       void handleError();\n   ```\n\n\n### 代码实现\n\n1. 构造：重要参数 - loop、sockfd、localAddr、peerAddr\n\n   1. 给loop赋值，name起名字\n   2. 赋state为`kConnecting`、reading为`true`\n   3. 以sockfd为参数构造socket，new后赋给智能指针`m_socket`\n   4. 以loop、sockfd为参数构造channel，new后赋给智能指针`m_channel`\n   5. 赋值localAddr、peerAddr\n   6. 赋高水位阈值`m_highWaterMark`为`64*1024*1024`(64M)\n   7. 给`m_channel`设置相应的回调，当poller给channel通知感兴趣的事件发生，则channel会回调相应的操作函数\n   8. 对`m_socket`调用`setKeepAlive`，使TCP启动保活机制\n\n   ```cpp\n   /* 写为static，防止函数名字冲突 */\n   static EventLoop* CheckLoopNotNull(EventLoop* loop)\n   {\n       if(loop == nullptr)\n       {\n           LOG_FATAL(\"%s:%s:%d mainLoop is null\\n\", __FILE__, __FUNCTION__, __LINE__);\n       }\n       return loop;\n   }\n   TcpConnection::TcpConnection(EventLoop* loop, const std::string &nameArg, int sockfd,\n                                const InetAddress &localAddr, const InetAddress &peerAddr)\n       : m_loop(CheckLoopNotNull(loop)), m_name(nameArg),\n         m_state(kConnecting), m_reading(true),\n         m_socket(new Socket(sockfd)),\n         m_channel(new Channel(loop, sockfd)),\n         m_localAddr(localAddr), m_peerAddr(peerAddr),\n         m_highWaterMark(64*1024*1024) //64M\n   {\n       m_channel->setReadCallback(std::bind(&TcpConnection::handleRead, this, _1));\n       m_channel->setWriteCallback(std::bind(&TcpConnection::handleWrite, this));\n       m_channel->setCloseCallback(std::bind(&TcpConnection::handleClose, this));\n       m_channel->setErrorCallback(std::bind(&TcpConnection::handleError, this));\n       LOG_INFO(\"%s [%s] at fd = %d\\n\", __FUNCTION__, m_name.c_str(), sockfd);\n       m_socket->setKeepAlive(true);   //启动TCP保活机制\n   }\n   ```\n\n2. 析构\n   ```cpp\n   TcpConnection::~TcpConnection()\n   {\n       LOG_INFO(\"%s [%s] at fd = %d, state = %d\\n\",\n                 __FUNCTION__, m_name.c_str(), m_channel->fd(), m_state.load());\n   }\n   ```\n\n3. handleRead - 调用`m_inputBuffer`的`readFd`, 读取channel上的消息; 如果有数据则调用`m_messageCallback`; 如果返回值为0说明客户端断开, 调用`handleClose`; 如果出错则`handleError`;\n   ```cpp\n   void TcpConnection::handleRead(Timestamp receiveTime)\n   {\n       int savedErrno = 0;\n       ssize_t n = m_inputBuffer.readFd(m_channel->fd(), &savedErrno);\n       if(n > 0)\n       {\n           //已建立连接的用户，有可读事件发生了，调用用户传入的回调操作onMessage\n           m_messageCallback(shared_from_this(), &m_inputBuffer, receiveTime);\n       }\n       else if(n == 0) //客户端断开\n       {\n           handleClose();\n       }\n       else\n       {\n           errno = savedErrno;\n           LOG_ERROR(\"%s\\n\", __FUNCTION__);\n           handleError();\n       }\n   }\n   ```\n\n4. handleWrite - 调用`m_outputBuffer`的`writeFd`, 写到channel上对应fd的缓冲区(调用`peek`, 找到缓冲区数据包中可读数据起始位置, 把从此位置起共`readableBytes()`数据写到fd); 如果成功则调用`m_loop->queueInLoop(std::bind(m_writeCompleteCallback, shared_from_this()))`; 最后, 判断连接的状态如果是`Disconnecting`则`shutdownInLoop`\n   ```cpp\n   void TcpConnection::handleWrite()\n   {\n       if(m_channel->isWriting())\n       {\n           int savedErrno = 0;\n           ssize_t n = m_outputBuffer.writeFd(m_channel->fd(), &savedErrno);\n           if(n > 0)\n           {\n               m_outputBuffer.retrieve(n);\n               if(m_outputBuffer.readableBytes() == 0)\n               {\n                   m_channel->disableWriting();\n                   if(m_writeCompleteCallback)\n                   {\n                       /* 唤醒loop对应的thread线程, 执行回调 */\n                       m_loop->queueInLoop(std::bind(m_writeCompleteCallback,\n                                                     shared_from_this()));\n                   }\n                   if(m_state == kDisconnecting)\n                   {\n                       shutdownInLoop();\n                   }\n               }\n           }\n           else\n           {\n               LOG_ERROR(\"%s\\n\", __FUNCTION__);\n           }\n       }\n       else\n       {\n           LOG_ERROR(\"%s: connection fd = %d is down, no more writing.\\n\",\n                      __FUNCTION__, m_channel->fd());\n       }\n   }\n   ```\n\n5. handleClose - 调用`setState(kDisconnected)`, `m_channel->disableAll()`, `m_connectionCallback`, `m_closeCallback`\n   ```cpp\n   void TcpConnection::handleClose()\n   {\n       LOG_INFO(\"%s: fd = %d, state: %d\\n\", __FUNCTION__, m_channel->fd(), m_state.load());\n       setState(kDisconnected);\n       m_channel->disableAll();\n   \n       TcpConnectionPtr connPtr(shared_from_this());\n       m_connectionCallback(connPtr);\n       m_closeCallback(connPtr);\n   }\n   ```\n\n6. handleError - 调用`getsockopt`, 调查fd的错误, 如果连getsockopt也失败则存储全局errno\n\n   * `int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen)`: 操作套接字选项时，必须指定选项所在的级别和选项的名称, `SOL_SOCKET`表示在套接字API级别, 参见`getprotoent(3)`; 参数`optval`和`optlen`对于getsockopt(), 标识一个缓冲区，请求选项的值将在其中返回。`optlen`是一个值结果参数，最初包含`optval`指向的缓冲区的大小，并在返回时修改以指示返回值的实际大小。 如果不提供或返回选项值，则`optval`可能为NULL。\n\n   ```cpp\n   void TcpConnection::handleError()\n   {\n       int optval;\n       socklen_t optlen = sizeof optval;\n       int err = 0;\n       if(::getsockopt(m_channel->fd(), SOL_SOCKET, SO_ERROR, &optval, &optlen) < 0)\n       {\n           err = errno;\n       }\n       else\n       {\n           err = optval;\n       }\n       LOG_ERROR(\"%s name: %s - SO_ERROR: %d\\n\", __FUNCTION__, m_name.c_str(), err);\n   }\n   ```\n\n7. send - 用户会给TcpServer注册onMessageCallback, 已建立连接的用户有读写事件时, 尤其是读事件, onMessage会响应; 处理完客户端发来的事件后(onMessageCallback), 服务端会send给客户端回发消息; \n\n   > 在TcpConnection的成员中, 有两个Buffer成员; \n   >\n   > 1. inputBuffer - 接收数据的缓冲区 - 即recv操作需要暂存的区域\n   > 2. outputBuffer - 发送数据的缓冲区 - 即send操作需要暂存的区域\n   >\n   > 其中, outputBuffer存在的意义?\n   >\n   > 1. 应用层可能需要处理很多数据, 数据从传输层到网络层到数据链路层的传输往往比应用层发送得快; 需要用缓冲区暂存; \n   > 2. 为了防止应用层与底层传输的数据量差距悬殊导致数据丢失, 设置了一个高水位阈值; \n\n   > 收发数据的方式: 本项目的数据收发统一使用json或protobuf格式化的字符串进行, 所以此send函数的参数为了方便起见, 直接规定为string类型; \n\n   1. 判断当前连接的状态是否为connected; \n   2. 判断此loop是否在本thread中, 如果是则调用sendInLoop; 否则runInLoop, 绑定的函数也是sendInLoop; \n\n   ```cpp\n   void TcpConnection::send(const std::string &buf)\n   {\n       if(m_state == kConnected)\n       {\n           if(m_loop->isInLoopThread())\n           {\n               sendInLoop(buf.c_str(), buf.size());\n           }\n           else\n           {\n               m_loop->runInLoop(std::bind(&TcpConnection::sendInLoop,\n                                 this, buf.c_str(), buf.size()));\n           }\n       }\n   }\n   ```\n\n8. sendInLoop - 写数据操作, 结合了sendInLoop和handleWrite\n   ```cpp\n   void TcpConnection::sendInLoop(const void * data, size_t len)\n   {\n       ssize_t nwrote = 0;\n       size_t remaining = len;\n       bool faultError = false;\t//记录是否产生错误\n       if(m_state == kDisconnected)\n       {\n           LOG_ERROR(\"Disconnected, give up writing!\");\n           return;\n       }\n       /** \n        * m_channel->isWriting()为false表示channel第一次开始写数据, \n        * readableBytes()为0说明缓冲区没有待发送数据; \n        */\n       if(!m_channel->isWriting() && m_outputBuffer.readableBytes() == 0)\n       {\n           nwrote = ::write(m_channel->fd(), data, len);\n           if(nwrote >= 0)\n           {\n               remaining = len - nwrote;\n               if(remaining == 0 && m_writeCompleteCallback)\n               {\n                   //如果此时数据全部发送完毕, 不用再给channel设置epollout事件\n                   m_loop->queueInLoop(std::bind(m_writeCompleteCallback, shared_from_this()));\n               }\n           }\n           else //nwrote < 0\n           {\n               nwrote = 0;\n               if(errno != EWOULDBLOCK)\n               {\n                   LOG_ERROR(\"%s\\n\", __FUNCTION__);\n                   if(errno == EPIPE || errno == ECONNRESET)// SIGPIPE or RESET\n                   {\n                       faultError = true;\n                   }\n               }\n           }\n       }\n       if(!faultError && remaining > 0)//没有出错, 没有发送完毕, 剩余数据需要存到缓冲区, 然后给channel注册epollout事件, LT模式, poller发现tcp的发送缓冲区有空间, 会通知相应的sock->channel, 调用writeCallback方法, 即调用handleWrite, 直到把发送缓冲区中数据全部发送\n       {\n           size_t oldlen = m_outputBuffer.readableBytes();\n           if(oldlen + remaining >= m_highWaterMark && oldlen < m_highWaterMark && m_highWaterMarkCallback)\n           {\n               m_loop->queueInLoop(std::bind(m_highWaterMarkCallback, shared_from_this(), oldlen+remaining));\n           }\n           m_outputBuffer.append((char*)data+nwrote, remaining);//data+nworte即剩余的位置\n           if(!m_channel->isWriting())//m_channel->isWriting()为false表示channel第一次开始写数据, 之前没有注册epollout, 现在需要注册\n           {\n               m_channel->enableWriting();\n           }\n       }\n   }\n   ```\n\n9. connectEstablished\n\n   1. setState为kConnected;\n   2. 调用`m_channel->tie`, 让`m_channel`绑定一个TcpConnection, 方便后期观察TcpConnection是否还有效, 若已失效将不进行相应的操作, 已然无意义;\n\n   ```cpp\n   void TcpConnection::connectEstablished()\n   {\n       setState(kConnected);\n       m_channel->tie(shared_from_this());\n       m_channel->enableReading();\t//向poller注册channel的epollin事件\n       //有新连接建立, 调用connectionCallback\n       m_connectionCallback(shared_from_this());\n   }\n   ```\n\n10. connectDestroyed\n\n    1. 判断state是否为connected, 若是则setState为kDisconnected, 并调用`m_channel->disableAll()`, 调用`connectionCallback`\n    2. 最后`m_channel->remove()`, 把channel从poller中删除掉\n\n    ```cpp\n    void TcpConnection::connectDestoryed()\n    {\n        if(m_state == kConnected)\n        {\n            setState(kDisconnected);\n            m_channel->disableAll();\n            m_connectionCallback(shared_from_this());\n        }\n        m_channel->remove();\n    }\n    ```\n\n11. shutdown/shutdownInLoop\n\n    * 关闭写端, 将会触发epollhup, 调用closeCallback, 即TcpConnection中的handleClose方法,\n      1. setState(kDisconnected)\n      2. m_channel->disableAll()\n      3. connectionCallback, closeCallback\n\n    ```cpp\n    void TcpConnection::shutdown()\n    {\n        if(m_state == kConnected)\n        {\n            setState(kDisconnecting);\n            m_loop->runInLoop(std::bind(&TcpConnection::shutdownInLoop, this));\n        }\n    }\n    /**\n     * 关闭写端, 将会触发epollhup, \n     * 会调用closeCallback, \n     * 即TcpConnection中的handleClose方法,\n     * handleClose将会: \n     *  1. setState(kDisconnected);\n     *  2. m_channel->disableAll();\n     *  3. connectionCallback, closeCallback\n     */\n    void TcpConnection::shutdownInLoop()\n    {\n        if(!m_channel->isWriting())//说明outputBuffer中的数据已经全部发送完成\n        {\n            m_socket->shutdownWrite();//关闭写端, 将会触发epollhup, 会调用closeCallback, 即TcpConnection中的handleClose方法\n        }\n    }\n    ```\n\n# TcpServer收尾\n\n1. newConnection - 运行在主线程当中，主线程的mainLoop调用此函数，选择了一个ioLoop，**在非子loop的线程中（即当前是在mainThread）执行cb，就需要唤醒子loop所在线程（subThread），执行cb**，即调用subLoop的`queueInLoop(cb)`。\n\n   1. 根据轮询算法选择一个subLoop，即调用`m_threadPool->getNextLoop()`\n   2. 唤醒subLoop\n   3. 把当前connfd封装成channel分发给subloop\n\n   ```cpp\n   void TcpServer::newConnection(int sockfd, const InetAddress &peerAddr)\n   {\n       EventLoop *ioLoop = m_threadPool->getNextLoop();\n       char buf[64] = {0};\n       snprintf(buf, sizeof buf, \"-%s#%d\", m_IPport.c_str(), m_nextConnId)\n   }\n   ```\n\n2. removeConnection/removeConnectionInLoop\n   ```cpp\n   void TcpServer::removeConnection(const TcpConnectionPtr &conn)\n   {\n       m_loop->runInLoop(std::bind(&TcpServer::removeConnectionInLoop, this, conn));\n   }\n   void TcpServer::removeConnectionInLoop(const TcpConnectionPtr &conn)\n   {\n       LOG_INFO(\"%s [%s] - connection %s\\n\",\n                __FUNCTION__, m_name.c_str(), conn->name().c_str());\n       m_connections.erase(conn->name());\n       EventLoop *ioLoop = conn->getLoop();\n       ioLoop->queueInLoop(std::bind(&TcpConnection::connectDestoryed, conn));\n   }\n   ```\n\n\n# 流程\n\n1. TcpServer -> Acceptor -> 有一个新用户连接，通过accept函数得到connfd\n2. 用户给TcpServer设置回调 -> TcpServer给TcpConnection设置回调 -> TcpConnection把回调传给Channel -> Channel注册到Poller中 -> Poller通知Channel调用回调\n3. mainLoop中的acceptor是一个特殊的socketfd, 它只有一个回调`ReadCallback`, 负责监听新用户的连接, 返回socket, 将这个socket打包成TcpConnection, 再注册相应的回调; \n","categories":["项目","muduo"]},{"title":"CAS_原子操作","url":"/多线程/CAS_原子操作/","content":"# 内容\n\n1. CAS原理\n2. 原子操作\n3. 栈\n4. 汇编层面\n# CAS\n\nCAS(compare And Swap)也叫比较交换，是一种无锁原子算法，映射到操作系统就是一条cmpxchg硬件汇编指令(**保证原子性**)，其作用是让CPU将内存值更新为新值，但是有个条件，内存值必须与期望值相同，并且CAS操作**无需用户态与内核态切换，直接在用户态对内存进行读写**操作(意味着不会阻塞/线程上下文切换)。\n\n它包含3个参数CAS(V，E，N) ，**V表示待更新的内存值，E表示预期值**，N表示新值，当V值等于E值时，才会将V值更新成N值，如果V值和E值不等，不做更新，这就是一次CAS的操作。\n\n![image-20220527162619434](../../images/原子操作/image-20220527162619434.png)\n\n# 链栈\n\n```cpp\n#include<mutex>\n#include<thread>\ntemplate<class T>\nclass Stack\n{\nprivate:\nstruct StackNode\n{\n\tT data;\n\tStackNode* next;\n};\nStackNode* Buynode()\n{\n\tStackNode* s = (StackNode*)malloc(sizeof(StackNode));\n\tif (NULL == s)exit(1);\n\tmemset(s, 0, sizeof(StackNode));\n\treturn s;\n}\nvoid Freenode(StackNode* pnode)\n{\n\tfree(pnode);\n}\nprivate:\n\tStackNode* base;\n\tsize_t cursize;\n\t//mutable std::mutex mtx;\n\tmutable std::recursive_mutex mtx;\n\tStack(const Stack&) = delete;\n\tStack& operator=(const Stack&) = delete;\npublic:\n\tStack()\n\t\t:base(nullptr), cursize(0)\n\t{\n\n\t}\n\t~Stack()\n\t{\n\t\tclear();\n\t}\n\tvoid clear()\n\t{\n\t\tstd::lock_guard<std::recursive_mutex> locker(mtx);\n\t\twhile (base != nullptr)\n\t\t{\n\t\t\tStackNode* q = base;\n\t\t\tbase = q->next;\n\t\t\t(&(q->data))->~T();\n\t\t\tFreenode(q);\n\t\t\tcursize -= 1;\n\t\t}\n\t}\n\tvoid push(const T& x)\n\t{\n\t\tstd::lock_guard<std::recursive_mutex> locker(mtx);\n\t\tStackNode* s = Buynode();\n\t\tnew(&(s->data)) T(x);\t//定位new构造对象\n\t\ts->next = base;\n\t\tbase = s;\n\t\tcursize += 1;\n\t}\n\tconst T& top() const\n\t{\n\t\tstd::lock_guard<std::recursive_mutex> locker(mtx);\n\t\treturn base->data;\n\t}\n\tT& top()\n\t{\n\t\tstd::lock_guard<std::recursive_mutex> locker(mtx);\n\t\treturn base->data;\n\t}\n\tvoid pop()\n\t{\n\t\tstd::lock_guard<std::recursive_mutex> locker(mtx);\n\t\tif (base != nullptr)\n\t\t{\n\t\t\tStackNode* q = base;\n\t\t\tbase = q->next;\n\t\t\t(&(q->data))->~T();\t//定位析构\n\t\t\tFreenode(q);\n\t\t\tcursize -= 1;\n\t\t}\n\t}\npublic:\n\tsize_t get_size() const\n\t{\n\t\tstd::lock_guard<std::recursive_mutex> locker(mtx);\n\t\treturn cursize;\n\t}\n\tbool is_empty() const\n\t{\n\t\tstd::lock_guard<std::recursive_mutex> locker(mtx);\n\t\treturn get_size() == 0;\n\t}\n};\n#define _TEST1\n#ifdef _TEST1\n#include<iostream>\n#include<thread>\nvoid thread_funa(Stack<int>& s)\n{\n\tfor (int i = 1; i <= 10; i += 2)\n\t{\n\t\tstd::cout << i << std::endl;\n\t\ts.push(i);\n\t}\n}\nvoid thread_funb(Stack<int>& s)\n{\n\tfor (int i = 2; i <= 10; i += 2)\n\t{\n\t\tstd::cout << i << std::endl;\n\t\ts.push(i);\n\t}\n}\nint main()\n{\n\tStack<int> ist;\n\tstd::thread tha(thread_funa, std::ref(ist));\n\tstd::thread thb(thread_funb, std::ref(ist));\n\n\ttha.join();\n\tthb.join();\n\tstd::cout << \"push over.\" << std::endl;\n\twhile (!ist.is_empty())\n\t{\n\t\tint val = ist.top();\n\t\tstd::cout << val << std::endl;\n\t\tist.pop();\n\t}\n}\n#endif\n```\n\n结果\n\n```\n12\n\n43\n\n65\n\n87\n\n109\n\npush over.\n9\n10\n7\n8\n5\n6\n3\n4\n1\n2\n```\n\n# 标准库原子操作API\n\n## 构造函数\n\n原型：`std::atomic<T>::atomic`\n\n```cpp\natomic() noexcept = default;\nconstexpr atomic() = noexcept(std::is_nothrow_default_constructible_v<T>);\nconstexpr atomic(T desired) noexcept;\natomic(const atomic&) = delete;\n```\n\n有默认无参构造；拷贝构造删除。\n\n## operator=\n\n```cpp\nT operator=(T desired) noexcept;\nT operator=(T desired) volatile noexcept;\natomic& operator=(const atomic&) = delete;\natomic& operator=(const atomic&) volatile = delete;\n```\n\n两个原子对象之间不可相互赋值。\n\n### 代码示例\n\n```cpp\n#include<atomic>\nint main()\n{\n    atomic<int> iat;\n    atomic<int> iat2;\n    //iat = iat2; //error\n    iat = 10;\n}\n```\n\n## load\n\n原子地加载并返回原子对象的当前值。安装order的值影响内存。\n\n```cpp\nT load(std::memory_order order = std::memory_order_seq_cst) const noexcept;\nT load(std::memory_order order = std::memory_order_seq_cst) const volatile noexcept;\n参数：\n    order\t- 强制的内存顺数\n返回值：\n    原子变量的当前值\n```\n\n\n\n```cpp\n#include<atomic>\nint main()\n{\n    atomic<int> iat;\n    atomic<int> iat2;\n    iat = 10;\n    int val = iat.load();\n}\n```\n\n存在的问题：\n\n语义是获取原子对象的值没错，但是获取的此值只作为当时的瞬时值。\n\n在多线程中，可能获得的是脏数据。\n\n## compare_exchange\n\n有两个函数。`compare_exchange_weak`、`compare_exchange_strong`。\n\n原子地比较原子对象与的非原子参数的值，若相等进行交换，若不相等则进行加载。\n\n```cpp\nbool compare_exchange_weak(T & expected, T desired, std::memory_order order = std::memory_order_seq_cst) noexcept;\n参数：\n\texpected - 到期待在原子对象中找到的值的引用。若比较失败则被存储*this的实际值。\n\tdesired  - 若符合期待则存储于原子对象的值\n\tsuccess  - 若比较成功,则读修改写操作所用的内存同步顺序。容许所有值。\n\tfailure  - 若比较失败,则加载操作所用的内存同步顺序。不能为std::memory_order_release或std::memory_order_acq_rel，且不能指定强于success 的顺序(C++17前)\n    order \t - 两个操作所用的内存同步顺序\n返回值：\n\t若成功更改底层原子值则为true，否则为false\n```\n\n原子地比较`*this`原子对象与`expected`的`对象表示(C++20前) | 值表示(C++20起)`，而若它们逐位相等则以`desired`替换前者（进行读修改写操作）。否则，将`*this`中的实际值加载进`expected`（进行加载操作）。\n\n读修改写和加载操作的内存模型分别为`success`和`failure`。在上面这个函数中，order用于读修改写操作和加载操作，除了若`order == std::memory_order_acq_rel`或`order== std::memory_order_release`，则加载操作分别使用`std::memory_order_acquire`和`std::memory_order_relaxed`。\n\n# 改写链栈\n\n```cpp\n#include<mutex>\n#include<thread>\ntemplate<class T>\nclass Stack\n{\nprivate:\nstruct StackNode\n{\n\tT data;\n\tStackNode* next;\n};\nStackNode* Buynode()\n{\n\tStackNode* s = (StackNode*)malloc(sizeof(StackNode));\n\tif (NULL == s)exit(1);\n\tmemset(s, 0, sizeof(StackNode));\n\treturn s;\n}\nvoid Freenode(StackNode* pnode)\n{\n\tfree(pnode);\n}\nprivate:\n\tmutable std::atomic<StackNode*> pHead;\n\tStack(const Stack&) = delete;\n\tStack& operator=(const Stack&) = delete;\npublic:\n\tStack()\n\t\t:pHead(nullptr)\n\t{\n\n\t}\n\t~Stack()\n\t{\n\t\t\n\t}\n    void push(const T& val)\n    {\n        StackNode * newnode = Buynode();\n        new(&(newnode->data)) T(val);\n        newnode->next = pHead;\n        pHead = newnode;\n    }\n};\nint main()\n{\n    Stack<int> ist;\n    \n}\n```\n\n对`newnode->next = pHead; pHead = newnode;`进行原子化。\n即转为：`while(!pHead.compare_exchange_weak(newnode->next, newnode));`\n\n```cpp\n    void push(const T& val)\n    {\n        StackNode * newnode = Buynode();\n        new(&(newnode->data)) T(val);\n        \n        newnode->next = pHead.load();\n        while(!pHead.compare_exchange_weak(newnode->next, newnode));\n    }\n```\n\n判断`pHead`是否等于`newnode->next`，如果相等，则把`newnode`赋值给`pHead`。\n","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"Linux线程调度策略","url":"/多线程/Linux线程调度策略/","content":"# 内容\n\n1. 先来先服务（FIFO）调度策略\n2. 时间片轮转调度策略\n3. 分时调度策略\n# Linux内核线程的三种调度策略\n\n函数`pthread_attr_setschedpolicy`和`pthread_attr_getschedpolicy`分别用来设置、获取线程的调度策略。\n\n```c\nint pthread_attr_setschedpolicy(pthread_attr_t *, int policy);\nint pthread_attr_getschedpolicy(const pthread_attr_t *, int policy);\n参数：\n    attr \t- 线程属性变量\n    policy\t- 调度策略\n返回值\n    成功返回0，失败返回-1\n```\n\n1. `SCHED_OTHER`：分时调度策略，非实时。不支持优先级。\n2. `SCHED_FIFO`：先到先服务，实时。一旦占用cpu则一直运行。直到有更高优先级任务或主动放弃cpu。\n3. `SCHED_RR`：时间片轮转，实时。当进程的时间片用完，重新分配时间片长度，置于就绪队列尾。可以看作是FIFO的延伸。\n\n# 先到先服务策略\n\n1. 创建进程时指定采用FIFO，并设置**实时优先级**`rt_priority`(1-99)。\n2. 如果没有等待资源，则将该任务加入到就绪队列中。\n3. 调度程序遍历就绪队列，根据**实时优先级**计算调度权值(`1000+rt_priority`)，选择权值最高的任务使用cpu，**该FIFO任务将一直占有cpu直到有优先级更高的任务就绪**(即使优先级相同也不行)**或者主动放弃(等待资源)**。\n4. 调度程序发现有优先级更高的任务到达(高优先级任务可能被中断或定时器任务唤醒，再或被当前运行的任务唤醒等等)，则调度程序立即在当前任务堆栈中保存当前cpu寄存器的所有数据，重新从高优先级任务的堆栈中加载寄存器数据到cpu，此时高优先级的任务开始运行。重复第3步。\n5. 如果当前任务因等待资源而主动放弃cpu使用权，则该任务将从就绪队列中删除，加入等待队列，此时重复第3步。\n\n# 时间片轮转策略\n\n所有任务都采用RR调度策略时：\n\n1. 创建任务时指定调度参数为RR，并设置任务的**实时优先级**和**nice值**(nice值将会转换为该任务的时间片的长度)。\n\n   > 可见，相比于FIFO，时间片轮转法多了一个nice值，用于计算时间片长度。\n\n2. 如果没有等待资源，则将该任务加入到就绪队列中。\n\n3. 调度程序遍历就绪队列，根据**实时优先级**计算调度权值(`1000+rt_priority`)，**选择权值最高**的任务使用cpu。\n\n   > 相比于FIFO，FIFO会一直占用CPU，直到更高优先级线程到达。\n\n4. 如果就绪队列中的RR任务**时间片为0，则会根据nice值设置该任务的时间片，同时将该任务放入就绪队列的末尾**。重复步骤3。\n\n5. 当前任务由于等待资源而主动退出cpu，则其加入等待队列中。重复步骤3。\n\n# 分时调度策略\n\n所有任务都采用Linux分时调度策略时：\n\n1. 创建任务指定采用分时调度策略，并指定nice值(`-20~19`, 可以认为值越小优先级越高)。\n\n   > 相比于FIFO，没有**实时优先级**数值属性(1~99)\n\n2. 将**根据每个任务的nice值确定在cpu上的执行时间**(counter)。\n\n3. 如果没有等待资源，则将该任务**加入到就绪队列**中。\n\n4. 调度程序**遍历就绪队列**中的任务，通过对每个任务动态优先级的计算权值(`counter+20-nice`)结果，选择计算结果最大的一个去运行，当这个时间片用完后(`counter减至0`)或者主动放弃cpu时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃cpu)中。\n\n5. 此时调度程序重复上面计算过程，转到第4步。\n\n6. 当调度程序发现所有就绪任务计算所得的权值都`不大于0时`，重复第2步。\n\n# 区别\n\n系统中既有分时调度，又有时间片轮转调度和先进先出调度：\n\n1. RR调度和FIFO调度的进程属于实时进程，以分时调度的进程是非实时进程。\n2. 当实时进程准备就绪后，如果当前cpu正在运行非实时进程，则实时进程立即抢占非实时进程。\n3. RR进程和FIFO进程**都采用实时优先级**做为调度的**权值标准**，RR是FIFO的一个延伸。\n4. FIFO时，如果两个进程的优先级一样，则这两个优先级一样的进程具体执行哪一个是由其在队列中的未知决定的，这样导致一些不公正性（优先级是一样的，为什么要让你一直运行？），如果将两个优先级一样的任务的调度策略都设为RR，则保证了这两个任务可以循环执行，保证了公平。","categories":["操作系统","多线程","Linux"]},{"title":"Linux_IO复用_epoll","url":"/Linux/Linux_IO复用_epoll/","content":"\n# 内容\n\n1. 基本概念\n6. epoll\n\n# epoll\n\nepoll是Linux特有的I/O复用函数。\n\nepoll的使用实际上不是单独的API，而是有一组函数来完成。三个函数。\n\n## API\n\n```c\n#include<sys/epoll.h>\nint epoll_create(int size);\t//创建内核时间表，用于存放描述符和事件\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n```\n\n1. epoll\\_create()：创建内核事件表，存放描述符和事件，红黑树。\n2. epoll\\_ctl()：添加、移除描述符，每个描述符只需要添加一次。\n3. epoll\\_wait()：获取已就绪的描述符，复杂度`O(1)`\n\n内核怎么样实现`O(1)`？：注册回调函数的方式\n\n## epoll_create\n\nepoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传描述符集或事件集。\n\n但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。\n\n这个文件描述符就是使用`epoll_create`函数来创建。\n\n```c\nint epoll_create(int size);\n```\n\n只有一个参数`size`，但是实际上这个参数并不起作用，只是给内核一个提示，告诉他事件表大概需要多大。\n\n函数返回值为对应这个事件表的一个文件描述符。其他所有epoll系统调用的第一个参数将使用该返回值，以指定要访问的内核事件表。\n\n## epoll_ctl\n\n```c\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n// epoll_ctl成功时返回0，失败则返回-1并设置errno。\n```\n\n1. 参数`epfd`是`epoll_create`返回值。\n\n2. 参数`op`指定操作类型。操作类型有如下3种：\n\n   1. `EPOLL_CTL_ADD`，往事件表中注册fd上的事件；\n   2. `EPOLL_CTL_MOD`，修改fd上的注册事件；\n   3. `EPOLL_CTL_DEL`，删除fd上的注册事件；\n\n3. 参数`fd`是要操作的文件描述符\n\n4. 参数`event`指定事件，它是`epoll_event`结构指针类型\n\n   1. `epoll_event`的定义如下\n\n      ```c\n      struct epoll_event\n      {\n          __uint32_t events;\t/* epoll事件, 和poll类似，前加E*/\n          epoll_data_t data;\t/* 用户数据 */\n      }\n      ```\n\n      1. 结构体中成员`events`描述事件类型。epoll支持的事件类型与poll基本相同。表示epoll事件类型的宏是在poll对应的宏前加上\"E\"，比如数据可读事件是`EPOLLIN`。但epoll有两个额外的事件类型——`EPOLLET`和`EPOLLONESHOT`，这俩事件往往对应epoll的高效运作模式。\n\n      2. data成员用于存储用户数据。其类型`epoll_data_t`的定义如下：\n         ```c\n         typedef union epoll_data\n         {\n             void * ptr;\n             int fd;\n             uint32_t u32;\n             uint64_t u64;\n         }epoll_data_t;\n         ```\n\n         `epoll_data_t`是一个联合体，其4个成员中：\n\n         1. 使用最多的是`fd`，它指定事件所从属的目标文件描述符。\n         2. 成员`ptr`可用来指定与`fd`相关的用户数据。但由于`epoll_data_t`是一个联合体，不可同时使用`ptr`和`fd`，因此，如果要将文件描述符和用户数据关联起来以实现快速的数据访问的话，只能使用其他手段。比如放弃使用`fd`成员，而在`ptr`指向的用户数据中包含`fd`。\n\n## epoll_wait\n\n在一段超时时间内等待一组文件描述符上的事件。\n\n```c\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n// 成功返回就绪的文件描述符的个数，失败则返回-1并设置errno\n```\n\n`epoll_wait`函数如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指出）中复制到它的第二个参数`events`指向的数组中。这个数组只用于用户接收内核检测到的就绪事件，而不像select/poll的数组参数那样拷贝来拷贝去。极大地提高了应用程序索引就绪文件描述符的效率。\n\n参数`maxevents`指定最多监听多少个事件，必须大于0。\n\n参数`timeout`含义与`poll`接口的`timeout`参数相同，都是指定超时值，单位是`毫秒`。当设置为`-1`时，`poll`调用讲永远阻塞直到某个事件发生；当设置为`0`时`poll`调用将立即返回。\n\n### 与poll的代码差异\n\n```c\nint ret = poll(fds, MAX_EVENT_NUMBER, -1);\nfor(int i = 0; i<MAX_EVENT_NUMBER, ++i)\n{\n    if(fds[i].revents & POLLIN)\n    {\n        int sockfd = fds[i].fd;\n        /* 处理sockfd */\n    }\n}\n//以上为poll\n-----------------------------------------------------\n//以下为epoll\nint ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);\nfor(int i = 0; i < ret; ++i)\n{\n    int sockfd = events[i].data.fd;\n    /* sockfd肯定就绪，直接处理 */\n}\n```\n\n# 内核事件表\n\nepoll的最大优势在于处理描述符特别多的情况，相比轮询方式：\n\n1. 如果用传统的select、poll单纯的顺序轮询方法监测就绪的描述符，那么性能会很低下的。\n2. 而且虽然select、poll能顺利查出有几个描述符上有事件产生，但是是哪个描述符？并没有告诉我们，所以又得浪费一轮时间来查找产生时间是哪个描述符。\n\n## 数据结构\n\n本质上，是一棵红黑树。\n\n# 思路的转变\n\n相较于select/poll，我们所关心的事件（描述符）表，直接创建于内核态。\n\n# LT/ET模式\n\nepoll对文件描述符的操作有两种模式：LT (Level Trigger, 电平触发)模式和ET (Edge Trigger, 边沿触发)模式。\n\n* LT：有事件就绪后，用户不用立即处理；用户如果没有处理完，还会继续提醒\n* ET：有事件就绪，只提醒用户一次。下次就没了。\n\n## LT\n\nLT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。\n\n对于采用LT工作模式的文件描述符，当`epoll_wait`检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用`epoll_wait`时，`epoll_wait`还会再次向应用程序通告此事件，直到该事件被处理。\n\n## ET\n\n当往epoll内核事件表中注册一个文件描述符上的`EPOLLET`事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。\n\n而对于采用ET工作模式的文件描述符，当`epoll_wait`检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的`epoll_wait`调用将不再向应用程序通知这一事件。可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。\n\n# LT - 代码示例\n\n```c\n#include<string.h>\n#include<assert.h>\n#include<sys/socket.h>\n#incldue<netinet/in.h>\n#include<arpa/inet.h>\n\n#include<sys/epoll.h>\n\n#define MAX 10\nint socket_init();\nint epoll_add(int epfd, int fd)\n{\n    struct epoll_event ev;\n    ev.data.fd = fd;\n    ev.events = EPOLLIN;//ev.events = EPOLLIN | EPOLLET; 这样可工作在ET模式\n    \n    if(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) == -1)\n    {\n        perror(\"epoll ctl add err\\n\");\n    }\n}\nvoid epoll_del(int epfd, int fd)\n{\n    if(epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL) == -1)\n    {\n        perror(\"epoll ctl del err\\n\");\n    }\n}\nint main()\n{\n    int sockfd = socket_init();\n    assert(sockfd != -1);\n    int epfd = epoll_create(MAX);\n    assert(epfd != -1);\n    \n    epoll_add(epfd, sockfd);//将监听套接字添加到内核事件表\n    struct epoll_event evs[MAX];\n    while(1)\n    {\n        int n = epoll_wait(epfd, evs, MAX, 5000);\t//5000ms\n        if(n == -1)\n        {\n            perror(\"epoll wait err\\n\");\n        }\n        else if(n == 0)\n        {\n            printf(\"time out\\n\");\n        }\n        else\n        {\n            for(int i = 0; i < n; ++i)//每个事件均为就绪状态\n            {\n                int fd = evs[i].data.fd;\n                if(evs[i].events & EPOLLIN)\n                {\n                    if(fd == sockfd)//监听套接字\n                    {\n                        struct sockaddr_in caddr;\n                        int len = sizeof(caddr);\n                        int c = accept(sockfd, (struct sockaddr*)&caddr, &len);\n                        if(c < 0)\n                        {\n                            continue;\n                        }\n                        printf(\"accept c = %d\\n\", c);\n                        \n                        epoll_add(epfd, c);\n                    }\n                    else\t//连接套接字\n                    {\n                        char buff[128] = {0};\n                        int num = recv(fd, buff, 127, 0);\n                        if(num <= 0)//对方关闭 或异常，需要移除\n                        {\n                            //注意不要先close，因为epoll_del需要用到fd描述符。\n                            epoll_del(epfd, fd);\n                            close(fd);\n                            printf(\"client close\\n\");\n                        }\n                        else\n                        {\n                            printf(\"recv(%d)=%s\\n\", fd, buff);\n                            send(fd, \"ok\", 2, 0);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n# ET - 代码示例\n\n主要解决的问题：怎么一次性把描述符上的数据接收完？\n\n1. 描述符设置成非阻塞\n   ```c\n   #include<fcntl.h>\n   int fcntl(int fd, int cmd, ... /* arg */);\n   /* fcntl()可以采用可选的第三个参数。是否需要这个参数由 cmd 决定。\n   所需的参数类型在每个 cmd 名称后面的括号中指示（在大多数情况下，所需的类型是 int，我们使用名称 arg 来标识参数），如果不需要参数，则指定 void。\n   只有特定的 Linux 内核版本才支持某些 cmd 操作。检查主机内核是否支持特定操作的首选方法是使用所需的 cmd 值调用 fcntl()，然后测试调用是否以 EINVAL 失败，表明内核无法识别该值。*/\n   /*\n   For a successful call, the return value depends on the operation:\n   \tF_DUPFD  \tThe new file descriptor.\n   \tF_GETFD  \tValue of file descriptor flags.\n   \tF_GETFL  \tValue of file status flags.\n   \tF_GETSIG \tValue of signal sent when read or write becomes possible, or zero for traditional SIGIO behavior.\n   \t\n   All other commands : Zero.\n   On error, -1 is returned, and errno is set appropriately.\n   */\n   可选的cmd操作（其中之二）：\n   F_GETFL(void)//get file access mode and the file status flags\n   F_SETFL(int)//set file status flags to the value by arg. File access mode and file creation flags in arg are ignored. On Linux, this command can only change the O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, O_NONBLOCK flags. It's not possible to change the O_DSYNC, O_SYNC flags.\n   ```\n\n2. 循环处理（读取）\n   需要判断recv返回值为`-1`时的错误类型（没数据时，非阻塞情况下立即返回`-1`）\n\n   ```\n   返回值\n   如果发生错误，则返回-1，设置errno以指示错误。\n   当流套接字对等点执行了有序关闭时，返回值将为0（传统的“文件结束”返回）。\n   成功则返回接收到的字节数；\n   \n   各种域（例如，UNIX 和 Internet 域）中的数据报套接字允许零长度数据报。当接收到这样的数据报时，返回值为 0。\n   如果从流套接字接收的请求字节数为 0，则也可能返回值 0。\n   \n   错误\n   这些是套接字层产生的一些标准错误。底层协议模块可能会产生和返回额外的错误；查看他们的手册页。\n   \n   EAGAIN 或 EWOULDBLOCK\n   套接字被标记为非阻塞并且接收操作将阻塞，或者已设置接收超时并且在接收数据之前超时已过期。POSIX.1允许在这种情况下返回任一错误，并且不要求这些常量具有相同的值，因此可移植应用程序应检查这两种可能性。\n   \n   EBADF\n   参数 sockfd 是无效的文件描述符。\n   ECONNREFUSED\n   远程主机拒绝允许网络连接（通常是因为它没有运行请求的服务）。\n   EFAULT\n   接收缓冲区指针指向进程地址空间之外。\n   EINTR\n   在任何数据可用之前，接收被信号传递中断；见signal(7)。\n   EINVAL\n   传递了无效的参数。\n   ENOMEM\n   无法为 recvmsg() 分配内存。\n   ENOTCONN\n   套接字与面向连接的协议相关联，并且尚未连接（请参阅connect(2)和 accept(2)）\n   ENOTSOCK\n   文件描述符 sockfd 不引用套接字。\n   ```\n\n* 设置为非阻塞\n\n```c\nvoid setnonblock(int fd)\n{\n    int oldfilestatusflags = fcntl(fd, F_GETFL);\n    int newfilestatusflags = oldfilestatusflags | O_NONBLOCK;\n    if(fcntl(fd, F_SETFL, newfilestatusflags) == -1)\n    {\n        perror(\"fcntl setfl err\\n\");\n    }\n}\nvoid epoll_add(int epfd, int fd)\n{\n    struct epoll_event ev;\n    ev.data.fd = fd;\n    ev.events = EPOLLIN | EPOLLET;\n    if(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) == -1)\n    {\n        perror(\"epoll ctl add err\\n\");\n    }\n    setnonblock(fd);\t//这个操作放在前后不影响，与epoll_ctl独立。\n}\n```\n\n* 循环处理\n\n```c\n#include<errno.h>\nelse\n{\n    while(1)\n    {\n        char buff[128] = {0};\n        int num = recv(fd, buff, 1, 0);\t//1次读1个字节\n        if(num == -1)\n        {\n            if(errno == EAGAIN || errno == EWOULDBLOCK)//没有数据了\n            {\n                send(fd, \"ok\", 2, 0);\n            }\n            else\t\n            {\n                perror(\"recv err\");\n            }\n            break;\n        }\n        else if(num == 0)//对方关闭了\n        {\n            epoll_del(epfd, fd);\n            close(fd);\n            printf(\"client close\\n\");\n            break;\n        }\n        else\t//这一次的recv有数据\n        {\n            printf(\"buff=%s\\n\", buff);\n        }\n    }\n}\n```\n\n","categories":["Linux","网络"]},{"title":"阻塞_非阻塞_同步_异步","url":"/项目/阻塞_非阻塞_同步_异步/","content":"\n# 内容\n\n1. 阻塞\n1. 非阻塞\n1. 同步\n1. 异步\n\n首先应该阐明的是：阻塞、非阻塞、同步、异步描述的都是IO的状态。然后从IO的两个阶段谈。\n\n5. 五种IO模型\n\n# 典型IO的两个阶段\n\n数据准备 - 数据读写\n\n## 例子\n\nrecv，传sockfd、buf、len。数据准备即观察接收缓冲区是否有数据可读。\n\n* 数据未就绪 - 阻塞、非阻塞\n\n当sockfd工作在阻塞模式下，调用recv，如果没有数据就绪，则会阻塞；若sockfd工作在非阻塞模式下，如果没有数据就绪，则立即返回。\n\n如何判断返回的原因？看返回值。以判断是否正常返回。\n\n* 数据就绪 - 同步、异步\n\n应用程序讲内核缓冲区中准备好的数据拷贝到用户空间中的buf缓存区。这个拷贝的过程是需要等待的，等待拷贝完毕应用程序才可以继续向下执行。\n\n异步和同步的方式不一样，需要调用linux提供的异步io接口，`aio_read`、`aio_write`。需要传递`sockfd`、`buf`、`sigio信号(通知方式)`。之后应用程序则立即往后执行其他业务，直到被通知buf的数据已经准备好了，则调用实现绑定的回调函数进行处理。\n\n# 同步/异步\n\n在两个方面都涉及同步/异步。一个方面是**IO同步/异步**，属于上面谈到的。\n\n另一个方面是**业务层面的同步/异步**。\n\n两个方面，角度不同，但思路是一样的，同步是需要自己操心；异步是约定好处理方式，先去忙别的。\n\n**同步**表示A（应用程序）向B（操作系统）请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞（非阻塞的同步类似于忙等待））；**异步**表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。\n\n# 五种IO模型\n\n这里谈的IO是指网络IO。\n\n## 同步阻塞IO\n\n![image-20220522194427303](../../images/阻塞_非阻塞_同步_异步/image-20220522194427303.png)\n\n阻塞指上半段等待准备好数据；同步指需要花费用户应用程序的时间去拷贝数据、处理数据。\n\n## 同步非阻塞IO\n\n![image-20220522194949186](../../images/阻塞_非阻塞_同步_异步/image-20220522194949186.png)\n\n非阻塞指上半段不管数据是否准备好，立即返回；同步指需要花费用户应用程序的时间去拷贝数据、处理数据。\n\n## IO复用\n\n![image-20220522200137240](../../images/阻塞_非阻塞_同步_异步/image-20220522200137240.png)\n\n三种接口都是同步阻塞IO。与上面的区别是，一个线程可以管理多个socket。\n\n## 信号驱动\n\n![image-20220522201543844](../../images/阻塞_非阻塞_同步_异步/image-20220522201543844.png)\n\n等待数据是异步的过程。在数据就绪前，用户应用程序执行其他逻辑；但是数据准备好后，还是得需要用户应用程序自己处理。仍是同步过程。\n\n优点是提供了消息通知机制，减少了系统调用的次数（相比于同步非阻塞的反复调用EAGAIN）\n\n## 异步IO\n\n![image-20220522202459276](../../images/阻塞_非阻塞_同步_异步/image-20220522202459276.png)\n\n```c\nstruct aiocb\n{\n    int \t\t\taio_fildes;\n    off_t \t\t\taio_offset;\n    volatile void *\taio_buf;\n    size_t \t\t\taio_nbytes;\n    int \t\t\taio_reqprio;\n    struct \t\t\tsigevent aio_sigevent;\n    int\t\t\t\taio_lio_opcode;\n}\n```\n\n","categories":["项目","Linux","网络"]},{"title":"高级数据结构_BST","url":"/高级数据结构/高级数据结构_BST/","content":"\n# 二叉树相关概念\n\n1. 根节点\n2. 左孩子、右孩子\n3. 双亲节点（父节点）\n4. 祖先节点\n5. 兄弟节点\n6. 叔叔节点（祖先节点的另一个子节点）\n7. 叶子节点\n8. 左子树、右子树\n9. 二叉树的高度/层数\n\n# BST - 二叉搜索树\n\n对于一棵二叉树，上的每一个节点如果满足`左孩子的值 < 父节点的值 < 右孩子的值`，则称作`BST(Binary Search/Sort Tree)`树，即二叉搜索树（二叉排序树）。\n\n# 二叉搜索树节点的结构\n\n```cpp\ntypedef int KeyType;\ntypedef struct BstNode\n{\n    KeyType key;\n    BstNode * lchild;\n    BstNode * parent;\t//不必要, 但可以大大简化代码\n    BstNode * rchild;\n}BstNode, * BSTree;\n```\n\n# 二叉搜索树的插入\n\n1. BST如果为空，建根。\n2. BST不为空，从根节点进行比较，找到合适位置，生成新节点，新节点的地址赋给父节点的`leftchild/rightchild`。\n\n```cpp\n#include<functional>\t//less<T>\nusing namespace std;\n\ntemplate<typename T, typename Compare=less<T>>\nclass BSTree\n{\nprivate:\n    //节点定义\n    struct Node\n    {\n        Node(T data = T())\n            : data_(data), left_(nullptr), right_(nullptr)\n        {}\n        T data_;\t\t//数据域\n        Node *left_;\t//左孩子域\n        Node *right_;\t//右孩子域\n    };\n    Node *root_;\t\t//指向BST树的根节点\npublic:\n    BSTree()\n        : root_(nullptr)\n    {\n    }\n    ~BSTree()\n    {\n    }\n    //非递归插入操作\n    void n_insert(const T &val)\n    {\n        if(root_ == nullptr)\n        {\n            root_ = new Node(val);\n            return;\n        }\n        \n        Node * parent = nullptr;\n        Node * cur = root_;\n        while(cur != nullptr)\n        {\n            if(val < cur->data_)\n            {\n                parent = cur;\n                cur = cur->left_;\n            }\n            else if(val > cur->data_)\n            {\n                parent = cur;\n                cur = cur->right_;\n            }\n            else //val == cur->data_\n            {\n                //不插入值相同的元素\n                return;\n            }\n        }\n        //把新节点插入到parent节点下\n        if(val < parent->data_)\n        {\n            parent->left_ = new Node(val);\n        }\n        else\n        {\n            parent->right_ = new Node(val);\n        }\n    }\n};\n```\n\n测试\n\n```cpp\nint main()\n{\n    int ar[] = {58, 24, 67, 0, 34, 62, 69, 5, 41, 64, 78};\n    BSTree<int> bst;\n    for(int val : ar)\n    {\n        bst.n_insert(val);\n    }\n    bst.n_insert(12);\n    return 0;\n}\n```\n\n## 更简洁的写法\n\n```cpp\nbool Insert(AVLNode *& tree, KeyType kx)\n{\n    if(tree == nullptr)\n    {\n        tree = MakeRoot(val);\n        return true;\n    }\n    AVLNode * pa = nullptr;\n    AVLNode * p = tree;\n    while(p != nullptr && p->key != kx)\n    {\n        pa = p;\n        p = kx < p->key ? p->leftchild : p->rightchild;\n    }\n    if(p != nullptr && p->key == kx) //已存在重复值\n        return false;\n\n    //把新节点插入到pa下\n    if(val < pa->key)\n    {\n        pa->leftchild = new Node(val);\n    }\n    else\n    {\n        pa->rightchild = new Node(val);\n    }\n    \n}\n```\n\n","categories":["高级数据结构","树"]},{"title":"高级数据结构_二叉树","url":"/高级数据结构/高级数据结构_二叉树/","content":"\n# 内容\n\n1. 树相关概念\n\n## 考点\n\n1. CreateBinaryTree\n2. `NicePreOrder` - 前序遍历、`NiceInOrder` - 中序遍历、`NicePostOrder` - 后序遍历\n3. 二叉树是否是完全二叉树、满二叉树、二叉搜索树、平衡二叉树\n\n## 相关术语及翻译\n\n| 术语     | 英译                |\n| -------- | ------------------- |\n| 先序遍历 | PreOrder Traversal  |\n| 中序遍历 | InOrder Traversal   |\n| 后序遍历 | PostOrder Traversal |\n\n# 树相关概念\n\n三个字来总结：一对多。\n\n树是由`n(n>=0)`个结点组成的有限集合。\n如果`n=0`，称为空树；\n如果`n>0`，则有一个特定的称之为根`(root)`的结点， 它只有直接后继， 但没有直接前驱；\n除根以外的其它结点划分为`m(m>=0)`个互不相交的有限集合$T_0, T_1, T_{m-1}$，每个集合又是一棵树，并且称之为根的**子树(subTree)** 。**每棵子树的根结点有且仅有一个直接前驱**， 但可以有0个或多个直接后继。\n\n1. 节点的度：一个节点含有的子树的个数（直接后继节点）。\n2. 树的度：一棵树中，所有节点的度中的最大值。\n3. 叶节点（终端节点）：度为0的节点。\n4. 非叶节点（分支节点）：度不为0的节点。\n5. 父节点（双亲）：若一个节点含有子节点，则是其子节点的父节点；某节点的直接前驱节点。\n6. 子节点（孩子）：一个节点的字树的根节点（或直接后继节点）。\n7. 兄弟节点：有相同父节点的节点互称为兄弟节点。\n8. 节点的层次：从根开始定义起，**根为第1层**，根的子节点为第2层，以此类推。\n9. 深度：即从根（第1层）到第n层的路径长，根的深度为0。即`层次数-1`。——偏向于层\n10. 高度：从根节点到叶节点的最长路径。当只有根节点时，路径为0即高度为0。——偏向于一条路径\n11. 堂兄弟节点：它们的父节点不同，但它们的父节点在同一层的节点，互为堂兄弟。\n12. 祖先节点：从根到该节点路径上所经过的所有节点；有的解释为爷爷节点。\n\n# 二叉树概念\n\n二叉树的定义：一棵二叉树是节点的一个有限集合，该集合或为空，或为由一个根节点加上两棵分别称为左子树和右子树的互不相交的二叉树组成。\n\n> 从定义可以看出，“二叉树是由二叉树组成的”，属于递归式定义。如果某件事物的本质是递归的，那么我们解决此类事物的方法往往也是递归式的。\n\n## 二叉树的性质\n\n1. 若二叉树的层次从$0$开始，则第$i$层最多有$2^i$个节点$(i\\ge0)$。可用数学归纳法证明。\n2. 高度为$k$的二叉树最多有$2^{k+1}-1$个节点$(k\\ge0)$。可用等比数列求和公式得出。\n3. 对于任何一棵二叉树，如果叶节点个数为$n_0$（$n$的下标表示度数），度为2的非叶节点个数为$n_2$，则有$n_0=n_2+1$。\n\n## 特殊的二叉树\n\n### 满二叉树 - Full Binary Tree\n\n二叉树的每一层的节点数都达到最大值。\n\n![image-20220520153714340](../../images/高级数据结构_二叉树/image-20220520153714340.png)\n\n### 完全二叉树 - Complete Binary Tree\n\n若二叉树的高度为$h$，则共有$h+1$层。除第$h$层外，其他各层`(0 ~ h-1)`的节点数都达到最大个数，第$h$层从右向左**连续缺**0个或若干个节点。满二叉树是一种特殊的完全二叉树。\n\n具有$n$个节点的完全二叉树的高度为$\\lceil\\log_2(n+1)\\rceil-1$。注意，只适于完全二叉树，不适于一般的二叉树。\n\n> 证明：设完全二叉树的高度为$h$，则有\n> $$\n> \\begin{flalign}\n> &~~~~~~2^h-1<n\\le2^{h+1}-1\\\\\n> &\\Leftrightarrow 2^h<n+1\\le2^{h+1}\\\\\n> 取对数&\\Leftrightarrow h<\\log_2(n+1)\\le h+1&\n> \\end{flalign}\n> $$\n\n![image-20220520154516885](../../images/高级数据结构_二叉树/image-20220520154516885.png)\n\n# 中序+前序/后序序列建立二叉树\n\n| 遍历方式 | 步骤                                           |\n| -------- | ---------------------------------------------- |\n| 先序遍历 | 先操作根节点，再遍历左子树，再遍历右子树       |\n| 中序遍历 | 先遍历左子树，返回后再操作根节点，再遍历右子树 |\n| 后序遍历 | 先遍历左子树，再遍历右子树，再操作根节点。     |\n\n\n\n![image-20220520163512650](../../images/高级数据结构_二叉树/image-20220520163512650.png)\n\n如此一棵二叉树。手写出三种方式遍历的序列：\n\n```\n先序遍历：ABCDEFGH\n中序遍历：CBEDFAGH\n后序遍历：CEFDBHGA\n```\n\n我们观察手写出来的先序遍历序列和中序遍历序列，发现规律。\n\n在先序遍历中可以看出，A为根节点，以A为基准，再把目光转向中序遍历，则可以看出以A划分出了`CBEDF`和`GH`，而这也分别对应A节点的左子树和右子树。\n按照这个规律，再看先序遍历，A后面一个是B，以B为基准，再把目光转向中序遍历，则可以看出以B划分出了`C`和`EDF`，而这也分别对应B节点的左子树和右子树。\n......\n因此可以根据中序遍历序列和先序/后序遍历序列的其中一种来复画二叉树逻辑结构。\n\n由此，相应地，我们的代码逻辑也浮于水面。先来看根据前序、中序序列来创建二叉树代码。\n\n```cpp\nBtNode* CreatePreIn(const char * pre_str, const char * in_str, int len)\n{\n    BtNode * s = NULL;\n    if(len >= 1)\n    {\n        s = Buynode();\n        s->data = pre_str[0];\n        int pos = FindInStr(in_str, len, pre_str[0]);\n        if(pos == -1)\n        {\n            exit(1);\n        }\n        s->left  = CreatePreIn(pre_str+1, in_str, pos);\t//左子树\n        s->right = CreatePreIn(pre_str+pos+1, in_str+pos+1, len-pos-1);//右子树\n    }\n    return s;\n}\n```\n\n测试\n\n```cpp\n#include<iostream>\n#include<cassert>\n#include<cstring>\nusing namespace std;\ntypedef char ElemType;\ntypedef struct BtNode\n{\n    BtNode * left;\n    BtNode * right;\n    ElemType data;\n}BtNode, *BinaryTree;\nBtNode* Buynode()\n{\n    BtNode * s = (BtNode*)malloc(sizeof(BtNode));\n    if(s == NULL)\n    {\n        exit(1);\n    }\n    return s;\n}\nint FindInStr(const char * in_str, int len, char ch)\n{\n    assert(in_str != NULL);\n    int pos = -1;\n    int i = 0;\n    while(i < len)\n    {\n        if(in_str[i]==ch)\n        {\n            pos = i;\n            break;\n        }\n        ++i;\n    }\n    return pos;\n}\nBtNode* CreatePreIn(const char * pre_str, const char * in_str, int len)\n{\n    BtNode * s = NULL;\n    if(len >= 1)\n    {\n        s = Buynode();\n        s->data = pre_str[0];\n        int pos = FindInStr(in_str, len, pre_str[0]);\n        if(pos == -1)\n        {\n            exit(1);\n        }\n        s->left  = CreatePreIn(pre_str+1, in_str, pos);\t//左子树\n        s->right = CreatePreIn(pre_str+pos+1, in_str+pos+1, len-pos-1);//右子树\n    }\n    return s;\n}\nBtNode* CreateTreePreIn(const char * pre_str, const char * in_str)\n{\n    if(pre_str == NULL || in_str == NULL)return NULL;\n    int pre_len = strlen(pre_str);\n    int in_len = strlen(in_str);\n    if(pre_len != in_len)return NULL;\n    return CreatePreIn(pre_str, in_str, pre_len);\n}\nvoid PrintPre(BinaryTree bt)\n{\n    if(bt == NULL)return;\n    cout << bt->data << \" \";\n    PrintPre(bt->left);\n    PrintPre(bt->right);\n}\nvoid PrintIn(BinaryTree bt)\n{\n    if(bt == NULL)return;\n    PrintIn(bt->left);\n    cout << bt->data << \" \";\n    PrintIn(bt->right);\n}\nvoid PrintPost(BinaryTree bt)\n{\n    if(bt == NULL)return;\n    PrintPost(bt->left);\n    PrintPost(bt->right);\n    cout << bt->data << \" \";\n}\nint main()\n{\n    BinaryTree root = NULL;\n    char pre_str[] = {\"ABCDEFGH\"};\n    char in_str[] = {\"CBEDFAGH\"};\n    root = CreateTreePreIn(pre_str, in_str);\n    PrintPre(root); cout << endl;\n    PrintIn(root); cout << endl;\n    PrintPost(root); cout << endl;\n    return 0;\n}\n```\n\n运行结果\n\n![image-20220520180445645](../../images/高级数据结构_二叉树/image-20220520180445645.png)\n\n相应地，可以得出后序、中序序列建立二叉树代码\n\n```cpp\n#include<iostream>\n#include<cassert>\n#include<cstring>\nusing namespace std;\ntypedef char ElemType;\ntypedef struct BtNode\n{\n    BtNode * left;\n    BtNode * right;\n    ElemType data;\n}BtNode, *BinaryTree;\nBtNode* Buynode()\n{\n    BtNode * s = (BtNode*)malloc(sizeof(BtNode));\n    if(s == NULL)\n    {\n        exit(1);\n    }\n    return s;\n}\nint FindInStr(const char * in_str, int len, char ch)\n{\n    assert(in_str != NULL);\n    int pos = -1;\n    int i = 0;\n    while(i < len)\n    {\n        if(in_str[i]==ch)\n        {\n            pos = i;\n            break;\n        }\n        ++i;\n    }\n    return pos;\n}\nBtNode* CreatePostIn(const char * post_str, const char * in_str, int len)\n{\n    BtNode * s = NULL;\n    if(len >= 1)\n    {\n        s = Buynode();\n        s->data = post_str[len-1];\n        int pos = FindInStr(in_str, len, post_str[len-1]);\n        if(pos == -1)\n        {\n            exit(1);\n        }\n        s->left  = CreatePostIn(post_str, in_str, pos);\t               //左子树\n        s->right = CreatePostIn(post_str+pos, in_str+pos+1, len-pos-1);//右子树\n    }\n    return s;\n}\nBtNode* CreateTreePostIn(const char * post_str, const char * in_str)\n{\n    if(post_str == NULL || in_str == NULL)return NULL;\n    int pre_len = strlen(post_str);\n    int in_len = strlen(in_str);\n    if(pre_len != in_len)return NULL;\n    return CreatePostIn(post_str, in_str, pre_len);\n}\nvoid PrintPre(BinaryTree bt)\n{\n    if(bt == NULL)return;\n    cout << bt->data << \" \";\n    PrintPre(bt->left);\n    PrintPre(bt->right);\n}\nvoid PrintIn(BinaryTree bt)\n{\n    if(bt == NULL)return;\n    PrintIn(bt->left);\n    cout << bt->data << \" \";\n    PrintIn(bt->right);\n}\nvoid PrintPost(BinaryTree bt)\n{\n    if(bt == NULL)return;\n    PrintPost(bt->left);\n    PrintPost(bt->right);\n    cout << bt->data << \" \";\n}\nint main()\n{\n    BinaryTree root = NULL;\n    char pre_str[] = {\"ABCDEFGH\"};\n    char in_str[] = {\"CBEDFAGH\"};\n    char post_str[] = {\"CEFDBHGA\"};\n    root = CreateTreePostIn(post_str, in_str);\n    PrintPre(root); cout << endl;\n    PrintIn(root); cout << endl;\n    PrintPost(root); cout << endl;\n    return 0;\n}\n```\n\n\n\n![image-20220520183237682](../../images/高级数据结构_二叉树/image-20220520183237682.png)\n\n# 非递归遍历链式存储二叉树\n\n## 前序遍历\n\n一个栈，先入右，后入左。\n\n```cpp\n#include<iostream>\n#include<stack>\nusing namespace std;\ntypedef struct TreeNode\n{\n    TreeNode* left;\n    TreeNode* right;\n    int val;\n}TreeNode;\nvoid preorderTraversal(TreeNode* root)\n{\n    TreeNode* cur = root;\n    stack<TreeNode*> st;\n    st.push(cur);\n    while (!st.empty())\n    {\n        cur = st.top();\n        st.pop();\n        cout << cur->val;\n        if (cur->right != nullptr)\n        {\n            st.push(cur->right);\n        }\n        if (cur->left != nullptr)\n        {\n            st.push(cur->left);\n        }\n    }\n}\n```\n\n## 中序遍历\n\n一个栈。\n\n1. 指针所指节点的左不为空时，入栈左子树\n2. 左空则出栈回退，指针指向出栈的节点（父节点）\n3. 打印\n4. 指针指向右子树\n5. 循环\n\n```cpp\n#include<stack>\n\nvoid inorderTraversal(TreeNode* root)\n{\n    stack<TreeNode*> st;\n    TreeNode* cur = root;\n    while(!st.empty() || cur != NULL)\n    {\n        while(cur != NULL)\n        {\n            st.push(cur);\n            cur = cur->left;\n        }\n        cur = st.top();\n        st.pop();\n        cout << cur->val;\n        cur = cur->right;\n    }\n}\n```\n\n还有一种写法，只是循环的形式稍有不同。\n\n```cpp\n#include<stack>\nvoid inorderTraversal(TreeNode* root)\n{\n    stack<TreeNode*> st;\n    TreeNode* cur = root;\n    while(!st.empty() || cur != NULL)\n    {\n        if(cur != NULL)\n        {\n            st.push(cur);\n            cur = cur->left;\n        }\n        else\n        {\n            cur = st.top();\n            st.pop();\n            cout << cur->val;\n            cur = cur->right;\n        }\n    }\n}\n```\n\n## 后序遍历\n\n两种方法。\n\n### 双栈法\n\n模仿前序遍历，但是需要另外一个栈来记录。\n\n```cpp\nvoid postorderTraversal(TreeNode* root)\n{\n    TreeNode* cur = root;\n    stack<TreeNode*> st;\n    stack<int> ist;\n    st.push(cur);\n    while (!st.empty())\n    {\n        cur = st.top();\n        st.pop();\n        ist.push(cur->val);\n        if (cur->left != nullptr)\n        {\n            st.push(cur->left);\n        }\n        if (cur->right != nullptr)\n        {\n            st.push(cur->right);\n        }\n    }\n    while (!ist.empty())\n    {\n        cout << ist.top();\n        ist.pop();\n    }\n}\n```\n\n### 迭代法\n\n仍是单栈，但需要一个tag标记指针来记录已经访问过哪个节点。\n\n```cpp\n#include<stack>\n#include<vector>\n#include<iostream>\nusing namespace std;\ntypedef struct TreeNode\n{\n    TreeNode* left;\n    TreeNode* right;\n    int val;\n}TreeNode;\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> v;\n        stack<TreeNode*> st;\n        TreeNode* cur = root;\n        TreeNode* tag = nullptr;\n        while (cur != nullptr || !st.empty())\n        {\n            while (cur != nullptr)\n            {\n                st.push(cur);\n                cur = cur->left;\n            }\n            cur = st.top();\n            st.pop();\n            if (cur->right == nullptr || cur->right == tag)\n            {\n                tag = cur;\n                v.push_back(cur->val);\n                cout << cur->val;\n                cur = nullptr;  //不易写出。\n            }\n            else\n            {\n                st.push(cur);\n                cur = cur->right;\n            }\n        }\n        return v;\n    }\n};\nint main()\n{\n    TreeNode n3 = { nullptr, nullptr, 3 };\n    TreeNode n2 = { &n3, nullptr, 2 };\n    TreeNode n1 = { nullptr, &n2, 1 };\n    Solution s;\n    s.postorderTraversal(&n1);\n}\n```\n\n","categories":["高级数据结构","树"]},{"title":"MySQL_存储引擎","url":"/数据库/MySQL_存储引擎/","content":"# 存储引擎\n\nMySQL的一大特点就是支持插件式的存储引擎，即其存储引擎是可更换的，支持不同的存储引擎。\n\n那么，存储引擎代表的是什么呢？\n\n在创建/使用表时，有三大部分需要管理：\n\n1. 表的结构（有几个字段，字段的类型，约束条件）\n2. 数据\n3. 索引（有利于加速表的查询）\n\n存储引擎直接影响以上三大部分内容的存储方式。即，不同的存储引擎，对应的数据及其结构的存储方式是不一样的。\n\n# 配置文件\n\nwindows下是`my.ini`\n\nLinux下是`my.cnf`，在`/etc`下。\n\n# 数据库、表对应的文件\n\n都存到了`/var/lib/mysql`下。\n\n对该目录进行读取时需要进入root用户模式。\n\n1. `ls`后发现，每个数据库都会有一个同名的文件夹，里面存放着库中的表。\n2. 进一个文件夹，发现里面每一张表都对应有多种后缀名不同的文件。\n    1. `.frm`表示表的框架信息，即frame。MyISAM和InnoDB存储引擎都要用。\n    2. `.MYD`、`.MYI`是MyISAM存储引擎下的数据表的文件。\n        1. `.MYD`表示使用MyISAM引擎的表的数据信息，即MyISAM Data。\n        2. `.MYI`表示使用MyISAM引擎的表的索引信息，即MyISAM Index。\n    3. `.ibd`是InnoDB存储引擎下的数据表的文件，同时存储了表的数据信息和索引信息。\n\n> 可以从表的数据文件的存储方式 - 延伸到索引上\n\n## 总结\n\n1. InnoDB的底层文件存储是`.frm`+`.ibd`，其中`.frm`存储的是表的结构，`.ibd`存储的是数据+索引；\n2. MyISAM的底层文件，表结构、表数据、表索引，各有一个对应的文件。\n\n# 相关命令\n\n```mysql\nSHOW engines;\n```\n\n![image-20220519140553878](../../images/MySQL_存储引擎/image-20220519140553878.png)\nMyISAM不支持事务。\nInnoDB支持事务。\n如果仅作查询，则MyISAM比InnoDB轻量级。\n# 各存储引擎区别\n\n| 存储引擎   | 锁机制 | B树索引 | 哈希索引   | 外键      | 事务      | 索引缓存 | 数据缓存    |\n| ------ | --- | ---- | ------ | ------- | ------- | ---- | ------- |\n| MyISAM | 表锁  | 支持   | 不支持    | **不支持** | **不支持** | 支持   | **不支持** |\n| InnoDB | 行锁  | 支持   | 不支持    | 支持      | 支持      | 支持   | 支持      |\n| Memory | 表锁  | 支持   | **支持** | 不支持     | 不支持     | 支持   | 支持      |\n\n**锁机制**：表示数据库在并发请求访问的时候，多个事务在操作时，并发操作的粒度。\n\n**B树索引、哈希索引**：加速SQL的查询速度。\n\n**外键**：子表的字段依赖父表的主键，设置了两张表的依赖关系。\n\n**事务**：多个SQL语句，保证它们共同执行的原子操作，要么全部成功，要么失败。不能只成功一部分，失败后需要回滚事务。\n\n**索引缓存和数据缓存**：和MySQL Server的查询缓存相关，在没有对数据和索引做修改之前，重复查询可以不用进行磁盘IO，读取上一次内存中查询的缓存就可以了，提升数据库的性能。\n## 总结\nMyISAM不支持事务、也不支持外键。\n# 数据的存储方式\n## MyISAM\nMyISAM索引采用**非聚集索引**，其优势是访问的速度快，对事务完整性没有要求，以`SELECT`、`INSERT`为主的应用基本上都可以使用这个存储引擎来创建表。\n\n**MyISAM**的表在磁盘上存储成 3 个文件，其文件名都和表名相同，扩展名分别是：\n`.frm`（存储表定义）\n`.MYD`（MYData，存储数据）\n`.MYI`（MYIndex，存储索引）\n## InnoDB\n**InnoDB**存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全，支持自动增长列，外键等功能，索引采用**聚集索引**，索引和数据存储在同一个文件，所以InnoDB的表在磁盘上有两个文件，其文件名都和表名相同，扩展名分别是：\n`.frm`（存储表的定义）\n`.ibd`（存储数据和索引）\n![](../../images/MySQL_索引/image-20250730200406795.png)\n![](../../images/MySQL_索引/image-20250730200415545.png)\n## MEMORY\n**MEMORY**存储引擎使用存在内存中的内容来创建表。\n每个MEMORY表实际**只对应一个磁盘文件，格式是.frm**（表结构定义）。\nMEMORY类型的表访问非常快，因为它的数据是放在内存中的，并且默认使用**HASH索引**（不适合做范围查询），但是一旦服务关闭，表中的数据就会丢失掉。\n\n## 索引文件和数据文件是否分离造成的结果\n见[MySQL_索引.md - 一次select where过滤条件查询所经历的事情](MySQL_索引.md#一次select%20where过滤条件查询所经历的事情)。","categories":["数据库","MySQL"]},{"title":"MySQL_索引","url":"/数据库/MySQL_索引/","content":"# 内容\n1. 索引\n2. 怎么创建索引\n3. 怎么优化索引\n4. 怎么分析索引的好坏\n5. 索引的创建、删除、使用\n6. explain分析相关SQL语句\n7. 总结 - 使用索引时需要注意的\n# 数据库文件存在哪里？\n同一数据库的不同表，存放在不同的文件里。\n详见《[MySQL_存储引擎 - 数据的存储方式](MySQL_存储引擎#数据的存储方式)》\n# 为什么要有索引\n\n当表中的数据量到达几十万甚至上百万的时候，SQL查询所花费的时间会很长，导致业务超时出错，此时就需要用索引来加速SQL查询。\n# 索引的本质\n\n索引也是一个数据结构，B+树。不用的时候，也是会存在磁盘上的。\n# 索引的双面性\n由于索引也是需要存储成索引文件的，因此对索引的使用也会涉及磁盘I/O操作。如果索引创建过多，使用不当，会造成SQL查询时大量无用的磁盘I/O操作，降低了SQL的查询效率，就会适得其反，因此掌握良好的索引创建原则非常重要！\n\n除此之外，如果要对某列建立索引，存储引擎会对列对应的行进行排列，当更新表内容时，不仅仅会改变数据，索引的文件也是要改动的。如果索引数目过多，则牵扯到的改动也会过多。\n# 索引的分类\n从两个方面来看：物理上/逻辑上\n## 物理上\n可分为：聚集索引、非聚集索引（有的高大上的叫法也叫“聚簇”）\n## 逻辑上\n可分为：\n1. 普通索引（又称为二级索引）：主动、手动创建的索引。\n    1. 没有任何限制条件，可以给任何类型的字段创建普通索引。\n    2. 可在创建新表时指定建立索引，也可给已创建表指定建立索引\n    3. 索引数量不限，但是不建议过多；有的存储引擎可能对表的索引数量有限制。\n    4. 一张表的一次SQL查询只能用1个索引，通常是用where的过滤条件中的某个字段。\n2. 唯一性索引\n    1. 使用UNIQUE修饰的字段，值不能重复，主键索引也属于唯一性索引。\n3. **主键索引（自动创建索引）**\n    1. 使用Primary Key修饰的字段会自动创建索引\n    2. 要注意主键和主键索引的区分，MyISAM存储引擎下，如果没有设置主键，也不会自动添加一列主键列。只有主动设置主键才会有主键存储。因为它的索引和数据是分开存放的；但在InnoDB存储引擎下，如果没有设置主键，会默认添加一列整型字段的列，作为主键。因为数据和索引是存在一个文件`.idb`中的，如果没有索引树，数据无处存放。\n4. 单列索引\n    1. 在一个字段上创建的索引\n5. 多列索引（联合索引）\n    1. 在表的多个字段上创建的索引，常出现于联合主键上。\n    2. 也可以用在普通字段。\n6. 全文索引\n    1. 主要用于字符串搜索\n    2. 使用`FULLTEXT`参数可以设置全文索引，只支持`CHAR`、`VARCHAR`和`TEXT`类型的字段上，常用于数据量较大的字符串类型上，可以提高查询速度。\n    3. 但是一般不在本地数据库中使用全文索引，而是给后台服务器另外增设专门的搜索引擎模块，如`elasticSearch, ES`。\n# 索引的创建与删除\n\n## 创建表的时候指定索引字段\n\n```mysql\nCREATE TABLE user(\n    id INT,\n    name VARCHAR(20),\n    sex ENUM('male', 'female'),\n    INDEX(id)\n);\n```\n\n## 在已创建的表上添加索引\n\n```mysql\nCREATE [UNIQUE] INDEX [索引名]\nON 表名 (字段名(长度) [ASC | DESC]);\n```\n\n## 删除索引\n\n```mysql\nDROP INDEX 索引名 ON 表名;\n```\n# 一次select where过滤条件查询所经历的事情\n```mysql\nSELECT * from student WHERE uid = 5;\n```\nUID为主键，默认有索引。\n查询一次的全流程：\n1. 存储引擎启动\n2. kernel space\n3. 磁盘IO（读取索引文件）\n4. 内存上，用索引的数据构建B树\n5. 查找数据，内存上二分找到索引节点，**value为一行记录的文件指针或者一行记录的数据（根据不同存储引擎实现）**。\n    1. MyISAM的索引文件和数据文件是分离的，因此索引节点的value为一行记录的文件指针，需要去磁盘中读取。\n    2. InnoDB的索引文件和数据文件是一起的，因此以及把索引的数据提前读取到了内存中，所以value值直接是一行记录的数据。\n6. kernel space\n7. 磁盘IO返回内存。\n# 实操探索索引\n\n首先`su root` + `netstat -natp | grep mysqld`查看mysql守护进程是否正在运行，默认工作在3306端口。\n\n我们先拿小表来探索。\n\n![image-20220519170152517](../../images/MySQL_索引/image-20220519170152517.png)\n## 查看表的结构 - 看主键索引\n```mysql\nSHOW CREATE TABLE student\\G #查看表的结构\n```\n\n![image-20220519174256317](../../images/MySQL_索引/image-20220519174256317.png)\n\n发现此表只有一个uid主键索引。\n## explain命令查看select where的性能分析\n```mysql\nEXPLAIN SELECT * FROM student WHERE uid = 3;\n```\n\n![image-20220519174431412](../../images/MySQL_索引/image-20220519174431412.png)\n\n由于uid上有主键索引，所以不管此表中有多少数据，只要是按照uid过滤条件来查找，直接就可以找到，不受查找的数据的位置的影响（不会在后面就找得慢，在前面就找得快）。\n\nexplain结果中**type为const表示常量时间**，`key_len`为4，对应了uid的int型的4字节大小。\n\n```mysql\nEXPLAIN SELECT * FROM student WHERE name = 'linfeng';\n```\n\n![image-20220519174825252](../../images/MySQL_索引/image-20220519174825252.png)\n\n由于`name`没有索引，所以explain分析出的性能显示`type`字段为`ALL`。\n通过name进行查找只能进行全表检索，效率较低。\n## 非主键字段创建索引，前后区别\n我们给name字段建立一个索引。\n\n```mysql\nCREATE INDEX nameidx ON student(name);\nSHOW CREATE TABLE student\\G\n```\n\n![image-20220519175233259](../../images/MySQL_索引/image-20220519175233259.png)\n\n发现，下面多了一个`KEY nameidx(name)`。\n但是，**建立了索引之后，不一定会用到索引，\nMySQL会进行性能分析，如果使用索引后需要搜索的数目和整表搜索的数目差不多的话，就不会使用索引**，\n因为通过索引来检索也是需要消耗磁盘IO的，恐会适得其反。\n\n对name加完索引之后，再来分析按`name`搜索的性能：\n\n```mysql\nEXPLAIN SELECT * FROM student WHERE name='zhangsan';\n```\n\n![image-20220519175732865](../../images/MySQL_索引/image-20220519175732865.png)\n\n这里我们看到，加了索引后，`type`的内容变为`ref`。\n\n还有一个可以优化的点，我们发现，`key_len`为152，这个值是索引的字长。\n\n我们可以在创建索引时在字段后加一个`(长度)`，以限制索引的字长。\n**通过控制索引的字长，避免索引长度过大，来提高搜索效率**。\n\n通常对字符串索引进行控制。\n### 非主键索引（普通索引/二级索引）的结构 - 回表\n以下讨论的是InnoDB存储引擎的情况。\n\n创建普通字段索引的实现原理是，普通字段（如name）充当key，value变成uid。\n\n回表是指，查到name索引树中linfeng对应的uid后，去主键索引树再找uid对应的一整行记录。\n![](../../images/MySQL_索引/image-20250731001703762.png)\n涉及到回表时，磁盘IO会增加，效率降低。\n## 测试InnoDB的数据缓存\n\n现在来测试`t_user`表，此表中有2000000条数据。\n\n现在测试查找同一个password的用户。（注意，我们用的是整型的1000000）\n\n```mysql\nSELECT * FROM t_user WHERE password = 1000000;\n```\n\n![image-20220519194908928](../../images/MySQL_索引/image-20220519194908928.png)\n\n再运行一次相同的SQL。（测试InnoDB的数据缓存）\n\n```mysql\nSELECT * FROM t_user WHERE password = 1000000;\n```\n\n![image-20220519195157521](../../images/MySQL_索引/image-20220519195157521.png)\n\n我们发现，由于两次相同的查找之间没有对数据库表进行修改、添加、删除操作，利用了存储引擎的缓存机制，比第一次查找出的时间快了，因为不用花费磁盘IO。\n## 测试有无索引的性能区别（涉及到类型转换时索引失效的问题）\n现在给password字段添加个索引。\n\n```mysql\nCREATE INDEX pwdidx ON t_user(password);\nSHOW CREATE TABLE t_user\\G\n```\n\n![image-20220519195427490](../../images/MySQL_索引/image-20220519195427490.png)\n\n现在再来试试查password。（故意写成整型）\n\n```mysql\nSELECT * FROM t_user WHERE password = 1000000;\n```\n\n![image-20220519195537622](../../images/MySQL_索引/image-20220519195537622.png)\n\n感觉性能并未大幅提升！这是为啥呢？\n\n```mysql\nEXPLAIN SELECT * FROM t_user WHERE password = 1000000;\n```\n\n![image-20220519195807298](../../images/MySQL_索引/image-20220519195807298.png)\n\nExplain发现：`key`值为`NULL`，意思就是：在执行SELECT where过滤password字段时，索引失效！\n\n原因是因为在查询过程的过滤过程中，涉及到了一个**类型转换操作**。\n（数据表原本设计password是字符串，而我们是用整型值传递的查询命令），如此就会让索引失效。\n\n我们把它写正确：\n\n```mysql\nSELECT * FROM t_user WHERE password = '1000000';\n```\n\n![image-20220519200232453](../../images/MySQL_索引/image-20220519200232453.png)\n\n```mysql\nEXPLAIN SELECT * FROM t_user WHERE password = '1000000';\n```\n\n![image-20220519200158653](../../images/MySQL_索引/image-20220519200158653.png)\n\n可以发现，如果没有类型强转，则一切恢复正常，索引发挥了它原有的功力——即使是在百万数据集中，也能瞬间找到要找的记录。\n## 测试删除索引\n\n最后我们测试一下删除索引\n\n```mysql\nDROP INDEX pwdidx ON t_user;\nSHOW CREATE TABLE t_user\\G\n```\n\n![image-20220519200416678](../../images/MySQL_索引/image-20220519200416678.png)\n# 多列索引（联合索引）\n一次SQL查询中，一张表只能使用一次索引。否则使用多个索引会耗费成倍的磁盘IO。\n```mysql\nexplain select * from student where age = 20 order by name;\n```\n创建多列索引，用在这种场景：过滤条件为非主键，排序条件为非主键。\n如果只建立了两个独立的单列age、name索引，那么：\n![](../../images/MySQL_索引/image-20250731002838480.png)\n虽然用到了age索引，但是依然会出现using filesort，这是由于name索引失效的问题。\n我们可以创建age、name的联合索引。实际的实现原理是，索引节点的key是age，value域一起绑定了name、uid。\n那么，最终的效果就是：先按age排序，再按name排序；age相同，按name排序。\n\n```mysql\ncreate index name_age_idx on student(age, name);\n```\n![](../../images/MySQL_索引/image-20250731003138392.png)\n![](../../images/MySQL_索引/image-20250731003209295.png)\n\n但是，如果只有age、name的联合索引，当我们用name过滤条件查询时，age、name的联合索引会失效。\n![](../../images/MySQL_索引/image-20250731003647042.png)\n这是因为age排在age、name的前面，age充当索引的key。\n# 聚集索引（聚簇索引）\n聚集索引指的是，索引和数据在一起。（比如InnoDB）\n非聚集索引指的是，索引和数据是分开的，索引的value保存的是数据的文件地址。（比如MyISAM）\n\n因此，MyISAM二级索引树，查询其他非索引字段时，不用进行回表操作，因为可以直接访问数据地址。\n![](../../images/MySQL_索引/image-20250731004540466.png)\n# 创建索引时指定索引结构\n```mysql\ncreate index nameidx on student(name) using hash;\n```\n![](../../images/MySQL_索引/image-20250731005319197.png)\n虽然指定了使用哈希索引，并且表结构也显示USING HASH，但实际上用的什么索引结构是不确定的。\n需要查看：\n```mysql\nshow indexes drom student;\n```\n![](../../images/MySQL_索引/image-20250731005526111.png)\n\n可以看到，实际上，刚才创建的nameidx依然为BTREE索引结构。\n# 哈希索引\nmemory存储引擎支持哈希索引。\nmemory存储引擎是基于内存的，掉电数据会丢失。\n\n虽然查询的效率很高，为`O(1)`，但是：哈希表中的元素没有任何顺序可言，只适合等值比较。\n```mysql\nselect * from student where name = 'zhangsan';\n```\n如果一旦涉及：范围查找，或者前缀查找，或者order by排序，则效率不高，只能遍历搜索哈希表了。\nzhangsan、zhangyang、zhangcheng，大概率不在一个桶中。\n```mysql\nselect * from student where name like 'zhang%';\n```\n而且，哈希表的结构很分散，无法利用计算机存储结构的局部性原理。磁盘IO会很频繁。\n\n因此哈希索引的场景：只适合把索引和数据全部加载到内存上。并且只做等值比较查询。\n## InnoDB自适应哈希索引\nInnoDB存储引擎会监测：如果同样的二级索引不断被使用，那么它会根据这个二级索引，在内存上根据二级索引树（B+树）上的二级索引值，在内存上构建一个哈希索引，来加索搜索。\n![](../../images/MySQL_索引/image-20250731011638213.png)\n\n自适应哈希索引本身的数据维护也是要耗费性能的，并不是说自适应哈希索引在任何情况下都会提升二级索引的查询性能。\n需要根据参数指标，来具体分析是否打开或者关闭自适应哈希索引。\n\n以下命令能看到两个比较重要的信息：\n1. RW-latch等待的线程数量（自适应哈希索引默认分配了8个分区），\n2. 走自适应哈希索引搜索的频率（低）和二级索引树搜索的频率（高）\n\n```mysql\nshow engine innodb status\\G \n```\n如果观察到同一个分区等待的线程数量过多，走哈希索引搜索频率低、二级索引树频率高，则最好关掉自适应哈希索引。\n# 总结 - 索引要注意的点\n1. 经常作为where条件过滤的字段考虑添加索引\n2. 针对字符串列创建索引时，尽量规定索引的长度，避免索引值的长度`key_len`过长\n3. 索引字段涉及类型强转、mysql函数调用、表达式计算等，索引就失效了。","categories":["数据库","MySQL"]},{"title":"安装Nginx","url":"/项目/安装nginx/","content":"# 内容\n\n安装nginx及其依赖。\n\n可能需要的命令：\n\n1. Linux下`*.tar.gz`文件解压缩命令：`tar -zxvf 压缩文件名.tar.gz`\n2. `chown -R` : 处理指定目录以及其子目录下的所有文件\n\n参考文章\n\n1. [Hexo部署至服务器（Ubuntu 20.04）](https://cloud.tencent.com/developer/article/1945550)\n2. [ubuntu nginx源代码安装](https://www.jianshu.com/p/8af24b0adaf6)\n3. [Ubuntu20.04安装openssl-1.1.1k](https://zhuanlan.zhihu.com/p/387379400)\n4. [linux中ln -s 命令详解](https://blog.csdn.net/liangtianmeng/article/details/86736761)\n5. [解决：Linux8整合Nginx过程中报错：src/os/unix/ngx_user.c: 在函数‘ngx_libc_crypt’中: src/os/unix/ngx_user.c:36:7](https://blog.csdn.net/weixin_48033662/article/details/122004967)\n6. [OpenSSL library is not used](https://blog.csdn.net/beagreatprogrammer/article/details/78369638)\n7. [设置Nginx在linux服务器（Ubuntu）开机启动](http://t.zoukankan.com/hoaprox-p-12416624.html)\n8. [Unable to locate package sysv-rc-conf](https://blog.csdn.net/hancc_824/article/details/109181317)\n9. https://blog.csdn.net/weixin_45837693/article/details/107675339\n\n# 安装其依赖\n\nnginx依赖pcre、openssl、zlib\n\n安装pcre\n\n```bash\nsudo apt install libpcre3 libpcre3-dev\n```\n\n安装zlib\n\n下载地址:http://www.zlib.net\n\n```bash\ntar -xvf zlib-<version>.tar.gz \ncd zlib-<version>/\n./configure\nmake\nmake install\n```\n\n","categories":["项目"]},{"title":"MySQL_分组_排序","url":"/数据库/MySQL_分组_排序/","content":"\n# 内容\n\n1. 排序 - order by\n   1. 升序 - asc (默认)\n   2. 降序 - desc\n2. 分组 - group by\n\n# 排序\n\n格式如下：\n\n```mysql\nSELECT * FROM tablename ORDER BY 字段1,字段2,... [ASC(default) | DESC];\n```\n\n其中，`ORDER BY`后面的条件是优先级规则。先比照`字段1`，若相同则比照`字段2`，以此类推；其次，后面的`ASC`表示升序排列，是默认选项，如果欲按照降序排列则需指明`DESC`。\n\n## 排序查询性能分析\n\n```mysql\nSELECT * FROM user ORDER BY age;\nEXPLAIN SELECT * FROM user ORDER BY age;\n```\n\n![image-20220518085532824](../../images/MySQL_分组&排序/image-20220518085532824.png)\n\n![image-20220518085549904](../../images/MySQL_分组&排序/image-20220518085549904.png)\n\nexplain之后发现`rows=5`，如果单纯地进行排序而不加任何条件，将会进行整表查询。\n\n`type`为`ALL`，意为整表查询，以前我们用带索引的查询此处为`const`，表示常量时间，此处的`ALL`则代表复杂度较高；`Extra`为`Using filesort`，这个标志意味着，此查询涉及到磁盘IO和外排序，将严重影响性能。\n\n外排序的意思就是，有时磁盘的数据量很大，无法全部装到内存中处理，一般会采用n路归并排序思想，这将会涉及很多磁盘IO，效率低下。\n\n再来看一个。\n\n```mysql\nEXPLAIN SELECT * FROM user ORDER BY name;\n```\n\n![image-20220518090603207](../../images/MySQL_分组&排序/image-20220518090603207.png)\n\nexplain发现即使按照字段`name`排序，结果还是与上面的效果一致。\n\n再来一个。\n\n```mysql\nEXPLAIN SELECT name FROM user ORDER BY name;\n```\n\n这次我们没有查按name排序结果后的所有字段，而是只查了字段`name`。\n\n![image-20220518090847761](../../images/MySQL_分组&排序/image-20220518090847761.png)\n\nexplain发现，变化显著。\n\n首先`type`变为`index`；`key`变为`name`；最后，`Extra`变为`Using index`。\n\n再试一个。\n\n```mysql\nEXPLAIN SELECT age FROM user ORDER BY age;\n```\n\n![image-20220518091136751](../../images/MySQL_分组&排序/image-20220518091136751.png)\n\nexplain发现，并不是说按啥排序并且只查啥的话性能就高。我们发现按age排序，只查age的话Extra仍是`Using filesort`。\n\n结论就是：order by的性能不仅与待排序的字段是否有索引有关，还与select选择的列字段有关系。这与主索引树、辅助索引树有关，也就是聚集索引和非聚集索引的搜索过程有关，也涉及到回表问题。\n\n# 分组\n\n按照字段分组，字段内容相同的放在一组。\n\n```mysql\nSELECT * FROM user;\n```\n\n![image-20220518092546416](../../images/MySQL_分组&排序/image-20220518092546416.png)\n\n```mysql\nSELECT DISTINCT age FROM user;\n```\n\n![image-20220518092624988](../../images/MySQL_分组&排序/image-20220518092624988.png)\n\n```mysql\nSELECT age FROM user GROUP BY age;\n```\n\n![image-20220518092651495](../../images/MySQL_分组&排序/image-20220518092651495.png)\n\n## 常用语句\n\n### 分组并显示该组记录的条数\n\n```mysql\nSELECT age,COUNT(age) AS number FROM user GROUP BY age;#AS可省略\n```\n\n### 分组后条件筛选 - HAVING\n\n```mysql\nSELECT age,COUNT(age) number FROM user GROUP BY age HAVING age>20;\n```\n\n也可以分组前条件筛选 - where\n\n```mysql\nSELECT age,COUNT(age) number FROM user WHERE age>20 GROUP BY age;\n```\n\n### 多字段分组\n\n```mysql\nSELECT age,sex FROM user GROUP BY age,sex;\n```\n\n这个语句将会把age和sex同时一样的记录分组。\n\n![image-20220518094730869](../../images/MySQL_分组&排序/image-20220518094730869.png)\n\n```mysql\nSELECT age,sex,COUNT(*) FROM user GROUP BY age,sex;\n```\n\n![image-20220518094828414](../../images/MySQL_分组&排序/image-20220518094828414.png)\n\n`count(*)`相当于求的是记录的行数。\n\n### 与排序结合\n\n```mysql\nSELECT age,sex,COUNT(*) FROM user GROUP BY age,sex ORDER BY age;\n```\n\n![image-20220518095349412](../../images/MySQL_分组&排序/image-20220518095349412.png)\n\n## 性能分析\n\n首先我们先确定一下此表的结构属性。再用Explain进行性能分析。\n\n```mysql\nDESC user;\nEXPLAIN SELECT age FROM user GROUP BY age;\n```\n\n![image-20220518095647124](../../images/MySQL_分组&排序/image-20220518095647124.png)\n\ndesc发现，id有主键索引，name有唯一性索引。其他的age、sex无索引。\n\nexplain发现，`Extra`中为`Using temporary; Using filesort`。说明此分组查询需要：产生临时表+使用外排序。效率极差。\n\n实际上group by也会进行类似order by的排序。分组查询是先把分组以后的数据放到临时表中，然后在临时表中进行排序。由于age没有索引，所以需要使用外排序。\n\n试试按name分组。\n\n```mysql\nEXPLAIN SELECT name FROM user GROUP BY name;\n```\n\n![image-20220518100614162](../../images/MySQL_分组&排序/image-20220518100614162.png)\n\nexplain发现，`Extra`为`Using index`。变化是很显著的。所以GROUP BY后面加索引也是非常有必要的。\n\n# 练习\n\n某银行代缴话费主流水表（`bank_bill`）结构：\n\n| 字段名 | 描述     |\n| ------ | -------- |\n| serno  | 流水号   |\n| date   | 交易日期 |\n| accno  | 账号     |\n| name   | 姓名     |\n| amount | 金额     |\n| brno   | 缴费网点 |\n\n题目：1）统计表中缴费的总笔数和总金额；2）给出一个SQL，按网点和日期统计每个网点每天的营业额，并按照营业额进行倒序排序。\n\n```mysql\nCREATE TABLE bank_bill(\n    serno BIGINT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    date DATE NOT NULL,\n    accno VARCHAR(100) NOT NULL,\n    name VARCHAR(50) NOT NULL,\n    amount DECIMAL(10,1) NOT NULL,\n    brno VARCHAR(150) NOT NULL\n);\nINSERT INTO bank_bill VALUES\n('101000','2022-3-1','111','zhang',100,'高新区支行'),\n('101001','2022-3-1','222','liu',200,'碑林区支行'),\n('101002','2022-3-1','333','gao',300,'高新区支行'),\n('101003','2022-3-1','444','lian',150,'雁塔区支行'),\n('101004','2022-3-1','555','lan',360,'雁塔区支行'),\n('101005','2022-3-1','666','wang',300,'碑林区支行'),\n('101006','2022-3-2','777','wei',500,'碑林区支行'),\n('101007','2022-3-2','888','yao',50,'碑林区支行'),\n('101008','2022-3-2','111','zhang',100,'高新区支行'),\n('101009','2022-3-2','222','liu',200,'雁塔区支行'),\n('101010','2022-3-3','333','gao',300,'高新区支行'),\n('101011','2022-3-3','444','lian',150,'雁塔区支行'),\n('101012','2022-3-3','555','lan',360,'雁塔区支行'),\n('101013','2022-3-3','666','wang',300,'碑林区支行');\n```\n\n1）总笔数、总金额：\n\n```mysql\nSELECT COUNT(serno),SUM(amount) FROM bank_bill;\n```\n\n![image-20220518102653368](../../images/MySQL_分组&排序/image-20220518102653368.png)\n\n2）按网点和日期统计每天营业额，倒序。\n\n```mysql\nSELECT brno,date,sum(amount) AS total FROM bank_bill GROUP BY brno,date ORDER BY brno,total DESC;\n```\n\n![image-20220518105904641](../../images/MySQL_分组&排序/image-20220518105904641.png)","categories":["数据库","MySQL"]},{"title":"刷题_打家劫舍","url":"/算法/刷题_打家劫舍/","content":"\n# 打家劫舍\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你**不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。\n\n示例 1：\n\n```\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n\n示例 2：\n\n```\n输入：[2,7,9,3,1]\n输出：12\n解释：\n    偷窃1号房屋(金额=2),偷窃3号房屋(金额=9)，接着偷窃5号房屋(金额=1)。\n    偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n提示：\n\n```\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n```\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        vector<int> ar;\n        ar.reserve(nums.size()+1);\n        ar[0] = 0;\n        ar[1] = nums[0];\n        int max = ar[1];\n        for(int i = 2; i<=nums.size(); ++i)\n        {\n            ar[i] = std::max(ar[i-2]+nums[i-1],ar[i-1]);\n            if(ar[i]>max)max = ar[i];\n        }\n        return max;\n    }\n};\n```\n\n# 打家劫舍2\n\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈**，这意味着**第一个房屋和最后一个房屋是紧挨着**的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。\n\n示例 1：\n\n```\n输入：nums = [2,3,2]\n输出：3\n解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n```\n\n\n示例 2：\n\n```\n输入：nums = [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n示例 3：\n\n```\n输入：nums = [1,2,3]\n输出：3\n```\n\n提示：\n\n```\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000\n```\n\n## 题解\n\n这道题是**打家劫舍**的进阶，和初级版的不同之处是，这道题中的房屋是首尾相连的，第一间房屋和最后一间房屋相邻，因此第一间房屋和最后一间房屋不能在同一晚上偷窃。\n\n和其相似，这道题也可以使用动态规划解决。建议首先了解动态规划的思想。\n\n---\n\n首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。\n\n注意到当房屋数量不超过两间时，最多只能偷窃一间房屋，因此不需要考虑首尾相连的问题。如果房屋数量大于两间，就必须考虑首尾相连的问题，第一间房屋和最后一间房屋不能同时偷窃。\n\n如何才能保证第一间房屋和最后一间房屋不同时偷窃呢？如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。\n\n假设数组$nums$的长度为$n$。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是$[0, n-2]$；如果不偷窃第一间房屋，则偷窃房屋的下标范围是$[1,n−1]$。在确定偷窃房屋的下标范围之后，即可用第1题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在$n$间房屋中可以偷窃到的最高总金额。\n\n假设偷窃房屋的下标范围是$[start,end]$，用$dp[i]$表示在下标范围$[start,i]$内可以偷窃到的最高总金额，那么就有如下的状态转移方程：\n\n$dp[i]=max(dp[i−2]+nums[i],dp[i−1])$\n\n边界条件为：\n\n$$\n\\begin{cases} \\textit{dp}[\\textit{start}] = \\textit{nums}[\\textit{start}] & 只有一间房屋，则偷窃该房屋 \\\\ \\textit{dp}[\\textit{start}+1] = \\max(\\textit{nums}[\\textit{start}], \\textit{nums}[\\textit{start}+1]) & 只有两间房屋，偷窃其中金额较高的房屋 \\end{cases}\n$$\n 计算得到$dp[end]$即为下标范围$[start,end]$内可以偷窃到的最高总金额。\n\n分别取$(start,end)=(0,n−2)$和$(start,end)=(1,n−1)$进行计算，取两个$dp[end]$中的最大值，即可得到最终结果。\n\n根据上述思路，可以得到时间复杂度$O(n)$和空间复杂度$O(n)$的实现。\n\n考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额，将空间复杂度降到$O(1)$。\n\n```cpp\nclass Solution {\npublic:\n    int robRange(vector<int>& nums, int start, int end) {\n        int first = nums[start], second = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n\n    int rob(vector<int>& nums) {\n        int length = nums.size();\n        if (length == 1) {\n            return nums[0];\n        } else if (length == 2) {\n            return max(nums[0], nums[1]);\n        }\n        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n};\n```\n\n# 打家劫舍3\n\n小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为`root`。\n\n除了`root`之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果**两个直接相连的房子在同一天晚上被打劫**，房屋将自动报警。\n\n给定二叉树的`root`。返回**在不触动警报的情况下**，小偷能够盗取的最高金额 。\n\n**示例 1:**\n\n![image-20220518184546102](../../images/刷题_打家劫舍/image-20220518184546102.png)\n\n```\n输入: root = [3,2,3,null,3,null,1]\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7\n```\n\n**示例 2:**\n\n![image-20220518184621752](../../images/刷题_打家劫舍/image-20220518184621752.png)\n\n```\n输入: root = [3,4,5,1,3,null,1]\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9\n```\n\n**提示：**\n\n- 树的节点数在 `[1, 104]` 范围内\n- `0 <= Node.val <= 104`\n\n## 题解\n\n思路与算法\n\n简化一下这个问题：一棵二叉树，树上的每个点都有对应的权值，每个点有两种状态（选中和不选中），问在不能同时选中有父子关系的点的情况下，能选中的点的最大权值和是多少。\n\n我们可以用$f(o)$表示选择$o$节点的情况下，$o$节点的子树上被选择的节点的最大权值和；$g(o)$表示不选择$o$节点的情况下，$o$节点的子树上被选择的节点的最大权值和；$l$和$r$代表$o$的左右孩子。\n\n* 当$o$被选中时，$o$的左右孩子都不能被选中，故$o$被选中情况下子树上被选中点的最大权值和为$l$和$r$不被选中的最大权值和相加，即$f(o)=g(l)+g(r)$。\n* 当$o$不被选中时，$o$的左右孩子可以被选中，也可以不被选中。对于$o$的某个具体的孩子$x$，它对$o$的贡献是$x$被选中和不被选中情况下权值和的较大值。故$g(o)=max\\{f(l),g(l)\\}+max\\{f(r),g(r)\\}$。\n\n至此，我们可以用哈希表来存$f$和$g$的函数值，用深度优先搜索的办法后序遍历这棵二叉树，我们就可以得到每一个节点的$f$和$g$。根节点的$f$和$g$的最大值就是我们要找的答案。\n\n我们不难给出这样的实现：\n\n```cpp\nclass Solution {\npublic:\n    unordered_map <TreeNode*, int> f, g;\n\n    void dfs(TreeNode* node) {\n        if (!node) {\n            return;\n        }\n        dfs(node->left);\n        dfs(node->right);\n        f[node] = node->val + g[node->left] + g[node->right];\n        g[node] = max(f[node->left], g[node->left]) + max(f[node->right], g[node->right]);\n    }\n\n    int rob(TreeNode* root) {\n        dfs(root);\n        return max(f[root], g[root]);\n    }\n};\n```\n\n假设二叉树的节点个数为$n$。\n\n我们可以看出，以上的算法对二叉树做了一次后序遍历，时间复杂度是$O(n)$；由于递归会使用到栈空间，空间代价是$O(n)$，哈希表的空间代价也是$O(n)$，故空间复杂度也是$O(n)$。\n\n我们可以做一个小小的优化，我们发现无论是$f(o)$还是$g(o)$，他们最终的值只和$f(l)$、$g(l)$、$f(r)$、$g(r)$有关，所以对于每个节点，我们只关心它的孩子节点们的$f$和$g$是多少。我们可以设计一个结构，表示某个节点的$f$和$g$值，在每次递归返回的时候，都把这个点对应的$f$和$g$返回给上一级调用，这样可以省去哈希表的空间。\n\n代码如下。\n\n```cpp\nstruct SubtreeStatus {\n    int selected;\n    int notSelected;\n};\n\nclass Solution {\npublic:\n    SubtreeStatus dfs(TreeNode* node) {\n        if (!node) {\n            return {0, 0};\n        }\n        auto l = dfs(node->left);\n        auto r = dfs(node->right);\n        int selected = node->val + l.notSelected + r.notSelected;\n        int notSelected = max(l.selected, l.notSelected) + max(r.selected, r.notSelected);\n        return {selected, notSelected};\n    }\n\n    int rob(TreeNode* root) {\n        auto rootStatus = dfs(root);\n        return max(rootStatus.selected, rootStatus.notSelected);\n    }\n};\n```\n\n复杂度分析\n\n时间复杂度：$O(n)$。上文中已分析。\n\n空间复杂度：$O(n)$。虽然优化过的版本省去了哈希表的空间，但是栈空间的使用代价依旧是$O(n)$，故空间复杂度不变。\n","categories":["算法","刷题"]},{"title":"MySQL_SQL","url":"/数据库/MySQL_SQL/","content":"\n# 内容\n\n1. SQL(Structure Query Language, 结构化查询语言)\n2. SQL划分为3个类别，DD(Definition)L、DM(Manipulation)L、DC(Control)L\n3. 库操作\n4. 表操作\n5. CRUD\n6. SQL语句和索引的关系\n\n# SQL\n\nSQL即Structure Query Language，结构化查询语言。它是关系型数据库的通用语言。\n\nSQL可划分为以下三种类别：\n\n1. DDL(Data Definition Language)\n   * 数据定义语言，与数据库、表、列、索引等数据库对象的定义有关。\n   * 常用的语句关键字主要包括`create`、`drop`、`alter`等。\n2. DML(Data Manipulation Language)\n   * 数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性。\n   * 常用的语句关键字主要包括`insert`、`delete`、`update`、`select`等。\n3. DCL(Data Control Language)\n   * 数据控制语句，用于控制不同的许可和访问级别的语句。与数据库、表、字段、用户的访问权限和安全级别有关。\n   * 主要的语句关键字包括`grant`、`revoke`。\n\n# 库操作\n\n查询数据库：`show databases;`\n\n创建数据库：`create database dbname;`\n\n删除数据库：`drop database dbname;`\n\n选择数据库：`use dbname;`\n\n我们下面以学校的数据库为例，创建库表。\n\n```mysql\nCREATE DATABASE school;\nUSE school;\n```\n\n# 表操作\n\n表的设计要素：\n\n1. 字段的数据类型\n2. 完整性约束条件的规范\n3. 一对一/一对多/多对多实体关系对应的表设计原则\n\n* 创建表\n\n```mysql\nCREATE TABLE user(\n    id INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    name VARCHAR(50) UNIQUE NOT NULL,\n    age TINTINT NOT NULL,\n    sex ENUM('M', 'W') NOT NULL\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\n```\n\n> 对于存储引擎以及默认字符集的配置文件，\n> 在windows下为mysql安装目录下的`my.ini`；\n> linux下为`/etc/my.cnf`。\n> 配置字段为`[mysqld]`\n\n* 查看表\n\n```mysql\nshow tables;\n```\n\n![image-20220517103024114](../../images/MySQL_SQL/image-20220517103024114.png)\n\n* 查看表的描述信息\n\n```mysql\nDESC user;\ndescribe user; # 全拼\n```\n\n![image-20220517103053213](../../images/MySQL_SQL/image-20220517103053213.png)\n\n* 表已创建后，查看表的创建语句\n\n```mysql\nSHOW CREATE TABLE user;\nSHOW CREATE TABLE user\\G # \\G结尾和;结尾的区别在于显示方式不同\n```\n\n![image-20220517103908450](../../images/MySQL_SQL/image-20220517103908450.png)\n\n* 删除表 - drop (不光是表的内容，整个表的结构都没了)\n\n```mysql\nDROP TABLE user;\n```\n# 不常用的操作\n## View（视图）\n在数据库中，左边栏，存在一个view，可以存放一个表中的多个字段的查询结果，也可以存放多个表连接之后的临时结果。\n![](../../images/MySQL_SQL/image-20250730182642168.png)\n\n实际用途中，视图可以用于屏蔽与实际数据库的差异，比如数据库的实际字段可能不是用户请求的字段，视图起了个别名。\n也可以用于隐藏一些细节。把实际数据库中的内容提取出来的不敏感的部分放到视图里，建立虚拟的字段，供用户使用。\n## 存储过程\n类似于批处理脚本。可以没有返回值。\n## 函数\n封装操作过程，可以定义变量，可以有控制语句、循环语句等。必须有返回值。\n## 触发器\n触发器的作用：比如插入、删除一条记录等等操作，可以进行相应的回调。\n触发器是基于行的，即基于记录的。当操作很多行时，不建议使用触发器。\n## 总结\n存储过程和函数一般是专门操作数据库的后端人员负责的。实际上，存储过程和函数的操作，完全可以在上层服务用高级语言（`C++`等）完成。数据库可以只负责简单的计算。\n# CRUD\n\n## Create - 插入\n\n```mysql\nINSERT INTO user VALUES(1, 'zhangsan', 20, 'M'); #如果不指明插入的属性，则必须按照字段的顺序全部填入\nINSERT INTO user(name,age,sex) VALUES('lisi', 22, 'W'); #指明插入的属性，由于id设置为自增性，所以不用填写。\n```\n\n* 每次添加一个\n\n```mysql\nINSERT INTO user(name,age,sex) VALUES('zhangsan', 20, 'M');\nINSERT INTO user(name,age,sex) VALUES('gaoyang', 22, 'W');\nINSERT INTO user(name,age,sex) VALUES('chenwei', 20, 'M');\nINSERT INTO user(name,age,sex) VALUES('zhangfan', 21, 'W');\nINSERT INTO user(name,age,sex) VALUES('zhanglan', 21, 'W');\n```\n\n* 批量增加\n\n```mysql\nINSERT INTO user(name,age,sex) VALUES\n('zhangsan', 20, 'M'),\n('gaoyang', 22, 'W'),\n('chenwei', 20, 'M'),\n('zhangfan', 21, 'W'),\n('zhanglan', 21, 'W');\n```\n\n### 最终表中存放的数据是一致的。有啥区别？\n\n我们使用sql，相当于mysql server的一个client。\n\n每次添加一个：\n\n1. client和server进行tcp三次握手，建立通信链路；\n2. client发送sql语句到server上接收并处理，返回处理结果；\n3. server和client断开连接，tcp四次挥手，释放通信链路。\n\n把每次添加一条记录的操作抽象为3次步骤。则总共需要`3*n`个步骤。\n\n而如果是批量添加：\n\n1. client和server进行tcp三次握手，建立通信链路；\n2. client发送sql语句到server上接收并处理，返回处理结果；\n3. server和client断开连接，tcp四次挥手，释放通信链路。\n\n则总共仅需`3`个步骤，即可全部插入。\n\n## Delete - 删除\n\n```mysql\nDELETE FROM user;\t\t\t\t#删除表中所有数据\nDELETE FROM user WHERE id=1; \t#只删除id为1的记录\n```\n\n## Update - 更新\n\n```mysql\nUPDATE user SET age=age+1 WHERE name='gaoyang';\t#调正gaoyang的年龄+1\n```\n\n## Retrieve - 查询\n\n在这里我们示例一些简单的查询语句。\n\n* 无条件查询全部字段\n\n```mysql\nSELECT * FROM user;\t#不推荐，最好还是老老实实地写出所有字段名称，因为表的结构之后可能会变更，可能会影响业务代码。\n```\n\n* 条件查询指定字段\n\n```mysql\nSELECT name,age,sex FROM user WHERE age>=21;\nSELECT name,age,sex FROM user WHERE age>20 AND age<22;\nSELECT name,age,sex FROM user WHERE BETWEEN 20 AND 22;#闭区间\n```\n\n```mysql\n# 以下两个sql语句效果一致。\nSELECT name,age,sex FROM user WHERE age=20 OR age=21;\nSELECT name,age,sex FROM user WHERE age IN (20,21);\n```\n\n* 使用通配符查询\n\n```mysql\nSELECT name,age,sex FROM user WHERE name LIKE \"zhang%\";#必须用LIKE，不能用=等号，否则会把%通配符看作实际字符。\n```\n\n* 判断为空不用`=`，而用`IS NULL`\n\n```mysql\nSELECT name,age,sex FROM user WHERE name IS NULL;\nSELECT name,age,sex FROM user WHERE name IS NOT NULL;\n```\n\n### 去重\n\n有两种去重的方式\n\n1. `distinct` - 简单地去重\n2. `group by` - 功能强大，耗时\n\n```mysql\nSELECT DISTINCT age FROM user;\n```\n\n![image-20220517114906800](../../images/MySQL_SQL/image-20220517114906800.png)\n\n### 合并查询 - union\n\n格式如下\n\n```\nSELECT expression1, expression2, ..., expression\nFROM table1 [WHERE conditions]\nUNION [ALL | DISTINCT(default)]\nSELECT expression1, expression2, ..., expression\nFROM table2 [WHERE conditions];\n# union默认为distinct去重，all表示显示重复的记录项\n```\n\n```mysql\nSELECT name,age,sex\nFROM user WHERE age>=21\nUNION ALL\nSELECT name,age,sex\nFROM user WHERE sex='M';\n```\n\n![image-20220517163204447](../../images/MySQL_SQL/image-20220517163204447.png)\n\n# SQL语句和索引的关系\n\n```mysql\nSELECT name,age,sex FROM user WHERE age=20 OR age=21;\n```\n\n通常都说带`逻辑与`的SQL语句会用到索引，带`逻辑或`的SQL语句不会用到索引。比如上面这句带`逻辑或`的SQL语句不会用到索引吗？错误。\n\n如果仅仅是对于这个SQL语句的表象来说，是不会用到索引的。但是MySQL实际运行过程中是会对用户提交的SQL语句进行优化的。\n\n`OR`的语义是：`要么..., 要么...`。对于逻辑或语句，MySQL有可能将其转化为`union`合并查询，即前后分别执行两个不同的不带逻辑或的SQL语句，这样的SQL语句是完全可以用不到索引的。\n\n类似地，带`in`的SQL语句，表面上是能用到索引；带`not in`的SQL语句，表面上用不到索引。带仅仅限于MySQL不做优化的情况。\n\n所以，会不会用到索引不能只看表面的SQL语句，而要看MySQL实际如何优化。\n\n# 连接查询\n\n表1：Employees\n\n|EmployeeID|Name|DepartmentID|\n|---|---|---|\n|1|张三|101|\n|2|李四|102|\n|3|王五|102|\n|4|赵六|103|\n|​**​5​**​|​**​钱七​**​|​**​NULL​**|\n\n表2：Departments\n\n| DepartmentID | DepartmentName |\n| ------------ | -------------- |\n| 101          | 人事部            |\n| 102          | 技术部            |\n| 104          | 财务部            |\n## 笛卡尔积（交叉查询）\n```mysql\nSELECT\n    e.EmployeeID AS EmpID,\n    e.Name AS EmpName,\n    e.DepartmentID AS A_DeptID,\n    d.DepartmentID AS B_DeptID,\n    d.DepartmentName AS DeptName\nFROM Employees e -- 给表起别名 'e'\nCROSS JOIN Departments d; -- 给表起别名 'd'\n-- 没有 ON 子句！\n```\n\n| EmpID | EmpName | A_DeptID | B_DeptID | DeptName |\n| ----- | ------- | -------- | -------- | -------- |\n| ​​1​​ | 张三      | 101      | ​​101​​  | 人事部      |\n| ​​1​​ | 张三      | 101      | ​​102​​  | 技术部      |\n| ​​1​​ | 张三      | 101      | ​​104​​  | 财务部      |\n| ​​2​​ | 李四      | 102      | ​​101​​  | 人事部      |\n| ​​2​​ | 李四      | 102      | ​​102​​  | 技术部      |\n| ​​2​​ | 李四      | 102      | ​​104​​  | 财务部      |\n| ​​3​​ | 王五      | 102      | ​​101​​  | 人事部      |\n| ​​3​​ | 王五      | 102      | ​​102​​  | 技术部      |\n| ​​3​​ | 王五      | 102      | ​​104​​  | 财务部      |\n| ​​4​​ | 赵六      | 103      | ​​101​​  | 人事部      |\n| ​​4​​ | 赵六      | 103      | ​​102​​  | 技术部      |\n| ​​4​​ | 赵六      | 103      | ​​104​​  | 财务部      |\n| 5     | 钱七      | NULL     | 101      | 人事部      |\n| 5     | 钱七      | NULL     | 102      | 技术部      |\n| 5     | 钱七      | NULL     | 104      | 财务部      |\n## 内连接 (INNER JOIN / JOIN)\n![](../../images/MySQL_SQL/image-20250729014631298.png)\n\n\n**通俗解释：只保留“两头都能配上对”的数据。​**​ 两边都有记录的才显示出来。\n\n```mysql\nSELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName\nFROM Employees\nINNER JOIN Departments\nON Employees.DepartmentID = Departments.DepartmentID;\n```\n\n结果：\n\n|EmployeeID|Name|DepartmentName|\n|---|---|---|\n|1|张三|人事部|\n|2|李四|技术部|\n|3|王五|技术部|\n\n- `赵六`(员工ID4) 的部门ID是103，而部门表里没有103号部门，所以被​**​过滤掉​**​了。\n- `财务部`(部门ID 104) 没有任何员工，也​**​没出现​**​。\n\n## 左连接 (LEFT JOIN / LEFT OUTER JOIN)\n![](../../images/MySQL_SQL/image-20250729014650883.png)\n\n\n**通俗解释：“左边表全保，右边表尽量配”。​**​ 左表所有记录都显示，右表有匹配的也显示出来，​**​没匹配的补空值（NULL）​**​。\n\n**场景：​**​ 列出​**​所有员工​**​（不管有没有部门），​**​同时​**​如果员工有部门，就显示部门名称（没有部门的员工，部门名称显示为空）。\n\n```mysql\nSELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName\nFROM Employees\nLEFT JOIN Departments\nON Employees.DepartmentID = Departments.DepartmentID;\n```\n\n结果：\n\n| EmployeeID | Name | DepartmentName | DepartmentID |\n| ---------- | ---- | -------------- | ------------ |\n| 1          | 张三   | 人事部            | 101          |\n| 2          | 李四   | 技术部            | 102          |\n| 3          | 王五   | 技术部            | 102          |\n| 4          | 赵六   | ​**​NULL​**    | 103          |\n| 5          | 钱七   | **NULL**       | **NULL**     |\n\n- 左边员工表 (`Employees`) 的 5 条记录​**​全部保留​**​。\n- `张三`、`李四`、`王五` 在部门表里找到了匹配 (`101`, `102`)，所以显示部门名称。\n- `赵六`(部门ID `103`) 在部门表里没找到对应的名字，所以部门名称显示为 ​**​`NULL`​**​。\n- `钱七`（员工ID `5`）的部门 ID 本来就是 NULL，所以无法查询，显示 NULL。\n- 部门表中孤立的 `财务部`(`104`) ​**​没出现​**​。\n### 如何筛选出A表中外键为NULL的记录\n![](../../images/MySQL_SQL/image-20250729015124124.png)\n如此查询，便能筛选出钱七。\n这个图的意思是：在外面的红色部分，与B没有交集，意思就是说，外面这部分没有记录来自B的外键信息，与B无关联。\n\n## 右连接 (RIGHT JOIN / RIGHT OUTER JOIN)\n（其实相当于左连接的镜像，左连接时，A和B表交换书写位置就是他们的右连接）\n\n**通俗解释：“右边表全保，左边表尽量配”。​**​ 右表所有记录都显示，左表有匹配的也显示出来，​**​没匹配的补空值（NULL）​**​。​**​（和左连接方向相反）​**\n​\n**​场景：​**​ 列出​**​所有部门​**​（不管有没有员工），​**​同时​**​如果部门下有员工，就列出员工姓名；没人的部门，员工信息显示为空。\n\n```mysql\nSELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName\nFROM Employees\nRIGHT JOIN Departments\nON Employees.DepartmentID = Departments.DepartmentID;\n```\n\n结果：\n\n| EmployeeID   | Name         | DepartmentName |\n| ------------ | ------------ | -------------- |\n| 1            | 张三           | 人事部（101）       |\n| 2            | 李四           | 技术部（102）       |\n| 3            | 王五           | 技术部（102）       |\n| ​**​NULL​**​ | ​**​NULL​**​ | 财务部（104）       |\n- 右边部门表 (`Departments`) 的 3 条记录(`101`,`102`,`104`)​**​全部保留​**​。\n- `人事部`(`101`)、`技术部`(`102`) 找到了员工 (`张三` / `李四`, `王五`)，显示姓名。\n- `财务部`(`104`) 在员工表里没任何员工，所以员工ID和姓名都是 ​**​`NULL`​**​。\n- 员工 `赵六` (部门ID `103`)、`钱七`（员工ID `5`，部门ID `NULL`） ​**​没出现​**​（因为它的部门103在部门表里不存在，不属于右表保留范围）。\n\n## 全连接 (FULL JOIN / FULL OUTER JOIN)\n![](../../images/MySQL_SQL/image-20250729015251762.png)\n\n\n**通俗解释：“两个表我都全要！管你配不配得上！”​**​ 两个表的所有记录都保留。能配上对的就合并成一行显示。配不上对的，各自那边的空缺就用 ​**​`NULL`​**​ 填充。\n\n**​场景：​**​ 想做一个​**​完整的组织结构/花名册快照​**​，既要看到所有员工（包括没部门的），也要看到所有部门（包括没员工的）。信息齐全！\n\n```mysql\nSELECT Employees.EmployeeID, Employees.Name, Departments.DepartmentName\nFROM Employees\nFULL JOIN Departments\nON Employees.DepartmentID = Departments.DepartmentID;\n```\n结果：\n\n| EmployeeID   | Name         | DepartmentName | DepartmentID |\n| ------------ | ------------ | -------------- | ------------ |\n| 1            | 张三           | 人事部            | 101          |\n| 2            | 李四           | 技术部            | 102          |\n| 3            | 王五           | 技术部            | 102          |\n| 4            | 赵六           | ​**​NULL​**​   | 103          |\n| 5            | 钱七           | **NULL**       | NULL         |\n| ​**​NULL​**​ | ​**​NULL​**​ | 财务部            | 104          |\n- ​**​全部 6 种情况都展示出来了：​**​\n    1. 有员工有部门 (`张三-人事部`, `李四-技术部`, `王五-技术部`)。\n    2. 有员工​**​没​**​(匹配的)部门 (`赵六`、`钱七`)。\n    3. 有部门​**​没​**​(匹配的)员工 (`财务部`)。\n### 如何筛选出A表或B表的外键为NULL的记录\n![](../../images/MySQL_SQL/image-20250729015440879.png)\n\n如此查询，便能筛选出钱七。\n\n由于本例中B表没有外键，因此无法体现B表中没有外键的记录。\n\n\n## 连接查询（Join）和联合查询（Union）的区别\n​**​联合查询（Union Query）：​**​ 这个概念容易和连接混淆。\n- ​**​通俗解释：​**​ 把两张结构_相似_的表 ​**​上下拼起来​**​。就像把《番茄供应商名单》和《鸡蛋供应商名单》摞在一起，变成《食材供应商总名单》。注意：是垂直叠加！\n- ​**​核心要求：​**​\n    - 两张表查询结果的​**​列数必须一样​**​。\n    - 对应列的数据类型要​**​兼容​**​（比如数字对数字，字符串对字符串）。\n\n```mysql\nSELECT EmployeeID, Name FROM Employees -- 查员工ID和名字\nUNION -- 或者 UNION ALL (包含重复行)\nSELECT DepartmentID, DepartmentName FROM Departments; -- 查部门ID和名字\n```\n\n| EmployeeID/DepartmentID | Name/DepartmentName |\n| ----------------------- | ------------------- |\n| 1                       | 张三                  |\n| 2                       | 李四                  |\n| 3                       | 王五                  |\n| 4                       | 赵六                  |\n| 5                       | 钱七                  |\n| 101                     | 人事部                 |\n| 102                     | 技术部                 |\n| 104                     | 财务部                 |\n注意：这个例子不常用，只是为了展示UNION效果。UNION更常用于合并同类型数据，比如不同年份的销售记录表\n\n## `SELECT ... FROM A, B WHERE ...`和`SELECT ... FROM A JOIN B ON ...`的区别\n这两者​**​功能上对于内连接(INNER JOIN)是等效的​**​，但存在关键区别：​**​语法标准、可读性、维护性以及错误预防能力​**​。\n\n| 特性                | `SELECT ... FROM A, B WHERE ...` (隐式连接)      | `SELECT ... FROM A JOIN B ON ...` (显式连接)      |\n| ----------------- | -------------------------------------------- | --------------------------------------------- |\n| ​**​语法本质​**​      | 老式SQL标准，FROM子句用逗号分隔表，WHERE定义条件和连接            | 新式SQL-92标准，用JOIN关键字明确指定连接类型和条件                |\n| ​**​连接类型​**​      | 默认是​**​交叉连接(CROSS JOIN)​**​，需要WHERE过滤才能变成内连接 | ​**​明确指出连接类型​**​ (INNER/LEFT/RIGHT/FULL JOIN) |\n| ​**​连接条件位置​**​    | 和过滤条件​**​混在WHERE子句中​**​                      | 连接条件在​**​独立的ON子句​**​，过滤条件在WHERE（逻辑分离）         |\n| ​**​可读性 & 维护性​**​ | 差（复杂查询时条件混乱）                                 | 优（清晰区分连接条件和过滤逻辑）                              |\n| ​**​防止笛卡尔积错误​**​  | 弱（忘记WHERE会导致全组合）                             | 强（JOIN必须配ON或USING，否则语法错误）                     |\n| ​**​支持外连接​**​     | 部分数据库不支持（如Oracle老语法用`(+)`）                   | ​**​所有数据库都支持​**​标准外连接写法(LEFT/RIGHT/FULL JOIN) |\n| ​**​现代推荐度​**​     | ⚠️ 不推荐（尤其复杂查询）                               | ✅ ​**​强烈推荐​**                                 |\n# 练习\n![](../../images/MySQL_SQL/image-20250728231556591.png)\n\n查询平均成绩大于60分的同学的学号和平均成绩。\n```mysql\nselect s_id, avg(sc_score)\nfrom score\ngroup by s_id\nhaving avg(sc_score)>60\n```\n![](../../images/MySQL_SQL/image-20250729034259743.png)\n\n\n\n查询所有同学的学号、姓名、选课总数、总成绩。\n```mysql\nselect s_id, s_name, count(c_id), sum(sc_score) from student left join score on student.s_id = score.s_id;\n```\n也可以这么写，嵌套select：\n```mysql\nselect student.s_id, student.s_name, count_id as XKS, sum_id as ZCJ\nfrom student\nleft join\n(select s_id, count(c_id), as count_id, sum(sc_score) as sum_id from score group by s_id) as ss\non student.s_id = ss.s_id;\n```\n![](../../images/MySQL_SQL/image-20250729034241165.png)\n\n查询没有选全部课的同学的学号、姓名。\n```mysql\nselect student.s_id, student.s_name from student, score\nwhere student.s_id = score.s_id\ngroup by student.s_id\nhaving count(score.c_id) < (select count(c_id) from course);\n```\n\n先让score表补充一列学生的姓名。\n再让此临时表，按学号（确定1人）分组，每一组的`s_id`数就是这个人选的课程数。\n\n结果\n![](../../images/MySQL_SQL/image-20250729040128046.png)\n\n删除`Kim`老师课的Score表记录\n为了看到效果，临时增加一条成绩。\n![](../../images/MySQL_SQL/image-20250729040422771.png)\n\n```mysql\ndelete from score\nwhere c_id in\n(select course.c_id from course inner join teacher on course.t_id = teacher.t_id where teacher.t_name = 'Kim');\n```\n后面的select，先让course表补充一列老师的名字，之后筛选出老师名字是Kim的course；\nin用于批量处理。\n\n结果：\n![](../../images/MySQL_SQL/image-20250729040946803.png)\n\n","categories":["数据库","MySQL"]},{"title":"MySQL_查询专题","url":"/数据库/MySQL_查询专题/","content":"\n# 内容\n\n1. 简单的查询语句\n2. 分页查询 - limit\n3. 排序、分组\n4. 连接查询（多表查询）\n\n# 存储过程\n\n为了模拟实际中的大数据场景，我们创建一个`t_user`数据库，`t_user`表，向其中添加200万条记录。\n\n表的创建：\n\n```mysql\ncreate table t_user(\n    id int(11) NOT NULL AUTO_INCREMENT,\n    email varchar(255) DEFAULT NULL,\n    password varchar(255) DEFAULT NULL,\n    PRIMARY KEY(id)\n)engine=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8;\n```\n\n\n\n需要用到存储过程。\n\n1. 首先改变分隔符`delimiter $`\n2. 创建存储过程\n\n```mysql\nCreate Procedure add_t_user(IN n INT)\nBEGIN\nDECLARE i INT;\nSET i=0;\n\nWHILE i<n DO\nINSERT INTO t_user VALUES(NULL, CONCAT(i+1,'@xcg.com'),i+1);\nSET i=i+1;\nEND WHILE;\nEND$\n```\n\n创建好后，可以`show create procedure add_t_user\\G`查看此存储过程。\n\n![image-20220517201206028](../../images/MySQL_查询专题/image-20220517201206028.png)\n\n3. 改回分隔符`delimiter ;`\n4. 调用存储过程`call add_t_user(2000000);`，括号内的参数为要添加的记录数。\n\n插入数据成功后，可以对其测试\n\n```mysql\nSELECT COUNT(*) FROM t_user;\t#应为2000000\n```\n\n```mysql\nSELECT * FROM t_user LIMIT 10;\n```\n\n```mysql\nSELECT * FROM t_user WHERE email='1@xcg.com';\nEXPLAIN SELECT * FROM t_user WHERE email='1@xcg.com';\n```\n\n# 简单的查询语句\n\n在这里我们示例一些简单的查询语句。\n\n* 无条件查询全部字段\n\n```mysql\nSELECT * FROM user;\t#不推荐，最好还是老老实实地写出所有字段名称，因为表的结构之后可能会变更，可能会影响业务代码。\n```\n\n* 条件查询指定字段\n\n```mysql\nSELECT name,age,sex FROM user WHERE age>=21;\nSELECT name,age,sex FROM user WHERE age>20 AND age<22;\nSELECT name,age,sex FROM user WHERE BETWEEN 20 AND 22;#闭区间\n```\n\n```mysql\n# 以下两个sql语句效果一致。\nSELECT name,age,sex FROM user WHERE age=20 OR age=21;\nSELECT name,age,sex FROM user WHERE age IN (20,21);\n```\n\n* 使用通配符查询\n\n```mysql\nSELECT name,age,sex FROM user WHERE name LIKE \"zhang%\";#必须用LIKE，不能用=等号，否则会把%通配符看作实际字符。\n```\n\n* 判断为空不用`=`，而用`IS NULL`\n\n```mysql\nSELECT name,age,sex FROM user WHERE name IS NULL;\nSELECT name,age,sex FROM user WHERE name IS NOT NULL;\n```\n\n## 去重\n\n有两种去重的方式\n\n1. `distinct` - 简单地去重\n2. `group by` - 功能强大，耗时\n\n```mysql\nSELECT DISTINCT age FROM user;\n```\n\n![image-20220517114906800](../../images/MySQL_查询专题/image-20220517114906800.png)\n\n## 合并查询 - union\n\n格式如下\n\n```\nSELECT expression1, expression2, ..., expression\nFROM table1 [WHERE conditions]\nUNION [ALL | DISTINCT(default)]\nSELECT expression1, expression2, ..., expression\nFROM table2 [WHERE conditions];\n# union默认为distinct去重，all表示显示重复的记录项\n```\n\n```mysql\nSELECT name,age,sex\nFROM user WHERE age>=21\nUNION ALL\nSELECT name,age,sex\nFROM user WHERE sex='M';\n```\n\n![image-20220517163204447](../../images/MySQL_查询专题/image-20220517163204447.png)\n\n# 分页查询 - limit\n\n需要掌握的内容：\n\n1. limit分页查询的语法\n2. `explain`可以查看SQL语句大致的执行计划\n3. limit在何种情况下能够提升查询效率，使用limit需要注意哪些\n4. 项目中用到分页处理时，如何编写相应的SQL语句\n\n## 语法\n\n### limit M,N - limit N\n\n```mysql\nSELECT * FROM user LIMIT N;\t\t#表示取user表第0~N条记录的所有字段，相当于取前N条\nSELECT * FROM user LIMIT M,N;\t#表示取user表第M~(M+N)条记录的所有字段，相当于先偏移M条，再取N条。\nSELECT * FROM user LIMIT N OFFSET M;\t#同LIMIT M,N\n```\n\nlimit只是改变了数据显示的效果吗？对查询的效率有没有提升呢？先引入一个关键字`explain`。\n\n>explain是一个关键字，是定位SQL、索引性能的有利工具。\n>\n>使用它加载SQL语句开头，可以查看SQL语句的执行计划。\n>\n>explain展示的字段：\n>\n>1. id: 编号\n>2. `select_type`: 如`SIMPLE`，表示查询语句的复杂程度类型\n>3. table: 如`user`，当前表\n>4. partitions: NULL\n>5. type: const\n>6. `possible_keys`: name，可能用到的索引\n>7. key: name，实际用到的索引\n>8. `key_len`: 152\n>9. ref: const\n>10. rows: 1，查询语句可能需要扫描的行数。\n>11. filtered: 100.00\n>12. Extra: NULL\n\n```mysql\nEXPLAIN SELECT * FROM user WHERE name='zhangsan';\n```\n\n![image-20220517192840144](../../images/MySQL_查询专题/image-20220517192840144.png)\n\n我们发现，搜索\"zhangsan\"只扫了1行。可能你会猜测是因为他在表的第一行，那么试试查找其他人扫描几行呢？\n\n```mysql\nEXPLAIN SELECT * FROM user WHERE name='chenwei';\nEXPLAIN SELECT * FROM user WHERE name='zhanglan';\n```\n\n![image-20220517193136218](../../images/MySQL_查询专题/image-20220517193136218.png)\n\n发现仍是`row=1`。\n\n这是因为name有索引。\n\n我们再试试与age有关的查询语句。\n\n```mysql\nEXPLAIN SELECT * FROM user WHERE age=20;\n```\n\n![image-20220517193519105](../../images/MySQL_查询专题/image-20220517193519105.png)\n\n我们发现现在的row为5。相当于把user表进行了全表搜索。\n\n相比于与name有关的查询语句，由于age没有索引，查询的效率就很低。\n\n怎么尽可能提高效率呢？\n\n如果我们只想得到第一个满足条件的记录，那么可以用limit。\n\n```mysql\nSELECT * FROM user WHERE age=20 LIMIT 1;\n```\n\n理论上，EXPLAIN此语句的rows应较小，但实际上rows还是5。\n\n```mysql\nEXPLAIN SELECT * FROM user WHERE age=20 LIMIT 1;\n```\n\n![image-20220517194317756](../../images/MySQL_查询专题/image-20220517194317756.png)\n\n说明EXPLAIN不能看到limit的作用。\n\n---\n\n我们现在对拥有200w条记录的`t_user`表进行测试。\n\n```mysql\nSELECT * FROM t_user WHERE email='1@xcg.com';\t\t#约0.44s\nEXPLAIN SELECT * FROM t_user WHERE email='1@xcg.com';\nSELECT * FROM t_user WHERE email='1@xcg.com' LIMIT 1;#约0.00s\n```\n\n```mysql\nSELECT * FROM t_user LIMIT 1000000, 1;#约0.20s，说明偏移也很费时\nSELECT * FROM t_user WHERE email='1000001@xcg.com';\t#约0.44s\nSELECT * FROM t_user WHERE email='1000001@xcg.com' LIMIT 1;\t#约0.23s\n```\n\n## 分页需要注意的事情\n\n首先需要明白分页的参数`pagenum=20`，表示每页显示的记录数为20；`pageno`表示当前的页码。\n\n那么，根据LIMIT的`M,N`规则，计算出下面的语句公式：\n\n```mysql\nSELECT * FROM user LIMIT (pageno-1)*pagenum, pagenum;\n```\n\n这样就实现了每一页显示对应位置的20条记录。\n\n但是，有个很现实的性能问题，我们总不能让越往后的页数查出来的时间越久吧？因为LIMIT M,N默认是全表顺序查询，查后面的数据时，会在前面查很多冗余的信息，浪费了时间。\n\n```mysql\nSELECT * FROM t_user LIMIT 0, 20;\t#0.00s\nSELECT * FROM t_user LIMIT 1000000, 20;\t#0.23s\n```\n\n可以用一个思想来优化性能——过滤。\n\n我们知道，其主键id是有规律的，可根据对id的限制来进行过滤。\n\n```mysql\nSELECT * FROM t_user WHERE id>2000000 LIMIT 0, 20;#0.00s\n```\n\n上面的语句和`SELECT * FROM t_user LIMIT 1000000, 20;`查询出来的结果一样。但是性能却大大提升。\n\n即\n\n```mysql\nSELECT * FROM user WHERE id>上一页最后一条数据的id值 LIMIT 0, 20;\n```\n\n但是，不是每个分页都通过id来解决，具体问题具体分析，选择合适的索引去过滤，不一定非要选id。\n\nLIMIT可以很好地帮助我们在没有索引的情况下，以相应的列作为过滤条件时，提高效率。\n\n# 连接查询\n\n分为两种\n\n1. 内连接查询\n2. 外连接查询\n    1. left连接查询\n    2. right连接查询\n\n![image-20220518111035278](../../images/MySQL_查询专题/image-20220518111035278.png)\n\n## 内连接\n\n场景分析：学生、课程、考试结果\n\nstudent: `uid、name、age、sex`\n\ncourse: `cid、cname、credit`\n\nexam: `uid、cid、time、score`\n\n```mysql\nCREATE TABLE student(\n    uid INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    name VARCHAR(50) NOT NULL,\n    age TINYINT UNSIGNED NOT NULL,\n    sex ENUM('M', 'W') NOT NULL\n);\nCREATE TABLE course(\n    cid INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    cname VARCHAR(50) NOT NULL,\n    credit TINYINT UNSIGNED NOT NULL\n);\nCREATE TABLE exam(\n    uid INT UNSIGNED NOT NULL,\n    cid INT UNSIGNED NOT NULL,\n    time DATE NOT NULL,\n    score FLOAT NOT NULL\n    PRIMARY KEY(uid,cid) #联合主键\n);\nDESC student;\nDESC course;\nDESC exam;\nINSERT INTO student(name,age,sex) VALUES\n('zhangsan', 18, 'M'),\n('gaoyang', 20, 'W'),\n('chenwei', 22, 'M'),\n('liufeng', 21, 'W'),\n('liuxiang', 19, 'W');\nINSERT INTO course(cname,credit) VALUES\n('C++基础课程', 5),\n('C++高级课程', 10),\n('C++项目开发', 8),\n('C++算法课程', 12),\nINSERT INTO exam(uid,cid,time,score) VALUES\n(1, 1, '2022-04-09', 99.0),\n(1, 2, '2022-04-10', 90.0),\n(2, 2, '2022-04-10', 90.0),\n(2, 3, '2022-04-12', 85.0),\n(3, 1, '2022-04-09', 56.0),\n(3, 2, '2022-04-10', 93.0),\n(3, 3, '2022-04-12', 89.0),\n(3, 4, '2022-04-11', 100.0),\n(4, 4, '2022-04-11', 99.0),\n(5, 2, '2022-04-10', 59.0),\n(5, 3, '2022-04-12', 94.0),\n(5, 4, '2022-04-11', 95.0);\n```\n\nzhangsan同学某门课的考试成绩，假设知道预置条件：学号uid: 1、课程号cid: 2\n\n```mysql\nSELECT score FROM exam WHERE uid=1 AND cid=2;\n```\n\n![image-20220518113024474](../../images/MySQL_查询专题/image-20220518113024474.png)\n\n按上面这样查，只能查出score: 80。其他的信息没有，这样给出的信息过少。\n\n怎么进行内连接查询，以获取更多信息呢？\n\n先查学生表和考试创建表：由于学生中要根据uid，考试成绩中也是要根据uid，所以属于公有的内容，属于内连接。\n\n下面是两个表单独的SQL：\n\n```mysql\nSELECT uid,name,age,sex FROM student WHERE uid=1;\nSELECT score FROM exam WHERE uid=1 AND cid=2;\n```\n\n我们把它想办法合并：\n\n各表中可能有重复的字段名，所以需要给表起别名\n\n```mysql\nSELECT S.uid,S.name,S.age,S.sex FROM student S WHERE S.uid=1;\n\nSELECT E.score FROM exam E WHERE E.uid=1 AND E.cid=2;\n```\n\n我们发现，两个SQL语句的共同点是uid为1。则是按uid来进行关联的。\n\n```mysql\nSELECT S.uid,S.name,S.age,S.sex,E.score FROM student S\nINNER JOIN exam E\nON S.uid=E.uid\t#拿什么来关联\nWHERE E.uid=1 AND E.cid=2;\t#过滤的条件，即1、查的是某个人；2、查的是某门课\n```\n\n![image-20220518144857264](../../images/MySQL_查询专题/image-20220518144857264.png)\n\n连接查询的性能分析：\n\n`on S.uid=E.uid`按照表中记录的数目来区分大表和小表，小表永远是整表扫描，然后去大表搜索。即从`student`小表中取出所有的`S.uid`，然后拿着这些`uid`去`exam`大表中搜索。\n\n继续：现在只有学生信息、分数，但是没有课程信息。\n\n现在我们发现，如果基于`select ... from student`的话，无法与course表进行关联。因为student表中无cid。而如果基于eaxm查的话，就很顺利，因为exam表既有uid又有cid，既可与student表关联，又可与course表关联。\n\n于是我们就需要改造select语句的第一句中的`FROM ...`。把`FROM student`改为`FROM exam`。\n\n```mysql\nSELECT S.uid,S.name,S.age,S.sex,E.score FROM eaxm E\nINNER JOIN student S\nON S.uid=E.uid\n...\n```\n\n然后，我们接下来要做的就是再去内连接course表，以产生exam与其的关联。先写出要查course表信息的单独的SQL语句：\n\n```mysql\nSELECT cid,cname,credit FROM course C WHERE C.cid=2;\n```\n\n然后再加入到内连接语句中去：\n\n```mysql\nSELECT  S.uid,S.name,S.age,S.sex,\n\t\tC.cid,C.cname,C.credit,\n\t\tE.score FROM eaxm E\nINNER JOIN student S ON E.uid=S.uid\nINNER JOIN course C ON E.cid=C.cid\nWHERE E.uid=1 AND E.cid=2;\n```\n\n以上就是三表内连接查询的标准写法。\n\n## 内连接的应用 - 与分页结合提升性能\n\n前面我们研究过了，如果直接按LIMIT M,N进行先偏移后查询的方法来进行的话，越往后性能越差。\n\n分页 - 第一个方案，最差：\n\n![image-20220518163625400](../../images/MySQL_查询专题/image-20220518163625400.png)\n\n同时我们也发现，查询的效率也与查询的字段个数有关系，比如只查id的话，性能就会有所提升。\n\n分页 - 第二个方案，适中，但是信息少：\n\n![image-20220518163818854](../../images/MySQL_查询专题/image-20220518163818854.png)\n\n最极致性能的办法，但是常常不通用——先过滤id，直接从过滤完的位置LIMIT查询N条记录。但是这要求我们知道当前的id值及其条件，通常情况下不能实现，我们只清楚目前偏移到了多少位置，一次取多少条。\n\n分页 - 第三个方案，极致，但是往往不能实现：\n\n![image-20220518164026806](../../images/MySQL_查询专题/image-20220518164026806.png)\n\n我们再把目光转到第二个方案 - 即只查id。\n\n为了尽可能提高性能，我们只查出了id这一列。目前的信息量过少。但是**我们却可以利用查出的id数据，与自己的原表进行内连接**。这是基本思想。\n\n```mysql\nSELECT U.id,U.email,U.password FROM t_user U\nINNER JOIN (SELECT id FROM t_user LIMIT 1500000,10) temp ON U.id=temp.id;\n```\n\n如此不仅仅可以得到更多信息，而且效率和只查id这一列一致。\n\n![image-20220518164514376](../../images/MySQL_查询专题/image-20220518164514376.png)\n\nexplain此语句的结果：\n\n![image-20220518164909106](../../images/MySQL_查询专题/image-20220518164909106.png)\n\n### 总结 - 内连接的过程\n\n> 在做实验之前，先声明一下表中的最新内容\n> ![image-20220519082805106](../../images/MySQL_查询专题/image-20220519082805106.png)\n\n```mysql\nSELECT S.*,E.* FROM student S\nINNER JOIN exam E ON S.uid=E.uid;\n```\n\n![image-20220519083428353](../../images/MySQL_查询专题/image-20220519083428353.png)\n\n```mysql\nEXPLAIN\nSELECT S.*,E.* FROM student S\nINNER JOIN exam E ON S.uid=E.uid;\n```\n\n![image-20220519084255059](../../images/MySQL_查询专题/image-20220519084255059.png)\n\n如果我们通过where过滤条件使Exam从大表变小表呢？\n\n```mysql\nSELECT S.*,E.* FROM student S\nINNER JOIN exam E ON S.uid=E.uid\nWHERE E.cid=3;\n```\n\n![image-20220519090035026](../../images/MySQL_查询专题/image-20220519090035026.png)\n\n我们看到，在E表进行内连接时，需要先过滤，即E需要进行全表扫描，然后E成为小表（相比于S表），然后，再拿剩下的记录与S表比对。\n\nE表没有用到cid的索引，因为uid和cid是联合索引，只有先用uid索引，cid才有效。\n\n再看一个 - 把where的过滤条件改到on中。和上面有区别吗？\n\n```mysql\nSELECT S.*,E.* FROM student S\nINNER JOIN exam E ON S.uid=E.uid and E.cid=3;\n```\n\n![image-20220519091420259](../../images/MySQL_查询专题/image-20220519091420259.png)\n\n发现，对于`inner join`内连接，过滤条件不管写在where的后面和on连接条件里面，效果是一样的。而且extra里写明第一个是`Using where`，说明mysql为我们做了优化，改成了where过滤，因为where过滤后再查询的效率会更好。\n\n## 外连接\n\n格式：\n\n```\n#左连接查询\n#显示left表所有数据，右表中如果不存在相应数据则显示NULL\nSELECT a.属性名列表, b.属性名列表 FROM table_a a\nLEFT [OUTER] JOIN table_b b ON a.id=b.id;\n\n#右连接查询\n#显示right表所有数据，左表中如果不存在相应数据则显示NULL\nSELECT a.属性名列表, b.属性名列表 FROM table_a a\nRIGHT [OUTER] JOIN table_b b ON a.id=b.id;\n```\n\n\n\n```mysql\nSELECT S.*,E.* FROM student S\nLEFT JOIN exam E ON S.uid=E.uid;\n```\n\n![image-20220519094125697](../../images/MySQL_查询专题/image-20220519094125697.png)\n\n```mysql\nSELECT S.*,E.* FROM student S\nRIGHT JOIN exam E ON S.uid=E.uid;\n```\n\n![image-20220519094314249](../../images/MySQL_查询专题/image-20220519094314249.png)\n\n```mysql\nEXPLAIN SELECT S.*,E.* FROM student S\nINNER JOIN exam E ON S.uid=E.uid;\n\nEXPLAIN SELECT S.*,E.* FROM student S\nLEFT JOIN exam E ON S.uid=E.uid;\n\nEXPLAIN SELECT S.*,E.* FROM student S\nRIGHT JOIN exam E ON S.uid=E.uid;\n```\n\n![image-20220519100936236](../../images/MySQL_查询专题/image-20220519100936236.png)\n\n---\n\n实际的问题：能不能查出来谁没参加考试？\n\n```mysql\nSELECT * FROM student WHERE uid NOT IN (SELECT DISTINCT uid FROM exam);\n```\n\n上面这个SQL虽然可以完成，但是NOT IN是否能够用到索引是不容易确定的。另外，子查询的结果可能会生成临时表。\n\n用外连接来解决：\n\n```mysql\nSELECT S.* FROM student S\nLEFT JOIN exam E ON S.uid=E.uid\nWHERE E.cid IS NULL;\n```\n\n![image-20220519101959096](../../images/MySQL_查询专题/image-20220519101959096.png)\n\nExplain查看查询流程：\n\n![image-20220519102456318](../../images/MySQL_查询专题/image-20220519102456318.png)\n\n拿student表所有数据与exam表对比。exam表中的uid和cid是联合主键，因为uid是第一列索引，所以可以使用uid索引。\n\n---\n\n## 外连接和内连接的区别\n\n参加过某一门考试的人\n\n先用内连接来写：\n\n```mysql\nSELECT S.* FROM student S\nINNER JOIN exam E ON S.uid=E.uid\nWHERE E.cid=3;\n```\n\n![image-20220519103001353](../../images/MySQL_查询专题/image-20220519103001353.png)\n\n没有参加cid为3的考试的人\n\n```mysql\nSELECT S.* FROM student S\nLEFT JOIN exam E\nON S.uid=E.uid\nWHERE E.uid=3\nAND E.cid IS NULL;\n```\n\n```mysql\nSELECT S.* FROM student S\nLEFT JOIN exam E\nON S.uid=E.uid\nWHERE E.uid=3;\n```\n\n```mysql\nSELECT S.* FROM student S\nLEFT JOIN exam E\nON S.uid=E.uid AND E.cid=3;\n```\n\n![image-20220519103539550](../../images/MySQL_查询专题/image-20220519103539550.png)\n\n```mysql\nSELECT S.* FROM student S\nLEFT JOIN exam E\nON S.uid=E.uid AND E.cid=3\nWHERE E.cid IS NULL;\n```\n\n![image-20220519103820392](../../images/MySQL_查询专题/image-20220519103820392.png)\n\n我们发现，where条件和on条件在内外连接上需要斟酌。\n\n---\n\nexplain分析\n\n![image-20220519104015360](../../images/MySQL_查询专题/image-20220519104015360.png)\n\n![image-20220519104102999](../../images/MySQL_查询专题/image-20220519104102999.png)\n\n这样写内连接和外连接无区别。都是先使用where过滤，然后exam变为小表。拿exam全部数据（主键）去student搜索。这样的外连接是不正确的。\n\n```mysql\nEXPLAIN SELECT S.* FROM student S\nLEFT JOIN exam E ON S.uid=E.uid AND E.uid=3;\n```\n\n![image-20220519112753295](../../images/MySQL_查询专题/image-20220519112753295.png)\n\n把`E.uid=3`放在on后面才会对student表进行全表扫描。进而去exam表中匹配。\n\n然后我们再在这个正确外连接后的基础上，再加`WHERE E.cid IS NULL`，这才能正确显示未参加cid为的考试的学生。\n\n```mysql\nSELECT S.* FROM student S\nLEFT JOIN exam E ON S.uid=E.uid AND E.uid=3\nWHERE E.cid IS NULL;\n```\n\n![image-20220519113227107](../../images/MySQL_查询专题/image-20220519113227107.png)\n\n因此我们总结出了一条经验：外连接中，连接时的限制条件要放到ON后面，然后把NULL的过滤条件放到最后的where中。\n# 连接查询中的索引影响性能\n![](../../images/MySQL_查询专题/image-20250731013505045.png)\n\n小表决定循环的次数，大表决定每次循环的查询时间。","categories":["数据库","MySQL"]},{"title":"MySQL_范式设计","url":"/数据库/MySQL_范式设计/","content":"# 内容\n\n1. 关系型数据库范式\n2. 应用范式的好处\n3. 第一范式\n4. 第二范式\n5. 第三范式\n6. BC范式\n7. 第四范式\n\n# 应用范式的好处\n\n范式和表的设计有什么关系呢？可以说是息息相关，表设计过程中需要知道的规则，在范式设计中，都会有所提及。可以说，范式是表设计原则的提炼。\n\n表设计原则是告诉我们怎么设计表之间的关联，并且尽量减少数据冗余。\n\n而应用范式最重要的好处也是**减少数据冗余**。由此带来的好处有：\n\n1. 消除异常（插入异常、更新异常、删除异常）\n2. 让数据组织地更加和谐\n\n# 第一范式\n\n> 1. 每一列保持原子特性\n> 2. 不符合第一范式则不能称作关系型数据库。比如key-value，因为key对应的value可能包含了各种杂乱的信息，例如json数据。\n\n列都是基本数据项，不能再进行分割，否则设计成一对多的实体关系。\n\n例如表中的地址字段，可以再细分为省、市、区等不可再分割的字段。\n\n![image-20220516163422062](../../images/MySQL_范式设计/image-20220516163422062.png)\n\n上图的Employee表中的Address字段，就没有遵循第一范式。即地址信息可以细分为很多详细的地址。如果没有去规范地址的分类，则就会造成地址数据粒度太粗。如果我们要查询某一特定地址的雇员信息，还要从地址字符串中提取相关信息，过于麻烦。\n\n![image-20220516163314051](../../images/MySQL_范式设计/image-20220516163314051.png)\n\n我们现在将Address抽取出来作为一个单独的表，让地址字段分成更详细的city、country、street三个字段。再让Employee表与其关联，则可解决Address粒度过粗的问题。\n\n查询指定EmployeeID的职员的地址信息。\n\n```mysql\n# 方法一：带in的子查询，子查询效率较低\nselect * from EmployeeAddress where addressID in (select AddressID from Employee where EmployeeID=1);\n# 用连接查询效率高一些。\n```\n\n# 第二范式\n\n> 属性完全依赖于主键 - 主要针对联合主键\n\n非主属性（不是主键的字段）必须完全依赖主关键字（包括联合主键的每一列），如果不是完全依赖主键，应该拆分成新的实体，设计成一对多的实体关系。\n\n例如教务系统中的选课：\n选课关系表为`SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)`。\n则`(学号, 课程名称)`是联合主键，\n但是**学分字段只与课程名称有关，与学号无关**，相当于只依赖联合主键的其中一个字段 - `课程名称`，不符合第二范式。\n姓名、年龄只和学号有关，与课程名称无关。只依赖联合主键的其中一个字段 - `学号`，不符合第二范式。\n\n总之，学分在此表中属于冗余存储。`姓名`和`年龄`字段也属于冗余存储。\n\n学生和课程之间，属于多对多的关系。\n\n学生表：\n\n| 学号  | 姓名  | 年龄  |\n| --- | --- | --- |\n\n课程表：\n\n| 课程id | 课程名称 | 学分 |\n| ------ | -------- | ---- |\n\n选课情况（中间表）：\n\n| 学号 | 课程id | 成绩 |\n| ---- | ------ | ---- |\n\n---\n\n再例如，上面的Employee表。经历了第一范式之后，仍存在问题。\n\n该表存在联合主键`(EmployeeID, departmentName)`。表中`Name`字段明显与`departmentName`不存在关系。因此不符合第二范式。\n\n则把department有关信息\n\n![image-20220516202334294](../../images/MySQL_范式设计/image-20220516202334294.png)\n\n# 第三范式\n\n> 属性不依赖于其他非主属性。\n>\n> 一般的关系型数据库满足第三范式就足够了。\n\n要求一个数据表中不包含已在其他表中已包含的非主关键字信息。\n\n示例：\n学生关系表为`Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)`，\n字段`学号`是主键。\n但是，字段`学院地点`、`学院电话`依赖于非主属性`所在学院`，并不依赖于主键`学号`。\n因此该设计不符合第三范式。\n应该把学院单独设计成一张表，学院和学生是一对多的关系。\n\n---\n\n再如Employee表中的问题，发现字段`jobDescription`并不依赖于主键`EmployeeID`，而是依赖非主属性`job`。不符合第三范式。因此把`job`有关的属性抽取出来单独作为`job`表。工作和雇员也是一对多的关系。\n\n![image-20220517082159583](../../images/MySQL_范式设计/image-20220517082159583.png)\n\n# BC范式\n\n> 每个表中只有一个候选键\n\nBC范式是在第三范式的基础上的一种特殊情况，即每个表中只有一个**候选键**（在一个数据库中，每行的值都不相同，则可称为候选键）。Employee表中可以看出，每一个员工的`email`都是唯一的（逻辑上来说，邮箱是单人单用），则上表不符合BC范式。\n\n应把邮箱单独抽出作为一张表。邮箱与雇员属于一对一的关系。\n\n![image-20220517084229658](../../images/MySQL_范式设计/image-20220517084229658.png)\n\n# 第四范式\n\n> 消除表中的多值依赖\n\n简单来说，第四范式就是要消除表中的多值依赖，也就是说可以减少数据一致性的工作。比如Employee表中的字段`skill`，有的人是`\"java, mysql\"`，有的人是`\"Java, MySQL\"`，这样数据就不一致了。\n\n解决方案就是将多值属性放入一个新表。Employee表则是把`skill`抽出作为一张表。雇员和技能是一对多的关系。\n\n![image-20220517085547889](../../images/MySQL_范式设计/image-20220517085547889.png)\n\n| skill  | EmployeeID |\n| ------ | ---------- |\n| C++    | 1000       |\n| Java   | 1000       |\n| MySQL  | 2000       |\n| Golang | 2000       |\n| Rust   | 1000       |\n| C++    | 2000       |\n\n# 总结\n\n* 范式含义\n* 好处：应用数据库范式可以带来许多好处,但是最重要的好处归结为三点：\n    1. 减少数据沉余(这是最主要的好处，其他好处都是由此而附带的)\n    2. 消除异常(插入异常、更新异常、删除异常\n    3. 让数据组织的更加和谐\n* 缺点：但是数据库范式绝对不是越高越好，范式越高，意味着表越多，多表联合查询的机率就越大，SQL的效率就变低。","categories":["数据库","MySQL"]},{"title":"Linux_exit","url":"/Linux/Linux_exit/","content":"\n# 内容\n\n1. \n2. `exit`\n3. 僵死进程\n\n# 进程终止方式\n\n![image-20220515093901952](../../images/Linux_exit/image-20220515093901952.png)\n\n## 进程5种正常终止方式\n\n1. 从main返回，即在main函数内执行`return`语句，等效于调用`exit`。\n2. 调用`exit`函数。此函数由`ISO C`定义，其操作包括调用各终止处理程序（终止处理程序在调用`atexit`函数时登记），然后关闭所有标准I/O流等。因为`ISO C`并不处理文件描述符、多进程（父进程和子进程）以及作业控制，所以这一定义对UNIX系统而言是不完整的。\n3. 调用`_exit`或`_Exit`函数。`ISO C`定义`_Exit`，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗取决于实现方式。在UNIX系统中，`_Exit`和`_exit`是同义的，并不冲洗标准I/O流。`_exit`函数由`exit`调用，它处理UNIX系统特定的细节。`_exit`是由`POSIX.1`说明的。\n\n   > 在大多数UNIX系统实现中，`exit(3)`是标准C库中的一个函数，而`_exit(2)`则是一个系统调用。\n4. 最后一个线程从其启动例程返回中执行return语句。但是该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。\n5. 从最后一个线程调用`pthread_exit`函数。如同前面一样，在这种情况中，进程终止状态总是0，这与传送给`pthread_exit`的参数无关。\n\n## 进程3种异常终止方式\n\n1. 调用abort。产生`SIGABRT`信号，这是下一种异常终止的一种特例。\n2. 当进程接收到某些信号时。信号可由进程自身（如调用`abort`函数）、其他进程或内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生相应的信号。\n3. 最后一个线程对取消(cancellation)请求做出响应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止。\n\n## 总结\n\n不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。\n\n对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(`exit`、`_exit`和`_Exit`)，实现这一点的方法是将其退出状态(`exit status`)作为参数传送给函数。在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的终止状态(`termination status`)。在任意一种情况下，该终止进程的父进程都能用`wait`或`waitpid`函数取得其终止状态。\n\n注意，这里使用了“**退出状态**”(它是传递给向3个终止函数的参数，或`main`的返回值)和“**终止状态**”两个术语，以表示有所区别。在最后调用`_exit`时，内核将退出状态转换成终止状态。\n\n父进程检查子进程终止状态的方法有很多。如果子进程正常终止，则父进程可以获得子进程的退出状态。\n\n# 父子进程终止问题\n\n## 孤儿进程\n\n在说明`fork`函数时，显而易见，子进程是在父进程调用fork后生成的。上面又说明了子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，又将如何呢？其回答是：\n\n如果某进程的父进程已经终止，它们的父进程都改变为`init`进程。我们称这些进程由`init`进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则更改该进程的父进程ID为1 (`init`进程的ID)。这种处理方法保证了每个进程有一个父进程。\n\n## 僵死进程\n\n另一个我们关心的情况是，如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用`wait`或`waitpid`时可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。\n\n内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为**僵死进程(zombie)**。`ps(1)`命令将僵死进程的状态打印为`Z`。如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程。\n\n> 最后一个要考虑的问题是：一个由`init`进程收养的进程终止时会发生什么？它会不会变成一个僵死进程？\n>\n> 对此问题的回答是“否”，因为`init`被编写成无论何时只要有一个子进程终止，init就会调用一个`wait`函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。\n>\n> 当提及“一个`init`的子进程”时，这指的可能是`init`直接产生的进程（如getty进程），也可能是其父进程已终止，由`init`收养的进程。\n\n# 退出函数\n\n3个函数用于正常终止一个程序：`_exit`和`_Exit`立即进入内核，`exit`则先执行一些清理处理，然后返回内核。\n\n```c\n#include<stdlib.h>\nvoid exit(int status);\nvoid _Exit(int status);\n#include<unistd.h>\nvoid _exit(int status);\n```\n\n调用这三个函数的进程对其他进程有一定影响（如其父进程和子进程）。\n\n> 使用不同头文件的原因是`exit`和`_Exit`是由`ISO C`说明的，而`_exit`是由`POSIX.1`说明的。\n\n由于历史原因，`exit`函数总是执行一个标准I/O库的清理关闭操作：对于所有打开流调用`fclose`函数，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。\n\n3个退出函数都带一个整型参数，称为**终止状态**（或退出状态，`exit status`)。大多数UNIX系统shell都提供检查进程终止状态的方法。如果(a)调用这些函数时不带终止状态，或`(b)main`执行了一个无返回值的`return`语句，或`(c)main`没有声明返回类型为整型，则该进程的终止状态是未定义的。但是，若main的返回类型是整型，并且main执行到最后一条语句时返回（隐式返回），那么该进程的终止状态是0。\n\n> 这种处理是ISO C标准1999版引入的。历史上，若main函数终止时没有显式使用return语句或调用exit函数，那么进程终止状态是未定义的。\n>\n> 比如以下程序：\n> ```c\n> #include<stdio.h>\n> main()\n> {\n>     printf(\"hello, world!\\n\");\n> }\n> ```\n>\n> 对该程序进行编译，然后运行，则可见到其终止码是随机的。如果在不同的系统上编译该程序，我们很可能得到不同的终止码，这**取决于main函数返回时栈和寄存器的内容**\n>\n> ```bash\n> $ gcc hello.c\n> $ ./a.out\n> hello,world\n> $ echo $?\t# $? 为终止状态码\n> 13\n> ```\n>\n> 现在，我们启用1999 ISO C编译器扩展，则可见到终止码改变了：\n>\n> ```bash\n> $ gcc -std=c99 hello.c\t# 启用gcc的1999 ISO C扩展\n> hello.c:4: warning: return type defaults to 'int'\n> $ ./a.out\n> hello,world\n> $ echo $?\t# $? 为终止状态码\n> 0\t\t\t# 此处处理为0\n> ```\n\nmain函数返回一个整型值与用该值调用`exit`是等价的。于是在main函数中`exit(0);`等价于`return(0);`。\n\n# wait\n\n当一个进程正常或异常终止时，内核就向其父进程发送`SIGCHLD`信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。\n\n父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。\n\n现在需要知道的是调用`wait`或`waitpid`的进程可能会发生什么。\n\n* 如果其所有子进程都还在运行，则阻塞。\n* 如果**一个**子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。\n* 如果它没有任何子进程，则立即出错返回。\n\n如果进程由于接收到`SIGCHLD`信号而调用`wait`， 我们期望`wait`会立即返回。但是如果在随机时间点调用`wait`， 则进程可能会阻塞。\n\n## api\n\n```c\n#include<sys/wait.h>\npid_t wait(int * statloc);\npid_t waitpid(pid_t pid, int * statloc, int options);\n//两个函数返回值：若成功，返回进程ID；若出错，返回0或-1\n```\n\n这两个函数的区别如下。\n\n* 在一个子进程终止前，`wait`使其调用者阻塞；而`waitpid`有一选项，可使调用者不阻塞。\n* `waitpid`并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。\n\n如果子进程已经终止，并且是一个僵死进程，则`wait`立即返回并取得该子进程的状态；否则`wait`使其调用者阻塞，直到一个子进程终止。如调用者阻塞而且它有多个子进程，则在其某一子进程终止时，`wait`就立即返回。因为`wait`返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。\n\n这两个函数的参数`statloc`是一个整型指针。如果`statloc`不是一个空指针，则终止进程的**终止状态就存放在它所指向的单元**内。如果不关心终止状态，则可将该参数指定为空指针。\n\n依据传统，这两个函数返回的整型状态字是由实现定义的。其中某些位表示退出状态（正常返回），其他位则指示信号编号（异常返回），有一位指示是否产生了`core`文件等。`POSIX.1`规定，终止状态用定义在`<sys/wait.h>`中的各个宏来查看。有4个互斥的宏可用来取得进程终止的原因，它们的名字都以`WIF`开始。基于这4个宏中哪一个值为真，就可选用其他宏来取得退出状态、信号编号等。\n\n![image-20220515100404070](../../images/Linux_exit/image-20220515100404070.png)\n\n正如前面所述，如果一个进程有几个子进程，那么只要有一个子进程终止，wait就返回。\n\n如果要等待一个指定的进程终止（如果知道要等待进程的ID），那么该如何做呢？在早期的UNIX版本中，必须调用`wait`，然后将其返回的进程ID和所期望的进程ID相比较。如果终止进程不是所期望的，则将该进程ID和终止状态保存起来，然后再次调用`wait`。反复这样做，直到所期望的进程终止。下一次又想等待一个特定进程时，先查看已终止的进程列表，若其中已有要等待的进程，则获取相关信息；否则调用`wait`。其实，我们需要的是等待一个特定进程的函数。POSIX定义了`waitpid`函数以提供这种功能（以及其他一些功能）。\n对于`waitpid`函数中`pid`参数的作用解释如下。\n\n| 参数值    | 作用                                                |\n| --------- | --------------------------------------------------- |\n| `pid==-1` | 等待任一子进程。此种情况下，`waitpid`与`wait`等效。 |\n| `pid>0`   | 等待进程ID与pid相等的子进程。                       |\n| `pid==0`  | 等待**组ID**等于调用进程组ID的任一子进程。          |\n| `pid<-1`  | 等待**组ID**等于pid绝对值的任一子进程。             |\n\n`waitpid`函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由`statloc`指向的存储单元中。\n\n对于`wait`，其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返回另一种出错）。但是对于`waitpid`，如果指定的进程或进程组不存在，或者参数`pid`指定的进程不是调用进程的子进程，都可能出错。\n\noptions参数使我们能进一步控制`waitpid`的操作。此参数或者是0，或者是下表中常量按位或运算的结果。\n\n![image-20220515101143654](../../images/Linux_exit/image-20220515101143654.png)\n\nwaitpid函数提供了wait函数没有提供的3个功能。\n\n1. `waitpid`可等待一个特定的进程；而`wait`则返回任一终止子进程的状态。在讨论`popen`函数时会再说明这一功能。\n2. `waitpid`提供了一个`wait`的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。\n3. `waitpid`通过`WUNTRACED`和`WCONTINUED`选项支持作业控制。\n\n# 避免僵死进程的方法\n\n回忆有关僵死进程的讨论。如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止，实现这一要求的诀窍是调用fork两次。\n\n```c\n#include<sys/wait.h>\nint main(void)\n{\n    pid_t pid;\n    if((pid = fork()) < 0)\n    {\n        err_sys(\"fork error\");\n    }\n    else if(pid == 0)\t//第一个子进程\n    {\n        if((pid = fork()) < 0)\t//子进程再次fork\n        {\n            err_sys(\"fork error\");\n        }\n        else if(pid > 0)\t\t//子进程退出\n        {\n            exit(0);\n        }\n        sleep(2);\n        printf(\"child's child, parent pid = %ld\\n\", (long)getppid());\n        exit(0);\n    }\n    if(waitpid(pid, NULL, 0) != pid)\n    {\n        err_sys(\"waitpid error\");\n    }\n    exit(0);\n}\n```\n\n在fork之后，如果不使第二个子进程休眠，那么它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程，而不是`init`进程（进程ID 1）。第二个子进程调用sleep以保证在打印父进程ID时第一个子进程已终止。\n\n执行程序得到：\n\n```\n$ ./a.out\n$ child's child, parent pid = 1\n```\n\n注意，当原先的进程（也就是exec本程序的进程）终止时，shell打印其提示符，这在第二个子进程打印其父进程ID之前。\n\n# 竞争条件\n\n当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了**竞争条件(race condition)**。如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行，那么fork函数就会是竞争条件活跃的滋生地。\n\n通常，我们不能预料哪一个进程先运行。即使我们知道哪一个进程先运行，在该进程开始运行后所发生的事情也依赖于系统负载以及内核的调度算法。\n\n在上个程序中，当第二个子进程打印其父进程ID时，我们看到了一个潜在的竞争条件。如果第二个子进程在第一个子进程之前运行，则最终其父进程将会是第一个子进程，则就会成为僵死进程。但是，如果第一个子进程先运行，并有足够的时间到达并执行`exit`（最关键是在第二个子进程退出前，第一个子进程退出，使第二个子进程变为孤儿进程），则第二个子进程的父进程就是`init`。即使在程序中调用`sleep`，也不能保证什么。如果系统负载很重，那么在`sleep`返回之后、第一个子进程得到机会运行之前，第二个子进程可能恢复运行。这种形式的问题很难调试，因为在大部分时间，这种问题并不出现。\n\n如果一个进程希望等待一个子进程终止，则它必须调用`wait`函数中的一个；反过来，如果一个进程要等待其父进程终止，则可使用下列形式的循环：\n\n```c\nwhile(getppid()!=1)\n\tsleep(1)；\n```\n\n这种形式的循环称为轮询(polling)，它的问题是浪费了CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试。\n\n为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制作为解决此方面问题的一种用法。各种形式的进程间通信(IPC)也可解决此问题。\n\n在父进程和子进程的关系中，常常出现下述情况。在fork之后，父进程和子进程都有一些事情要做。例如，父进程可能要用子进程ID更新日志文件中的一个记录，而子进程则可能要为父进程创建一个文件。在本例中，要求每个进程在执行完它的一套初始化操作后要通知对方，并且在继续运行之前，要等待另一方完成其初始化操作。这种情况可以用代码描述如下：\n\n```c\n#include\"apue.h\"\nTELL_WAIT();\nif((pid = fork()) < 0)\n{\n    errsys(\"fork error\");\n}\nelse if(pid == 0)\n{\n    TELL_PARENT(getppid());\n    WAIT_PARENT();\n    exit(0);\n}\nTELL_CHILD(pid);\nWAIT_CHILD();\nexit(0);\n```\n\n假定在头文件`apue.h`中定义了需要使用的各个变量。\n\n5个例程`TELL_WAIT`、`TELL_PARENT`、`TELL_CHILD`、`WAIT_PARENT`以及`WAIT_CHILD`可以是宏，也可以是函数。\n\n实现这些TELL和WAIT例程的不同方法：使用信号的一种实现；使用管道的一种实现。\n\n以下程序，子进程、父进程分别输出两个字符串，因为输出依赖于内核使这两个进程运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞争条件。\n\n```c\n#include\"apue.h\"\nstatic void charatatime(char *);\nint main(void)\n{\n    pid_t pid;\n    if((pid = fork()) < 0)\n    {\n        err_sys(\"fork error\");\n    }\n    else if(pid == 0)\n    {\n        charatatime(\"output from child\\n\");\n    }\n    else\n    {\n        charatatime(\"output from parent\\n\");\n    }\n    exit(0);\n}\nstatic void charatatime(chat * str)\n{\n    char * ptr;\n    int c;\n    setbuf(stdout, NULL);\t//set unbuffered\n    for(ptr = str; (c = *ptr++) != 0; )\t//赋值语句的返回值是所赋的值，即*ptr\n    {\n        putc(c, stdout);\n    }\n}\n```\n\n在程序中将标准输出设置为不带缓冲的，于是每个字符输出都需调用一次`write`。本例的目的是使内核能尽可能多次地在两个进程之间进行切换，以便演示竞争条件。（如果不这样做，可能也就决不会见到下面所示的输出。没有看到具有错误的输出并不意味着竞争条件不存在，这只是意味着在此特定的系统上未能见到它。)下面的实际输出说明该程序的运行结果是会改变的。\n\n![image-20220515173120942](../../images/Linux_exit/image-20220515173120942.png)\n\n修改这个程序，使其使用`TELL`和`WAIT`函数，于是形成了以下程序。行首标以`+`号的行是新增加的行。\n\n```c\n    #include\"apue.h\"\n    static void charatatime(char *);\n    int main(void)\n    {\n        pid_t pid;\n+       TELL_WAIT();\n        if((pid = fork()) < 0)\n        {\n            err_sys(\"fork error\");\n        }\n        else if(pid == 0)\n        {\n+           WAIT_PARENT();\t//parent goes first\n            charatatime(\"output from child\\n\");\n        }\n        else\n        {\n            charatatime(\"output from parent\\n\");\n+           TELL_CHILD(pid);\n        }\n        exit(0);\n    }\n    static void charatatime(chat * str)\n    {\n        char * ptr;\n        int c;\n        setbuf(stdout, NULL);\t//set unbuffered\n        for(ptr = str; (c = *ptr++) != 0; )\t//赋值语句的返回值是所赋的值，即*ptr\n        {\n            putc(c, stdout);\n        }\n    }\n```\n\n运行此程序则能得到所预期的两个进程的输出不再交叉混合，且父进程先输出。\n\n如果将fork之后的行改成以下代码，则子进程先输出：\n```c\nelse if(pid == 0)\n{\n    charatatime(\"output from child\\n\");\n    TELL_PARENT(getppid());\n}\nelse\n{\n    WAIT_CHILD();\t//child goes first\n    charatatime(\"output from parent\\n\");\n}\n```\n\n\n\n","categories":["Linux"]},{"title":"Linux_gcc_gdb","url":"/Linux/Linux_gcc_gdb/","content":"# 内容\n\n1. gcc\n2. gdb\n# gcc的文件类型约定规则\n![](../../images/Linux_gcc_gdb/image-20250717221711701.png)\n# gcc常用选项\n![](../../images/Linux_gcc_gdb/image-20250717221742017.png)\n\n\n# gdb - 调试工具\n\n* 调试的对象：可执行程序\n* 编译时需要增加调试信息`-g`\n\n## 常用命令\n\n| 命令标识                | 含义           |\n| ------------------- | ------------ |\n| `l`                 | 显示代码         |\n| `Enter（回车键）`        | 重复上一条命令      |\n| `b 行号`              | 为某行添加断点      |\n| info break          | 查看断点信息(bnum)   |\n| delete bnum         | 删除断点对应的编号  |\n| `r`、`run`           | 启动程序         |\n| `n`、`next`          | 单步执行         |\n| `p 变量名`、`print 变量名` | 打印变量名内容      |\n| `q`                 | 退出调试         |\n| `s`、`step`          | 进入函数         |\n| `f`、`finish`        | 跳出函数         |\n| `continue`          | 继续程序（到下一个断点） |\n\n![](../../images/Linux_gcc_gdb/image-20250717223939391.png)\n\n","categories":["Linux"]},{"title":"makefile","url":"/项目/makefile/","content":"# 内容\n\n1. makefile的编写\n2. 命令\n# 示例\n\n示例所用到的代码内容：\n\n```c\n//main.c\n#include<stdio.h>\nint main()\n{\n    int a = 2;\n    int b = 3;\n    printf(\"a+b = %d\\n\",add(a,b));\n    printf(\"Max = %d\\n\",max(a,b));\n    return 0;\n}\n```\n\n```c\n//add.c\nint add(int x, int y)\n{\n    return x+y;\n}\n```\n\n```c\n//max.c\nint max(int x, int y)\n{\n    return x > y ? x : y;\n}\n```\n\n# makefile编写\n\n```bash\n# Makefile\nall : main\n\nmain : main.o add.o max.o\n\tgcc -o main main.o add.o max.o\n\t\nmain.o : main.c\n\tgcc -c main.c\n\nadd.o : add.c\n\tgcc -c add.c\n\t\nmax.o : max.c\n\tgcc -c max.c\n\t\nclean:\n\trm -f *.o main\n```\n\n# 命令\n\n```bash\nmake makefile\t#make命令--读取makefile文件\n```\n\n","categories":["项目","Linux"]},{"title":"外观模式","url":"/设计模式/外观模式/","content":"\n外观模式是一种使用频率非常高的**结构型设计模式**，它通过引入一个外观角色来简化客户端与子系统之间的交互，**为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度**，且客户端调用非常方便。\n\n# 引例\n\n不知道大家有没有比较过自己泡茶和去茶馆喝茶的区别，如果是自己泡茶需要自行准备茶叶、茶具和开水，如图所示。\n![image-20220509175118569](../../images/外观模式/image-20220509175118569.png)\n\n而去茶馆喝茶，最简单的方式就是跟茶馆服务员说想要一杯什么样的茶。正因为茶馆有服务员，顾客无须直接和茶叶、茶具、开水等交互，整个泡茶过程由服务员来完成，顾客只需与服务员交互即可，整个过程非常简单省事，如图所示。\n![image-20220509175152669](../../images/外观模式/image-20220509175152669.png)\n\n在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别**需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互**。\n\n外观模式通过引入一个**外观类(Facade)**来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。\n\n在外观模式中，那些**需要交互的业务类被称为子系统(Subsystem)**。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大。而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度，如图所示。\n![image-20220509175402273](../../images/外观模式/image-20220509175402273.png)\n\n# 外观模式\n\n外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。\n\n* 定义\n\n外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\nFacade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\n\n外观模式又称为门面模式，它是一种对象结构型模式。外观模式**是迪米特法则的一种具体实现**，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。\n\n# 外观模式结构与实现\n\n## 模式结构\n\n外观模式没有一个一般化的类图描述。下图可以简单地描述外观模式的结构：\n![image-20220509185718460](../../images/外观模式/image-20220509185718460.png)\n\n外观模式包含如下两个角色：\n\n* **Facade（外观角色）**\n  * 在客户端可以调用它的方法\n  * 在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；\n  * 在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。\n\n* **SubSystem（子系统角色）**\n  * 在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；\n  * 每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；\n  * 子系统并不知道外观的存在，**对于子系统而言，外观角色仅仅是另外一个客户端**而已。\n## 模式实现\n\n外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化。\n\n而外观模式的引入在很大程度上降低了类与类之间的耦合关系，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。\n\n### 子系统\n\n外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下：\n\n```cpp\nclass SubSystemA\n{\npublic:\n    void MethodA()\n    {\n        //业务实现代码\n    }\n};\nclass SubSystemB\n{\npublic:\n    void MethodB()\n    {\n        //业务实现代码\n    }\n};\nclass SubSystemC\n{\npublic:\n    void MethodC()\n    {\n        //业务实现代码\n    }\n};\n```\n\n### 外观类\n\n 在引入外观类之后，与子系统业务类之间的交互统一由外观类来完成，在外观类中通常存在如下代码：\n\n```cpp\nclass Facade\n{\nprivate:\n    SubSystemA * obja;\n\tSubSystemB * objb;\n\tSubSystemC * objc;\npublic:\n    Facade()\n    {\n        obja = new SubSystemA();\n        objb = new SubSystemB();\n        objc = new SubSystemC();\n    }\n    void Method()\n    {\n        obja->MethodA();\n        objb->MethodB();\n        objc->MethodC();\n    }\n};\n```\n\n### 客户端\n\n由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。引入外观类后，客户端代码变得非常简单，典型代码如下：\n\n```cpp\nint main()\n{\n\tFacade facade = new Facade();\n    facade->Method();\n}\n```\n\n# 外观模式应用实例\n\n下面通过一个应用实例来进一步学习和理解外观模式。\n\n某软件公司欲开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分：**读取源文件、加密、保存加密之后的文件**。其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这三个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这三个操作的业务代码封装在三个不同的类中。\n\n现使用外观模式设计该文件加密模块。\n\n## 实例类图\n\n通过分析，本实例结构图如下。\n\n![image-20220509200434876](../../images/外观模式/image-20220509200434876.png)\n\n图中，EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。\n\n## 示例代码\n\n### FileReader\n\n文件读取类，充当子系统类。\n\n```cpp\n#ifndef FILEREADER_H\n#define FILEREADER_H\n#include<iostream>\n#include<fstream>\n#include<sstream>\nusing namespace std;\nclass FileReader\n{\npublic:\n    string Read(const string & fileNameSrc)\n    {\n        cout << \"读取文件，获取明文。\" << endl;\n        fstream fs(fileNameSrc.c_str(), ios_base::in);\n        stringstream ss;\n        string s;\n        if(fs.is_open())\n        {\n            while(fs >> s)\n            {\n                ss << s;\n            }\n        }\n        else\n        {\n            cout << \"不能打开文件！\" << endl;\n        }\n        return ss.str();\n    }\n};\n#endif\n```\n\n### CipherMachine\n\n数据加密类，充当子系统类。\n\n```cpp\n#ifndef CIPHERMACHINE_H\n#define CIPHERMACHINE_H\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nclass CipherMachine\n{\npublic:\n    string Encrypt(const string & plainText)\n    {\n        cout << \"数据加密，将明文转换为密文！\" << endl;\n        string es = \"\";\n        vector<char> vc(plainText.begin(), plainText.end());\n        for(auto & c : vc)\n        {\n            es += (c % 36) + 65;\n        }\n        cout << es << endl;\n        return es;\n    }\n};\n#endif\n```\n\n### FileWriter\n\n文件保存类，充当子系统类。\n\n```cpp\n#ifndef FILEWRITER_H\n#define FILEWRITER_H\n#include<fstream>\n#include<iostream>\n#include<sstream>\nusing namespace std;\nclass FileWriter\n{\npublic:\n    void Write(const string & encryptStr, const string& fileNameDes)\n    {\n        cout << \"保存密码，写入文件。\" << endl;\n        fstream fs(fileNameDes, ios_base::out);\n        if(fs.is_open())\n        {\n            fs.write(encryptStr.c_str(), encryptStr.size());\n        }\n        else\n        {\n            cout << \"文件写入失败！\" << endl;\n        }\n    }\n};\n#endif\n```\n\n### EncryptFacade\n\n加密外观类，充当外观类。\n\n```cpp\n#ifndef ENCRYPTFACADE_H\n#define ENCRYPTFACADE_H\n#include\"ciphermachine.h\"\n#include\"filereader.h\"\n#include\"filewriter.h\"\n#include<memory>\nclass EncryptFacade\n{\nprivate:\n    shared_ptr<FileReader> reader;\n    shared_ptr<FileWriter> writer;\n    shared_ptr<CipherMachine> cipher;\npublic:\n    EncryptFacade()\n    {\n        reader = make_shared<FileReader>();\n        cipher = make_shared<CipherMachine>();\n        writer = make_shared<FileWriter>();\n    }\n    void FileEncrypt(const string & fileNameSrc, const string & fileNameDes)\n    {\n        string plainStr = reader->Read(fileNameSrc);\n        string encryptStr = cipher->Encrypt(plainStr);\n        writer->Write(encryptStr, fileNameDes);\n    }\n};\n#endif\n```\n\n## 客户端代码\n\n```cpp\n#include\"encryptfacade.h\"\nint main()\n{\n    unique_ptr<EncryptFacade> ef = make_unique<EncryptFacade>();\n    ef->FileEncrypt(\"./file.txt\", \"./code.txt\");\n}\n```\n\n## 运行结果\n\n```\n读取文件，获取明文。(19060212119ChenggongXing)\n数据加密，将明文转换为密文！\nNVMSMNONNV`a^C``DC`QbC`\n保存密码，写入文件。\n```\n\n发现，目录下多了一个code.txt，里面存放的是密文。\n\n# 抽象外观类\n\n在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类来对系统进行改进，在一定程度上可以解决该问题。\n\n在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，**对于新的业务需求，不需要修改原有外观类**，而是**增加一个新的具体外观类**，由新的具体外观类来关联新的子系统对象，同时**通过修改配置文件来达到不修改任何源代码并更换外观类**的目的。\n\n## 实例分析\n\n下面通过一个具体实例来学习如何使用抽象外观类：如果在应用实例“文件加密模块”中需要更换一个加密类，不再使用原有的基于求模运算的加密类CipherMachine，而改为新加密类NewCipherMachine，其代码如下：\n\n```cpp\n#ifndef NEWCIPHERMACHINE_H\n#define NEWCIPHERMACHINE_H\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nclass NewCipherMachine\n{\npublic:\n    string Encrypt(const string & plainText)\n    {\n        cout << \"数据加密，将明文转换为密文！\" << endl;\n        string es = \"\";\n        vector<char> vc(plainText.begin(), plainText.end());\n        for(auto & c : vc)\n        {\n            es += (c % 36) + 60;\t//由原来的+65变为+60\n        }\n        cout << es << endl;\n        return es;\n    }\n};\n#endif\n```\n\n如果不增加新的外观类，只能通过修改原有外观类EncryptFacade的源代码来实现加密类的更换，将原有的对CipherMachine类型对象的引用改为对NewCipherMachine类型对象的引用，这违背了开闭原则，因此需要通过增加新的外观类来实现对子系统对象引用的改变。\n\n## 解决方案\n\n如果增加一个新的外观类NewEncryptFacade来与FileReader类、FileWriter类以及新增加的NewCipherMachine类进行交互，虽然原有系统类库无须做任何修改，但是因为客户端代码中原来针对EncryptFacade类进行编程，现在需要改为NewEncryptFacade类，因此需要修改客户端源代码。\n\n如何在不修改客户端代码的前提下使用新的外观类呢？\n\n解决方法之一是：引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类，引入抽象外观类之后的文件加密模块结构图如图所示：\n\n![image-20220510085052559](../../images/外观模式/image-20220510085052559.png)\n\n## 代码实现\n\n* 抽象外观类AbstractEncryptFacade\n\n```cpp\n#ifndef ABSTRACTENCRYPTFACADE_H\n#define ABSTRACTENCRYPTFACADE_H\nclass AbstractEncryptFacade\n{\npublic:\n    virtual void FileEncrypt(const string & fileNameSrc, const string & fileNameDes) = 0;\n};\n#endif\n```\n\n* 新增具体加密外观类NewEncryptFacade代码如下：\n\n```cpp\n#ifndef NEWENCRYPTFACADE_H\n#define NEWENCRYPTFACADE_H\n#include\"abstractencryptfacade.h\"\n#include\"newciphermachine.h\"\n#include\"filereader.h\"\n#include\"filewriter.h\"\n#include<memory>\nclass NewEncryptFacade : public AbstractEncryptFacade\n{\nprivate:\n    shared_ptr<FileReader> reader;\n    shared_ptr<FileWriter> writer;\n    shared_ptr<NewCipherMachine> cipher;\t//new\npublic:\n    NewEncryptFacade()\n    {\n        reader = make_shared<FileReader>();\n        cipher = make_shared<NewCipherMachine>();\n        writer = make_shared<FileWriter>();\n    }\n    /* 实现抽象函数 */\n    void FileEncrypt(const string & fileNameSrc, const string & fileNameDes)\n    {\n        string plainStr = reader->Read(fileNameSrc);\n        string encryptStr = cipher->Encrypt(plainStr);\n        writer->Write(encryptStr, fileNameDes);\n    }\n};\n#endif\n```\n\n## 引入配置文件\n\n我们的配置文件使用json来处理，引入一个适用于cpp的json第三方库，使用json.hpp。\n\n```json\n{\n    \"cipher\": \"new\"\n}\n```\n\n还需要写对应配套的map映射生成具体使用的对象。\n\n```cpp\n#ifndef PUBLIC_H\n#define PUBLIC_H\n#include<unordered_map>\n#include<string>\n#include\"abstractencryptfacade.h\"\n#include\"encryptfacade.h\"\n#include\"newencryptfacade.h\"\n#include\"functional\"\nusing namespace std;\nunordered_map<string, function<unique_ptr<AbstractEncryptFacade>()>> s_facade_map = \n{\n    { \"old\", []()->unique_ptr<AbstractEncryptFacade> {return make_unique<EncryptFacade>();}},\n    { \"new\", []()->unique_ptr<AbstractEncryptFacade> {return make_unique<NewEncryptFacade>();}}\n};\n#endif\n```\n\n## 客户端改写\n\n```cpp\n#include\"encryptfacade.h\"\n#include\"json.hpp\"\n#include\"public.h\"\n#include<fstream>\nusing json = nlohmann::json;\nint main()\n{\n    json j;\n    ifstream jfile(\"../config.json\");\n    jfile >> j;\n    jfile.close();\n    \n    unique_ptr<AbstractEncryptFacade> ef = s_facade_map[j.at(\"cipher\")]();\n    ef->FileEncrypt(\"../file.txt\", \"../code.txt\");\n}\n```\n\n```\n读取文件，获取明文。\n数据加密，将明文转换为密文！\nIQHNHIJIIQ[\\Y>[[?>[L]>[\n保存密码，写入文件。\n```\n\n原有外观类EncryptFacade也需作为抽象外观类AbstractEncryptFacade类的子类，更换具体外观类时只需修改配置文件，无须修改源代码，符合开闭原则。\n\n# 总结\n\n外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。\n\n在几乎所有的软件中都能够找到外观模式的应用，如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度。所有涉及到与多个业务对象交互的场景都可以考虑使用外观模式进行重构。\n\n## 优点\n\n1. 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。\n2. 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。\n3. 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。\n\n## 缺点\n\n1. 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。\n2. 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。\n\n## 适用场景\n\n在以下情况下可以考虑使用外观模式：\n\n1. 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。\n2. 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。\n3. 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。\n","categories":["设计模式","结构型模式"]},{"title":"Linux_库","url":"/Linux/Linux_库/","content":"# 内容\n\n1. 库文件\n2. 静态库\n3. 共享库（动态链接库）\n\n# 一段代码\n\n```c\n#include<stdio.h>\nint main()\n{\n    printf(\"hello, world!\");\n    return 0;\n}\n```\n\n众所周知，引入的`.h`文件只是引入了一堆函数的声明，在这个源代码和`.h`文件中并没有实现这些函数。那么`printf`谁帮我们实现的呢？\n\n答案就是，c程序自动链接了`libc.so`库文件。\n\n# 举例\n\nC语言编程中经常使用的`printf()`，显然不是我们自己实现的，它是在c标准库中实现的。c标准库即`libc.so`（后面带`.6`表示版本号，如`libc.so.6`），此库文件在系统中充当共享库。\n\n库中存放的是什么？——预先编译好的方法，把这些方法打包为一个集合，就是库文件。\n\n比如，`add.c`、`max.c`分别编译为`add.o`、`max.o`，把编译好的二进制文件打包到`libfoo.a`或`libfoo.so`。以后我们要是想使用`add.o`或`max.o`中的方法时，链接`libfoo`库即可成功调用。为了方便他人使用，往往会给调用方再提供一个头文件`foo.h`，以声明此库中包含哪些接口。\n\n# 库文件\n\n预先编译好的方法（函数）的集合。\n\n库文件通常存放到`/lib`、`/usr/lib`下。\n\n头文件通常存放到`/usr/include`下。\n\n## 库文件使编译链接方便了\n\n* 我们编写第一个版本的代码，只有一个文件`main.c`\n\n```c\n#include<stdio.h>\nint add(int a, int b);\nint main()\n{\n    int a = 10;\n    int b = 20;\n    int c = add(a, b);\n    printf(\"a + b = %d\\n\", c);\n    return 0;\n}\nint add(int a, int b)\n{\n    return a + b;\n}\n```\n\n此版本我们把`add`函数的声明、实现全部写到了此文件中。\n\n测试编译链接——单文件的编译链接很方便。\n\n```bash\ngcc -o main main.c\n```\n\n按上面语句编译即可成功。\n\n* 我们编写第二个版本的代码，把add函数抽出来写到第二个文件中。\n\n```c\nint add(int a, int b)\n{\n    return a + b;\n}\n```\n\n改写main.c，对于add函数只在此文件中声明\n\n```c\n#include<stdio.h>\nint add(int a, int b);\nint main()\n{\n    int a = 10;\n    int b = 20;\n    int c = add(a, b);\n    printf(\"a + b = %d\\n\", c);\n    return 0;\n}\n```\n\n此时如果再像第一次那样编译就行不通了`gcc -o main main.c`，报错：\n\n![image-20220507200930308](../../images/Linux_库/image-20220507200930308.png)\n\n这时，就得这样编译链接才能通过：\n\n```bash\ngcc -o main main.c add.c\n```\n\n后面得加个`add.c`才行。\n\n**这时，就很有可能出现了一个现象：好多人可能都需要调用`add.c`里面的函数**。\n\n此时出现了诸多问题：\n\n1. 如果直接给你add.c，这个源码就要暴露给所有人了，不利于隐藏代码实现细节。\n2. 实际上，`gcc -o main main.c add.c`不是一步到位生成main的，而是隐藏了好多过程，如果大家都要用add.c那么大家在每一次生成main之前，都需要另外先编译好add.c，才能与main.o链接生成main。这样重复的工作我们是要想办法避免的，即直接给你编译好的`.o`文件。\n\n针对以上问题，我们`gcc -c add.c`编译add.c文件为.o文件。直接给用户编译好的`.o`文件，即可解决此问题。\n\n此时，我们要想通过`main.c`和`add.o`生成`main`可执行文件时，可以如此：\n\n```bash\ngcc -o main main.c add.o\n```\n\n生成`.o`文件解决了两个问题，接下来的问题：**以后我们可能不止有`add.o`，还可能有很多其他的`.o`文件，比如`max.o`。能不能打包为一个文件呢？这样就很方便了。——这就是库文件**。\n\n# 静态库\n\n`libxx.a`。\n\n编译链接时，把被链接的库程序的一部分包含到要生成的可执行文件中。\n\n## 如何生产静态库？ar命令\n\n我们把`add.c`和`max.c`做成一个静态库。\n\nadd.c文件内容略。\n\nmax.c文件：\n\n```c\nint max(int a, int b)\n{\n    return a > b ? a : b;\n}\n```\n\n把两个.c文件分别`gcc -c add.c max.c`生成了两个.o文件。\n\n然后，使用ar命令将指出的.o文件生成静态库。\n\n> 为什么是ar呢？因为静态库的英文是archive。\n\nar命令格式：`ar [选项] 库名 若干.o文件`\n\n| ar命令的选项参数 | 意义       |\n| --------- | -------- |\n| c         | 创建库      |\n| r         | 将方法添加到库中 |\n| v         | 显示过程     |\n\n则用以下命令即可把add.o、max.o打包为一个静态库文件`libfoo.a`\n\n```bash\nar crv libfoo.a add.o max.o\n```\n\n执行结果：![image-20220507204616204](../../images/Linux_库/image-20220507204616204.png)\n\n## 链接静态库\n\n我们当前目录下只有`libfoo.a`、`main.c`。\n\n首先，`gcc -o main main.c`肯定是不能编译通过的。\n\n其次，`gcc -o main main.c libfoo.a`是可以编译通过的。但是这不是一个好的办法，这样做的话每次链接需要把库文件拷贝到当前目录，而且还需要打出库的全名。\n\n* 标准的做法：`-L`指明库所在的目录，`-l`指明你要链接的库名。\n  * 在我们的例子中，库所在的目录是`.`；库名为`foo`，即`\"lib\"`的后半部分，不带`.a`。\n\n```bash\ngcc -o main main.c -L. -lfoo\n```\n\n## 库文件及其头文件标准目录\n\n我们为了给调用者声明它可以通过某库文件调用哪些函数，需要另外编写一个`foo.h`头文件。\n\n**注意，在编写`.c`文件时，需要`#include<foo.h>`**，如此就不用一个个自己声明函数了。\n\nfoo.h文件\n\n```c\nint add(int a, int b);\nint max(int a, int b);\n```\n\n改写main.c文件\n\n```c\n#include<stdio.h>\n#include<foo.h>\nint main()\n{\n    int a = 10;\n    int b = 20;\n    int c = add(a, b);\t// add函数已经声明于foo.h\n    printf(\"a + b = %d\\n\", c);\n    return 0;\n}\n```\n\n* 标准目录\n\n标准的位置，同时是`gcc`程序链接时默认扫描的位置是`/usr/include`。\n\n相应的库文件的默认扫描位置，`/lib`、`/usr/lib`。\n\n我们把我们自己编写的`foo.h`和`libfoo.a`移到标准目录。\n\n```bash\nsu root\nmv foo.h /usr/include\nmv libfoo.a /usr/lib\n```\n\n现在的编译链接过程，由于头文件、库文件都在标准目录底下，可以不加`-L`参数，但是仍然必须在后面指定`-l库名`，即`-lfoo`，便可编译链接成功。\n\n**注意：除了链接`libc.so`c标准库，`-l`通常不可省略，这就相当于c标准库是系统亲生的，用得很多，就默认可以省略。**\n\n```bash\ngcc -o main main.c -lfoo\n```\n\n\n\n# 动态库\n\n`libxx.so`。\n\n编译链接时，不会把被链接的库程序的一部分包含到要生成的可执行文件中。只做一个标记，只验证链接的库有没有问题。生成的可执行文件在运行时动态地加载动态库去运行，所以动态库一旦删除则无法运行。\n\n再回到那个众人皆知的代码。\n\n```c\n#include<stdio.h>\nint main()\n{\n    printf(\"hello, world!\");\n    return 0;\n}\n```\n\n我们编译它。\n\n```bash\ngcc -o main main.c\n```\n\n怎么证明`main`程序链接了`libc.so`库文件呢？\n\n## ldd命令\n\n`ldd`命令可以查看编译好的二进制程序需要链接的库文件信息。\n\n```bash\nldd main\n```\n\n我们的main程序使用到了`printf`的库，即`libc.so`，bash下输入`ldd main`的结果是：\n\n![image-20220507194717251](../../images/Linux_库/image-20220507194717251.png)\n\n## 如何生产动态库？\n\n我们把`add.o`和`max.o`做成一个动态库。\n\n生成动态库，使用的是gcc命令。\n\n```bash\ngcc -shared -fPIC -o libfoo.so add.o max.o\n```\n\n其中，`-shared`参数表示产生共享对象，`-fPIC`：\n\n## 链接动态库\n\n暂且如下编译链接main.c程序\n\n```bash\ngcc -o main main.c ./libfoo.so\n```\n\n这样得到了一个程序`main`，此程序使用了`libfoo.so`里面的`add`函数。从`main.c`的角度看，自己被链接成为可执行文件的这一步，在之前的静态链接中会把`main.o`和`libfoo.so`结合到一起。但是在动态链接里，`libfoo.so`没有被链接进来，链接的输入目标文件只有`main.o`（当然还有C语言运行库，我们这里暂时忽略）。但是上面gcc的命令行中，后面也加上了`./libfoo.so`这是咋回事？\n\n> **关于模块**\n>\n> 在静态链接时，整个程序最终只有一个可执行文件，它是一个不可分割的整体；\n>\n> 但在动态链接下，一个程序被分成了若干个文件，有程序的主要部分，即可执行文件`main`和程序所依赖的共享对象`libfoo.so`。很多时候我们把这些部分称为模块，即动态链接下的可执行文件和共享对象都可看作是程序的模块。\n\n## 动态链接的原理细节\n\n谈谈动态链接的机制，当程序模块`main.c`被编译成为`main.o`时，编译器还不知道`add`函数的地址。当链接器将`main.o`链接成可执行文件时，这时候**链接器必须确定`main.o`中所引用的`add`函数的性质**：\n\n1. 如果`add`是一个定义于其他静态目标模块中的函数，那么链接器将会按照静态链接的规则，将`main.o`中的`add`地址引用**重定位**；\n2. 如果`add`是一个定义在某个动态共享对象中的函数，**那么链接器就会将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行**。\n\n那么这里就有个问题，链接器如何知道`add`的引用是一个静态符号还是一个动态符号？这实际上就是我们的gcc命令后面要写`libfoo.so`的原因。`libfoo.so`中保存了完整的符号信息（因为运行时进行动态链接还须使用符号信息)，把`libfoo.so`也作为链接的输入文件之一，链接器在解析符号时就可以知道：`add`是一个定义在`libfoo.so`的动态符号。这样链接器就可以对`add`的引用做特殊的处理，使它成为一个对动态符号的引用。\n\n## 动态链接程序运行时地址空间分布\n\n对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，那就是可执行文件本身，静态链接下的进程虚拟地址空间的分布很清晰明了。但是对于动态链接来说，除了可执行文件本身之外，还有它所依赖的共享目标文件。那么这种情况下，进程的地址空间分布又会怎样呢？\n\n我们还是以上面的程序为例，我们对程序做适当的修改，在`main.c`中里面调用`sleep`函数。\n\n```bash\nxcg@instance-bkdrtyrm:~/ld-learn$ ./main &\n[1] 764261\nxcg@instance-bkdrtyrm:~/ld-learn$ 10 + 20 = 30\ncat /proc/764261/maps \n55f2437e2000-55f2437e3000 r--p 00000000 fc:01 1201223            /home/xcg/ld-learn/main\n55f2437e3000-55f2437e4000 r-xp 00001000 fc:01 1201223            /home/xcg/ld-learn/main\n55f2437e4000-55f2437e5000 r--p 00002000 fc:01 1201223            /home/xcg/ld-learn/main\n55f2437e5000-55f2437e6000 r--p 00002000 fc:01 1201223            /home/xcg/ld-learn/main\n55f2437e6000-55f2437e7000 rw-p 00003000 fc:01 1201223            /home/xcg/ld-learn/main\n55f244377000-55f244398000 rw-p 00000000 00:00 0                  [heap]\n7f814f30e000-7f814f311000 rw-p 00000000 00:00 0 \n7f814f311000-7f814f333000 r--p 00000000 fc:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7f814f333000-7f814f4ab000 r-xp 00022000 fc:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7f814f4ab000-7f814f4f9000 r--p 0019a000 fc:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7f814f4f9000-7f814f4fd000 r--p 001e7000 fc:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7f814f4fd000-7f814f4ff000 rw-p 001eb000 fc:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so\n7f814f4ff000-7f814f503000 rw-p 00000000 00:00 0 \n7f814f50b000-7f814f50c000 r--p 00000000 fc:01 1201222            /home/xcg/ld-learn/libfoo.so\n7f814f50c000-7f814f50d000 r-xp 00001000 fc:01 1201222            /home/xcg/ld-learn/libfoo.so\n7f814f50d000-7f814f50e000 r--p 00002000 fc:01 1201222            /home/xcg/ld-learn/libfoo.so\n7f814f50e000-7f814f50f000 r--p 00002000 fc:01 1201222            /home/xcg/ld-learn/libfoo.so\n7f814f50f000-7f814f510000 rw-p 00003000 fc:01 1201222            /home/xcg/ld-learn/libfoo.so\n7f814f510000-7f814f512000 rw-p 00000000 00:00 0 \n7f814f512000-7f814f513000 r--p 00000000 fc:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7f814f513000-7f814f536000 r-xp 00001000 fc:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7f814f536000-7f814f53e000 r--p 00024000 fc:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7f814f53f000-7f814f540000 r--p 0002c000 fc:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7f814f540000-7f814f541000 rw-p 0002d000 fc:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so\n7f814f541000-7f814f542000 rw-p 00000000 00:00 0 \n7ffc5ff25000-7ffc5ff46000 rw-p 00000000 00:00 0                  [stack]\n7ffc5fff5000-7ffc5fff8000 r--p 00000000 00:00 0                  [vvar]\n7ffc5fff8000-7ffc5fff9000 r-xp 00000000 00:00 0                  [vdso]\nffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0          [vsyscall]\n```\n\n我们看到，整个进程虚拟地址空间中，多出了几个文件的映射：\n\n1. `libfoo.so`与`main`一样，它们都是被操作系统用同样的方法映射至进程的虚拟地址空间，只是**它们占据的虚拟地址和长度不同**。\n2. `main`除了使用`libfoo.so`以外，它还用到了动态链接形式的C语言运行库`libc-2.31.so`。\n\n3. 另外还有一个很值得关注的共享对象就是`ld-2.31.so`，它实际上是Linux下的动态链接器。动态链接器与普通共享对象一样被映射到了进程的地址空间。\n\n在系统开始运行`main`之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给`main`，然后开始执行。\n\n我们通过readelf工具来查看`libfoo.so`的装载属性，就如我们在前面查看普通程序一样：\n\n```bash\nreadelf -l libfoo.so\n```\n\n```bash\nxcg@instance-bkdrtyrm:~/ld-learn$ readelf -l libfoo.so \n\nElf file type is DYN (Shared object file)\nEntry point 0x1040\nThere are 11 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x00000000000004c8 0x00000000000004c8  R      0x1000\n  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000\n                 0x0000000000000139 0x0000000000000139  R E    0x1000\n  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000\n                 0x00000000000000cc 0x00000000000000cc  R      0x1000\n  LOAD           0x0000000000002e80 0x0000000000003e80 0x0000000000003e80\n                 0x00000000000001a0 0x00000000000001a8  RW     0x1000\n  DYNAMIC        0x0000000000002e90 0x0000000000003e90 0x0000000000003e90\n                 0x0000000000000150 0x0000000000000150  RW     0x8\n  NOTE           0x00000000000002a8 0x00000000000002a8 0x00000000000002a8\n                 0x0000000000000020 0x0000000000000020  R      0x8\n  NOTE           0x00000000000002c8 0x00000000000002c8 0x00000000000002c8\n                 0x0000000000000024 0x0000000000000024  R      0x4\n  GNU_PROPERTY   0x00000000000002a8 0x00000000000002a8 0x00000000000002a8\n                 0x0000000000000020 0x0000000000000020  R      0x8\n  GNU_EH_FRAME   0x0000000000002000 0x0000000000002000 0x0000000000002000\n                 0x000000000000002c 0x000000000000002c  R      0x4\n  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000000000 0x0000000000000000  RW     0x10\n  GNU_RELRO      0x0000000000002e80 0x0000000000003e80 0x0000000000003e80\n                 0x0000000000000180 0x0000000000000180  R      0x1\n\n Section to Segment mapping:\n  Segment Sections...\n   00     .note.gnu.property .note.gnu.build-id .gnu.hash .dynsym .dynstr .rela.dyn \n   01     .init .plt .plt.got .text .fini \n   02     .eh_frame_hdr .eh_frame \n   03     .init_array .fini_array .dynamic .got .got.plt .data .bss \n   04     .dynamic \n   05     .note.gnu.property \n   06     .note.gnu.build-id \n   07     .note.gnu.property \n   08     .eh_frame_hdr \n   09     \n   10     .init_array .fini_array .dynamic .got\n```\n\n动态库文件除了文件的类型与普通程序不同以外，其他几乎与普通程序一样。有一点比较不同的是，**动态链接模块的装载地址是从地址`0x00000000`开始的**。我们知道这个地址是无效地址，并且从**上面的进程虚拟空间分布看到，`libfoo.so`的最终装载地址并不是`0x00000000`，而是其他具体值**。从这一点我们可以推断，**共享对象的最终装载地址在编译时是不确定的**，而**是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象**。\n\n当然，这仅仅是一个推断，至于为什么要这样做，为什么不将每个共享对象在进程中的地址固定，或者在真正的系统中是怎么运作的？\n\n## 装载地址\n\n我们设想是否可以让共享对象在任意地址加载？这个问题另一种表述方法就是：共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。与此不同的是，可执行文件基本可以确定自己在进程虚拟空间中的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，比如Linux下一般都是0x08040000，Windows下一般都是0x0040000。\n\n### 装载时重定位\n\n为了能够使共享对象在任意地址装载，我们首先能想到的方法就是静态链接中的重定位。这个想法的基本思路是在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。假设函数`add`相对于代码段的起始地址是0x100，当模块被装载到0x10000000时，我们假设代码段位于模块的最开始，即代码段的装载地址也是0x10000000，那么我们就可以确定`add`的地址为0x10000100。这时候，系统遍历模块中的重定位表，把所有对`add`的地址引用都重定位至0x10000100。\n\n事实上，类似的方法在很早以前就存在。早在没有虚拟存储概念的情况下，程序是直接被装载进物理内存的。当同时有多个程序运行的时候，操作系统根据当时内存空闲情况，动态分配一块大小合适的物理内存给程序，所以程序被装载的地址是不确定的。系统在装载程序的时候需要对程序的指令和数据中对绝对地址的引用进行重定位。但这种重定位比前面提到过的静态链接中的重定位要简单得多，因为整个程序是按照一个整体被加载的，程序中指令和数据的相对位置是不会改变的。比如一个程序在编译时假设被装载的目标地址为0x1000，但是在装载时操作系统发现0x1000这个地址已经被别的程序使用了，从0x4000开始有一块足够大的空间可以容纳该程序，那么该程序就可以被装载至0x4000，程序指令或数据中的所有绝对引用只要都加上0x3000的偏移量就可以了。\n\n我们前面在静态链接时提到过重定位，那时的重定位叫做**链接时重定位**(Link Time Relocation)，而现在这种情况经常被称为**装载时重定位**(Load Time Relocation)。在Windows中，这种装载时重定位又被叫做**基址重置**(Rebasing)。\n\n这种情况与我们碰到的问题很相似，**都是程序模块在编译时目标地址不确定而需要在装载时将模块重定位**。但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的问题。可以想象，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，**由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来讲是不同的**。当然，动态连接库中的可修改数据部分对于不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。\n\nLiux和GCC支持这种装载时重定位的方法，我们前面在产生共享对象时，使用了两个GCC参数`-shared`和`-fPIC`，如果只使用`-shared`，那么输出的共享对象就是使用装载时重定位的方法。\n\n### 地址无关代码\n\n那么什么是`-fPIC`呢？使用这个参数会有什么效果呢？\n\n装载时重定位是**解决动态模块中有绝对地址引用**的办法之一，但是它有一个很大的**缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势**。我们还需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题。其实我们的目的很简单，**希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变**，所以实现的基本想法就是**把指令中那些需要被修改的部分分离出来**，**跟数据部分放在一起**，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为**地址无关代码(PIC, Position-independent Code)的技术**。\n\n对于现代的机器来说，产生地址无关的代码并不麻烦。我们先来分析模块中各种类型的地址引用方式。\n\n#### 模块中各种类型的地址引用方式\n\n1. **把共享对象模块中的地址引用按照是否为跨模块分成两类**：模块内部引用和模块外部引用；\n2. **按照不同的引用方式**又可以分为指令引用（函数）和数据访问。\n\n则得到了4种情况。\n\n1. 模块内部的函数调用、跳转等。\n2. 模块内部的数据访问，比如模块中定义的全局变量、静态变量。\n3. 是模块外部的函数调用、跳转等。\n4. 是模块外部的数据访问，比如其他模块中定义的全局变量。\n\n```c\nstatic int a;\nextern int b;\nextern void ext();\nvoid bar()\n{\n    a = 1;\t//case 2, inner-module data\n    b = 2;\t//case 4, inter-module data\n}\nvoid foo()\n{\n    bar();\t//case 1, inner-module function\n    ext();\t//case 3, inter-module function\n}\n```\n\n> **关于模块内部和模块外部**\n>\n> 当编译器在编译时，它实际上并不能确定变量b和函数ext()是模块外部的还是模块内部的，因为它们有可能被定义在同一个共享对象的其他目标文件中。由于没法确定，编译器只能把它们都当作模块外部的函数和变量来处理。MSVC编译器提供了`__declspec(dllimport)`编译器扩展来表示一个符号是模块内部的还是模块外部的。\n\n* 模块内部调用或跳转\n\n这4种情况中，第一种类型应该是最简单的，那就是模块内部调用。因为被调用的函数与调用者都处于同一个模块，它们之间的相对位置是固定的，所以这种情况比较简单。对于现代的系统来讲，模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。比如上面例子中foo对bar的调用可能产生如下代码：\n\n![image-20220509112233608](../../images/Linux_库/image-20220509112233608.png)\n\nfoo中对bar的调用的那条指令实际上是一条相对地址调用指令，相对偏移调用指令如图。\n![image-20220509151553766](../../images/Linux_库/image-20220509151553766.png)\n\n这条指令中的后4个字节是目的地址相对于当前指令的下一条指令的偏移，即`0xFFFFFFE8`（小端）。`0xFFFFFFE8`是`-24`的补码形式，即`bar`的地址为`0x804835c+(-24)=0x8048344`。那么只要bar和foo的相对位置不变，这条指令是地址无关的。即无论模块被装载到哪个位置，这条指令都是有效的。这种相对地址的方式对于jmp指令也有效。\n\n这样看起来第一个模块内部调用或跳转很容易解决，但实际上这种方式还有一定的问题，这里存在一个叫做**共享对象全局符号介入(Global Symbol Interposition)问题**，但在这里，可以简单地把它当作相对地址调用/跳转。\n\n* 模块内部数据访问\n\n接着来看看第二种类型，模块内部的数据访问。很明显，指令中不能直接包含数据的绝对地址，那么唯一的办法就是**相对寻址**。我们知道，一个模块前面一般是若干个页的代码，后面紧跟着若千个页的数据，这些页之间的相对位置是固定的，也就是说，**任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的**，那么**只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据**了。\n\n现代的体系结构中，数据的相对寻址往往没有相对与当前指令地址（PC）的寻址方式，所以ELF用了一个很巧妙的办法来得到当前的PC值，然后再加上一个偏移量就可以达到访问相应变量的目的了。得到PC值的方法很多，我们来看看最常用的一种，也是现在ELF的共享对象里面用的一种方法：\n\n![image-20220509141654740](../../images/Linux_库/image-20220509141654740.png)\n\n这是对上面的例子中的代码先编译成共享对象然后反汇编的结果。用粗体表示的是`bar()`函数中访问模块内部变量`a`的相应代码。\n\n从上面的指令中可以看到，它先调用了一个叫`__i686.get_pc_thunk.cx`的函数，这个函数的作用就是把返回地址的值放到ecx寄存器，即把call的下一条指令的地址放到ecx寄存器。\n\n>我们知道当处理器执行call指令以后，下一条指令的地址会被压到栈顶，而esp寄存器就是始终指向栈顶的，那么当`__i686.get_pc_thunk.cx`执行`mov(%esp), %ecx`的时候，返回地址就被赋值到ecx寄存器了。\n\n接着执行一条add指令和一条mov指令，可以看到变量`a`的地址是add指令地址（保存在ecx寄存器）加上两个偏移量`0x118c`和`0x28`（`0x28(%ecx)`相当于`%ecx+0x28`），即如果模块被装载到`0x10000000`这个地址的话，那么变量a的实际地址将是`0x10000000+0x454+0x118c+0x28=0x10001608`。\n\n![image-20220509151732270](../../images/Linux_库/image-20220509151732270.png)\n\n* 模块间数据访问\n\n模块间的数据访问比模块内部稍微麻烦一点，因为模块间的数据访问目标地址要等到装载时才决定，比如上面例子中的变量b，它被定义在其他模块中，并且该地址在装载时才能确定。我们前面提到要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面，很明显，这些其他模块的全局变量的地址是跟模块装载地址有关的。**ELF的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表**(GlobalOffset Table, GOT)，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用，它的基本机制如图所示。\n![image-20220509153306467](../../images/Linux_库/image-20220509153306467.png)\n\n当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。\n\n我们来看看GOT如何做到指令的地址无关性。从第二种类型的数据访问我们了解到，模块在编译时可以确定模块内部变量相对与当前指令的偏移，那么我们也可以**在编译时确定GOT相对于当前指令的偏移**。确定GOT的位置跟上面的访问变量a的方法基本一样，通过得到PC值然后加上一个偏移量，就可以得到GOT的位置。然后我们根据变量地址在GOT中的偏移就可以得到变量的地址，当然GOT中每个地址对应于哪个变量是由编译器决定的，比如第一个地址对应变量b，第二个对应变量c等。\n\n让我们再回顾刚才函数`bar()`的反汇编代码。为访问变量b，我们的程序首先计算出变量b的地址在GOT中的位置，即`0x10000000+0x454+0x118c+(-8)=0x100015d8`（`0xfffffff8`为`-8`的补码表示），然后使用寄存器间接寻址方式给变量b赋值2。\n\n![image-20220509141654740](../../images/Linux_库/image-20220509141654740.png)\n\n我们也可以使用objdump来查看GOT的位置：\n\n![image-20220509154001142](../../images/Linux_库/image-20220509154001142.png)\n\n可以看到GOT在文件中的偏移是`0x15d0`，我们再来看看`pic.so`的需要在动态链接时重定位项：\n\n![image-20220509154033873](../../images/Linux_库/image-20220509154033873.png)\n\n可以看到变量b的地址需要重定位，它位于`0x15d8`，也就是GOT中偏移8，相当于是GOT中的第三项(每四个字节一项) 。从上面重定位项中看到，变量b的地址的偏移为`0x15d8`，正好对应了我们前面通过指令计算出来的偏移值，即`0x100015d8-0x10000000=0x15d8`。\n\n* 模块间调用、跳转\n\n对于模块间调用和跳转，我们也可以采用上面的方法来解决。与上面的类型有所不同的是，GOT中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转，基本的原理如图所示。\n![image-20220509154400584](../../images/Linux_库/image-20220509154400584.png)\n\n调用`ext()`函数的方法与上面访问变量b的方法基本类似，先得到当前指令地址PC，然后加上一个偏移得到函数地址在GOT中的偏移，然后一个间接调用。\n\n![image-20220509154449640](../../images/Linux_库/image-20220509154449640.png)\n\n* 小结\n\n4种地址引用方式在理论上都实现了地址无关性，将它们总结一下，如表。\n\n![image-20220509154617511](../../images/Linux_库/image-20220509154617511.png)\n\n## -fPIC\n\n生成动态库用到的参数`fPIC`即是指明GCC产生地址无关代码。实际上GCC还提供了另外一个类似的参数叫做`-fpic`，即`PIC`3个字母小写。这两个参数从功能上来讲完全一样，都是指示GCC产生地址无关代码。唯一的区别是，`-fPIC`产生的代码要大，而`-fpic`产生的代码相对较小，而且较快。\n\n那么我们为什么不使用`-fpic`而要使用`-fPIC`呢？原因是，由于地址无关代码都是跟硬件平台相关的，不同的平台有着不同的实现， `-fpic`在某些平台上会有一些限制，比如全局符号的数量或者代码的长度等，而`-fPIC`则没有这样的限制。所以为了方便起见，绝大部分情况下我们都使用`-fPIC`参数来产生地址无关代码。\n\n* 如何区分一个DSO(Dynamic Shared Object, 动态共享对象)是否为PIC？\n\n```bash\nreadelf -d foo.so | grep TEXTREL\n```\n\n如果上面的命令有任何输出那么`foo.so`就不是PIC的，否则为PIC的。因为PIC的DSO是不会包含任何代码段重定位表的，TEXTREL表示代码段重定位表地址。\n\n* PIC与PIE\n\n地址无关代码技术除了可以用在共享对象上面，它也可以用于可执行文件，一个以地址无关方式编译的可执行文件被称作地址无关可执行文件(PIE, Position-Independent Executable)。与GCC的`-fPIC`和`-fpic`参数类似，产生PIE的参数为`-fPIE`或`-f pie`。\n\n## 共享模块的全局变量问题\n\n在谈到动态库的装载地址时，说到了地址无关性问题。地址无关性问题就这么解决了吗？看起来好像是的。但仔细看看前面的4种地址引用方式的分类，会有一个小问题：我们上面的情况中没有包含**定义在模块内部的全局变量**的情况。把它跟模块内部的静态变量一样处理可以吗？的确，粗略一看模块内部的全局变量和静态变量的地址都可以通过上面所列出的类型两种方法来解决。但是有一种情况很特殊，我们来看看会产生什么问题。\n\n有一种很特殊的情况是，当**一个模块引用了一个定义在共享对象的全局变量**的时候，比如一个共享对象定义了一个全局变量global，而模块module.c中是这么引用的：\n\n```c\nextern int global;\t//定义在一个共享对象\nint foo()\n{\n    global = 1;\n}\n```\n\n当编译器编译module.c时，它**无法根据这个上下文判断global是定义在同一个模块的的其他目标文件还是定义在另外一个共享对象之中**，即**无法判断是否为跨模块间的调用**。\n假设module.c是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代码并不是地址无关代码，也就是说代码不会使用这种类似于PIC的机制，它引用这个全局变量的方式跟普通数据访问方式一样，编译器会产生这样的代码：\n`movl $0x1, xxxxxxxx`\n\n`XXXXXXXX`就是global的地址。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的“.bss”段创建一个global变量的副本。那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的“.bss”段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。\n\n于是解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。**ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量**，也就是说当作前面的类型四，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本， 那么GOT中的相应地址就指向模块内部的该变量副本。\n\n假设module.c是一个共享对象的一部分，那么GCC编译器在`-fPIC`的情况下，就会把对global的调用按照跨模块模式产生代码。原因也很简单：**编译器无法确定对global的引用是跨模块的还是模块内部的**。**即使是模块内部的，即模块内部的全局变量的引用，按照上面的结论，还是会产生跨模块代码，因为global可能被可执行文件引用**，从而使得共享模块中对global的引用要执行可执行文件中的global副本。\n\n> Q&A\n>\n> Q：如果一个共享对象`lib.so`中定义了一个全局变量`G`，而进程A和进程B都使用了`lib.so`，那么当进程A改变这个全局变量`G`的值时，进程B中的G会受到影响吗？\n> A：不会。因为当`lib.so`被两个进程加载时，它的数据段部分在每个进程中都有独立的副本，从这个角度看，**共享对象中的全局变量实际上和定义在程序内部的全局变量没什么区别**。任何一个进程访问的只是自己的那个副本，而不会影响其他进程。\n>\n> Q：那么，如果我们把这个问题的条件改成同一个进程中的线程A和线程B，它们是否看得到对方对`lib.so`中的全局变量G的修改呢？\n> A：对于同一个进程的两个线程来说，它们访问的是同一个进程地址空间，也就是同一个`lib.so`的副本，所以它们对G的修改，对方都是看得到的。\n>\n> Q：那么我们可不可以做到跟前面答案相反的情况呢？比如要求**两个进程共享一个共享对象的副本**或要求**两个线程访问全局变量的不同副本**，这两种需求都是存在的，比如多个进程可以共享同一个全局变量就可以用来实现进程间通信；而多个线程访问全局变量的不同副本可以防止不同线程之间对全局变量的干扰，比如C语言运行库的erron全局变量。\n> A：实际上这两种需求都是有相应的解决方法的，**多进程共享全局变量又叫做“共享数据段”**，在介绍Windows DLL的时候会碰到它。而**多个线程访问不同的全局变量副本又被叫做“线程私有存储”**(Thread Local Storage)。\n\n## 数据段地址无关性\n\n通过上面的方法，我们能够保证共享对象中的代码部分地址无关，但是数据部分是不是也有绝对地址引用的问题呢？让我们来看看这样一段代码：\n```c\nstatic int a;\nstatic int * p = &a;\n```\n\n如果某个共享对象里面有这样一段代码的话，那么指针p的地址就是一个绝对地址，它指向变量a，而变量a的地址会随着共享对象的装载地址改变而改变。那么有什么办法解决这个问题呢？\n\n**对于数据段来说，它在每个进程都有一份独立的副本**，所以并不担心被进程改变。从这点来看，我们**可以选择装载时重定位**的方法来解决数据段中绝对地址引用问题。**对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表**，这个重定位表里面包含了`R_386_RELATIVE`类型的重定位入口，用于解决上述问题。当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。\n\n实际上，我们**甚至可以让代码段也使用这种装载时重定位的方法，而不使用地址无关代码**。从前面的例子中我们看到，我们在编译共享对象时使用了`-fPIC`参数，这个参数表示产生地址无关的代码段。如果我们不使用这个参数来产生共享对象又会怎么样呢？\n\n```bash\ngcc -shared -o pic.so pic.c\n```\n\n上面这个命令就会产生一个不使用地址无关代码而使用装载时重定位的共享对象。但正如我们前面分析过的一样，如果代码不是地址无关的，它就不能被多个进程之间共享，于是也就失去了节省内存的优点。但是装载时重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它**省去了地址无关代码中每次访问全局数据和函数时需要做一次计算当前地址以及间接地址寻址的过程**。\n\n对于可执行文件来说，**默认情况下，如果可执行文件是动态链接的，那么GCC会使用PIC的方法来产生可执行文件的代码段部分**，以便于不同的进程能够共享代码段，节省内存。\n\n所以我们可以看到，动态链接的可执行文件中存在“.got”这样的段。\n\n# 延迟绑定\n\n动态链接的确有很多优势，比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。据统计ELF程序在静态链接下要比动态库稍微快点，大约为`1%~5%`，当然这取决于程序本身的特性及运行环境等。\n\n动态链接比静态链接慢的主要原因是：\n\n1. 动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后再进行间接跳转，如此一来，程序的运行速度必定会减慢。\n2. 另外一个减慢运行速度的原因是动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要进行一次链接工作，正如我们上面提到的，动态链接器会寻找并装载所需要的共享对象，然后进行符号查找地址重定位等工作，这些工作势必减慢程序的启动速度。\n\n这是影响动态链接性能的两个主要问题，我们将介绍优化动态链接性能的一些方法。\n\n## 优化的突破口\n\n在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量的全局变量会导致模块之间耦合度变大）。所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位，这也是我们上面提到的减慢动态链接性能的第二个原因。\n\n不过可以想象，在一个**程序运行过程中，可能很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者是一些用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费**。所以ELF采用了一种叫做**延迟绑定(Lazy Binding)**的做法，**基本的思想就是当函数第一次被用到时才由动态链接器进行绑定（符号查找、重定位等）**，如果没有用到则不进行绑定。这样的做法可以大大加快程序的启动速度，特别有利于一些有大量函数引用和大量模块的程序。\n\n## 延迟绑定实现\n\nELF使用**PLT**(Procedure Linkage Table)的方法来实现，这种方法使用了一些很精巧的指令序列来完成。\n\n在开始详细介绍PLT之前，我们先从动态链接器的角度设想一下：\n\n假设`liba.so`需要调用`libc.so`中的`bar()`函数，那么当`liba.so`中第一次调用`bar()`时，这时候就需要**调用动态链接器中的某个函数来完成地址绑定工作**，我们假设这个函数叫做`lookup()`，那么`lookup()`需要知道哪些必要的信息才能完成这个函数地址绑定工作呢？答案很明显，**`lookup()`至少需要知道这个地址绑定发生在哪个模块，哪个函数**。那么我们可以假设`lookup`的原型为`lookup(module, function)`，这两个参数的值在我们这个例子中分别为`liba.so`和`bar()`。\n\n在`Glibc`中，我们这里的`lookup()`函数真正的名字叫`_dl_runtime_resolve()`。\n\n当我们调用某个外部模块的函数时，如果按照通常的做法应该是通过GOT中相应的项进行间接跳转。**PLT为了实现延迟绑定，在这个过程中间又增加了一层间接跳转**。调用函数并**不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转**。每个外部函数在PLT中都有一个相应的项，比如`bar()`函数在PLT中的项的地址我们称之为`bar@plt`。让我们来看看bar@plt的实现：\n\n```x86asm\nbar@plt:\njmp *(bar@GOT)\npush n\npush moduleID\njump _dl_runtime_resolve\n```\n\n`bar@plt`的第一条指令是一条通过GOT间接跳转的指令。`bar@GOT`表示GOT中保存`bar()`这个函数相应的项。如果链接器在初始化阶段已经初始化该项，并且将`bar()`的地址填入该项，那么这个跳转指令的结果就是我们所期望的，跳转到`bar()`，实现函数正确调用。\n\n但是为了实现延迟绑定，链接器在初始化阶段并没有将`bar()`的地址填入到该项，而是将上面代码中第二条指令`push n`的地址填入到`bar@GOT`中，这个步骤不需要查找任何符号，所以代价很低。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。\n\n第二条指令将一个数字n压入堆栈中，这个数字是bar这个符号引用在重定位表`.rel.plt`中的下标，接着又是一条`push`指令将模块的ID压入到堆栈，然后跳转到`_dl_runtime_resolve`。这实际上就是在实现我们前面提到的`lookup(module, function)`这个函数的调用：先将所需要决议符号的下标压入堆栈，再将模块ID压入堆栈，然后调用动态链接器的`_dl_runtime_resolve()`函数来完成符号解析和重定位工作。`_dl_runtime_resolve()`在进行一系列工作以后将`bar()`的真正地址填入到`bar@GOT`中。\n\n一旦`bar()`这个函数被解析完毕，当我们再次调用`bar@plt`时，第一条`jmp`指令就能够跳转到真正的`bar()`函数中，`bar()`函数返回的时候会根据堆栈里面保存的`EIP`直接返回到调用者，而不会再继续执行`bar@plt`中第二条指令开始的那段代码，那段代码只会在符号未被解析时执行一次。\n\n上面我们描述的是PLT的基本原理，PLT真正的实现要比它的结构稍微复杂一些。ELF将GOT拆分成了两个表叫做`.got`和`.got.plt`。其中`.got`用来保存全局变量引用的地址，`.got.plt`用来保存函数引用的地址。也就是说，所有对于外部函数的引用全部被分离出来放到了`.got.plt`中。另外`.got.plt`还有一个特殊的地方是它的前三项是有特殊意义的，分别含义如下：\n\n1. 第一项保存的是`.dynamic`段的地址，这个段描述了本模块动态链接相关的信息，我们在后面还会介绍`.dynamic`段。\n2. 第二项保存的是本模块的ID。\n3. 第三项保存的是`_dl_runtime_resolve()`的地址。\n\n其中第二项和第三项由动态链接器在装载共享模块的时候负责将它们初始化。`.got.plt`的其余项分别对应每个外部函数的引用。PLT的结构也与我们示例中的PLT稍有不同，为了减少代码的重复，ELF把上面例子中的最后两条指令放到PLT中的第一项。并且规定每一项的长度是16个字节，刚好用来存放3条指令，实际的PLT基本结构如图所示。\n![image-20220509165057010](../../images/Linux_库/image-20220509165057010.png)\n\n实际的PLT基本结构代码如下：\n\n```x86asm\nPLT0:\npush *(GOT + 4)\njump *(GOT + 8)\n...\n\nbar@plt:\njmp *(bar@GOT)\npush n\njump PLT0\n```\n\nPLT在ELF文件中以独立的段存放，段名通常叫做`.plt`，因为它本身是一些地址无关的代码，所以可以跟代码段等一起合并成同一个可读可执行的`Segment`被装载入内存。\n\n# 总结\n\n我们分析了使用动态链接技术的原因，即使用动态链接可以更加有效地利用内存和磁盘资源，可以更加方便地维护升级程序，可以让程序的重用变得更加可行和有效。\n\n接着我们介绍了动态链接的基本例子，分析了动态链接中装载地址不确定时如何解决绝对地址引用的问题。\n\n**装载时重定位**和**地址无关代码**是解决绝对地址引用问题的两个方法。\n\n1. 装载时重定位的缺点是**无法共享代码段，但是它的运行速度较快**；\n2. 地址无关代码的缺点是**运行速度稍慢，但它可以实现代码段在各个进程之间的共享**。\n","categories":["Linux"]},{"title":"函数调用堆栈过程","url":"/计算机知识体系/函数调用堆栈过程/","content":"# 一段代码\n\n```cpp\nint sum(int a, int b)\n{\n    int temp = 0;\n    temp = a + b;\n    return temp;\n}\nint main()\n{\n    int a = 10;\n    int b = 20;\n    int res = sum(a, b);\n    cout << \"res:\" << res << endl;\n    return 0;\n}\n```\n\n问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数中？\n\n问题2：sum函数执行完后，回到main后，怎么知道下一条指令在哪？\n\n# 栈帧\n\n有两个与栈底、栈顶地址有关的寄存器。\n\n`ebp`全称`Extended Base Pointer`，扩展基址指针寄存器，用于存放函数栈底指针。\n\n`esp`全称`Extended Stack Pointer`，扩展栈指针寄存器，用于存放函数栈顶指针，指向栈的栈顶（下一个压入栈的活动记录的顶部）。\n\n先分析main函数的栈帧。\n\n```x86asm\nmov dword ptr[ebp-4], 0Ah\t# int a = 10;\nmov dword ptr[ebp-8], 14h\t# int b = 20;\n```\n\n","categories":["计算机知识体系"]},{"title":"进程地址空间体系","url":"/计算机知识体系/进程地址空间体系/","content":"# 进程地址空间体系图\n\n![image-20220507094939651](../../images/地址空间体系/image-20220507094939651.png)\n\n对于32位X86架构上运行的Linux而言， 其虚拟地址空间的寻址范围从`0 ~ 4G`，内核将这块空间划分为两个部分，将最高的**1G**字节`0xC0000000 ~ 0xFFFFFFFF`称为**“内核空间”**， 顾名思义是提供给内核使用；而将较低**3G**字节`0x00000000 ~ 0xBFFFFFFF`称为**“用户空间”**，即提供给各个运行的进程使用。\n\n理论上，每个进程都是可以访问全部能寻址的4G虚拟内存空间的，但是系统为了防止内核空间被用户进程有意或无意的破坏，所以采用了分级保护措施： 将内核定为0级，将用户进程定为3级， **这样用户进程便无法直接访问内核的虚拟内存空间，仅能通过系统调用来进入内核态，从而来访问被限定的部分内核空间地址**。同时，由于访问权限的机制，不同的进程间也都拥有独立的用户空间。这样非对称的访问机制使得Linux系统运行更加的安全稳定。\n\n另外，**用户进程是无法访问`0x00000000 ~ 0x08048000`这一段虚拟内存地址的**，在这段地址上有诸多例如C库，动态加载器如ld.so和VDSO等的映射地址。 如果用户进程访问到该区间会返回段错误。\n\n# 内核空间（最高地址，之后列的依次更低地址）\n\n每一个进程的用户空间是私有的，但是所有进程共享用一个内核空间。\n\n所以，进程之间的通信方式中的匿名管道通信就应用于此。\n\n## ZONE_HIGHMEM\n\n高端内存。在32位Linux系统，内核空间只有1G，在内核中映射高于1G的物理内存时，会使用到高端内存。64位不存在高端内存，因为64位系统的内核空间有512G。\n\n## ZONE_NORMAL\n\n内核常用的部分、最重要的部分。\n\n## ZONE_DMA\n\n直接内存访问。加快磁盘和内存交换数据。避免了经过CPU寄存器的过程，因此可以避免浪费CPU资源。\n\n# 命令行参数和环境变量\n\nmain函数的原型就是一个例子。\n\n```\nint main(int argc, char ** argv, char ** environ)\n```\n\nargc记录了命令行参数的个数。\n\nargv存的是命令行参数。\n\nenviron存的是环境变量。\n\n我们简单地引入一个stdio.h头文件，就能使用C语言库函数了，这个头文件并没有在本地，这是因为环境变量指出了库文件存在哪些位置，程序编译链接时加载了环境变量。\n\n这里涉及的命令行参数、环境变量都是存在于栈的高内存地址空间的。\n\n# 栈\n\n为何要有栈？程序运行时，总要有一个主入口，即\n\n**进程中的每一个线程都有属于自己的栈**。\n\n用户空间中地址最高的段叫做栈，他被**用于存放函数参数和动态局部变量**。调用一个方法或函数会将一个新的栈帧（stack frame）压入到栈中，这个栈帧会在函数返回时被清理掉。\n\n在程序运行过程中，进程通过函数的调用和返回使得控制权在各个函数间转移，在新函数调用时，原函数的栈帧状态保持不变，并为新的函数开辟其所需的帧空间；当调用函数返回时，该函数的运行空间随着栈帧被弹出而清空，这次进程回到原函数的栈帧环境中继续执行。\n\n>通过不断向栈中压入数据，超出其容量就会耗尽栈所对应的内存区域，这将触发一个页故障（page fault），而被Linux的`expand_stack()`处理，它会调用`acct_stack_growth()`来检查是否还有合适的地方用于栈的增长。\n>\n>如果栈的大小低于`RLIMIT_STACK`（通常为8MB），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情。这是一种将栈扩展到所需大小的常规机制；\n>\n>然而，如果达到了最大栈空间的大小，就会栈溢出(stack overflow)，程序收到一个段错误(segmentation fault)。\n>\n>* 动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。\n\n# 共享库内存段\n\n在栈和堆之间，有一段是用来存放共享库的。\n\n# mmap段\n\nmmap段，即Memory Mapping Segment。\n\n> File mappings (including dynamic libraries) and anonymous mappings. Example: `/lib/libc.so`\n\n在栈段的低一段便是mmap段，mmap是一种高效便捷的文件I/O方式，**内核将文件内容映射在此段内存中，常见情形便是加载动态链接库**。另外，在Linux中，如果你通过`malloc`申请一块大于`MMAP_THRESHOLD`(通常默认为128KB， 可用`mallopt()`修改)大小的堆空间时， glibc会返回一块匿名的mmap内存块而非一块堆内存。\n\n# 堆\n\n在mmap段再低一段便是堆段了，堆段同栈段一样，都是为进程运行提供动态的内存分配，**但是其和栈的区别在于堆上内存的生命期和执行分配的函数的生命期不一致，堆上分配的内存只有在对应进程通过系统调用主动释放或进程结束后才会释放**。所以，内存泄露这个经典的问题便由此产生。\n\n另外， 由于堆内存的反复申请和释放，也不可避免的会造成堆段碎片化。这种情况可以使用“对象池”的设计手段来避免。\n\n# 静态内存区域（数据段）-- bss 段和 data 段\n\n堆段再往下便是**BSS段**和**DATA段**这两个静态内存区域，这两段都是用来存储静态局部或静态全局变量，其在编译期间便决定了虚拟内存的消耗。\n\n**区别是DATA段存放的是已经初始化的变量，其映射自程序镜像中包含对应静态变量的文件；而BSS段则存放的是未初始化的变量，它不映射自任何一个执行文件**。\n\n根据C语言标准规定，未初始化的静态成员变量的初始值必须为0，所以内核在加载二进制文件后执行程序前会将BSS段清0。\n\n# 代码段\n\nBSS和DATA段下是**代码段**(TEXT)，此段存有程序的指令代码。Text段是通过只读的方式加载到内存中的，在多个进程中可以被安全共享。\n\n# 数据存放于哪个段？\n\n```cpp\nint gdata1 = 10;\nint gdata2 = 0;\nint gdata3;\n\nstatic int gdata4 = 11;\nstatic int gdata5 = 0;\nstatic int gdata6;\n\nint main()\n{\n    int a = 12;\n    int b = 0;\n    int c;\n    \n    static int d = 13;\n    static int e = 0;\n    static int f;\n    \n    return 0;\n}\n```\n\n全部的指令都存放在代码段，而一个程序除了数据就是指令，因此，函数中的局部变量`int a = 12; int b = 0; int c;`均为指令。其余的静态变量、全局变量都为数据。\n\n## 对于全局变量\n\n全局变量都是数据。则`gdata1~gdata6`都是数据，都会生成对应的符号。\n\n然而，如果未初始化或者初始化为0，均视为未初始化，如`gdata2`、`gdata3`、`gdata5`、`gdata6`预留在`.bss`段。\n\n> 未初始化和初始化为0是不同的概念、动作！即使最终的结果都是把int数据置0且存到bss段。但是显式初始化在C语言中会生成强符号，没有进行初始化的（即没有=0）会生成弱符号！\n\n`gdata1`、`gdata4`分配到`.data`段。\n\n## 对于局部变量\n\n对于非静态量，即`a`、`b`、`c`来说，已经不再属于数据，因为不会生成相应的符号。\n\n而是属于指令的范畴。实际翻译过来的指令含义如下。\n\n```x86asm\nmov dword ptr[a], 0Ch\t# word为2字节，dword表示double word，即4字节数据\n```\n\n即把`0Ch`移到a的内存中。\n\n这些指令产生后，在`.data`代码段存放。\n\n对于静态量，即`d`、`e`、`f`来说，依旧当作数据处理，生成符号，如果未初始化或者初始化为0，均视为未初始化，如`e`、`f`预留在`.bss`段。\n\n`d`分配到`.data`段。\n\n# 虚拟地址的实现原理\n\n它存在，你能看得见，这是物理的；\n它存在，你看不见，这是透明的；\n它不存在，你却看得见，这是虚拟的；\n它不存在，你也看不见，这是删除的。\n\n---\n\n每个进程都运行在一个属于自己的内存沙盒里，这个沙盒即虚拟地址空间，这些虚拟地址再通过页表(page table)来映射到物理内存上，页表由操作系统维护并被CPU所引用。所以用户空间地址的映射是动态变化的；而内核空间则是持续存在的，在每个进程中都映射到相同的物理内存中，这样便于寻址以应对随时出现的中断和系统调用。\n","categories":["计算机知识体系"]},{"title":"MySQL_完整性约束","url":"/数据库/MySQL_完整性约束/","content":"\n# 内容\n\n1. 主键约束\n1. 自增键约束\n1. 唯一键约束\n1. 非空约束\n1. 默认值约束\n1. 外键约束\n\n# 主键约束\n\n`PRIMARY KEY`\n\n只能有一个主键。\n\n```mysql\ncreate table user(\n\tid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT comment '用户的主键id',\n\tusername VARCHAR(50) UNIQUE NOT NULL COMMENT '用户名',\n\tage TINYINT UNSIGNED NOT NULL default 18,\n\tsex ENUM('male','demale')\n);\n# commit + ’...‘ 可以对本属性进行备注注释说明\n```\n\n创建表后，可以通过`desc user\\G`，或者`desc user;`来查看字段的详细信息。前者是展开列表形式，后者是二维表格形式。\n\n# 自增键约束\n\n`AUTO_INCREMENT`\n\n# 唯一键约束\n\n`UNIQUE`\n\n可以有多个唯一键，而且可以为空。\n\n# 非空约束\n\n`NOT NULL`\n\n# 默认值约束\n\n`DEFAULT`\n\n# 外键约束\n\n`FOREIGN KEY`\n\n拿学生信息表、考试信息表来举例子。两张表中的信息是有关联的，不是独立的。\n\n学生信息表中有张三，那么考试信息表里就可能有依赖张三的信息。\n\n如果我们要删除张三，那么需要把另一个表中依赖张三的信息也删掉。否则就会出现无效冗余数据。\n\n外键、存储函数、存储过程、触发器，在现如今的后台开发中几乎不直接用在mysql端了。\n\n而是尽量把这个过程放在业务逻辑上提前处理好，让数据库持久层专于做增删改查，有利于提高效率。\n","categories":["数据库","MySQL"]},{"title":"MySQL_数据类型","url":"/数据库/MySQL_数据类型/","content":"# 内容\n\n1. 数值类型\n2. 字符串类型\n3. 日期和时间类型\n4. enum和set\n\n# 设计数据类型的重要性\n\n业务层是工作在内存上的，速度很快。\n\n而最先达到性能瓶颈的一般都是数据库，因为数据库涉及到磁盘IO。磁盘IO是很慢的。\n\n所以我们定义数据表时，每一个字段的数据类型都要好好去斟酌。\n\nMySQL server虽然工作在内存上，但是它要读取数据、索引时，就要进行磁盘IO。磁盘IO次数越少，则性能越高，所以我们要尽力减少磁盘IO次数。\n\nMySQL数据类型定义了数据的大小范围，因此使用时选择合适的类型，不仅会降低表占用的磁盘空间，还能间接减少磁盘IO的次数，提高了表的访问效率；不仅如此，索引的效率也和数据类型息息相关。\n\n# 数值类型\n\n| 整数类型            | 字节  | 最小值                            | 最大值                                            |\n| --------------- | --- | ------------------------------ | ---------------------------------------------- |\n| `TINYINT`       | 1   | 有符号`-128`；无符号0                 | 有符号127；无符号255                                  |\n| `SMALLINT`      | 2   | 有符号`-32768`；无符号0               | 有符号32767；无符号65535                              |\n| `MEDIUMINT`     | 3   | 有符号`-8388608`；无符号0             | 有符号8388607；无符号1677215                          |\n| `INT`、`INTEGER` | 4   | 有符号`-2147483648`；无符号0          | 有符号2147483647；无符号4294967295                    |\n| `BIGINT`        | 8   | 有符号`-9223372036854775808`；无符号0 | 有符号9223372036854775807；无符号18446744073709551615 |\n\n| 浮点数类型 | 字节 | 最小值                        | 最大值                        |\n| ---------- | ---- | ----------------------------- | ----------------------------- |\n| `FLOAT`    | 4    | $\\pm 1.175494351E-38$         | $\\pm 3.402823466E+38$         |\n| `DOUBLE`   | 8    | $\\pm 2.2250738585072014E-308$ | $\\pm 1.7976931348623517E+308$ |\n\n其中浮点类型推荐使用`decimal`类型（保存为字符串格式）。数据精度范围很大，约28位，而且计算时，越界、溢出会报错，而普通整数、浮点只是截断。\n\n* 注意\n    * `age INT(9)`这不是意味着定义了一个长度为9字节的整型。数值类型占用内存的大小是固定的，和具体的类型是强相关的，括号内的数目只是代表它显示的宽度。\n\n## 示例\n\n```mysql\ncreate table user(age TINYINT unsigned NOT NULL default 0)\n```\n\n# 字符串类型\n\n| 字符串类型          | 字节  | 描述及存储需求                       |\n| -------------- | --- | ----------------------------- |\n| `CHAR(M)`      | M   | M为`0~255`之间的整数。占用空间M字节。       |\n| `VARCHAR(M)`   |     | M为`0~65535`之间的整数，值的长度+1个字节    |\n| `TINYBLOB`     |     | 允许长度`0~255`字节，值的长度+1字节        |\n| `BLOB`         |     | 允许长度`0~65535`字节，值的长度+2字节      |\n| `MEDIUMBLOB`   |     | 允许长度`0~167772150`字节，值的长度+3字节  |\n| `LONGBLOB`     |     | 允许长度`0~4294967295`字节，值的长度+4字节 |\n| `TINYTEXT`     |     | 允许长度`0~255`字节，值的长度+2字节        |\n| `TEXT`         |     | 允许长度`0~65535`字节，值的长度+2字节      |\n| `MEDIUMTEXT`   |     | 允许长度`0~167772150`字节，值的长度+3字节  |\n| `LONGTEXT`     |     | 允许长度`0~4294967295`字节，值的长度+4字节 |\n| `VARBINARY(M)` |     | 允许长度`0~M`个字节的变长字节字符串，值的长度+1字节 |\n| `BINARY(M)`    | M   | 允许长度`0~M`个字节的定长字节字符串          |\n\n* `CHAR(12)`和`VARCHAR(12)`的区别在于，如果实际的字符串长度不够12，`VARCHAR`大小则为实际的长度，而`CHAR`的大小则依旧是12字节；共同点：如果数据超过12则都会产生截断。\n* BLOB一般用于存储二进制格式的图片、音频。\n* TEXT的应用：留言板，商品的备注说明，聊天信息的存储。一些大文本。\n\n初期设计时，可能低估了将来的数据量，可能会超过设计的范围。\n\n数据库中字符串以单引号包裹。\n* SQL注入式攻击——字符串拼接导致的问题。\n\n# 日期和时间类型\n\n| 日期和时间类型 | 字节 | 最小值                | 最大值                |\n| -------------- | ---- | --------------------- | --------------------- |\n| `DATE`         | 4    | `1000-01-01`          | `9999-12-31`          |\n| `DATETIME`     | 8    | `1000-01-01 00:00:00` | `9999-12-31 23:59:59` |\n| `TIMESTAMP`    | 4    | `19700101080001`      | 2038年的某个时刻      |\n| `TIME`         | 3    | `-838:59:59`          | `838:59:59`           |\n| `YEAR`         | 1    | `1901`                | `2155`                |\n\n* 日期类型是做项目过程中经常使用的类型信息，尤其是`TIMESTAMP`和`DATETIME`两个类型；\n* 注意`TIMESTAMP`会自动更新时间，非常适合需要记录最新更新时间的场景，对应的函数是`unix_timestamp(now())`；而`DATETIME`需要手动更新。\n* 这里虽然介绍了MySQL的时间类型，但是现代的后端开发，MySQL基本已经很少使用自身的存储过程、存储函数、触发器、外键设置了，尽量把复杂的业务在业务层处理。涉及的时间操作也是同理。应该让MySQL聚焦在核心的增删改查操作上。\n## 时间戳示例\n\n```mysql\nselect now();\t\t\t\t\t# 2022-04-28 19:30:11\nselect unix_timestamp(now());\t# 1617683855\n```\n`unix_timestamp(now());`用于生成UNIX的时间戳，数值含义是自1970年起的秒数。用整型存储。\n# 枚举和集合（enum和set）\n\n* 这两种类型都是限制该字段只能取预定义的固定的某些值。比如性别——只能男或女。\n* 枚举字段只能取一个唯一的值。\n* 集合字段可以取任意个值。\n## 示例\n\n```mysql\nsex enum('M','W') default 'M'\n```\n\n","categories":["数据库","MySQL"]},{"title":"MySQL_表设计原则","url":"/数据库/MySQL_表设计原则/","content":"\n# 内容\n\n1. 给你一个场景，让你设计表。\n1. 关系型数据库的范式设计。\n1. 一对一/一对多实体关系的表设计原则\n1. 多对多实体关系的表设计原则\n1. 总结 - 表设计三要素\n\n# 表间的关系\n\n现实中，表与表之间的关系无非就三种：一对一、一对多、多对多。\n\n如何设计表之间的关联关系？\n\n# 一对一\n\n举个例子：用户User和身份信息Info的关系，一个用户对应一个身份信息。两张表是一对一的关系。\n\n* 用户User\n\n| uid(主键、自增) | name  | age  | sex  |\n| --------------- | ----- | ---- | ---- |\n| 1000            | zhang | 20   | M    |\n| 1020            | liu   | 21   | W    |\n| 2010            | wang  | 22   | M    |\n\n* 身份信息Info\n\n| cardid | addrinfo |\n| ------ | -------- |\n| 112233 | china    |\n| 334455 | japan    |\n| 556677 | canada   |\n\n目前来看，身份信息表和用户表完全对应不上。\n\n**需要在身份信息表加一个关联父表主键的字段uid，才能和用户表对应上**。\n\n| uid  | cardid | addrinfo |\n| ---- | ------ | -------- |\n| 1000 | 112233 | china    |\n| 1020 | 334455 | japan    |\n| 2010 | 556677 | canada   |\n\n现在，两个表之间的关联就是靠Info表的uid建立起来的，即**Info表的uid字段关联了父表的主键**，Info表的uid在逻辑上实际上就是**外键**，Info叫做**子表**，User叫做**父表**。子表的外键和父表的主键的数据类型必须一致，字段名无所谓。\n\n> mysql的性能瓶颈主要集中在磁盘IO，出于对性能的优化考虑，我们现在不会在sql层明确指出这是一个外键，不会把外键的约束工作分配给mysql。而是把外键的处理我们放到应用层代码。以让sql处理更核心的业务。\n\n使表之间能够一对一关联起来的做法：在子表中**增加一列**，与父表的主键关联。\n\n```mysql\nselect * from info where uid=2010;\t#如此就相当于间接查到“王”的身份信息\n```\n\n# 一对多/多对多\n\n举个例子：电商平台。有三个实体：用户User、商品Product、订单Order。\n\n## 分析\n\n* 用户 - 商品：在用户购买商品之前，它们之间没有直接的关联关系\n* 用户 - 订单：一对多的关系\n* 商品 - 订单：多对多的关系\n\n## 表设计\n\n* 用户User表\n\n| uid  | name  | age  | sex  |\n| ---- | ----- | ---- | ---- |\n| 1000 | zhang | 20   | M    |\n| 1020 | liu   | 21   | W    |\n| 2010 | wang  | 22   | M    |\n\n* 商品Product表\n\n| pid  | pname   | price  | amount |\n| ---- | ------- | ------ | ------ |\n| 1    | phone   | 600.0  | 100    |\n| 2    | laptop  | 2000.0 | 50     |\n| 3    | battery | 10.0   | 200    |\n\n* 订单Order表\n\n| orderid | pid  | number | money  | totalprice | addrinfo     |\n| ------- | ---- | ------ | ------ | ---------- | ------------ |\n| O1000   | 1    | 1      | 600.0  | 4640.0     | 西安工业大学 |\n| O1000   | 2    | 2      | 4000.0 | 4640.0     | 西安工业大学 |\n| O1000   | 3    | 4      | 40.0   | 4640.0     | 西安工业大学 |\n| O2000   | 2    | 1      | 2000.0 | 2000.0     | 陕西科技大学 |\n\n## 用户和订单 - 一对多\n\n订单中没有用户的信息，对应不上是哪个用户的订单。\n\n则需要给订单加一个用户id字段，需与主表的主键关联，类型必须一致。即可与用户对应。\n\n| orderid | uid  | pid  | number | money  | totalprice | addrinfo     |\n| ------- | ---- | ---- | ------ | ------ | ---------- | ------------ |\n| O1000   | 1000 | 1    | 1      | 600.0  | 4640.0     | 西安工业大学 |\n| O1000   | 1000 | 2    | 2      | 4000.0 | 4640.0     | 西安工业大学 |\n| O1000   | 1000 | 3    | 4      | 40.0   | 4640.0     | 西安工业大学 |\n| O2000   | 2010 | 2    | 1      | 2000.0 | 2000.0     | 陕西科技大学 |\n\n## 商品和订单 - 多对多\n\n目前的订单表的设计是有很多问题的，信息冗余过多。如果某用户在同一订单中购买了多种商品，则orderid、uid、totalprice和addrinfo都是一致的，为每一种商品都单列一条记录，冗余过多。\n\n冗余带来的问题有很多，其中最大的问题是，如果用户对订单进行增删改查，则有可能影响整个有关此订单的所有记录，修改代价高。\n\n如果订单(Order)表像下面这样，就很简洁了。这就不存在冗余了。如果需要更改订单，不用删除多行记录，只需修改一次。\n\n| orderid | uid  | totalprice | addrinfo     |\n| ------- | ---- | ---------- | ------------ |\n| O1000   | 1000 | 4640.0     | 西安工业大学 |\n| O2000   | 2010 | 2000.0     | 陕西科技大学 |\n\n但是还要知道订单的内容，需要一个中间表 - 订单内容OrderList。\n\n| orderid | pid  | number | money  |\n| ------- | ---- | ------ | ------ |\n| O1000   | 1    | 1      | 600.0  |\n| O1000   | 2    | 2      | 4000.0 |\n| O1000   | 3    | 4      | 40.0   |\n| O2000   | 2    | 1      | 2000.0 |\n\n由此设计，商品表和订单表则不会出现数据冗余。\n\n# 总结\n\n在进行表的设计时，考虑三个问题\n\n1. 表字段数据类型的斟酌\n2. 完整性约束条件的规范\n3. 实体关系对应的表设计原则\n\n实体之间的关系，无非是一对一、一对多、多对多。\n\n一对一、一对多中，子表和父表的关联可由子表增加一列字段来关联父表的主键。\n\n而多对多关系中，除了增加一列字段来关联父表，还需要增加一个中间表来消除冗余。\n\n","categories":["数据库","MySQL"]},{"title":"MySQL_运算符","url":"/数据库/MySQL_运算符/","content":"\n# 内容\n\n1. 算数运算符\n1. 逻辑运算符\n1. 比较运算符\n\n# 算术运算符\n\n| 运算符     | 作用           |\n| ---------- | -------------- |\n| `+`        | 加法           |\n| `-`        | 减法           |\n| `*`        | 乘法           |\n| `/`、`DIV` | 除法，返回商   |\n| `%`、`MOD` | 除法，返回余数 |\n\n* 注意\n  * 计算时，需要注意当时的数据类型取值范围是否合适，以免越界导致业务出错\n\n## 示例\n\n```mysql\nupdate user set age=age+1;\n```\n\n# 逻辑运算符\n\n| 运算符      | 作用   |\n| ----------- | ------ |\n| `NOT`或`!`  | 逻辑非 |\n| `AND`或`&&` | 逻辑与 |\n| `OR`或`||`  | 逻辑或 |\n\n# 比较运算符\n\n| 运算符     | 作用                             |\n| ---------- | -------------------------------- |\n| `=`        | 等于                             |\n| `<>`或`!=` | 不等于（`<>`在未来可能会被淘汰） |\n| `<=>`      | NULL安全的等于(NULL-safe)        |\n| <          | 小于                             |\n| <=         | 小于等于                         |\n| >          | 大于                             |\n| >=         | 大于等于                         |\n\n| 运算符            | 作用           |\n| ----------------- | -------------- |\n| `BETWEEN`         | 存在于指定范围 |\n| `IN`              | 存在于指定集合 |\n| `IS NULL`         | 为NULL         |\n| `IS NOT NULL`     | 不为NULL       |\n| `LIKE`            | 通配符匹配     |\n| `REGEXP`或`RLIKE` | 正则表达式匹配 |\n\n* 注意\n  * 判空不要写`=NULL`，而是要写`IS NOT NULL`或`IS NULL`；判空经常出现在左连接、右连接中的外键查询。\n  * 通配符与索引的关系？\n    * `LIKE`通配符不一定会用到索引，需要看通配符加的地方，如果通配符在中间、末尾则能用到；但是如果加到最开始则不会用到。\n\n## 示例\n\n```mysql\nselect * from user where age between 20 and 22;\nselect * from user where score in (99.0, 100.0);\n```\n\n```mysql\nselect * from user where score IS NOT NULL;\n```\n\n```mysql\nselect * from user where name like 'zhang%';\t#zhang开头的任何字符串\nselect * from user where name like 'zhang_';\t#下划线是占位通配符，只能匹配后面只有一个字符的\n```\n\n\n\n\n\n# 综合示例\n\n下面这个查询语句用到了多个运算符：`sex='M'`、`and`、`score>=90.0`\n\n```mysql\nselect * from where sex='M' and score>=90.0;\n```\n\n","categories":["数据库","MySQL"]},{"title":"类之间的关系","url":"/设计模式/类之间的关系/","content":"# 内容\n\n在软件系统中，类不是孤立存在的，类与类之间存在相互关系，因此需要通过UML来描述这些类之间的关系。类之间具有如下几种关系。\n\n1. 关联关系\n    1. 双向关联\n    2. 单向关联\n    3. 自关联\n    4. 多重性关联\n    5. 聚合关系\n    6. 组合关系\n2. 依赖关系\n3. 泛化关系（继承关系）\n4. 接口与实现关系\n以上是按照刘伟的分类方式来说的。\n\n更易理解、符合名字定义的分类方式如下：\n\n1. 继承关系（即泛化关系，将接口与实现关系也包含在内）\n2. 组合关系\n3. 聚合关系\n4. 依赖关系\n5. 关联关系\n# 关联关系\n\n关联关系（Association）是类与类之间最常用的一种关系，它是一种**结构化关系**，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。\n\n**在UML类图中，用实线连接有关联的对象所对应的类**，在使用Java、`C#`和`C++`等编程语言**实现关联关系时，通常将一个类的对象作为另一个类的属性**。\n\n* 要点\n    * 在使用类图表示关联关系时可以在关联线上标注角色名，**一般使用一个表示两者之间关系的动词或者名词表示角色名(有时该名词为实例对象名)**\n    * 关系的两端代表不同的两种角色，因此在一个关联关系中可以包含两个角色名。\n    * 角色名不是必需的，可以根据需要增加，其目的是使类之间的关系更加明确。\n\n例如，在一个登录界面类Login Form中包含一个JButton类型的注册按钮login Button，它们之间可以表示为关联关系，代码实现时可以在Login Form中定义一个名为login Button的属性对象，其类型为JButton，如图所示。\n\n![image-20220427152626763](../../images/类之间的关系/image-20220427152626763.png)\n\n关联关系可以细分为6种。\n\n## 双向关联\n\n默认情况下，关联是双向的。例如，顾客(Customer)购买商品(Product)并拥有商品；反之，卖出的商品总有某个顾客与之相关联。因此，`Customer`类和`Product`类之间具有双向关联关系，**用直线表示**，如图所示。\n\n![类之间关系2](../../images/类之间的关系/类之间关系2.png)\n\n## 单向关联\n\n类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如，顾客(Customer)拥有地址(Address),则Customer类与Address类具有单向关联关系。与第一个图`LoginForm - JButton`的关系一样。**用直线加箭头表示**。\n\n## 自关联\n\n在系统中可能存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如，一个节点类(Node)的成员又是节点对象，如图。\n\n![image-20220427154807115](../../images/类之间的关系/image-20220427154807115.png)\n\n## 多重性关联\n\n又称为重数性关联关系（Multiplicity），表示一个类的对象与另一个类的对象连接的个数。\n\n在UML中多重性关联关系可以直接**在关联直线上增加一个数字表示与之对应的另一个类的对象的个数**。\n\n* 下表：多重性表示方式列表\n\n| 表示方式 | 多重性说明                                                   |\n| -------- | ------------------------------------------------------------ |\n| `1..1`   | 表示另一个类的1个对象**只与1个**该类对象有关系               |\n| `0..*`   | 表示另一个类的1个对象与**0个或多个**该类对象有关系           |\n| `1..*`   | 表示另一个类的1个对象与**1个或多个**该类对象有关系           |\n| `0..1`   | 表示另一个类的1个对象**没有或只与1个**该类对象有关系         |\n| `m..n`   | 表示另一个类的1个对象与最少m、最多n个该类对象有关系$(m\\le n)$ |\n\n例如，一个界面(Form)可以拥有0个或多个按钮(Button)，但是一个按钮只能属于一个界面。因此，一个Form类的对象可以与0个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联，如图。\n\n![image-20220427160905246](../../images/类之间的关系/image-20220427160905246.png)\n\n## 聚合关系\n\n聚合关系（Aggregation）**表示一个整体与部分**的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。如一台计算机包含显示器、主机、键盘、鼠标等部分，就可以使用聚合关系来描述整体与部分之间的关系。\n\n在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。例如，汽车发动机(Engine)是汽车(Car)的组成部分，但是汽车发动机可以独立存在，因此汽车和发动机是聚合关系，如图所示。\n\n![image-20220427162037062](../../images/类之间的关系/image-20220427162037062.png)\n\nCar中定义了一个Engine类型的成员变量，从语义上来说，Engine是Car的一部分，但是Engine对象可以脱离Car单独存在。因此，**在类Car中并不直接实例化Engine，而是通过构造函数或者setter设值将在类外部实例化好的Engine对象以参数形式传入Car中**，这种传入方式称为**注入（Injection）**。正因为Car和Engine的实例化时刻不相同，因此**它们之间不存在生命周期的制约关系**，而**仅仅只是整体与部分之间的关系**而已。\n\n## 组合关系\n\n组合关系（Composition）也表示类之间整体和部分的关系，但是组合关系中**部分和整体具有统一的生存期**。**一旦整体对象不存在，部分对象也将不存在**，部分对象与整体对象之间具有**同生共死**的关系。例如一个界面对象与其包含的按钮、文本框、静态文本等成员对象，如果界面对象在内存中被销毁，则所有成员均被销毁。\n\n在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。\n\n在UML中，组合关系用带**实心菱形**的直线表示。例如，人的头(Head)与嘴巴(Mouth)，嘴巴是头的组成部分之一，而且如果头没了，则嘴巴也就没了，因此头和嘴巴是组合关系，如图所示。\n\n![image-20220427162715751](../../images/类之间的关系/image-20220427162715751.png)\n\nHead中定义了一个Mouth类型的成员，而且在Head的构造函数中实例化Mouth对象，因此在创建Head对象的同时将创建Mouth对象，在销毁Head对象的同时销毁Mouth对象。**它们之间不仅仅只是整体与部分之间的关系，而且整体还可以控制部分的生命周期**。\n\n* 聚合和组合的对比\n    * 聚合关系表示整体与部分的关系比较弱，而组合关系比较强；\n    * 聚合关系中代表部分事物的对象与代表整体事物的对象的生存期无关，删除整体对象并不表示部分对象被删除。\n    * 从代码实现的角度来看也略有区别，聚合关系通过对象注入的方式来实现，而组合关系通过在整体类的构造函数中实例化成员类来实现。\n    * 但是它们的**共同点是一个类的实例为另一个类的成员对象**。\n\n聚合关系和组合关系与普通的关联关系主要是语义上的区别，如表示客户类与产品类的关系就不能用聚合和组合，因为产品并不是客户的一部分，不存在整体与部分关系，只能用普通的关联关系。\n# 依赖关系\n\n依赖关系（Dependency）**是一种使用关系**，被使用者的改变有可能会影响到使用者，在需要**表示一个事物使用另一个事物**时使用依赖关系。\n\n大多数情况下，依赖关系**体现在某个类的方法使用另一个类的对象作为参数**。\n\n在UML中，依赖关系**用带箭头的虚线**表示，由依赖的一方指向被依赖的一方。例如，驾驶员开车，在`Driver`类的`drive()`方法中将`Car`类型的对象`car`作为一个参数传递，以便在`drive()`方法中能够调用`car`的`move()`方法，且驾驶员的`drive()`方法依赖车的`move()`方法，因此类`Driver`依赖类`Car`，如图所示。\n\n![image-20220427164758961](../../images/类之间的关系/image-20220427164758961.png)\n\n在具体实现时：\n\n1. 如果在一个类的方法中调用了另一个类的静态方法；或：\n2. 在一个类的函数中定义了另一个类的对象作为其局部变量\n\n也是依赖关系的表现形式，但是这个关系需要在实现阶段慢慢浮现出来，在分析设计阶段可以暂时不予考虑。\n\n# 泛化关系\n\n泛化关系（Generalization）也就是继承关系，**也称为“is-a-kind-of”关系**。\n\n泛化关系用于**描述父类与子类**之间的关系，父类又称作基类或超类，子类又称作派生类。\n\n在UML中，**泛化关系用带空心三角形的直线**来表示。\n\n在代码实现时，**使用面向对象的继承机制来实现泛化关系**，如在Java语言中使用extends关键字，在`C++/C#`中使用冒号`:`来实现。例如，Student类和Teacher类都是Person类的子类，Student类和Teacher类继承了Person类的属性和方法，Person类的属性包含姓名(name)和年龄(age)，每一个Student和Teacher也都具有这两个属性，另外Student类增加了属性学号`(studentNo)`，Teacher类增加了属性教师编号`(teacherNo)`，Person类的方法包括行走`move()`和说话`say()`，Student类和Teacher类继承了这两个方法，而且Student类还新增方法`study()`，Teacher类还新增方法`teach()`，如图所示。\n\n![image-20220427171305290](../../images/类之间的关系/image-20220427171305290.png)\n\n# 接口与实现关系\n\n在很多面向对象语言中都引入了接口的概念，如Java、`C#`等。在接口中，一般没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。\n\nUML中用与类的表示法类似的方式表示接口，如图所示。\n\n![image-20220427173357890](../../images/类之间的关系/image-20220427173357890.png)\n\n接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种**实现关系（Realization）**。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。\n\n在UML中，**类与接口之间的实现关系用带空心三角形的虚线来表示**。例如，定义了一个交通工具接口`Vehicle`，其中有一个抽象操作`move()`，在类`Ship`和类`Car`中都实现了该`move()`操作，不过具体的实现细节将会不一样，如图所示。\n\n![image-20220427173447055](../../images/类之间的关系/image-20220427173447055.png)\n\n实现关系在用代码实现时，不同的面向对象语言也提供了不同的语法，如在Java语言中使用`implements`关键字，在`C++/C#`中使用冒号`:`来实现。\n\n# 参考文献\n\n```\n[1] 刘伟. 设计模式.\n```\n","categories":["设计模式"]},{"title":"建造者模式","url":"/设计模式/建造者模式/","content":"\n# 内容\n\n1. 引述\n1. 建造者模式概述\n2. 引入抽象工厂\n2. 抽象工厂模式概述\n2. 解决方案\n\n# 引述\n\n没有人买车会只买一个轮胎或者方向盘，大家买的都是一辆包含轮胎、方向盘和发动机等多个部件的完整汽车。**如何将这些部件组装成一辆完整的汽车并返回给用户，这是建造者模式需要解决的问题**。建造者模式**又称为生成器模式**，它是一种较为复杂、使用频率也相对较低的创建型模式。建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。\n\n## 案例-游戏角色设计\n\n该软件公司游戏开发小组决定开发一款名为《仙魔群侠传》的网络游戏，该游戏采用主流的RPG(Role Playing Game,角色扮演游戏)模式，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。\n\n作为RPG游戏的一个重要组成部分，**需要对游戏角色进行设计，而且随着该游戏的升级将不断增加新的角色。不同类型的游戏角色，其性别、脸型、服装、发型等外部特性都有所差异**，例如“天使”拥有美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”极其丑陋，留着光头并穿一件刺眼的黑衣。\n\n该公司决定**开发一个小工具来创建游戏角色，可以创建不同类型的角色并可以灵活增加新的角色**。\n\n该司的开发人员通过分析发现，游戏角色是一个复杂对象，它包含性别、脸型等多个组成部分，不同的游戏角色其组成部分有所差异，如图所示：\n\n![image-20220426115229892](../../images/建造者模式/image-20220426115229892.png)\n\n无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。**如何一步步创建一个包含多个组成部分的复杂对象**，建造者模式为解决此类问题而诞生。\n\n# 建造者模式概述\n\n建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，**客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可**。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。\n\n## 定义\n\n建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。\n\n## 结构\n\n建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图所示：\n\n![image-20220426115426800](../../images/建造者模式/image-20220426115426800.png)\n\n## 角色\n\n在建造者模式结构图中包含如下几个角色：\n\n* Builder（抽象建造者）：Builder既可以是抽象类，也可以是接口。它为创建一个产品Product对象的各个部件指定抽象接口。在该接口中一般声明两类方法。\n  * 一类方法是buildPartX()，它们用于创建复杂对象的各个部件\n  * 另一类方法是getResult()，它们用于返回复杂对象。\n* ConcreteBuilder（具体建造者）\n  * 它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。\n* Product（产品角色）\n  * 它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。\n* Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序。\n  * 指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。\n  * 客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。\n\n## 代码\n\n* 产品类\n\n在建造者模式的定义中提到了**复杂对象**，那么什么是复杂对象？简单来说，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件，一个典型的复杂对象类代码示例如下：\n\n```cpp\nclass Product  \n{\nprivate:\n    String partA; //定义部件，部件可以是任意类型，包括值类型和引用类型\n    String partB;\n    String partC;\n    //partA的Getter方法和Setter方法省略\n    //partB的Getter方法和Setter方法省略\n    //partC的Getter方法和Setter方法省略\n};\n```\n\n* 抽象建造者类\n\n在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下\n\n```cpp\nclass Builder\n{\nprotected:\n    //创建产品对象\n    Product * product;//Product product=new Product();\npublic:\n    void buildPartA() = 0;\n    void buildPartB() = 0;\n    void buildPartC() = 0;\n    //返回产品对象\n\tProduct* getResult()\n    {\n        return product;\n    }\n};\n```\n\n在抽象类`Builder`中声明了一系列抽象的`buildPartX()`方法用于创建复杂产品的各个部件，具体建造过程在`ConcreteBuilder`中实现，此外还提供了工厂方法`getResult()`，用于返回一个建造好的完整产品。\n\n* 具体建造者类\n\n在`ConcreteBuilder`中实现了`buildPartX()`方法，通过调用`Product`的`setPartX()`方法可以给产品对象的成员属性设值。不同的具体建造者在实现`buildPartX()`方法时将有所区别，如`setPartX()`方法的参数可能不一样，在有些具体建造者类中某些`setPartX()`方法无须实现（提供一个空实现）。而这些对于客户端来说都无须关心，客户端只需知道具体建造者类型即可。\n\n* 指挥者类\n\n在建造者模式的结构中还引入了一个指挥者类Director，该类主要有两个作用：一方面它隔离了客户与创建过程；另一方面它控制产品的创建过程，包括某个buildPartX()方法是否被调用以及多个buildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。在实际生活中也存在类似指挥者一样的角色，如一个客户去购买电脑，电脑销售人员相当于指挥者，只要客户确定电脑的类型，电脑销售人员可以通知电脑组装人员给客户组装一台电脑。指挥者类的代码示例如下：\n\n```cpp\nclass Director\n{\nprivate:\n    Builder * builder;\npublic:\n    Director(Builder* builder)\n    {\n    \tthis.builder = builder;\n    }\n    void setBuilder(Builder* builder)\n    {\n    \tthis.builder = builer;\n    }\n    //产品构建与组装方法\n    Product* construct()\n    {\n        builder->buildPartA();\n        builder->buildPartB();\n        builder->buildPartC();\n        return builder->getResult();\n    }\n};\n```\n\n在指挥者类中可以注入一个抽象建造者类型的对象，其核心在于提供了一个建造方法construct()，在该方法中调用了builder对象的构造部件的方法，最后返回一个产品对象。\n\n* 客户端\n\n对于客户端而言，只需关心具体的建造者即可，一般情况下，客户端类代码片段如下所示：\n\n```cpp\nBuilder* builder = new ConcreteBuilder(); //可通过配置文件实现\nDirector* director = new Director(builder);\nProduct* product = director->construct();\n```\n\n可以通过配置文件来存储具体建造者类`ConcreteBuilder`的类名，使得更换新的建造者时无须修改源代码，系统扩展更为方便。在客户端代码中，无须关心产品对象的具体组装过程，只需指定具体建造者的类型即可。\n\n## 与抽象工厂模式的对比\n\n建造者模式与抽象工厂模式有点相似，但是\n\n* **建造者模式返回一个完整的复杂产品**，而**抽象工厂模式返回一系列相关的产品**；\n* 在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而**在建造者模式中，客户端通过指定具体建造者类型并指导Director类如何去生成对象**，侧重于一步步构造一个复杂对象，然后将结果返回。\n* 如果将**抽象工厂模式看成一个汽车配件生产厂**，生成不同类型的汽车配件，那么**建造者模式就是一个汽车组装厂**，通过对配件进行组装返回一辆完整的汽车。\n\n# 完整解决方案\n\n该公司开发人员决定使用建造者模式来实现游戏角色的创建，其基本结构如图所示：\n\n![image-20220427191321266](../../images/建造者模式/image-20220427191321266.png)\n\n在图中，ActorController充当指挥者，ActorBuilder充当抽象建造者，HeroBuilder、AngelBuilder和DevilBuilder充当具体建造者，Actor充当复杂产品。\n\n指挥者类ActorController需要定义`construct()`方法，该方法拥有一个抽象建造者`ActorBuilder`类型的参数，在该方法内部实现了游戏角色对象的逐步构建。\n\n为了提高系统的灵活性和可扩展性，最好将具体建造者类的类名存储在配置文件中，并通过某个工具类Util来读取配置文件并反射生成对象。\n\n# 总结\n\n建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。\n\n## 主要优点\n\n* 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n* 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”\n* 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n\n## 主要缺点\n\n* 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。\n* 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。\n\n## 适用场景\n\n* 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。\n* 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。\n* 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。\n* 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。\n\n在建造者模式中，**客户端只需实例化指挥者类**，指挥者类针对抽象建造者编程，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品（逐步调用具体建造者的buildX()方法），相同的构造过程可以创建完全不同的产品。\n\n在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；\n\n如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。\n\n# 参考文献\n\n```\n[1] 刘伟. 设计模式.\n```\n","categories":["设计模式","创建型模式"]},{"title":"抽象工厂模式","url":"/设计模式/抽象工厂模式/","content":"\n# 内容\n\n1. 抽象工厂模式之前\n2. 引入抽象工厂\n2. 抽象工厂模式概述\n2. 解决方案\n\n# 抽象工厂模式之前\n\n工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题。\n但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。\n此时，我们可以考虑**将一些相关的产品组成一个“产品族”**，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。\n\n## 案例-界面皮肤库的初始设计\n\n某软件公司欲开发一套界面皮肤库，可以对Java桌面软件进行界面美化。为了保护版权，该皮肤库源代码不打算公开，而只向用户提供已打包为jar文件的class字节码文件。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，其结构示意图如图。\n\n![image-20220426083347741](../../images/抽象工厂模式/image-20220426083347741.png)\n\n该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。\n\n该软件公司的开发人员针对上述要求，决定使用工厂方法模式进行系统的设计，为了保证系统的灵活性和可扩展性，提供一系列具体工厂来创建按钮、文本框、组合框等界面元素，客户端针对抽象工厂编程，初始结构如图所示。\n\n![img](../../images/抽象工厂模式/image-20220426083347742.png)\n\n* 在图中，提供了大量工厂来创建具体的界面组件，可以通过配置文件更换具体界面组件从而改变界面风格。但是，此设计方案存在如下问题：\n  * 当需要增加新的皮肤时，虽然不要修改现有代码，**但是需要增加大量类**，针对每一个新增具体组件都需要增加一个具体工厂，**类的个数成对增加，这无疑会导致系统越来越庞大**，增加系统的维护成本和运行开销；\n  * 由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱，虽然我们可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂。\n\n如何减少系统中类的个数并保证客户端每次始终只使用某一种风格的具体界面组件？这是该公司开发人员所面临的两个问题，显然，工厂方法模式无法解决这两个问题，别着急，将要介绍的抽象工厂模式可以让这些问题迎刃而解。\n\n# 引入抽象工厂\n\n在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是**有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器**，而不是只生产某一种电器。为了更好地理解抽象工厂模式，我们先引入两个概念：\n\n* **产品等级结构**：产品等级结构即**产品的继承结构**，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。\n* **产品族**：在抽象工厂模式中，**产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品**，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。\n\n产品等级结构与产品族示意图如图所示：\n\n![img](../../images/抽象工厂模式/image-20220426083347743.png)\n\n在图中，不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。图中一共有五个产品族，分属于三个不同的产品等级结构。我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品。\n\n**当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式**。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。**抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建**。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图所示：\n\n![image-20220426084423742](../../images/抽象工厂模式/image-20220426084423742.png)\n\n在图中，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，图所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减少了系统中类的个数。\n\n# 抽象工厂模式概述\n\n抽象工厂模式为创建一组对象提供了一种解决方案。**与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品**。抽象工厂模式定义如下：\n\n> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。\n\n在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图\n\n![image-20220426090141713](../../images/抽象工厂模式/image-20220426090141713.png)\n\n## 该模式包含的角色\n\n1. **AbstractFactory（抽象工厂）**\n   * 它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。\n2. **ConcreteFactory（具体工厂）**\n   * 它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。\n3. **AbstractProduct（抽象产品）**\n   * 它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。\n4. **ConcreteProduct（具体产品角色）**\n   * 它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。\n\n## 典型代码\n\n在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：\n\n```c++\nclass AbstractFactory\n{\npublic:\n    AbstractProductA createProductA() = 0;\t//工厂方法一\n\tAbstractProductB createProductB() = 0;\t//工厂方法二\n}\n```\n\n具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：\n\n```c++\nclass ConcreteFactory1 : public AbstractFactory\n{\npublic:\n    //工厂方法一\n    AbstractProductA createProductA()\n    {\n    \treturn new ConcreteProductA1();\n    }\n\t//工厂方法二\n\tAbstractProductB createProductB()\n    {\n    \treturn new ConcreteProductB1();\n\t}\n}\n```\n\n# 前文案例完整解决方案\n\n该公司开发人员使用抽象工厂模式来重构界面皮肤库的设计，其基本结构如图所示：\n\n![image-20220426091002353](../../images/抽象工厂模式/image-20220426091002353.png)\n\n在图中，`SkinFactory`接口充当抽象工厂，其子类`SpringSkinFactory`和`SummerSkinFactory`充当具体工厂，接口`Button`、`TextField`和`ComboBox`充当抽象产品，其子类`SpringButton`、`SpringTextField`、`SpringComboBox`和`SummerButton`、`SummerTextField`、`SummerComboBox`充当具体产品。完整代码如下所示：\n\n```cpp\n//在本实例中对代码进行了大量简化，实际使用时，界面组件的初始化代码较为复杂，为了突出核心代码，在此只提供框架代码和演示输出。\n//按钮接口：抽象产品\nclass Button\n{\npublic:\n\tvirtual void display() = 0;\n};\n//Spring按钮类：具体产品\nclass SpringButton : public Button\n{\npublic:\n\tvoid display()\n\t{\n\t\tcout << \"显示浅绿色按钮。\" << endl;\n\t}\n};\n//Summer按钮类：具体产品\nclass SummerButton : public Button\n{\npublic:\n\tvoid display()\n\t{\n\t\tcout << \"显示浅蓝色按钮。\" << endl;\n\t}\n};\n//文本框接口：抽象产品\nclass TextField\n{\npublic:\n\tvirtual void display() = 0;\n};\n//Spring文本框类：具体产品\nclass SpringTextField : public TextField\n{\npublic:\n\tvoid display()\n\t{\n\t\tcout << \"显示绿色边框文本框。\" << endl;\n\t}\n};\n//Summer文本框类：具体产品\nclass SummerTextField : public TextField\n{\npublic:\n\tvoid display()\n\t{\n\t\tcout << \"显示蓝色边框文本框。\" << endl;\n\t}\n};\n//组合框接口：抽象产品\nclass ComboBox\n{\npublic:\n\tvirtual void display() = 0;\n};\n//Spring组合框类：具体产品\nclass SpringComboBox : public ComboBox\n{\npublic:\n\tvoid display()\n\t{\n\t\tcout << \"显示绿色边框组合框。\" << endl;\n\t}\n};\n//Summer组合框类：具体产品\nclass SummerComboBox : public ComboBox\n{\npublic:\n\tvoid display()\n\t{\n\t\tcout << \"显示蓝色边框组合框。\" << endl;\n\t}\n};\n//界面皮肤工厂接口：抽象工厂\nclass SkinFactory\n{\npublic:\n\tvirtual Button* createButton() = 0;\n\tvirtual TextField* createTextField() = 0;\n\tvirtual ComboBox* createComboBox() = 0;\n};\n//Spring皮肤工厂：具体工厂\nclass SpringSkinFactory : public SkinFactory\n{\npublic:\n\tButton* createButton()\n\t{\n\t\treturn new SpringButton();\n\t}\n\tTextField* createTextField()\n\t{\n\t\treturn new SpringTextField();\n\t}\n\tComboBox* createComboBox()\n\t{\n\t\treturn new SpringComboBox();\n\t}\n};\n//Summer皮肤工厂：具体工厂\nclass SummerSkinFactory : public SkinFactory\n{\npublic:\n\tButton* createButton()\n\t{\n\t\treturn new SummerButton();\n\t}\n\tTextField* createTextField()\n\t{\n\t\treturn new SummerTextField();\n\t}\n\tComboBox* createComboBox()\n\t{\n\t\treturn new SummerComboBox();\n\t}\n};\n```\n\n## 客户端\n\n编写如下客户端测试代码\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main()\n{\n\t//使用抽象层定义\n\tSkinFactory* factory;\n\tButton* bt;\n\tTextField* tf;\n\tComboBox* cb;\n\tfactory = new SpringSkinFactory;\n\tbt = factory->createButton();\n\ttf = factory->createTextField();\n\tcb = factory->createComboBox();\n\tbt->display();\n\ttf->display();\n\tcb->display();\n}\n```\n\n编译并运行程序，输出结果如下\n\n```\n显示浅绿色按钮。\n显示绿色边框文本框。\n显示绿色边框组合框。\n```\n\n# 问题\n\n该公司使用抽象工厂模式设计了界面皮肤库，该皮肤库可以较为方便地增加新的皮肤，但是现在遇到一个非常严重的问题：由于设计时考虑不全面，忘记为单选按钮(RadioButton)提供不同皮肤的风格化显示，导致无论选择哪种皮肤，单选按钮都显得那么“格格不入”。该公司的设计人员决定向系统中增加单选按钮，但是发现原有系统居然不能够在符合“开闭原则”的前提下增加新的组件，原因是抽象工厂SkinFactory中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先需要修改抽象工厂接口SkinFactory，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。\n\n怎么办？答案是抽象工厂模式无法解决该问题，这也是抽象工厂模式最大的缺点。在抽象工厂模式中，**增加新的产品族很方便，但是增加新的产品等级结构很麻烦**。\n\n抽象工厂模式的这种性质称为**“开闭原则”的倾斜性**。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：\n\n* 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。\n* 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。\n\n正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，**因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改**，为后续维护工作带来诸多麻烦。\n\n# 总结\n\n抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。\n\n* 优点\n  * 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。\n  * 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。\n  * 对于增加新的产品族——很方便，无须修改已有系统，符合“开闭原则”。\n* 缺点\n  * 对于增加新的产品等级结构——很麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。\n* 适用场景\n  * 一个系统**不应当依赖于产品类实例如何被创建、组合和表达的细节**，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，**将对象的创建和使用解耦**。\n  * 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以**很方便地增加新的产品族**。\n  * 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。**同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束**，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。\n  * 产品等级结构要求保持稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。\n\n# 参考文献\n\n```\n[1] 刘伟. 设计模式.\n```\n","categories":["设计模式","创建型模式"]},{"title":"读muduo有感_线程安全的对象生命期管理","url":"/多线程/读muduo有感_线程安全的对象生命期管理/","content":"# 内容\n\n1. 线程安全的定义\n2. 对象的创建\n3. 对象的销毁\n4. 线程安全的Observer\n5. 解决方案\n6. 陷阱\n# 线程安全的定义\n\n依据`[JCP]`，一个线程安全的class应当满足以下三个条件：\n\n* 多个线程同时访问时，其表现出正确的行为。\n* 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。\n* 调用端代码无须额外的同步或其他协调动作。\n\n依据这个定义，C++标准库里的大多数class都不是线程安全的，包括`std::string`、`std::vector`、`std::map`等。这些class通常需要在外部加锁才能供多个线程同时访问。\n\n## 以Counter为例说明问题\n\n```cpp\nclass Counter : boost::nocopyable\n{\npublic:\n    Counter() : value_(0)\n    {}\n    int64_t value() const;\n    int64_t getAndIncrease();\nprivate:\n    int64_t value_;\n    mutable MutexLock mutex_;\n    \n};\nint64_t Counter::value() const\n{\n    MutexLockGuard lock(mutex_);\n    int64_t ret = value_++;\n    return ret;\n}\n```\n\n这个class很直白，一看就明白，也容易验证它是线程安全的。每个Counter对象有自己的`mutex_`，因此不同对象之间不构成**锁争用(lock contention)**。如果是同一个Counter对象则不可同时访问`value_++`。\n\n注意到，其`mutex_`成员是`mutable`的，意味着`const`成员函数如`Counter::value()`也能直接使用`non-const`的`mutex_`。\n\n尽管这个`Counter`毫无疑问是线程安全的，但是如果`Counter`是动态创建的，并通过指针来访问，则对象销毁的**竞态条件(race condition)**仍然存在。\n\n### 当析构函数遇到多线程\n\n与其他面向对象语言不同，Cpp要求程序员自己管理对象的生命期，这在多线程环境下显得尤为困难。\n\n**当一个对象能被多个线程同时看到时，那么对象的销毁时机就变得模糊不清，可能出现多种竞态条件**。\n\n* 在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？\n* 如何保证在执行成员函数期间，对象不会在另一个线程被析构？\n* 在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？\n\n这些竞态条件问题是C++多线程编程面临的基本问题。\n\n# 对象的创建\n\n对象构造要做到线程安全，唯一的要求是在构造期间不要给其他对象泄露this指针（其自身创建的子对象除外）。即：\n\n* 不要在构造函数中注册任何回调；\n* 不要在构造函数中把this传给跨线程的对象；\n* 即便在构造函数的最后一行也不行。\n\n之所以这样规定，是因为在构造函数执行期间，对象还没有完成初始化工作，如果这时this泄露给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。\n\n```cpp\n#include <algorithm>\n#include <vector>\n#include <stdio.h>\n\nclass Observable;\n\nclass Observer\n{\n public:\n  virtual ~Observer();\n  virtual void update() = 0;\n\n  void observe(Observable* s);\n\n protected:\n  Observable* subject_;\n};\n\nclass Observable\n{\n public:\n  void register_(Observer* x);\n  void unregister(Observer* x);\n\n  void notifyObservers()\n  {\n    for (size_t i = 0; i < observers_.size(); ++i)\n    {\n      Observer* x = observers_[i];\n      if (x) {\n        x->update(); // (3)\n      }\n    }\n  }\n\n private:\n  std::vector<Observer*> observers_;\n};\n\nObserver::~Observer()\n{\n  subject_->unregister(this);\n}\n\nvoid Observer::observe(Observable* s)\n{\n  s->register_(this);\n  subject_ = s;\n}\n\nvoid Observable::register_(Observer* x)\n{\n  observers_.push_back(x);\n}\n\nvoid Observable::unregister(Observer* x)\n{\n  std::vector<Observer*>::iterator it = std::find(observers_.begin(), observers_.end(), x);\n  if (it != observers_.end())\n  {\n    std::swap(*it, observers_.back());\n    observers_.pop_back();\n  }\n}\n```\n\n```cpp\n/* 错误 */\nclass Foo : public Observer\n{\npublic:\n    Foo(Observer * s)\n    {\n        s->register_(this);\n    }\n    virtual void update();\n};\n```\n\n```cpp\n/* 正确 */\nclass Foo : public Observer\n{\npublic:\n    Foo();\n    virtual void update();\n    void observe(Observer * s)\n    {\n        s->register_(this);\n    }\n};\nFoo* pFoo = new Foo;\nObserver * s = getSubject();\npFoo->observer(s);\t//二段式构造，或者直接写s->register_(pFoo);\n```\n\n二段式构造——即构造函数+initialize()——有时会是好办法，这虽然不符合C++教条，但是多线程下别无选择。\n\n另外，既然允许二段式构造，那么构造函数不必主动抛异常，调用方靠initialize()的返回值来判断对象是否构造成功，这能简化错误处理。\n\n即使是构造函数的最后一行，也不要泄露this指针，因为Foo有可能是个基类，基类先于派生类构造，执行完`Foo::Foo()`的最后一行代码还会继续执行派生类的构造函数，这时`most-derived class`的对象还处于构造中，仍然不安全。\n\n# 对象的销毁\n\n对象的析构，在单线程里不构成问题，最多需要注意避免空悬指针和野指针。\n\n而在多线程程序中，存在了太多的竞态条件。对**一般成员函数**而言，做到线程安全的办法是让它们顺次执行，而不要并发执行（关键是不要同时读写共享状态），也就是让每个成员函数的临界区不重叠。这是显而易见的，不过有一个隐含条件或许不是每个人都能立刻想到：成员函数用来保护临界区的**互斥器本身必须是有效的。而析构函数破坏了这一假设，它会把mutex成员变量销毁掉**。悲剧啊！\n\n* mutex不是办法。\n\nmutex只能保证函数一个接一个地执行，考虑下面两个代码（并行），它试图用互斥锁来保护析构函数：\n\n![image-20220425141301184](../../images/读muduo有感_线程安全的对象生命期管理/image-20220425141301184.png)\n\n此时，有A、B两个线程都能看到Foo对象x，线程A即将销毁x，而线程B正准备调用`x->update()`。\n\n![image-20220425141415894](../../images/读muduo有感_线程安全的对象生命期管理/image-20220425141415894.png)\n\n尽管线程A在销毁对象之后把指针置为了`NULL`，尽管线程B在调用x的成员函数之前检查了指针x的值，但还是无法避免一种竞态条件：\n\n1. 线程A执行到了析构函数的`(1)`处，已经持有了互斥锁，即将继续往下执行。\n2. 线程B通过了`if(x)`检测，阻塞在`(2)`处。\n\n接下来会发生什么，只有天晓得。因为析构函数会把`mutex_`销毁，那么`(2)`处有可能永远阻塞下去，有可能进入“临界区”，然后`core dump`，或者发生其他更糟糕的情况。\n\n这个例子至少说明`delete`对象之后把指针置为`NULL`根本没用，如果一个程序要靠这个来防止二次释放，说明代码逻辑出了问题。\n\n* 作为数据成员的mutex不能保护析构\n\n前面的例子说明，作为class数据成员的`MutexLock`只能用于同步本class的其他数据成员的读和写，它不能保护安全地析构。因为`MutexLock`成员的生命期最多与对象一样长，而析构动作可说是发生在对象死亡之后（或者说死亡之时）。另外，对于基类对象，调用到基类析构函数的时候，派生类对象的那部分已经析构完毕了，那么基类对象拥有的`MutexLock`不能保护整个析构过程。\n\n其实，析构过程本来也不需要保护，因为只有别的线程都访问不到这个对象时，析构才是安全的，否则会有竞态条件发生。\n\n## 死锁\n\n如果要同时读写一个class的两个对象，有潜在的死锁可能。比方说有`swap()`这个函数。\n\n```cpp\nvoid swap(Counter & a, Counter & b)\n{\n    MutexLockGuard aLock(a.mutex_);\n    MutexLockGuard bLock(b.mutex_);\n    int64_t value = a.value_;\n    a.value_ = b.value_;\n    b.value_ = value;\n}\n```\n\n如果线程A执行`swap(a, b);`而同时线程B执行`swap(b, a);`，就有可能死锁。`operator=()`也是类似的道理。\n\n```cpp\nCounter& Counter::operator=(const Counter& rhs)\n{\n    if(this == &rhs)return *this;\n    MutexLockGuard myLock(mutex_);\n    MutexLockGuard itsLock(rhs.mutex_);\n    /* 不要写成 value_ = rhs.value()，会死锁； \n     * rhs.value() --> \n     *\t\tMutexLockGuard lock(mutex_);\n     *\t\tint64_t ret = value_++;\n     *\t\treturn ret;\n     */\n    value_ = rhs.value_;\n    return *this;\n}\n```\n\n一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较mutex对象的地址，始终先加锁地址较小的mutex。？？？\n\n# 线程安全的Observer\n\n一个动态创建的对象是否还活着，光看指针（或引用）看不出来。指针就是指向了一块内存，这块内存上的对象如果已经销毁，那么根本就不能访问（就像`free(3)`之后的地址不能访问一样），既然不能访问又如何知道对象的状态？换句话说，**没有高效的办法判断一个指针是否是合法指针，这是C/C++指针问题的根源**。（万一原址又创建了一个新的对象呢？再万一这个新的对象的类型异于老的对象呢？）\n\n## 对象之间关系的三种主要类型\n\n`composition`（组合/复合）、`aggregation`（聚合）、`association`（关联）。\n\n* 组合关系\n\n组合关系在多线程里不会遇到什么麻烦，因为对象x的生命期由其唯一的拥有者owner控制，owner析构的时候会把x也析构掉。从形式上看，x是owner的直接数据成员，或者`scoped_ptr/unique_ptr`成员，抑或owner持有的容器的元素。\n\n后两种关系在C++里比较难办，处理不好就会造成内存泄露或者重复释放。\n\n* 关联关系\n\n关联是一种很宽泛的关系，它表示一个对象a用到了另一个对象b，调用了后者的成员函数。从代码形式上看，**a持有b的指针或引用，但是b的生命期不由a单独控制**。\n\n* 聚合关系\n\n聚合关系从形式上看与关联关系相同，除了a和b有逻辑上的整体与部分的关系。如果b是动态创建的并在整个程序结束前有可能被释放，那么就会出现前文提到的竞态条件。\n\n## 如何避免访问失效对象\n\n似乎有一个简单的解决方法：只创建不销毁。程序使用一个对象池来暂存用过的对象，下次申请新对象时，如果对象池里有存货就拿一个利用，否则就新建一个；对象用完之后不是直接释放掉而是放回池子里。这个办法虽然有很多缺点，但是却能避免访问失效对象的情况发生。\n\n缺点和问题：\n\n* 对象池的线程安全，如何安全地、完整地把对象放回池子里，防止出现“部分放回”的竞态？（线程A任务对象x已经放回了，而线程B以为对象x还活着。）\n* 全局共享数据引发的lock contention，这个集中化的对象池可能会把多线程并发操作退化为串行。\n* 如果共享对象的类型不止一种，那么是重复实现对象池还是使用类模板呢？\n* 会不会造成内存泄漏与分片？因为对象池占用的内存只增不减，而且多个对象池不能共享内存。\n\n## Observer模式\n\n回到正题上来，如果对象x注册了任何非静态成员函数回调，那么必然在某处持有了指向x的指针，这就暴露在了竞态条件下。\n\n一个典型的场景是Observer模式。\n\n```cpp\n/* 观察者 */\nclass Observer //: boost::noncopyable\n{\npublic:\n    virtual ~Observer();\n    virtual void update() = 0;\n    /* ... */\n};\n/* 观察目标 */\nclass Observable //: boost::noncopyable\n{\npublic:\n    void register_(Observer * x);\t//因为和关键字冲突了，所以加个_\n    void unregister(Observer * x);\n    void notifyObservers()\n    {\n        for(Observer * x : observers_)\n        {\n            x->update();\n        }\n    }\nprivate:\n    std::vector<Observer*> observers_;\n}\n```\n\n当Observable通知每一个Observer时（`x->update();`），它从何得知Observer对象x还活着？要不试试在Observer的析构函数里调用`unregister()`来解注册？恐难奏效。\n\n```cpp\nclass Observer //: boost::noncopyable\n{\npublic:\n    // 同前\n    void observe(Observable * s)\n    {\n        s->register_(this);\n        subject_ = s;\n    }\n    virtual ~Observer()\n    {\n        subject_->unregister(this);\n    }\n    Observable* subject_;\n    /* ... */\n};\n```\n\n我们试着让Observer的析构函数去调用`unregister(this)`，这里有两个竞态条件。其一：`subject_->unregister(this)`中如何得知`subject_`还活着？其二：就算`subject_`指向某个永久存在的对象，那么还是险象环生：\n\n1. 线程A执行到`subject_->unregister(this)`之前，还没有来得及`unregister`本对象。\n2. 线程B执行到`x->update();`，x正好指向是`subject_->unregister(this)`正在析构的对象。\n\n这时悲剧又发生了，既然x所指的Observer对象正在析构，调用它的任何非静态成员函数都是不安全的，何况是虚函数（C++标准对在构造函数和析构函数中调用虚函数的行为有明确规定，但是没有考虑并发调用的情况。）。更糟糕的是，Observer是个基类，执行到`subject_->unregister(this)`时，派生类对象已经析构掉了，这时候整个对象处于将死未死的状态，`core dump`恐怕是最幸运的结果。\n\n这些竞态条件似乎可以通过加锁来解决，但在哪儿加锁？谁持有这些互斥锁？似乎不是那么显而易见。要是有一个活着的对象能帮帮我们就好了，这个对象需要提供一个`isAlive()`之类的程序函数，告诉我们某个对象还在不在。可惜指针和引用都不是对象，它们是内建类型。（这时候就要引出来智能指针了）\n\n## 不要使用原始指针\n\n指向对象的原始指针(raw pointer)是坏的，尤其当暴露给别的线程时。Observable应当保存的不是原始的`Observer*`，而是一个能够分辨Observer对象是否存活的东西。类似地，如果Observer要在析构函数里解注册（这虽然不能解决前面提到的竞态条件，但是在析构函数中打扫战场还是应该的），那么`subject_`的类型也不能是原始的`Observable*`（因为解注册用到了`Obervable`，它的`unregister`成员函数）。\n\n可以**使用引用计数型智能指针**，即`shared_ptr`。用一层间接性（二级指针）保证了避免释放空悬指针，也通过引用计数解决了释放对象期间的竞态条件问题。\n\n## 一个万能的解决方案\n\n引如另外一层间接性，用对象来管理共享资源，亦即`handle/body`惯用技法。用标准库中的一对“神兵利器”可助我们完美解决原始指针的问题。\n\n即`share_ptr`+`weak_ptr`。\n\n* `shared_ptr`控制对象的生命期。\n  * `shared_ptr`是强引用(想象成用铁丝绑住堆上的对象)，只要有一个指向x对象的`shared_ptr`存在，该x对象就不会析构。\n  * 当指向对象x的最后一个`shared_ptr`析构或`reset()`的时候，x保证会被销毁。\n* `weak_ptr`不控制对象的生命期，但是它知道对象是否还活着(想象成用棉线轻轻拴住堆上的对象)。\n  * 如果对象还活着,那么它可以提升为有效的`shared_ptr`；\n  * 如果对象已经死了，提升会失败，返回一个空的`shared_ptr`。提升`lock()`行为是线程安全的。\n* `shared_ptr`/`weak_ptr`的“计数”在主流平台上是原子操作，没有用锁，性能不俗。\n* `shared_ptr`/`weak_ptr`的线程安全级别与`std::string`和STL容器一样。\n\n孟岩在《垃圾收集机制批判》中一针见血地点出智能指针的优势：“C++利用智能指针达成的效果是：一旦某对象不再被引用，系统刻不容缓，立刻回收内存。这通常发生在关键任务完成后的清理时期，不会影响关键任务的实时性，同时，内存里所有的对象都是有用的，绝对没有垃圾空占内存。”\n\n# C++的内存问题很容易解决\n\nC++里可能出现的内存问题大致有这么几个方面：\n\n1. 缓冲区溢出(buffer overrun)\n2. 空悬指针/野指针\n3. 重复释放(double delete)\n4. 内存泄漏(memory leak)\n5. 不配对的`new[]/delete`\n6. 内存碎片(memory fragmentation)\n\n在这几种错误里边，内存泄漏的危害相对较小，因为它只是借了东西不还，程序功能在一段时间内还算正常；而其他如缓冲区溢出或重复释放等致命错误可能会造成安全性(security和data safety)方面的严重后果。\n\n正确使用智能指针能很轻易地解决前面5个问题。解决第6个问题——内存碎片需要别的思路。\n\n* 缓冲区溢出\n  * 用`std::vector<char>/std::string`或自己编写`Buffer class`来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。\n* 空悬指针/野指针\n  * 用`shared_ptr/weak_ptr`\n* 重复释放\n  * 用`scoped_ptr`，只在对象析构的时候释放一次。\n* 内存泄漏\n  * 用`scoped_ptr`，对象析构的时候自动释放内存。\n* 不配对的`new[]/delete`\n  * 把`new[]`统统替换为`std::vector/scoped_array`。\n\n注意：`scoped_ptr`、`shared_ptr`、`weak_ptr`都是值语义。要么是栈上对象，或是其他对象的直接数据成员，或是标准库容器里的元素，即不会出现下面这种形式：`shared_ptr<Foo>* pFoo = new shared_ptr<Foo>(new Foo);`\n\n现代的C++程序中一般不要出现delete语句，资源（包括复杂对象本身）都要通过对象（智能指针或容器）来管理，不要让程序员还要为此操心。\n\n# 应用到Observer上\n\nObserver模式的竞态条件的核心问题是被观察者如何探查观察者的生死，可以通过`weak_ptr`解决，只要让`Observable`保存`weak_ptr<Observer>`即可。\n\n```cpp\nclass Observable\n{\npublic:\n    void register_(weak_ptr<Observer x);\t//参数类型可用const weak_ptr<Observer>&\n    // void unregister(weak_ptr<Observer> x);\t//不需要了，已经有下边的代码帮我们解决把失效观察者从observers_中删除了。相应地，Observer的析构函数也不用调用Observable的unregister了。\n    void notifyObservers();\nprivate:\n    mutable MutexLock mutex_;\n    std::vector<weak_ptr<Observer>> observers_;\n    using Iterator = std::vector<weak_ptr<Observer>>::iterator;\n};\nvoid Observable::notifyObservers()\n{\n    MutexLockGuard lock(mutex_);\n    Iterator it = observers_.begin();\n    while(it != observers_.end())\n    {\n        shared_ptr<Observer> obj(it->lock());\t//weak_ptr的lock函数，尝试提升为shared_ptr，这一步是线程安全的。\n        if(obj)\n        {\n            obj->update();\t//没有竞态条件，因为obj在栈上，对象不可能在本作用域内销毁。\n            ++it;\n        }\n        else\n        {\n            // 观察者对象已经销毁，从容器中删除weak_ptr，即做了unregister的工作。\n            it = observers_.erase(it);\n        }\n    }\n}\n```\n\n经过把`Observer*`替换为`weak_ptr<Observer>`，部分解决了`Observer`模式的线程安全问题，但还有以下疑点。\n\n* 侵入性\n  * 强制要求`Observer`必须以`shared_ptr`来管理\n* 不是完全线程安全\n* 锁争用(lock contention)\n  * 即`Observable`的三个成员函数都用了互斥器来同步，这会造成`register_`\n","categories":["操作系统","多线程","Cpp","设计模式"]},{"title":"观察者模式","url":"/设计模式/观察者模式/","content":"\n# 内容\n\n1. 行为型模式\n2. 观察者模式\n\n* 行为型模式\n  * 关注系统中对象之间的相互交互，研究运行时对象之间的互相通信和协作，明确对象职责。\n\n# 观察者模式\n\n* 模式动机：建立一套低耦合的消息触发机制。\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时，将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，被通知的对象成为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。\n\n* 观察者模式概述\n\n观察者模式是使用频率最高的设计模式之一。\n\n建立对象间一对多的关联关系，并能使一个对象的变化被所有关联对象感知。\n\n* 定义\n\n观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括**发布-订阅(Publish/Subscribe)模式**、**模型-视图(Model/View)模式**、**源-监听器(Source/Listener）模式**或**从属者(Dependents)模式**。\n\n观察者模式是一种对象行为型模式。\n\n## 类之间的关系\n\n观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如图所示：\n\n![image-20220425091749152](../../images/观察者模式/image-20220425091749152.png)\n\n  在观察者模式结构图中包含如下几个角色：\n\n* **Subject（目标）**：**目标**又称为**主题**，它是指**被观察的对象**。\n  * 在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，如`attach(ObServer*)`，`detach(Observer*)`。\n  * 同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。\n* **ConcreteSubject（具体目标）**：具体目标是目标类的子类。如果无须扩展目标类，则具体目标类可以省略。\n  * 通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；\n  * 同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。\n* **Observer（观察者）**：观察者将对观察目标的改变做出反应，观察者一般定义为接口。\n  * 该接口声明了更新数据的方法update()，因此又称为抽象观察者。\n* **ConcreteObserver（具体观察者）**：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。\n  * 通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。\n\n## 代码示例\n\n* 观察目标\n\n下面通过示意代码来对该模式进行进一步分析。首先我们定义一个抽象目标Subject，典型代码如下所示：\n\n```java\nimport java.util.*;\nabstract class Subject\n{\n    //定义一个观察者集合用于存储所有观察者对象\n    protected ArrayList observers<Observer> = new ArrayList();\n    \n    //注册方法，用于向观察者集合中增加一个观察者\n\tpublic void attach(Observer observer)\n    {\n    \tobservers.add(observer);\n    }\n    //注销方法，用于在观察者集合中删除一个观察者\n\tpublic void detach(Observer observer)\n    {\n    \tobservers.remove(observer);\n    }\n    //声明抽象通知方法\n\tpublic abstract void notify();\n}\n```\n\n具体目标类ConcreteSubject是实现了抽象目标类Subject的一个具体子类，其典型代码如下所示：\n\n```java\nclass ConcreteSubject extends Subject\n{\n    //实现通知方法\n\tpublic void notify() \n    {\n        //遍历观察者集合，调用每一个观察者的响应方法\n\t\tfor(Object obs : observers) \n        {\n\t\t\t((Observer)obs).update();\n\t\t}\n\t}\t\n}\n```\n\n* 观察者\n\n抽象观察者角色一般定义为一个接口，通常只声明一个update()方法，为不同观察者的更新（响应）行为定义相同的接口，这个方法在其子类中实现，不同的观察者具有不同的响应方法。抽象观察者Observer典型代码如下所示。\n\n```java\ninterface Observer \n{\n    //声明响应方法\n\tpublic void update();\n}\n```\n\n在具体观察者ConcreteObserver中实现了update()方法，其典型代码如下所示：\n\n```java\nclass ConcreteObserver implements Observer \n{\n    //实现响应方法\n\tpublic void update() {\n\t\t//具体响应代码\n\t}\n}\n```\n\n在有些更加复杂的情况下，具体观察者类`ConcreteObserver`的`update()`方法在执行时需要使用到具体目标类`ConcreteSubject`中的状态（属性），**因此在`ConcreteObserver`与`ConcreteSubject`之间有时候还存在关联或依赖关系**，在`ConcreteObserver`中定义一个`ConcreteSubject`实例，通过该实例获取存储在`ConcreteSubject`中的状态。\n\n如果`ConcreteObserver`的`update()`方法不需要使用到`ConcreteSubject`中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者`ConcreteObserver`和具体目标`ConcreteSubject`之间无须维持对象引用。\n\n**如果在具体层具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码**，在一定程度上违反了“开闭原则”，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。\n\n## 代码练习\n\n```cpp\nusing namespace std;\nclass Subject;\nclass Observer\n{\nprotected:\n    string name;\n    Subject * sub;\npublic:\n    Observer(string na, Subject* s)\n        : name(na), sub(s)\n    {}\n    virtual ~Observer() {}\npublic:\n    virtual void update() = 0;\n    \n};\nclass StockObserver : public Observer\n{\npublic:\n    StockObserver(string ns, Subject* sub)\n        : Observer(na, sub)\n    {}\n\tvoid update()\n    {\n        cout << name << \" 收到消息: \" << sub->event << endl;\n        if(sub->event == \"Boss来了!\")\n        {\n            cout << \"马上关闭炒股软件，装作很认真工作的样子！\" << endl;\n        }\n    }\n};\nclass GameObserver : public Observer\n{\npublic:\n    GameObserver(string ns, Subject* sub)\n        : Observer(na, sub)\n    {}\n\tvoid update()\n    {\n        cout << name << \" 收到消息: \" << sub->event << endl;\n        if(sub->event == \"Boss来了!\")\n        {\n            cout << \"马上关闭游戏，装作很认真工作的样子！\" << endl;\n        }\n    }\n};\n/* 通知者 */\nclass Subject\n{\nprotected:\n    list<Observer*> observers;\t//list<std::shared_ptr<Observer>> objservers;\npublic:\n    string event;\t// 事件\n    virtual void attach(Observer*) = 0;\n    virtual void detach(Observer*) = 0;\n    virtual void notify() = 0;\n};\n/* 秘书 */\nclass Secretary : public Subject\n{\npublic:\n    void attach(Observer* obs)\n    {\n        observers.push_back(obs);\n    }\n    void detach(Observer* obs)\n    {\n        observers.remove(obs);\n    }\n    void notify()\n    {\n        for(auto & x : observers)\n        {\n            x->update();\n        }\n    }\n};\nint main()\n{\n    Subject * dwq = new Secretary();\t//\n    Observer * xiaoshuai = new GameObserver(\"小帅\", dwq);\n    Observer * liming = new GameObserver(\"李明\", dwq);\n    Observer * wangfang = new StockObserver(\"王芳\", dwq);\n    dwq->attach(xiaoshuai);\n    dwq->attach(liming);\n    dwq->attach(wangfang);\n    \n    dwq->event = \"去吃饭了!\";\n    dwq->notify();\n    cout << endl;\n    \n    dwq->event = \"老板来了!\";\n    dwq->notify();\n    cout << endl;\n    return 0;\n}\n```\n\n# 观察者模式与MVC\n\n在当前流行的MVC(Model-View-Controller)架构中也应用了观察者模式，MVC是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。\n\n其中**模型可对应于观察者模式中的观察目标**，而**视图对应于观察者**，控制器可充当两者之间的中介者。当**模型层的数据发生改变时，视图层将自动改变其显示内容**。\n\n**模型层提供的数据是视图层所观察的对象**，在视图层中包含两个用于显示数据的图表对象，一个是柱状图，一个是饼状图，相同的数据拥有不同的图表显示方式，如果模型层的数据发生改变，两个图表对象将随之发生变化，这意味着图表对象依赖模型层提供的数据对象，因此数据对象的任何状态改变都应立即通知它们。同时，这两个图表之间相互独立，不存在任何联系，而且图表对象的个数没有任何限制，用户可以根据需要再增加新的图表对象，如折线图。在增加新的图表对象时，无须修改原有类库，满足“开闭原则”。\n\n# 适用场景\n\n在以下情况下可以考虑使用观察者模式：\n\n1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。\n2. 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。\n3. 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。\n","categories":["设计模式","行为型模式"]},{"title":"笔试记录","url":"/算法/笔试记录/","content":"\n# 20220416网易笔试\n\n* 输入n，打印大小为n的\"o\"\n\n```\nn==1时\n.**.\n*..*\n*..*\n.**,\nn==2时\n..****..\n.**..**.\n.**..**.\n\n```\n\n","categories":["算法","刷题"]},{"title":"集群服务器","url":"/项目/集群服务器架构/","content":"# 内容\n\n1. 项目需求及目标\n2. 开发环境\n3. `Json`介绍\n4. `muduo`网络库编程\n5. 服务器集群\n6. 基于`发布-订阅`的`Redis`——服务器中间件\n7. 数据库设计\n\n本项目要用到的技术栈：\n\n1. `Json`序列化和反序列化；\n2. `muduo`网络库开发；\n3. `nginx`源码编译安装和环境部署；\n4. `nginx`的`tcp`负载均衡器配置；\n5. `redis`缓存服务器编程实践；\n6. 基于`发布-订阅`的服务器中间件`redis`消息队列编程实践；\n7. `MySQL`数据库编程；\n8. `CMake`构建编译环境；\n9. `Github`托管项目\n\n本项目的内容包含了：通常开发的服务器，网络、业务、数据模块（数据库、数据的操作），\n项目中要把三大模块区分开，项目初期时以登录模块为主线，分三大块推进。\n\n# 项目需求及目标\n* 项目需求\n    1. 客户端新用户注册\n    2. 客户端用户登录\n    3. 添加好友和添加群组\n    4. 好友聊天和群组聊天\n    5. `nginx`配置`tcp`负载均衡\n    6. 集群聊天系统支持客户端跨服务器通信\n* 项目目标\n    1. 掌握服务器的网络`I/O`模块，业务模块，数据模块分层的设计思想\n    2. 掌握`C++` `muduo`网络库的编程以及实现原理\n    3. 掌握`Json`的编程应用\n    4. 掌握`nginx`配置部署`tcp`负载均衡器的原理及应用\n    5. 掌握服务器中间件的应用场景和基于`发布-订阅`的`redis`编程实践以及应用原理\n    6. 掌握`CMake`构建自动化编程环境\n# 开发环境\nmuduo库基于boost库，需要先安装boost。\n```sh\ntar -zxvf boost_1_69_0.tar.gz\ncd boost_1_69_0/\n./bootstrap.sh #运行bootstrap.sh工程编译构建程序\n./b2 #源码根目录下生成了b2程序，运行b2程序\n#编译完成后，会有如下打印: The Boost C++ Libraries were successfully built!\nsudo ./b2 install #把上面的boost库头文件和lib库文件安装在默认的Linux系统头文件和库文件的搜索路径下\n```\n## 工程目录\n\n```\ninclude目录是头文件放的位置。\n\nserver和client的代码在同一工程中，最后生成时可以把C/S分开生成到bin目录下。\n可按server和client分类，\n比如生成代码所需用到的头文件可以分别放在/include/server和/include/client，\n而server和client共需的头文件直接放到/include下。比如消息的id。\n\nsrc放源码。\n\nthirdparty是第三方库文件夹，比如放json.hpp。\n\n本项目没有生成lib库(.a/.so)，所以没有lib文件夹。\n```\n# CMakeLists.txt编写\n## 根目录\n```cmake\ncmake_minimum_required(VERSION 3.0.0)\nproject(chat)\n# 配置编译选项\nset(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} -g)\n# 配置最终的可执行文件输出的路径\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)\n# 配置头文件的搜索路径\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\ninclude_directories(${PROJECT_SOURCE_DIR}/include/server)\n# 加载子目录\nadd_subdirectory(src)\n```\n## `/src`\n```cmake\nadd_subdirectory(server)\n```\n## `/src/server`\n```cmake\n# 定义了一个SRC_LIST变量，包含了该目录下所有的源文件\naux_source_directory(. SRC_LIST)\n# 指定生成可执行文件\nadd_executable(ChatServer ${SRC_LIST})\n# 指定可执行文件链接时 需要依赖的库文件\ntarget_link_libraries(CharServer muduo_net muduo_base pthread)\n```\n# JSON介绍\nJSON，全拼：JavaScript Object Notation\n\nJSON是一种轻量级的数据交换格式（也叫数据序列化方式）。\n\nJSON采用完全**独立于编程语言**的文本格式来存储和表示数据。\n\n简洁和清晰的层次结构使得JSON成为理想的数据交换语言。\n\n易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\nJSON的用处就是下图：\n![image-20220413164124873](../../images/集群服务器/image-20220413164124873.png)\n\n## JSON第三方库\n本项目选用的是`JSON for Modern C++`，由德国人`nlohmann`编写的在`C++`下使用的`JSON`库。特点如下：\n1. 整个代码由一个头文件`json.hpp`包含，没有依赖关系，使用方便；\n2. 使用C++11标准编写；\n3. 使得JSON像STL容器一样，而且STL和JSON容器之间可以相互转换；\n4. 所有类都经过严格的单元测试，覆盖100％的代码，包括所有特殊的行为。此外，还检查了Valgrind是否有内存泄漏。为了保持高质量，该项目遵循“核心基础设施”倡议的最佳实践。\n## 测试JSON\n```cpp\n#include\"json.hpp\"\nusing json = nlohmann::json;\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n/* json序列化 示例1 */\nvoid func1()\n{\n    json js;\n    js[\"msg_type\"] = 2;\n    js[\"from\"] = \"zhang san\";\n    js[\"to\"] = \"li si\";\n    js[\"msg\"] = \"hello, i'm zhang san\";\n    cout << js << endl;\n}\nint main()\n{\n    func1();\n    return 0;\n}\n\n```\n输出结果\n```\n{\"from\":\"zhang san\",\"msg\":\"hello, i'm zhang san\",\"msg_type\":2,\"to\":\"li si\"}\n```\n### 能直接添加二维key - value\n```cpp\n/* JSON 序列化 实例2 */\nvoid func2()\n{\n\tjson js;\n    js[\"id\"] = {1, 2, 3, 4, 5};\n    js[\"name\"] = \"zhang san\";\n    js[\"msg\"][\"zhang san\"] = \"i'm zhang san\";\n    js[\"msg\"][\"li si\"] = \"i'm li si\";\n    /* 上面两句等同于下面这句一次性添加数组对象 */\n/*  js[\"msg\"] = {{\"zhang san\", \"i'm zhang san\"}, {\"li si\", \"i'm li si\"}}; */\n\tcout << js << endl;\n}\nint main()\n{\n    func2();\n    return 0;\n}\n\n\n```\n输出结果\n```\n{\"id\":[1,2,3,4,5],\"msg\":{\"li si\":\"i'm li si\",\"zhang san\":\"i'm zhang san\"},\"name\":\"zhang san\"}\n```\n### STL容器内容导入JSON\n这个JSON库强大到直接把`C++` `STL`中的容器内容可以直接序列化成Json字符串，代码如下：\n\n```cpp\n/* json序列化 实例3 */\nvoid func3()\n{\n    json js;\n    vector<int> vec;\n    vec.push_back(1);\n    vec.push_back(2);\n    vec.push_back(5);\n    // 直接序列化一个vector容器\n    js[\"list\"] = vec;\n    map<int, string> m;\n    m.insert({1, \"黄山\"});\n    m.insert({2, \"华山\"});\n    m.insert({3, \"泰山\"});\n    // 直接序列化一个map容器\n    js[\"path\"] = m;\n    cout << js << endl;\n}\n```\n输出结果\n```\n{\"list\":[1,2,5],\"path\":[[1,\"黄山\"],[2,\"华山\"],[3,\"泰山\"]]}\n```\n## API\n### dump（序列化）\n生成的字符串内容和`<< json`的一样。返回一个string对象。\n\n`cout <<`能输出 JSON 对象是因为重载了`<<`运算符；而要实际生成`string`可用`dump()`，生成的字符串内容和`<< json`的一样。传输数据时，不要传`string`对象，而是要传`string`实际指向的字符串首指针，`c_str()`。\n\n```cpp\nvoid func1()\n{\n    json js;\n    js[\"msg_type\"] = 2;\n    js[\"from\"] = \"zhang san\";\n    js[\"to\"] = \"li si\";\n    js[\"msg\"] = \"hello, i'm zhang san\";\n    string sendBuf = js.dump();\n    cout << sendBuf.c_str() << endl;\n}\n```\n### parse（反序列化为JSON对象，可以赋值给STL容器）\n解析string类型的字符串，生成一个JSON对象。可以转换为容器。\n```cpp\nvoid func1()\n{\n    json js;\n    js[\"msg_type\"] = 2;\n    js[\"from\"] = \"zhang san\";\n    js[\"to\"] = \"li si\";\n    js[\"msg\"] = \"hello, i'm zhang san\";\n    cout << js << endl;\n}\nint main()\n{\n    string recvBuf = func1();\n    json json_obj = json::parse(recvBuf);\n    cout << json_obj[\"msg_type\"] << endl;\n    cout << json_obj[\"from\"] << endl;\n    cout << json_obj[\"to\"] << endl;\n    cout << json_obj[\"msg\"] << endl;\n}\n```\n输出结果：\n```\n2\n\"zhang san\"\n\"li si\"\n\"hello, what are you doing now?\"\n```\n\n```cpp\nvoid func2()\n{\n\tjson js;\n    js[\"id\"] = {1, 2, 3, 4, 5};\n}\nint main()\n{\n    string recvBuf = func2();\n    json json_obj = json::parse(recvBuf);\n    auto arr = json_obj[\"id\"];\n    cout << json_obj[\"id\"] << endl;\n    cout << arr[2] << endl;\n}\n```\n输出结果\n```\n[1,2,3,4,5]\n3\n```\n\n```cpp\nvoid func3()\n{\n    json js;\n    vector<int> vec;\n    vec.push_back(1);\n    vec.push_back(2);\n    vec.push_back(5);\n    // 直接序列化一个vector容器\n    js[\"list\"] = vec;\n    map<int, string> m;\n    m.insert({1, \"黄山\"});\n    m.insert({2, \"华山\"});\n    m.insert({3, \"泰山\"});\n    // 直接序列化一个map容器\n    js[\"path\"] = m;\n    cout << js << endl;\n}\nint main()\n{\n    vector<int> vec = json_obj[\"list\"];\n    for (int & v : vec)\n    {\n        cout << v << \" \";\n    }\n    cout << endl;\n\n    map<int, string> mymap = json_obj[\"path\"];\n    for (auto & p : mymap)\n    {\n        cout << p.first << \" \" << p.second << endl;\n    }\n    cout << endl;\n}\n```\n输出结果\n```\n1 2 5 \n1 黄山\n2 华山\n3 泰山\n```\n# 网络IO模块\n## main入口（⭐需要处理服务器程序异常退出，如SIGINT信号）\n诸如被kill、或者Ctrl + C终止服务器主程序时，需要处理信号，绑定回调`void resetHandler(int)`\n在ChatService中，调用reset函数。\n\n```cpp\n#include\"chatserver.hpp\"\n#include<iostream>\nusing namespace std;\n\n#include<signal.h>\n#include\"chatservice.hpp\"\n#include<muduo/base/Logging.h>  // LOG_ERROR <<\nusing namespace muduo;\n\n/* 处理服务器Ctrl+C结束后，重置user状态信息 */\nvoid resetHandler(int)\n{\n    ChatService::instance()->reset();\n    LOG_INFO << \"服务器因SIGINT信号退出，用户状态已重置。\";\n    exit(0);\n}\nint main()\n{\n    signal(SIGINT, resetHandler);\n    EventLoop loop;\n    InetAddress addr(\"127.0.0.1\", 6000);\n    ChatServer server(&loop, addr, \"ChatServer\");\n    ChatService::instance()->reset();\n    server.start();\n    loop.loop();    //开启事件循环\n    return 0;\n}\n```\nChatService中的`reset()`函数，就是调用`_userModel`的`resetAllState()`方法。\n```cpp\n/* 业务重置方法，通常在服务器异常退出时调用 */\nvoid ChatService::reset()\n{\n    /* 把所有online用户的状态置为offline */\n    _userModel.resetAllState();\n}\n```\n即重置所有用户的状态信息，把所有 online 的改成 offline 。\n```cpp\n/* 重置所有用户的状态信息 */\nvoid UserModel::resetAllState()\n{\n    char sql[1024] = \"update user set state = 'offline' where state = 'online'\";\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        mysql.update(sql);\n    }\n}\n```\n\n## ChatServer\n\n### 成员属性\n\n1. `TcpServer m_server` - **基于事件驱动的、IO复用+epoll+线程池**的服务器类，完全**基于Reactor模型**\n2. `EventLoop *m_loop` - mainLoop的指针, 保存事件循环. 有了事件循环的指针，可以在合适的时候调用quit退出事件循环；\n\n```cpp\nprivate:\n    /* 组合的muduo库，实现服务器功能的类对象 */\n    TcpServer _server;\n    /* 指向事件循环对象的指针 */\n    EventLoop *_loop;\n```\n\n### 成员函数\n\n#### 构造\n参数为`loop`指针, `listenAddr`, `name`, 用于初始化TcpServer\n```cpp\npublic:\n/* 初始化聊天服务器对象 */\nChatServer(EventLoop* loop,\n           const InetAddress& listenAddr,\n           const string& nameArg);\n```\n#### `start()`\n```cpp\npublic:\n    void start();\n```\n\n#### `onConnection`/`onMessage`\n连接创建/断开的回调函数\n\n读写事件发生的回调函数\n   \n```cpp\nprivate:\n   /* 上报链接相关信息的回调函数（连接创建，连接断开）*/\n   void onConnection(const TcpConnectionPtr&);\n   /* 上报读写事件相关信息的回调函数 */\n   void onMessage(const TcpConnectionPtr&, Buffer*, Timestamp);\n```\n### 头文件\n\n```cpp\n#ifndef CHATSERVER_H\n#define CHATSERVER_H\n#include <muduo/net/TcpServer.h>\n#include <muduo/net/EventLoop.h>\nusing namespace muduo;\nusing namespace muduo::net;\n/**\n * 聊天服务器的主类;\n *\n * 要注册两个方法:\n * 给TcpServer注册新用户的连接、连接断开的、已连接用户的可读写事件;\n */\nclass ChatServer\n{\npublic:\n    /* 初始化聊天服务器对象 */\n    ChatServer(EventLoop* loop,\n               const InetAddress& listenAddr,\n               const string& nameArg);\npublic:\n    /* 启动服务 */\n    void start();\n\nprivate:\n    /* 上报链接相关信息的回调函数（连接创建，连接断开）*/\n    void onConnection(const TcpConnectionPtr&);\n    /* 上报读写事件相关信息的回调函数 */\n    void onMessage(const TcpConnectionPtr&, Buffer*, Timestamp);\n\n\nprivate:\n    /* 组合的muduo库，实现服务器功能的类对象 */\n    TcpServer _server;\n    /* 指向事件循环对象的指针 */\n    EventLoop *_loop;\n};\n#endif\n```\n## Reactor模型\n\n本项目基于muduo库，模型是**基于事件驱动的、IO复用+epoll+线程池**的网络，完全**基于Reactor模型**，线程暂时设置为 4 个，有一个主Reactor是 IO 线程，主要负责新用户的连接，3个 sub-Reactor 是工作线程，主要负责已连接用户的读写事件的处理。\n## （⭐）客户端异常退出的业务代码解决\n需要知道，如果客户端异常断网的话，是不会发送TCP报文的，更不会发送JSON信息。\n但是好在muduo网络库为我们封装了处理客户端异常断网的逻辑，我们只需要在onConnection回调里处理客户端断开的逻辑就好了。\n既然客户端断开了，需要在Service层面记录用户退出。\n\n```cpp\nvoid ChatServer::onConnection(const TcpConnectionPtr& conn)\n{\n    if (!conn->connected())\n    {\n        ChatService::instance()->cloentCloseException(conn);\n        conn->shutdown();\n    }\n}\n```\n\n```cpp\nvoid ChatService::clientCloseException(const TcpConnectionPtr &conn)\n{\n    User user;\n    {\n        lock_guard<mutex> lock(_connMutex);\n        // 从 map 表中找到该 conn 的用户，删除连接信息\n        for (auto it = _userConnMap.begin(); it != _userConnMap.end(); ++it)\n        {\n            if (it->second == conn)\n            {\n                user.setId(it->first);\n                _userConnMap.erase(it);\n                break;\n            }\n        }\n    }\n    // 更新用户的状态信息\n    if (user.getId() != -1)\n    {\n        user.setState(\"offline\");\n        _userModel.updateState(user);\n    }\n}\n```\n# 数据库设计\nUser表\n\n| 字段名称     | 字段类型                      | 字段说明   | 约束                         |\n| -------- | ------------------------- | ------ | -------------------------- |\n| id       | INT                       | 用户id   | PRIMARY KEY、AUTO_INCREMENT |\n| name     | VARCHAR(50)               | 用户名    | NOT NULL                   |\n| password | VARCHAR(50)               | 用户密码   | NOT NULL                   |\n| state    | ENUM('online', 'offline') | 当前登录状态 | DEFAULT 'offline'          |\nFriend表\n\n| 字段名称     | 字段类型 | 字段说明 | 约束            |\n| -------- | ---- | ---- | ------------- |\n| userid   | INT  | 用户id | NOT NULL、联合主键 |\n| friendid | INT  | 好友id | NOT NULL、联合主键 |\nAllGroup表\n\n| 字段名称      | 字段类型         | 字段说明 | 约束                         |\n| --------- | ------------ | ---- | -------------------------- |\n| id        | INT          | 群组id | PRIMARY KEY、AUTO_INCREMENT |\n| groupname | VARCHAR(50)  | 群组名称 | NOT NULL                   |\n| groupdesc | VARCHAR(200) | 群组描述 | DEFAULT ''                 |\n\nGroupUser表\n\n| 字段名称      | 字段类型                      | 字段说明   | 约束               |\n| --------- | ------------------------- | ------ | ---------------- |\n| groupid   | INT                       | 群组id   | PRIMARY KEY      |\n| userid    | INT                       | 群组成员id | NOT NULL         |\n| grouprole | ENUM('creator', 'normal') | 群组身份   | DEFAULT 'normal' |\nOfflineMessage表\n\n| 字段名称    | 字段类型         | 字段说明          | 约束          |\n| ------- | ------------ | ------------- | ----------- |\n| userid  | INT          | 用户id          | PRIMARY KEY |\n| message | VARCHAR(500) | 离线消息（JSON字符串） | NOT NULL    |\n# 业务模块\n\n## （⭐）业务模块与网络模块解耦 - 回调\n\n考虑问题：\n网络模块收到的消息如何派发到业务模块？\n\n让网络模块的代码和业务模块的代码解耦。\n\n假设有一个用户在做登录业务，登录业务包含`messageID`，`name`，`password`，要验证用户名密码是否正确。\n\n解耦的方案有两种：\n1. 使用基于面向接口的编程。（抽象基类）\n2. **基于回调函数**的操作。\n## 业务类型\n1. 登录 - `LOGIN_MSG/ACK`\n2. 注册 - `REG_MSG/ACK`\n3. 加好友 - `ADD_FRIEND_MSG`\n4. 一对一聊天 - `ONE_CHAT_MSG`\n5. 创建群组 - `CREATE_GROUP_MSG`\n6. 加入群组 - `ADD_GROUP_MSG`\n7. 群聊 - `GROUP_CHAT_MSG`\n\n```cpp\n#ifndef PUBLIC_H\n#define PUBLIC_H\n/* server和client的公共文件 */\n\nenum EnMsgType  //En表示Enum枚举\n{\n    LOGIN_MSG = 1,      //登录 消息id, 与chatservice中的login方法绑定\n    LOGIN_MSG_ACK,      //登录响应\n\n    REG_MSG,            //注册 消息id, 与chatservice中的reg方法绑定\n    REG_MSG_ACK,        //注册响应\n\n    ADD_FRIEND_MSG,     //添加好友\n    ONE_CHAT_MSG,       //一对一聊天\n\n    CREATE_GROUP_MSG,   //创建群组\n    ADD_GROUP_MSG,      //加入群组\n    GROUP_CHAT_MSG      //群聊\n};\n\nenum EnLoginErrType\n{\n    LOGIN_SUCCEESS = 0,\n    LOGIN_REPEAT = 1,\n    LOGIN_NOTFOUND = 2,\n    LOGIN_WRONGPWD = 3\n};\n#endif\n```\n### 业务消息对应的JSON格式\n\n| 业务类型         | JSON示例                                                     |\n| ---------------- | ------------------------------------------------------------ |\n| 登录请求消息     | `\"msgid\":1,\"id\":22,\"password\":\"123\"`                         |\n| 登录响应消息     | `\"msgid\":2,\"errno\":0,\"id\":22,\"name\":\"xcg\"`或`\"msgid\":2,\"errno\":1,\"errmsg\":\"this account is online!\"`或`\"msgid\":2,\"errno\":2,\"errmsg\":\"id not found!\"`或`\"msgid\":2,\"errno\":3,\"errmsg\":\"password wrong!\"` |\n| 注册请求消息     | `\"msgid\":3,\"name\":\"xcg\",\"password\":\"123\"`                    |\n| 注册响应消息     | `\"msgid\":4,\"errno\":0,\"id\":22`或`\"msgid\":4,\"errno\":1`         |\n| 加好友请求消息   | `\"msgid\":5,\"friendid\":12`                                    |\n| 一对一聊天消息   | `\"msgid\":6,\"to\":12,\"msg\":\"hello!\"`                           |\n| 创建群组请求消息 | `\"msgid\":7,\"groupname\":\"group1\",\"groupdesc\":\"this is a group.\"` |\n| 加入群组请求消息 | `\"msgid\":8,\"id\":22,\"groupid\":10`                             |\n| 群聊请求消息     | `\"msgid\":9,\"id\":22,\"groupid\":10,\"msg\":\"hello, everyone!\"`    |\n| 注销请求消息     | `\"msgid\":10,\"id\":22`                                         |\n## ChatService\n\n### 前置处理\n\n```cpp\n#include\"json.hpp\"\nusing json = nlohmann::json;\n```\n\n```cpp\n/* 表示处理消息的事件回调方法类型 */\nusing MsgHandler = std::function<void(const TcpConnectionPtr&, json&, Timestamp)>;\n```\n\n### 成员属性\n#### `m_msgHandlerMap`\n是一个`unordered_map<int, MsgHandler> `\n\n映射消息类型id 和 事件回调函数\n\n在启动业务服务之前，里面的key value都提前添加好了，不用处理线程安全问题。\n\n```cpp\nprivate:\n   /* 存储消息id和其对应的业务处理方法 */\n   unordered_map<int, MsgHandler> m_msgHandlerMap;\n```\n\n#### `m_userConnectionMap`\n是一个`unordered_map<int, TcpConnectionPtr>`\n\n存储在线用户的通信连接状态。这是聊天服务器实现**长连接的基础**。\n\n需要处理线程安全问题。\n\n```cpp\nprivate:\n   /* 存储在线用户的通信连接 */\n   unordered_map<int, TcpConnectionPtr> m_userConnectionMap;\n```\n\n#### `mutex m_connMutex`\n定义互斥锁，保证`m_userConnectionMap`的线程安全\n\n```cpp\nprivate:\n   /* 定义互斥锁，保证m_userConnectionMap的线程安全 */\n   mutex _connMutex;\n```\n#### 数据操作类对象\n   1. UserModel - `m_userModel`\n   2. OfflineMsgModel - `m_offlineMsgModel`\n   3. FriendModel - `friendModel`\n   4. GroupModel - `groupModel`\n\n```cpp\nprivate:\n   UserModel       _userModel;         /* 数据操作类对象 */\n   OfflineMsgModel _offlineMsgModel;   /* 数据操作类对象 */\n   FriendModel     _friendModel;       /* 数据操作类对象 */\n   GroupModel      _groupModel;        /* 数据操作类对象 */\n```\n### 成员函数\n#### 构造函数（⭐单例）\n私有化, 单例处理\n```cpp\npublic:\n   static ChatService * instance();\nprivate:\n   ChatService();\n```\n#### 业务接口\n   1. login - 登陆业务\n   2. reg - 注册业务\n   3. addFriend - 添加好友业务\n   4. oneChat - 一对一聊天业务\n   5. createGroup - 创建群组业务\n   6. addGroup - 加入群组业务\n   7. groupChat - 群组聊天业务\n\n```cpp\npublic:\n   /* 处理登录业务 */\n   void login(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   /* 处理注册业务 */\n   void reg(const TcpConnectionPtr &conn, json &js, Timestamp time);\n\n   /* 添加好友业务 */\n   void addFriend(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   /* 一对一聊天业务 */\n   void oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n\n   /* 创建群组业务 */\n   void createGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   /* 加入群组业务 */\n   void addGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   /* 群组聊天业务 */\n   void groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n   ```\n#### getHandler\n获取消息对应的处理器\n```cpp\npublic:\n   /* 获取消息对应的处理器 */\n   MsgHandler getHandler(int msgid);\n```\n#### clientCloseException\n处理客户端异常退出\n```cpp\npublic:\n   /* 处理客户端异常退出 */\n   void clientCloseException(const TcpConnectionPtr & conn);\n```\n#### reset\n业务重置方法，通常在服务器异常退出时调用\n   ```cpp\n   public:\n       /* 业务重置方法，通常在服务器异常退出时调用 */\n       void reset();\n   ```\n### 头文件\n\n```cpp\n#ifndef CHATSERVICE_H\n#define CHATSERVICE_H\n#include<muduo/net/TcpConnection.h>\n#include<unordered_map>\n#include<functional>\n\n#include\"usermodel.hpp\"\n#include\"offlinemsgmodel.hpp\"\n#include\"friendmodel.hpp\"\n#include\"groupmodel.hpp\"\n\nusing namespace std;\nusing namespace muduo;\nusing namespace muduo::net;\n#include\"json.hpp\"\nusing json = nlohmann::json;\n\n#include<mutex>\n\n/* 表示处理消息的事件回调方法类型 */\nusing MsgHandler = std::function<void(const TcpConnectionPtr&, json&, Timestamp)>;\n/**\n * 聊天服务器业务类. \n * 用映射关系来存储消息id和具体处理函数. \n * 此类有一个实例就够了，所以采用单例模式. \n */\nclass ChatService\n{\npublic:\n    /* 获取单例对象的接口函数 */\n    static ChatService* instance();\npublic:\n    /* 处理登录业务 */\n    void login(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 处理注册业务 */\n    void reg(const TcpConnectionPtr &conn, json &js, Timestamp time);\n\n    /* 添加好友业务 */\n    void addFriend(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 一对一聊天业务 */\n    void oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\n\n    /* 创建群组业务 */\n    void createGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 加入群组业务 */\n    void addGroup(const TcpConnectionPtr &conn, json &js, Timestamp time);\n    /* 群组聊天业务 */\n    void groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time);\npublic:\n    /* 获取消息对应的处理器 */\n    MsgHandler getHandler(int msgid);\npublic:\n    /* 处理客户端异常退出 */\n    void clientCloseException(const TcpConnectionPtr & conn);\npublic:\n    /* 业务重置方法，通常在服务器异常退出时调用 */\n    void reset();\n\nprivate:\n    ChatService();\nprivate:\n    UserModel       _userModel;         /* 数据操作类对象 */\n    OfflineMsgModel _offlineMsgModel;   /* 数据操作类对象 */\n    FriendModel     _friendModel;       /* 数据操作类对象 */\n    GroupModel      _groupModel;        /* 数据操作类对象 */\nprivate:\n    /* 定义互斥锁，保证m_userConnectionMap的线程安全 */\n    mutex _connMutex;\nprivate:\n    /* 存储消息id和其对应的业务处理方法 */\n    unordered_map<int, MsgHandler> _msgHandlerMap;\n    /* 存储在线用户的通信连接 */\n    unordered_map<int, TcpConnectionPtr> _userConnectionMap;\n};\n#endif\n```\n## （⭐）登录业务需要处理的长连接问题、线程安全问题\n需要ChatService类中有一个记录用户的连接状态才行。\n因为聊天服务器需要保持一个给用户推送消息的状态。\n```cpp\nprivate:\n    unordered_map<int, TcpConnectionPtr> _userConnMap;\n    mutex _connMutex;\n```\n\n```cpp\n/* 处理登录业务 */\nvoid ChatService::login(const TcpConnectionPtr &conn,\n                        json &js, Timestamp time)\n{\n    /* 从json参数获取账号、密码信息 */\n    int id = js[\"id\"].get<int>();\n    string password = js[\"password\"];\n    User user = _userModel.query(id);\n\n    json response;\n    response[\"msgid\"] = LOGIN_MSG_ACK;\n    if(user.getId() == id && user.getPassword() == password)\n    {\n        if(user.getState() == \"online\")\n        {\n            /* 该用户已经登录在线，不允许重复登陆 */\n            response[\"errno\"] = LOGIN_REPEAT;\n            response[\"errmsg\"] = \"该用户已经登录\";\n        }\n        else if(user.getState() == \"offline\")\n        {\n            /* 登陆成功 */\n            {\n                /* 记录用户连接信息 */\n                lock_guard<mutex> lock(_connMutex);\n                _userConnectionMap.insert({id, conn});\n            }\n#ifdef __CLUSTER__\n            /**\n             * 集群环境下, 向redis订阅此id \n             */\n            m_redis.subscribe(id);\n#endif\n            /* 更新用户状态信息 */\n            user.setState(\"online\");\n            _userModel.updateState(user);\n\n            response[\"errno\"] = LOGIN_SUCCEESS;\n            response[\"id\"] = user.getId();\n            response[\"name\"] = user.getName();\n            /* 查询该用户是否在离线时未收到的消息 */\n            vector<string> offlineMsgVec = _offlineMsgModel.query(id);\n            if(!offlineMsgVec.empty())\n            {\n                response[\"offlinemsg\"] = offlineMsgVec;\n                /* 把该用户的所有离线消息从从数据中删除掉 */\n                _offlineMsgModel.remove(id);\n            }\n            /* 查询该用户的好友信息，并返回 */\n            vector<User> userVec = _friendModel.query(id);\n            if(!userVec.empty())\n            {\n                vector<string> friendJsonInfoVec;\n                for(User &user : userVec)\n                {\n                    json js;\n                    js[\"id\"] = user.getId();\n                    js[\"name\"] = user.getName();\n                    js[\"state\"] = user.getState();\n                    friendJsonInfoVec.push_back(js.dump());\n                }\n                response[\"friends\"] = friendJsonInfoVec;\n            }\n        }\n    }\n    else if(user.getId() != id)\n    {\n        /* 登录失败，用户不存在 */\n        response[\"errno\"] = LOGIN_NOTFOUND;\n        response[\"errmsg\"] = \"用户不存在\";\n    }\n    else if(user.getPassword() != password)\n    {\n        /* 登录失败，密码不匹配 */\n        response[\"errno\"] = LOGIN_WRONGPWD;\n        response[\"errmsg\"] = \"密码验证失败\";\n    }\n    conn->send(response.dump());\n}\n```\n## （⭐）离线消息的处理（包括集群环境下）\n用OfflineMessage数据表存储离线消息。\n当用户登陆时，ChatService去数据表查询是否有该用户id的离线消息。如果有，则推送。\n\n当处于集群环境时，某一台服务器中的`_userConnectionMap`只记录了在该服务器在线的用户，\n所以用户可能在本服务器offline，而在其他服务器上online，\n所以真实的在线状态应该去数据库的`User`表中查询（`_userModel.query(id); user.getState() == \"online\";`）\n如果真的是offline，则才存储离线消息。\n\n```cpp\n/* 一对一聊天业务 */\nvoid ChatService::oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time)\n{\n    int to = js[\"to\"].get<int>();\n    {\n        lock_guard<mutex> lock(_connMutex);\n        auto it = _userConnectionMap.find(to);\n        if(it != _userConnectionMap.end())\n        {\n            /* 接收方在线，转发消息 */\n            /* 服务器主动推送消息给接收方 */\n            it->second->send(js.dump());    // it->second 表示 \n            return;\n        }\n    }\n#ifdef __CLUSTER__\n    /**\n     * 集群环境下, 需要查询对方(to)是否在线;\n     * 不可通过服务器connMap查询, 是通过数据库信息;\n     */\n    User user = _userModel.query(to);\n    if(user.getState() == \"online\")\n    {\n        m_redis.publish(to, js.dump());\n        return;\n    }\n#endif\n    /* 接收方离线，存储离线消息 */\n    _offlineMsgModel.insert(to, js.dump());\n}\n```\n\n```cpp\n/* 群组聊天业务 */\nvoid ChatService::groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time)\n{\n    int userid = js[\"id\"].get<int>();\n    int groupid = js[\"groupid\"].get<int>();\n    vector<int> useridVec = _groupModel.queryGroupUsers(userid, groupid);\n\n    bool offline = true;\n    bool reallyOffline = true;\n    for(int id : useridVec)\n    {\n        {\n            lock_guard<mutex> lock(_connMutex);\n            auto it = _userConnectionMap.find(id);\n            if(it != _userConnectionMap.end())//在本台服务器上线\n            {\n                offline = false;\n                reallyOffline = false;\n                it->second->send(js.dump());\n            }\n        }\n#ifdef __CLUSTER__\n        if(offline)\n        {\n            /**\n             * 集群环境下, 需要判断其是否在其他服务器上在线;\n             */\n            User user = _userModel.query(id);\n            if(user.getState() == \"online\")\n            {\n                reallyOffline = false;\n                m_redis.publish(id, js.dump());\n            }\n        }\n#endif\n        if(reallyOffline)\n        {\n            _offlineMsgModel.insert(id, js.dump());\n        }\n        reallyOffline = true;\n        offline = true;\n    }\n}\n```\n\n```cpp\n/* 处理登录业务 */\nvoid ChatService::login(const TcpConnectionPtr &conn,\n                        json &js, Timestamp time)\n{\n    /* 从json参数获取账号、密码信息 */\n    int id = js[\"id\"].get<int>();\n    string password = js[\"password\"];\n    User user = _userModel.query(id);\n\n    json response;\n    response[\"msgid\"] = LOGIN_MSG_ACK;\n    if(user.getId() == id && user.getPassword() == password)\n    {\n        if(user.getState() == \"online\")\n        {\n            /* 该用户已经登录在线，不允许重复登陆 */\n            response[\"errno\"] = LOGIN_REPEAT;\n            response[\"errmsg\"] = \"该用户已经登录\";\n        }\n        else if(user.getState() == \"offline\")\n        {\n            /* 登陆成功 */\n            {\n                /* 记录用户连接信息 */\n                lock_guard<mutex> lock(_connMutex);\n                _userConnectionMap.insert({id, conn});\n            }\n#ifdef __CLUSTER__\n            /**\n             * 集群环境下, 向redis订阅此id \n             */\n            m_redis.subscribe(id);\n#endif\n            /* 更新用户状态信息 */\n            user.setState(\"online\");\n            _userModel.updateState(user);\n\n            response[\"errno\"] = LOGIN_SUCCEESS;\n            response[\"id\"] = user.getId();\n            response[\"name\"] = user.getName();\n            /* 查询该用户是否在离线时未收到的消息 */\n            vector<string> offlineMsgVec = _offlineMsgModel.query(id);\n            if(!offlineMsgVec.empty())\n            {\n                response[\"offlinemsg\"] = offlineMsgVec;\n                /* 把该用户的所有离线消息从从数据中删除掉 */\n                _offlineMsgModel.remove(id);\n            }\n            /* 查询该用户的好友信息，并返回 */\n            vector<User> userVec = _friendModel.query(id);\n            if(!userVec.empty())\n            {\n                vector<string> friendJsonInfoVec;\n                for(User &user : userVec)\n                {\n                    json js;\n                    js[\"id\"] = user.getId();\n                    js[\"name\"] = user.getName();\n                    js[\"state\"] = user.getState();\n                    friendJsonInfoVec.push_back(js.dump());\n                }\n                response[\"friends\"] = friendJsonInfoVec;\n            }\n        }\n    }\n    else if(user.getId() != id)\n    {\n        /* 登录失败，用户不存在 */\n        response[\"errno\"] = LOGIN_NOTFOUND;\n        response[\"errmsg\"] = \"用户不存在\";\n    }\n    else if(user.getPassword() != password)\n    {\n        /* 登录失败，密码不匹配 */\n        response[\"errno\"] = LOGIN_WRONGPWD;\n        response[\"errmsg\"] = \"密码验证失败\";\n    }\n    conn->send(response.dump());\n}\n```\n# 数据模块\n\n## （⭐）业务模块与数据模块解耦 - ORM框架\n\n> Object Relation Map - 对象关系映射。\n\n在这个框架中，业务层操作的都是对象，看不到具体的SQL操作。\n\n在DAO层（数据层），才有具体的数据库操作。\n\n解决了痛点：业务模块、数据模块之间的解耦。\n\n## 搭建MySQL数据库环境\n\n(以下命令基于Ubuntu环境)\n\n1. 安装mysql-server和mysql开发包, 包括mysql头文件和动态库文件\n\n```bash\nsudo apt-get install mysql-server\t\t#安装最新版MySQL服务器\nsudo apt-get install libmysqlclient-dev #安装开发包\n```\n\n2. 初始的用户名和密码是自动生成的，按下面步骤修改mysql的root用户密码为123456\n\n```bash\n~$ sudo cat /etc/mysql/debian.cnf\n\n[client]\nhost = localhost\nuser = debian-sys-maint \t\t\t#初始的用户名\npassword = Kk3TbShbFNvjvhpM\t\t\t#初始的密码\nsocket = /var/run/mysqld/mysqld.sock\n```\n\n```bash\n# 用上面初始的用户名和密码，登录mysql server，修改root用户的密码，命令如下：\n~$ mysql -u debian-sys-maint -pKk3TbShbFNvjvhpM\n#-u后面是上面查看的用户名; -p后面紧跟上面查看的密码\n```\n\n更改密码：参考 https://blog.csdn.net/mrcan666/article/details/124163537?spm=1001.2014.3001.5502\n\n3. 设置MySQL字符编码utf-8，以支持中文操作\n```mysql\nmysql> show variables like \"char%\"; # 先查看MySQL默认的字符编码\n+--------------------------+----------------------------+\n| Variable_name\t\t\t   | Value\t\t\t   \t\t\t|\n+--------------------------+----------------------------+\n| character_set_client     | utf8                       |\n| character_set_connection | utf8                       |\n| character_set_database   | latin1                     |\n| character_set_filesystem | binary                     |\n| character_set_results    | utf8                       |\n| character_set_server     | latin1                     |#不支持中文！！！\n| character_set_system     | utf8                       |\n| character_sets_dir       | /usr/share/mysql/charsets/ |\n+--------------------------+----------------------------+\n8 rows in set (0.06 sec)\n\nmysql> set character_set_server=utf8;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n4. 修改表的字符编码：`alter table user default character set utf8;`\n5. 修改属性的字符编码：`alter table user modify column name varchar(50) character set utf8;`\n## MySQL类 - 封装MySQL操作\n\n需要引入`mysql/mysql.h`头文件\n```cpp\n#include<mysql/mysql.h>\n```\n### 成员变量\n#### `MYSQL *m_conn`\n记录MYSQL类型的指针, 以获取这个mysql连接\n```cpp\nprivate:\n    MYSQL *m_conn;\n```\n### 成员函数\n#### 构造/析构\n初始化/释放数据库连接\n```cpp\npublic:\n   /* 初始化数据库连接 */\n   MySQL();\n   /* 释放数据库连接资源 */\n   ~MySQL();\n```\n#### getConnection\n获取连接, 即获取成员`m_conn`\n```cpp\npublic:\n   /* 获取连接 */\n   MYSQL * getConnection();\n```\n#### connect\n连接数据库, 返回值为bool, 说明连接成功与否\n```cpp\npublic:\n   /* 连接数据库 */\n   bool connect();\n```\n#### query\n查询操作, 参数是string类型的sql语句, 返回值为`MYSQL_RES`, 即MySQL结果集类型\n```cpp\npublic:\n   /* 查询操作 */\n   MYSQL_RES * query(string sql);\n```\n#### update\n更新操作, 参数是string类型的sql语句, 返回值为bool, 说明更新成功与否\n   ```cpp\n   public:\n       /* 更新操作 */\n       bool update(string sql);\n   ```\n### 代码实现\n\n前置全局声明\n```cpp\n#include <muduo/base/Logging.h>\t//日志工具\n/* 数据库配置信息 */\nstatic string server = \"127.0.0.1\";\nstatic string user = \"root\";\nstatic string password = \"123\";\nstatic string dbname = \"chat\";\n```\n#### 构造\n调用`mysql_init`, 实际上只是对mysql连接进行空间资源的开辟, 返回一个指针赋给`m_conn`成员, 没有真正连接, 因此传入nullptr\n   ```cpp\n   /* 初始化数据库连接 */\n   MySQL::MySQL()\n   {\n       m_conn = mysql_init(nullptr);\n   }\n   ```\n#### 析构\n调用`mysql_close(m_conn)`, 对MySQL连接资源进行释放\n   ```cpp\n   /* 释放数据库连接资源 */\n   MySQL::~MySQL()\n   {\n       if(m_conn != nullptr)\n       {\n           mysql_close(m_conn);\n       }\n   }\n   ```\n#### getConnection\n获取连接, 即返回`m_conn`成员\n   ```cpp\n   /* 获取连接 */\n   MYSQL * MySQL::getConnection()\n   {\n       return m_conn;\n   }\n   ```\n#### connect\n连接数据库, 内部调用`mysql_real_connect`, 传入`m_conn`, 以及server地址, user号, 密码, 要连接的数据库name, 服务器端口;\n   ```cpp\n   /* 连接数据库 */\n   bool MySQL::connect()\n   {\n       MYSQL *p = mysql_real_connect(m_conn, server.c_str(), user.c_str(),\n                                     password.c_str(), dbname.c_str(), 3306, nullptr, 0);\n       if(p != nullptr)\n       {\n           /* C/C++代码默认的编码字符是ASCII，如果不设置，则从MySQL上拉下来的中文无法正常显示 */\n           mysql_query(m_conn, \"set name gbk\");\n           LOG_INFO << \"connect mysql success!\";\n       }\n       else\n       {\n           LOG_INFO << \"connect mysql failed!\";\n       }\n       return p;\n   }\n   ```\n#### query\n查询操作\n\n1. 内部调用`mysql_query`, 传入`m_conn`, `sql-string`的C风格字符串首址；\n    1. `mysql_query`的返回值：\n        1. 如果查询成功，返回0;\n        2. 如果出现错误，返回非0值。\n        3. 返回值需要调用`mysql_use_result(m_conn)`获取结果集, 再return\n\n```cpp\n/* 查询操作 */\nMYSQL_RES * MySQL::query(string sql)\n{\n    if (mysql_query(m_conn, sql.c_str()))\n    {\n        LOG_INFO << __FILE__ << \":\" << __LINE__ << \":\" << sql << \"查询失败!\";\n        return nullptr;\n    }\n    return mysql_use_result(m_conn);\n}\n```\n\n2. update - 更新操作\n    1. 内部调用`mysql_query`, 传入`m_conn`, `sql-string`的C风格字符串首址;\n    2. 判断`mysql_query`的返回值, 若为**非 0 则更新失败**; 若为 **0 则更新成功**;\n\n```cpp\n/* 更新操作 */\nbool MySQL::update(string sql)\n{\n    if (mysql_query(m_conn, sql.c_str()))\n    {\n        LOG_INFO << __FILE__ << \":\" << __LINE__ << \":\" << sql << \"更新失败!\";\n        return false;\n    }\n    return true;\n}\n```\n\n## Model层 - 对业务层封装底层数据库的操作\n\n以User类的操作为例\n### User类\n\n```cpp\n#ifndef USER_H\n#define USER_H\n#include<string>\nusing namespace std;\n/**\n * 属于映射类;\n * 匹配User表的ORM类;\n */\nclass User\n{\npublic:\n    User(int id = -1, string name=\"\", string password=\"\", string state=\"offline\")\n        : id_(id), name_(name), password_(password), state_(state)\n    {   \n    }\npublic:\n    void setId(int id){id_ = id;}\n    void setName(string name){name_ = name;}\n    void setPassword(string password){password_ = password;}\n    void setState(string state){state_ = state;}\npublic:\n    int getId() const{return id_;}\n    string getName() const{return name_;}\n    string getPassword() const{return password_;}\n    string getState() const{return state_;}\nprivate:\n    int id_;\n    string name_;\n    string password_;\n    string state_;\n};\n#endif\n```\n### UserModel类\n\n1. insert - 参数为User的引用, 返回值为bool\n2. query - 参数为id, 返回值为User\n3. updateState - 更新用户的状态信息, 参数为User的一个临时副本, 返回bool\n4. resetAllState - 重置所有用户的状态信息\n\n```cpp\n#ifndef USERMODEL_H\n#define USERMODEL_H\n#include\"user.hpp\"\n/* User表的数据操作类 */\nclass UserModel\n{\npublic:\n    /* User表的增加方法 */\n    bool insert(User &user);\npublic:\n    /* 根据用户号码查询用户信息 */\n    User query(int id);\npublic:\n    /* 更新用户的状态信息 */\n    bool updateState(User user);\n    /* 重置所有用户的状态信息 */\n    void resetAllState();\n};\n#endif\n```\n### 代码实现\n\n```cpp\n#include\"usermodel.hpp\"\n#include\"db.h\"\n#include<iostream>\nusing namespace std;\n/* User表的增加方法 */\nbool UserModel::insert(User &user)\n{\n    /* 1.组装SQL语句 */\n    char sql[1024] = {0};\n    sprintf(sql, \"insert into user(name, password, state) values('%s', '%s', '%s')\",\n        user.getName().c_str(), user.getPassword().c_str(), user.getState().c_str());\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        if(mysql.update(sql))\n        {\n            /* 获取插入成功的用户数据生成的主键id */\n            /* 以下的mysql_insert_id是生成id的方法之一 */\n            user.setId(mysql_insert_id(mysql.getConnection()));\n            return true;\n        }\n    }\n    /* 注册失败 */\n    return false;\n}\n/* 根据用户号码查询用户信息 */\nUser UserModel::query(int id)\n{\n    /* 1.组装SQL语句 */\n    char sql[1024] = {0};\n    sprintf(sql, \"select * from user where id = %d\", id);\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        /* mysql.query内部申请了资源，处理完成User的构造后，需要free */\n        MYSQL_RES *res = mysql.query(sql);  // 此query为MySQL的query，和update同级。\n        if(res != nullptr)\n        {\n            MYSQL_ROW row = mysql_fetch_row(res);\n            if(row != nullptr)\n            {\n                User user;\n                user.setId(atoi(row[0]));\n                user.setName(row[1]);\n                user.setPassword(row[2]);\n                user.setState(row[3]);\n                mysql_free_result(res);\n                return user;\n            }\n        }\n    }\n    /* 如果没有有效的查询结果，返回一个默认User，id为-1，表示出错 */\n    return User();\n}\n/* 更新用户的状态信息 */\nbool UserModel::updateState(User user)\n{\n    /* 1.组装SQL语句 */\n    char sql[1024] = {0};\n    sprintf(sql, \"update user set state = '%s' where id = %d\", user.getState().c_str(), user.getId());\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        if(mysql.update(sql))\n        {\n            return true;\n        }\n    }\n    return false;\n}\n/* 重置所有用户的状态信息 */\nvoid UserModel::resetAllState()\n{\n    char sql[1024] = \"update user set state = 'offline' where state = 'online'\";\n    MySQL mysql;\n    if(mysql.connect())\n    {\n        mysql.update(sql);\n    }\n}\n```\n# 测试\n\n点对点聊天\n\n```bash\n./ChatServer\n```\n\n点对点聊天的json格式：`{\"msgid\":5,\"from\":\"from_name\",\"to\":to_id,\"msg\":\"......\"}`\n\n```\n# 注册\ntelnet 127.0.0.1 6000\n{\"msgid\":3,\"name\":\"test0511\",\"password\":\"123\"}\n```\n\n```\n#登录后一对一聊天\n{\"msgid\":1,\"id\":22,\"password\":\"123\"}\n{\"msgid\":6,\"from\":\"test0511\",\"to\":13,\"msg\":\"hello zhang san, i am test0511!\"}\n\n{\"msgid\":1,\"id\":13,\"password\":\"123456\"}\n{\"msgid\":6,\"from\":\"zhang san\",\"to\":22,\"msg\":\"hello test0511, i'm zhang san!\"}\n\n```\n\n\n```bash\n# xcg\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":22,\"password\":\"123\"}\t#登录\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello zhang san, i'm xcg!\"}\t#发送消息\n# 发送离线消息\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello - 1\"}\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello - 2\"}\n{\"msgid\":5,\"from\":\"xcg\",\"to\":13,\"msg\":\"hello - 3\"}\n\n```\n\n```bash\n# zhang san\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":13,\"password\":\"123456\"}\t#登录\n{\"msgid\":6,\"from\":\"zhang san\",\"to\":22,\"msg\":\"hello xcg, i'm zhang san!\"}#发送消息\n\n```\n# 好友业务\n\n1. 显示有哪些已添加的好友，id\n2. 添加好友\n\n但是业务并不严格，只要知道其id即可聊天。\n\n总体业务流程：向服务器发起添加好友的请求，服务器就把关系添加到friend表中，初版本不用征询对方的同意。\n\nfriend表就两个字段：`userid`、`friendid`是联合主键。\n## 测试\n\n添加好友、登陆成功后显示好友列表\n\n```bash\n./ChatServer\n```\n\n添加好友的JSON格式：`{\"msgid\":6,\"id\":22,\"friendid\":13}`。此语句意为：id为22的用户主动添加id为13的用户为好友，建立双向关系。\n\n添加后，查看friend表中是否有信息，应有一个`id:22 - friendid:13`。\n\n```mysql\nselect * from friend;\n```\n\n\n```bash\n# xcg\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":22,\"password\":\"123\"}\t# 登录\n{\"msgid\":6,\"id\":22,\"friendid\":13}\t# 添加id:13为好友\n\n# Ctrl + ] -> quit 退出\n# 重新登陆\ntelnet 127.0.0.1 6000\n{\"msgid\":1,\"id\":22,\"password\":\"123\"}\t# 登录\n# 看看是否返回好友列表\n```\n\n# 群组业务\n\n1. 管理员创建群\n2. 用户加入群\n3. 群聊\n## 表\n\n与群组业务相关的有两张表：一个是`AllGroup`表，一个是`GroupUser`表。\n\nAllGroup表有三个字段：id、groupname、groupdesc(群组描述)\n\nGroupUser表，因为群和成员之间是多对多的关系，所以需要此中间表来描述这个关系。有三个字段：`groupid`、`userid`、`grouprole`(成员在群中的权限)。\n\n`groupid`和`userid`是联合主键。\n\n这两张表都是处理群组业务的，所以对应的model只创建了一个。\n## model\n\ngroupmodel.hpp\n\n# 负载均衡\n\n负载均衡器, 亦叫做反向代理服务器, 在集群服务器架构中, 作为统一接收客户端请求的端口。\n\n其根据配置所界定的负载算法，把客户端的请求分发到业务服务器上。\n\n要做的三件事情：\n\n1. 把 client 的请求按照负载均衡算法分发到具体的业务服务器 ChatServer 上面；\n    1. 相应地, 服务器的响应也要经过负载均衡器, 准确地返回给这个 client 。\n    2. 服务器的响应消息，也可以通过服务器和客户端建立一个 IP 隧道实现，达到直接连接, 这样的效率更好; \n3. 能够和 ChatServer 保持心跳机制，监测 ChatServer 故障；\n4. 能够发现新添加的 ChatServer 设备，方便扩展服务器数量，最好是能够平滑地完成这个过程，而不是需要重启负载均衡服务器导致服务停止。\n## nginx负载均衡模块\n\n本项目选择 Nginx 的 TCP 负载均衡模块，要解决的问题\n\n1. 如何进行 Nginx 源码编译，包含 TCP 负载均衡模块\n2. `nginx.conf` 配置文件中如何配置负载均衡\n3. Nginx 的平滑加载配置文件启动\n\nnginx在1.9版本之前，只支持http协议web服务器的负载均衡，\n**从1.9版本开始以后，Nginx开始支持 TCP 的长连接负载均衡**，\n但是 Nginx 默认不编译 TCP 负载均衡模块，\n编写它时，需要加入`--with-stream`参数来激活这个模块。\n### 编译安装流程（记得带`--with-stream`）\n\n以`nginx-1.12.2.tar.gz`为例;\n\nnginx编译安装需要先安装pcre、openssl、zlib等库。\n\n```bash\nsudo apt-get install libpcre3 libpcre3-dev\n```\n\n\n>对开源产品发行源代码的编译安装, 一般都是: \n>\n>1. 先执行`./configure`, 生产相应的makefile文件;\n>2. `make`, 进行编译\n>3. `make install`, 进行安装\n\n解压`nginx-1.12.2.tar.gz`后，进入`nginx-1.12.2`目录，\n先运行`./configure --with-stream`生成`Makefile`后，\n运行`make`，最后`make install`。\nmake install命令会向系统路径拷贝文件，所以需要在root用户下执行。\n\n编译完成后，默认安装在了`/usr/local/nginx`目录。\n\n`nginx`目录下，可执行文件在`sbin`目录里，配置文件在`conf`目录里。\n\n### 配置文件\n\n如何配置负载均衡?\n\n`/usr/local/nginx/conf/nginx.conf`中, 可以看到http字段, 这是基于http的负载均衡配置; \n\n```nginx\n#user  nobody;\nworker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    server {\n        listen       80;\n        server_name  localhost;\n        location / {\n            root /var/www/hexo;\n            index  index.html index.htm;\n        }\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n}\n```\n\n而本项目是 TCP 服务器, 需要写到`stream`下, 表示基于TCP的负载均衡配置; \n1. server字段\n    1. listen - nginx负载均衡器将要监听的端口号\n    2. `proxy_pass` - 所有在listen字段端口号上的请求都将分发到这个标记字段所填充到信息中\n2. upstream字段 - 可用于负载均衡的服务器信息\n    1. `server IP:Port weight=权重 max_fail=最多失败次数 fail_timeout=最长等待响应时间`\n\n```nginx\n# nginx tcp loadbalance config\nstream {\n    upstream MyServer {\n        server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;\n        server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;\n    }\n    server {\n        # proxy connect timeout 1s;\n        listen     8000;\n        proxy_pass MyServer;\n    }\n}\n```\n### 常用操作\n\n```bash\nnginx -s reload\t\t# 重新加载配置文件，平滑启动\nnginx -s stop\t\t# 停止nginx服务\n```\n### Nginx的网络模型设计（accpet锁解决惊群现象）（reactors in process - one loop per process）\n我们上面的网络IO模块的 muduo 的网络设计是：reactors in threads - one loop per thread.\n\n而 Nginx 服务器的网络模块设计是基于进程的，采用多个 Reactor 充当 I/O 进程和工作**进程**，通过一把 accept 锁完美解决多个 Reactors 的惊群现象。\n因此Nginx服务器的模型是：**reactors in process - one loop per process**\n## 更加高并发？把负载均衡器也集群！（LVS负载均衡器）\n\n负载均衡也分为很多种, \n\n1. 可分为业务层负载均衡器，通过业务分发; \n2. 也可分为传输层的负载均衡器，通过UDP/TCP分发; \n3. 网络层的负载均衡器，通过IP分发; \n4. 数据链路层的负载均衡器，通过数据帧分发; \n\n如何更进一步提高并发量?\n\n可以把负载均衡器也进行集群处理, 前端使用一个偏底层的 LVS 负载均衡器, 即, 一台 LVS 加多台 Nginx 服务器的模型。\n\nLVS的并发量很容易扩展到十几万; \n# Redis优化跨服务器通信\n\n本项目中, 用户间的通信模型无非有两种：一对一聊天、群聊。\n\n集群环境中，即用户可能分布在不同服务器主机上。\n\n如果按照之前的代码逻辑，每台服务器上的一个 Server 都只有一个`m_userConnectionMap`（因为这个是ChatService中的成员，而ChatService是单例模式）。\n\n所以用户给对方发消息后，如果接收方用户不在同一台服务器上，那么该消息就会被当作离线消息，这显然是不对的。\n\n那么怎么解决跨服务器通信呢？\n## 多个服务器广播通信（虽能解决，但是太差）\n**最直观的想法**是让各个ChatServer服务器互相之间直接建立TCP连接进行通信，相当于在服务器网络之间进行广播。\n![](../../images/集群服务器架构/image-20250803032633484.png)\n这样的设计使得各个服务器之间耦合度太高，不利于系统扩展，并且会占用系统大量的 socket 资源，各服务器之间的带宽压力很大，不能够节省资源给更多的客户端提供服务，因此不是一个好的设计。\n## Redis 消息队列 解耦设计\n集群部署的服务器之间进行通信，最好的方式就是引入中间件消息队列，\n解耦各个服务器，使整个系统松耦合，提高服务器的响应能力，节省服务器的带宽资源。\n\n所以答案是引入服务器中间件如消息队列。\n![](../../images/集群服务器架构/image-20250803032927009.png)\n\n\n如此一来, **服务器仅需做的工作是：向中间件发布订阅消息，之后等待中间件通知去取消息**。\n\n在集群分布式环境中，经常使用的中间件消息队列有 ActiveMQ 、RabbitMQ 、Kafka 等，都是应用场景广泛并且性能很好的消息队列，供集群服务器之间，分布式服务之间进行消息通信。\n\n限于本项目业务类型并不是非常复杂，对并发请求量也没有太高的要求，因此本项目中间件消息队列选型的是：基于发布-订阅模式的 Redis。\n## Redis环境安装和配置\n\n1. Ubuntu安装redis服务命令\n\n```bash\nsudo apt-get install redis-server\n```\n\n2. 安装完成后会自动启动redis服务，通过ps命令确认; redis默认端口为6379\n\n```bash\nps -ef | grep redis\n```\n## redis-cli测试redis-server\n\n启动redis-cli客户端，连接redis server体验一下数据缓存功能\n\n```bash\nredis-cli\n```\n\n```redis\n127.0.0.1:6379> set \"abc\" \"hello world\" #设置key-value\nOK\n127.0.0.1:6379> get \"abc\"\n\"hello world\"\n```\n### Redis 订阅 / 发布\n\nRedis 的发布-订阅机制：发布-订阅模式包含了两种角色，分别是消息的发布者和消息的订阅者。\n\n订阅者可以订阅一个或者多个频道 channel ，发布者可以向指定的频道 channel 发送消息，所有订阅此频道的订阅者都会收到此消息。\n\n订阅频道的命令是 subscribe，可以同时订阅多个频道，用法是`subscribe channel1 [channel2] ...`;\n\n```redis\n127.0.0.1:6379> subscribe 13\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"13\"\n3) (integer) 1\n```\n\n```redis\n127.0.0.1:6379> publish 13 \"hello, 13\" #另一端推送消息给13\n```\n\n订阅了`13`频道 的用户收到的消息: \n\n```redis\n1) \"message\"\n2) \"13\"\n3) \"hello, 13\"\n```\n\n## 对应于本项目\n\n由于服务器是集群化的, 所以登录到本系统的用户可能不在同一聊天服务器上, 需要观察Redis中间件来获取消息;\n\n即, 用户是观察者, 消息队列是被观察者;\n\n某一用户登陆到聊天系统后, \n\n1. 服务器需要向 Redis 订阅某一频道的消息, 这个频道的id号即为该用户的id号;\n2. 当该用户给另一用户发送消息时, 发现其不在本服务器中, 需要向该频道发布消息;\n\n# Redis发布-订阅的客户端编程 - 封装为Redis类\n\nredis支持多种不同的客户端编程语言，例如 Java 对应 Jedis ，PHP对应 phpredis ，**C++对应的是 hiredis**。\n## hiredis 安装步骤\n1. `git clone https://github.com/redis/hiredis`\n2. `make && make install`\n\n```bash\ncd hiredis\nmake\n...\nsudo make install #拷贝生成的动态库到/usr/local/lib目录下\n# 如果提示没有找到hiredis动态库，则执行下面\n# sudo ldconfig /usr/local/lib\n```\n## 成员变量\n\n1. hiredis同步上下文对象\n    1. 一个专门负责publish消息\n    2. 一个专门负责subscribe消息\n\n```cpp\nprivate:\n   /* hiredis同步上下文对象, 负责publish消息 */\n   redisContext * m_publish_context;\n   /* hiredis同步上下文对象, 负责subscribe消息 */\n   redisContext * m_subscribe_context;\n```\n\n2. 回调操作, 收到订阅的消息, 给service层上报\n\n```cpp\nprivate:\n   /* 回调操作, 收到订阅的消息, 给service层上报 */\n   MessageCallback m_notify_handler;\n```\n\n>1. 对于\"hiredis上下文对象\"的理解:\n>   - 相当于一个redis-cli, 存储了连接相关的信息;\n>2. 为什么要写两个上下文对象?\n>   - 如果上下文对象正在subscribe那么其将会阻塞, 所以 subscribe 和 publish 需要分开操作;\n\n## 成员函数\n\n### 构造/析构\n```cpp\npublic:\n   Redis();\n   ~Redis();\n```\n### connect\n连接Redis服务器\n```cpp\npublic:\n   /* 连接Redis服务器 */\n   bool connect();\n```\n### 发布/订阅消息\n```cpp\npublic:\n   /* 向指定的redis频道发布消息 */\n   bool publish(int channel, string message);\n   /* 向指定的redis频道订阅消息 */\n   bool subscribe(int channel);\n   /* 向指定的redis频道取消订阅消息 */\n   bool unsubscribe(int channel);\n```\n### `observer_channel_message`\n在独立线程中接收订阅频道中的消息\n\n```cpp\npublic:\n   /* 在独立线程中接收订阅频道中的消息 */\n   void observer_channel_message();\n```\n\n### `init_notify_handler`\n初始化向业务层上报频道消息 的回调函数, 需要用到一个int(频道号), 一个消息内容字符串\n```cpp\npublic:\n   using MessageCallback = function<void(int, string)>;\n   /* 初始化向业务层上报频道消息 的回调函数, 需要用到int(频道号), 消息内容字符串 */\n   void init_notify_handler(MessageCallback cb);\n```\n## 代码实现\n\n### 构造\n只是对两个上下文对象指针赋nullptr, 没有实际构造\n```cpp\nRedis::Redis()\n   : m_publish_context(nullptr), m_subscribe_context(nullptr)\n{\n}\n```\n### 析构\n调用`redisFree`释放上下文对象资源\n```cpp\nRedis::~Redis()\n{\n   if(m_publish_context != nullptr)\n   {\n       redisFree(m_publish_context);\n   }\n   if(m_subscribe_context != nullptr)\n   {\n       redisFree(m_subscribe_context);\n   }\n}\n```\n### connect\n1. 对context进行实际的申请资源/构造, 返回指针赋给成员, 底层调用`redisConnect`\n2. 创建线程, 执行`observer_channel_message`, 即循环等待Redis频道的reply\n\n```cpp\nbool Redis::connect()\n{\n   m_publish_context = redisConnect(\"127.0.0.1\", 6379);\n   if(nullptr == m_publish_context)\n   {\n       cerr << \"connect redis failed!\" << endl;\n       return false;\n   }\n\n   m_subscribe_context = redisConnect(\"127.0.0.1\", 6379);\n   if(nullptr == m_subscribe_context)\n   {\n       cerr << \"connect redis failed!\" << endl;\n       return false;\n   }\n\n   /**\n    * 由于subscribe操作是阻塞的, \n    * 在实际的使用环境下, 不可能因为一个订阅操作去阻塞一个服务器, \n    * 所以要用一个单独的线程来完成监听频道上的事件,\n    * 有消息则给业务层进行上报; \n    */\n   thread t(\n       [&]() { observer_channel_message();} );\n   t.detach();\n\n   cout << \"connect redis-server success!\" << endl;\n   return true;\n}\n```\n\n### publish\n相当于向redis-server发送命令, reply接收命令执行结果\n```cpp\nbool Redis::publish(int channel, string message)\n{\n   /* 相当于向redis-server发送命令, reply接收命令执行结果 */\n   redisReply * reply = (redisReply*)redisCommand(\n       m_publish_context, \"PUBLISH %d %s\", channel, message.c_str());\n   if(nullptr == reply)\n   {\n       cerr << \"publish command failed!\" << endl;\n       return false;\n   }\n   freeReplyObject(reply);\n   return true;\n}\n```\n\n### subscribe\n相当于把redisCommand细化了, 只操作了发命令, 接收结果交给单独的线程做了, 详见`observer_channel_message`\n```cpp\nbool Redis::subscribe(int channel)\n{\n   if(REDIS_ERR == redisAppendCommand(\n       m_subscribe_context, \"SUBSCRIBE %d\", channel))\n   {\n       cerr << \"subscribe command failed!\" << endl;\n       return false;\n   }\n   /* 循环发送缓冲区内容, 直到发送完毕 */\n   int done = 0;\n   while(!done)\n   {\n       if(REDIS_ERR == redisBufferWrite(m_subscribe_context, &done))\n       {\n           cerr << \"subscribe command failed!\" << endl;\n           return false;\n       }\n   }\n   /**\n    * 这里不做redisReply的操作,\n    * 这是个阻塞的操作, 放在observer_channel_message中做;\n    */\n   return true;\n}\n```\n\n### unsubscribe\n```cpp\nbool Redis::unsubscribe(int channel)\n{\n   if(REDIS_ERR == redisAppendCommand(\n       m_subscribe_context, \"UNSUBSCRIBE %d\", channel))\n   {\n       cerr << \"unsubscribe command failed!\" << endl;\n       return false;\n   }\n   /* 循环发送缓冲区内容, 直到发送完毕 */\n   int done = 0;\n   while(!done)\n   {\n       if(REDIS_ERR == redisBufferWrite(m_subscribe_context, &done))\n       {\n           cerr << \"unsubscribe command failed!\" << endl;\n           return false;\n       }\n   }\n   /**\n    * 这里不做redisReply的操作,\n    * 这是个阻塞的操作, 放在observer_channel_message中做;\n    */\n   return true;\n}\n```\n### `observer_channel_message`\n* Redis频道如果有消息, 则有三个字段, \n    1. 对应的是redisGetReply返回的`reply->element[0],[1],[2]`;\n    2. 本项目的`element[1]`对应的是频道号;\n    3. 本项目的`element[2]`对应的是消息体;\n\n```cpp\nvoid Redis::observer_channel_message()\n{\n   redisReply *reply = nullptr;\n   int res = REDIS_ERR;\n   while(REDIS_OK==(res = redisGetReply(\n                               m_subscribe_context, (void**)&reply)))\n   {\n       if(reply != nullptr &&\n          reply->element[2] != nullptr &&\n          reply->element[2]->str != nullptr)\n       {\n           /* 给业务层上报频道上发生的消息, 即频道号+消息体 */\n           m_notify_handler(atoi(reply->element[1]->str),\n                            reply->element[2]->str );\n       }\n       freeReplyObject(reply);\n   }\n   if(res == REDIS_ERR)\n   {\n       cerr << \"redisGetReply err\" << endl;\n       return;\n   }\n   cerr << \"observer_channel_message quit\" << endl;\n}\n```\n### `init_notify_handler`\n设置`m_notify_handler`回调\n\n```cpp\nvoid Redis::init_notify_handler(MessageCallback cb)\n{\n   m_notify_handler = cb;\n}\n```\n\n> redisCommand和redisAppendCommand的区别:\n>\n> 1. redisAppendCommand只是把命令先写到本地缓存中;\n> 2. 写到缓存之后还需要调用redisBufferWrite把缓存中的命令发送到Redis服务器;\n> 3. 最后, 如果要获得reply, 还需要调用redisGetReply获取结果, 这个操作对于subscribe是阻塞的;\n> 4. 由于publish操作一般不会阻塞, 所以直接调用redisCommand;\n> 5. 由于subscribe操作最后的redisGetReply将会阻塞, 所以我们把这几个步骤单独写出来, 粒度减小, 追求效率;\n\n## ChatService加入Redis组件\n\n首先, 需要在`chatservice.hpp`中, 引入头文件`\"redis.hpp\"`; 然后在`ChatService`的类成员变量中声明一个`Redis m_redis`redis操作对象;\n```cpp\nprivate:\n   Redis m_redis;\n```\n\n在ChatService类中, 添加一个处理redis业务的成员函数`handleRedisSubscribeMessage`\n   ```cpp\n   public:\n       void handleRedisSubscribeMessage(int channel, string message);\n   ```\n\n在`chatservice.cpp`中, ChatService的构造函数中, 需要添加连接redis服务器的操作; \n如果连接成功, 给redis设置回调函数为`handleRedisSubscribeMessage`, 参数为chatservice对象指针, channel, message;\n```cpp\nChatService::ChatService()\n{\n   // ...\n   if(m_redis.connect())\n   {\n       m_redis.init_notify_handler(std::bind(\n           &ChatService::handleRedisSubscribeMessage, this, _1, _2));\n   }\n}\n```\n","categories":["Cpp","项目","集群"]},{"title":"Cpp_原子类型_无锁队列","url":"/Cpp/Cpp_原子类型_无锁队列/","content":"# 线程安全问题\n\n```cpp\nint count = 0;\ncount++;\ncount--;\t/* 是线程不安全的 */\n```\n后置`++`有多个动作：\n1. 取出count的值为tmp\n2. 计算`count + 1`\n3. `count + 1`的结果赋给count\n4. 返回tmp\n\n对应于多条指令。\n\n传统地解决，可以用加锁的方式\n```cpp\n{\n    lock_guard<std::mutex> guard(mtx);\n\tcount++;\n}\n```\n但是，互斥锁是比较耗费资源的，如果临界区的代码比较轻量级，那么传统mutex锁相对而言就比较小题大做了。\n\n现在有新机制解决：指令级并发。\n\n如果想让这么多动作在一条指令内做完的话，需要让处理器支持这样的操作，而不用锁机制，因此这种叫做无锁结构。\n# 原子类型\n定义于`<atomic>`\n原子类型，封装了一个值，保证其的访问不会导致数据竞争，并且可用于同步不同线程之间的内存访问。\n## `atomic_flag`\n初始化可以赋值为`ATOMIC_FLAG_INIT`，意为无状态，对应false。\n1. `test_and_set()`：置位为有状态，对应true，并返回调用之前的状态。这是一个原子操作，不会被其他线程干扰。\n2. `clear()`重置flag为无状态\n### `atomic_flag`做自旋锁\n以下就是一个用`atomic_flag`做忙等待的例子：\n1. 初始flag为无状态\n2. 调用一次`test_and_set()`置位flag为有状态\n3. while中一直调用`test_and_set()`，测试它的状态，直到为无状态时，退出循环，结束程序。\n\n```cpp\n#include <atomic>\n\nint main()\n{\n    std::atomic_flag flag = ATOMIC_FLAG_INIT;\n    flag.test_and_set();\n    while (flag.test_and_set())\n    {\n        continue;   \n    }\n    return 0;\n}\n```\n\n给定一个`atomic_flag`，初始为无状态，同时启动10个线程，操作之前，调用`test_and_set`，如果测试为无状态，说明没有其他线程在操作，就可以进行操作。\n操作完毕后，`clear`重置flag为无状态。下一个线程就可以探测到无状态，开始它的操作。\n\n此时，`atomic_flag`就相当于自旋锁的作用。\n```cpp\n\nstd::atomic_flag lock_output = ATOMIC_FLAG_INIT;\nstd::counting_semaphore<10> sema{ 0 };\nvoid worker(int v)\n{\n    // lock\n    while (lock_output.test_and_set())\n    {}\n    std::cout << \"thread #\" << v << std::endl;\n    // unlock\n    lock_output.clear();\n}\nint main()\n{\n    std::jthread t[10];\n    for (int i = 0; i < 10; ++i)\n    {\n        t[i] = std::jthread(&worker, i + 1);\n    }\n    sema.release(10);\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(5s);\n    return 0;\n}\n```\n输出：\n```\nthread #1\nthread #5\nthread #4\nthread #7\nthread #2\nthread #10\nthread #6\nthread #3\nthread #9\nthread #8\n```\n## atomic\n```cpp\ntemplate <class T> struct atomic;\n```\n原子对象的主要特征是，从不同线程访问值不会导致数据竞争（即，这样做是明确定义的行为，访问顺序正确）。\n通常，对于所有其他对象，如果同时访问同一对象而导致数据争用，则该操作将被视为未定义行为。\n\n原子对象能够通过**指定不同的内存顺序**来**同步对其线程中其他非原子对象的访问**。\n# Relaxed Ordering的问题\n```cpp\n// Thread 1:\nr1 = y.load(std::memory_order_relaxed); // A\nx.store(r1, std::memory_order_relaxed); // B\n// Thread 2:\nr2 = x.load(std::memory_order_relaxed); // C\ny.store(42, std::memory_order_relaxed); // D\n```\n标记为 `memory_order_relaxed` 的原子操作不是同步操作。它们不会在并发内存访问中强加顺序，它们只保证原子性和修改顺序的一致性。\n例如，x 和 y 初始为零。\n以上程序就会允许产生 `r1 == r2 == 42`，在线程 1 内，A 在 B 之前被排序，并且在线程 2 内，C 在 D 之前被排序。\n但是没有什么可以阻止 D 在 A 之前 修改了 y，并且 B 在 C 之前 修改 x 。\nD 对 y 的副作用对于线程 1 中的 load A 是可见的，B 对 x 的副作用对于线程 2 中的 load C 是可见的。\n\n特别是，如果在线程 2 中 D 在 C 之前完成，这可能会发生，这可能是在运行时发生的，或者由于编译器重新排序导致的。\n>实际上，A、B是不能调换的，因为编译器会看到，同在线程1中，B中的 `r1` 的值依赖于上一句的A对 `r1` 的操作。\n>而C、D之间就没有依赖了，因为 D 操作的是 `42`，是个常量。\n>所以，经过线程并发、内存重排，可能的执行顺序有：\n>A B C D  此时 x、y、r1、r2的值：0、0、0、42\n>A B D C  此时 x、y、r1、r2的值：0、42、0、0\n>A C D B  此时 x、y、r1、r2的值：0、42、0、0\n>A D C B  此时 x、y、r1、r2的值：0、42、0、0\n>C A D B  此时 x、y、r1、r2的值：0、42、0、0\n>**D A C B**  此时 x、y、r1、r2的值：**42、42、42、42**  => 这时便出现了`r1 == r2 == 42`\n>C D A B  此时 x、y、r1、r2的值：42、42、42、0\n>D C A B  此时 x、y、r1、r2的值：0、42、42、0\n\n怎么解决呢？\n见下文\n\n# 内存顺序\n原子操作只是提供了不同线程读写的同步。\n但是**没有提供操作顺序的同步**。\n\n比如：线程1修改原子值a，线程2读取原子值a。\n\n两个线程各自的读写操作，确实是保证了不会有脏值。\n但是线程1、线程2的顺序没有做控制，\n如果线程2想要读出旧值，但是线程1在线程2读值前进行写操作，还是会导致线程2读出脏值。\n\n因此需要提供内存顺序机制。\n\n下面举一个类似的例子，怎么通过原子变量+内存顺序控制，让consumer确保producer执行完毕后，再 load 出 b 的值。\n```cpp\nvoid producer(void)\n{\n    a.store(true, std::memory_order::relaxed);\n    b.store(true, std::memory_order::release);\n}\nvoid consumer(void)\n{\n    // memory_order_acquire表示必须排序在x store、y store之后\n    while (!b.load(std::memory_order::acquire))\n    {}\n    if (a.load(std::memory_order::relaxed))\n        ++c;\n}\nint main()\n{\n    a = false;\n    b = false;\n    c = 0;\n    using namespace std::chrono::literals;\n    std::jthread th2(consumer);\n    std::this_thread::sleep_for(2s);\n    \n    std::jthread th(producer);\n\n    th.join();\n    th2.join();\n}\n```\n\n\n| 类型          | 含义                                                                                                                                                                                  |\n| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| relaxed     | CPU和编译器可以重新排序变量顺序。<br>这是一种松散的内存顺序，不保证不同线程中的内存访问对原子操作进行排序。                                                                                                                           |\n| consume（废弃） | 针对某个原子变量的访问指令（store）重排到此指令（load）前。**即自己load排到针对某个变量的release操作后**。（在`C++26`中被废弃了，推荐用acquire）                                                                                         |\n| acquire     | 所有访问指令（store）排到此指令（load）前。**即自己load排到所有release操作后**。                                                                                                                                |\n| release     | 所有访问指令（load）排到此指令（store）之后。即自己store排到所有consume、acquire操作之前。<br>扮演了一个同步点（synchronization point）的角色。                                                                                  |\n| acq_rel     | The operation loads acquiring and stores releasing。<br>该操作可能扮演两种角色。<br>比如`std::atomic::exchange`操作，两个变量交换：<br>需要load值，可能需要等待release；<br>需要store值，即产生release，需要给其他acquire、consume通知。 |\n| seq_cst     | sequentially consistent，意思是该操作以顺序一致的方式排序。一旦所有可能对其他线程产生可见副作用的内存访问已经发生，则所有操作使用此内存顺序。<br>这是最严格的内存顺序，保证了在非原子内存访问中线程交互之间的意外副作用最小。<br>对于consume和acquire的load，顺序一致的store操作被认为是release操作。   |\n\n# lock_free测试\n测试以确定原子模板包含的类型是否支持无锁。\n```cpp\nint main()\n{\n    std::wcout << std::boolalpha << std::atomic<int>{}.is_lock_free() << std::endl; // true\n    std::wcout << std::boolalpha << std::atomic<int>{}.is_always_lock_free << std::endl; // true\n}\n```\n经过测试后发现，不超过8字节（64位）的数据结构，并且没有虚函数表的数据结构，是支持无锁的。\n```cpp\nstruct A {int x, y; A() {}}\nstruct B {int a[2];}\nstruct C {int a[3];}\n\nint main()\n{\n    std::wcout << std::boolalpha << std::atomic<A>{}.is_lock_free() << std::endl; // true\n    std::wcout << std::boolalpha << std::atomic<B>{}.is_lock_free() << std::endl; // true\n    std::wcout << std::boolalpha << std::atomic<C>{}.is_lock_free() << std::endl; // false\n}\n```\n# 无锁编程的原理\n## CAS（Compare-And-Swap）\nCAS在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一模一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。（具有ABA问题：用版本号或时间戳解决）\n\n现代CPU提供​**​CAS（Compare-And-Swap）​**​ 等原子指令，可在单个指令周期内完成类似以下的判断函数：\n```c\nbool CAS(T* ptr, T old_val, T new_val)\n{\n    if (*ptr == old_val)\n    {\n        *ptr = new_val;\n        return true;\n    }\n    return false;\n}\n```\n以上类似的操作，实际指令执行期间不会被中断，避免了数据竞争。\n\n比如，用这个特性，实现一个自旋锁：\n```c\nint TestAndSet(int *old_ptr, int new)\n{\n    int old = *old_ptr;\n    *old_ptr = new;\n    return old;\n}\n```\n\n```c\ntypedef struct lock_t\n{\n    int flag;\n} lock_t;\nvoid init(lock_t *lock)\n{\n    lock->flag = 0;\n}\n// 当 flag 为 0 时，函数返回false，退出。加锁成功。flag被修改为 1\nvoid lock(lock_t *lock)\n{\n    while (TestAndSet(&lock->flag, 1) == 1)\n    {} // do nothing\n}\nvoid unlock(lock_t *lock)\n{\n    lock->flag = 0;\n}\n```\n## 内存顺序\n```cpp\nstd::atomic<int> flag(0);\n// 线程1\ndata = 42;                                       // 1. 写数据\nflag.store(1, std::memory_order_release);        // 2. 释放屏障：保证 1 一定在 2 前完成\n\n// 线程2\nwhile (flag.load(std::memory_order_acquire) != 1)// 3. 获取屏障：保证读到 flag = 1 时，才退出循环\n    ;                                            //    一定能看到data=42\nread(data);                                      // 4. 安全读取数据\n```\n# 无锁数据结构的实现模式\n## ”读-修改-写“循环（Read-Modify-Write Loop）\n这是实现无锁的关键思维之一：**乐观并发控制**：**先执行操作，提交前，验证数据（tail）未被修改，如果未被修改，再提交**\n```cpp\nbool CAS(Node* old_ptr, Node* new_ptr)\n{\n    if (this == old_ptr)\n    {\n        this = new_ptr;\n        return true;\n    }\n    return false;\n}\nvoid push(T value)\n{\n    Node* new_node = new Node(value);\n    Node* old_tail;\n    do {\n        old_tail = tail.load();              // 读\n        new_node->next = old_tail;           // 修改\n    } while (!tail.CAS(old_tail, new_node)); // 把 tail 改为 new_node（失败则重试）\n}\n```\n## 帮助机制（Helping Mechanism）​\n\n当线程A发现线程B的操作未完成时，主动协助推进（如无锁队列中帮其他线程移动tail指针）。\n## ​​分离并发关注点（如头尾指针分离）​\n将数据结构拆分为多个可独立更新的部分，减少竞争点。\n\n这是实现无锁的关键思维之二：​**​局部性原理（Locality Principle）**：通过数据分片（如分槽队列）减少缓存行冲突：\n对齐64位。\n```cpp\nstruct alignas(64) PaddedAtomic\n{ \n    std::atomic<int> count;  // 独占缓存行\n};\n```\n# ABA问题（乐观锁问题）\n乐观锁会出现这种问题。\n\n乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突（一般实现方式是通过加版本号然后进行版本号的对比方式实现）\n\n特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁。而是通过业务实现锁的功能。\n不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程。\n这种方式节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能。\n不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源。\n所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。\n## 问题场景\n比如说线程一从数据库中取出库存数 3，这时候线程二也从数据库中取出库存数 3。\n**线程二进行了一些操作变成了 2**。**但是然后线程二在线程一拿到操作权之前，又将库存数变成了 3**。\n这时候：线程一进行 CAS 操作发现数据库中仍然是 3，然后线程一操作成功。\n尽管线程一的 CAS 操作成功，但是不代表这个过程就是没有问题的。\n## 解决方案\n使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是脏数据，需要处理。\n\n使用带版本号的指针：\n```cpp\nstruct VersionedPtr\n{\n    Node* ptr;\n    uint64_t version;  // 每次修改+1\n};\n```\n# 内存回收挑战\n| 方法                    | 原理                                     | 适用场景      |\n| --------------------- | -------------------------------------- | --------- |\n| Hazard Pointers       | 线程本地记录\"危险指针\"（有的也叫风险指针），延迟删除其他线程可能访问的内存 | Linux内核常用 |\n| Epoch-Based Reclaim   | 将内存标记为待回收，当所有线程都不持有旧epoch时才删除          | NVIDIA库常用 |\n| RCU（Read-Copy-Update） | 读操作无同步，写操作创建副本延迟回收                     | Linux内核链表 |\n# MPMC无锁队列\n## Node的设计（伪共享预防、ABA问题解决）\n- ​**​伪共享预防​**​：`alignas(64)`和填充确保 头尾 在不同缓存行\n- **ABA问题防护​**​：通过`version`版本号区分指针复用\n\n```cpp\nstruct Node\n{\n    T* data;  // 数据指针（避免拷贝开销）\n    std::atomic<Node*> next; // 原子指针\n    // 防止伪共享\n    char padding[64 - sizeof(T*) - sizeof(std::atomic<Node*>)];\n};\n\nstruct VersionedPtr\n{\n    Node* ptr;\n    uint64_t version;  // ABA防护\n};\n```\n\n```cpp\n#include <atomic>\n#include <memory>\n\ntemplate<typename T>\nclass LockFreeMPMCQueue {\nprivate:\n    // 节点结构：带缓存行填充防止伪共享\n    struct Node\n    {\n        Node() : data(nullptr), next(nullptr)\n        {\n        \n        }\n        T* data;  // 存储实际数据指针（避免对象拷贝开销）\n        std::atomic<Node*> next;  // 下一个节点指针\n        // 确保每个节点独占缓存行（64字节）\n        char padding[64 - sizeof(T*) - sizeof(std::atomic<Node*>)];\n    };\n\n    // 带版本号的指针（解决ABA问题）\n    struct alignas(16) VersionedPtr\n    {\n        Node* ptr;\n        uint64_t version;\n    };\n\n    // 保证头尾指针不在同一缓存行\n    struct\n    {\n        alignas(64) std::atomic<VersionedPtr> head;\n        char padding[64];  // 填充确保tail在下一个缓存行\n    };\n    alignas(64) std::atomic<VersionedPtr> tail;\npublic:\n    // ...\n};\n```\n## 队列初始化（哨兵dummy头节点）\n**作用​**​：保证非空队列始终存在头节点，避免头尾指针竞态\n\n```cpp\n{\n// ...\npublic:\n    LockFreeMPMCQueue()\n    {\n        // 初始化哑元节点（dummy node）\n        Node* dummy = new Node();\n        \n        // 头尾指针指向同一个节点\n        VersionedPtr init = {dummy, 0};\n        head.store(init, std::memory_order_relaxed);\n        tail.store(init, std::memory_order_relaxed);\n    }\n// ...\n};\n```\n## 入队操作\n\n```cpp\n// ...\n    // 入队操作（多线程安全）\n    bool Enqueue(T value)\n    {\n        // 1. 创建新节点并填充数据\n        Node* new_node = new Node();\n        try\n        {\n            new_node->data = new T(std::move(value));\n        }\n        catch (...)\n        {\n            delete new_node;\n            return false;\n        }\n\n        // 2. CAS循环：找到真正的尾节点\n        VersionedPtr current_tail;\n        while (true)\n        {\n            // 原子获取当前尾指针\n            // current_tail是std::atomic<VersionedPtr>类型的\n            // 还要取出其成员 ptr。是 Node* 类型\n            current_tail = tail.load(std::memory_order_acquire);\n            Node* real_tail = current_tail.ptr;\n            \n            // 定义新的 Node * next，先让它指向尾节点的 next\n            Node* next = (real_tail->next).load(std::memory_order_acquire);\n            \n            // 检查期间尾指针是否变化\n            if (current_tail.ptr != tail.load(std::memory_order_acquire).ptr)\n                continue;  // 发生变化则循环重试\n            \n            if (next == nullptr)\n            {\n                // 情况A：尾节点后是空位置（理想情况）\n                VersionedPtr new_ptr{new_node, current_tail.version + 1};\n                // 尝试将新节点链接到尾节点后面\n                // 关键CAS：\n                    // 如果成功，则 原子更新尾节点的 next 指针，即尾节点的 next 指向 new_node\n                    // 如果失败，则 real_tail->next 的值 写入到 next 中（详见函数的作用）\n                    // 总之不会阻塞。\n                if (real_tail->next.compare_exchange_weak(\n                    next, new_node, \n                    std::memory_order_release,\n                    std::memory_order_relaxed)) \n                {\n                    break; // 链接成功，退出循环\n                }\n            }\n            else\n            {\n                // 情况B：发现尾指针滞后，帮助其它线程推进\n                // 意思就是说，现在的 next 不是 null，说明这是一个其他人入队创建的节点\n                VersionedPtr other_ptr{next, current_tail.version + 1};\n                \n                // 尝试更新尾指针到后继节点（避免竞争导致的阻塞）\n                // 即，把队列的 tail 改为 other_ptr\n                tail.compare_exchange_strong(\n                    current_tail, other_ptr,\n                    std::memory_order_release,\n                    std::memory_order_relaxed);\n            }\n        }\n        \n        // 3. 尝试更新全局尾指针（允许失败，因为有可能有人帮忙推进了）\n        // 即，把队列的 tail 改为 new_tail\n        VersionedPtr new_tail{new_node, current_tail.version + 1};\n        tail.compare_exchange_strong(\n            current_tail, new_tail,\n            std::memory_order_release,\n            std::memory_order_relaxed);\n        \n        return true;\n    }\n// ...\n```\n### `compare_exchange_weak`和strong\n```cpp\nbool compare_exchange_weak(T& expected, T desired,\n                           std::memory_order success,\n                           std::memory_order failure) noexcept;\nbool compare_exchange_strong(T& expected, T desired,\n                             std::memory_order success,\n                             std::memory_order failure) noexcept;\n```\n两个函数都是：\nAtomically compares the [value representation](https://en.cppreference.com/w/cpp/language/objects.html \"cpp/language/object\") (since C++20) of `*this` with that of expected. If those are bitwise-equal, replaces the former with desired (performs read-modify-write operation). Otherwise, loads the actual value stored in `*this` into expected (performs load operation).\n比较`*this`和`expected`的值，若相等，则把`*this`替换为`desired`（执行`read-modify-write operation`，即：读-修改-写），返回真。否则，把`*this`实际的值，存到`expected`中（执行`load operation`），返回假。\n\n参数：\n`compare_exchange_weak`和`compare_exchange_strong`都在后面有两个内存顺序的参数，第一个内存顺序指的是，成功时，做`read‑modify‑write operation`的内存顺序；第二个内存顺序指的是，失败时，做`load operation`的内存顺序。\n\n与 [compare_exchange_strong](https://legacy.cplusplus.com/atomic_compare_exchange_strong) 不同的是，这个弱版本允许通过返回 `false`来虚假地失败，即使`*expected` 确实与 obj 中包含的值相等。\n对于某些循环算法来说，这可能是可接受的行为，并且可能在某些平台上导致显著更好的性能。\n对于这些虚假的失败，函数返回`false`，但不修改预期。\n\n## 出队操作\n```cpp\n// ...\n    // 出队操作（多线程安全）\n    bool Dequeue(T& result)\n    {\n        VersionedPtr current_head;\n        Node* real_tail;\n        Node* next;\n\n        while (true)\n        {\n            // 1. 原子获取头尾指针（关键）\n            current_head = head.load(std::memory_order_acquire);\n            Node* real_head = current_head.ptr;\n            \n            real_tail = tail.load(std::memory_order_acquire).ptr;\n            \n            next = (real_head->next).load(std::memory_order_acquire);\n\n            // 一致性检查：防止读取过程中数据结构变化\n            if (current_head.ptr != head.load(std::memory_order_acquire).ptr)\n                continue;\n                \n            // 2. 队列状态判断\n            if (real_head == real_tail)\n            {\n                if (next == nullptr)\n                {\n                    // 情况A：队列为空\n                    return false;\n                }\n                \n                // 情况B：尾指针滞后，帮助推进\n                VersionedPtr new_tail{next, tail.load().version + 1};\n                tail.compare_exchange_strong(\n                    tail.load(), new_tail,\n                    std::memory_order_release,\n                    std::memory_order_relaxed);\n            }\n            else\n            {\n                // 情况C：正常出队\n                // 移动数据前预先加载（减少持有锁时间）\n                // 注意，我们是有哑元节点的，现在获取到的head不是真实的head，而是dummy\n                // dummy的下一个才是真实有数据的head，因此在这里取next的data\n                T* data_ptr = next->data;\n                \n                // 尝试移动头指针\n                VersionedPtr new_head{next, current_head.version + 1};\n                if (head.compare_exchange_strong(\n                    current_head, new_head,\n                    std::memory_order_release,\n                    std::memory_order_relaxed)) \n                {\n                    // 出队成功：转移数据\n                    result = std::move(*data_ptr);\n                    \n                    // 安全删除旧头节点（工业实现需延迟回收）\n                    delete data_ptr;\n                    delete real_head;  // 实际应使用危险指针回收\n                    return true;\n                }\n            }\n        }\n    }\n// ...\n```\n## 析构\n```cpp\n// ...\n    ~LockFreeMPMCQueue()\n    {\n        // 遍历删除所有节点（实际应用中需处理并发安全）\n        while (Node* node = head.load().ptr)\n        {\n            head.store({node->next, 0}, std::memory_order_relaxed);\n            delete node->data;\n            delete node;\n        }\n    }\n// ...\n```\n## 完整代码\n```cpp\n#include <atomic>\n#include <memory>\n\ntemplate<typename T>\nclass LockFreeMPMCQueue {\nprivate:\n    // 节点结构：带缓存行填充防止伪共享\n    struct Node {\n        Node() : data(nullptr), next(nullptr) {}\n        \n        T* data;  // 存储实际数据指针（避免对象拷贝开销）\n        std::atomic<Node*> next;  // 下一个节点指针\n\n        // 确保每个节点独占缓存行（64字节）\n        char padding[64 - sizeof(T*) - sizeof(std::atomic<Node*>)];\n    };\n\n    // 带版本号的指针（解决ABA问题）\n    struct alignas(16) VersionedPtr {\n        Node* ptr;\n        uint64_t version;\n    };\n\n    // 保证头尾指针不在同一缓存行\n    struct {\n        alignas(64) std::atomic<VersionedPtr> head;\n        char padding[64];  // 填充确保tail在下一个缓存行\n    };\n    alignas(64) std::atomic<VersionedPtr> tail;\n\npublic:\n    LockFreeMPMCQueue() {\n        // 初始化哑元节点（dummy node）\n        Node* dummy = new Node();\n        \n        // 头尾指针指向同一个节点\n        VersionedPtr init = {dummy, 0};\n        head.store(init, std::memory_order_relaxed);\n        tail.store(init, std::memory_order_relaxed);\n    }\n\n    ~LockFreeMPMCQueue() {\n        // 遍历删除所有节点（实际应用中需处理并发安全）\n        while (Node* node = head.load().ptr) {\n            head.store({node->next, 0}, std::memory_order_relaxed);\n            delete node->data;\n            delete node;\n        }\n    }\n\n    // 入队操作（多线程安全）\n    bool Enqueue(T value) {\n        // 1. 创建新节点并填充数据\n        Node* new_node = new Node();\n        try {\n            new_node->data = new T(std::move(value));\n        } catch (...) {\n            delete new_node;\n            return false;\n        }\n\n        // 2. CAS循环：找到真正的尾节点\n        VersionedPtr current_tail;\n        while (true) {\n            // 原子获取当前尾指针\n            current_tail = tail.load(std::memory_order_acquire);\n            Node* real_tail = current_tail.ptr;\n            \n            // 尝试将新节点链接到尾节点后面\n            Node* next = real_tail->next.load(std::memory_order_acquire);\n            \n            // 检查期间尾指针是否变化\n            if (current_tail.ptr != tail.load(std::memory_order_acquire).ptr) \n                continue;  // 发生变化则重试\n\n            if (next == nullptr) {\n                // 情况A：尾节点后是空位置（理想情况）\n                VersionedPtr new_ptr{new_node, current_tail.version + 1};\n                \n                // 关键CAS：原子更新尾节点的next指针\n                if (real_tail->next.compare_exchange_weak(\n                    next, new_node, \n                    std::memory_order_release,\n                    std::memory_order_relaxed)) \n                {\n                    break; // 链接成功，退出循环\n                }\n            } else {\n                // 情况B：发现尾指针滞后，帮助其它线程推进\n                VersionedPtr new_ptr{next, current_tail.version + 1};\n                \n                // 尝试更新尾指针到后继节点（避免竞争导致的阻塞）\n                tail.compare_exchange_strong(\n                    current_tail, new_ptr,\n                    std::memory_order_release,\n                    std::memory_order_relaxed);\n            }\n        }\n        \n        // 3. 尝试更新全局尾指针（允许失败）\n        VersionedPtr new_tail{new_node, current_tail.version + 1};\n        tail.compare_exchange_strong(\n            current_tail, new_tail,\n            std::memory_order_release,\n            std::memory_order_relaxed);\n        \n        return true;\n    }\n\n    // 出队操作（多线程安全）\n    bool Dequeue(T& result) {\n        VersionedPtr current_head;\n        Node* real_tail;\n        Node* next;\n\n        while (true) {\n            // 1. 原子获取头尾指针（关键）\n            current_head = head.load(std::memory_order_acquire);\n            Node* real_head = current_head.ptr;\n            real_tail = tail.load(std::memory_order_acquire).ptr;\n            next = real_head->next.load(std::memory_order_acquire);\n\n            // 一致性检查：防止读取过程中数据结构变化\n            if (current_head.ptr != head.load(std::memory_order_acquire).ptr)\n                continue;\n                \n            // 2. 队列状态判断\n            if (real_head == real_tail) {\n                if (next == nullptr) {\n                    // 情况A：队列为空\n                    return false;\n                }\n                \n                // 情况B：尾指针滞后，帮助推进\n                VersionedPtr new_tail{next, tail.load().version + 1};\n                tail.compare_exchange_strong(\n                    tail.load(), new_tail,\n                    std::memory_order_release,\n                    std::memory_order_relaxed);\n            } else {\n                // 情况C：正常出队\n                // 移动数据前预先加载（减少持有锁时间）\n                T* data_ptr = next->data;\n                \n                // 尝试移动头指针\n                VersionedPtr new_head{next, current_head.version + 1};\n                if (head.compare_exchange_strong(\n                    current_head, new_head,\n                    std::memory_order_release,\n                    std::memory_order_relaxed)) \n                {\n                    // 出队成功：转移数据\n                    result = std::move(*data_ptr);\n                    \n                    // 安全删除旧头节点（工业实现需延迟回收）\n                    delete data_ptr;\n                    delete real_head;  // 实际应使用危险指针回收\n                    return true;\n                }\n            }\n        }\n    }\n};\n```\n\n## 内存回收（危险指针）\n```cpp\n// Hazard Pointer简单实现（线程本地注册）\nthread_local std::vector<Node*> hp_records(2);  // 通常每个线程2个足够\n\nvoid RetireNode(Node* old)\n{\n    // 检查其他线程是否引用该节点\n    if (!IsPointerHazard(old))\n    {\n        delete old;\n    }\n    else\n    {\n        // 加入待删除列表（延迟处理）\n        retired_list.push_back(old);\n    }\n}\n```\n# 无锁是忙等待吗？\n无锁编程并不等同于忙等待（Busy-Waiting），其核心在于「非阻塞」，而非具体等待方式。​​\n1. ​**​「非阻塞」的定义​**\n    - _Lock-Free_：至少一个线程能前进\n    - _Wait-Free_：所有线程都能在有限步完成\n2. ​**​延迟与吞吐的权衡​**​\n    - ​**​忙等待​**​：牺牲CPU，以降低延迟（高频交易系统）\n    - ​**​阻塞等待​**​：加大延迟，以加大吞吐（Web服务器连接池）\n\n无锁编程可​**​根据竞争强度动态选择等待策略​**​：\n1. 低竞争时短暂自旋（利用CPU流水线）\n2. 中竞争时退避+主动让出CPU\n3. 高竞争时进入操作系统阻塞队列  \n\n​**​核心目标是以最小开销维持「至少一个线程前进」的非阻塞特性​**​，而非强制忙等待。\n\n实际无锁设计中可通过多种策略避免忙等：\n## 操作系统级阻塞等待\n```cpp\n// C++20 前（使用 futex）\nwhile (!atomic_var.compare_exchange_weak(...))\n{\n    syscall(SYS_futex, &atomic_var, FUTEX_WAIT, ...);  // 主动让出CPU\n}\n\n// C++20 后（std::atomic::wait）\natomic_var.wait(old_val, std::memory_order_relaxed);  // 线程挂起直到值变化\n```\n## 定时退避策略\n```cpp\nint retries = 0;\nwhile (!CAS(ptr, old_val, new_val))\n{\n    if (retries++ > MAX_SPIN)\n    {\n        std::this_thread::yield();     // 放弃时间片，通知调度器切换\n        retries = 0;\n    }\n    else\n    {\n        _mm_pause();                  // x86 自旋等待指令（降低CPU功耗）\n    }\n}\n```\n## 队列化竞争机制（排队锁）\n```cpp\nstruct Waiter { std::atomic<Waiter*> next; };\nstd::atomic<Waiter*> tail_{nullptr};\n\nvoid lock()\n{\n    Waiter w;\n    w.next = nullptr;\n    Waiter* prev = tail_.exchange(&w, std::memory_order_acq_rel);\n    if (prev)\n    {\n        prev->next = &w;                      // 排队\n        while (w.next.load() != &w) {}       // 等待前驱节点唤醒\n    }\n}\n\nvoid unlock()\n{\n    Waiter* w = ...;\n    if (!w->next)\n    {                           // 无后续等待者\n        if (tail_.compare_exchange_strong(w, nullptr)) return;\n    }\n    while (!w->next.load())    // 等待后继节点就绪\n    {}\n    // 唤醒下一个\n    w->next.load()->next.store(w->next.load()->next, ...); \n}\n```\n## 对比\n|**策略​**​|实现方式|适用场景|CPU占用|延迟|\n|---|---|---|---|---|\n|​**​忙等待​**​|`while(!CAS)`|极低延迟场景（<100ns）|100%核心|极低|\n|​**​主动退让​**​|`std::this_thread::yield()`|用户态竞争适中|< 30%|微秒级|\n|​**​操作系统阻塞​**​|`futex` / `atomic::wait`|高竞争/长等待|~0%|毫秒级|\n|​**​队列化调度​**​|MCS锁等排队机制|严格公平性要求|随队列转移|亚毫秒级|\n## 工业级案例\n### Linux内核Futex\n- 首次CAS竞争失败后，通过`FUTEX_WAIT`系统调用挂起线程\n- 解锁时通过`FUTEX_WAKE`唤醒等待线程\n### ​​Java的AQS（Abstract Queued Synchronizer）​\n```java\nfinal boolean acquireQueued(...)\n{\n    for (;;)\n    {\n        if (tryAcquire(arg)) return true;  // 无锁尝试\n        if (shouldParkAfterFailedAcquire()) \n            LockSupport.park(this);       // 挂起线程（JVM层面）\n    }\n}\n```\n### C++20原子等待\n```cpp\nstd::atomic<int> flag(0);\n// 消费者\nwhile (!flag.wait(1, std::memory_order_seq_cst)); // 阻塞直至值!=1\n// 生产者\nflag.store(2);\nflag.notify_all();  // 唤醒所有等待者\n```\n# 总线锁和缓存锁\n## 总线锁（Bus Lock）\n当CPU执行带`LOCK`前缀的指令（如`CMPXCHG`）时，会通过芯片组发出​**​硬件信号​**​，​**​独占整个内存总线（Bus）​**​ 。此时其他CPU的所有内存访问请求将被阻塞，直到当前操作完成。\n\n```mermaid\nsequenceDiagram\n    CPU核心A->>内存总线: LOCK#信号（总线锁定）\n    内存总线->>所有CPU: 阻塞其他内存请求\n    CPU核心A->>内存: 执行原子操作（如CAS）\n    内存总线->>所有CPU: 解锁\n```\n特点\n- ​**​全局性锁定​**​：锁定期间所有内存操作均被阻塞（包括非竞争数据）\n- ​**​性能开销大​**​：原子操作串行化，多核性能急剧下降\n- ​**​兼容性强​**​：早期x86处理器的唯一选择（如80486）\n## 缓存锁（Cache Locking）—— MESI优化\n核心：缓存一致性协议（Cache Coherence）\n\n现代CPU通过​**​MESI协议​**​（Modified/Exclusive/Shared/Invalid）维护多核缓存一致性：\n\n```mermaid\ngraph LR\n    Modified -->|写回| Invalid\n    Exclusive -->|其他核读| Shared\n    Shared -->|写| Modified\n    Invalid -->|写| Exclusive\n```\n### 缓存锁的触发条件（以Intel CPU为例）\n当原子操作访问的数据满足：\n1. ​**​对齐在缓存行内​**​（通常64字节对齐）\n2. ​**​目标地址未跨缓存行​**​（Non-split Access）\n3. ​**​CPU支持缓存锁定技术​**​（几乎所有现代处理器）\n\n### 工作流程\n```cpp\n// 示例：两个线程在核 0 和核 1 上执行原子操作\n// 初始状态：变量 X 被核 0 和核 1 缓存（Shared状态）\n1. 核0执行原子操作（如X++）:\n   - 发出RFO（Request For Ownership）消息\n   - 其他核心将X的缓存行置为Invalid\n   - 核0将缓存行置为Modified状态\n   - 执行修改（未触发总线锁）\n2. 核1尝试操作X：\n   - 发现缓存失效（Invalid）\n   - 从核0的缓存中读取最新数据（缓存行状态转为Shared）\n```\n### 避免缓存冲突\n#### 内存对齐避免总线锁\n```cpp\n// 错误：变量可能跨缓存行\nstruct Unaligned\n{\n    char padding[62]; // 62字节填充\n    std::atomic<int> x; // 位于62-66字节（跨越两个缓存行）\n};\n\n// 正确：强制缓存行对齐\nstruct alignas(64) Aligned\n{\n    std::atomic<int> x; // 独占一个缓存行\n};\n```\n>检测方法：Linux下`perf c2c`可检测缓存行冲突（False Sharing）\n\n#### 写竞争下的性能差异​\n当两个CPU核心频繁写​**​同一缓存行​**​时：\n- ​**​缓存锁场景​**​：缓存行在`Modified`↔`Invalid`状态间震荡，产生大量RFO消息\n- ​**​解决方案​**​：​**​伪共享隔离（False Sharing Elimination）**\n\n```cpp\n// 多核计数器优化（每个核独占缓存行）\nstruct PerCoreCounter\n{\n    alignas(64) std::atomic<int> value;\n};\nPerCoreCounter counters[CPU_CORES]; \n```\n## 特殊场景总线锁不可避免\n```asm\nLOCK XCHG [mem], reg  ; 显式LOCK前缀\nCMPXCHG16B m128       ; 128位跨缓存行操作\n一个未对齐的LOCK操作    ; 如对跨64字节边界的int操作\n```\n## 对比\n| ​**​特征​**​   | 总线锁           | 缓存锁             |\n| ------------ | ------------- | --------------- |\n| ​**​锁定范围​**​ | 整个内存总线        | 单个缓存行           |\n| ​**​性能影响​**​ | 全局停顿，性能损失严重   | 仅影响涉及特定缓存行的操作   |\n| ​**​触发条件​**​ | `LOCK`前缀指令    | 内存对齐且未跨缓存行的原子操作 |\n| ​**​实现技术​**​ | 硬件信号硬阻塞       | MESI缓存一致性协议     |\n| ​**​现代应用​**​ | 仅作兜底（如跨缓存行操作） | 99%原子操作的默认实现    |\n| ​**​能耗​**​   | 高（总线开关）       | 低（仅缓存状态切换）      |\n","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"单例模式","url":"/设计模式/单例模式/","content":"# 内容\n\n1. 单例模式简介\n2. 饿汉式单例模式\n3. 懒汉式单例模式\n4. 线程安全的单例模式\n# 单例模式简介\n\n单例模式指的是，无论怎么获取，**永远只能得到该类类型的唯一一个实例对象**，那么设计一个单例就必须要满足下面三个条件：\n1. 构造函数私有化，这样用户就不能任意定义该类型的对象了\n2. 定义该类型唯一的对象\n3. 通过一个static静态成员方法返回唯一的对象实例\n# 饿汉式（本身线程安全）\n\n**饿汉式**单例模式，顾名思义，就是程序启动时就实例化了该对象，并没有推迟到第一次使用该对象时再进行实例化；如果运行过程中没有使用到，该实例对象就被浪费掉了。\n\n```cpp\nclass CSingleton\n{\npublic:\n\tstatic CSingleton* getInstance()\n\t{\n\t\treturn &single;\n\t}\nprivate:\n\tstatic CSingleton single;\n\tCSingleton() { cout << \"CSingleton()\" << endl; }\n\t~CSingleton() { cout << \"~CSingleton()\" << endl; }\n\tCSingleton(const CSingleton&) = delete; // 防止外部使用拷贝构造产生新的对象\n};\nCSingleton CSingleton::single;\n\nint main()\n{\n\tCSingleton *p1 = CSingleton::getInstance();\n\tCSingleton *p2 = CSingleton::getInstance();\n\tCSingleton *p3 = CSingleton::getInstance();\n\tcout << p1 << \" \" << p2 << \" \" << p3 << endl;\n\treturn 0;\n}\n\n```\n打印`0016E138 0016E138 0016E138`\n可以看到，三次获取的CSingleton对象都是同一个对象实例，这是一个**饿汉式**单例模式。\n# 懒汉式（线程不安全）\n\n**懒汉式**单例模式，顾名思义，将对象的实例化延迟到第一次使用它的时刻。\n\n```cpp\nclass CSingleton\n{\npublic:\n\tstatic CSingleton* getInstance()\n\t{\n\t\tif (nullptr == single)\n\t\t{\n\t\t\tsingle = new CSingleton();\n\t\t}\n\t\treturn single;\n\t}\nprivate:\n\tstatic CSingleton *single;\n\tCSingleton() { cout << \"CSingleton()\" << endl; }\n\t~CSingleton() { cout << \"~CSingleton()\" << endl; }\n\tCSingleton(const CSingleton&) = delete;\n};\nCSingleton* CSingleton::single = nullptr;\n\nint main()\n{\n\tCSingleton *p1 = CSingleton::getInstance();\n\tCSingleton *p2 = CSingleton::getInstance();\n\tCSingleton *p3 = CSingleton::getInstance();\n\tcout << p1 << \" \" << p2 << \" \" << p3 << endl;\n\treturn 0;\n}\n\n```\n\n符合单例模式的要求，三次获取的都是同一个对象，而且程序启动时，只对single指针初始化了空值，等第一次调用`getInstance`函数时，由于single指针为`nullptr`，才进行对象的实例化，所以是一个**懒汉式**单例模式。\n# 没有释放单例对象 - 内存泄漏\n但是上面的代码有一个问题：只有new没有delete！作为`C++`开发者，资源的分配和回收，我们必须要考虑清楚，不能糊涂。\n\n这个问题确实棘手，首先资源的释放如果交给用户来操作，难免会忘记写delete，又或者多次delete，可能错误释放野指针。我们可以利用static静态对象在程序结束时自动析构这么一个特征，给出如下释放资源的代码：在单例类中定义一个嵌套类，在嵌套类的析构函数中，自动释放外层类的资源。\n\n```cpp\nclass CSingleton\n{\npublic:\n\tstatic CSingleton* getInstance()\n\t{\n\t\tif (nullptr == single)\n\t\t{\n\t\t\tsingle = new CSingleton();\n\t\t}\n\t\treturn single;\n\t}\nprivate:\n\tstatic CSingleton *single;\n\tCSingleton() { cout << \"CSingleton()\" << endl; }\n\t~CSingleton() { cout << \"~CSingleton()\" << endl; }\n\tCSingleton(const CSingleton&) = delete;\n\n\t// 定义一个嵌套类，在该类的析构函数中，自动释放外层类的资源\n\tclass CRelease\n\t{\n\tpublic:\n\t\t~CRelease() { delete single; }\n\t};\n\t// 通过该静态对象在程序结束时自动析构的特点，来释放外层类的对象资源\n\tstatic CRelease release;\n};\nCSingleton* CSingleton::single = nullptr;\nCSingleton::CRelease CSingleton::release;\n\nint main()\n{\n\tCSingleton *p1 = CSingleton::getInstance();\n\tCSingleton *p2 = CSingleton::getInstance();\n\tCSingleton *p3 = CSingleton::getInstance();\n\tcout << p1 << \" \" << p2 << \" \" << p3 << endl;\n\treturn 0;\n}\n\n```\n\n# 线程安全的懒汉式 - 锁\n\n在开发服务器程序的时候，经常会用到多线程，多线程要考虑代码的线程安全特性，不能让代码在多线程环境下出现竞态条件，否则就要进行线程互斥操作，我们来考虑一下上面两种单例模式，如果用在多线程环境当中，是否是线程安全的单例模式。\n1. 饿汉单例模式的线程安全特性\n    1. 饿汉单例模式中，单例对象定义成了一个static静态对象，它是在程序启动时，main函数运行之前就初始化好的，因此不存在线程安全问题，可以放心在多线程环境中使用。\n2. 懒汉单例模式的线程安全特性\n    1. 懒汉单例模式，获取单例对象的方法如下：\n\n```cpp\nstatic CSingleton* getInstance()\n{\n    if (nullptr == single)\n    {\n        single = new CSingleton();\n    }\n    return single;\n}\n```\n很明显，这个`getInstance`是个不可重入函数，也就它在多线程环境中执行，会出现竞态条件问题，首先搞清楚这句代码，`single = new CSingleton()`它会做三件事情，开辟内存，调用构造函数，给single指针赋值，那么在多线程环境下，就有可能出现如下问题：\n1. 线程A先调用getInstance函数，由于single为`nullptr`，进入if语句\n2. new操作先开辟内存，此时A线程的CPU时间片到了，切换到B线程\n3. B线程由于single为`nullptr`，也进入if语句了，开始new操作\n\n很明显，上面两个线程都进入了if语句，都试图new一个新的对象，不符合单例模式的设计，那该如何处理呢？应该为getInstance函数内部加锁，在线程间进行互斥操作。\n```cpp\n#include <iostream>\n#include <pthread.h>\nusing namespace std;\n\nclass CSingleton\n{\npublic:\n    static CSingleton* getInstance()\n  \t{\n  \t\t// 获取互斥锁\n  \t\tpthread_mutex_lock(&mutex);\n  \t\tif (nullptr == single)\n  \t\t{\n  \t\t\tsingle = new CSingleton();\n  \t\t}\n  \t\t// 释放互斥锁\n  \t\tpthread_mutex_unlock(&mutex);\n  \t\treturn single;\n  \t}\nprivate:\n  \tstatic CSingleton *single;\n  \tCSingleton() { cout << \"CSingleton()\" << endl; }\n  \t~CSingleton() \n  \t{\n  \t\tpthread_mutex_destroy(&mutex); // 释放锁\n  \t\tcout << \"~CSingleton()\" << endl; \n  \t}\n  \tCSingleton(const CSingleton&);\n  \n  \tclass CRelease\n  \t{\n  \tpublic:\n  \t\t~CRelease() { delete single; }\n  \t};\n  \tstatic CRelease release;\n  \t\n  \t// 定义线程间的互斥锁\n  \tstatic pthread_mutex_t mutex;\n};\nCSingleton* CSingleton::single = nullptr;\nCSingleton::CRelease CSingleton::release;\n// 互斥锁的初始化\npthread_mutex_t CSingleton::mutex = PTHREAD_MUTEX_INITIALIZER;\n\nint main()\n{\n    CSingleton *p1 = CSingleton::getInstance();\n    CSingleton *p2 = CSingleton::getInstance();\n    CSingleton *p3 = CSingleton::getInstance();\n    return 0;\n}\n```\n上面的代码，是一个线程安全的懒汉单例模式，但是效率太低，因为每次调用getInstance都需要加锁解锁，除了第一次调用，后面对getInstance函数持续的加解锁实在时没有必要，所以这里需要使用`锁+双重判断`，也叫**双重检验锁**，把上面的getInstance函数代码修改如下：\n```cpp\nstatic CSingleton* getInstance()\n{\n  \tif (nullptr == single)\n  \t{\n        // 获取互斥锁\n        pthread_mutex_lock(&mutex);\n        /* \n            这里需要再添加一个if判断，否则当两个\n            线程都进入这里，又会多次new对象，不符合单例模式\n        */\n        if(nullptr == single)\n        {\n            single = new CSingleton();\n        }\n        // 释放互斥锁\n        pthread_mutex_unlock(&mutex);\n    }\n\n    return single;\n}\n```\n如果把mutex封装为一个类，那么更加符合面向对象的思想。\n```cpp\n#include <iostream>\n#include <pthread.h>\nusing namespace std;\n\n// 对互斥锁操作的封装\nclass CMutex\n{\npublic:\n    CMutex(){pthread_mutex_init(&mutex, NULL);}  // 初始化锁\n    ~CMutex(){pthread_mutex_destroy(&mutex);}  // 销毁锁 \n    void lock(){pthread_mutex_lock(&mutex);}  // 获取锁\n    void unlock(){pthread_mutex_unlock(&mutex);}  // 释放锁\nprivate:\n    pthread_mutex_t mutex;\n};\n\nclass CSingleton\n{\npublic:\n    static CSingleton* getInstance()\n    {\n        if (nullptr == single)\n        {\n            // 获取互斥锁\n            mutex.lock();\n            /* \n                这里需要再添加一个if判断，否则当两个\n                线程都进入这里，又会多次new对象，不符合\n                单例模式的涉及\n            */\n            if(nullptr == single)\n            {\n                single = new CSingleton();\n            }\n            // 释放互斥锁\n            mutex.unlock();\n        }\n\n        return single;\n    }\nprivate:\n    static CSingleton *single;\n    CSingleton() { cout << \"CSingleton()\" << endl; }\n    ~CSingleton() { cout << \"~CSingleton()\" << endl;}\n    CSingleton(const CSingleton&);\n\n    class CRelease\n    {\n    public:\n        ~CRelease() { delete single; }\n    };\n    static CRelease release;\n\n    //线程间的静态互斥锁\n    static CMutex mutex;\n};\nCSingleton* CSingleton::single = nullptr;\nCSingleton::CRelease CSingleton::release;\n// 定义互斥锁静态对象\nCMutex CSingleton::mutex;\n\nint main() \n{\n    CSingleton *p1 = CSingleton::getInstance();\n    CSingleton *p2 = CSingleton::getInstance();\n    CSingleton *p3 = CSingleton::getInstance();\n    return 0;\n}\n```\n输出结果：\n```\nCSingleton()\n~CSingleton()\n```\n# 线程安全的懒汉式 - `call_once`\n```cpp\n#include <iostream>\n#include <mutex> // call_once\nusing namespace std;\nclass CSingleton\n{\npublic:\n\tstatic CSingleton* getInstance()\n\t{\n    \t// 确保线程安全的只初始化一次\n\t\tstd::call_once(once_flag, init);\n\t\treturn single;\n\t}\nprivate:\n\tstatic void init()\n\t{\n    \t// 无需检查 if (!single)，因为 call_once 保证只执行一次\n\t\tsingle = new CSingleton;\n\t}\n\tstatic CSingleton * single;\n\tstatic std::once_flag once_flag;\n\tCSingleton() { cout << \"CSingleton()\" << endl; }\n\t~CSingleton() { cout << \"~CSingleton()\" << endl; }\n\tCSingleton(const CSingleton&) = delete;\n\tCSingleton& operator=(const CSingleton&) = delete;\n\t\n\tclass CRelease\n\t{\n\tpublic:\n\t\t~CRelease() { delete single; }\n\t};\n\tstatic CRelease release;\n};\n// 类外定义\nCSingleton* CSingleton::single = nullptr;\nstd::once_flag CSingleton::once_flag;\nCSingleton::CRelease CSingleton::release; // 程序结束时自动调用析构\nint main()\n{\n\tCSingleton* p1 = CSingleton::getInstance();\n\tCSingleton* p2 = CSingleton::getInstance();\n\tCSingleton* p3 = CSingleton::getInstance();\n\treturn 0;\n}\n```\n运行结果：\n```\nCSingleton()\n~CSingleton()\n```\n# 更简洁的线程安全的懒汉式\n\n下面这个懒汉单例模式是否是线程安全的，代码如下：\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass CSingleton\n{\npublic:\n\tstatic CSingleton* getInstance()\n\t{\n\t\tstatic CSingleton single; // 懒汉式单例模式，定义唯一的对象实例\n\t\treturn &single;\n\t}\nprivate:\n\tCSingleton() { cout << \"CSingleton()\" << endl; }\n\t~CSingleton() { cout << \"~CSingleton()\" << endl; }\n\tCSingleton(const CSingleton&) = delete;\n};\nint main()\n{\n\tCSingleton *p1 = CSingleton::getInstance();\n\tCSingleton *p2 = CSingleton::getInstance();\n\tCSingleton *p3 = CSingleton::getInstance();\n\treturn 0;\n}\n```\n\n上面的单例模式在多线程环境中使用时，会不会出现这种情况，线程A第一次调用getInstance函数的时候，single对象第一次初始化，此时线程B也调用getInstance函数，会不会也进行single对象的初始化呢，因为此时线程A并没有初始化完single？\n\n在Linux环境中，通过g++编译上面的代码，命令如下：\n`g++ -o main main.cpp -g`\n生成可执行文件main，用gdb进行调试，到getInstance函数，并打印该函数的汇编指令，如下：\n\n![image-20220410090711941](../../images/单例模式/image-20220410090711941.png)\n\n可以看到，**对于static静态局部变量的初始化，编译器会自动对它的初始化进行加锁和解锁控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量，因此上面的懒汉单例模式是线程安全的单例模式！**\n# 总结\n\n一个看似小小的单例模式，却可以串联面向对象思想，到软件设计思想，到设计模式，再到Linux操作系统的进程和线程模型，线程间的互斥和通信。\n\n---\n参考文献：[C++设计模式 - 单例模式_单例模式大秦坑王-CSDN博客](https://blog.csdn.net/QIANGWEIYUAN/article/details/88544524?spm=1001.2014.3001.5502)","categories":["设计模式","创建型模式"]},{"title":"cmake","url":"/项目/cmake/","content":"# 概述\n\n是个编译构建工具，相当于对makefile以及其之下的g++/gcc包装了一层。makefile语法比较难记，而cmake比较容易，适合用来编译大型项目。\n\n# 示例\n\n```cmake\n# 环境变量 PROJECT_SOURCE_DIR\ncmake_minimum_required(VERSION 3.0.0)\n\nproject(distributed-system-framework)\nset(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} -g)\n# 可执行文件的输出路径，PROJECT_SOURCE_DIR为项目的根目录\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)\n\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\ninclude_directories(${PROJECT_SOURCE_DIR}/include/utils)\ninclude_directories(${PROJECT_SOURCE_DIR}/include/logger)\n# 指明CMakelists的子目录位置\nadd_subdirectory(src)\n```\n\n# 尝试\n\n首先文件名是CMakeLists.txt，严格大小写。\n\n写一个hello world，用cmake编译。\n\n```cmake\n# ~/vscode/0411_test/CMakeLists.txt\ncmake_minimum_required(VERSION 3.0.0)\nproject(helloworld)\n# 指明项目下面的源文件都有哪些，\".\"指当前目录，SRC是自定义的变量名\naux_source_directory(. SRC)\n# 指定二进制可执行文件的输出路径\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)\n\n# 附加编译时的参数\nadd_definitions(\"-g\")\n# 用${SRC}目录下的全部源文件生成\"helloworld\"可执行文件\nadd_executable(helloworld ${SRC})\n```\n\n```cpp\n// ~/vscode/0411_test/main.c\n#include<stdio.h>\nint main()\n{\n    printf(\"\\033[35mhello\\n\");\n    printf(\"\\033[36mhello\\n\");\n    printf(\"\\033[37mhello\\n\");\n    return 0;\n}\n```\n\n```bash\n# 当前目录处于~/vscode/0411_test\nmkdir build\ncd build\ncmake .. # cmake寻找上级目录中CMakeLists，把构建文件输出到当前目录（build目录）\nmake # cmake构建到build目录下一个Makefile文件，在此目录下make即可编译项目\n# 因为CMakeLists.txt指明把可执行文件生成到项目根目录下的bin目录，所以make也到bin\ncd ../bin\n./helloworld\n```\n\n# 重写muduo项目下的cmake\n\n```cmake\ncmake_minimum_required(VERSION 2.5)\nproject(mymuduo)\n\n#mymuduo 最终编译成so动态库，设置动态库的路径\nset(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)#注意不是OUTPUT_DIRECTORY.这两者有区别\n#设置为调试模式 以及 声明C++11语言标准\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g -std=c++11 -fPIC\")#在较新的编译器后需要加-fPIC，以示生成的是动态库\n#定义参与编译的源文件 起一个别名\naux_source_directory(. SRC_LIST)\n#编译生成动态库mymuduo\nadd_library(mymuduo SHARED ${SRC_LIST})\n```\n\n","categories":["项目","Linux"]},{"title":"git","url":"/项目/git/","content":"\n# 内容\n\n1. 新建仓库\n1. git init\n1. git remote add\n\n# 如何让本地指向远程仓库\n\n1. 创建一个目录，使用git init命令将其变为一个可以通过git管理的仓库\n\n   ```bash\n   1.mkdir一个目录\n   2.cd 创建的目录\n   3.git init .\n   ```\n\n2. git remote是管理远程仓库的命令，git remote add \\[name\\] \\[url\\]可以给当前目录下的git添加一个远程仓库。这里的url我填的是gitee仓库的ssh地址。\n\n   ```bash\n   git remote add mygitee git@gitee.com:mrcan/distributed-system-framework.git\n   # git remote -v 可以查看远程仓库的信息\n   ```\n\n# 本地、远程进行同步\n\n1. 生成密钥\n\n   ```bash\n   ssh-keygen -t rsa -C \"邮箱\"\n   ```\n\n2. 切换到家目录下的\".ssh\"文件夹，发现有id\\_rsa和id\\_rsa.pub，后者是公钥，公钥给别人，连接时根据其他用户输入的公钥经过加密算法与服务器上的私钥比对。\n\n3. cat id\\_rsa.pub，把公钥内容拷贝下来，在gitee上的项目管理中找到部署公钥管理。\n\n4. 配置git全局用户名、邮箱\n\n   ```bash\n   git config --global user.name 'xcg'\n   git config --global user.email '1933966629@qq.com'\n   ```\n\n   \n\n5. 使用git branch -r查看远程的分支有哪些，或者-a查看所有分支（包括本地分支）\n","categories":["项目","Linux","git"]},{"title":"SGI-STL和Nginx内存池剖析","url":"/项目/SGI-STL和Nginx内存池剖析/","content":"# 内容\n\n内存池是为了更高效地管理小块内存的频繁开辟、释放。\n1. `C++` STL：标准模板库。\n2. SGI STL：第三方厂商开发的，后来被纳入`C++`标准，成为了`C++` STL中管理内存的底层实现。\n3. Nginx内存池设计\n# `C++ STL`空间配置器\n\n先用vector举个例子\n\n```cpp\ntemplate<typename T, typename _Alloc = allocator<T>>\nclass vector\n{\n    \n};\n```\n\n可以看到，vector第二个模板参数是一个空间配置器。\n\n主要包含了四个方法：\n1. `allocate`：负责给容器开辟内存空间=>`malloc`\n2. `deallocate`：负责释放容器内存空间=>`free`\n3. `construct`：负责在容器中构造对象=>`定位new`：是基于已经开辟好了的容器空间中直接构造的。\n4. `destroy`：负责析构容器中的对象=>`p->~T()`\n\n空间配置器的核心作用：\n1. 拆开了new的两个操作——对象的内存开辟、对象构造；\n2. 拆开了delete的两个操作——对象的析构，内存的内存释放。\n把空间和对象本身分开，在容器这个场景下更为适合。\n# SGI STL 的两级 allocator\n\n提供了两个allocator的实现：\n1. 一级allocator，实际上就是`malloc/free`；\n2. 二级allocator，是基于内存池的内存管理。\n本文主要剖析SGI的二级allocator，即内存池的实现。\n\n通过阅读源码，发现：\n\nSGI STL底层对于容器的对象的构造、析构是通过自定义的全局模板函数Construct和Destroy完成的。\n而点进去发现本质上仍是通过**定位new**、**调用对象的析构**函数完成的。这些都是内存申请、释放工作之外的动作。\n\n因此，可以推断，SGI STL的空间配置器**主要工作的区别在于 allocate 和 deallocate**，即**对容器内存申请、释放的管理**。\n# SGI STL 内存池的实现\n内存池的粒度信息\n```cpp\nenum { _ALIGN = 8 };\nenum { _MAX_BYTES = 128 };\nenum { _NFREELISTS = 16 };\n```\n每一个内存chunk块的头信息\n```cpp\nunion _Obj\n{\n    union _Obj* _M_free_list_link;\n    char _M_client_data[1];\n};\n```\n组织所有自由链表的指针数组。\n这是静态变量，多线程共享，volatile避免了读取缓存的脏数据。\n```cpp\nstatic _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];\n```\n图示：\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250807041312313.png)\n一个数组，第 1 个位置存放的是 8 字节的内存池，第 2 个位置存放的是 16 字节的内存池，...，最后一个位置存放的是 128 字节的内存池。数组的大小和每个位置对应的字节数由**内存池的粒度信息**决定。\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250807041752139.png)\n## `allocate(size_t)`\n定义在`stl_alloc.h`中\n\n统一的allocate接口。外部申请 n 个字节。如果是大块内存，则普通malloc。\n如果是128字节及以下的内存，则会从内存池中分配，这就是二级空间配置。\n\n```cpp\n  static void* allocate(size_t __n)\n  {\n    void* __ret = 0;\n\n    if (__n > (size_t) _MAX_BYTES)\n    {\n      __ret = malloc_alloc::allocate(__n);\n    }\n    else  // 核心代码\n    {\n        // 返回 freelist 的某下标的指针（二级指针）\n      _Obj* __STL_VOLATILE* __my_free_list\n          = _S_free_list + _S_freelist_index(__n);\n      // Acquire the lock here with a constructor call.\n      // This ensures that it is released in exit or during stack\n      // unwinding.\n      \n#     ifndef _NOTHREADS\n      /*REFERENCED*/\n      _Lock __lock_instance;\n#     endif\n        // 去看 freelist 这个下标，有没有已开辟且由空闲的块\n      _Obj* __RESTRICT __result = *__my_free_list;\n      if (__result == nullptr)  // 没有空闲块，或者没开辟。\n      {\n        __ret = _S_refill(_S_round_up(__n));\n      }\n      else                      // 有空闲块。\n      {\n          // 让 这个下标 指向下一块空闲块。（见_Obj联合体定义）\n        *__my_free_list = __result -> _M_free_list_link;\n          // 返回的是 __result 这个空闲块\n        __ret = __result;\n      }\n    }\n    return __ret;\n  };\n```\n###  `_S_freelist_index(size_t)`\n用于返回freelist的下标，0下标存放的是8字节的内存池块。1下标存放的是16字节的内存池块。以此类推。\n比如，\n外部申请 1 字节，则 $(1 + 8 - 1) / 8 - 1 = 1 - 1 = 0$\n外部申请 7 字节，则 $(7 + 8 - 1) / 8 - 1 = 1 - 1 = 0$\n外部申请 8 字节，则 $(8 + 8 - 1) / 8 - 1 = 1 - 1 = 0$\n外部申请 9 字节，则 $(9 + 8 - 1) / 8 - 1 = 2 - 1 = 1$\n```cpp\nstatic  size_t _S_freelist_index(size_t __bytes)\n{\n    return (__bytes + (size_t)_ALIGN - 1 ) / (size_t)_ALIGN      - 1;\n}\n```\n### `_S_round_up(size_t)`\n外部申请 n 字节，返回的是 n 字节对应的在内存池块中，一小块的实际大小（8的整数倍）。\n类似于向上取整（取8的整倍数的最小值），比如输入1到8，输出8。输入9到16，输出16。（输入0，输出0）\n比如，\n外部申请 1 字节，则 $(1 + 8 - 1) \\& \\sim(8 - 1) = 8 \\& \\sim(7) = 1000 \\& \\sim(0111) = 1000 \\& 1000 = 8$\n外部申请 7 字节，则 $(7 + 8 - 1) \\& \\sim(15 - 1) = 15 \\& \\sim(7) = 1110 \\& \\sim(0111) = 1110 \\& 1000 = 8$\n外部申请 8 字节，则 $(8 + 8 - 1) \\& \\sim(16 - 1) = 15 \\& \\sim(7) = 1111 \\& \\sim(0111) = 1111 \\& 1000 = 8$\n外部申请 9 字节，则 $(9 + 8 - 1) \\& \\sim(17 - 1) = 16 \\& \\sim(7) = 10000 \\& \\sim(00111) = 10000 \\& 11000 = 16$\n```cpp\nstatic size_t\n_S_round_up(size_t __bytes) \n{\n    return (__bytes + (size_t)_ALIGN - 1) & ~((size_t)_ALIGN - 1);\n}\n```\n## `_S_refill(size_t)`\n调用`_S_chunk_alloc(__n, __nobjs)`，在内存池块中尽量找一个合适的小字节块。\n`_S_chunk_alloc`内部会帮你处理底层的开辟内存池，处理内存碎片，管理内存池的指示信息等等。\n由于`_S_chunk_alloc`第二个参数`__nobjs`传入的是引用，有可能`__nobjs`会被改变。\n调用之前，`__nobjs`是我们想要申请的小字节块的个数。\n调用结束后，`__nobjs`更新为了实际分配到的小字节块的个数。\n如果是 1 ，此次分配完之后，这个内存池块正好用完了，不构建freelist下标的链表。\n其他情况，构建相应的freelist下标的链表。\nfor循环中做的是遍历内存池大块中的每个单元小块，联合体`_Obj*`的`_M_free_list_link`指向紧挨着的下一个单元小块。\n```cpp\n/* Returns an object of size __n, and optionally adds to size __n free list.*/\n/* We assume that __n is properly aligned.                                */\n/* We hold the allocation lock.                                         */\ntemplate <bool __threads, int __inst>\nvoid*\n__default_alloc_template<__threads, __inst>::_S_refill(size_t __n)\n{\n    int __nobjs = 20;\n    char* __chunk = _S_chunk_alloc(__n, __nobjs);\n    \n    _Obj* __STL_VOLATILE* __my_free_list;\n    _Obj* __result;\n    _Obj* __current_obj;\n    _Obj* __next_obj;\n    int __i;\n\n    if (1 == __nobjs) return(__chunk);\n    \n    __my_free_list = _S_free_list + _S_freelist_index(__n);\n\n    /* Build free list in chunk */\n    __result = (_Obj*)__chunk;\n    *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);\n    for (__i = 1; ; __i++)\n    {\n        __current_obj = __next_obj;\n        __next_obj = (_Obj*)((char*)__next_obj + __n);\n        if (__nobjs - 1 == __i)\n        {\n            __current_obj -> _M_free_list_link = 0;\n            break;\n        }\n        else\n        {\n            __current_obj -> _M_free_list_link = __next_obj;\n        }\n    }\n    return(__result);\n}\n```\n图示：\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250807041752139.png)\n## `_S_chunk_alloc(size_t, int& nobjs)`\n在内存池块中尽量找一个合适的小字节块。\n期间，可能会改变外部传入的`__nobjs`。（因为是引用，外部会受影响）\n\n`__total_bytes`记录的是欲开辟的内存池大小（根据`__nobjs`，这个是小字节块数）。\n`__bytes_left`指的是`_S_end_free - _S_start_free`，指目前未被开发的大小。\n### `__bytes_left`还足够，返回，无需开辟新空间\n如果`__bytes_left`还足够（至少是 1 个小字节块），则返回`_S_start_free`。同时移动`_S_start_free`到新的位置。\n成功返回。无需额外操作。\n\n---\n### `__bytes_left`不足，开辟新的更大的内存池块\n如果`__bytes_left`不足，则将要开辟新的更大的内存池块。`__bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size >> 4)`\n#### `__bytes_left > 0`，头插到合适的一个链表，管理这个内存碎片\n如果`__bytes_left > 0`。这时，为了不浪费`__bytes_left`而造成内存碎片，把这部分尚余的小内存给其对应的freelist下标的链头插。比如，剩余 32 字节，则找下标 3 ，**头插**进去。（见下文图示）\n#### 开辟新的大块内存_malloc正常\n以下是`__bytes_left`不足时，都需要做的操作，目的是开辟新的大块内存。返回的地址赋给`_S_start_free`。\n\n---\n如果malloc正常（`malloc返回 != 0`），更新`_S_heap_size += __bytes_to_get;`，更新`_S_end_free = _S_start_free + __bytes_to_get;`。\n\nmalloc成功，递归调用`return(_S_chunk_alloc(__size, __nobjs));`。\n#### 开辟新的大块内存_malloc失败：找内存池中已开辟的大单元链表的空间\n---\n如果malloc失败（`malloc返回 == 0`）。则处理：\n遍历freelist的下标各个内存池块。从`size_t __n`对应的freelist下标，依次往后找有没有还有空闲的。\n\n`__i`初始化为`__n`，循环，每次`__i += (size_t) _ALIGN`（即加8）。比如，`__n`等于 40 字节，我们依次去找40、48、56等等的freelist下标的内存池块，看看有没有能分配出来空间的。\n\n如果有，则`_S_start_free`指向第一个空闲块。更新`_S_end_free = _S_start_free + __i;`\n好了，成功在更大单元的内存池块找到，递归调用`return(_S_chunk_alloc(__size, __nobjs));`。\n#### 开辟新的大块内存_malloc失败：异常处理\n---\n如果以上的for循环找了后面更大单元的内存池块，仍没有可用空间，则是系统内存不足的迹象：\n需要调用`malloc_alloc::allocate(__bytes_to_get);`。\n内部最后一次进行普通malloc的挣扎。\n如果malloc仍然返回 0 ，则进行异常处理（绑定的回调）。\n\n---\n\n```cpp\n/* We allocate memory in large chunks in order to avoid fragmenting     */\n/* the malloc heap too much.                                            */\n/* We assume that size is properly aligned.                             */\n/* We hold the allocation lock.                                         */\ntemplate <bool __threads, int __inst>\nchar*\n__default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size, \n                                                            int& __nobjs)\n{\n    char* __result;\n    size_t __total_bytes = __size * __nobjs;\n    size_t __bytes_left = _S_end_free - _S_start_free;\n\n    if (__bytes_left >= __total_bytes)\n    {\n        __result = _S_start_free;\n        _S_start_free += __total_bytes;\n        return(__result);\n    }\n    else if (__bytes_left >= __size)\n    {\n        __nobjs = (int)(__bytes_left / __size);\n        __total_bytes = __size * __nobjs;\n        __result = _S_start_free;\n        _S_start_free += __total_bytes;\n        return(__result);\n    }\n    else\n    {\n        size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n        // Try to make use of the left-over piece.\n        if (__bytes_left > 0)\n        {\n            _Obj* __STL_VOLATILE* __my_free_list =\n                        _S_free_list + _S_freelist_index(__bytes_left);\n\n            ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n            *__my_free_list = (_Obj*)_S_start_free;\n        }\n        _S_start_free = (char*)malloc(__bytes_to_get);\n        if (0 == _S_start_free)\n        {\n            size_t __i;\n            _Obj* __STL_VOLATILE* __my_free_list;\n            _Obj* __p;\n            // Try to make do with what we have.  That can't\n            // hurt.  We do not try smaller requests, since that tends\n            // to result in disaster on multi-process machines.\n            for (__i = __size; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN)\n            {\n                __my_free_list = _S_free_list + _S_freelist_index(__i);\n                __p = *__my_free_list;\n                if (0 != __p)\n                {\n                    *__my_free_list = __p -> _M_free_list_link;\n                    _S_start_free = (char*)__p;\n                    _S_end_free = _S_start_free + __i;\n                    return(_S_chunk_alloc(__size, __nobjs));\n                    // Any leftover piece will eventually make it to the\n                    // right free list.\n                }\n            }\n            _S_end_free = 0;\t// In case of exception.\n            _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get);\n            // This should either throw an\n            // exception or remedy the situation.  Thus we assume it\n            // succeeded.\n        }\n        _S_heap_size += __bytes_to_get;\n        _S_end_free = _S_start_free + __bytes_to_get;\n        return(_S_chunk_alloc(__size, __nobjs));\n    }\n}\n```\n### 头插小内存碎片，图示\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250807063843813.png)\n### oom异常处理\n```cpp\ntemplate <int __inst>\nclass __malloc_alloc_template\n{\nprivate:\n#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n  static void (* __malloc_alloc_oom_handler)();\n#endif\npublic:\n  static void* allocate(size_t __n)\n  {\n    void* __result = malloc(__n);\n    if (0 == __result)\n    {\n        __result = _S_oom_malloc(__n);\n    }\n    return __result;\n  }\n  // ...\n};\n```\n\n```cpp\ntemplate <int __inst>\nvoid*\n__malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)\n{\n    void (* __my_malloc_handler)();\n    void* __result;\n\n    for (;;)\n    {\n        __my_malloc_handler = __malloc_alloc_oom_handler;\n        if (0 == __my_malloc_handler)\n        {\n            __THROW_BAD_ALLOC;\n        }\n        \n        (*__my_malloc_handler)();\n        \n        __result = malloc(__n);\n        \n        if (__result)\n        {\n            return(__result);\n        }\n    }\n}\n```\n### `_S_start_free`、`_S_end_free`、`_S_heap_size`\n这三个变量，只会在`_S_chunk_alloc(size_t, int&)`函数执行中改变。\n```cpp\ntemplate <bool __threads, int __inst>\nchar* __default_alloc_template<__threads, __inst>::_S_start_free = 0;\n\ntemplate <bool __threads, int __inst>\nchar* __default_alloc_template<__threads, __inst>::_S_end_free = 0;\n\ntemplate <bool __threads, int __inst>\nsize_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;\n```\n## `deallocate(void* p, size_t)`\n定义于`stl_alloc.h`\n\n头插归还，看图示。\n```cpp\ntemplate <bool threads, int inst>\nclass __default_alloc_template {\n// ...\npublic:\n// ...\n\n  /* __p may not be 0 */\n    static void deallocate(void* __p, size_t __n)\n    {\n        if (__n > (size_t) _MAX_BYTES)\n        {\n            malloc_alloc::deallocate(__p, __n);\n        }\n        else\n        {\n            _Obj* __STL_VOLATILE*  __my_free_list = \n                _S_free_list + _S_freelist_index(__n);\n            _Obj* __q = (_Obj*)__p;\n            \n            // acquire lock\n#           ifndef _NOTHREADS\n            /*REFERENCED*/\n            _Lock __lock_instance;\n#           endif /* _NOTHREADS */\n    \n            __q -> _M_free_list_link = *__my_free_list;\n            *__my_free_list = __q;\n            // lock is released here\n        }\n    }\n\n//...\n};\n```\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250807073716103.png)\n## `reallocate(void* p, old_sz, new_sz)`\n对已开辟的内存池块的扩容、缩容。\n\n```cpp\ntemplate <bool threads, int inst>\nvoid*\n__default_alloc_template<threads, inst>::reallocate(void* __p,\n                                                    size_t __old_sz,\n                                                    size_t __new_sz)\n{\n    void* __result;\n    size_t __copy_sz;\n\n    if (__old_sz > (size_t)_MAX_BYTES && __new_sz > (size_t)_MAX_BYTES)\n    {\n        return(realloc(__p, __new_sz));\n    }\n    if (_S_round_up(__old_sz) == _S_round_up(__new_sz))\n    {\n        return(__p);\n    }\n    __result = allocate(__new_sz);\n    __copy_sz = __new_sz > __old_sz ? __old_sz : __new_sz;\n    memcpy(__result, __p, __copy_sz);\n    deallocate(__p, __old_sz);\n    return(__result);\n}\n```\n## SGI STL内存池总结\n\nSGI STL 二级空间配置器内存池的实现优点：\n1. 对于每一个字节数的chunk块分配，都是给出一部分进行使用，另一部分作为备用，这个备用可以给当前字节数使用，也可以给其它字节数使用\n2. 对于备用内存池划分完chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块再次分配出去，备用内存池使用的干干净净！防止小块内存频繁的分配，释放，造成内存很多的碎片出来，内存没有更多的连续的大内存块。所以应用对于小块内存的操作，一般都会使用内存池来进行管理。\n3. malloc内存分配失败，还会调用`oom_malloc`这么一个预先设置好的以后的回调函数，如果没设置，则`throw bad_alloc`。设置了则`for(;;)(*oom_malloc_handler)();`。\n# Nginx内存池设计和实现\n区分大小内存块的申请和释放，大于池尺寸的定义为大内存块，使用单独的大内存块链表保存，即时分配和释放；小于等于池尺寸的定义为小内存块，直接从预先分配的内存块中提取，不够就扩充池中的内存，在生命周期内对小块内存不做释放，直到最后统一销毁。\n## Nginx内存池结构图\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250719234700476.png)\n## Nginx源码\n本次分析的是Nginx-release-1.13.1的源码。\nsrc目录下，有好多模块，其中内存池的模块位于`/src/core`目录下。使用的是C语言。\n对于不同的操作系统，有不同的实现，位于`/src/os/unix`和`/src/os/win32`下。\n## 指标\n```c\n// 位于 ngx_palloc.h\n/*\n * NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86.\n * On Windows NT it decreases a number of locked pages in a kernel.\n */\n#define NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)\n\n#define NGX_DEFAULT_POOL_SIZE    (16 * 1024)\n\n#define NGX_POOL_ALIGNMENT       16\n#define NGX_MIN_POOL_SIZE                                                     \\\n    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \\\n              NGX_POOL_ALIGNMENT)\n```\n1. `NGX_MAX_ALLOC_FROM_POOL`定义了可以从内存池中申请的最大内存。默认是`Nginx页面大小减1`。x86系统下是`4096字节减1`。\n2. `NGX_DEFAULT_POOL_SIZE`定义了Nginx内存池默认大小。是`16 * 1024B` 即 `16KB`。\n3. `NGX_POOL_ALIGNMENT`，内存池，分配内存时的对齐大小。默认是16。\n4. `NGX_MIN_POOL_SIZE`定义了内存池的最小大小。\n    1. 其需要通过`ngx_align`计算，定义如下：发现和STL的`round_up`一样，向上取 d 的整 a 倍数。比如，a等于16、d等于7的话，那d取整后就是16，d等于17的话，取整后就是32。\n    2. 其中d是`(sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t))`。a是`NGX_POOL_ALIGNMENT`，默认是16。\n\n```c\n// 位于 ngx_config.h\n#define ngx_align(d, a)     ( ( (d) + (a - 1) ) & ~(a - 1))\n```\n## 关键数据结构\n定义于`ngx_palloc.h`\n```c\ntypdef strcut\n{\n    u_char        *last;       // 当前数据块中内存分配指针的当前位置\n    u_char        *end;        // 内存块的结束位置\n    ngx_pool_t    *next;       // 内存池由多块内存块组成，指向下一个数据块的位置\n    ngx_uint_t    failed;      // 当前数据块内存不足引起分配失败的次数\n} ngx_pool_data_t;\n\nstruct ngx_pool_s\n{\n    ngx_pool_data_t    d;        // 上面那个结构体：内存池当前的数据区指针的结构体\n    \n    size_t             max;      // max 指的是 Nginx 一次分配小块内存大小 的最大值。\n    ngx_pool_t         *current; // 当前正在使用的数据块的指针\n    ngx_chain_t        *chain;   // 把内存池链接起来\n    ngx_pool_large_t   *large;   // 指向大数据块的指针（大数据块是指size > max的数据）\n    ngx_pool_cleanup_t *cleanup; // 类似于析构函数，在 内存free 之前，对内存上的数据进行处理，比如释放指针对应的外部资源\n    ngx_log_t          *log;     \n}; // in ngx_core.h: typedef struct ngx_pool_s ngx_pool_t;\n```\n在`ngx_core.h`中，\n```c\ntypedef struct ngx_pool_s ngx_pool_t;\n```\n即`npx_pool_t`是`struct ngx_pool_s`的别名。\n\n在Nginx内存池中，`npx_pool_t`这个结构只出现在第一个内存池块的头部上，后续链接的内存池块头部只有`ngx_pool_data_t`。\n\n`struct ngx_pool_s`（别名`ngx_pool_t`）结构示意图（大小为1024的池）\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250719235439957.png)\n\n## `npx_create_pool`创建内存池\n声明于`ngx_palloc.h`，定义于`ngx_palloc.c`。\n```c\nngx_pool_t * ngx_create_pool(size_t size, ngx_log_t *log);\n```\n返回`npx_pool_t *`。\n\n开辟指定大小的内存池。根据不同系统、不同的对齐方法，调用不同的API。\n一般是普通的malloc。\n```c\nngx_pool_t * ngx_create_pool(size_t size, ngx_log_t *log)\n{\n    ngx_pool_t  *p;\n    // 如果不用内存对齐，则实际就是普通的 malloc\n    // 如果需要内存对齐，则调用posix_memalign(void ** p, size_t alignment, size_t size)\n    // 或 memalign(size_t alignment, size_t size)\n    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);\n    if (p == NULL)\n    {\n        return NULL;\n    }\n    // 最后一个内存池大块，指向这个新开辟的内存池大块的头信息之后。\n    p->d.last = (u_char *) p + sizeof(ngx_pool_t);\n    // 内存池的结束位置，整个大块的尾部。\n    p->d.end = (u_char *) p + size;\n    p->d.next = NULL;\n    p->d.failed = 0;\n\n    // size 更新为 除去头信息大小的 实际存储数据的大小\n    size = size - sizeof(ngx_pool_t);\n    // 若 size 小于 MAX_ALLOC，则 max为size，size 大于 MAX_ALLOC 则 max 为 MAX_ALLOC\n    // max 指的是 Nginx 一次分配小块内存大小 的最大值。如果用户申请大于max，则按大块数据块处理。\n    p->max = (size < NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;\n    // 指向自己，首地址（包含头信息）\n    p->current = p;\n    p->chain = NULL;\n    p->large = NULL;\n    p->cleanup = NULL;\n    p->log = log;\n\n    return p;\n}\n```\n### `ngx_memalign(POOL_ALIGNMENT, size, log)`或`ngx_alloc(size, log)`\n这是个宏定义，定义于`/src/os/unix`和`/src/os/win32`下的`ngx_alloc.h`。\n\n在Unix下，有对齐的区别：如果要做内存对齐，则`size_t alignment`参数生效，否则忽略对齐参数\n```c\n#if (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)\nvoid *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log);\n#else\n#define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)\n#endif\n```\n在Win32下，没有对齐限制。`#define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)`\n\n名字上，暂时一样。但是相应的`ngx_alloc(size, log)`函数，在两个操作系统上就是不同的实现了。\n我们看Unix的：实际就是套了个**普通malloc**。然后输出了一些日志信息。\n定义于`/src/os/unix/ngx_alloc.c`\n```c\nvoid * ngx_alloc(size_t size, ngx_log_t *log)\n{\n    void  *p;\n\n    p = malloc(size);\n    if (p == NULL)\n    {\n        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n                      \"malloc(%uz) failed\", size);\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, \"malloc: %p:%uz\", p, size);\n\n    return p;\n}\n```\n## 从创建好的内存池中申请内存\n定义于`ngx_palloc.c`\n3个接口：`ngx_palloc`、`ngx_pnalloc`、`ngx_pcalloc`\n1. `ngx_palloc`和`ngx_pnalloc`的区别在于在申请**小块内存**时，**前者考虑对齐**，后者不考虑对齐\n2. `ngx_pcalloc`是调用`ngx_palloc`，之后的额外操作是**清零申请的区域**。\n### `ngx_palloc(pool, size)`\n如果用户申请小于等于pool头信息中max大小的内存，则按小块管理。\n```c\nvoid * ngx_palloc(ngx_pool_t *pool, size_t size)\n{\n#if !(NGX_DEBUG_PALLOC)\n    if (size <= pool->max)\n    {\n        // 第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。\n        return ngx_palloc_small(pool, size, 1);\n    }\n#endif\n    return ngx_palloc_large(pool, size);\n}\n```\n\n```c\nvoid * ngx_pnalloc(ngx_pool_t *pool, size_t size)\n{\n#if !(NGX_DEBUG_PALLOC)\n    if (size <= pool->max)\n    {\n        // 第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。\n        return ngx_palloc_small(pool, size, 0);\n    }\n#endif\n    return ngx_palloc_large(pool, size);\n}\n```\n\n```c\nvoid * ngx_pcalloc(ngx_pool_t *pool, size_t size)\n{\n    void *p;\n    p = ngx_palloc(pool, size);\n    if (p)\n    {\n        ngx_memzero(p, size);    \n    }\n    return p;\n}\n```\n### `ngx_palloc_small(pool, size, align)`\n第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。\n\n找current，即从该内存池大块之中分配内存。\n\n`ngx_align_ptr`，将`p->d.last`指向的可用数据地址按`NGX_ALIGNMENT`对齐到指定数（默认是32）的倍数，比如如果地址是8，则舍弃一部分内存，对齐到32。\n\n```c\nstatic ngx_inline void *\nngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)\n{\n    u_char      *m;\n    ngx_pool_t  *p;\n    // 从 pool 头信息找到当前可用的内存池大块\n    p = pool->current;\n\n    do {\n        // 当前数据块中可分配的内存的开始位置\n        m = p->d.last;\n\n        if (align)\n        {\n            m = ngx_align_ptr(m, NGX_ALIGNMENT);\n        }\n        // end 是当前数据块中可分配的内存的结束位置，与开始位置相减，如果大于等于用户申请的大小\n        // 则 直接返回 m ，即开始位置，把 last 位置 下移 size，表示分配了 size 大小\n        if ((size_t) (p->d.end - m) >= size)\n        {\n            p->d.last = m + size;\n\n            return m;\n        }\n        // 如果 目前的数据块 大小 不够 size，则遍历找下一个数据块。\n        p = p->d.next;\n\n    } while (p);\n    // 直到所有数据块都不够用，则\n    return ngx_palloc_block(pool, size);\n}\n```\n#### `ngx_align_ptr(p, a)`内存对齐\n定义于`ngx_config.h`\n\n如果没有定义`NGX_ALIGNMENT`，则默认是`sizeof(unsigned long)`，按照32位对齐。这是内存单元对齐。\n>注意要和`ngx_palloc.h`中定义的`#define NGX_POOL_ALIGNMENT 16`区分。那是内存池对齐。\n\n即向定义的对齐大小（32）向上取整32倍。\n\n操作是：传入的指针地址，加上指针大小32（4字节，32位）减1，和32减1取反后，相与。\n比如：传入的指针地址是8：`0000 1000`（前面补0），则加32减1：`0010 1000`\n`0010 0000 - 1 = 0001 1111`取反`1110 0000`（前面补1）。`0010 1000`和`1110 0000`相与后：`0010 0000`，由原先的8，对齐到了32。\n```c\n#ifndef NGX_ALIGNMENT\n#define NGX_ALIGNMENT   sizeof(unsigned long)    /* platform word */\n#endif\n\n#define ngx_align_ptr(p, a)                                                   \\\n    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) & ~((uintptr_t) a - 1))\n```\n\n## `ngx_palloc_block(pool, size)`再开辟一大块内存池\n从pool的头块找到`end - pool`的大小，这是内存池每一个大块的大小（包含头信息的大小）\n\n这是为了**再开辟一大块内存池**做准备。\n\n`ngx_memalign`和第一次创建内存池一样，如果没有对齐要求，则普通malloc。\n\n\n```c\nstatic void *\nngx_palloc_block(ngx_pool_t *pool, size_t size)\n{\n    u_char      *m;\n    size_t       psize;\n    ngx_pool_t  *p, *new;\n    // 一整个内存池大块（包含头信息）的大小。\n    psize = (size_t) (pool->d.end - (u_char *) pool);\n\n    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool->log);\n    if (m == NULL)\n    {\n        return NULL;\n    }\n\n    new = (ngx_pool_t *) m;\n    // psize是整个内存池块的大小。m是开始，则end指向这个新开辟的内存池块的末尾\n    new->d.end = m + psize;\n    // next暂时指向NULL。\n    new->d.next = NULL;\n    new->d.failed = 0;\n\n    // 存放普通内存池块的头信息\n    m += sizeof(ngx_pool_data_t);\n    // 内存对齐 m ，存储实际数据的开始地址\n    m = ngx_align_ptr(m, NGX_ALIGNMENT);\n    // 分配出去 size 大小的内存，last（下一个空闲内存的开始地址）更新到新位置\n    new->d.last = m + size;\n    \n    // 从整个内存池的current到后续一长串，给每一个内存池块的failed计数加1。\n    // 如果发现当前这个内存池块的failed是4，则current指向这个failed次数过多内存池块的下一个内存池块。 \n    for (p = pool->current; p->d.next; p = p->d.next)\n    {\n        if (p->d.failed++ > 4)\n        {\n            pool->current = p->d.next;\n        }\n    }\n    // 退出for 循环后，p 更新到了 最后一个内存池块。同时，当前pool的current指向的是第一个failed不为4的内存池块\n    // 尾插。链接起来新开辟的这个内存池块。\n    p->d.next = new;\n\n    return m;\n}\n```\n## `ngx_palloc_large(pool, size)`大块内存分配管理\n用户申请比`pool->max`大的内存时，按大块内存分配管理。\n用`ngx_alloc`分配size大小的内存（和分配内存池块的方法一样）见[`ngx_memalign(POOL_ALIGNMENT, size, log)`或`ngx_alloc(size, log)`](#`ngx_memalign(POOL_ALIGNMENT,%20size,%20log)`或`ngx_alloc(size,%20log)`)。\n遍历找large链的前5个，看是否有large的alloc为空的，直接让alloc指向一开始malloc得到的p。\n如果连续找了5个，发现large的alloc都不为空，则跳出循环，不再找了。\n这个for循环是为了快速在前5个large中，找到一个之前开辟的，但已经空闲了的大内存块头信息，其alloc管理的大内存块已经释放了，所以为NULL，直接让alloc指向一开始malloc得到的p即可。\n\n如果没有进入循环，说明large一开始就是空的，内存池没有申请过大块内存；或者是找了5个发现large的alloc都不空：执行下面的操作（头插大内存块的头信息到pool的large链）：\n\n记录大内存块（large管理）的 头信息`ngx_pool_large_t`，是按照`ngx_palloc_small`方法，存放到了内存池块的小块内存中。\n`ngx_palloc_small`返回空说明系统内存不够用了，失败，释放一开始malloc得到的大块内存，返回NULL。\n\n如果正常，则在这个大块内存头信息填写：\n`alloc`，即这个大块内存的地址，为一开始malloc得到的地址。\n`next`，指向pool的large链头，pool的large指向这个新大块内存的头信息。相当于头插！只不过插的是大内存块的头信息。\n```c\nstatic void *\nngx_palloc_large(ngx_pool_t *pool, size_t size)\n{\n    void              *p;\n    ngx_uint_t         n;\n    ngx_pool_large_t  *large;\n\n    p = ngx_alloc(size, pool->log);\n    if (p == NULL)\n    {\n        return NULL;\n    }\n\n    n = 0;\n\n    for (large = pool->large; large; large = large->next)\n    {\n        if (large->alloc == NULL)\n        {\n            large->alloc = p;\n            return p;\n        }\n\n        if (n++ > 3)\n        {\n            break;\n        }\n    }\n    // 记录 大块 内存（large管理）的 头信息，存放到内存池块管理的小块内存中。\n    // 返回空说明 系统 内存不够用了，失败。\n    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);\n    if (large == NULL)\n    {\n        ngx_free(p);\n        return NULL;\n    }\n\n    large->alloc = p;\n    large->next = pool->large;\n    pool->large = large;\n\n    return p;\n}\n```\n图示：\n![](../../images/SGI%20STL和Nginx内存池剖析/image-20250807115333694.png)\n\n如图，大块内存的头信息，是按小块内存管理，分配到了内存池块中。\n\n下面要提到的外部资源所绑定的清理的头信息，也像是大块内存头信息一样，按小块内存管理，分配到了内存池块中。\n## `ngx_pool_cleanup_add`分配一个需要管理外部资源的数据（比如指针、fd）\n按小块内存分配`ngx_pool_cleanup_t`，这是清理的头信息块。\n有：handler、data、next。\n\n之后才是分配size。\n\n之后，像头插大内存块的头信息链表一样，头插清理类的头信息链表。\n```c\nngx_pool_cleanup_t * ngx_pool_cleanup_add(ngx_pool_t *p, size_t size)\n{\n    ngx_pool_cleanup_t  *c;\n\n    c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t));\n    if (c == NULL)\n    {\n        return NULL;\n    }\n\n    if (size)\n    {\n        c->data = ngx_palloc(p, size);\n        if (c->data == NULL)\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        c->data = NULL;\n    }\n\n    c->handler = NULL;\n    c->next = p->cleanup;\n\n    p->cleanup = c;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p->log, 0, \"add cleanup: %p\", c);\n\n    return c;\n}\n```\n### 通过返回的`ngx_pool_cleanup_t *`绑定清理回调函数\n```c\nstruct Data\n{\n    char * p;\n    // ...\n};\nstruct Data *pData = ngx_alloc(512);\npData->p = (char*)malloc(128);\nstrcpy(pData->p, \"hello world\");\n\nvoid my_release(void *p)\n{\n    free(p);\n}\n\nngx_pool_cleanup_t *pclean = ngx_pool_cleanup_add(pool, sizeof(char*));\npclean->handler = &my_release;\npclean->data = pData->p;\n```\n## `ngx_pfree(pool, void *p)`大块内存释放\n用于释放大块内存。先free，后把large头信息中的alloc置空。\n```c\nngx_int_t\nngx_pfree(ngx_pool_t *pool, void *p)\n{\n    ngx_pool_large_t  *l;\n\n    for (l = pool->large; l; l = l->next)\n    {\n        if (p == l->alloc)\n        {\n            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,\n                           \"free: %p\", l->alloc);\n\n            ngx_free(l->alloc);\n            l->alloc = NULL;\n\n            return NGX_OK;\n        }\n    }\n    return NGX_DECLINED;\n}\n```\n## 小块内存释放：无\nNginx的小块内存一旦分配了之后，就无法精确地回收。\n\n不像SGI STL一样，假设A、B、C三个小内存单元相邻，A、C空闲，A是freelist的第一个空闲块，A的next是C。现在释放B，则B头插到freelist，现在是B连着A连着C。这样可以精确地释放，并下次还能重新分配（可以发现，由于是头插到了freelist的第一个空闲区域，所以最后释放的最先分配）。\n\nNginx呢，每个内存池块只是由`last`和`end`两个指针管理，只能指示当前内存池块的未分配的部分。\n\n当已分配的部分中，有 1 个小块内存要释放，无法精确管理。所以Nginx只能连续地释放一整段空间，与last相连。\n## `ngx_reset_pool(pool)`\n遍历large链表，释放每个大块内存。最后large置空。\n遍历每个内存池块，把last拉到头信息的末尾即可，相当于释放了内存池的数据。最后current置为pool。\n注意，只是释放了大块内存，所有内存池块都没有free，只是更新了last。\n```c\nvoid ngx_reset_pool(ngx_pool_t *pool)\n{\n    ngx_pool_t        *p;\n    ngx_pool_large_t  *l;\n\n    for (l = pool->large; l; l = l->next)\n    {\n        if (l->alloc)\n        {\n            ngx_free(l->alloc);\n        }\n    }\n    \n    for (p = pool; p; p = p->d.next)\n    {\n        if (p == pool) // 第一个内存池，有pool头信息\n        {\n            p->d.last = (u_char*)p + sizeof(ngx_pool_t);\n        }\n        else           // 其余的内存池，只有小头信息，没有pool大头\n        {\n            p->d.last = (u_char *) p + sizeof(ngx_pool_data_t);\n        }\n        p->d.failed = 0;\n    }\n\n    pool->current = pool;\n    pool->chain = NULL;\n    pool->large = NULL;\n}\n```\n## `ngx_destroy_pool(pool)`\n1. 遍历“清理”链表，每个都按照绑定的handler释放其data外部资源。\n2. 遍历large链表，释放每个大块内存。\n3. 遍历每个内存池块，释放每个内存池块。\n\n```c\nvoid\nngx_destroy_pool(ngx_pool_t *pool)\n{\n    ngx_pool_t          *p, *n;\n    ngx_pool_large_t    *l;\n    ngx_pool_cleanup_t  *c;\n\n    for (c = pool->cleanup; c; c = c->next)\n    {\n        if (c->handler)\n        {\n            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0,\n                           \"run cleanup: %p\", c);\n            c->handler(c->data);\n        }\n    }\n#if (NGX_DEBUG)\n    /*\n     * we could allocate the pool->log from this pool\n     * so we cannot use this log while free()ing the pool\n     */\n    for (l = pool->large; l; l = l->next)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool->log, 0, \"free: %p\", l->alloc);\n    }\n    for (p = pool, n = pool->d.next; /* void */; p = n, n = n->d.next)\n    {\n        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool->log, 0,\n                       \"free: %p, unused: %uz\", p, p->d.end - p->d.last);\n        if (n == NULL)\n        {\n            break;\n        }\n    }\n#endif\n    for (l = pool->large; l; l = l->next)\n    {\n        if (l->alloc)\n        {\n            ngx_free(l->alloc);\n        }\n    }\n    for (p = pool, n = pool->d.next; /* void */; p = n, n = n->d.next)\n    {\n        ngx_free(p);\n        if (n == NULL)\n        {\n            break;\n        }\n    }\n}\n```\n# Nginx和STL释放内存的策略适用的场景\nNginx大块内存分配=》内存释放ngx_free函数\nNginx小块内存分配=》没有提供任何的内存释放函数。\n\n实际上，从小块内存的分配方式来看（直接通过last指针偏移来分配内存），根本没法进行中间部分的小块内存的回收。\n\nNginx本质：HTTP服务器是一个短链接的服务器，客户端（浏览器）发起一个request请求，到达Nginx服务器以后，处理完成，Nginx给客户端返回一个response响应，HTTP服务器就主动断开tcp连接。\n假设HTTP 1.1 keep-alive：60s，HTTP服务器（nginx）返回响应以后，需要等待60s，60s之内客户端又发来请求，重置这个时间；\n否则60s之内没有客户端发来的响应，Nginx也是最终会主动断开连接，此时Nginx可以调用ngx_reset_pool重置内存池了，等待下一次客户端的请求。\n\n因此，Nginx内存池的设计适用于间歇性、短连接的服务。虽然有内存泄漏，但效率高，空间换时间。\n\n如果是长连接，且小块内存分配、释放较多，最好用STL二级空间配置器，避免内存泄漏过多。","categories":["Cpp","STL","项目","内存池"]},{"title":"设计并实现线程池_future原理","url":"/项目/设计并实现线程池_future原理/","content":"# 知识储备\n## 并发和并行\n\n* 并发\n\n单核上，CPU时间片轮转，多个线程轮流执行。物理上是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），宏观上看就像是多个线程在共同执行，这样的场景称作并发(concurrent)。\n\n* 并行\n\n在多核或者多CPU上，多个线程在同一时刻执行，这样的场景才是真正的并行(parallel)。\n## 两种密集型程序\n\n多线程程序一定好吗？不一定，要看具体的应用场景。\n* IO密集型：程序里面指令的执行，涉及IO操作较多，比如设备、文件、网络操作（等待客户端的连接），可能会把程序阻塞。如果CPU时间片再分配给这种线程，相当于浪费了CPU资源。\n* CPU密集型：程序里面的指令都是做计算用的，不会阻塞。\n---\n* 多核情况下\n    1. IO密集型和CPU密集型虽然对并行计算有不同的需求，IO密集型更适合设计成多线程程序。但是在多核情况下两种密集型程序都是有必要用多线程来处理的。\n    2. 线程进行调度时，内核中有这样两个队列：runnable，就绪的或正在调度的队列。如果因IO操作有线程阻塞了，则将会进入阻塞队列，blocking queue。\n* 单核情况下\n    1. IO密集型的程序依然适合设计为多线程程序。\n    2. CPU密集型程序不再适合！这就相当于只有一个计算器，却让多个人分段算。线程的调度有额外的花费：线程的上下文切换。CPU寄存器信息会保存在线程栈上，下次还要再恢复到CPU中，实属麻烦。\n## 线程的代价\n\n为了完成任务，创建很多线程可以吗？线程越多越好吗？\n* 线程的创建和销毁都是非常“重”的操作，需要进入内核态。在执行任务的过程中，没有集中资源去干正事，而是去花费很大力度创建/销毁？\n    * 需要给线程创建`PCB(task_struct)`、线程的内核栈、页目录、页表\n    * 描述地址空间相应的数据结构：`vm_area_struct`\n    * 内核创建完后，还要返回用户态\n    * 线程执行完业务，还要销毁线程，又要切换一次\n* 线程栈本身占用大量内存，每一个线程都需要线程栈，栈几乎都被占用完了，还怎么做事情？\n    * 32位地址空间，共4G，用户空间有3G。\n    * 线程共享进程的地址空间。\n    * 可在linux下执行`ulimt -a`命令观察stack size默认栈大小，为8192字节即8M。\n    * $3*1024M=3072M, 3072M/8M=384$个。这说明32位环境下，最多创建384个线程。\n* 线程的上下文切换要占用大量时间\n    * 线程过多，线程的调度是需要进行上下文切换的，上下文切换花费CPU时间也特别多，CPU的利用率就不高了。\n* 大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机\n    * 如果在某一时刻，大量的IO操作准备好了，那么一时间线程是来不及处理的。\n# 线程同步\n## 线程互斥\n\n某段代码能不能多线程环境下执行？看这段代码是否存在**竞态条件**，即有无临界区代码段。（代码片段在多线程环境下执行，随着线程的调度顺序不同而得到不同的执行结果）。如果有，则要通过线程同步来保证它的原子操作。\n\n如果在多线程环境下不存在竞态条件，则称之为**可重入的**。\n### 互斥锁\n* lock\n* `try_lock`\n* `lock_guard`\n* `unique_lock`\n### atomic原子类型\n* CAS操作（无锁机制）\n    * 无锁队列、无锁链表、无锁数组\n    * 实际上使用的是轻量级、效率高的锁，不是没用锁。\n## 线程通信\n\n[GDB调试C++11多线程死锁](https://blog.csdn.net/QIANGWEIYUAN/article/details/88792621)\n### 条件变量\n### 信号量\n看作资源计数没有限制的mutex互斥锁。mutex互斥锁的资源计数只能是0或者1。\n### 区别\n* 二元信号量和互斥锁的区别\n    * mutex只能是哪个线程获取锁，由哪个线程释放锁。\n    * `sem.wait()`和`sem.post()`则可以处在不同的线程中调用。\n# 线程池\n线程池的优势：\n\n服务进程启动之初，事先创建好线程池里面的线程，当业务到来需要分配线程时直接从线程池中获取一个空闲线程执行task任务即可，task执行完成之后把线程归还到线程池中继续给后续task提供服务，而不用释放线程。\n## 项目介绍\n\n本项目所实现的线程池和对象池、内存池、STL库的意义一样，只能称作一个库，而不能作为一个独立运行的中间件，必须镶嵌在应用程序中。最终项目表现形式为一种提供给他人的**动态库**，比如用到了`mysql.h`头文件，`libmysqlclient.so`动态库。动态库需要编译出来。\n### 使用方式\n\n* 启动线程池\n\n如果你想在应用程序中或者代码中使用本项目的线程池，你可以\n\n1. 直接`ThreadPool pool;`定义一个`pool`对象；\n2. 而后则可以调用`pool.sexMode(fixed(default) | cached);`接口设置线程池的运行模式，默认为固定模式。\n3. 然后`pool.start();`启动线程池。start不会阻塞。\n\n启动线程池意味着线程池开始创建若干线程，就绪，等待任务过来执行任务。\n\n* 提交任务\n\n调用方只要按以下形式调用API即可：`Result result = pool.submitTask(concreteTask);`\n\n调用方无需关心内部操作，包括线程分配、执行过程。\n\n有时调用方需要获取任务执行的结果，可用`T res = result.get().Cast<T>();`获得任务结果。任务结果的返回值是任意类型，具体类型T由用户指出。（此处用到了C++17中的Any类型）\n\n# 线程池的设计\n\n## 类成员\n\n首先说一说抽象出的类：线程池类、线程池中的线程类。\n\n1. 既然是线程池，就要有一个**存放线程的容器**\n    1. 我们最好能实时监控线程池中线程的数量、以及上限阈值，避免线程数量走向极端从而影响性能（线程数量不是越多越好，坏处：1、线程栈空间冗余；2、上下文切换过程时间多于执行操作）\n2. 还要有一个存放待完成任务的容器，即**任务队列**\n    1. 考不考虑线程安全问题？必须考虑，外层用户提交任务要放数据，下层线程执行任务要取数据。\n    2. 任务不能堆积过多。对于任务队列，也要有一个上限阈值。\n\n## 通用化的实现 - Task设计 - 继承多态思想\n\n任务类型需要达到通用性，所以要用到继承、多态的思想。用基类指针可以指向各种各样的派生类对象。\n\n所以需要**设计一个抽象类Task。内部提供一个纯虚函数`virtual void run() = 0`**。如果要设计特定的任务，则继承（实现）之，重写run函数即可。\n\n## 线程通信的保证 - mtx+cv\n\n因为涉及到放任务、取任务，所以很明显是个生产者消费者模型。\n\n必然**用到互斥锁+条件变量，从而对任务队列进行互斥保护**、达到正确的线程通信。\n\n## 线程池的模式\n* fixed模式\n    * 线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。\n* cached模式\n    * 线程池里面的线程个数是可动态增长的，根据任务的数量动态地增加线程的数量，但是会设置一个线程数量的阈值。任务处理完成后，如果动态增长的线程空闲60s而没有其他任务待处理，那么就关闭线程，保持池中线程的最初数量。\n### 代码形式\n```cpp\nint main()\n{\n\tThreadPool pool;\n    pool.setMode(fixed(default) | cached);\n    pool.start();\n}\n```\n### 提交任务API\n```cpp\nResult result = pool.submitTask(concreteTask);\nresult.get().Cast<T>();\n```\n\n# 线程池类（ThreadPool）\n线程池，不光要管理线程，而且要集成一个任务队列。要对外提供提交任务的接口。\n\n其中的线程去取任务，做，然后返回任务结果。（这是线程类里的事情）\n\n管理的线程，用 vector 管理。\n管理的任务，用 queue 管理。任务队列要保证线程安全。\n\n```cpp\nenum class PoolMode\n{\n    MODE_FIXED,     // 固定数量的线程\n    MODE_CACHED,    // 线程数量可动态增长\n};\nclass ThreadPool\n{\npublic:\n    ThreadPool();\n    ~ThreadPool();\n    /* 设置线程池的工作模式 */\n    void setMode(PoolMode mode);\n    /* 设置初始的线程数量 */\n    void setInitThreadSize(int size);\n    /* 设置task队列任务数量最大阈值 */\n    void setTaskQueMaxThreshHold(int threshHold);\n    /* 启动线程池 */\n    void start();\n    /* 给线程池提交任务 */\n    void submitTask(std::shared_ptr<Task> task);\nprivate:\n    PoolMode m_poolMode;                //当前线程池工作模式\n    std::vector<Thread*> m_threads;     //线程列表\n    int m_initThreadSize;               //初始的线程数量\n    /**\n     * 任务队列容器。\n     * 特别要注意，需要用 shared_ptr 强引用用户传来的 task ，\n     * 以保证任务对象的生命期。\n     */\n    std::queue<std::shared_ptr<Task>> m_taskQueue;\n    /* 目前任务队列中的任务数量 */\n    std::atomic_int m_taskNum;\n    /* 任务队列最大上限阈值 */\n    int m_taskQueMaxThreshHold;\n    /* 保护安全地操作任务队列 */\n    std::mutex m_taskQueMtx;\n    /* 表示任务队列不满 */\n    std::condition_variable m_taskQueNotFull;\n    /* 表示任务队列不空 */\n    std::condition_variable m_taskQueNotEmpty;\nprivate:\n    ThreadPool(const ThreadPool &) = delete;\n    ThreadPool& operator=(const ThreadPool &) = delete;\n};\n```\n## ThreadPool构造、析构\n```cpp\n/* 线程池构造 */\nThreadPool::ThreadPool()\n   : m_initThreadSize(4),\n     m_taskNum(0),\n     m_taskQueMaxThreshHold(TASK_MAX_THRESHHOLD),\n     m_poolMode(PoolMode::MODE_FIXED)\n{\n\n}\nThreadPool::~ThreadPool()\n{\n\n}\n```\n## 设置参数\n```cpp\n/* 设置线程池的工作模式 */\nvoid ThreadPool::setMode(PoolMode mode)\n{\n   m_poolMode = mode;\n}\n/* 设置初始的线程数量 */\nvoid ThreadPool::setInitThreadSize(int size)\n{\n   m_initThreadSize = size;\n}\n/* 设置task队列任务数量最大阈值 */\nvoid ThreadPool::setTaskQueMaxThreshHold(int threshHold)\n{\n   m_taskQueMaxThreshHold = threshHold;\n}\n```\n## 启动线程池\n```cpp\n/* 启动线程池 */\nvoid ThreadPool::start(int initThreadSize);\n```\n## 给线程池提交任务\n```cpp\n/* 给线程池提交任务 */\nvoid ThreadPool::submitTask(std::shared_ptr<Task> task);\n```\n\n# Thread类\n## 线程函数定义在哪个位置呢？\n* 思考：线程函数定义在哪个位置呢？\n    * 如果写在Thread类中，那么定义在 ThreadPool 的变量则不容易被函数所访问。\n    * 定义为全局函数呢？线程池里的变量都是私有的，也不易访问。\n    * 结论：OOP的手法，写在ThreadPool中。\n\n```cpp\n/* threadpool.h */\nclass ThreadPool\n{\nprivate:\n  /* 定义线程函数 */\n  void threadFunc();\n};\n```\n## 怎么把线程函数扔给Thread对象\n* 线程对象是在线程池里构建的，线程启动执行也是在线程池里做的，\n* 那么创建 thread 线程对象时需要把线程函数给到 thread 线程对象。怎么把函数扔给对象？怎么解决这个技术问题？\n    * 引入`<functional>`，用`std::bind()`把函数对象绑定。在线程池 start 时，构造 thread 时传入\n\n```cpp\nvoid ThreadPool::start(int initThreadSize)\n{\n    m_initThreadSize = initThreadSize;\n    for(int i = 0; i < m_initThreadSize; ++i)\n    {\n        m_threads.emplace_back(\n            new Thread(std::bind(&ThreadPool::threadFunc, this))\n        );\n    }\n    for(int i = 0; i < m_initThreadSize; ++i)\n    {\n        m_threads[i]->start();\n    }\n}\n```\n## 头文件\n由上述 Thread 类构造时对函数对象的处理，可以得到 Thread 类的大致属性需求、构造参数。\n\n```cpp\nclass Thread\n{\npublic:\n    /* 线程函数对象类型别名 */\n    using ThreadFunc = std::function<void()>;\n    Thread(ThreadFunc func);\n    ~Thread();\n    void start();\nprivate:\n    ThreadFunc m_func;\n};\n```\n## start 函数（创建线程后，分离线程）\n* start 函数 - 启动线程，创建一个线程来执行一个线程函数\n    * 需要注意：出了start函数作用域之后线程对象会析构，但是线程函数不能消失，他还要去消费任务队列上的任务。**所以线程对象需要设置为分离线程，否则程序会挂掉**。\n    * 分离的效果就是：**线程对象**和它所**启动的线程（实质的线程**）分离开了。独立存在，互不关心对方的生命期。\n\n```cpp\n/* threadpool.cpp */\n#include<thread>\n/* 启动线程 */\nvoid Thread::start()\n{\n    std::thread t(m_func);\t//线程对象t，线程函数m_func\n    t.detach();\n}\n```\n# 简单测试\n* 简单测试，默认启动 4 个线程。启动后在不同的线程分别执行 threadFunc 函数。\n    * 注意：创建的线程分离之后，执行完毕后会自动回收。但是可能存在主线程启动后看不到打印结果的情况，那是因为主线程结束地太快，导致没能看到（实际中的服务器主线程不会很快结束，而是保持）。为了看到执行结果，可以睡眠一段时间。\n\n```cpp\nvoid ThreadPool::threadFunc()\n{\n  std::cout << \"begin threadFunc tid:\" \n      << std::this_thread::get_id() << std::endl;\n  std::cout << \"end threadFunc\" \n      << std::this_thread::get_id() << std::endl;\n}\n/* 线程池项目测试.cpp */\n#include\"threadpool.h\"\n#include<iostream>\n#include<chrono>\n#include<thread>\nint main()\n{\n    ThreadPool pool;\n    pool.start();\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n}\n```\n\n# 智能指针解决避免手动释放\n\n```cpp\nvoid ThreadPool::start(int initThreadSize)\n{\n    m_initThreadSize = initThreadSize;\n    for(int i = 0; i < m_initThreadSize; ++i)\n    {\n        auto ptr = std::make_unique<Thread>(\n            std::bind(&ThreadPool::threadFunc, this)\n        );\n        m_threads.emplace_back(ptr);\n    }\n    for(int i = 0; i < m_initThreadSize; ++i)\n    {\n        m_threads[i]->start();\n    }\n}\n```\n\n但是这样会出现编译不过的问题，为什么呢？因为报错发现`unique_ptr`的拷贝构造已经删除，这是唯一性智能指针的语义决定的。而移动构造没有删除，意味可以用右值进行资源转移，所以我们需要在`ptr`前加`std::move`。\n\n```cpp\n        m_threads.emplace_back(std::move(ptr));\n```\n\n# submitTask\n\n```cpp\n/* 给线程池提交任务 */\nvoid ThreadPool::submitTask(std::shared_ptr<Task> sp)\n{\n    /* 获取锁 */\n    std::unique_lock<std::mutex> lock(m_taskQueMtx);\n    /* 线程的通信，等待任务队列有空余 */\n    //while(taskQue_.size() == taskQueMaxThreshHold_){ notFull_.wait(); }\n    m_taskQueNotFull.wait(\n        lock,\n        [&]()->bool {\n            return m_taskQueue.size() < m_taskQueMaxThreshHold;\n        }\n    );\n    /* 如果有空余，把任务放到任务队列中 */\n\tm_taskQueue.emplace(sp);\n    ++m_taskNum;\n    /* 因为新放了任务，任务队列肯定不空了，通知notEmpty_上的等待线程 */\n    m_taskQueNotEmpty.notify_all();\n}\n```\n\n## 服务降级（`wait_for(time)`）\n\n为了性能更加优化，我们限制用户提交任务的最长阻塞时间是`1s`，如果提交任务超过了 1s 说明目前线程池的任务队列压力比较大，防止短时间内积压很多任务，则规定为提交任务失败，返回。称为**服务降级**。\n\n需要用到`wait`的两个延伸，`wait_for(time)`，`wait_until(endtime)`。返回值为bool值，`false`表示到时间后条件依然没满足。\n\n以下说的是：如果等了超过 1 秒，说明满的状态已经超过了 1 秒，`wait_for`返回 `false` ，`if` 条件成立，提交失败。\n```cpp\n    if(!m_taskQueNotFull.wait_for(\n        lock,\n        std::chrono::seconds(1),\n        [&]()->bool {\n            return taskQue_.size() < (size_t)taskQueMaxThreshHold_;\n        }))\n    {\n        std::cerr<<\"task queue is full, submit out of time failed.\"<<endl;\n        return;\n    }\n```\n# ThreadFunc\n\n```cpp\nvoid ThreadPool::threadFunc()\n{\nfor(;;)\n{\n    std::shared_ptr<Task> task;\n    /* 块作用域 */\n    {\n        /* 先获取锁 */\n        std::unique_lock<std::mutex> lock(m_taskQueMtx);\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"尝试获取任务...\" << std::endl;\n        /* 等待notEmpty条件 */\n        m_taskQueNotEmpty.wait(\n            lock,\n            [&]()->bool {\n                return m_taskQueue.size() > 0;\n            }\n        );\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"获取任务成功...\" << std::endl;\n        /* 从任务队列中取一个任务出来 */\n        task = m_taskQueue.front();\n        m_taskQueue.pop();\n        --m_taskNum;\n        /* 如果有剩余任务，继续通知其他线程来取任务 */\n        if (m_taskQueue.size() > 0)\n        {\n            m_taskQueNotEmpty.notify_all();\n        }\n        /* 取出了一个任务，任务队列此时肯定不满了，对等待提交任务的人进行通知 */\n        m_taskQueNotFull.notify_one();\n    }\n    /* 当前线程负责执行这个任务, 没必要拥有锁, 脱离块作用域, 释放锁 */\n    if(task != nullptr)\n        task->run();\n}\n}\n```\n\n# 测试1\n\n```cpp\nclass MyTask : public Task\n{\npublic:\n    void run()\n    {\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"begin!\" << std::endl;\n        \n        std::this_thread::sleep_for(std::chrono::seconds(2));\n        \n    \tstd::cout << \"tid:\" << std::this_thread::get_id()\n            << \"end!\" << std::endl;\n    }\n};\n-------------------------------------------------------------------\ntest example:\n/* 以下为提交3个任务，预估结果为3个线程获取任务成功，1个没有获取到，一直阻塞 */\nint main()\n{\n    ThreadPool pool;\n\tpool.start(4);\n\tpool.submitTask(std::make_shared<MyTask>());\n\tpool.submitTask(std::make_shared<MyTask>());\n\tpool.submitTask(std::make_shared<MyTask>());\n    getchar();\n}\n/* 若4个线程，提交5个任务，则最先完成并抢到锁的线程能再次获得第5个任务 */\n/* 若4个线程，提交10个任务，并把队列容量设为4，则可能有2个任务提交失败 */\n```\n\n# 线程执行的返回值（future和packaged_task的实现原理）\n\n比如，计算1到30000的和。线程1计算1到10000，2计算10001到20000，3计算20001到30000。\n主线程给每一个线程分配计算的区间，并等待他们算完之后返回结果，合并最终的结果即可。\n但是，怎么能拿到线程的返回值呢？\n\n```cpp\nclass MyTask : public Task\n{\npublic:\n    MyTask(int begin, int end)\n    \t: begin_(begin), end_(end)\n    {\n        \n    }\n    void run()\n    {\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"begin!\" << std::endl;\n        int sum = 0;\n        for(int i = begin_; i <= end_; ++i)\n        {\n            sum += i;\n        }\n        \n    \tstd::cout << \"tid:\" << std::this_thread::get_id()\n            << \"end!\" << std::endl;\n        \n        return sum;\n    }\n};\n```\n\n* 问题1：怎么设计run函数的返回值，可以表示任意的类型？\n* 问题2：如何设计这里的Result机制？\n\n```cpp\nResult res1 = pool.submitTask(std::make_shared<MyTask>(1, 10000));\nResult res2 = pool.submitTask(std::make_shared<MyTask>(10001, 20000));\nResult res3 = pool.submitTask(std::make_shared<MyTask>(20001, 30000));\nres1.get();\nres2.get();\nres3.get();\n```\n\n\n## Any类型 - 按需返回具体类型\n\n```cpp\nclass Any\n{\npublic:\n    Any() = default;\n    ~Any() = default;\n    Any(const Any&) = delete;\n    Any& operator=(const Any&) = delete;\n    Any(Any &&) = default;\n    Any& operator=(Any &&) = default;\n    \n    /* 这个构造函数可以让 Any 类型接收任意其他的数据 */\n    template<typename T>\n    Any(T data) : base_(std::make_unique<Derived<T>>(data))\n    {}\n    /* 这个方法能把 Any 对象里面存储的 data 数据提取出来 */\n    template<typename T>\n    T cast_()\n    {\n        // base_ 是定义在 Any 类中的一个 std::unique_ptr<Base>\n        // get() 可以获得 其实际指针\n        Derive<T>* pd = dynamic_cast<Derive<T>*>(base_.get());\n        if(pd == nullptr)\n        {\n            throw \"type is unmatch!\";\n        }\n        return pd->data_;\n    }\nprivate:\n    class Base\n    {\n    public:\n        virtual ~Base() = default;\n    };\n    \n    template<typename T>\n    class Derived : public Base\n    {\n    public:\n        Derived(T data) : data_(data)\n        {}\n    private:\n        // 实际的 data 存在 Derived 类中。\n        T data_;\n    };\n    \nprivate:\n    /* 定义一个基类的指针 */\n    std::unique_ptr<Base> base_;\n};\nint main()\n{\n    ThreadPool pool;\n    pool.start(4);\n    \n    Result res = pool.submitTask(std::make_shared<MyTask>(1, 10000));\n    int sum = res.get().cast_<int>();\n}\n```\n如此一来：\nres调用get，等待 task 执行完毕，`get()`就能返回一个`Any`。这个 `Any` 的模板参数指明了里面存放的数据是 `int` 型， `Any` 对象调用其 `cast_`， 取出了里面存放的数据。（通过`dynamic_cast<Derive<int>*>`）如果类型不匹配，则抛出异常。\n\n## 自实现信号量类\n\n```cpp\nclass Semaphore\n{\npublic:\n    Semaphore(int limit = 0)\n        : resLimit_(limit)\n    {\n    }\n    ~Semaphore() = default;\n    /* 获取一个信号量资源 */\n    void wait()\n    {\n        std::unique_lock<std::mutex> lock(mtx_);\n        /* 等待信号量有资源，没有资源的话，阻塞当前线程 */\n        cond_.wait(lock, [&]()->bool {return resLimit_ > 0;});\n        --resLimit_;\n    }\n    /* 增加一个信号量资源 */\n    void post()\n    {\n        std::unique_lock<std::mutex> lock(mtx_);\n        ++resLimit_;\n        cond_.notify_one();\n    }\nprivate:\n    // 信号量目前拥有的资源数\n    int resLimit_;\n    std::mutex mtx_;\n    std::condition_variable cond_;\n};\n```\n\n## （⭐）Result设计\n先分析一下局势：\n1. Task里面肯定有结果\n2. 外部有一个Result要接收结果\n3. Task里面的结果怎么巧妙地转移到Result上面？\n4. 其实Task不用专门有一个Any成员变量保存。\n5. 可以直接在Task中保存一个Result指针。\n6. 外部Result也绑定一个Task作为成员对象。**为了让Task延长生命期，Result需要用`shared_ptr<Task>`构造**。\n7. `Result`构造函数中，只需要执行：`task_->setResult(this);`，便可以移花接木，把Task成员变量`result_`指向外部的Result。\n8. 这样，Task内部，run完之后，返回了Any，Task便可以主动调用`result_->setVal(run())`。把结果写回外部的Result内部。\n\nsubmitTask接口返回类型需要让用户能接收到线程任务的返回值，并且要求可以是任意类型，所以改为Result。相应的，我们需要设计这样的Result类型。\n* 思考，return时用下面哪种方式？\n    * `task->getResult();`还是`Result(task);`？\n    * 要执行的task从队列中`taskQue_.pop()`，接着调用完毕后Task就会析构（注意，submitTask传入的是shared_ptr，引用计数减1，如果此时没有其他人引用该Task，将会析构，里面的any存储的结果就失效了），即task生命期现在只存在于`threadFunc`函数中。\n    * 如果是`task->getResult();`\n        * 若task中的Result是以值形式存的，则肯定不行，因为task析构之后，Result也会析构。\n        * 若task中的Result是以指针形式存的，则必须指定到一个外部资源保存。比如存到堆上。\n            * 如果是在堆上保存，还必须提供一个getResult接口，返回Result的指针，即`result_`成员变量。这样，可以做到把Result安全地保存下来。\n    * 但是，可以以更为巧妙的方式！`Result(task);`\n        * Result绑定了这个task（用shared智能指针管理，让task对象的生命期延至和Result对等），在Result的构造函数中，调用`task->setResult(this);`！！！居然巧妙地把“外部资源地址”指向了外部待接收结果的Result自己！避免了堆上建立的烦恼。\n\n```cpp\nclass ThreadPool\n{\n/*\t\t\t...\t\t\t*/\npublic:\n    Result submitTask(std::shared_ptr<Task> sp);\n/*\t\t\t...\t\t\t*/\n};\n--------------------------\nResult ThreadPool::submitTask(std::shared_ptr<Task> sp)\n{\n/*\t\t\t...\t\t\t*/\n\tif(...)\n    {\n        ...\n/*\t\t思考，return时用下面哪种方式？\t*/\n/*      return task->getResult();\t */\n        // 此时是提交任务失败的返回\n        return Result(task);\n    }\n\n/*\t\t\t...\t\t\t*/\n\n/*\t思考，return时用下面哪种方式？\t*/\n/*  return task->getResult();\t */\n    // 此时是提交任务成功后的返回\n    return Result(task);\n}\n```\n\n经过上面的讨论，Result类成员里需要绑定一个Task对象。即下面的`task_`。下面是Result成员和其构造。\n\n```cpp\n/* 实现接收提交到线程池的task任务执行完成后的返回值类型Result */\nclass Result\n{\npublic:\n    Result(std::shared_ptr<Task> task, bool isValid = true);\n    ~Result() = default;\nprivate:\n    /* 存储任务的返回值 */\n    Any any_;\n    /* 线程通信信号量 */\n    Semaphore sem_;\n    /* 指向对应获取返回值的任务对象 */\n    std::shared_ptr<Task> task_;\n    /* 任务执行是否有效/成功 */\n    std::atomic_bool isValid_;\n}\n------------------\n//threadpool.cpp\nResult::Result(std::shared_ptr<Task> task, bool isValid)\n    : isValid_(isValid), task_(task)\n{\n}\n\n```\n### 成员函数\n* 问题1：setVal函数，获取任务执行完的返回值，记录在any成员。\n* 问题2：get函数，用户调用这个方法获取task的返回值（没执行完需要阻塞）\n\n```cpp\nclass Result\n{\npublic:\n    void setVal(Any any);\n    Any get();\nprivate:\n    Any any_;\n    Semaphore sem_;\n    std::shared_ptr<Task> task_;\n    std::atomic_bool isValid_;\n};\n-------------\n/* \t用户调用的 */\nAny Result::get()\n{\n    if(!isValid_)\n    {\n        return \"\";\n    }\n    /* 阻塞用户的线程直到task通知其执行完毕 */\n    sem_.wait();\n    return std::move(any_);\n}\n/* 谁调用？答案是 Task 的 run 结束之后，通过Result * result_ 间接调用次函数，通知 get() 唤醒拿结果 */\nvoid Result::setVal(Any any)\n{\n    /* 存储task的返回值 */\n    this->any_ = std::move(any);\n    sem_.post();\n}\n```\n## Task增加方法，把结果写入Result\n\n思想：在threadFun函数中，不仅要靠task对象Task类中的run方法执行具体哪种任务，还要把任务的返回值给到result，可以用exec来封装，exec没有多态，run有多态。\n\n```cpp\nvoid Task::exec()\n{\n    if(result_ != nullptr)\n    {\n        // run()结束之后，setVal才能被调用成功，此时影响到了 result_ 中保存的信号量 +1，因此 外部的result.get()不再阻塞\n\t    result_->setVal(run());\t//如此可知，task中需要封装一个result对象。\n    }\n}\n----------------\nclass Task\n{\npublic:\n    Task();\n    ~Task() = default;\n\tvoid exec();\n    void setResult(Result *res);\n    virtual Any run() = 0;\nprivate:\n/*\t没必要用shared智能指针，否则就会出现：Result中有shared_ptr<Task>，Task中有shared_ptr<Result>。循环引用，无法释放！*/\n    Result *result_;\t//result对象的生命周期长于task，不怕。\n};\n----------------\nvoid Task::setResult(Result *res)\n{\n    result_ = res;\n}\nTask::Task()\n    : result_(nullptr)\n{       \n}\n----------------\n/* 谁调用setResult？此 Result 不是 Result 里的 val ， 而是保存 Val 的一个地方，不要搞混了 */\n// 外部可以通过 task 来 指定 Result 要保存到哪个地方。\n// 比如可以传入 外部 Result 的 this 指针；也可以 new 一个 Result 在 堆上，set 到堆上地址\n// 如果 Result 绑定了一个 task 就可以 通过这个 task 设置 Result 为 自己（this）\nResult::Result(std::std::shared_ptr<Task> task, bool isValid)\n\t: isValid_(isValid), task_(task)\n{\n    task_->setResult(this);\n}\n```\n\n## 测试2（Master - Slave模型）\n\nMaster - Slave模型，Master线程用来分解任务，然后给各个Slave线程分配任务，等待各个Slave线程执行完任务，返回结果。最后Master线程合并各个任务结果，输出。\n\n```cpp\nclass MyTask : public Task\n{\npublic:\n    MyTask(int begin, int end)\n    \t: begin_(begin), end_(end)\n    {\n    }\n\tAny run()\n    {\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"begin!\" << std::endl;\n        uLong sum = 0;\n        for(uLong i = begin_; i <= end_; ++i)\n            sum += i;\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"end!\" << std::endl;\n        return sum;\n    }\n};\nusing uLong = unsigned long long;\nint main()\n{\n    ThreadPool pool;\n    pool.start(4);\n    Result res1 = pool.submitTask(std::make_shared<MyTask>(1, 100000000));\n    Result res2 = pool.submitTask(std::make_shared<MyTask>(100000001, 200000000));\n    Result res3 = pool.submitTask(std::make_shared<MyTask>(200000001, 300000000));\n    uLong sum1 = res1.get().cast_<uLong>();\n    uLong sum2 = res2.get().cast_<uLong>();\n    uLong sum3 = res3.get().cast_<uLong>();\n    cout << sum1 + sum2 + sum3 << endl;\n}\n```\n\n测试结果：\n\n![image-20220407095057418](../../images/线程池2.0/image-20220407095057418.png)\n\n# cached模式线程池\n\n主要的使用点：submitTask函数中，可能需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程。\n* 需要处理的问题\n    * 问题1，用户自己如何设置线程池的工作模式\n    * 问题2，submitTask函数中，根据任务数量和空闲线程的数量，判断是否需要创建新的线程\n    * 问题3，threadFunc函数中，有可能已经创建了很多的线程，如果空闲时间超过60s，需要结束、回收。\n\n```cpp\nint main()\n{\n    ThreadPool pool;\n    /* 用户自己设置线程池的工作模式 */\n    pool.setMode(PoolMode::MODE_CACHED);\n    /* 开始启动线程池 */\n    pool.start(4);\n}\n```\n\n## 切换工作模式\n\n为了防止用户在线程池启动后再去切换线程池的工作模式，我们需要给线程池添加一个状态变量，以控制用户能否对线程池的工作模式进行切换。\n\n```cpp\nclass ThreadPool\n{\npublic:\n/*\t\t\t...\t\t\t*/\nprivate:\n/*\t\t\t...\t\t\t*/\n    /* 检查pool的运行状态 */\n    bool checkRunningState() const;\nprivate:\n/*\t\t\t...\t\t\t*/\n    \n    /* 表示当前线程池的启动 */\n    std::atomic_bool isPoolRunning_;\n};\n-------------------------------------------\nThreadPool::ThreadPool()\n\t: initThreadSize_(0),\n\t  taskSize_(0),\n\t  taskQueMaxThreshHold_(TASK_MAX_THRESHHOLD),\n\t  poolMode_(PoolMode::MODE_FIXED),\n\t  isPoolRunning_(false)\n{\n}\nvoid ThreadPool::start(int initThreadSize)\n{\n    /* 设置线程池的状态为运行态 */\n    isPoolRunning_ = true;\n    \n/*\t\t\t...\t\t\t*/\n}\nbool ThreadPool::checkRunningState() const\n{\n    return isPoolRunning_;\n}\n------------------------------------------\nvoid ThreadPool::setMode(PoolMode mode)\n{\n    if(checkRunningState())\n        return;\n    poolMode_ = mode;\n}\n```\n\n## 创建更多线程\n\ncached模式：任务处理比较紧急，场景是小而快的任务。\n\nThreadPool需要添加记录一个空闲线程数量的变量。\n\n```cpp\nclass ThreadPool\n{\npublic:\n/*\t\t\t...\t\t\t*/\nprivate:\n/*\t\t\t...\t\t\t*/\nprivate:\n/*\t\t\t...\t\t\t*/\n\n    /* 记录空闲线程的数量 */\n    std::atomic_int idleThreadSize_;\n}\n-------------------------------------------\nThreadPool::ThreadPool()\n\t: initThreadSize_(0),\n\t  taskSize_(0),\n\t  idleThreadSize_(0),\n\t  taskQueMaxThreshHold_(TASK_MAX_THRESHHOLD),\n\t  poolMode_(PoolMode::MODE_FIXED),\n\t  isPoolRunning_(false)\n{\n}\n/* 空闲线程数量需要加1 */\nvoid ThreadPool::start(int initThreadSize)\n{\n/*\t\t\t...\t\t\t*/\n    /* 每启动一个线程就给idleThreadSize_加1，表示多了一个空闲线程 */\n    for(int i = 0; i < initThreadSize_; ++i)\n    {\n        threads_[i]->start();\n        ++idleThreadSize_;\n    }\n}\n/* 空闲线程数量需要减1 */\nvoid ThreadPool::threadFunc()\n{\n    for(;;)\n    {\n    /*\t\t\t...\t\t\t*/\n        std::shared_ptr<Task> task;\n        {\n            notEmpty_.wait(lock, [&]()->bool {return taskQue_.size()>0;});\n            --idleThreadSize_;\n        }\n    /*\t\t\t...\t\t\t*/\n    \tnotFull_.notify_all();\n    }\n    if(task != nullptr) task -> exec();\n    ++idleThreadSize_;\n}\n```\n\n现在来增加 submitTask 函数对 cached 模式处理的细节。\n有一点要注意，就是尽管任务非常多，但是我们要对线程的数量设一定的上限值。\n即需要给 ThreadPool 类增加一个线程数量阈值变量。\n\n然后为了比较线程池当前线程的数量状况，也要添加一个记录线程总数量的变量。\n\n```cpp\nconst int THREAD_MAX_THRESHHOLD = 10;\nclass ThreadPool\n{\npublic:\n/*\t\t\t...\t\t\t*/\n    /* 设置线程池cached模式下的线程阈值 */\n    void setThreadSizeThreshHold(int threshhold);\n/*\t\t\t...\t\t\t*/\nprivate:\n/*\t\t\t...\t\t\t*/\nprivate:\n/*\t\t\t...\t\t\t*/\n    /* 线程数量上限阈值 */\n    int threadSizeThreshHold_;\n    /* 记录当前线程池里面线程的总数量 */\n    std::atomic_int curThreadSize_;\n/*\t\t\t...\t\t\t*/\n};\nThreadPool::ThreadPool()\n\t: initThreadSize_(0),\n\t  taskSize_(0),\n\t  idleThreadSize_(0),\n\t  curThreadSize_(0),\n\t  taskQueMaxThreshHold_(TASK_MAX_THRESHHOLD),\n\t  threadSizeThreshHold_(THREAD_MAX_THRESHHOLD),\n\t  poolMode_(PoolMode::MODE_FIXED),\n\t  isPoolRunning_(false)\n{\n}\nvoid ThreadPool::start(int initThreadSize)\n{\n/*\t\t\t...\t\t\t*/\n    /* 记录初始线程个数 */\n    initThreadSize_ = initThreadSize;\n    curThreadSize_ = initThreadSize;\n    /* 创建线程对象 */\n/*\t\t\t...\t\t\t*/\n    /* 启动所有线程 */\n/*\t\t\t...\t\t\t*/\n}\nvoid ThreadPool::setThreadSizeThreshHold(int threshhold)\n{\n    if(checkRunningState() || poolMode_==PoolMode::MODE_FIXED)\n        return;\n    threadSizeThreshHold_ = threshhold;\n}\n-------------------------------------------------------\n/* 关注三个状态：\n * 1.线程池的工作模式是否是cached；\n * 2.任务数量是否已经大于空闲线程数量；\n * 3.线程总数量是否没有超过线程数量上限；\n */\nResult ThreadPool::submitTask(std::shared_ptr<Task> sp)\n{\n/*\t\t\t...\t\t\t*/\n    if(poolMode_ == PoolMode::MODE_CACHED\n      && taskSize_ > idleThreadSize_\n      && curThreadSize_ < threadSizeThreshHold_)\n    {\n        /* 创建新线程 */\n        auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::threadFunc, this));\n        threads_.emplace_back(std::move(ptr));\n        threads_[threadId]->start();\t//启动线程\n        /* 修改线程个数相关的变量 */\n        ++curThreadSize_;\n        ++idleThreadSize_;\n    }\n    \n    return Result(sp);\n}\n```\n\n## 任务处理完毕，回收多余线程\n\n超过`initThreadSize_`数量的线程要进行回收。\n\n**当前时间 比 上一次线程执行完毕的时间** 大于 60s 后回收。\n\n> `C++11`中提供了高精度时间API - `std::chrono::high_resolution_clock().now()`;\n\n```cpp\nconst int THREAD_IDLE_TIME = 60;\t//单位s\nvoid ThreadPool::threadFunc(int threadid)\n{\n    /* 上一次线程执行完任务的时间 */\n    auto lastTime = std::chrono::high_resolution_clock().now();\n    for(;;)\n    {\n    \tTask task;\n        {\n            std::unique_lock<std::mutex> lock(taskQueMtx_);\n            std::cout << \"tid: \" << std::this_thread::get_id()\n                << \"尝试获取任务...\" << std::endl;\n                \n            // cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程\n            // 结束回收掉（超过initThreadSize_数量的线程要进行回收）\n            // 当前时间 - 上一次线程执行的时间 > 60s\n\n            // 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回\n            // 锁 + 双重判断\n            while (taskQueue_.size() == 0)\n            {\n                // 线程池要结束，回收线程资源\n                if (!isPoolRunning_)\n                {\n                    threads_.erase(threadid);\n                    std::cout << \"threadid: \" << std::this_thread::get_id() << \" exit!\"\n                        << std::endl;\n                    exitCond_.notify_all();\n                    return;\n                }\n                \n                if (poolMode_ == PoolMode::MODE_CACHED)\n                {\n                    //while(taskQue_.size() > 0) // 不再去判断 taskQue_.size() > 0，即使size是0，也一直等待60s\n                    //{\n                    \n                    /* 超时 1s 返回 */\n                    if(std::cv_status::timeout ==\n                       notEmpty_.wait_for(lock, std::chrono::seconds(1)))\n                    {\n                        auto now = std::chrono::high_resolution_clock().now(); //返回的是time_point类型\n                        auto dur = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime);\n                        if(dur.count() >= THREAD_MAX_IDLE_TIME\n                          && curThreadSize_ > initThreadSize_)\n                        {\n                            /* 开始回收当前线程 */\n                            /* 修改记录线程数量的相关变量 */\n                            /* 把线程从线程列表容器中删除 */\n                            /* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */\n                            /* 我们需要有一个映射关系来记录：threadid => thread对象 => 删除 */\n                            thread_.erase(threadid);\n                            --curThreadSize_;\n                            --idleThreadSize_;\n                            std::cout << \"threadid: \" << std::this_thread::get_id() << \" exit!\"\n                                << std::endl;\n                            return;\n                        }\n                    } \n                    //} // while(taskQue_.size() > 0) 结束\n                } \n                else // poolMode_ != PoolMode::MODE_CACHED\n                {\n                    notEmpty_.wait(lock /* , [&]()->bool { return taskQue_.size() > 0; } */);\n                }\n            } // end while (taskQueue_.size() == 0)\n\n            // 此时 taskQueue_.size() != 0 而 我们又拿到了 任务队列的锁，可以直接取走任务\n            --idleThreadSize_;\n            std::cout << \"tid: \" << std::this_thread::get_id()\n                << \"获取任务成功...\" << std::endl;\n            task = taskQue_.front();\n            taskQue_.pop();\n            --taskSize_;\n\n            if (taskQue_.size() > 0)\n            {\n                notEmpty_.notify_all();\n            }\n\n            notFull_.notify_all();\n        } // end std::unique_lock<std::mutex> lock(taskQueMtx_);\n        if(task != nullptr)\n        {\n            task();\n        }\n        ++idleThreadSize_;\n        /* 线程执行完任务后更新lastTime */\n        lastTime = std::chrono::high_resolution_clock().now();\n    }\n}\n```\n\n## 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象？\n\n我们需要有一个映射关系来记录：`threadid - thread对象`\n```cpp\n    std::unordered_map<int, std::unique_ptr<Thread>> threads_;\n```\n\n所以，Thread对象需要封装一个id值。\n然后，在线程函数`threadFunc`传入`int threadid`参数。\n这样，该 id 的Thread在线程函数中计时自己的空闲时间，若连续 wait 了 60s（每wait一次1s超时返回），说明任务过少，空闲线程过多。\n只有知道了 id 号，才能让 ThreadPool 记录的 线程map 精确地删除。\n\n```cpp\nclass Thread\n{\npublic:\n    using ThreadFunc = std::function<void()>;\n    Thread(ThreadFunc func);\n    ~Thread();\n    void start();\n    /* 启动线程 */\n    int getId() const;\nprivate:\n    ThreadFunc func_;\n    // 这是属于 Thread类 共享的计数器。表示曾经已生成了多少个线程对象\n    static int generateId;\n    // 当前Thread 对象的ID\n    int threadId_;\n}\n----------------------------------------------\nint Thread::generateId_ = 0;\nThread::Thread(ThreadFunc func)\n\t: func_(func), threadId(++generateId_)\n{\n    \n}\nint Thread::getId() const\n{\n    return threadId_;\n}\n```\n\n然后，最大的变化来了，把原先的线程列表的vector容器变成了unordered\\_map。\n```cpp\nclass ThreadPool\n{\n// ...\nprivate:\n    std::unordered_map<int, std::unique_ptr<Thread>> threads_; // 线程列表\n// ...\n};\n```\n\n因此，在 start 启动线程池的操作中，生成线程的动作就要有所变化\n\n要预留一个占位符`_1`，这是给线程函数的传入参数的位置，`threadid`。\n\n```cpp\n// 开启线程池\nvoid ThreadPool::start(int initThreadSize = std::thread::hardware_concurrency())\n{\n    // 设置线程池的运行状态\n    isPoolRunning_ = true;\n\n    // 记录初始线程个数\n    initThreadSize_ = initThreadSize;\n    curThreadSize_ = initThreadSize;\n\n    // 创建线程对象\n    for (int i = 0; i < initThreadSize_; i++)\n    {\n        // 创建thread线程对象的时候，把线程函数给到thread线程对象\n        auto ptr = std::make_unique<Thread>(std::bind(&ThreadPool::threadFunc, this, std::placeholders::_1));\n        int threadId = ptr->getId();\n        threads_.emplace(threadId, std::move(ptr));\n        // threads_.emplace_back(std::move(ptr));\n    }\n\n    // 启动所有线程  std::vector<Thread*> threads_;\n    for (int i = 0; i < initThreadSize_; i++)\n    {\n        threads_[i]->start(); // 需要去执行一个线程函数\n        idleThreadSize_++;    // 记录初始空闲线程的数量\n    }\n}\n```\n## 改为无序哈希表存储id、Thread对象映射关系，后的代码调整\n### submitTask\n```cpp\nResult ThreadPool::submitTask(std::shared_ptr<Task> sp)\n{\n/*\t\t\t...\t\t\t*/\n    if(poolMode == PoolMode::MODE_CACHED\n      && taskSize_ > idleThreadSize_\n      && curThreadSize_ < threadSizeThreshHold_)\n    {\n        auto ptr = std::make_unique<Thead>(std::bind(&ThreadPool::threadFunc, this));\n        int threadId = ptr->getId();\n        threads_.emplace(threadId, std::move(ptr));\n        threads_[threadId]->start();\n        /* 修改线程个数相关的变量 */\n        ++curThreadSize_;\n        ++idleThreadSize_;\n    }\n    return Result(sp);\n}\n```\n### ThreadPool的`threadFunc(int threadid)`接口添加int参数\n\n```cpp\nclass ThreadPool\n{\npublic:\n    ...\nprivate:\n    /* 定义线程函数，加了一个参数threadid */\n    void threadFunc(int threadid);\n    ...\nprivate:\n\t...\n}\n```\n### Thread中`using ThreadFunc`的`std::function<void(int)>`\n```cpp\nclass Thread\n{\npublic:\n    /* 要和threadFunc函数参数一致 */\n    using ThreadFunc = std::function<void(int)>;\n}\n```\n### Thread的start，多传入一个`threadId_`\n```cpp\nvoid Thread::Start()\n{\n    std::thread t(func_, threadId_);\n    t.detach();\n}\n```\n## 测试3\n\n```cpp\nclass MyTask : public Task\n{\npublic:\n    MyTask(int begin, int end)\n\t\t: begin_(begin), end_(end)\n    {\n    }\n    Any run()\n    {\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"begin!\" << std::endl;\n        std::this_thread::sleep_for(std::chrono::seconds(3));\n        uLong sum = 0;\n        for(uLong i = begin_; i <= end_; ++i)\n            sum += i;\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"end!\" << std::endl;\n        return sum;\n    }\n};\n---------------------------------------------------------------------------------------\n/* 在submitTask函数中 加打印线程的相关信息 */\nResult ThreadPool::submitTask(std::shared_ptr<Task> sp)\n{\n/*\t\t\t...\t\t\t*/\n    if(poolMode == PoolMode::MODE_CACHED\n      && taskSize_ > idleThreadSize_\n      && curThreadSize_ < threadSizeThreshHold_)\n    {\n        std::cout << \">>> create new thread ...\" << std::endl;\n        auto ptr = std::make_unique<Thead>(\n            std::bind(&ThreadPool::threadFunc,\n                      this, std::placeholders::_1)\n        );\n        int threadId = ptr->getId();\n        threads_.emplace(threadId, std::move(ptr));\n        threads_[threadId]->start();\t//启动线程\n        /* 修改线程个数相关的变量 */\n        ++curThreadSize_;\n        ++idleThreadSize_;\n    }\n    return Result(sp);\n}\n--------------------------------------------------------------------------------------\n/* 暂时修改超时时间，方便测试观察 */\nconst int THREAD_MAX_IDLE_TIME = 10;\nvoid ThreadPool::threadFunc()\n{\n\t\t\t\t\t/*\t\t\t...\t\t\t*/\n                    \tif(dur.count() >= THREAD_MAX_IDLE_TIME\n                          && curThreadSize_ > initThreadSize_)\n                        {\n                            ...\n                        }\n\t\t\t\t\t/*\t\t\t...\t\t\t*/\n}\n--------------------------------------------------------------------------------------\n/* 默认初始四线程，六任务。\n * 每个任务都至少消耗3秒，\n * 开始时会把四个线程都占住，会创建新的线程来完成后两个任务\n * 全部任务完成后，超过10秒后，会把多余的2个线程回收。\n */\nconst int TASK_MAX_THRESHHOLD = INT32_MAX;\nconst int THREAD_MAX_THRESHHOLD = 10;\nint main()\n{\n    {\n        ThreadPool pool;\n        pool.setMode(PoolMode::MODE_CACHED);\n        pool.start(4);\n        Result res1 = pool.submitTask(std::make_shared<MyTask>(1,100000000));\t\t\t//1\n        Result res2 = pool.submitTask(std::make_shared<MyTask>(100000001,200000000));\t//2\n        Result res3 = pool.submitTask(std::make_shared<MyTask>(200000001,300000000));\t//3\n        pool.submitTask(std::make_shared<MyTask>(200000001,300000000));\t\t\t\t\t//4\n\n        pool.submitTask(std::make_shared<MyTask>(200000001,300000000));\t\t\t\t\t//5\n        pool.submitTask(std::make_shared<MyTask>(200000001,300000000));\t\t\t\t\t//6\n        uLong sum1 = res1.get().cast_<uLong>();\n        uLong sum2 = res2.get().cast_<uLong>();\n        uLong sum3 = res3.get().cast_<uLong>();\n    }\n    getchar();\n}\n```\n\n测试结果\n\n![image-20220407172417250](../../images/线程池2.0/image-20220407172417250.png)\n\n![image-20220407172451064](../../images/线程池2.0/image-20220407172451064.png)\n\n![image-20220407172642102](../../images/线程池2.0/image-20220407172642102.png)\n\n## 问题：ThreadPool对象析构以后，怎么样把线程池相关的线程资源全部回收\n\n在析构函数中，用户线程需要等待线程池线程，这是两类不同的线程，需要通过线程间通信来达到等待完成。\n\n线程间通信可以用信号量、条件变量，都可以，我们在ThreadPool类中使用一个条件变量`exitCond_`。\n\n```cpp\nclass ThreadPool\n{\npublic:\n    ...\nprivate:\n    ...\nprivate:\n    ...\n    /* 等待线程资源全部回收 */\n    std::condition_variable exitCond_;\n    ...\n}\n```\n\n在析构函数中，\n1. 置`isPoolRunning_`为false，如此线程函数进去之后发现线程池要关闭了，\n    1. 如果任务队列为0，则就直接退出。\n    2. 如果任务队列不为0则取任务。\n2. `notEmpty_.notify_all();`，最后一波唤醒，让所有线程醒来，看有没有任务，没任务就收工。\n3. ThreadPool关注`exitCond_`，若有人通知了，则说明是线程陆陆续续在退出了，直到`threads_.size() == 0`，说明所有线程都退出了。这时候，线程池就可以放心析构了。\n\n```cpp\nThreadPool::~ThreadPool()\n{\n    isPoolRunning_ = false;\n    notEmpty_.notify_all();\n    /* 等待线程池中所有的线程返回，有两种状态：阻塞/执行中 */\n    std::unique_lock<std::mutex> lock(taskQueMtx_);\n    exitCond_.wait(lock, [&]()->bool {return threads_.size() == 0;});\n}\n```\n\n# 项目推进时遇到了什么问题？\n1. 实现核心功能时的问题：如何通用地获取提交任务后的返回值，即Any，Result的设计。\n2. 设计线程池资源回收的，是以...的方式实现的，测试时，有时会出现死锁的现象\n## 调试方法\ngdb调试，attach到正在死锁的进程，把线程栈打印出来，在哪一个函数的哪一句话不动了。\n\n问题要素：\n1、线程池要结束，要释放整个池子的资源了。\n2、线程池的成员`isPoolRunning_`状态置为了`false`。\n\n以上两个要素\n\n1，不受线程池内的线程目前的状态而影响，线程的状态：在等待任务、在执行任务。\n2，`isPoolRunning_`必将影响线程的代码路径。\n\n`isPoolRunning_`在线程池`start`时置为`true`。\n\n我们设计的ThreadPool不用考虑成员的析构问题，最主要的两个成员容器：\n1、无序map中的线程对象是`unique_ptr`管理的。\n2、queue中的任务队列是`shared_ptr`管理的。\n3、其余的变量都是非指针变量。\n\nThreadPool析构时仅仅只是把`isPoolRunning_`置`false`就可以了吗？\n当然不可以。线程池要等待线程池里面所有的线程返回。\n目前线程可能在`threadFunc`函数中阻塞在`notEmpty`上，另一种是正在执行任务中。\n\n此时就需要不同线程的通信。即用户线程和线程池中的线程之间进行通信。\n用信号量、条件变量都可以。\n我们用条件变量。\n在ThreadPool中定义一个成员，`std::condition_variable exitCond_;` 等待线程资源全部回收\n\n```cpp\nThreadPool::~ThreadPool()\n{\n    isPoolRunning_ = false;\n    /* 我们暂且在这个位置 唤醒notEmpty_上的所有线程 */\t//实际上，是留了一个坑\n    notEmpty_.notify_all();\n    \n    std::unique_lock<std::mutex> lock(taskQueMtx_);\n    /* 表明：要等待到threads_.size()等于0 */\n    exitCond_.wait(lock, [&]()->bool {return threads_.size()==0;});\n}\n```\n\n```cpp\n//可能会产生死锁的情况：\nint main()\n{\n    ThreadPool pool;\n    pool.start(4);\n    Result res1 = pool.submitTask(std::make_shared<MyTask>(1,10000000));\n    uLong sum1 = res1.get().cast_<uLong>();\n    cout << sum1 << endl;\n    cout << \"main over!\" << endl;\n}\n/* 运行结果\n * tid: 9624尝试获取任务..\n * tid: 9624获取任务成功...\n * tid:tid: 1664尝试获取任务...\n * 9624begin!\n * tid: 15228尝试获取任务...\n * tid:6796尝试获取任务...\n * tid:9624end!\n * tid:9624尝试获取任务...5000000050000000\n * main over!\n * \n * threadid:6796 exit!\n * threadid:s1664 exit!\n * threadid:15228 exit!\n *\t\t//发现，抢到任务的线程回不来了。\n */\n```\n\n## 代码分析\n\n```cpp\n/* main函数所在的主线程，即用户创建线程池的线程 */\nThreadPool::~ThreadPool()\n{\n    isPoolRunning_ = false;\n    notEmpty_.notify_all();\n    std::unique_lock<std::mutex> lock(taskQueMtx_);\n    exitCond_.wait(lock, [&]()->bool {return threads_.size()==0;});\n}\n/* 线程池中的每个线程的线程函数 */\nvoid ThreadPool::threadFunc(int threadid)\n{\n    auto lastTime = ...;\n    while(isPoolRunning_)\n    {\n        std::shared_ptr<Task> task;\n        {\n            std::unique_lock<std::mutex> lock(taskQueMtx_);\t\t//抢锁动作\n            std::cout << \"tid: \" << std::this_thread::get_id()\n                << \"尝试获取任务... \" << std::endl;\n            while(taskQue_.size() == 0)\n            {\n                if(poolMode_ == PoolMode::MODE_CACHED)\n                {\n                    /* timeout==wait_for的返回值 意味着等待超时了 */\n                    if(std::cv_status::timeout ==\n                       notEmpty_.wait_for(lock, std::chrono::seconds(1)))\n                    {\n                        //回收长时间空闲的线程\n                        return;\n                    }\n                    /* 否则，说明被唤醒了，有任务了，且抢到锁了，继续往下 */\n                }\n                else /* 若不是cached模式，则按部就班老实等待 */\n                {\n                    notEmpty_.wait(lock);\n                }\n            }\n\t\t\tif(!isPoolRunning_)\n            {\n                threads_.erase(threadid);\n                std::cout << \"threadid:\" << std::this_thread::get_id()\n                    << \" exit:\" << std::endl;\n                /* 每一个线程删除后，都通知exitCond_一下，唤醒用户主线程 */\n                exitCond_.notify_all();\n                return;\n            }\n        }\n        /* 若被唤醒了，有任务了，且抢到锁了，而且确认了isPoolRunning，则可以取得任务 */\n        --idleThreadSize_;\n        std::cout << \"tid:\" << std::this_thread::get_id()\n            << \"获取任务成功...\" << std::endl;\n    }\n}\n```\n\n第一种情况：线程是固定模式，任务队列空时，等待在`notEmpty_`上。这种情况我们不怕，因为线程池析构函数已经写了`notEmpty_.notify_all()`;\n\n第二种情况：`task->exec()`中，即线程执行任务中。这种也没事，线程执行完任务再次进入while循环判断时发现`isPoolRunning_为false`了，则删除线程，退出。\n\n第三种情况才是关键，线程`task->exec()` 执行完后进入了`while (isPoolRunning_)`循环，到了获取锁语句之前的位置。这时，线程池关闭了，也就是说在Running状态切换为`false`！现在，线程池、子线程的下一个动作都是对`taskQueMtx_`进行加锁！而最关键的，**如果能够“阴差阳错地”进入第二个`while`循环，那么就会在`notEmpty_`上等死**，因为此时线程池在语义上是已经关闭了，没人再去唤醒它。\n\n第三种情况中的第一种情况：线程池抢到锁，又在`exitCond_`上`wait`阻塞，而子线程虽然能抢到锁，但是会死在`notEmpty_`上。\n\n第三种情况中的第二种情况：子线程抢到锁，往下执行，则没有任务时，在`notEmpty_`上等待会放弃锁，阻塞自己，线程池之后会抢到锁，等待线程结束。**这时没有人去唤醒notEmpty\\_上的子线程了。死锁。这是问题之关键**。\n\n那么，第三种情况怎么解决死锁问题呢？\n\n我们注意到，第三种情况中第一种情况的问题是因为线程池`exitCond_.wait()`后，进入了第一个`while`后争抢`lock`的线程可能拿到锁后，顺理成章进入第二个`while`中，若恰逢没有任务，则死在了`notEmpty_`上。所以为了防止错误的时机进入到第二个`while`循环中，在条件处首先再判断一次`isPoolRunning_`。\n\n### 3.1的解决方案：锁+双重判断\n\n```cpp\nvoid ThreadPool::threadFunc(int threadid)\n{\n    auto lastTime = ...;\n    while(isPoolRunning_)\n    {\n        std::shared_ptr<Task> task;\n        {\n            std::unique_lock<std::mutex> lock(taskQueMtx_);\n            std::cout << ... << std::endl;\n            while(isPoolRunning_ && taskQue_.size()==0)\n            {\n                if(poolMode_ == PoolMode::MODE_CACHED)\n                {\n                    if(std::cv_status::timeout ==\n                       notEmpty_.wait_for(lock, std::chrono::seconds(1)))\n                    {\n                        //...\n                        return;\n                    }\n                }\n                else\n                {\n                    notEmpty_.wait(lock);\n                }\n            }//退出while的两种情况：1.!Running, 2.Running && taskQue_.size()!=0\n            if(!isPoolRunning_)\n            {\n\t\t\t\tbreak;\n            }\n            --idleThreadSize_;\n            std::cout << \"获取任务成功\" << std::endl;\n            task = taskQue_.front();taskQue_.pop();\n            --taskSize_;\n            notFull_.notify_all();\n        }\n        if(task != nullptr)task->exec();\n        ++idleThreadSize_;\n        lastTime = ...;\n    }\n    threads_.erase(threadid);\n    std::cout << \"线程退出\" << std::endl;\n    exitCond_.notify_all();\n    return;\n}\n```\n\n如此一来，线程池先抢到锁，再在`exitCond_`上`wait`阻塞释放锁后，子线程得到锁向下走到了第二个while语句，由于再次判断`isPoolRunning_`，这时发现改变为`false`了，就不会走到`notEmpty_.wait()`了。灰溜溜去做删除动作了。\n\n### 3.2的解决方案：调整加锁位置\n\n虽然3.1解决了`isPoolRunning`状态脏读这个漏洞问题，但是依旧不能解决“子线程先抢到锁”从而在`notEmpty_`上等待这种情况发生。即使子线程释放了锁，但是没有人再去唤醒`notEmpty_`，因为原来的语序是先唤醒，再抢锁。所以我们要让用户线程的加锁、唤醒放在子线程wait之后，**要让子线程wait释放了锁之后，才让用户线程唤醒`notEmpty_`**！于是：\n\n```cpp\nThreadPool::~ThreadPool()\n{\n    isPoolRunning_ = false;\n    std::unique_lock<std::mutex> lock(taskQueMtx_);\n    notEmpty_.notify_all();\n    exitCond_.wait(lock, [&]()->bool {return threads_.size()==0;});\n}\n```\n\n调换了一下第二、第三句，即子线程先抢到锁后wait在`notEmpty_`上后释放锁，用户线程再抢到锁之后才去`notify_all()`它，那么阻塞的子线程被唤醒了，往下执行，发现`isPoolRunning_`变为`false`了，灰溜溜去做删除动作了。完美解决问题。\n\n# 编译为动态库\n\n## 直接在命令行使用`g++`编译\n\n```bash\ng++ -o libxcg-threadpool.so -fPIC -shared [源文件如: threadpool.cpp] -std=c++17\n```\n\n## 用cmake构建编译\n\n### 根目录\n\n```cmake\ncmake_minimum_required(VERSION 3.0.0)\nproject(xcg-threadpool)\n#配置编译选项\nset(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} -g)\n#配置最终的库文件输出的路径\nset(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)\n#配置头文件的搜索路径\ninclude_directories(${PROJECT_SOURCE_DIR}/include)\n#加载子目录\nadd_subdirectory(src)\n```\n\n### src目录\n\n```cmake\n#定义了SRC_LIST变量，包含了该目录下所有的源文件\naux_source_directory(. SRC_LIST)\n#指定生成可执行文件\nadd_library(${PROJECT_NAME} SHARED ${SRC_LIST})\n#指定可执行文件链接时 需要依赖的库文件\ntarget_link_libraries(xcg-threadpool pthread)\n```\n\n# 使用动态库编译可执行文件\n\n首先需要把动态库`libxcg-threadpool.so`移动到`/usr/lib`或`/usr/local/lib`；把动态库对应的头文件`threadpool.h`移动到`/usr/include`或`/usr/local/include`下。\n\n```bash\ng++ -o main main.cpp -std=c++17 -lxcg-threadpool -lpthread\n```\n\n# 重构简洁版的线程池\n要对外提供一个简单易用的submitTask接口。\n让用户直接传一个：`future result = submitTask(func, 1, 2);`\n而不用再去继承一个抽象的Task了，甚至还得`make_shared<MyTask()>(func, 1, 2);`，这样太繁琐了。\n\n主要用到的技巧就是：可变参模板，万能引用，函数绑定器，完美转发。\nsubmitTask的返回类型无法写出，需要用到auto占位，之后用decltype进行推导。\n## ThreadPool成员变量\n```cpp\nprivate:\n    std::unordered_map<int, std::unique_ptr<Thread>> threads_;\n    int initThreadSize_;\n    int threadSizeThreshHold_;\n    std::atomic_int curThreadSize_;\n    std::atomic_int idleThreadSize_;\n\n    using Task = std::function<void()>;\n    // 此处之前的版本是智能指针管理的task，目前不需要了。\n    // 因为我们把sharedptr对Task的包装都在submitTask内部进行封装了。\n    std::queue<Task> taskQue_;\n\n    std::atomic_int taskSize_;\n    int taskQueMaxThreshHold_;\n\n    std::mutex taskQueMtx_;\n    std::condition_variable notFull_;\n    std::condition_variable notEmpty_;\n    std::condition_variable exitCond_;\n\n    PoolMode poolMode_;\n    std::atomic_bool isPoolRunning_;\n};\n```\n## 优化submitTask\n以下的关键点：任务队列中存储的任务（lambda）捕获了`shared_ptr`，因此当这个任务被执行时，它仍然持有一个`shared_ptr`，这样`packaged_task`就不会在执行前被销毁。\n当任务执行完毕，这个lambda就会被销毁，那么它持有的`shared_ptr`也会被销毁（引用计数减一）。如果这时没有其他`shared_ptr`引用（比如在`submitTask`函数中，除了任务队列中的那个`shared_ptr`，还有`submitTask`函数中的局部变量`task`），那么`packaged_task`就会在任务执行完毕后被销毁。\n\n但是，在submitTask函数中，我们返回了一个`future`，这个`future`是与`packaged_task`关联的。值得注意的是，`std::packaged_task`的析构不会影响其关联的`future`吗？不会。因为`std::future`是通过共享状态（shared state）与`std::packaged_task`关联的，这个共享状态独立于`packaged_task`对象。也就是说，即使`packaged_task`对象销毁了，只要共享状态还存在（因为`future`还持有），那么`future`仍然可以正常工作。所以，`packaged_task`对象销毁后，`future`的`get()`仍然可以正常返回结果（或者异常）。\n\n我们要明确的：\nfuture只是负责持有结果。但\n**future 不会延长 task 的生命周期​**​，\n- `std::future` 只管理​**​共享状态​**​（shared state）的生命周期（存储结果的内存区域）\n- ​**​不会​**​延长关联的 `packaged_task` 对象的生命周期\n- `future` 只依赖共享状态，不依赖 `packaged_task` 对象本身。即共享状态的生命周期独立于 `packaged_task`\n    - 由最后一个引用它的 `future` 或 `shared_future` 管理\n    - 与 `packaged_task` 对象的销毁无关\n\n```mermaid\nclassDiagram\n    class PackagedTask {\n        +operator()()\n        +get_future()\n        -shared_state* \n    }\n    \n    class SharedState {\n        +result\n        +ready_flag\n    }\n    \n    class Future {\n        +shared_state*\n    }\n    \n    PackagedTask --> SharedState : 独占拥有\n    Future --> SharedState : 只读引用\n```\n关键点：\n1. `packaged_task` ​**​独占拥有​**​共享状态的生命周期\n2. `future` ​**​只持有对共享状态的弱引用​**​\n3. 移动、销毁 `packaged_task` 会​**​转移共享状态的所有权​**。但是不会销毁SharedState，因为外部还有Future在观察。\n    1. 因此，其实也可以在之前就保存下来task的future，然后再去把task转移给任务队列。这样无所谓task是否在外部获得结果之前销毁了。\n        1. 但是这样会限制task在移动之后的操作，无法在移动之后获得future了。\n\n\n关键点：\n1. ​**​共享所有权​**​：\n    - 任务队列和工作线程共同持有 `shared_ptr`。\n        - （⭐）当 lambda 被放入队列时，`shared_ptr` 的引用计数增加\n    - 最后一个持有者释放时 `packaged_task` 才会销毁\n        - 当队列中的 lambda 被销毁时，`shared_ptr` 引用计数减少\n2. ​**​生命周期安全​**​：\n    - 即使 `submitTask` 返回，只要队列或线程持有 `shared_ptr`\n    - `packaged_task` 对象会一直存活到任务执行完成\n\n```cpp\ntemplate<typename Func, typename... Args>\nauto submitTask(Func&& func, Args&&... args) -> std::future<decltype(func(args...))>\n{\n    using RType = decltype(func(args...));\n    auto task = std::make_shared<std::packaged_task<RType()>>(\n        std::bind(std::forward<Func>(func), std::forward<Args>(args)...));\n    std::future<RType> result = task->get_future();\n\n    std::unique_lock<std::mutex> lock(taskQueMtx_);\n    if (!notFull_.wait_for(lock, std::chrono::seconds(1),\n        [&]() -> bool { return taskQue_.size() < taskQueMaxThreshHold_; }))\n    {\n        std::cerr << \"task queue is full, submit task failed.\" << std::endl;\n        // 这里，用 lambda 表达式 充当 线程函数 func，函数中只返回一个空RType()\n        // RType()即一个默认构造的 future\n        // 但是可能会出现两个问题：\n        // 1. RType 没有默认构造函数（如 std::atomic），\n        // 2. 语义不准确，应该显式指出 提交失败的原因\n        // auto task = std::make_shared<std::packaged_task<RType()>>(\n        //     []() -> RType { return RType(); });\n        // task();\n        // return task->get_future();\n        \n        // 改进方案一：\n        // return std::async(std::launch::deferred, \n        //     [] { throw std::runtime_error(\"Task queue full\"); }).share().get_future();\n        // 改进方案二：\n        std::promise<RType> p;\n        p.set_exception(std::make_exception_ptr(std::runtime_error(\"Task queue full\")));\n        return p.get_future();\n    }\n    \n    // 关键：task这个shared_ptr，由这个lambda表达式捕获了，之后这个task的生命周期就和任务队列一致了。\n    taskQue_.emplace([task]() { (*task)(); });\n    ++taskSize_;\n\n    notEmpty_.notify_all();\n\n    if (poolMode_ == PoolMode::MODE_CACHED\n        && taskSize_ > idleThreadSize_\n        && curThreadSize_ < threadSizeThreshHold_)\n    {\n        std::cout << \">>> create new thread...\" << std::endl;\n        // 创建新的线程对象\n        auto ptr = std::make_unique<Thread(std::bind(&ThreadPool::threadFunc, this, std::placeholder::_1));\n        int threadId = ptr->getId();\n        threads_.emplace(threadId, std::move(ptr));\n        threads_[threadId]->start();\n        ++curThreadSize_;\n        ++idleThreadSize_;\n    }\n    return result;\n}\n```\n## 再次优化submitTask\n- `future` 只依赖共享状态，不依赖 `packaged_task` 对象本身。即共享状态的生命周期独立于 `packaged_task`\n    - 由最后一个引用它的 `future` 或 `shared_future` 管理\n    - 与 `packaged_task` 对象的销毁无关\n```mermaid\nclassDiagram\n    class PackagedTask {\n        +operator()()\n        +get_future()\n        -shared_state* \n    }\n    \n    class SharedState {\n        +result\n        +ready_flag\n    }\n    \n    class Future {\n        +shared_state*\n    }\n    \n    PackagedTask --> SharedState : 独占拥有\n    Future --> SharedState : 只读引用\n```\n关键点：\n1. `packaged_task` ​**​独占拥有​**​共享状态的生命周期\n2. `future` ​**​只持有对共享状态的弱引用​**​\n3. 移动、销毁 `packaged_task` 会​**​转移共享状态的所有权​**。但是不会销毁SharedState，因为外部还有Future在观察。\n    1. 因此，其实也可以在之前就保存下来task的future，然后再去把task转移给任务队列。这样无所谓task是否在外部获得结果之前销毁了。\n        1. 移动task的缺点：但是这样会限制task在移动之后的操作，无法在移动之后获得future了。\n\n优化点：\n1. 完美转发捕获（C++20）代替 `std::bind`，更高效且避免额外开销\n2. 移动task到lambda中，而不是建立`shared_ptr`来管理它。比`shared_ptr`版本更轻量高效（减少一次堆分配）。\n注意点：\n为什么需要mutable？\n\n因为`packaged_task`的`operator()`调用会改变`packaged_task`对象（它内部会执行任务并将结果存储到共享状态，所以会改变`packaged_task`的状态），因此`lambda`的调用运算符必须声明为`mutable`，否则编译器会认为你在一个`const`的`lambda`中试图修改捕获的对象。\n所以，这里mutable是必须的。\n\n在完美转发捕获可变参时，为什么也需要加mutable？\n我们通过完美转发捕获了`func`和`args`。在lambda体内，我们调用了`func`，并使用了`std::forward<Args>(args)...`来转发参数。由于**转发可能意味着移动（当参数是右值时），这会修改捕获的`args`**（移动后，对象的状态被改变，通常为空或有效状态被转移）。因此，我们需要`mutable`来允许对捕获的变量进行修改（包括移动操作）。\n\n```cpp\ntemplate<typename Func, typename... Args>\nauto submitTask(Func&& func, Args&&... args) -> std::future<decltype(func(args...))>\n{\n    using RType = decltype(func(args...));\n    \n    // 1. 创建任务和future\n    auto task = std::packaged_task<RType()>(\n        [func = std::forward<Func>(func), ...args = std::forward<Args>(args)] () mutable \n        {\n             return func(std::forward<Args>(args)...);\n        }); // ✅ 完美转发捕获(C++20)\n    \n    std::future<RType> result = task.get_future();\n\n    // 2. 锁保护队列操作\n    std::unique_lock<std::mutex> lock(taskQueMtx_);\n    \n    // 3. 检查队列容量\n    if (!notFull_.wait_for(lock, 1s, \n        [&] { return taskQue_.size() < taskQueMaxThreshHold_; }))\n    {\n        // 优雅的错误处理\n        std::promise<RType> p;\n        p.set_exception(\n            std::make_exception_ptr(std::runtime_error(\"Task queue full\")));\n        return p.get_future(); // ⏱️ 立即就绪的异常future\n    }\n    \n    // 4. 提交任务到队列\n    taskQue_.emplace([task = std::move(task)]() mutable {\n        task(); // ✅ 执行移动后的任务\n    });\n    ++taskSize_;\n    \n    // 5. 通知工作线程\n    notEmpty_.notify_all();\n    \n    // 6. 动态扩缩容逻辑 (CACHED模式)\n    if (poolMode_ == PoolMode::MODE_CACHED && \n        taskSize_ > idleThreadSize_ &&\n        curThreadSize_ < threadSizeThreshHold_)\n    {\n        // ... 创建新线程 (省略细节)\n    }\n    \n    return result; // 🎯 返回有效的future\n}\n```\n## threadFunc的重构\n```cpp\nconst int THREAD_IDLE_TIME = 60;\t//单位s\nvoid ThreadPool::threadFunc(int threadid)\n{\n    /* 上一次线程执行完任务的时间 */\n    auto lastTime = std::chrono::high_resolution_clock().now();\n    for(;;)\n    {\n        // 此处之前的版本是智能指针管理的task，目前不需要了。\n        // 因为我们把sharedptr对Task的包装都在submitTask内部进行封装了。\n    \tTask task;\n        {\n            std::unique_lock<std::mutex> lock(taskQueMtx_);\n            std::cout << \"tid: \" << std::this_thread::get_id()\n                << \"尝试获取任务...\" << std::endl;\n                \n            // cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程\n            // 结束回收掉（超过initThreadSize_数量的线程要进行回收）\n            // 当前时间 - 上一次线程执行的时间 > 60s\n\n            // 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回\n            // 锁 + 双重判断\n            while (taskQueue_.size() == 0)\n            {\n                // 线程池要结束，回收线程资源\n                if (!isPoolRunning_)\n                {\n                    threads_.erase(threadid);\n                    std::cout << \"threadid: \" << std::this_thread::get_id() << \" exit!\"\n                        << std::endl;\n                    exitCond_.notify_all();\n                    return;\n                }\n                \n                if (poolMode_ == PoolMode::MODE_CACHED)\n                {\n                    //while(taskQue_.size() > 0) // 不再去判断 taskQue_.size() > 0，即使size是0，也一直等待60s\n                    //{\n                    \n                    /* 超时 1s 返回 */\n                    if(std::cv_status::timeout ==\n                       notEmpty_.wait_for(lock, std::chrono::seconds(1)))\n                    {\n                        auto now = std::chrono::high_resolution_clock().now(); //返回的是time_point类型\n                        auto dur = std::chrono::duration_cast<std::chrono::seconds>(now - lastTime);\n                        if(dur.count() >= THREAD_MAX_IDLE_TIME\n                          && curThreadSize_ > initThreadSize_)\n                        {\n                            /* 开始回收当前线程 */\n                            /* 修改记录线程数量的相关变量 */\n                            /* 把线程从线程列表容器中删除 */\n                            /* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */\n                            /* 我们需要有一个映射关系来记录：threadid => thread对象 => 删除 */\n                            thread_.erase(threadid);\n                            --curThreadSize_;\n                            --idleThreadSize_;\n                            std::cout << \"threadid: \" << std::this_thread::get_id() << \" exit!\"\n                                << std::endl;\n                            return;\n                        }\n                    } \n                    //} // while(taskQue_.size() > 0) 结束\n                } \n                else // poolMode_ != PoolMode::MODE_CACHED\n                {\n                    notEmpty_.wait(lock /* , [&]()->bool { return taskQue_.size() > 0; } */);\n                }\n            } // end while (taskQueue_.size() == 0)\n\n            // 此时 taskQueue_.size() != 0 而 我们又拿到了 任务队列的锁，可以直接取走任务\n            --idleThreadSize_;\n            std::cout << \"tid: \" << std::this_thread::get_id()\n                << \"获取任务成功...\" << std::endl;\n            task = taskQue_.front();\n            taskQue_.pop();\n            --taskSize_;\n\n            if (taskQue_.size() > 0)\n            {\n                notEmpty_.notify_all();\n            }\n\n            notFull_.notify_all();\n        } // end std::unique_lock<std::mutex> lock(taskQueMtx_);\n        if(task != nullptr)\n        {\n            task();\n        }\n        ++idleThreadSize_;\n        /* 线程执行完任务后更新lastTime */\n        lastTime = std::chrono::high_resolution_clock().now();\n    }\n}\n```\n测试\n```cpp\nint sum(int a, int b)\n{\n    return a + b;\n}\nint main()\n{\n    ThreadPool pool;\n    pool.setMode(PoolMode::MODE_CACHED);\n    pool.start(2);\n    future<int> res1 = pool.submitTask(sum, 1, 2);\n    future<int> res2 = pool.submitTask([](int begin, int end) -> int\n        {\n            int sum = 0;\n            for (int i = begin; i <= end; ++i)\n            {\n                sum += i;\n            }\n            return sum;\n        }, 1, 100);\n    future<int> res3 = pool.submitTask(sum, 1, 2);\n    future<int> res4 = pool.submitTask(sum, 1, 2);\n        \n    cout << res1.get() << endl;\n    cout << res2.get() << endl;\n    cout << res3.get() << endl;\n    cout << res4.get() << endl;\n}\n```\n","categories":["操作系统","多线程","Cpp","项目"]},{"title":"半同步半异步线程池模型","url":"/项目/半同步半异步线程池模型/","content":"# 内容\n\n1. 半同步半异步线程池介绍\n# 线程池介绍\n\n在处理大量并发任务的时候，如果按照传统的方式：来一个任务请求，对应一个线程来处理请求任务。那么大量的线程创建和销毁将消耗过多的系统资源，还增加了线程上下文（运行环境）切换的开销，而通过线程池技术就可以很好地解决这些问题。\n\n线程池技术通过在系统中预先创建一定数量的线程，当任务请求到来时从线程池中分配一个**预先创建的线程**去处理任务，线程在处理完任务之后还可以重用，**不会销毁**，而是等待下次任务的到来。这样，通过线程池能**避免大量的线程创建和销毁动作，从而节省系统资源**。\n\n这样做的一个好处是，对于多核处理器，由于线程会被分配到多个CPU，会**提高并行处理的效率**；另一个好处是**每个线程独立阻塞**，可以防止主线程被阻塞而使主流程被阻塞，导致其他的请求得不到响应的问题。\n\n线程池分为半同步半异步线程池和领导者追随者线程池，本文将主要介绍半同步半异步线程池，这种线程池在实现上更简单，使用得比较多。\n\n# 半同步半异步线程池结构\n\n半同步半异步线程池分成三层，如图所示。\n\n![image-20220330153004372](../../images/线程池/image-20220330153004372.png)\n\n第一层是同步服务层，它处理来自上层的任务请求，上层的请求可能是并发的，这些请求不是马上就会被处理，而是将这些任务放到一个同步排队层中，等待处理。\n\n第二层是同步排队层，来自上层的任务请求都会加到排队层中等待处理。\n\n第三层是异步服务层，这一层中会有多个线程同时处理排队层中的任务，异步服务层从同步排队层中取出任务并行的处理。\n\n这种三层的结构可以最大程度处理上层的并发请求。对于上层来说只要将任务丢到同步队列中就行了，至于谁去处理，什么时候处理都不用关心，主线程也不会阻塞，还能继续发起新的请求。至于任务具体怎么处理，这些细节都是靠异步服务层的多线程异步并行来完成的，这些线程是一开始就创建的，不会因为大量的任务到来而创建新的线程，避免了频繁创建和销毁线程导致的系统开销，而且通过多核处理能大幅提高处理效率。\n\n# 关键技术分析\n\n同步排队层居于核心地位，因为上层会将任务加到排队层中，异步服务层同时也会取出任务，这里有一个同步的过程。\n\n在实现时，排队层就是一个同步队列，允许多个线程同时添加或取出任务，并且要保证操作过程是安全的。\n\n线程池有两个活动过程，一个是往同步队列中添加任务，另一个是从同步队列中取任务。活动图如图所示。\n\n![image-20220330154305073](../../images/线程池/image-20220330154305073.png)\n\n从活动图中可以看到线程池的活动过程，一开始线程池会启动一定数量的线程，这些线程属于异步层，主要用来并行处理排队层中的任务。\n\n如果排队层中的任务数为空，则这些线程等待任务的到来，如果发现排队层中有任务了，线程池则会从等待的这些线程中唤醒一个来处理新任务。同步服务层则会不断地将新的任务添加到同步排队层中这里有个问题值得注意，有可能上层的任务非常多，而任务又是非常耗时的，这时，异步层中的线程处理不过来，则同步排队层中的任务会不断增加，如果同步排队层不加上限控制，则可能会导致排队层中的任务过多、内存暴涨的问题。因此，排队层需要加上限的控制，当排队层中的任务数达到上限时，就不让上层的任务添加进来，起到限制和保护的作用。\n\n# 同步队列\n\n同步队列即为线程中三层结构中的中间那一层，它的主要作用是保证队列中共享数据线程安全，还为上一层同步服务层提供添加新任务的接口，以及为下一层异步服务层提供取任务的接口。同时，还要限制任务数的上限，避免任务过多导致内存暴涨的问题。\n\n同步队列的实现比较简单，我们会用到C++11的锁、条件变量、右值引用、std::move以及std::forward。move是为了实现移动语义，forward是为了实现完美转发。\n\n同步队列的锁是用来线程同步的。\n\n条件变量是用来实现线程通信的，即线程池空了就要等待，不为空就通知一个线程去处理；线程池满了就等待，直到没有满的时候才通知上层添加新任务。\n\n同步队列的具体实现如下。\n\n```cpp\n#include<list>\n#include<mutex>\n#include<condition_variable>\n#include<iostream>\nusing namespace std;\ntemplate<class T>\nclass SyncQueue\n{\npublic:\n    SyncQueue(int maxSize) : m_maxSize(maxSize), m_needStop(false){}\n    void Put(const T& x)\n    {\n        Add(x);\n    }\n    void Put(T && x)\n    {\n        Add(std::forward<T>(x));\n    }\n    void Take(std::list<T>& list)\n    {\n        std::unique_lock<std::mutex> locker(m_mutex);\n        //如果队列没有停止运行，则继续看任务队列是否空，如果空则阻塞，不空则继续\n        m_notEmpty.wait(locker,\n                       [this]()->bool{return m_needStop || NotEmpty();});\n        if(m_needStop)return;\n        list = std::move(m_queue);\t//move对于list来说只移动容器内部对象\n        m_notFull.notify_one();\n    }\n    void Take(T & t)\n    {\n        std::unique_lock<std::mutex> locker(m_mutex);\n        //如果队列没有停止运行，则继续看任务队列是否空，如果空则阻塞，不空则继续\n        m_notEmpty.wait(locker,\n                       [this]()->bool{return m_needStop || NotEmpty();});\n        if(m_needStop)return;\n        t = m_queue.front();\t//赋值拷贝\n        m_queue.pop_front();\n        m_notFull.notify_one();\n    }\nprivate:\n    std::list<T> m_queue;\t//任务\n    std::mutex m_mutex;\n    std::condition_variable m_notEmpty;\t//异步任务层\n    std::condition_variable m_notFull;\t//同步任务层\n    int m_maxSize;\n    bool m_needStop;\n};\n```\n\n其中Take函数取的方法是“钓鱼”的方式。\n\n> 如果想通过函数的return直接返回\\_Ty是不现实的，因为如果栈空的话会产生返回值混淆。\n>\n> 所以在外部先定义一个对象名，通过传入引用去接收对象值（通过赋值拷贝）。\n\n```cpp\n_Ty Top();\n_Ty GetTop()\n{\n/*  if(Empty())return -1; */\n}\nbool GetPop(_Ty &v)\n{\n    if(Empty())return false;\n    v = data[top];\n    top -= 1;\n    return true;\n}\n```\n\n## Stop\n\n```cpp\nclass SyncQueue\n{\npublic:\n    void Stop()\n    {\n        {\n            std::unique_lock<std::mutex> locker(m_mutex);\n\t        m_needStop = true;\n        }\n        //需要唤醒所有阻塞的线程，让他们尽快退出业务操作。\n        m_notFull.notify_all();\n        m_notEmpty.notify_all();\n    }\n    bool Empty()/* 此方法需要修改成员锁的属性，不能设置为const方法 */\n    {\n        std::unique_lock<std::mutex> locker(m_mutex);\n        return m_queue.empty();\n    }\n    bool Full()\n    {\n        std::unique_lock<std::mutex> locker(m_mutex);\n        return m_queue.size() == m_maxSize;\n    }\n    size_t Size()\n    {\n        std::unique_lock<std::mutex> locker(m_mutex);\n        return m_queue.size();\n    }\n    int Count()\n    {\n        return m_queue.size();\n    }\nprivate:\n    bool NotFull() const\n    {\n        bool full = m_queue.size() >= m_maxSize;\n        if(full)\n        {\n            cout << \"m_queue 满了\" << endl;\n        }\n        return !full;\n    }\n    bool NotEmpty() const\n    {\n        bool empty = m_queue.empty();\n        if(empty)\n        {\n            cout << \"m_queue 空了\" << endl;\n        }\n        return !empty;\n    }\n};\n```\n\n### Add\n\n```cpp\nclass SyncQueue\n{\nprivate:\n    template<class F>\n    void Add(F&& x)\n    {\n        std::unique_lock<std::mutex> locker(m_mutex);\n        m_notFull.wait(locker,\n                      [this]()->bool {return m_needStop||NotFull();});\n        m_queue.push_back(std::forward<F>(x));\n        m_notEmpty.notify_one();\n    }\n};\n```\n\n# 线程池\n\n```cpp\nconst int MaxTaskCount = 100;\nclass ThreadPool\n{\npublic:\n    using Task = std::function<void()>;\n    ThreadPool(int numThreads = std::thread::hardware_concurrency)\n        : m_queue(MaxTaskCount) /* 设置m_queue的最大容纳任务量 */\n    {\n        Start(numThreads);\n    }\n    ~ThreadPool()\n    {\n        Stop();\n    }\nprivate:\n    std::list<std::shared_ptr<std::thread> > m_threadgroup;\n    SyncQueue<Task> m_queue;\n    atomic_bool m_running;\t//初始化为假\n    std::once_flag m_flag;\t//确保函数执行一次的标志\n}\n```\n\n* Start、RunInThread、StopThread\n\n```cpp\nclass ThreadPool\n{\npublic:\n    void Stop()\n    {\n        std::call_once(m_flag, [this]() {StopThreadGroup();});\n    }\n\n    void Start(int numThreads)\t//创建若干线程，放到线程组\n    {\n        m_running = true;\n        for(int i = 0; i < numThreads; ++i)\n        {\n            //注意，RunInThread是类成员函数，需要指明其是哪个类中的，而且要在前面加&\n            m_threadgroup.push_back(\n                make_shared<thread>(&ThreadPool::RunInThread, this)\n            );\n            \n        }\n    }\nprivate:\n    void RunInThread()\t\t//主线程对应的函数，属于类成员函数，需传入this\n    {\n        while(m_running)\t//Start后running为true\n        {\n            std::list<Task> list;\n            m_queue.Take(list);\n            for(auto & task : list)\n            {\n                if(!m_running)return;\n                task();\n            }\n        }\n    }\n    void StopThreadGroup()\n    {\n        m_queue.Stop();\n        m_running = false;\n        for(auto & th : m_threadgroup)\n        {\n            if(th)\n            {\n                th->join();\n            }\n        }\n        m_threadgroup.clear();\n    }\n};\n```\n\n* AddTask\n\n```cpp\nclass ThreadPool\n{\npublic:\n    void AddTask(Task && task)\n    {\n        m_queue.Put(task);\n    }\n    void AddTask(const Task & task)\n    {\n        m_queue.Put(task);\n    }\n};\n```\n\n# 测试\n\n```cpp\nvoid funa(ThreadPool &pool)\n{\n    for(int i = 0;i < 10; ++i)\n    {\n        auto thdid = this_thread::get_id();\n        pool.AddTask();\n    }\n}\nvoid TestThPool()\n{\n    ThreadPool pool;\n    std::thread tha(fun, 1);\n}\nint main()\n{\n    TestThPool();\n    return 0;\n}\n```\n# 下去思考的问题\n\n1. 还有一个概念是协程。是在用户态的模拟并发，因而比线程速度更快，但是协程本质上不是并行、高并发，因为实际上它相对于CPU来说是处于串行的状态。\n2. 下去思考线程池如何与对象池连接，对象中可以连接MySQL数据库，如何使用线程池调用对象的查询、更新数据方法。\n3. 创建一个线程对象与某个线程挂接后，能不能在中间暂停？暂停时改变线程的属性，然后再继续跑动？\n4. 能不能精准地创建一个线程，准确地挂在某个核上？\n5. 下去看看谷歌的线程池\n6. 下去看看protobuf\n","categories":["操作系统","多线程","Cpp","项目"]},{"title":"Cpp_functional","url":"/Cpp/Cpp_functional/","content":"# 内容\n\n1. std::function\n2. std::bind\n# 可调用对象\n\nCpp中，存在“可调用对象(Callable Objects)”这一概念。准确来说，可调用对象有如下几种定义：\n\n1. 是一个函数指针\n2. 是一个具有operator()成员函数的类对象（仿函数）。\n3. 是一个可被转换为函数指针的类对象。\n4. 是一个类成员（函数）指针。\n\n* 可调用对象的使用示例\n\n  * 函数指针\n\n    ```cpp\n    void func(void)\n    {\n        // ...\n    }\n    ```\n\n  * 仿函数\n\n    ```cpp\n    struct Foo\n    {\n        void operator()(void)\n        {\n            // ...\n        }\n    };\n    ```\n\n  * 可转换为函数指针的类对象\n\n    ```cpp\n    struct Bar\n    {\n        using fr_t = void(*)(void);\n        static void func(void)\n        {\n            // ...\n        }\n        operator fr_t(void)\n        {\n            return func;\n        }\n    }\n    ```\n\n  * 类成员函数指针\n\n    ```cpp\n    struct A\n    {\n        int a_;\n        void mem_func(void)\n        {\n            // ...\n        }\n    };\n    ```\n\n  * 测试\n\n    ```cpp\n    int main(void)\n    {\n        void (* func_ptr)(void) = &func;\n        func_ptr();\n        \n        Foo foo;\n        foo();\n        \n        Bar bar;\n        bar();\n        \n        void (A::*mem_func_ptr)(void) = &A::mem_func;\n        int A::*mem_obj_ptr = &A::a_;\n        A aa;\n        (aa.*mem_func_ptr)();\n        aa.*mem_obj_ptr = 123;\n        \n        return 0;\n    }\n    ```\n\n从上述可看到，除了类成员指针之外，上面定义涉及的对象均可以像一个函数那样做调用操作。Cpp11中，这些对象(func\\_ptr、foo、bar、mem\\_func\\_ptr、mem\\_obj\\_ptr)都被称作**可调用对象**。相对应地，这些对象的类型被统称为“**可调用类型**”。\n\n> 上面对可调用类型的定义里并没有包括函数类型，这是因为函数类型并不能直接用来定义对象；也没有包括函数引用，因为引用从某种意义来说，可以看作一个const的函数指针。\n\nCpp中的可调用对象具有统一的操作形式，即后面加括号进行调用（除了类成员函数指针），但是定义方法却五花八门。我们试图使用统一的方式进行保存，或传递一个可调用对象时。于是Cpp11通过提供std::funciton和std::bind统一了可调用对象的各种操作。\n\n# 可调用对象包装器std::function\n\nstd::function是可调用对象的包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。\n\n* std::function的基本用法示例\n\n  * 绑定一个普通函数\n\n    ```cpp\n    #include<iostream>\n    #include<functional>\n    void func(void)\n    {\n        std::cout << __FUNCTION__ << std::endl;\n    }\n    int main()\n    {\n        std::function<void(void)> fr1 = func;\n        fr1();\n        return 0;\n    }\n    /* func */\n    ```\n\n  * 绑定一个类的静态成员函数\n\n    ```cpp\n    #include<iostream>\n    #include<functional>\n    class Foo\n    {\n    public:\n        static int foo_func(int a)\n        {\n            std::cout << __FUNCTION__ << \"(\" << a << \") ->: \";\n            return a;\n        }\n    };\n    int main()\n    {\n        std::function<int(int)> fr2 = Foo::foo_func;\n        std::cout << fr2(123) << std::endl;\n        return 0;\n    }\n    /* foo_func(123) ->: 123 */\n    ```\n\n  * 绑定一个仿函数\n\n    ```cpp\n    class Bar\n    {\n    public:\n        int operator()(int a)\n        {\n            std::cout << __FUNCTION__ << \"(\" << a << \") ->: \";\n            return a;\n        }\n    };\n    int main()\n    {\n        Bar bar;\n        fr2 = bar;\n        std::cout << fr2(123) << std::endl;\n        return 0;\n    }\n    /* operator()(123) ->: 123 */\n    ```\n\n从上面我们可以看到std::function的使用方法，当我们给std::function填入合适的函数签名（即一个函数类型，只需要包括返回值和参数表）之后，它就变成了一个可以容纳所有这一类调用方式的“函数包装器”。\n\n* std::function作为回调函数的示例\n\n  ```cpp\n  #include<iostream>\n  #include<functional>\n  class A\n  {\n      std::function<void()> callback_;\n  public:\n      A(const std::function<void()> & f) : callback_(f)\n      {}\n      void notify(void)\n      {\n          callback_();\t//回调到上层\n      }\n  };\n  class Foo\n  {\n  public:\n      void operator()(void)\n      {\n          std::cout << __FUNCTION__ << std::endl;\n      }\n  };\n  int main()\n  {\n      Foo foo;\n      A aa(foo);\n      aa.notify();\n      return 0;\n  }\n  ```\n\n从上面例子中可以看到，std::function可以取代函数指针的作用。因为它可以保存函数延迟执行，所以比较适合作为回调函数。\n\n* std::function还可以作为函数入参\n\n  ```cpp\n  #include<iostream>\n  #include<functional>\n  void call_when_even(int x, const std::funciton<void(int)> & f)\n  {\n      if(!(x&1))\t//x % 2 == 0\n      {\n          f(x);\n      }\n  }\n  void output(int x)\n  {\n      std::cout << x << \" \";\n  }\n  int main()\n  {\n      for(int i = 0; i < 10; ++i)\n      {\n          call_when_even(i, output);\n      }\n      std::cout << std::endl;\n      return 0;\n  }\n  /* 0 2 4 6 8 */\n  ```\n\n从上例可以看到，std::function比普通函数指针更灵活、便利。\n\n# std::bind绑定器\n\n当std::function和std::bind配合起来使用时，所有的可调用对象（包括类成员函数指针和类成员指针）都将具有统一的调用方式。\n\nstd::bind用来将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。\n\n通俗来讲，bind主要有两大作用：\n\n1. 将可调用对象与其参数一起绑定成一个仿函数。\n2. 将多元（参数个数为n, n>1）可调用对象转成一元或者（n-1）元可调用对象，即只绑定部分参数。\n\n* 实际使用示例\n\n  ```cpp\n  #include<iostream>\n  #include<functional>\n  void call_when_even(int x, const std::function<void(int)> & f)\n  {\n      if(!(x&1))\t//x % 2 == 0\n      {\n          f(x);\n      }\n  }\n  void output(int x)\n  {\n      std::cout << x << \" \";\n  }\n  void output_add_2(int x)\n  {\n      std::cout << x + 2 << \" \";\n  }\n  int main()\n  {\n      {\n          auto fr = std::bind(output, std::placeholders::_1);\n          for(int i = 0; i < 10; ++i)\n          {\n              call_when_even(i, fr);\n          }\n          std::cout << std::endl;\n      }\n      {\n          auto fr = std::bind(output_add_2, std::placeholders::_1);\n          for(int i = 0; i < 10; ++i)\n          {\n              call_when_even(i, fr);\n          }\n          std::cout << std::endl;\n      }\n      return 0;\n  }\n  /* \n  0 2 4 6 8 \n  2 4 6 8 10\n  */\n  ```\n\n同样还是上面std::function中最后的一个例子，只是在这里我们使用了std::bind，在函数外部通过绑定不同的函数，控制了最后的执行结果。\n\n我们使用auto fr保存std::bind的返回结果，是因为我们并不关心std::bind真正的返回类型（**实际上std::bind的返回类型是一个stl内部定义的仿函数类型**），只需要知道它是一个仿函数，可以直接赋值给一个std::function。当然，这里直接使用std::function类型来保存std::bind的返回值也是可以的。\n\nstd::placeholders::\\_1是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代。\n\n因为有了占位符的概念，std::bind的使用非常灵活。\n\n```cpp\n#include<iostream>\n#include<functional>\nvoid output(int x, int y)\n{\n    std::cout << x << \" \" << y << std::endl;\n}\nint main()\n{\n    std::bind(output, 1, 2)();\t\t\t\t\t\t\t//输出1 2\n    std::bind(output, std::placeholders::_1, 2)(1);\t\t//输出1 2\n    std::bind(output, 2, std::placeholders::_1)(1);\t\t//输出2 1\n/*  std::bind(output, 2, std::placeholders::_2)(1);*/\t//error, 缺少第二个参数\n    std::bind(output, 2, std::placeholders::_2)(1, 2);\t//输出2 2, 相当于第1个参数仅仅是标志\n    std::bind(output, std::placeholders::_1,\n              \t\t  std::placeholders::_2)(1, 2);\t\t//输出1 2\n    std::bind(output, std::placeholders::_2,\n              \t\t  std::placeholders::_1)(1, 2);\t\t//输出2 1\n    return 0;\n}\n```\n\n上面例子对std::bind的返回结果直接施以调用，可以看到，**std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数**。\n\n在绑定部分参数的时候，通过使用std::placeholders，来决定空位参数将会属于调用发生时的第几个参数。\n\n* 下面来看bind和function配合使用\n\n  ```cpp\n  #include<iostream>\n  #include<functional>\n  class A\n  {\n  public:\n      int i_ = 0;\n      void output(int x, int y)\n      {\n          std::cout << x << \" \" << y << std::endl;\n      }\n  };\n  int main()\n  {\n      A a;\n      std::functional<void(int, int)> fr = \n          std::bind(&A::output, &a, std::placeholders::_1,\n                    std::placeholders::_2);//目标函数A::output, 第一个参数是this指针, 还有其他两个参数。\n      fr(1, 2);\t//输出1 2\n      std::function<int&(void)> fr_i = std::bind(&A::i_, &a);\n      fr_i() = 123;\n      std::cout << a.i_ << std::endl;\t//输出123\n      return 0;\n  }\n  ```\n\nfr的类型是std::function<void(int, int)>。我们通过使用std::bind，将A的成员函数output的指针和a绑定，并转换为一个仿函数放入fr中存储。\n\n之后，std::bind将A的成员i\\_的指针和a绑定，返回的结果被放入std::function<int&(void)>中存储，并可以在需要时修改访问这个成员。\n\n# 实质\n\n```cpp\nclass Alloc\n{\n    size_t _sz;\n    int *& _ptr;\npublic:\n    Alloc(size_t sz, int *& p) : _sz(sz), _ptr(p) {}\n    void operator()()\n    {\n        _ptr = (int*)malloc(_sz);\n    }\n}\nvoid alloc(size_t sz, int *& p)\n{\n    p = (int*)malloc(sz);\n}\nint main()\n{\n    int * p = nullptr;\n    int sz = sizeof(int) * 10;\n    auto fr = std::bind(alloc, sz, std::ref(p));\n    fr();\n    if(p != nullptr)\n    {\n        cout << p << endl;\n    }\n}\n```\n\n","categories":["Cpp"]},{"title":"Linux_libevent_Reactor模式","url":"/Linux/Linux_libevent_Reactor模式/","content":"# 内容\n\n1. IO框架库\n2. Reactor模式的IO框架库包含哪些组件\n3. libevent是一个轻量级的I/O框架库。\n# I/O框架库\n\nI/O框架库以库函数的形式，封装了较为底层的系统调用。\n各种I/O框架库的实现原理基本相似，要么以Reactor模式实现，要么以Proactor模式实现，要么同时两种模式实现。\n# Reactor模式\n\n`Reactor模式`要求**主线程（IO处理单元）只负责监听文件描述符上是否有事件发生**，有的话就立即向工作线程（逻辑单元）通知该事件。除此之外，主线程不做其他实质性的工作。即读写数据、接受新的连接、处理客户请求均在工作线程中完成。\n## 工作流程\n\n使用同步I/O模型（以`epoll_wait`为例）实现的`Reactor模式`的工作流程是：\n\n1. **主线程往`epoll`内核事件表中注册`socket`上的读就绪事件**。\n2. 主线程调用`epoll_wait`等待`socket`上有数据可读。\n3. 当`socket`上有数据可读时，`epoll_wait`通知主线程。**主线程则将`socket`可读事件放入请求队列**。\n4. 睡眠在请求队列上的某个**工作线程**被唤醒，它从`socket`读取数据，并处理客户请求，然后**工作线程往`epoll`内核事件表中注册该`socket`上的写就绪事件**。\n5. 主线程调用`epoll_wait`等待`socket`可写。\n6. 当`socket`可写时，`epoll_wait`通知**主线程**。**主线程将`socket`可写事件放入请求队列**。\n7. 睡眠在请求队列上的某个**工作线程**被唤醒，它往`socket`上写入服务器处理客户请求的结果。\n\n总结：主线程注册读事件，可读时，主线程放入请求队列；工作线程读数据，处理请求，工作线程注册写事件；可写时，主线程放入请求队列；工作线程写数据。\n\n![image-20220524104612105](../../images/Linux_libevent/image-20220524104612105.png)\n\n## 组件框架\n\n基于Reactor模式的I/O框架库包含如下几个组件：\n\n1. 句柄(Handle)\n2. 事件多路分发器(Event Demultiplexer)\n3. 事件处理器(Event Handler)和具体的事件处理器(Concrete EventHandler)\n4. Reactor。\n\n这些组件的关系如下图所示。\n\n![image-20220423142048988](../../images/Linux_libevent/image-20220423142048988.png)\n\n* 句柄\n  * 说白了就是文件描述符，句柄在windows上某个资源的id，因为libevent库是跨平台的，所以叫法容易混用。\n* 事件多路分发器\n  * 事件的到来是随机的、异步的。比如我们无法预知程序何时收到一个客户连接请求，又亦或收到一个暂停信号，所以程序需要循环地等待判断有无事件产生，这就是**事件循环**。\n  * 在事件循环中，等待事件一般使用I/O复用技术来实现。I/O框架库一般将系统支持的各种I/O复用系统调用封装成统一的接口，称为**事件多路分发器**。因此事件多路分发器可以理解为封装了IO复用，提供了一个更便于使用的接口。\n  * 事件多路分发器的demultiplex方法是等待事件的核心函数，其内部调用的是select、poll、epoll\\_wait等函数。\n  * 事件多路分发器还需要实现`register_event`和`remove_event`方法，以供调用者给事件多路分发器中添加事件和从中删除事件。\n* 事件处理器和具体事件处理器\n  * 事件处理器执行事件对应的业务逻辑。它通常包含一个或多个`handle_event`回调函数，这些回调函数在事件循环中被执行。\n  * I/O框架库提供的事件处理器通常是一个接口，用户需要继承它来实现自己的事件处理器，即具体事件处理器。**因此，事件处理器中的回调函数一般被声明为虚函数，以支持用户的扩展**。\n  * 此外，事件处理器一般还提供一个`get_handle`方法，它返回与该事件处理器关联的句柄。那么，事件处理器和句柄有什么关系？**当事件多路分发器检测到有事件发生时，它是通过句柄来通知应用程序**的。因此，我们必须将事件处理器和句柄绑定，才能在事件发生时获取到正确的事件处理器。\n* Reactor是I/O框架库的核心。它提供的几个主要方法是：\n  * `handle_events`，该方法执行**事件循环**。重复过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。\n  * `register_handler`，该方法调用事件多路分发器的`register_event`方法来给事件多路分发器中注册一个事件。\n  * `remove_handler`，该方法调用事件多路分发器的`remove_event`方法来删除事件多路分发器中的一个事件。\n\n# libevent\n\nlibevent支持的事件类型\n\n```c\n#define EV_TIMEOUT\t\t0x01\t/* 定时事件 */\n#define EV_READ\t\t\t0x02\t/* 可读事件 */\n#define EV_WRITE\t\t0x04\t/* 可写事件 */\n#define EV_SIGNAL\t\t0x08\t/* 信号事件 */\n#define EV_PERSIST\t\t0x10\t/* 永久事件 */\n#define EV_ET\t\t\t0x20   /*边沿触发事件,需要IO复用系统调用支持,如epoll*/\n```\n\n## 编程流程\n\n1. 定义、创建框架示例\n2. 向框架示例注册、注销事件：指定具体哪个**base**、哪个**描述符**，哪种**事件**，绑定**回调函数**和**参数**\n    1. 有哪些事件：IO事件（`fd`、`EV_READ`、`fun_cb`）、信号事件（`sig`、`EV_SIGNAL`、`sig_cb`）、定时器事件（`-1`、`EV_TIMEOUT`、`tv_cb`）\n3. 开启事件循环，实际上就是框架底层调用`select/poll/epoll`\n4. 事件发生之后，调用回调函数如`fun_cb`。\n## 示例\n\n```c\n#include<sys/signal.h>\t//SIGINT\n#include<event.h>\nvoid signal_cb(int fd, short event, void * argc)\n{\n    struct event_base* base = (event_base*)argc;\n    struct timeval delay = {2, 0};\n    printf(\"Caught an interrupt signal; exiting cleanly in 2 seconds...\\n\");\n    event_base_loopexit(base, &delay);\n}\nvoid timeout_cb(int fd, short event, void * argc)\n{\n    printf(\"timeout\\n\");\n}\nint main()\n{\n    struct event_base* base = event_init();\n    struct event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);\n    event_add(signal_event, NULL);\n    \n    timeval tv = {1, 0};\n    struct event* timeout_event = evtimer_new(base, timeout_cb, NULL);\n    event_add(timeout_event, &tv);\n    \n    event_base_dispatch(base);\n    \n    event_free(timeout_event);\n    event_free(signal_event);\n    event_base_free(base);\n}\n```\n\n上面的代码描述了使用Libevent库的主要逻辑：\n\n1. 调用`event_init`函数创建`event_base`对象。一个`event_base`相当于一个Reactor实例。\n2. 创建具体的事件处理器，并设置他们所从属的Reactor实例。本例中的**`evsignal_new`**用于创建信号事件处理器，**`evtimer_new`**用于创建定时事件处理器，**它们是定义在`/include/event2/event.h`文件中的宏**，代码如下。其中`evtimer_new`的原型`event_new`的第二个参数默认赋`-1`，第三个参数默认赋`0`。\n\n```c\n#define evsignal_new(b, x, cb, arg) \\\nevent_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))\n#define evtimer_new(b, cb, arg) \\\nevent_new((b), -1, 0, (cb), (arg))\n```\n3. 回调函数的格式需要统一：`void fun_cb(int fd, short event, void* argc)`\n\n```c\n#include<sys/signal.h>\t//SIGINT\n#include<event.h>\nvoid sig_fun(int fd, short event, void * argc)\n{\n    printf(\"sig=%d\\n\", fd);\n}\nvoid timeout_fun(int fd, short event, void * argc)\n{\n    if(ev & EV_TIMEOUT)\n    {\n        printf(\"timeout\\n\");\n    }\n}\nint main()\n{\n    struct event_base* base = event_init();\n    assert(base != NULL);\n    \n    struct event* sig_ev = evsignal_new(base, SIGINT, sig_fun, NULL);\n    event_add(sig_ev, NULL);\n    \n    struct timeval tv = {5, 0};\n    //定时器不需要fd描述符、也不需要信号代号。\n    //所以，相应地:\tevtimer_new对应的timeout_fun回调函数中的fd参数默认赋-1\n    //\t\t\t\tevtimer_new对应的event_new函数的信号代号参数默认赋-1 \n    struct event* timeout_ev = evtimer_new(base, timeout_fun, NULL);\n    event_add(timeout_ev, &tv);\n    \n    event_base_dispatch(base);\t//开启事件循环\n    \n    event_free(sig_ev);\n    event_free(timeout_ev);\n    event_base_free(base);\n}\n```\n\n`ctrl+c`终止进程的信号代号是2，但是信号事件并没有fd描述符，而是巧妙地复用了fd，写入信号代号。\n\n## 编译测试\n\n`gcc`编译链接命令后需要加后缀`-levent`。\n\n# MainServer\n\n```cpp\nclass TcpServer;\nclass ThreadPool;\nclass Reactor;\n\nclass MainServer\n{\nprivate:\n    TcpServer * m_server;\n    ThreadPool * m_pool;\n    Reactor * m_reactor;\npublic:\n    MainServer();\n    ~MainServer();\n    static void ListenEventCallBack(int fd, short events, void * arg);\n    \n};\n```\n\n```cpp\n#include\"mainServer.h\"\n#include\"tcpServer.h\"\nMainServer::Mainserver()\n{\n    m_server = new TcpServer;\n}\nMainServer::~MainServer()\n{\n    m_server = new TcpServer(IpAddressPort{\"127.0.0.1\", 8000});\n    m_pool = new ThreadPool(3);\n    m_reactor = new Reactor();\n    m_reactor->AddEventAndHandler(m_server->GetLfd, EV_READ | EV_PERSIST, MainServer::ListenEventCallBack)\n}\nMainServer::ListenEventCallBack(int fd, short events, void * arg)\n{\n    \n}\n```","categories":["项目","Linux","网络","设计模式"]},{"title":"Linux_IO复用_select_poll","url":"/Linux/Linux_IO复用_select_poll/","content":"# 内容\n\n1. 基本概念\n2. 了解接口socket\n3. 了解协议tcp/udp\n4. io复用\n5. select\n6. poll/epoll\n\n可以参考学习的文章：\n\n1. [深入浅出理解select、poll、epoll的实现](https://zhuanlan.zhihu.com/p/367591714)\n2. [linux在系统调用进入内核时，为什么要将参数从用户空间拷贝到内核空间？不能直接访问，或是使用memcpy吗？非要使用copy_from_user才行吗？](https://www.zhihu.com/question/19728793) - 针对为什么select/poll调用一次拷贝一次数组到内核态空间。\n\n# I/O复用\n\n1. select\n2. poll\n3. epoll\n\n# select\n\n先观察其API\n\n```c\n#include<sys/select.h>\nint select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);\n```\n\n1. 参数\n   1. `nfds`参数通常被设置为`select`监听的所有文件描述符中的最大值加1，表示在`fd_set`集合中，我们关心的描述符的总数。为什么加1呢？因为文件描述符是从0开始计数的。`nfds`与`fd_set容量大小`不一样，容量大小指的是`FD_SETSIZE`，即`fd_set容量大小`是`fd_set`可容纳描述符的最大大小。\n   2. readfds参数是select关心的读事件的集合；\n   3. writefds参数是select关心的写事件的集合；\n   4. exceptfds参数select关心的异常事件的集合；\n   5. timeout参数设置select的超时时间。\n2. 返回值\n   1. 集合中有事件就绪的描述符的个数\n   2. 但是并没有告诉你具体是哪一个描述符就绪\n\n## fd_set结构体\n\n```c\n#include<typesizes.h>\n#define __FD_SETSIZE 1024\n\n#include<sys/select.h>\n#define FD_SETSIZE __FD_SETSIZE\ntypedef long int __fd_mask;\n#undef __NFDBITS\n#define __NFDBITS (8*(int)sizeof(__fd_mask))\ntypedef struct\n{\n#ifdef __USE_XOPEN\n    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];\n#define __FDS_BITS(set) ((set)->fds_bits)\n#else\n    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];\n#define __FDS_BITS(set) ((set)->__fds_bits)\n#endif\n}fd_set;\n-------------------\n#define FD_SETSIZE 1024\n#define NFDBITS (8*(int)sizeof(long int))\ntypedef struct\n{\n    long int fds_bits[FD_SETSIZE / NFDBITS];\n}fd_set;\n```\n\n其中，`__FD_SETSIZE`指出select可以关注的最大文件描述符个数，默认为1024。\n\n`__fd_mask`被定义为`long int`的类型别称，`long int`在32位机占8个字节。\n\n`__NFDBITS`计算的是1个`__fd_mask`元素所占用的位数，一个字节占8位，sizeof算出`__fd_mask`的字节数，相乘得其占用的bit大小。\n\n接着，定义`fds_bits`，其是`long int`型的数组，数组大小为`__FD_SETSIZE`除以`__NFDBITS`。比如`SETSIZE`为1024位，`NFDBITS`是64位，则数组大小位`1024/64=16`。这里的计算主要是为了计算出数组的大小，以确定多大的数组可以正好容纳`1024`个位数，来记录文件描述符信息。\n\n## 用到的宏函数\n\n`fd_set`集合对于文件描述符的管理是按位进行的，而位只有0和1两种状态。\n\n假如`SETSIZE=1024`，则可管理1024个文件描述符，如果`文件描述符7`有效，我们需要对位操作，使其位变为`1`。\n\n由于位操作过于繁琐，select API中提供了一系列宏函数来方便我们访问、操作`fd_set`集合状态。\n\n```c\n#include<sys/select.h>\nFD_ZERO(fd_set *fdset);\t\t\t\t/*清除fdset的所有位*/\nFD_SET(int fd, fd_set *fdset);\t\t/*设置fdset的位fd*/\nFD_CLR(int fd, fd_set *fdset);\t\t/*清除fdset的位fd*/\nint FD_ISSET(int fd, fd_set *fdset);/*测试fdset的位fd是否被设置*/\n```\n\n## select编程思路\n\n最好另外定义一个整型数组，其大小为我们预测将要出现的描述符的最多数目。用作我们存放描述符的容器。初始化时将数组值一律设为`-1`，表示容器中该位置还没有存放描述符。如果在某一时刻有一个描述符有了消息，我们就将该描述符数值覆盖到这个容器中第一个为`-1`的地方。\n\n```c\n#define MAX 10\nvoid fds_init(int fds[])\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        fds[i] = -1;\n    }\n}\nvoid fds_add(int fd, int fds[])//向fds容器中添加描述符fd\n{\n    if(fd<0)\n    {\n        printf(\"无效的描述符\\n\");\n        return;\n    }\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i]==-1)\n        {\n            fds[i] = fd;\n            return;\n        }\n    }\n    printf(\"容器已满，无法添加该描述符\\n\");\n}\nvoid fds_del(int fd, int fds[])\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i]==fd)\n        {\n            fds[i] = -1;\n            return;\n        }\n    }\n    printf(\"没有找到该描述符\\n\");\n}\nint main()\n{\n    int fds[MAX];\n    fds_init(fds);\n}\n```\n\n## 示例-TCP服务使用select处理多个套接字\n\n```c\nint main()\n{\n    int sockfd = socket_init();//socket_init封装了bind(ip:port)的操作，还封装了对sockfd进行listen的操作，并设置了监听队列大小。\n    assert(sockfd!=-1);\n    \n    int fds[MAX];\n    fds_init(fds);\n    \n    fds_add(sockfd, fds);\n    \n    fd_set fdset;//此处的fd_set即<sys/select.h>库中API提供的fd_set结构体，实际上是一个有1024个“二进制位”的数组。\n    while(1)//将fds[MAX]中所有有效的(即>=0)描述符全部“加入”fdset中，\n    //即把fdset中与某有效描述符对应的[位]的状态设为1。\n    {\n        FD_ZERO(&fdset);\t//把1024位全清零。\n        int maxfd = -1;//记录当前最大的描述符数值是多少，方便过后调用select传入参数nfds。\n        for(int i = 0; i<MAX; ++i)\n        {\n            if(fds[i] == -1)\n            {\n                continue;\n            }\n            FD_SET(fds[i],fdset);\t//fds[i] != -1, 说明有效\n            if(maxfd<fds[i])//寻找最大描述符数值\n            {\n                maxfd = fds[i];\n            }\n        }//end for\n        \n    \t//此时，我们已经把开始创建的sockfd添加到了fdset中。\n        //下面就可以用select来监测该套接字是否有消息了。\n        //比如，sockfd监听到了客户端的connect信息，\n        //则select就可以探测到fdset中对应的sockfd位处于消息就绪态，\n        //则select就可以不再阻塞，立马返回。\n        struct timeval tv = {5,0};\n        //返回在fdset集合中有信息的描述符的个数。\n        int n = select(maxfd+1, &fdset, NULL, NULL, &tv);\n        if(n < 0)\n        {\n            printf(\"select err\\n\");\n        }\n        else if(n == 0)\n        {\n            printf(\"time out\\n\");\n        }\n        else\n        {\n            for(int i = 0; i<MAX; ++i)//依然需要根据fdset查询:\n            //目前是哪个描述符有事件产生，\n            //fdset的过滤又需要根据fds的记录进行遍历。\n            {\n                if(fds[i] == -1)continue;\n                if(FD_ISSET(fds[i], &fdset))//此处判断ISSET\n                //即是判断我们关注的描述符是否有事件产生。\n                //为什么此时标志位为1一定有事件产生？\n                //因为在这之前我们进行了select，\n                //select不仅说明有事件产生，它还做了更多的工作：\n                //将我们关心的描述符却在其上没有事件产生的标志位置0。\n                //因此目前所有标志位为1的描述符均有事件。\n                {\n                    //以下才是核心业务代码,抓住了有事件产生的描述符,\n                    //对这些描述符我们的处理流程,对于不同类型的描述符\n                    //需要不同的处理流程。比如sockfd用accept处理，\n                    //accept返回1个新描述符c,则先将其加入fds容器,\n                    //下一轮再用recv处理描述符c的消息。\n                    if(fds[i] == sockfd)//处理监听套接字sockfd\n                    {\n                        struct sockaddr_in caddr;\n                        int len = sizeof(caddr);\n                        int c = accept(sockfd, (struct sockaddr*)&caddr, &len);\n                        if(c < 0)\n                        {\n                            continue;\n                        }\n                        printf(\"accept c = %d\\n\", c);\n                        //此处的fds_add是用户自定义的函数，添加的是fds自定义数组\n                        fds_add(c, fds);//只是收到fds容器，下次while扫描才将c加到fdset\n                    }\n                    else//处理收发套接字，在此程序，除了sockfd皆为收发套接字c\n                    {\n                        char buff[128] = {0};\n                        int num = recv(fds[i], buff, 127, 0);\n                        if(num <= 0)\n                        {\n                            printf(\"client close\\n\");\n                            close(fds[i]);\n                            fds_del(fds[i], fds);\n                        }\n                        else//num > 0，读到了数据\n                        {\n                            printf(\"recv(c = %d) = %s\\n\",fds[i],buff);\n                            send(fds[i], \"ok\", 2, 0);\n                        }\n                    }\n                }//end if(ISSET(fds[i], &fdset))\n            }//end for(int i = 0; i<MAX; ++i)\n        }//end if(n > 0)\n    }//while end\n}\n```\n\n场景情况：如果客户端与select服务端已建立连接，而客户端进程结束，select会一直阻塞、未感知吗？--不会。\n\n因为客户端的进程结束，也算是一种读事件，相当于通知服务端该套接字连接结束了。那么服务端recv会返回0，达到关闭该套接字的条件，关闭后，别忘了在fds容器中删除掉该描述符。\n\n如果忘记了close该套接字，且忘了`fds_del`该描述符，那么如果客户端结束进程，服务端就会一直打印\"`client close`\"，因为select一直在探测此描述符有无读事件，若该套接字连接关闭，那么此描述符一直有读事件，`recv`返回0，由于没有`fds_del`，每次都会关注，所以每次都会打印\"`client close`\"。\n\n# poll\n\n可以理解为加强版的select。\n\n先观察其API\n\n```c\n#include<poll.h>\nint poll(struct pollfd* fds, nfds_t nfds, int timeout);\n```\n\n1. fds参数是一个`pollfd`结构类型的指针，可指向一段连续空间（数组），因此很灵活，**大小可按需声明**。它可以指定我们感兴趣的文件描述符上发生的可读、可写和异常等事件。定义如下\n\n   ```c\n   struct pollfd\n   {\n       int fd;\t\t\t//文件描述符\n       short events;\t//注册的事件类型，按位标志\n       short revents;\t//实际发生的事件，按位标志，由内核填充\n   }\n   ```\n\n   1. 其中，fd成员指定文件描述符。\n   2. events成员告诉poll监听fd上的哪些事件类型，他可以是一系列事件类型的**按位或**。常见的事件类型有：`POLLIN`(数据可读)、`POLLOUT`(数据可写)。\n   3. revents成员由内核修改，以通知应用程序fd上实际发生了哪些事件。\n\n## poll编程\n\n```c\nvoid poll_fds_init(struct pollfd* fds)\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        fds[i].fd = -1;\n        fds[i].events = 0;\n        fds[i].revents = 0;\n    }\n}\nvoid poll_fds_add(int fd, struct pollfd* fds)\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i].fd == -1)\n        {\n            fds[i].fd = fd;\n            fds[i].events = POLLIN;//只关注读事件\n            fds[i].revents = 0;\n            break;\n        }\n    }\n}\nvoid poll_fds_del(int fd, struct pollfd* fds)\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i].fd == fd)\n        {\n            fds[i].fd = -1;\n            fds[i].events = 0;\n            fds[i].revents = 0;\n            break;\n        }\n    }\n}\n#define MAX 10\nint main()\n{\n    int sockfd = socket_init();\n    assert(sockfd != -1);\n    struct pollfd poll_fds[MAX];\n    poll_fds_init(poll_fds);\n    poll_fds_add(sockfd,poll_fds);\n    while(1)\n    {\n        int n = poll(poll_fds,MAX,5000);//5000ms timeout \n        if(n < 0)printf(\"poll error\\n\");\n        else if(n == 0)printf(\"time out \\n\");\n        else\n        {\n            for(int i = 0;i<MAX;++i)\n            {\n                if(poll_fds[i].fd == -1)continue;\n                //short has 16bits,POLLIN is 10000000 ...,\n                //when revents is 10000000 ...,then the read event is going\n                if(poll_fds[i].revents & POLLIN)//revents & POLLIN 不为0 则代表有读事件产生\n                {\n                    if(poll_fds[i].fd == sockfd)\n                    {\n                        struct sockaddr_in caddr;\n                        int len = sizeof(caddr);\n                        int c = accept(sockfd, (struct sockaddr*)&caddr, &len);\n                        if(c < 0)\n                        {\n                            continue;\n                        }\n                        printf(\"accept:%d\\n\", c);\n                        poll_fds_add(c, poll_fds);\n                    }\n                    else\n                    {\n                        char buff[128] = {0};\n                        int num = recv(poll_fds[i].fd, buff, 127, 0);\n                        if(num <= 0)\n                        {\n                            close(poll_fds[i].fd);\n                            poll_fds_del(poll_fds[i].fd, poll_fds);\n                            printf(\"client close\\n\");\n                        }\n                        else\n                        {\n                            printf(\"recv(%d):%s\\n\", poll_fds[i].fd, buff);\n                            send(poll_fds[i].fd, \"ok\", 2, 0);\n                        }\n                    }\n\n                }\n                if(poll_fds[i].revents & POLLOUT)\n                {\n\t\t\t\t\t//...\n                }\n            }\n        }\n    }    \n}\n```\n\n与select的一处细节区别：\n\n每次select除了监测`fd_set`有效描述符上有无事件，其次还将没有事件的描述符从`fd_set`移除（将该描述符对应在`fd_set`上的位进行`置0`操作）（**这样就得每次select之前都要重新注册一遍我们关注的描述符（即用户和内核共同操作FD_SET、FD_CLR等）**），然后下面过滤有事件的描述符时，只要找到`fd_set`集合哪个位是1状态即就找到了有事件产生的描述符。\n\n而poll的用法是：用户只管注册`events`，实际上的有无事件**由内核来进行对`revents`的填充**，以此来更好地区别该描述符是否有事件产生。**这样，就不用在每次poll之前重新注册一遍我们关注的描述符的结构体里的`events`了**。我们只要把要关心的描述符的`fd`置成`非-1`，以及管理好要关心的哪些事件类型`events`即可。\n\n## 与select相比的优点\n\n1. 可以监听的描述符的最大数目可以超过`1024`个，大小按需自拟。\n2. 可以监听的事件类型数目变多、变细了，更强大了。\n3. **不用**在每次`poll`之前**重新注册**一遍我们关注的描述符的结构体里的`events`了\n\n# 总结\n\nselect和poll的总体实现流程：\n* 用户程序\n\nselect用`fd_set`结构体（默认是1024个bit位的数组）；poll用`struct pollfd fds[MAX]`结构体。\n\nselect和poll通常被循环调用。每调用一次，就拷贝一次结构体数组给内核。\n\n> [linux在系统调用进入内核时，为什么要将参数从用户空间拷贝到内核空间？不能直接访问，或是使用memcpy吗？非要使用copy_from_user才行吗？](https://www.zhihu.com/question/19728793) - 针对为什么select/poll调用一次拷贝一次数组到内核态空间。\n\n* 内核轮询\n内核对若干个文件描述符进行轮询扫描。查看之上是否有事件发生。\n时间复杂度，为O(n)\n* select/poll返回后\n返回值仅仅告诉用户程序发生了事件的描述符个数，并未告诉具体哪个描述符。\n用户程序还需要再次轮询一遍。O(n)\n![select](../../images/Linux_IO复用_select&poll/select.mp4)\n\n","categories":["Linux","网络"]},{"title":"对象池","url":"/项目/对象池/","content":"\n# 内容\n\n1. 关联关系\n2. 一级配置器和二级配置器的关系\n3. 类型萃取\n4. allocator\n5. `__malloc_alloc_template`静态成员的类外初始化，其中函数指针尤为麻烦\n\n# 关联关系\n\n弱关联\n\n```cpp\nclass Person\n{\nprivate:\n    Book * pbook;\npublic:\n    Student(){}\n    ~Student(){}\t//不能析构book\n}\n```\n\n\n\n强关联\n\n```cpp\nclass Person\n{\nprivate:\n    Book & book;\npublic:\n    Student(Book & book) : _book(book){}\n}\n```\n\n# 聚合/组合关系\n\n```cpp\nclass Point\n{\nprivate:\n    float _x;\n    float _y;\npublic:\n    Point(float x = 0.0f, float y = 0.0f) : _x(x), _y(y){}\n    Point(const Point&) = default;\n    Point & operator=(const Point&) = default;\n    ~Point(){}\n}\n```\n\n# new\n\n1. sizeof\n2. 分配字节空间\n3. 构建 返回地址\n\n# delete\n\n1. 析构\n2. 空间释放\n\n# 二级配置器\n\n* 一级配置器的问题\n    * 直接的malloc后的数据上下各有一个越界标记。上越界标记之外还有信息，包括申请了多少字节，还有next域、prev域以便连接到链表中进行内存管理。除此之外可能还有有效/失效(是否释放)的标记。\n    * 除了包装信息占空间较多之外，还有malloc时花费的时间也多。这样就造成对于比较小的对象数据在malloc时入不敷出。\n    * 结论就是：对于较小数据，适用于内存池来进行内存管理。\n* **对于客户端申请较小空间（128bytes）的具体处理流程**：\n    1. 每次配置一大块内存，并维护对应的自由链表(free-list)\n    2. 下次如果再有相同大小的内存需求，直接从free-list中取出若干小块。\n    3. 如果客户端释放小块内存，就由配置器回收到free-list中。所以配置器除了分配空间，还负责回收空间。\n* 为了方便管理，SGI第二级配置器会主动按任何小块内存的内存需求量计算成8的倍数。（比如客户端要求30bytes，则计算为32bytes。\n* 共维护16个free-lists，各自管理大小分别为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128的小额区块。\n* free-lists的单结点结构如下：\n\n```cpp\nunion obj\n{\n  union obj * free_list_link;\n  char client_data[1];\t//the client sees this\n}\n```\n\n## 总览\n\n```c++\nenum { __ALIGN = 8};\nenum { __MAX_BYTES = 128};\nenum { __NFREELISTS = __MAX_BYTES / __ALIGN};\t// 128 / 8 = 16\n```\n\n```c++\ntemplate<bool threads, int inst>\t//参数1：是否考虑多线程，参数2：标识\nclass __default_alloc_template\n{\nprivate:\n    union obj\t/* 只是类型定义 */\n    {\n        union obj * free_list_link;\t//next\n        char client_data[1];\n    };\nprivate:\n    static obj * volatile free_list[__NFREELISTS];//volatile修饰obj*，即free_list数组中对于的数据内容。\n    static char* start_free;//每次配置的一大块'内存' 的内存来源的剩余部分的起始\n    static char* end_free;\t//每次配置的一大块'内存' 的内存来源的剩余部分的末尾\n    static size_t heap_size;//上面提到的都是内存来源，而这个内存来源都是从堆区申请的，堆区申请的总空间数要记录在案\n    static size_t ROUNT_UP(size_t bytes);\n    static size_t FREELIST_INDEX(size_t bytes);\t//hash\n    static char* chunk_alloc(size_t size, int & nobjs);//size - 对象的大小，nobjs对象的个数\n    static void* refill(size_t size);\t//重新填充\npublic:\t/* 用户调用 */\n    static void* allocate(size_t size);\n    static void deallocate(void* p, size_t n);\n    static void* reallocate(void* p, size_t old_sz, size_t new_sz);\n};\n```\n\n## 成员初始化\n\n```c++\n// 对free_list[__NFREELISTS]进行初始化。\ntemplate<bool threads, int inst> //\t1: __default_alloc_template是模板类，需要声明\ntypename __default_alloc_template<threads, inst>::obj * volatile // 2: obj是__default_alloc_template<threads, inst>类内的类，需要加上“哪个类”，并且要加上\"typename\"以示\"obj\"是个类名，而非成员。\n    __default_alloc_template<threads, inst>::free_list[__NFREELISTS] = {};\t// 3: free_list[__NFREELISTS]是__default_alloc_template<threads, inst>类内的成员，需要加上“哪个类”，但无需加\"typename\"。\n// 对start_free进行初始化\ntemplate<bool threads, int inst>\nchar* __default_alloc_template<threads, inst>::start_free = nullptr;\n// 对end_free进行初始化\ntemplate<bool threads, int inst>\nchar* __default_alloc_template<threads, inst>::end_free = nullptr;\n// 对heap_size进行初始化\ntemplate<bool threads, int inst>\nsize_t __default_alloc_template<threads, inst>::heap_size = 0;\n```\n\n## 函数实现\n\n准备工作\n\n```c++\nusing malloc_alloc = __malloc_alloc_template<0>;\n```\n\n### allocate\n\n相当于单链表的头删法，返回删了的节点的地址给用户用。\n\n```c++\nstatic void * allocate(size_t size)\n{\n    if(size > (size_t)__MAX_BYTES)\n    {\n        return malloc_alloc::allocate(size);\t//转给一级配置器。\n    }\n    obj * result = nullptr;\n    obj * volatile * my_free_list = nullptr;\t//是二级指针，要指向obj*\n    my_free_list = free_list + FREELIST_INDEX(size);\n    result = *my_free_list;\n    if(nullptr == result)\t//说明此下标处无内存块了，需要申请。\n    {\n        void * r = refill(ROUND_UP(size));\n        return r;\n    }\n    *my_free_list = result->free_list_link;\t//把free_list此下标的指针更新到下一个节点。相当于链表的头删法。\n    return result;\n}\n```\n\n### refill\n\n```c++\nstatic void * refill(size_t size)\n{\n    int nobjs = 20;\n    char * chunk = chunk_alloc(size, nobjs);\n    //chunk_alloc运行之后，nobjs值可能发生改变。\n    if(1 == nobjs)\n    {\n        //如果nobjs是1，则说明内存块正好用完，不用再处理后续内存区域的链接、移动\n        return chunk;\n    }\n    \n    //接下来，把内存块分崩离析，依次串联。\n    obj * volatile * my_free_list = NULL;\n    obj * result = (obj*)chunk;\n    obj * current_obj = NULL, * next_obj = NULL;\n    my_free_list = free_list + FREELIST_INDEX(size);\n    *my_free_list = next_obj = (obj*)(chunk+size);\n    for(int i = 1; ; ++i)\n    {\n        current_obj = next_obj;\n        next_obj = (obj*)((char*)next_obj + size);\n        if(i == nobjs-1)//最后一块\n        {\n            current_obj->free_list_link = NULL;\n            break;\n        }\n        current_obj->free_list_link = next_obj;\n    }\n    return result;\n}\n```\n\n### chunk_alloc\n\n```c++\nstatic char* chunk_alloc(size_t size, int & nobjs)\n{\n    char * result = NULL;\n    size_t total_bytes = size * nobjs;\n    size_t bytes_left = end_free - start_free;\n    if(bytes_left >= total_bytes)\n    {\n        result = start_free;\n        start_free = start_free + total_bytes;\n        return result;\n    }\n    else if(bytes_left >= size)\n    {\n        nobjs = bytes_left / size;\n        total = size * nobjs;\n        \n        result = start_free;\n        start_free = start_free + total_bytes;\n        return result;\n    }\n    else //内存不足以分配1个对象，把剩余的插入到其他下标(剩8字节插到0, 16字节插到1, ...)，然后再另外申请一个大的\n    {\n        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n        if(bytes_left > 0)\n        {\n            obj * volatile * my_free_list = free_list + FREELIST_INDEX(bytes_left);\n            //头插\n            ((obj*)start_free)->free_list_link = *my_free_list;\n            *my_free_list = (obj*)start_free;\n        }\n        //剩余的残存空间 处理完毕，接下来申请大块内存\n        start_free = (char*)malloc(bytes_to_get);\n        if(NULL == start_free)\t//堆区居然没有资源了！无奈之计，只能向比他之后的链表找有无剩余块。\n        {\n            obj * volatile * my_free_list = NULL;\n            for(int i = size; i <= __MAX_BYTES; i += __ALIGN)\t//注意，i从size开始，而不一定从最小的块大小8开始，因为找比你小的没有用处。得找大的。\n            {\n                my_free_list = free_list + FREELIST_INDEX(i);\n                obj * p = NULL;\n                if(NULL != p)\t//找到了比他大的的剩余的了！\n                {\n                    *my_free_list = (*my_free_list)->free_list_link;\n                    start_free = (char*)p;\n                    end_free = start_free + i;\n                    return chunk_alloc(size, nobjs);\n                }\n            }\n            //如果上面的for循环没能使得其找到合适的内存块，则说明真的是“山穷水尽疑无路”了，只能转1级配置器，抛出异常或者通过handler处理。\n            start_free = malloc_alloc::allocate(bytes_to_get);\n        }\n        end_free = start_free + bytes_to_get;\n        heap_size += bytes_to_get;\n        return chunk_alloc(size, nobjs);\t//递归此函数，相当于重新来一遍流程\n    }\n}\n```\n\n### ROUND_UP & INDEX\n\n```c++\nstatic size_t ROUNT_UP(size_t bytes)\n{\n    // 0 -> 0, 1~8 -> 8, 9~16 - > 16, 17~24 -> 24, ...\n    return (bytes+ __ALIGN-1) & ~(__ALIGN - 1);\n}\nstatic size_t FREELIST_INDEX(size_t bytes)\n{\n    // 1~8 -> 0, 9~16 -> 1, 17~24 -> 2, ...\n    return ((bytes+ __ALIGN-1) / __ALIGN) - 1;\n}\n```\n\n### 测试allocate\n\n```c++\n#ifdef __USE_MALLOC\ntypedef __malloc_alloc_template<0> malloc_alloc;\ntypedef malloc_alloc alloc;\n#else\ntypedef __default_alloc_template<0, 0> alloc;\n#endif\n```\n\n```c++\ntemplate<class T, class Alloc>\nclass simple_alloc\n{\npublic:\n    static T* allocate(size_t n)\t//申请n个T对象\n    {\n        return Alloc::allocate(sizeof(T)*n);\n    }\n    static T* allocate()\n    {\n        return Alloc::allocate(sizeof(T));\n    }\n    void deallocate(T *p, size_t n)\n    {\n        if(NULL == p)return;\n        Alloc::deallocate(p, sizeof(T)*n);\n    }\n    void deallocate(T* p)\n    {\n        if(NULL == p)return;\n        Alloc::deallocate(p, sizeof(T));\n    }\n};\n```\n\n引入list进行测试\n\n```c++\n#include\"my_list.h\"\nusing namespace std;\nint main()\n{\n    xcg::my_list<char> mylist;\n    \n    for(int i = 0; i < 23; ++i)\n    {\n        mylist.push_back(i + 'a');\n    }\n    return 0;\n}\n```\n\nlist构建流程：\n\n```c++\ntemplate<class _Ty, class _A = xcg::alloc>\nclass my_list\n{\npublic:\n    typedef _Ty\t\t\t\t\t\t\t value_type;\n    typedef _Ty&\t\t\t\t\t\t reference;\n    typedef _Ty*\t\t\t\t\t\t pointer;\n    typedef const _Ty&\t\t\t\t\t const_reference;\n    typedef const _Ty*\t\t\t\t\t const_pointer;\n    \n    typedef _A\t\t\t\t\t\t\t allocator_type;\n    typedef xcg::simple_alloc<_Node, _A> data_allocate;\t\t//simple_alloc中使用的是第二个参数的allocate。在这里即使用_A::allocate，默认参数是xcg::alloc，而根据开关语句，若是使用malloc_alloc则为一级配置器，若为default_alloc则用二级配置器。我们默认使用的是__default_alloc_template<0, 0>。\n    \npublic:\n    my_list() : _Head(_Buynode()), _Size(0) {}\nprotected:\n    _Nodeptr _Buynode(_Nodeptr _parg = NULL, _Nodeptr _narg = NULL)\n    {\n        _Nodeptr _S = data_allocate::allocate();\n        _Acc::_Prev(_S) = _parg == NULL ? _S : _parg;\n        _Acc::_Next(_S) = _narg == NULL ? _S : _narg;\n        return _S;\n    }\nprivate:\n    _Nodeptr _Head;\n    size_t _Size;\n};\n```\n\n### deallocate\n\n```c++\nstatic void deallocate(void * p, size_t size)\t// n 表示空间大小\n{\n    if(size > (size_t)__MAX_BYTES)\n    {\n        malloc_alloc::deallocate(p, size);\n        return;\n    }\n    //归还给配置器\n    obj * q = (obj*)p;\n    obj * volatile * my_free_list = free_list + FREELIST_INDEX(size);\n    //头插\n    q->free_list_link = *my_free_list;\n    *my_free_list = q;\n    return;\n}\n```\n\n### 测试deallocate\n\n```c++\niterator erase(iterator _P)\n{\n    _Nodeptr _S = _P++._Mynode();\n    _Acc::_Next(_Acc::_Prev(_S)) = _Acc::_Next(_S);\n    _Acc::_Prev(_Acc::_Next(_S)) = _Acc::_Prev(_S);\n    destroy(&_Acc::_Value(_S));\t//不删除节点，而是释放value域。\n    _Freenode(_);\n    \n    return _P;\n}\nvoid _Freenode(_Nodeptr _P)\n{\n    data_allocate::deallocate(_P);\n}\nvoid pop_back()\n{\n    erase(--end());\n}\nvoid pop_front()\n{\n    erase(begin());\n}\n```\n\n```c++\nclass Object\n{\nprivate:\n    int value;\npublic:\n    Object(int x = 0) : value(x)\n    {\n        cout << \"create object\" << this << endl;\n    }\n    ~Object()\n    {\n        cout << \"destroy object\" << this << endl;\n    }\n};\nint main()\n{\n    xcg::my_list<Object> objlist;\n    for(int i = 0; i < 10; ++i)\n    {\n        objlist.push_back(Object(i));\n    }\n    objlist.pop_back();\n    return 0;\n}\n```\n\n### reallocate\n\n```c++\nstatic void* reallocate(void * p, size_t old_sz, size_t new_sz)\n{\n    if(old_sz > (size_t)__MAX_BYTES && new_sz > (size_t)__MAX_BYTES)\n    {\n        return malloc_alloc::reallocate(p, old_sz, new_sz);\n    }\n    // old_sz == 20, new_sz == 22\t-->24, 24\n    if(ROUND_UP(old_sz) == ROUND_UP(new_sz))\n    {\n        return p;\n    }\n    // old_sz > 128, new_sz < 128\n    // old_sz < 128, new_sz < 128\n    // old_sz < 128, new_sz > 128\n    size_t sz = old_sz < new_sz ? old_sz : new_sz;\n    void * s = allocate(new_sz);\n    memmove(s, p ,sz);\n    deallocate(p, old, sz);\n    return s;\n}\n```\n\n","categories":["Cpp","项目"]},{"title":"网络_TCP","url":"/网络/网络_TCP/","content":"# 四次挥手\n![](../../images/网络_TCP/image-20250722092657370.png)\n\n\n# TCP\n特点：\n\n1. 面向连接的\n    1. 三次握手--在客户端connect()时\n        1. 必须是三次\n    2. 四次挥手--在任一方close时\n        1. 有时可以三次\n2. 可靠的\n    1. 应答确认\n    2. 超时重传\n    3. 乱序重排\n    4. 去重\n    5. 滑动窗口进行流量控制\n3. 流式服务\n    1. 发送和接收的次数可能不一致。\n        1. 连续多次发送的数据可能会被对方一次性收到。\n    2. 起始末尾加标记\n    3. send之后recv隔开\n4. tcp是有状态的\n    1. 开始`closed`\n    2. `listen`--`connecting`(三次握手中)\n    3. `established`(已完成握手)\n    4. `FIN_WAIT_1`/`FIN_WAIT_2`\n    5. `TIME_WAIT`\n        1. 可靠地终止TCP的连接\n        2. 让迟来的报文在这一段时间被识别，即收集后丢弃，以防止误传给下一个使用该端口的连接。\n\n问题：1、TCP/IP协议详解 卷一；2、UNIX网络编程 卷一\n\n1. 三次握手，四次挥手\n2. 应答确认、超时重传机制\n3. 乱序重排、去重、滑动窗口进行流量控制\n4. 什么是粘包？怎么解决？\n5. 中间转换状态的意义？TIME_WAIT状态的意义？\n# TCP首部\n\n![image-20220325091330300](../../images/Linux_TCP/image-20220325091330300.png)\n\n* 序列号(Sequence Number)字段标识了TCP发送端到TCP接收端的数据流的一个字节，**该字节代表着这个报文段对应的数据中的第一个字节**。如果我们考虑在两个应用程序之间的一个方向上流动的数据流，TCP给每个字节赋予一个序列号。这个序列号是一个32位的无符号数，到达$2^{32}-1$后再循环回到0。\n* **确认号(Acknowledgment Number)**是该发送方期待接收的下一个序列号。\n    * TCP可以被描述为一种“带累积正向确认的滑动窗口协议”。ACK号字段被构建用于指明在接收方已经顺序收到的最大字节(加1)。例如，如果字节1~1024已经接收成功，而下一个报文段包含字节2049~3072，那么接收方不能使用规则的ACK号字段去发信告诉发送方它接收到了这个新报文段（先保留）。然而，现代TCP有一个**选择确认(Selective ACKnowledgment, SACK)选项**，可以允许接收方告诉发送方它正确地接收到了次序杂乱的数据。当与一个具有选择重发(selective repeat)能力的TCP发送方搭配时，就可以实现性能的显著改善。我们将会看到TCP是如何使用重复确认(duplicate acknowledgments)以帮助它的拥塞控制和差错控制过程的。\n* **头部长度(Header Length)字段**给出了头部的长度，此字段只占4位，计算时，以32位字(4字节)为单位，比如该字段是1111，则头部长度为$15 * (32 / 8) = 60$字节。它是必需的，因为选项(Options)字段的长度是可变的。\n* 接下来是预留位(Resv)和8个标志位，旧版本的TCP头部的标志位只用到了后6个；它们中的1个或多个可被同时启用。其中除了后6个旧版本已有的，新的2个标志位为：\n    1. CWR：拥塞窗口减（发送方降低它的发送速率）\n    2. ECE：ECN回显（发送方接收到了一个更早的拥塞通告）\n* **窗口大小(Window Size)字段**。TCP的流量控制由每个端口使用这个字段来通告一个窗口大小来完成。这个窗口大小是**字节数**，从ACK号指定的，也是接收方想要接收的那个字节开始。这是一个16位的字段，限制了窗口大小到65535字节，从而限制了TCP的吞吐量性能。**窗口缩放(Window Scale)选项**可允许对这个值进行缩放,给高速和大延迟网络提供了更大的窗口和改进性能。\n* TCP校验和(TCP Checksum)字段覆盖了TCP的头部、数据以及IP头部中的一些字段；是一个强制性的字段，由发端计算和存储，并由收端进行验证。TCP检验和的计算与UDP检验和的计算相似，使用一个伪首部。\n* 紧急指针(Urgent Pointer)字段。紧急指针是一个正偏移量，和序列号字段中的值相加**表示紧急数据最后一个字节**的序列号。这种TCP紧急机制是发送端向另一端提供特殊标志数据的方法。\n* 选项字段。最常见的就是“最大段大小”选项。连接的每个端点一般在它发送的第一个报文段（为了建立该连接，SYN位字段被设置的那个报文段）上指定这个选项。MSS指定该选项的发送者在相反方向上希望接收到的报文段的最大值。\n* TCP报文段的数据部分是可选的。当一个连接被建立和终止时，交换的报文段只包含TCP头部(可能带选项)而没有数据。\n    * 如果这个方向上没有数据被传输，那么一个不带任何数据的头部也会用于ACK接收到的数据（称为一个pure ACK），同时通知通信方改变窗口大小（称为一个窗口更新(window update)）。\n    * 当一个报文段可不带数据发送时，超时操作会因此而产生一些新情况。\n\n# 标志位\n\n## URG\n\nURG，全拼是urgent。表示紧急。此标志表示：**紧急指针有效**。\n\n## ACK\n\n表示确认序号字段有效。需要注意，确认标志位和确认序号字段不一样，确认序号和序列号不一样。\n\n* 既然每个传输的字节都被计数，确认序号会填写该端所期望收到的下一个序号。因此确认序号应当是上次已成功收到数据字节序号+1。\n* 发送一个ACK与发送任何一个TCP报文段的开销是一样的，因为那个32位的ACK号字段一直都\n  是头部的一部分，ACK位字段也一样。\n  TCP/IP详解\\_卷1\\_第2版\\_英语原文如下：Sending an ACK costs nothing more than sending any other TCP segment because the 32-bit ACK Number field is always part of the header, as is the ACK bit field.\n* 只有ACK标志为1时，确认序号字段才有效；一旦一个连接建立起来，确认序号字段总是被设置， ACK标志也总是被设置为1；这个**ACK位字段几乎用于所有报文段，除了初始和末尾报文段**。\n\n## PSH\n\n接收方应该尽快将这个报文段交给应用层。\n\n## RST\n\n重建连接\n\n## SYN\n\n同步序号用来发起一个连接。\n\n* 当建立一个新的连接时，SYN标志变1。序列号字段随即会包含由这个主机选择的该连接的**初始序列号ISN(Initial Sequence Number)**。\n* 该主机要发送数据的第一个字节序列号为ISN+1，因为SYN标志消耗了一个序号。消耗一个序列号也意味着使用重传进行可靠传输。因此，SYN和应用程序字节（还有FIN，稍后我们将会见到）是被可靠传输的。不消耗序列号的ACKs则不是。\n## FIN\n\nFIN发端完成发送任务。\n\n# 如何保证数据可靠传输\n\n那些自身不包含可靠传递数据机制的协议。它们可能会使用一种像校验和或CRC这样的数学函数来**检测**接收到的有差错的数据，**但是它们不尝试去纠正差错**。比如对于IP和UDP则根本没有实现差错纠正。对于以太网和基于其上的其他协议，协议提供一定次数的重试，如果还是不成功则放弃。\n\n通信媒介可能会丢失或改变被传递的消息，在这种环境下的通信问题已经被研究了多年。关于这个课题的一些最重要的理论工作由香农在1948年给出。这些工作普及了术语“比特”，并成为信息理论(information theory)领域的基础，帮助我们理解了在一个有损（可能会删除或改变比特）信道里可通过的信息量的根本限制。信息理论与编码理论(coding theory)的领域密切相关，编码理论提供不同的信息编码手段，从而使得信息能在通信信道里尽量免于出错。其中有两种手段：\n\n1. 使用差错校正码（基本上是添加一些冗余的比特，使得即使某些比特被毁，真实的信息也可以被恢复过来）来纠正通信问题是处理差错的一种非常重要的方法。\n2. 另一种方法是简单地“尝试重新发送”，直到信息最终被接收。这种方法，称为自动重复请求(Automatic Repeat Request, ARQ)，构成了许多通信协议的基础，包括TCP在内。\n\n## ARQ和重传\n\n如果我们考虑的不只是单个通信信道，而是几个的多跳级联，我们会发现不只会碰到前面提到的那几种差错类型（分组比特差错），而且还会有更多其他的类型。这些问题可能发生在中间路由器上，是几种在讨论IP时会遇到的问题：分组重新排序，分组复制，分组泯灭（丢失）。为在多跳通信信道（例如IP）上使用而设计的带纠错的协议必须要处理这些问题。\n\n现在让我们来探讨能处理这些问题的协议机制。在概括性地讨论这些之后，我们会探究它们是如何被TCP在互联网上使用的。\n\n一个直接处理分组丢失（和比特差错）的方法是重发分组直到它被正确接收。这需要种方法来判断：\n\n1. 接收方是否已收到分组；\n2. 接收方接收到的分组是否与之前发送方发送的一样。\n\n接收方给发送方发信号以确定自己已经接收到一个分组，这种方法称为确认(acknowledgment, ACK)。最基本的形式是，发送方发送一个分组，然后等待一个ACK。当接收方接收到这个分组时，它发送对应的ACK。当发送方接收到这个ACK，它再发送另一个分组，这个过程就这样继续。这里会有一些有意思的问题：\n\n1. 发送方对一个ACK应该等待多长时间？\n2. 如果ACK丢失了怎么办？\n3. 如果分组被接收到了，但是里面有错怎么办？\n\n第一个问题其实挺深奥的。决定去等待多长时间与发送方期待(expect)为一个ACK等待多长时间有关。现在确定这个时间可能比较困难，因此我们推迟对这个技术的讨论。\n\n第二个问题的答案比容易：如果一个ACK丢失了，发送方不易区分ACK报文段丢失与原分组丢失的情况，所以它简单地再次发送原分组。当然，这样的话，接收方可能会接收到两个或更多的拷贝，因此它必须准备好处理这种情况（见下一段）。\n\n至于第三个问题，我们可以借助某个编码技术来解决。使用编码来检测一个大的分组中的差错（有很大的概率）一般都很简单，仅使用比其自身小很多的一些比特即可纠正。更简单的编码一般不能纠正差错，但是能检测它们。这就是校验和与CRC会如此受欢迎的原因。然后，为了检测分组里的差错，我们使用一种校验和形式。当一个接收方接收到一个含有差错的分组时，它不发送ACK。最后，发送方重发完整到达的无差错的分组。\n\n到目前为止即使这种简单的场景，接收方都可能接收到被传送分组的重复(duplicate)副本。这个问题要使用序列号(sequence number)来处理。基本上，在被源端发送时，每个**唯一**的分组都有一个新的序列号，这个序列号由分组自身一直携带着。接收方可以使用这个序列号来判断它是否已经见过这个分组，如果见过则丢弃它。\n\n到目前为止介绍的协议是可靠的，但效率不太高。如果从发送方到接收方传递即使一个很小的分组都要用很长时间（推迟或延迟）的话（如一秒或两秒，对卫星链路来说并非不正常），考虑一下那会怎样。发送方可以注入一个分组到通信路径，然后停下来等待直到它收到ACK。这个协议因此被称为“停止和等待”。假设没有分组在传输中丢失或者这些分组没有被无可挽回地损害，该协议的吞吐量(throughput)性能（每单位时间发送的数据量）与$M/R$成正比，$M$是分组大小，$R$是往返时间（RTT），即分组越小、往返时间越大则性能就越低。如果有分组丢失和损害的话，情况甚至更糟糕：“吞吐质(goodput)”（每单位时间传送的**有用**数据量）明显要比吞吐量要低。\n\n对于不会损害和丢失太多分组的网络来说，低吞吐量的原因是网络经常没有处于繁忙状态。情况与使用装配流水线时不出一个完整产品就不准新的工作进入类似。流水线大部分时间是空闲的。我们进一步对比，很明显，如果我们允许同一时间有多个工作单元进人流水线，就可以做得更好。对网络通信来说也是一样的一—如果我们允许多个分组进入网络，就可以使它“更繁忙”，从而得到更高的吞吐量。\n很明显，允许多个分组同时进人网络使事情变得复杂。现在发送方必须不仅要决定什么时间注入一个分组到网络中，还要考虑注入多少个。并且必须要指出在等待ACK时，怎样\n# TIME_WAIT\n2倍的MSL时间（Maximum Segment Lifetime）。","categories":["网络"]},{"title":"高级数据结构_B树","url":"/高级数据结构/高级数据结构_B树/","content":"# B树\nB代表Balanced，所有叶子节点都在同一层。\n# B树代码示例\n\n```cpp\n#include<iostream>\nusing namespace std;\n#define M 5\n#define MAXSIZE (M-1)\n#define MINSIZE (M/2)\ntypedef char KeyType;\ntypedef struct Record {} Record;\ntypedef struct ElemType\n{\n\tKeyType key;\n\tRecord* recptr;\n}ElemType;\ntypedef struct BNode\n{\n\tint num;\n\tstruct BNode* parent;\n\tElemType data[M + 1];\n\tstruct BNode* sub[M + 1];\n}BNode;\ntypedef struct BTree\n{\n\tstruct BNode* root;\n\tint cursize;\n}BTree;\ntypedef struct Result\n{\n\tstruct BNode* pnode;\n\tint index;\n\tbool tag;\n}Result;\nBNode* Buynode()\n{\n\tBNode* s = (BNode*)malloc(sizeof(BNode));\n\tif (nullptr == s)exit(1);\n\tmemset(s, 0, sizeof(BNode));\n\treturn s;\n}\nvoid Init_BTree(BTree& tree)\n{\n\ttree.root = nullptr;\n\ttree.cursize = 0;\n}\nResult FindKey(BTree& tree, KeyType kx)\n{\n\tResult res = { nullptr, -1,false };\n\tstruct BNode* ptr = tree.root;\n\twhile (ptr != nullptr)\n\t{\n\t\tptr->data[0].key = kx;\n\t\tint i = ptr->num;\n\t\twhile (i>=0 && ptr->data[i].key)\n\t\t{\n\t\t\t--i;\n\t\t}\n\t\tres.pnode = ptr;\n\t\tres.index = i;\n\t\tif (i > 0 && kx == ptr->data[i].key) \n\t\t{ \n\t\t\tres.tag = true;\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr->sub[i];\n\t}\n\treturn res;\n}\nBNode* MakeRoot(const ElemType& item, BNode* left, BNode* right)\n{\n\tBNode* s = Buynode();\n\ts->num = 1;\n\ts->parent = nullptr;\n\ts->data[1] = item;\n\ts->sub[0] = left;\n\tif (left != nullptr)left->parent = s;\n\ts->sub[1] = right;\n\tif (right != nullptr)right->parent = s;\n\treturn s;\n}\nvoid Insert_Item(BNode* ptr, int pos, const ElemType& item, BNode* right)\n{\n\tfor (int i = ptr->num; i > pos; --i)\n\t{\n\t\tptr->data[i + 1] = ptr->data[i];\n\t\tptr->sub[i + 1] = ptr->sub[i];\n\t}\n\tptr->data[pos + 1] = item;\t//?\n\tptr->sub[pos + 1] = right;\t//?\n\tptr->num += 1;\n}\nElemType Move_Item(BNode* s, BNode* ptr, int pos)\n{\n\tfor (int i = 0, j = pos + 1; j <= ptr->num; ++i, ++j)\n\t{\n\t\ts->data[i] = ptr->data[j];\n\t\ts->sub[i] = ptr->sub[j];\n\t\tif (s->sub[i] != nullptr)\n\t\t{\n\t\t\ts->sub[i]->parent = s;\n\t\t}\n\t}\n\ts->num = MINSIZE;\n\tptr->num = MINSIZE;\n\ts->parent = ptr->parent;\n\treturn s->data[0];\n}\nBNode* Splice(BNode* ptr)\n{\n\tBNode* s = Buynode();\n\tElemType item = Move_Item(s, ptr, MINSIZE);\n\tif (ptr->parent == nullptr)\n\t{\n\t\treturn MakeRoot(item, ptr, s);\n\t}\n\tBNode* pa = ptr->parent;\n\tint pos = pa->num;\n\tpa->data[0] = item;\n\twhile (pos > 0 && item.key < pa->data[pos].key) { --pos; }\n\tInsert_Item(pa, pos, item, s);\n\tif (pa->num > MAXSIZE)\n\t{\n\t\treturn Splice(pa);\n\t}\n\telse\n\t{\n\t\treturn nullptr;\n\t}\n}\nbool Insert(BTree& tree, const ElemType& item)\n{\n\tif (tree.root == nullptr)\n\t{\n\t\ttree.root = MakeRoot(item, nullptr, nullptr);\n\t\ttree.cursize = 1;\n\t\treturn true;\n\t}\n\t//不为空\n\tResult res = FindKey(tree, item.key);\n\tif (res.pnode != nullptr && res.tag)return false;\n\t//在res.pnode处插入\n\tBNode* ptr = res.pnode;\n\tint pos = res.index;\n\tInsert_Item(ptr, pos, item, nullptr);\n\n\tif (ptr->num > MAXSIZE)\n\t{\n\t\tBNode* newroot = Splice(ptr);\t//分裂\n\t\tif (newroot != nullptr)\n\t\t{\n\t\t\ttree.root = newroot;\n\t\t}\n\t}\n\ttree.cursize += 1;\n\treturn true;\n}\nBNode* FindPrev(BNode* ptr, int pos)\n{\n\tBNode* p = ptr->sub[pos];\n\twhile (p != nullptr && p->sub[p->num])\n\t{\n\t\tp = p->sub[p->num];\n\t}\n\treturn p;\n}\nBNode* FindNext(BNode* ptr, int pos)\n{\n\tBNode* p = ptr->sub[pos];\n\twhile (p != nullptr && p->sub[0])\n\t{\n\t\tp = p->sub[0];\n\t}\n\treturn p;\n}\nbool Remove(BTree& tree, KeyType kx)\n{\n\tResult res = FindKey(tree, kx);\n\tif (res.pnode == nullptr || !res.tag)return false;\n\tBNode* ptr = res.pnode;\n\tint pos = res.index;\n\tBNode* pre = FindPrev(ptr, pos - 1);\n\tBNode* nt = FindNext(ptr, pos);\n\tif (pre != nullptr && ptr->num > MINSIZE)\n\t{\n\t\tptr->data[pos] = pre->data[ptr->num];\n\t\tptr = pre;\n\t\tpos = pre->num;\n\t}\n\telse if (nt != nullptr && nt->num > MINSIZE)\n\t{\n\t\tptr->data[pos] = nt->data[1];\n\t\tptr = nt;\n\t\tpos = 1;\n\t}\n\telse if (pre != nullptr)\n\t{\n\t\tptr->data[pos] = pre->data[pre->num];\n\t\tptr = pre;\n\t\tpos = pre->num;\n\t}\n\tDelete_Leaf(ptr, pos);\n\tif (ptr->parent == nullptr && ptr->num == 0)\n\t{\n\t\tfree(ptr);\n\t\ttree.root = nullptr;\n\t}\n\telse if (ptr->num < MINSIZE)\n\t{\n\t\tBNode* newroot = Merge_Leaf(ptr);\n\t\tif (newroot != nullptr)\n\t\t{\n\t\t\ttree.root = newroot;\n\t\t}\n\t}\n}\nint main()\n{\n\tBTree myt;\n\tInit_BTree(myt);\n\tchar ch[] = { \"qwertyuiopasdfghjklzxcvbnm\" };\n\tint i = 0;\n\twhile (ch[i] != '\\0')\n\t{\n\t\tElemType item = { ch[i],nullptr };\n\t\tcout << Insert(myt, item);\n\t\ti++;\n\t}\n\tcout << endl;\n}\n```\n\n# `B*`\n\n与B+树的结构一致。\n\n但是\n\n```cpp\nbool Move_Left_Right(BNode * ptr)\n{\n    bool res = false;\t//是否移动\n    BNode * left = ptr->prev;\n    BNode * right = ptr->next;\n    if(left != nullptr && left->num < LEAFMAX)\n    {\n        //左移\n        res = true;\n    }else if(right != nullptr && right->num < LEAFMAX)\n    {\n        //右移\n        res = true;\n    }\n    return res;\n}\nbool Insert(BTree& tree, KeyType kx, Record * rec)\n{\n\tif (tree.root == nullptr)\n\t{\n\t\tBNode *s = BuyLeaf();\n\t\ts->key[0] = kx;\n        s->recptr[0] = rec;\n        s->num = 1;\n        tree.root = tree.first = s;\n        return true;\n\t}\n\t//不为空\n\tResult resr = FindRoot(tree.root, kx);\n\tResult resf = FindLeaf(tree.first, kx);\n\tif(resf.pnode == nullptr){cout << \"BTree struct err\"<<endl;return false;}\n    if (resf.tag){cout << \"exist\"<<endl;return false;}\n\t//在res.pnode处插入\n\tBNode* ptr = resf.pnode;\n\tint pos = resf.index;\n\tInsert_Leaf_Item(ptr, pos, kx, rec);\n\t\n\tif (ptr->num > LEAFMAX)\n\t{\n        // 移动\n\t\tBNode* newroot = Splice_Leaf(ptr);\t//分裂\n\t\tif (newroot != nullptr)\n\t\t{\n\t\t\ttree.root = newroot;\n\t\t}\n\t}\n\ttree.cursize += 1;\n\treturn true;\n}\n```\n\n\n\n\n\n","categories":["高级数据结构","树"]},{"title":"C语言_restrict","url":"/C/C语言_restrict/","content":"\n参考文章：[C++ 需要 restrict 关键字吗？ - 蓝色的回答 - 知乎](https://www.zhihu.com/question/32106315/answer/54660335)\n\n# 演示\n\nC/Cpp编译器，无论是GCC，Clang，VCpp，IBM XL Cpp等，这些主流的Cpp编译器都提供了restrict关键字的支持，只是书写的形式有所变化，如可能是\\_\\_restrict\\_\\_，\\_\\_restrict等 ，而restrict是限制**Pointer Alias**的，限制Pointer Alias有助于编译器做优化，这和unique_ptr完全是两码事。\n\n## restrict\n\n以GCC产生汇编指令的例子来补充一下，比较直观\n\n```c\nvoid f(int *a, int *b, int *c)\n{\n    *a += *c;\n    *b += *c;\n}\n```\n\n-O3后的汇编代码\n\n```x86asm\nf(int*, int*, int*):\n\tmovl\t(%rdx), %eax\n\taddl\t%eax, (%rdi)\n\tmovl\t(%rdx), %eax\n\taddl\t%eax, (%rsi)\n\tret\n```\n\n加上restrict\n\n```c\nvoid f(int * __restrict__ a, int* __restrict__ b, int* __restrict__ c)\n{\n  *a += *c;\n  *b += *c;\n}\n```\n\n-O3后\n\n```x86asm\nf(int*, int*, int*):\n\tmovl\t(%rdx), %eax\n\taddl\t%eax, (%rdi)\n\taddl\t%eax, (%rsi)\n\tret\n```\n\n**可以很清楚的看见是4条指令变为了3条指令，而少掉的一条就是第二次的load c**\n\n## unique_ptr\n\n```cpp\n#include <memory>\nusing namespace std;\nvoid f(std::unique_ptr<int> a, std::unique_ptr<int>b, std::unique_ptr<int> c)\n{\n  *a += *c;\n  *b += *c;\n}\n```\n\n-O3 -std=c++11\n\n```x86asm\nf(std::unique_ptr<int, std::default_delete<int> >, std::unique_ptr<int, std::default_delete<int> >, std::unique_ptr<int, std::default_delete<int> >):\n\tmovq\t(%rdx), %rdx\n\tmovq\t(%rdi), %rax\n        \n        ; *a += *c\n\tmovl\t(%rdx), %ecx\n\taddl\t%ecx, (%rax)\n\n\tmovq\t(%rsi), %rax\n        \n        ; *b += *c\n\tmovl\t(%rdx), %edx\n\taddl\t%edx, (%rax)\n\tret\n```\n\n所以，可见，unique_ptr和restrict完全是两码事。\n\n# 个人理解\n\n至于为什么会和unique_ptr混淆，因为他两个语义上有共同之处：只有一个指针指向某个变量。但是restrict的目的是给编译器做优化，而且它的限制效果与const修饰符很类似，需要自己去体会；\n\n---\n\n评论区见解：\n\n提问者 - dawnmist：按照unique_ptr的语义，它是资源的唯一持有者。如果资源是内存，那也只能通过这一个unique_ptr访问。用unique_ptr时，编译器能不能像restrict那样优化这个指针访问呢？\n\n回答者 - 蓝色：不行，unique_ptr可以通过get()方法转为原始指针；unique_ptr只是一个智能指针，所以你不能这样限制unique_ptr的语义。","categories":["C"]},{"title":"网络_网络编程流程","url":"/网络/网络_网络编程流程/","content":"# TCP编程流程\n面试唯一要写代码的。\n\n1. 服务器端：\n    1. `socket()` - 创建套接字 - 所需地址：ip+port\n    2. `bind()` - 指定这个套接字是哪个IP:Port\n    3. `listen()` - 设置监听队列的大小\n    4. `c = accept()` - 接受连接\n    5. `recv()` - 接收客户端发送的数据\n    6. `send()` - 给客户端发送数据\n    7. `close()` - 关闭连接\n2. 客户端：\n    1. `socket()` - 创建套接字\n    2. `connect()` - 发起连接\n    3. `send()` - 如果建立连接成功，则可以发送数据\n    4. `recv()` - 收服务器回复的数据\n    5. `close()`\n\n>客户端的bind：\n>一般情况下客户端不需要bind，端口号是随机的。如果想要让客户端固定自己发出连接的端口号，可以主动bind。\n# 字节序（大小端问题）\n参考：《Linux高性能服务器编程（游双）》5.1.1 主机字节序和网络字节序 一节。\n\n现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位机，下同），那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。\n\n字节序分为大端字节序（big endian）和小端字节序（little endian）。\n大端字节序是指一个整数的高位字节（23～31bit）存储在内存的低地址处，低位字节（0～7bit）存储在内存的高地址处。\n小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。\n\n**现代PC（如 x86）大多采用小端字节序**，因此小端字节序又被称为**主机字节序**。两台不同字节序的主机传递数据时，必然发生错误。\n\n>也有系统采用大端字节序，如PowerPC、Java虚拟机。\n\n解决问题的方法是：发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。因此大端字节序也称为网络字节序。\n\n需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由JAVA编写）通信，也要考虑字节序的问题（JAVA虚拟机采用大端字节序）。\n\n以下代码可用于检查机器的字节序。\n```c\n#include <stdio.h>\nvoid byteorder()\n{\n    union\n    {\n        short value;\n        char bytes[sizeof(short)];\n    } test;\n    test.value = 0x0102;\n    if (test.bytes[1] == 1)       // 通过数组[1] 看 高地址 存放的是 高位（1）吗？\n    {\n        printf(\"little endian\\n\");\n    }\n    else if (test.bytes[1] == 2)  // 通过数组[1] 看 高地址 存放的是 低位（2）吗？\n    {\n        printf(\"big endian\\n\");\n    }\n    else\n    {\n        printf(\"unknown endianness\\n\");\n    }\n}\n```\n## 转换字节序API\n定义于`<netinet/in.h>`\n\nLinux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：\n这4个函数中，长整型函数通常用来转换IP地址（4字节），短整型函数用来转换端口号（2字节）。\n当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序。\n```c\n#include <netinet/in.h>\nunsigned long int htonl(unsigned long int hostlong);\nunsigned short int htons(unsigned short int hostshort);\nunsigned long int ntohl(unsigned long int netlong);\nunsigned short int ntohs(unsigned short int netshort);\n```\n它们的含义很明确，比如`htonl`表示“host to network long”，即将长整型（32bit）的主机字节序数据转化为网络字节序数据。\n1. `h: host` / `n: network`\n2. to: transfer to\n    1. n + l: `long int` / `s: short int`\n    2. h + l: `long int` / `s: short int`\n# socket地址结构\n常见的协议族：\n![](../../images/网络_TCP编程流程/image-20250722065423512.png)\n>协议族：Protocol Family，简写PF。也称domain。\n>地址族：Address Family，简写AF。用于标识​**​网络地址和端口号​**​。\n>AF_INET：Address Family - Internet的简写。Internet采用的协议就是TCP/IP协议族。不带后缀的默认为TCP/IPv4。在 Linux/UNIX/Windows 系统中通用\n>AF_UNIX：Address Family - UNIX的简写，有的也简写为AF_LOCAL。用于本地进程间通信\n>AF_PACKET：用于底层的数据链路层访问\n## 通用socket地址结构\nsocket网络编程接口中表示**socket地址**的是结构体`sockaddr`，其定义如下：\n```c++\n#include<bits/socket.h>\nstruct sockaddr\n{\n    sa_family_t sa_family;\t//socket address family type\n    char sa_data[14];       //socket address data\n}\n```\n`sa_family`成员是地址族类型（`sa_family_t`）的变量。**地址族**类型通常与**协议族**类型对应。\n`sa_data`成员用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下图所示。\n![](../../images/网络_TCP编程流程/image-20250722070305877.png)\n可见，14字节根本无法完全容纳多数协议族的地址值。因此，Linux定义了新的通用socket地址结构体：\n>这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的\n\n```c\n#include <bits/socket.h>\nstruct sockaddr_storage\n{\n    sa_family_t sa_family;\n    unsigned long int __ss_align;\n    char __ss_padding[128 - sizeof(__ss_align)];\n}\n```\n## 专用socket地址结构\n上面提到的两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体。\n比如UNIX本地域协议族使用的socket地址结构体`sockaddr_un`：\n\n```c\n#include <sys/un.h>\nstruct sockaddr_un\n{\n    sa_family_t sin_family;// 搭配 AF_UNIX使用\n    char sun_path[108];    // socket unix path 文件路径\n}\n```\n\nTCP/IP的专用socket地址结构，见下文。\n# TCP/IP协议族地址结构\nTCP/IP协议族有`sockaddr_in`和`sockaddr_in6`两个专用socket地址结构体，分别用于IPv4和IPv6。\n定义于`<netinet/in.h>`中\n## IPv4：sockaddr_in\n`sockaddr_in`的in表示Internet（v4）。\n```c\n// IPv4 socket地址族结构\nstruct sockaddr_in\n{\n    sa_family_t \tsin_family;\t//地址族\n    __be16\t\t\tsin_port;\t//端口号，__be16 表示 16位大端序，类型是 u_int16_t\n    struct in_addr\tsin_addr;\t//IPv4 的 IP地址存放结构\n};\n```\n注意命名的规律：\nSocket地址族结构体`sockaddr_xx`成员的前缀都带`sxx_`。\n\n`in_addr`这个结构体是单独定义的，和socket概念是独立的。用于存放 IPv4 的 IP地址。所以类型名不带”s“前缀。\n```c\nstruct in_addr\n{\n    union\n    {\n        struct\n        {\n            // 4个char都是8位2进制，用于存储4个0-255。\n            u_char s_b1, s_b2, s_b3, s_b4; \n        }S_un_b;\t\t//An IPv4 address formatted as 4 u_chars, 4 * 8 bits\n        \n        struct\n        {\n            u_short s_w1, s_w2;\n        }S_un_w;\t\t//An IPv4 address formatted as 2 u_shorts, 2 * 16bits\n        \n        u_long S_addr;\t//An IPv4 address formatted as 1 u_long, 1 * 32 bits\n    }S_un;\n#define s_addr S_un.S_addr\t// u_long\n};\n```\n其中`#define`给`S_un.S_addr`取了别名`s_addr`。而且用的还是联合体，等效于：\n```c\nstruct in_addr\n{\n    u_int32_t s_addr;\n};\n```\n因此外界访问IP地址只需要：`mysocketaddr.sin_addr.s_addr`。注意中间的`sin_addr`是socketIPv4地址族的成员名，要和`sin_addr`的类型名`in_addr`区分。\n### 示例\n```c\nint main()\n{\n\tchar *echo_host = \"192.168.1.20\";\n\tint ehco_port = 7;\n\tstruct sockaddr_in *server = (struct sockaddr_in*)malloc(sizeof(struct sockaddr_in));\n\tserver->sin_family = AF_INET;\n\tserver->sin_port = htons(echo_port);\n\t//server is a struct of 'sockaddr_in'\n\t//so :  sockaddr_in . sin_addr(is a 'in_addr')\n\t\t\tin_addr . s_addr(is a #define of 'S_un.S_addr', S_addr is a u_long)\n\t\tso, sockaddr_in.in_addr.S_un.S_addr\n\t//final we find the u_long variable, 4 bytes, Corresponds to the 4 bytes of ipv4.\n\tserver->sin_addr.s_addr = inet_addr(echo_host);\n}\n```\n## IPv6\n```c\nstruct sockaddr_in6\n{\n    sa_family_t\t\tsin6_family;\t//AF_INET6\n    u_inet16_t\t\tsin6_port;\t\t//port 网络字节序\n    u_int32_t\t\tsin6_flowinfo;\t//流信息, 应设置为0\n    struct in6_addr\tsin6_addr;\t\t//IPv6地址结构体\n    u_int32_t\t\tsin6_scope_id;\t//scope ID,尚处于试验阶段\n};\n```\n\n```c\nstruct in6_addr\n{\n    unsigned char sa_addr[16];\t    //IP地址，16字节 网络字节序\n};\n```\n# IP地址字符串转换为整数\n\n人们习惯用点分十进制字符串表示IPv4地址，编程中我们需要把这个字符串转化为整数，才能填入地址结构体。\n\n```c\n#include<arpa/inet.h>\nin_addr_t inet_addr(const char* cp); //字符串表示的IPv4地址转化为网络字节序\nint inet_aton(const char* cp, struct in_addr* inp);// 与inet_addr功能相同，但是转化结果是存到了inp中 成功返回1失败返回0\n\nchar* inet_ntoa(struct in_addr in);\t //net to ASCII, IPv4地址的网络字节序转化为字符串表示\n```\n需要注意的是，`inet_ntoa`函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此`inet_ntoa`是不可重入的。\n```c\nchar* szValuel = inet_ntoa(\"1.2.3.4\");\nchar* szValue2 = inet_ntoa(\"10.194.71.60\");\nprintf(\"address 1: $s\\n\", szValue1);\nprintf(\"address 2: $s\\n\", szValue2);\n```\n运行这段代码，得到的结果是：\naddress1: 10.194.71.60\naddress2: 10.194.71.60\n因此多次调用该函数后，前面的结果都会失效。\n\n## 推荐使用更新的函数（pton、ntop）\n定义于`<arpa/inet.h>`。这是随IPv6出现的新函数，但同样适用于IPv4。\n```c\n#include<arpa/inet.h>\nint inet_pton(int af, const char* src, void* dst);\nconst char* inet_ntop(int af, const void* src, char* dst, socklen_t cnt);\n```\n`inet_pton`成功时返回1，失败则返回0并设置errno。\n\n`inet_ntop`中的cnt参数指定目标存储单元（字符数组）的大小。下面的宏能帮助我们指定这个大小：\n```c\n#include <netinet/in.h>\n#define INET_ADDRSTRLEN  16\n#define INET6_ADDRSTRLEN 46\n```\n16是：4个3位数+3个点+1个`\\0`\n\n`inet_ntop`成功时返回目标存储单元的地址，失败则返回`NULL`并设置errno。\n# 建立Socket连接API\n\n```c\n#include<sys/types.h>\n#include<sys/socket.h>\nint socket(int domain, int type, int protocol);\nint bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);\nint listen(int sockfd, int backlog);\nint accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);\nint connect(int sockfd, const struct sockaddr* serv_addr, socklen_t addrlen);\nint close(int sockfd);\n```\n## socket()\n```c\nint socket(int domain, int type, int protocol);\n```\n1. `socket()`方法是用来创建一个套接字，有了套接字就可以通过网络进行数据的收发。创建套接字时要**指定使用的服务类型**，比如使用TCP协议选择流式服务`SOCK_STREAM`。\n2. 参数含义：\n    1. 第一个domain表示Socket Address Family，通常是`AF_INET`；\n    2. 第二个参数表示基于的服务类型，通常有基于流式的服务(TCP)和基于数据报的服务(UDP)；\n    3. 第三个参数指明你是基于什么协议。一般填0，表示默认。因为前两个参数的确定即可约束第三个参数是TCP还是UDP了。\n3. Returns `file descriptor` on success, `-1` on error.\n## bind() - 命名socket - 绑定地址\n```c\nint bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);\n```\n1. `bind()`方法用来指定套接字使用的IP地址和端口\n    1. IP地址就是等待被连接的服务器地址。\n    2. 端口是一个16位的整型值。\n        1. `0-1023`为知名端口，在linux上，1024以内的端口号只有root用户可以使用。\n        2. `1024-4095`为预留端口，用户不可随意使用；\n        3. `4096以上`为临时端口，用户按需使用。\n2. sockaddr可以看作是`sockaddr_in`的抽象类型。\n3. return`0` on success, or `-1` on error.\n## listen()\n创建2个监听队列，一个存放未完成连接的客户，一个存放已完成连接的客户。\n```c\nint listen(int sockfd, int backlog);\n```\n1. 将文件描述符`sockfd`引用的流socket标记为被动。这个socket后面会被用来接受其他socket的主动连接。\n2. 用来创建监听队列。监听队列有**两种**，**一个是存放未完成三次握手的连接**，**一种是存放已完成三次握手的连接**。\n3. 第二个参数`backlog`指定系统监听连接的最大容量数目。如果连接数量超过了队列长度，服务器将不再受理新的连接，客户端会收到`ECONNREFUSED`错误消息。\n    1. 在内核版本2.2之前，backlog表示所有半连接（SYN_RCVD）、完全连接（ESTABLISHED）的数量上限。\n    2. 但自2.2之后，它只表示处于完全连接状态的数量上限。处于半连接状态的数量上限则由`/proc/svs/net/ipv4/tcp_max_syn_backlog`定义。\n    3. backlog参数的典型值是5。\n    4. 系统实际上可以监听的连接数目是超过backlog的。\n4. return `0` on success, or `-1` on error.\n5. 无法在一个已连接的socket（已经成功执行`connect()`的或由`accept()`调用返回的socket）再执行`listen()`。\n\n![](../../images/网络_TCP编程流程/image-20250722090234499.png)\n图片源于UNIX网络编程_卷1\n\n### 具体流程\n1. 当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项\n2. 然后响应以三路握手的第二个分节：服务器的SYN+ACK响应。\n3. 这一项一直保留在未完成连接队列中，直到三路握手的第三个分节（客户对服务器SYN的ACK）到达或者该项超时为止。\n4. 如果三路握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。\n5. 当进程调用accept时，已完成连接队列中的队头项将返回给进程，\n    1. 或者如果该队列为空，那么进程将被置于休眠状态，直到TCP在该队列中放入一项才唤醒它。\n## accept()\n```c\nint accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);\n```\n1. `accept()`：从已完成连接队列的队头取出一个连接项。每处理一个连接，则`accept()`返回该连接对应的套接字描述符。如果该队列为空，则accept阻塞。\n2. 它会创建一个新socket，并且正是这个新socket会与执行`connect()`的对等socket进行连接。\n3. 由于accept是通用的API，它不知道对方是什么协议族，因此addr是抽象类型，addrlen也是不确定的，需要传指针。\n4. `accept()`调用返回的函数结果是创建的socket对应的文件描述符。\n5. return `file descriptor` on success, or `-1` on error.\n\n### accept只管取出连接，不管连接状态\n现在考虑如下情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么服务器对这个连接执行的accept调用是否成\n功？\n客户端连接成功后，立即断开该客户端的网络连接（类似于拔掉网线）（服务器还没反应过来客户端断网了）。结果发现accept调用能够正常返回。\n在服务器上运行netstat命令以查看accept返回的连接socket的状态：发现依然是ESTABLISHED。说明，accept调用对于客户端网络断开毫不知情。\n\n如果客户端建立连接后立即退出客户端程序（客户端发出FIN）。这次accept调用同样正常返回。\n服务端netstat命令发现连接状态为`CLOSE_WAIT`。再次说明：accept只是从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化。\n## connect()\n```c\nint connect(int sockfd, const struct sockaddr* serv_addr, socklen_t addrlen);\n```\n1. connect方法将文件描述符`sockfd`引用的主动socket连接到通过addr和addrlen指定地址的监听socket上。\n2. 一般由客户端程序执行，需要指定连接的服务器端的IP地址和端口。该方法执行后，会进行三次握手，建立连接。\n3. return `0` on success, or `-1` on error.\n# 数据收发API\n\n## TCP\n```c\nssize_t recv(int sockfd, void* buff, size_t len, int flags);\nssize_t send(int sockfd, const void* buff, size_t len, int flags);\n```\nrecv返回接收的字节数，如果发生错误则返回 `-1`。如果发生错误，则会设置 `errno` 来指示错误。\n当**流套接字**（如TCP）对等体执行了有序关闭时，返回值为 0（传统的“文件结束”返回）。\n如果请求从**流套接字**接收的字节数为 0，也可能返回 0。\n\nsend如果成功，将返回已发送的字节数。如果失败，则返回 `-1`，并设置相应的 `errno`。\n## UDP\n```c\nssize_t recvfrom(int sockfd, void* buff, size_t len, int flags,\n                 struct sockaddr* src_addr, socklen_t* addrlen);\nssize_t sendto(int sockfd, void* buff, size_t len, int flags,\n               struct sockaddr* dest_addr, socklen_t addrlen);\n```\nrecvfrom返回接收的字节数，如果发生错误则返回 `-1`。如果发生错误，则会设置 `errno` 来指示错误。\n\n不同域（例如 UNIX 和 Internet 域）中的**数据报**套接字（如UDP）允许接收 0 长度数据报。当接收到此类数据报时，返回值为 0。\n\nsendto如果成功，将返回已发送的字节数。如果失败，则返回 `-1`，并设置相应的 `errno`。\n\n# Linux代码 - TCP\n\n```c\nint main()\n{\n/*  int socket(int domain, int type, int protocol);  */\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    assert(sockfd != -1);\n    \n    struct sockaddr_in ser_addr;\n    memset(&ser_addr, 0, sizeof(ser_addr));\n    \n    ser_addr.sin_family = AF_INET;\n    ser_addr.sin_port = htons(6000);\n    ser_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\t//inet_addr(): make string to integer\n    \n/*  int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);  */\n    int res = bind(sockfd, (struct sockaddr*)&ser_addr, sizeof(ser_addr));\n    assert(res != -1);\n    \n/*  int listen(int sockfd, int backlog);  */\n    res = listen(sockfd, 5);\n    assert(res != -1);\n    \n    struct sockaddr_in cli_addr;\n    while(1)\n    {\n/*  int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);  */\n        int len = sizeof(cli_addr);\n        int conn_fd = accept(sockfd, (struct sockaddr*)&cli_addr, &len);\n        if (conn_fd == -1) continue;\n        \n        char buff[128] = {0};\n        int num = recv(conn_fd, buff, 127, 0);\n        printf(\"buff = %s, num = %d\\n\", buff, num);\n        \n        send(conn_fd, \"OK\", 2, 0);\n        \n        close(conn_fd);\n    }\n}\n```\n# 粘包问题\nTCP是流式服务，数据是以流的形式传输的，在网络层这一层面，不应该考虑粘包的问题。\n\n而是应该在TCP传输的数据本身上做文章。\n\n可以这样处理：发送端每send一次，接收端就recv一次，并且要回发一个ok，发送端recv，等待ok到了之后才send下一个数据。但是这样做效率太低了。\n\n可以加标志位以区分数据的完整性。这是简单的做法。比如：7、3、2，处理之后：`[7][3][2]`\n\n更好的做法是：在每个独立的数据前加一个头部，头部中记录数据的长度。如此便可与下一个数据做区分。\n\n## 会引起粘包的客户端代码\n```c\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n\nint main()\n{\n    int error = 0;\n    int client_sock = socket(AF_INET, SOCK_STREAM, 0);\n    // 数据交互\n\n    // 发送消息\n    const char * msg1 = \"hi\";\n    const char * msg2 = \"jack\";\n    error = send(client_sock, msg1, strlen(msg1), 0);\n    if (error < 0)\n    {\n        printf(\"send error\\n\");\n        return -1;\n    }\n    error = send(client_sock, msg2, strlen(msg2), 0);\n    if (error < 0)\n    {\n        printf(\"send error\\n\");\n        return -1;\n    }\n\n    // 接收消息\n\n}\n```\n## 客户端改进\n为每个消息包一个包裹，前面4个字节存放消息的大小。\n使用memmove实现字节移动。（实际就是把消息填入到4字节后的位置）\n```c\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n\nint main()\n{\n    int error = 0;\n    int client_sock = socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &(server_addr.sin_addr.s_addr));\n\n    connect(client_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));\n\n    // 数据交互\n\n    // 发送消息\n    const char * msg1 = \"hi\";\n    const char * msg2 = \"jack\";\n    char data1[256] = {0};\n\n    // 在data1的低地址（占用4个字节）填充msg的长度\n    *(int*)(data1) = strlen(msg1);\n    int headLen = sizeof(int);\n\n    // 从data1的headLen后面开始，填充msg1的字符串内容\n    memmove(data1 + headLen, msg1, strlen(msg1));\n\n    error = send(client_sock, data1, headLen + strlen(msg1), 0);\n    if (error < 0)\n    {\n        printf(\"send error\\n\");\n        return -1;\n    }\n\n\n    char data2[256] = {0};\n    *(int*)(data2) = strlen(msg2);\n    memmove(data2 + headLen, msg2, strlen(msg2));\n    error = send(client_sock, data2, headLen + strlen(msg2), 0);\n    if (error < 0)\n    {\n        printf(\"send error\\n\");\n        return -1;\n    }\n\n    close(client_sock);\n}\n```\n## 服务端\n主要逻辑在循环上。\n要记录每次读到的长度（readLen），目前未处理的（因为数据不完整）的长度（gotLen）。\n当gotLen大于等于4字节时，前4个字节是字符串长度（msgLen）。\n再去看gotLen减去headLen（int的4字节），是否大于等于msgLen。如果是，则说明数据完整了，可以取出了。\n去除之后，别忘记更新gotLen的值，减去这次已经处理了的headLen和msgLen。\n容易遗忘的是，需要把buff中，把本次处理了的headLen、msgLen之后的数据前移覆盖。仍用memmove。\n第一层循环，是读到buff，有字节就读。除非返回`-1`。\n第二层循环，是看是否够4个字节，不够就退出第二层循环。\n```c\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\n\nint main()\n{\n    int error = 0;\n    int server_sock = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8888);\n    inet_pton(AF_INET, \"127.0.0.1\", &(server_addr.sin_addr.s_addr));\n    bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    listen(server_sock, 5);\n\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n    int client_sock = accept(server_sock, (struct sockaddr*)&client_addr, &client_addr_len);\n    // 数据交互\n\n    // 接收消息\n    char buff[1024] = {0};\n    int headLen = sizeof(int);\n    int gotLen = 0;\n    int readLen = 0;\n    while ((readLen = recv(client_sock, buff + gotLen, sizeof(buff) - gotLen, 0)) != -1)\n    {\n        gotLen += readLen;\n        while (gotLen >= headLen)\n        {\n            int msgLen = *(int*)buff;\n            if (gotLen - headLen >= msgLen)\n            {\n                char msgBuff[512] = {0};\n                memmove(msgBuff, buff + headLen, msgLen);\n                printf(\"msgBuff = %s\\n\", msgBuff);\n                int dataLen = headLen + msgLen;\n                memmove(buff, buff + dataLen, gotLen - dataLen);\n                gotLen -= dataLen;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n}\n```\n## 测试\n```\nmrcan@ubuntu:~/networkProgram$ ./tcpserver \nmsgBuff = hi\nmsgBuff = jack\n```\n# Linux代码 - UDP\n## 服务端\n```c\n#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\nint main()\n{\n    int error = 0;\n    int server_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    // addr\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8000);\n    error = inet_pton(AF_INET, \"127.0.0.1\", &(server_addr.sin_addr.s_addr));\n    if (error == -1)\n    {\n        printf(\"inet_pton error!\");\n        exit(1);\n    }\n\n    error = bind(server_socket, (sockaddr*)&server_addr, sizeof(server_addr));\n    if (error == -1)\n    {\n        printf(\"bind error!\");\n        exit(1);\n    }\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n    while (1)\n    {\n        char buff[1024];\n        memset(buff, 0, sizeof(buff));\n        int n = recvfrom(server_socket, buff, sizeof(buff), 0, (sockaddr*)&client_addr, &client_addr_len);\n        if (n == -1)\n        {\n            printf(\"recvfrom error!\");\n            exit(1);\n        }\n        printf(\"buff = %s\\n\", buff);\n        n = sendto(server_socket, \"ok\", 2, 0, (sockaddr*)&client_addr, client_addr_len);\n        if (n == -1)\n        {\n            printf(\"sendto error!\");\n            exit(1);\n        }\n    }\n}\n```\n\n## 客户端\n```c\n#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <string.h>\nint main()\n{\n    int error = 0;\n    int client_socket = socket(AF_INET, SOCK_DGRAM, 0);\n    // addr\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(8000);\n    error = inet_pton(AF_INET, \"127.0.0.1\", &(server_addr.sin_addr.s_addr));\n    if (error == -1)\n    {\n        printf(\"inet_pton error!\");\n        exit(1);\n    }\n\n    socklen_t server_addr_len = sizeof(server_addr);\n    char buff[1024];\n    while (1)\n    {\n        memset(buff, 0, sizeof(buff));\n        fgets(buff, sizeof(buff), stdin);\n        if (strncmp(\"end\", buff, 3) == 0)\n        {\n            break;\n        }\n        int n = sendto(client_socket, buff, strlen(buff) - 1, 0, (sockaddr*)&server_addr, server_addr_len);\n        if (n == -1)\n        {\n            printf(\"sendto error!\");\n            exit(1);\n        }\n        memset(buff, 0, sizeof(buff));\n        n = recvfrom(client_socket, buff, sizeof(buff), 0, (sockaddr*)&server_addr, &server_addr_len);\n        if (n == -1)\n        {\n            printf(\"recvfrom error!\");\n            exit(1);\n        }\n        printf(\"buff = %s\\n\", buff);\n    }\n}\n```\n\n# Windows代码\n## 要引入的库及链接器配置\nWindows下的socket编程需要引入`WinSock2.h`库，还需要预处理链接`#pragma comment(lib, \"Ws2_32.lib\")`。\n`#pragma comment(lib, \"Ws2_32.lib\")` 是用于指定链接器选项的预处理指令，在Windows平台的`C/C++`编程中比较常见。\n- **作用**: 这条指令告诉编译器在链接阶段要链接 `Ws2_32.lib` 库，这是一个包含 Windows Sockets 2 (Winsock) 函数的库。Winsock 提供了网络编程的 API，允许程序进行网络通信，比如创建套接字、发送和接收数据等。\n    - 通过 `#pragma comment(lib, \"Ws2_32.lib\")`，可以在代码中直接指定要链接的库，这样就不需要在编译或项目设置中手动配置链接器选项。\n        - 手动配置：右键项目名，Properties，左边栏：Linker - Input，右边的Additional Dependencies，点击右边的下拉键，再点其中的`<Edit...>`，之后弹出窗口，可以把要输入的库写在输入框中。\n\n![](../../images/网络_TCP编程流程详解/image-20240827021846342.png)\n- 如果你在代码中使用了网络函数而没有链接到 `Ws2_32.lib`，编译器会报错，提示找不到相关的函数定义。\n## WSAStartup\n在Microsoft Learn搜索WinSock2，可以找到`winsock2.h header`的条目。\n[Winsock2.h header](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/)\n\n编写Windows Socket程序之前，需要WSAStartup初始化。\n[WSAStartup function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsastartup)\n\nWSAStartup 函数启动进程对 Winsock DLL 的使用。（即初始化Winsock的动态链接库）\n别忘了在程序结束前要WSACleanup，表示卸载 Winsock DLL。\n```cpp\n#include <WinSock2.h>\n#include <iostream>\n#include <format>\n#pragma comment (lib, \"Ws2_32\")\nint main()\n{\n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n\n    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = ::WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0) {\n        /* Tell the user that we could not find a usable */\n        /* Winsock DLL.                                  */\n        std::wcout << std::format(L\"WSAStartup failed with error : {}\\n\", err);\n        return 1;\n    }\n    ::WSACleanup();\n    return 0;\n}\n```\n此处使用到了[Cpp_拼接字符串的几种方法（format）](../Cpp/Cpp_拼接字符串的几种方法（format）.md)中的format库的字符串输出方法。\n## 创建套接字\n用到的是[socket function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket)\n![](../../images/网络_TCP编程流程详解/image-20240827065503809.png)\n1. 第一个参数是Address Family，因此简称AF，意为地址族规范。\n    1. 当前支持的值为`AF_INET`或`AF_INET6`，它们是IPv4和ipv6的Internet地址族格式。\n    2. 如果安装了地址族的Windows套接字服务提供程序，则支持地址族的其他选项 (例如，与NetBIOS一起使用的`AF_NETBIOS`)。另外还有苹果的`AF_APPLETALK`，蓝牙的`AF_BTH`。\n    3. 请注意，`AF_` address系列和`PF_` protocol系列常量的值是相同的 (例如，AF_INET和PF_INET)，因此可以使用任一常量。\n2. 第二个参数是套接字的类型规范。\n    1. 有`SOCK_STREAN`（TCP）、`SOCK_DGRAM`（UDP）、`SOCK_RAW`（原始套接字）、`SOCK_RDM`（可靠多播）、`SOCK_SEQPACKET`（伪流数据报套接字）\n3. 第三个参数是协议(protocol)。协议参数的可能选项特定于指定的地址族和套接字类型。\n    1. 如果指定值0，则调用者不希望指定协议，并且服务提供者将选择要使用的协议。\n    2. 当af参数是AF_INET或AF_INET6并且类型是SOCK_RAW时，在IPv6或IPv4分组报头的 protocol 字段中设置为协议指定的值。\n    3. 该协议字段的常见值：`IPPROTO_ICMP`、`IPPROTO_IGMP`、`BTHPROTO_RFCOMM`、`IPPROTO_TCP`、`IPPROTO_UDP`、`IPPROTO_ICMPV6`、`IPPROTO_RM`\n4. 返回值：如果没有发生错误，则socket返回socket的描述符。否则，将返回`INVALID_SOCKET`，并且可以通过调用`WSAGetLastError`来检索特定的错误代码。\n\n```cpp\n#define INVALID_SOCKET  (SOCKET)(~0)  // 0取反，则是全1\n```\n\n```cpp\nint main()\n{\n    // ...\n\n    SOCKET listen_sock = ::socket(AF_INET, SOCK_STREAM, 0);\n    \n    if (listen_sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    \n    // ...\n}\n```\n## sockaddr结构\n重点说一下sockaddr，这是个结构体，包含了：\n1. `sin_family`\n2. `sin_addr`，是sockaddr中的一个联合体，存放IP地址的整型。可以用`inet_addr(\"127.0.0.1\")`将字符串转化为整型来填入`sin_addr.sin_addr`。\n3. `sin_port`，需要用`htons`，主机地址到网络的转换。s表示short，2字节。\n## bind\n[bind function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-bind)\n![](../../images/网络_TCP编程流程详解/image-20240827073919812.png)\n1. 参数1：socket描述符，没有绑定过的。\n2. 参数2：本地地址的sockaddr结构的指针\n3. 参数3：name参数所指向的值的长度 (以字节为单位)。\n4. 返回：如果没有发生错误，返回零。否则，它返回`SOCKET_ERROR`，并且可以通过调用`WSAGetLastError`来检索特定的错误代码。\n\n关于sockaddr结构：[sockaddr结构](#sockaddr结构)\n\n编写时，发现第二个参数`name`不能直接填入`&server_addr`，而是要显式转换为`const sockaddr*`\n```cpp\nint main()\n{\n    // ...\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");\n    server_addr.sin_port = htons(9008);\n    \n    if (SOCKET_ERROR == ::bind(listen_sock,\n            reinterpret_cast<const sockaddr*>(&server_addr),\n            sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    // ...\n}\n```\n### 问题\n报错：\n```\nerror C4996: 'inet_addr': Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings\n```\nVS编译器不建议使用`inet_addr`来转换`点分十进制IP地址字符串`为`网络字节序`。而是使用`<ws2tcpip.h>`库中的`inet_pton`，即字符串转为整数（p代表字符指针，n代表整数）。\n![](../../images/网络_TCP编程流程详解/image-20240828064535457.png)\n1. 参数1，地址族协议\n2. 参数2，要转化的字符串\n3. 参数3，要写入到哪里的地址\n4. 返回值\n    1. 如果没有发生错误，`InetPton`函数将返回值1，并且`pAddrBuf`参数指向的缓冲区包含按网络字节顺序排列的二进制数字IP地址。\n    2. 如果参数指向的字符串不是有效的IPv4点分十进制字符串或有效的IPv6地址字符串，则InetPton函数将返回值0。\n    3. 如果指向的字符串没问题，有其他错误：返回值为-1，可以通过调用`WSAGetLastError`获取扩展错误信息。\n\n```cpp\n// ...\n#include <ws2tcpip.h>\nint main()\n{\n    // ...\n    \n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    //server_addr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");\n    if (1 != ::inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr))\n    {\n        return 1;\n    }\n    server_addr.sin_port = htons(9008);\n    \n    if (SOCKET_ERROR == ::bind(listen_sock,\n            reinterpret_cast<const sockaddr*>(&server_addr),\n            sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    // ...\n}\n```\n## listen\n将套接字置于侦听传入连接的状态，本质上是设置了一个监听连接套接字的队列。\n[listen function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen)\n![](../../images/网络_TCP编程流程详解/image-20240828023630523.png)\n1. 参数1，已经绑定了的，但未连接的socket描述符。\n2. 参数2，等待连接队列的最大长度。一般设置为`SOMAXCONN`。\n3. 返回值，如果没有错误发生，返回0。否则，将返回`SOCKET_ERROR`，并且可以通过调用`WSAGetLastError`来检索特定的错误代码。\n\n```cpp\nint main()\n{\n    // ...\n    if (SOCKET_ERROR == ::listen(listen_sock, SOMAXCONN))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    // ...\n}\n```\n## accept\n从listen的监听队列中选出一个未被连接的，拿出来，产生一个worker socket（连接套接字）。如果监听队列中没有客户端连接，则阻塞，直到有人连接后返回。\n在这个阶段，accept函数会把连接到服务端`listen_sock`上的client的信息填入到参数`sockaddr* client_addr`中。\n\n[accept function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept)\n\n![](../../images/网络_TCP编程流程详解/image-20240828072239856.png)\n1. 参数1，已listen的套接字。但最终连接实际上是与accept返回的套接字进行的。\n2. 参数2，该缓冲区要填入客户端的地址。addr参数的确切格式由从sockaddr结构创建套接字时建立的地址族确定。\n3. 参数3，指向整数的指针，该整数包含addr参数所指向的结构的长度。最好让他指向一个初始化值为`sizeof(sockaddr_in)`的int值。\n    1. 标志为`[in, out]`，意为是一个需要正确输入、可能会输出的项：见返回值中对addrlen的描述。\n    2. addrlen引用的整数最初需要包含addr指向的空间量（即`int addrlen{ sizeof(client_addr) }`）。函数返回时，它将填入返回的地址的实际长度 (以字节为单位)。\n4. 返回值，如果没有发生错误，accept将返回一个SOCKET类型的值，该值是连接套接字的描述符。这个返回值是实际连接的套接字的句柄。\n    1. 否则，将返回`INVALID_SOCKET`的值，并且可以通过调用`WSAGetLastError`来检索特定的错误代码。\n\n```cpp\n// server\nint main()\n{\n    // ...\n    sockaddr_in client_addr;\n    int addrlen{ sizeof(client_addr) };\n    SOCKET work_sock = ::accept(\n        listen_sock,\n        reinterpret_cast<sockaddr*>(&client_addr),\n        &addrlen);\n    if (work_sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    // ...\n}\n```\n## 调试 accept - 通过 Error Lookup 查询原因\n程序已经通过`WSAGetLastError`把错误码填入到了err中。如果某个步骤出现了问题，可以看到err中的具体值。\n这个值是个整数，可以在VS菜单栏-Tools-External Tools中添加`errorlook.exe`程序的快捷方式：\nTitle是自定义的，我们填入Error LookUp。\nCommand填入`C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\Common7\\Tools\\errlook.exe`\nInitial directory填入`C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\Common7\\Tools`\n![](../../images/网络_TCP编程流程详解/image-20240829061511915.png)\n添加完毕后，Tools出来的菜单中就会显示了：\n![](../../images/网络_TCP编程流程详解/image-20240829061633740.png)\n\n如上面的程序，`addrlen`如果初始化为0时，传给accept函数后，就会导致accept错误。（因为accept文档中给出参数说明：addrlen引用的整数最初需要包含addr指向的空间量。此时我们传入0是没有意义的，accept中的操作可能会读取addrlen的内容，导致错误）\n```cpp\n// server\nint main()\n{\n    // ...\n    sockaddr_in client_addr;\n    int addrlen{ 0 };\n    SOCKET work_sock = ::accept(\n        listen_sock,\n        reinterpret_cast<sockaddr*>(&client_addr),\n        &addrlen);\n    if (work_sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    // ...\n}\n```\n最终err码是10014，那么在ErrorLook中查询：\n![](../../images/网络_TCP编程流程详解/image-20240829061728388.png)\n## 客户端\n新建一个空项目，SocketClientStudy，新建文件`basic_stream_client.cpp`。不用设置为启动项目。\n\n客户端程序需要WSA初始化、创建套接字。\n后面直接连接connect，connect的参数和服务器端bind的参数一样：创建`sockaddr_in`并且填入相关信息（协议、IP地址、端口号）。\n[connect function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect)\n![](../../images/网络_TCP编程流程详解/image-20240829063508988.png)\n返回值：如果没有发生错误，返回0。否则返回`SOCKET_ERROR`，并且可以通过调用`WSAGetLastError`来检索特定的错误代码。\n1. 阻塞套接字，返回值指示连接尝试的成功或失败。\n2. 非阻塞套接字，连接尝试无法立即完成。在这种情况下，connect将返回`SOCKET_ERROR`，`WSAGetLastError`将返回`WSAEWOULDBLOCK`。\n\n```cpp\n#include <WinSock2.h>\n#include <iostream>\n#include <format>\n#include <ws2tcpip.h>\n#pragma comment (lib, \"Ws2_32\")\nint main()\n{\n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n\n    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = ::WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0) {\n        /* Tell the user that we could not find a usable */\n        /* Winsock DLL.                                  */\n        std::wcout << std::format(L\"WSAStartup failed with error : {}\\n\", err);\n        return 1;\n    }\n\n    SOCKET sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    //service.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");\n    if (1 != ::inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    server_addr.sin_port = htons(9008);\n    \n    if (SOCKET_ERROR == ::connect(sock, reinterpret_cast<const sockaddr*>(&server_addr), sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    ::WSACleanup();\n    return 0;\n}\n```\n## 联调1\n单独Build客户端项目：右击客户端项目名-Project Only-Build Only ...\n![](../../images/网络_TCP编程流程详解/image-20240829070708525.png)\n若Build成功，则可以启动Server项目了。Server项目直接点击VS全局下的调试即可（快捷键F5）。\n启动Server之后，若成功地阻塞在accept，则可以单独启动客户端项目了：右击客户端项目-Debug-Start New Instance\n![](../../images/网络_TCP编程流程详解/image-20240829070915611.png)\n之后，可以很轻松地在此两个项目中流转、单步调试。\n## 服务端-显示连接的客户端信息\n想要显示连接的客户端的IP地址和端口号。\n[InetNtopW function (ws2tcpip.h)](https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetntopw)\n\n对于IP地址，在编写服务端的bind、客户端的connect时，声明`sockaddr_in`时，都需要使用`inet_pton`来填入`sin_addr`。这是让IP地址字符串转换为整数值填入联合体。\n而我们想要从`sockaddr_in`获得字符串形式的IP地址时，需要用`inet_ntop`，注意，不能直接读取`sockaddr_in`，而是`sockaddr_in.sin_addr`。详见[sockaddr结构](#sockaddr结构)\n对于端口号，对于网络程序来说，需要使用`htons`使主机字节序转为网络字节序（类似于IP地址从字符串转换为计算机程序可理解的整型值），填入`sin_port`。而对于人类的可读性来讲，需要从网络字节序转为主机字节序（类似于IP地址从整数值转换为人类可理解的字符串），需要：`ntohs`。\n>`inet_pton`和`inet_ntop`都是ANSI版本的。\n>`InetNtopW`是Unicode版本的。参数除了`pStringBuf`的类型为PWSTR不一样，其他一样。见[InetNtopW function (ws2tcpip.h)](https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetntopw)\n>\n>`htons`：h代表host，to意为转换，n为net，s为short（2字节）。还有`htonl`，为long int（4字节）。\n\n![](../../images/网络_TCP编程流程详解/image-20240829221004234.png)\n\n```cpp\nint main()\n{\n    // ...\n    wchar_t addr_str[46] = L\"\";\n    InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n    std::wcout << std::format(L\"client address: {}, port: {}\\n\", addr_str, ntohs(client_addr.sin_port));\n    // ...\n}\n```\n## 服务端-发送消息\n[send function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send)\n\n建立好socket通道后，可以直接在此socket上send，recv。\n![](../../images/网络_TCP编程流程详解/image-20240830004003760.png)\n1. 参数1，已连接的socket\n2. 参数2，要发送的数据的指针\n3. 参数3，要发送的数据的大小（字节数）\n4. 参数4，指定调用方式的标志，可以按位OR。如无特殊需要，填0即可。\n5. 返回值，如果没有发生错误，将返回已发送的总字节数，该字节数可以小于len参数中请求发送的字节数。若错误，将返回`SOCKET_ERROR`，并且可以通过调用`WSAGetLastError`来检索特定的错误代码。\n\n| Value         | Meaning                                                                                                                                                               |\n| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| MSG_DONTROUTE | Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.<br>指定数据不应进行路由。Windows套接字服务提供程序可以选择忽略此标志。 |\n| MSG_OOB       | Sends OOB data (stream-style socket such as SOCK_STREAM only).<br>发送OOB数据 (仅流式套接字，如SOCK_STREAM)                                                                       |\n要注意，由于我们想要发送的是一个Unicode字符串，而参数`buf`的类型是`const char *`。\n首先，不能以wstring对象的单位发送，应当发送其中的内容`message.c_str()`。\n其次，`message.c_str()`返回类型为`const wchar_t *`，而TCP的send是要按字节流进行发送的，所以要显式转换指针为`const char*`，这里的`char*`和字符没有关系，而是表示按字节。\n```cpp\nint main()\n{\n    // ...\n    std::wstring message{ L\"Welcome to server!\" };\n    ::send(\n        work_sock,\n        reinterpret_cast<const char*>(message.c_str()),\n        sizeof(wchar_t) * message.size(),\n        0);\n    // ...\n}\n```\n### send的阻塞问题\n如果传输系统内没有可用的缓冲区空间来保存要传输的数据，如果套接字不是非阻塞模式，send将阻塞。\n在面向流的非阻塞套接字上，写入的字节数可以介于1和请求长度之间，具体取决于客户端和服务器计算机上的缓冲区可用性。\n## 服务端-接收消息\n[recv function (winsock2.h)](https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-recv)\n\n![](../../images/网络_TCP编程流程详解/image-20240830044512192.png)\n1. 参数1，已连接的socket\n2. 参数2，要接收数据的buf指针\n3. 参数3，buf的字节大小\n4. 参数4，影响此函数行为的标志\n5. 返回值，如果没有发生错误，recv返回接收到的字节数，buf参数指向的缓冲区将填入接收到的数据。\n    1. 如果套接字是面向连接的，并且远程端已正常关闭连接，则recv将立即返回0，接收到0字节。\n    2. 如果是异常断开，将返回`SOCKET_ERROR`的值，并且可以通过调用`WSAGetLastError`来检索特定的错误代码。\n        1. 如果连接已重置，错误为`WSAECONNRESET`。\n\n```cpp\nint main()\n{\n    // ...\n    wchar_t buf[100] = { 0 };\n    int bytes_received = ::recv(work_sock, reinterpret_cast<char*>(buf), sizeof(wchar_t) * sizeof(buf), 0);\n    if (bytes_received > 0)\n    {\n        std::wcout << buf << std::endl;\n    }\n    // ...\n}\n```\n### recv的阻塞问题\n如果套接字上没有可用的传入数据，则recv调用将根据为阻塞并等待数据到达。\n如果套接字是非阻塞的。将返回`SOCKET_ERROR`，并将错误代码设置为`WSAEWOULDBLOCK`。\n## 客户端-接收消息\n\n```cpp\nint main()\n{\n    // ...\n    wchar_t buf[100] = { 0 };\n    int bytes_received = ::recv(\n        sock,\n        reinterpret_cast<char*>(buf),\n        sizeof(wchar_t) * sizeof(buf),\n        0);\n    if (bytes_received > 0)\n    {\n        std::wcout << buf << std::endl;\n    }\n    // ...\n}\n```\n\n## 客户端-发送消息\n可以使用`std::wcin`作为Unicode标准输入到buf。\nbuf中的内容会被覆盖。（但是用wcin作为输入有个缺陷，就是如果句子中间被空格断开了的话，只能填入buf空格之前的字符）\n注意，buf的类型是`wchar_t buf[100]`，是C风格的wchar数组，因此在计算有效长度len时（即不包含第一个`\\0`），需要使用`wcslen(buf)`。如果要计算有效长度的字节大小，还需要乘以`sizeof(wchar_t)`。\n```cpp\nint main()\n{\n    // ...\n    std::wcout << L\"Please input what you want to send to server: \";\n    std::wcin >> buf;\n    int bytes_sent = ::send(\n        sock,\n        reinterpret_cast<const char*>(buf),\n        sizeof(wchar_t) * wcslen(buf),\n        0);\n    // ...\n}\n```\n## 客户端-收尾工作\n类似于指针管理，先释放资源，再把描述符置为无效。\n```cpp\nint main()\n{\n    // ...\n    ::closesocket(sock);\n    sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n    return 0;\n}\n```\n## 服务端-收尾工作\n类似于指针管理，先释放资源，再把描述符置为无效。\n```cpp\nint main()\n{\n    // ...\n    ::closesocket(work_sock);\n    work_sock = INVALID_SOCKET;\n\n    ::closesocket(listen_sock);\n    listen_sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n}\n```\n## 联调2\n分别运行、调试两端程序的方法同[联调1](#联调1)。\n测试结果：\n![](../../images/网络_TCP编程流程详解/image-20240830061031808.png)\n\n![](../../images/网络_TCP编程流程详解/image-20240830061150520.png)\n## 【可选】客户端-bind\n见[客户端的bind](#客户端的bind)。\n需要在connect到server之前进行客户端的bind。需要声明一个本地的`sockaddr_in`，填入自己的协议、地址、端口号。\n```cpp\nint main()\n{\n    // create socket...\n    sockaddr_in local;\n    local.sin_family = AF_INET;\n    if (1 != inet_pton(AF_INET, \"127.0.0.1\", &local.sin_addr))\n    {\n        return 1;\n    }\n    local.sin_port = htons(10000);\n    \n    if (SOCKET_ERROR == ::bind(sock, reinterpret_cast<const sockaddr*>(&local), sizeof(local)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    \n    // connect ...\n    \n    // ...\n}\n```\n测试：\n![](../../images/网络_TCP编程流程/image-20240830063739465.png)\n发现，客户端的端口号确实改成了我们自定义的10000。\n## 服务端-循环多次accept\n在accept到send、recv直到`closesocket(work_sock)`外面包一个while循环即可。\n```cpp\n// server\nint main()\n{\n    // ...\n    while (true)\n    {\n        // accept ...\n        // send ...\n        // recv ...\n        ::closesocket(work_sock);\n        work_sock = INVALID_SOCKET;\n    }\n    \n    ::closesocket(listen_sock);\n    listen_sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n}\n```\n但要注意，如果想要在一个主机上运行多个客户端，则客户端不能自定义为固定的端口号。即不能主动bind。\n经测试，可以运行2个客户端，排队连接：\n![](../../images/网络_TCP编程流程/image-20240830064811774.png)\n## 服务端-修改监听队列大小\n如果修改服务端监听队列大小为1，会产生什么影响？\n```cpp\n// server\nint main()\n{\n    // ...\n    if (SOCKET_ERROR == ::listen(listen_sock, 1))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    // ...\n}\n```\n经测试，发现启动前2个客户端的connect正常：\n1. 第1个客户端在第2个客户端启动之前，connect很快返回。此时第1个客户端还没输入消息，占用了连接。\n2. 第2个客户端在监听队列中等待第1个客户端结束。因此connect阻塞。\n\n但第3个客户端启动后，发现监听队列满了，因此会connect失败，立即返回`SOCKET_ERROR`。\n## 服务端-循环+多线程accept\n使用`jthread`+`lambda表达式`封装每一个客户端被服务端accept后，服务端的操作。注意构造完毕jthread后需要detach，否则默认会join，导致主线程等待子线程结束从而无法处理其他网络事务。\n还有，由于使用到了`client_addr`和`work_sock`，需要在lambda表达式的`[]`中进行捕获。\n在lambda表达式中，如果要修改某些值（此例中要修改`client_addr`和`addr_str`），默认是不允许的，如果要修改，需要修饰其为`mutable`。\n```cpp\n// server\nint main()\n{\n    // WSAStartup\n    // Create Socket\n    // bind\n    // listen\n    while (true)\n    {\n        // accept ...\n        std::jthread t([client_addr, work_sock]() mutable\n            {\n                wchar_t addr_str[46] = L\"\";\n                InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n                std::wcout << std::format(L\"client address: {}, port: {}\\n\", addr_str, ntohs(client_addr.sin_port));\n                // send ...\n                // recv ...\n                ::closesocket(work_sock);\n                work_sock = INVALID_SOCKET;\n            });\n        t.detach();\n    }\n    \n    ::closesocket(listen_sock);\n    listen_sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n    return 0;\n}\n```\n### 更多测试：客户端bind固定端口，开启多个客户端\n客户端bind固定端口10000，开启多个客户端。\n在开启第2个客户端时，bind函数会失败，立即返回`SOCKET_ERROR`。\n此时关闭所有客户端。\n短时间内，再重新启动一个客户端，绑定的还是10000。还是会失败，此时bind成功，但connect是失败的。bind成功是因为目前10000端口只有一个客户端占用。connect失败是因为这个端口不久前刚被使用过，还没有完全失效。这与四次握手释放的时间有关系，默认在2分钟内相同的端口号不可重用。\n我们可以通过`WSAGetLastError()`获得错误码+Error Lookup查询详细的connect失败描述：\n经调试，connect失败时的错误码为10048。\n```cpp\n// client\n{\n    // ...\n    if (SOCKET_ERROR == ::connect(sock, reinterpret_cast<const sockaddr*>(&server_addr), sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    // ...\n}\n```\n![](../../images/网络_TCP编程流程/image-20240910022156675.png)\n一个socket五元组地址只能用一次。\n>五元组的组成：协议、网络地址、端口号。\n>协议：客户端、服务端是一致的。共1个。\n>网络地址：客户端、服务端各有一个。共2个。\n>端口号：客户端、服务端各有一个。共2个。\n>因此称为五元组。\n\n由于客户端中刚使用过的10000端口还未完全失效，因此无法很快地重用。\n## 结合协程\n在VS中，同一解决方案，多个项目：一个是服务器项目，一个是客户端项目，还有现在要提到的协程项目。为了使用协程，在解决方案中引入协程项目后，还需要在使用到它的项目中（如服务器项目）添加现有项（Add Existing Item），在Header Files中添加`.hpp`、`.h`文件，在Source Files中添加`.cpp`文件。然后，在代码文件中`#include \"../Coroutines/Agave.hpp\"`引入相应头文件以使用库。（在VS中，项目的当前目录都是以`.vcxproj`为基准的）\n\n用协程函数封装上面lambda表达式中做的事情。\n```cpp\n// server\n// ...\n#include \"../Coroutines-STD20/Agave.hpp\"\n// Fore Declaration\nagave::IAsyncAction worker_async(sockaddr_in client_addr, SOCKET work_sock);\nint main(void)\n{\n    // WSAStartup\n    // create socket\n    // bind\n    // listen\n    \n    while (true)\n    {\n        // ... accept\n        worker_async(client_addr, work_sock);\n    }\n    ::closesocket(listen_sock);\n    listen_sock = INVALID_SOCKET;\n    ::WSACleanup();\n    return 0;\n}\n\nagave::IAsyncAction worker_async(sockaddr_in client_addr, SOCKET work_sock)\n{\n    // let this function run on the child thread instead of the main thread.\n    co_await agave::resume_background();\n    \n    wchar_t addr_str[46] = L\"\";\n    InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n    std::wcout << std::format(L\"client address: {}, port: {}\\n\", addr_str, ntohs(client_addr.sin_port));\n    // send ...\n    // recv ...\n    ::closesocket(work_sock);\n    work_sock = INVALID_SOCKET;\n}\n```\n## 结合线程池\n线程池的设计、代码见[线程池_bubo](../项目/线程池_bubo.md)\n\n新建项目`StreamServer`，新建源文件`stream_server_threadpool.cpp`。文件内容先拷贝`basic_stream_server.cpp`的，之后再作调整。\n\n该项目引入头文件（Add Existing Item）：\n1. 线程池部分：`ITask.h`、`ThreadPool.h`\n2. 协程部分：`Agave.hpp`、`AgaveDetails.hpp`、`B_Object.hpp`、`BJobScheduler.h`\n\n引入源文件（Add Existing Item）：\n1. 线程池部分：`ThreadPool.cpp`\n2. 协程部分：`BJobScheduler.cpp`。\n\n记得调整项目的`C++`标准为`C++20`。\n### Task\n新建`network_task.h`。\n需要设计什么？\n1. 必须实现ITask的接口`run_task`。\n2. 根据`basic_stream_server.cpp`中的`worker_async(sockaddr_in client_addr, SOCKET work_sock)`接口，服务器要生成一个网络任务需要传入`client_addr`和`work_sock`（服务端`accept`后返回的sock）。因此`network_task`构造函数需要有这两个作为参数，以及需要有成员变量存储这两个。\n\n```cpp\n#include \"../ThreadPool/ITask.h\"\n#include <WinSock2.h>\nclass NetworkTask : public thpool::ITask\n{\npublic:\n\tNetworkTask(sockaddr_in client_addr, SOCKET work_sock);\n\t~NetworkTask();\n\tvoid run_task() override;\nprivate:\n\tsockaddr_in\t\t\t\t_client_addr;\n\tSOCKET\t\t\t\t\t_work_sock;\n};\n```\n\n实现：\n主要实现`run_task`，代码内容是：\n1. 服务端-显示连接的客户端信息\n2. 服务端-发送消息、接收消息\n3. 服务端-收尾工作\n\n```cpp\n// stream_server_threadpool.cpp\n#include \"network_task.h\"\n#include <iostream>\n#include <WS2tcpip.h>\n#include <format>\n\nNetworkTask::NetworkTask(sockaddr_in client_addr, SOCKET work_sock) : _client_addr{ client_addr }, _work_sock{ work_sock }\n{\n}\n\nNetworkTask::~NetworkTask()\n{\n}\n\nvoid NetworkTask::run_task()\n{\n    wchar_t addr_str[46] = L\"\";\n    InetNtopW(AF_INET, reinterpret_cast<void*>(&_client_addr.sin_addr), addr_str, 46);\n    std::wcout << std::format(L\"client address: {}, port: {}\\n\", addr_str, ntohs(_client_addr.sin_port));\n    // send ...\n    std::wstring message{ L\"Welcome to server!\" };\n    ::send(\n        _work_sock,\n        reinterpret_cast<const char*>(message.c_str()),\n        sizeof(wchar_t) * message.size(),\n        0);\n    // recv ...\n    wchar_t buf[100] = { 0 };\n    int bytes_received = ::recv(_work_sock, reinterpret_cast<char*>(buf), sizeof(wchar_t) * sizeof(buf), 0);\n    if (bytes_received > 0)\n    {\n        std::wcout << buf << std::endl;\n    }\n    ::closesocket(_work_sock);\n    _work_sock = INVALID_SOCKET;\n}\n```\n### 调用线程池\n原先`basic_stream_server.cpp`中获得`work_sock`之后，可以调整其后的行为，让其调用协程（实际是用协程函数封装了后续收发行为）。那么此处，可以更改为调用线程池。\n```cpp\n#include <WinSock2.h>\n#include <iostream>\n#include <format>\n#include <ws2tcpip.h>\n#include \"network_task.h\"                // add\n#include \"../ThreadPool/ThreadPool.h\"    // add\n#pragma comment (lib, \"Ws2_32\")\nint main()\n{\n    thpool::ThreadPool threadpool{ 10 }; // add\n    \n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n\n    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = ::WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0) {\n        /* Tell the user that we could not find a usable */\n        /* Winsock DLL.                                  */\n        std::wcout << std::format(L\"WSAStartup failed with error : {}\\n\", err);\n        return 1;\n    }\n\n    SOCKET listen_sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (listen_sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    //service.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");\n    if (1 != ::inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    server_addr.sin_port = htons(9008);\n\n    if (SOCKET_ERROR == ::bind(listen_sock,\n        reinterpret_cast<const sockaddr*>(&server_addr),\n        sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    if (SOCKET_ERROR == ::listen(listen_sock, SOMAXCONN))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    while (true)\n    {\n        sockaddr_in client_addr;\n        int addrlen{ sizeof(client_addr) };\n        SOCKET work_sock = ::accept(\n            listen_sock,\n            reinterpret_cast<sockaddr*>(&client_addr),\n            &addrlen);\n        if (work_sock == INVALID_SOCKET)\n        {\n            err = ::WSAGetLastError();\n            return 1;\n        }\n\n        // adjust: 调用线程池\n        threadpool.add_task(std::shared_ptr<thpool::ITask>(new NetworkTask{ client_addr, work_sock }));\n    }\n\n    ::closesocket(listen_sock);\n    listen_sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n    return 0;\n}\n```\n#### 测试\n运行1个服务端、3个客户端。\n![](../../images/网络_TCP编程流程/image-20240927061849838.png)\n3个客户端分别输入`ThisIs1/2/3`\n![](../../images/网络_TCP编程流程/image-20240927061953070.png)\n### 调用线程池同时使用协程\n新建源文件`stream_server_threadpool_coroutine.cpp`，内容暂时拷贝`stream_server_threadpool.cpp`。\n新建头文件`coroutine_task.hpp`。与`network_task.hpp`不同，其需要一个function。\n协程和任务之间用function来作为媒介，可以把fn看作是协程函数`agave::IAsyncAction worker_async`，传入给CoroutineTask。\n```cpp\n#include \"../ThreadPool/ITask.h\"\n#include <WinSock2.h>\n#include <functional>\nclass CoroutineTask : public thpool::ITask\n{\npublic:\n\tCoroutineTask(std::function<void(void)> cb) : _cb{ cb }\n\t{\n\n\t}\n\tvoid run_task() override\n\t{\n\t\tif (_cb)\n\t\t{\n\t\t\t_cb();\n\t\t}\n\t}\nprivate:\n\tstd::function<void(void)>\t\t_cb;\n};\n```\n调用线程池同时使用协程时，我们是设置协程的背景，绑定一个线程池。\n即在建立线程池后给出如下的`set_bg_entry`，达到的效果是：每当协程函数调用`co_await agave::resume_background()`时，都会从背景绑定的线程池中抽取线程资源执行协程函数。\n具体的：在`set_bg_entry`中填入一个lambda表达式，捕获创建好的线程池，在该线程池中添加任务`add_task`，即创建一个`CoroutineTask`，使用`fn`作为参数。\n```cpp\n// stream_server_threadpool_coroutine.cpp\n#include <WinSock2.h>\n#include <iostream>\n#include <format>\n#include <ws2tcpip.h>\n#include \"network_task.h\"\n#include \"../ThreadPool/ThreadPool.h\"\n#include \"../Coroutines/Agave.hpp\"\n#include \"coroutine_task.hpp\"\n#pragma comment (lib, \"Ws2_32\")\nagave::IAsyncAction worker_async(sockaddr_in client_addr, SOCKET work_sock);\n\nint main()\n{\n    thpool::ThreadPool threadpool{ 10 };\n    agave::set_bg_entry(\n        [&threadpool](std::function<void(void)> fn)\n            {\n                threadpool.add_task(std::shared_ptr<thpool::ITask>(new CoroutineTask{ fn }));\n            }\n        );\n    \n    WORD wVersionRequested;\n    WSADATA wsaData;\n    int err;\n\n    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */\n    wVersionRequested = MAKEWORD(2, 2);\n\n    err = ::WSAStartup(wVersionRequested, &wsaData);\n    if (err != 0) {\n        /* Tell the user that we could not find a usable */\n        /* Winsock DLL.                                  */\n        std::wcout << std::format(L\"WSAStartup failed with error : {}\\n\", err);\n        return 1;\n    }\n\n    SOCKET listen_sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (listen_sock == INVALID_SOCKET)\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    //service.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");\n    if (1 != ::inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n    server_addr.sin_port = htons(9008);\n\n    if (SOCKET_ERROR == ::bind(listen_sock,\n        reinterpret_cast<const sockaddr*>(&server_addr),\n        sizeof(server_addr)))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    if (SOCKET_ERROR == ::listen(listen_sock, SOMAXCONN))\n    {\n        err = ::WSAGetLastError();\n        return 1;\n    }\n\n    while (true)\n    {\n        sockaddr_in client_addr;\n        int addrlen{ sizeof(client_addr) };\n        SOCKET work_sock = ::accept(\n            listen_sock,\n            reinterpret_cast<sockaddr*>(&client_addr),\n            &addrlen);\n        if (work_sock == INVALID_SOCKET)\n        {\n            err = ::WSAGetLastError();\n            return 1;\n        }\n\n        worker_async(client_addr, work_sock);\n    }\n\n    ::closesocket(listen_sock);\n    listen_sock = INVALID_SOCKET;\n\n    ::WSACleanup();\n    return 0;\n}\n\nagave::IAsyncAction worker_async(sockaddr_in client_addr, SOCKET work_sock)\n{\n    // let this function run on the child thread instead of the main thread.\n    co_await agave::resume_background();\n\n    wchar_t addr_str[46] = L\"\";\n    InetNtopW(AF_INET, reinterpret_cast<void*>(&client_addr.sin_addr), addr_str, 46);\n    std::wcout << std::format(L\"client address: {}, port: {}\\n\", addr_str, ntohs(client_addr.sin_port));\n    // send ...\n    std::wstring message{ L\"Welcome to server!\" };\n    ::send(\n        work_sock,\n        reinterpret_cast<const char*>(message.c_str()),\n        sizeof(wchar_t) * message.size(),\n        0);\n    // recv ...\n    wchar_t buf[100] = { 0 };\n    int bytes_received = ::recv(work_sock, reinterpret_cast<char*>(buf), sizeof(wchar_t) * sizeof(buf), 0);\n    if (bytes_received > 0)\n    {\n        std::wcout << buf << std::endl;\n    }\n    ::closesocket(work_sock);\n    work_sock = INVALID_SOCKET;\n}\n```\n#### 测试\n![](../../images/网络_TCP编程流程/image-20240927065028838.png)\n","categories":["Linux","网络","Windows"]},{"title":"Linux_切换源","url":"/Linux/Linux_切换源/","content":"# 切换源\n\n```bash\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak #备份原来的列表\nsudo vim /etc/apt/sources.list #修改源\n# 将文件内容替换成源文件内容\ndeb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n# 保存\nsudo apt-get update #更新列表\n```\n","categories":["Linux"]},{"title":"Linux_配置VSCode","url":"/Linux/Linux_配置VSCode/","content":"# 如何在vscode下配置链接库(.so)\n\n* 配置头文件的搜索路径\n* 配置库文件的搜索路径\n* 配置需要链接的.so库\n\n按快捷键F1可把vscode的配置对话框打开，进行检索，我们对cpp文件的编译链接进行配置，输入Edit，找C/C++的条目。\n\n![image-20220318152213890](../../images/Linux_各种配置/image-20220318152213890.png)\n\n![image-20220318152333543](../../images/Linux_各种配置/image-20220318152333543.png)\n\n此处的json文件就是cpp文件编译的配置文件。\n\n![image-20220318152417135](../../images/Linux_各种配置/image-20220318152417135.png)\n\n```bash\n配置要点：\n\tg++ -I头文件搜索路径 -L库文件搜索路径 -l库的名称\n\tincludePath可以自定义添加文件的搜索路径\t# usr/(local/)include不用加，是全系统通用的\n\tcppstandard - 如: \"cppStandard\" : \"c++11\"\n\t\n```\n\n`Ctrl + shift + B`：是对build相关的配置，选择C/C++条目后面的齿轮。点进去发现是一个`task.json`。\n\n![image-20220318153301574](../../images/Linux_各种配置/image-20220318153301574.png)\n\n![image-20220318153413837](../../images/Linux_各种配置/image-20220318153413837.png)\n\n```bash\n配置要点：\n\t\"command\"是选择哪个路径下的C++编译器\n\t\"args\"是编译链接指令后面所带的可加参数的配置信息\n\t\t可在最后一行后面加自己相加的参数\n\t\t比如: \"${...}\",\n\t\t\t \"-lmuduo_net\",\n\t\t\t \"-lmuduo_base\",\n\t\t\t \"-lpthread\"\n```\n\n除了`c_cpp_properties.json`、`tasks.json`还有个`launch.json`配置文件，是关于调试、运行的。\n","categories":["Linux"]},{"title":"高级数据结构_红黑树","url":"/高级数据结构/高级数据结构_红黑树/","content":"# 内容\n\n1. 红黑树\n\n# 红黑树\n\n在计算机科学中，红黑树是一种自平衡二叉搜索树。典型用途是实现[关联数组](https://zh.wikipedia.org/wiki/关联数组)(即map)。红黑树是从 4 阶 B 树（即2-3-4树）衍生出来的形式。\n\n>以下内容来自wiki：https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\n>1972年，[鲁道夫·拜耳](https://en.wikipedia.org/wiki/Rudolf_Bayer)发明了一种[B 树](https://en.wikipedia.org/wiki/B-tree \"B-tree\")的特殊 4 阶形式。这个 4 阶 B 树维护从根到叶的所有路径，节点数相同，从而创建完美平衡的树（然而，并不是[二叉搜索树](https://zh.wikipedia.org/wiki/二元搜尋樹)）。拜尔在他的论文中称呼他们为“**对称二叉 B 树**”（symmetric binary B-tree），后来这种 4 阶 B 树被称为[2-3-4 树](https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree \"2–3–4 tree\")。\n>\n>在 1978 年的论文《A Dichromatic Framework for Balanced Trees》中，[Leonidas J. Guibas](https://en.wikipedia.org/wiki/Leonidas_J._Guibas \"Leonidas J. Guibas\")和[Robert Sedgewick](https://en.wikipedia.org/wiki/Robert_Sedgewick_\\(computer_scientist\\) \"Robert Sedgewick (computer scientist)\")从 2-3-4 树中衍生出了红黑树。\n>\n>之所以选择“红色”是因为它是作者在Xerox PARC工作时可用的彩色激光打印机打印出的最好看的颜色。Guibas 的另一个回应是，这是因为他们可以使用红色和黑色的笔来画树。\n>\n>1993 年，Arne Andersson 提出右倾树的概念，以简化插入和删除操作。\n>1999 年， [Chris Okasaki](https://en.wikipedia.org/wiki/Chris_Okasaki \"Chris Okasaki\")展示了如何使插入操作纯粹函数化（purely functional）。其平衡函数只需要处理 4 种不平衡情况和 1 种默认平​​衡情况。\n>原始算法需要处理 8 种不平衡情况，但 2001 年，[Cormen 等人](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#CITEREFCormenLeisersonRivestStein2001)将其简化为 6 种不平衡情况。Sedgewick 通过实践证明，插入操作仅需46行Java代码即可实现。\n>2008 年，Sedgewick 基于 Arne Andersson 简化插入和删除操作的理念，提出了[左倾红黑树](https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree \"Left-leaning red–black tree\")。该结构初期允许节点拥有两个红色子节点（更接近2-3-4树特性），后期通过增加节点限制使其更贴近2-3树结构。改进后，Sedgewick将插入算法的代码量从46行精减至33行，显著提升了代码效率。\n\n每个节点存储一个表示“颜色”（“红色”或“黑色”）的额外位，用于确保树在插入和删除期间保持平衡。\n\n当树被修改时，新树被重新排列并“重新绘制”以恢复限制树在最坏情况下可能变得多么不平衡的着色属性。这些属性被设计成可以有效地执行这种重新排列和重新着色。\n\n重新平衡并不完美，但保证在$O(\\log n)$时间内搜索，其中$n$是条目数。插入和删除操作以及树的重新排列和重新着色也在$O(\\log n)$时间内执行。\n\n跟踪每个节点的颜色只需要每个节点的一位信息，因为只有两种颜色。该树不包含任何其他特定于它是红黑树的数据，因此它的内存占用几乎与经典（未着色）二叉搜索树的内存占用相同。在许多情况下，无需额外的内存成本即可存储额外的信息位。\n\n## 红黑树与AVL的对比\n\n实际上树节点的结构与AVL一模一样, 只是balance的状态值只有两个, 然后又在这个基础上, 对其进行了一些限制; \n\n这样的好处就是, 对于红黑树的插入/删除操作, 在编写代码时, 只需考虑其两种状态即可, 这有利于开发实践; 而AVL需要考虑三种状态, 对于开发代码来说难度加大, 并且AVL树过于理想化, 导致旋转操作过多, 反而会影响性能; \n\nAVL树本来想解决什么问题呢? 是为了防止不加限制的二叉搜索树在持续插入一些极端的值(依次插入有序的数)后, 搜索树的结构退化为了一个长度为n的链表, 因此查找性能也会退化; \n\n但是, 对二叉搜索树的极度限制, 使其保持一个理想化的平衡又显得矫枉过正, 虽然插入数据时不用做过多的旋转(最多做2次旋转操作), 但是删除操作的时候, 可能会涉及到一长串的旋转处理($\\log n$次), 这也会导致性能的退化; \n\n于是, 红黑树的性质就像是同时克服了两者的缺点, 但是在高度平衡上, 做出了一些妥协, 但是这也是无伤大雅的, 红黑树节点的左右子树高度差, 长的长度不超过短的长度的2倍; \n\n| 操作               | AVL的时间复杂度 | 红黑树的时间复杂度 |\n| ------------------ | --------------- | ------------------ |\n| 增删查             | $O(\\log n)$     | $O(\\log n)$        |\n| Insert最多旋转次数 | 2               | 2                  |\n| remove最多旋转次数 | $O(\\log n)$     | 3                  |\n\n根据上表, 可以得出, 如果操作涉及到查询/插入较多, 优先选择AVL树, AVL是绝对平衡的树, 查询效率不会低于红黑树; 而插入效率两者等效; \n\n如果操作涉及修改较多, 查询不多, 则选择红黑树; 除此之外, 红黑树在百万级数据或更大规模的数据场景中表现将会脱颖而出; \n\n如果增删查三者操作都比较多, 红黑书综合性能要更优; \n\n# 红黑树的性质\n\n红黑树是每个节点都带有颜色属性的**二叉查找树**，颜色是红色或黑色。基于二叉查找树的强制要求，对于任何有效的红黑树我们增加了如下的额外要求：\n\n1. 每个节点不是红色就是黑色。\n2. 如果左右孩子是NIL, 则把此孩子看作黑色节点; 实际上这个NIL节点是哨兵节点, 可看作一个公共叶子节点; \n3. 根节点是黑色。\n4. 从每个叶子到根的所有路径上不能有两个连续的红色节点; 如此, 每个红色节点的两个子节点都是黑色。\n5. 从任一节点到其每个叶子(可以包含NIL公共叶节点)的所有路径都包含相同数目的黑色节点。\n\n这些约束强制了红黑树的关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。\n\n是性质4导致路径上不能有两个连续的红色节点确保了这个结果。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。\n\n> 思考: 为什么满足上面的性质，红黑树就能保证: 其最长路径中节点个数不会超过最短路径节点个数的两倍(红黑树节点的左右子树高度差, 长的长度不超过短的长度的2倍; )？\n>\n> 可以做个假设: 一个节点到其`叶子节点1`, 全部是黑色节点, 共10个; 而到其`叶子节点2`, 黑红节点交替, 共20个, 这种是满足性质5最大的极限了, 由于性质5的限制, 其最长路径中节点个数不会超过最短路径节点个数的两倍; \n\n# 用途和好处\n\n红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。不只在时间敏感的应用如实时应用（real time application）中有价值; 而且在提供最坏情况担保的其他数据结构中作为基础模板有价值, 例如，在计算几何中使用的很多数据结构都可以基于红黑树实现。\n\n红黑树在函数式编程中也特别有用，在这里它们是最常用的持久数据结构（persistent data structure）之一，它们用来构造关联数组和集合，每次插入、删除之后它们能保持为以前的版本。除了$O(\\log n)$的时间之外，红黑树的持久版本对每次插入或删除需要$O(\\log n)$的空间。\n\n红黑树是2-3-4树的一种等同。换句话说，对于每个2-3-4树，都存在至少一个数据元素是同样次序的红黑树。在2-3-4树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得2-3-4树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍2-3-4树的原因，尽管2-3-4树在实践中不经常使用。\n\n红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。\n\n# RB树的结构设计\n\n红黑树相比于AVL树, 有一个伎俩, 就是设置了一个哨兵节点, 作为每个叶节点的左右孩子, 或者是: 不为叶节点, 但有一孩子指针为空时指向的一个节点, 这会使编程难度降低; \n\n还可以引入一个作为整个红黑树的头节点, 双亲指针指向红黑树根节点, 左孩子指针指向红黑树最左节点(最小值), 右孩子指针指向红黑树最右节点(最大值), 根节点的双亲指针指向该头节点; \n\n## 节点结构\n\n```cpp\ntypedef enum { RED = 0, BLACK = 1 } ColorType;\ntypedef int KeyType;\ntypedef struct rb_node\n{\n    rb_node * leftchild;\n    rb_node * parent;\n    rb_node * rightchild;\n    ColorType color;\n    KeyType key;\n}rb_node, *RBTree;\nstatic rb_node *NIL = BuyNode();\n```\n\n### 新建节点函数 - BuyNode\n\n```cpp\nrb_node * BuyNode()\n{\n    rb_node * s = (rb_node*)malloc(sizeof(rb_node));\n    if(nullptr == s) exit(1);\n    memset(s, 0, sizeof(rb_node));\n    s->leftchild = NIL;\n    s->rightchild = NIL;\n    s->color = RED;\t\t//出生的红黑树节点默认为红色\n    return s;\n}\n```\n\n# 插入\n\n## 建根函数\n\n```cpp\nrb_node * MakeRoot(KeyType kx)\n{\n    rb_node * root = BuyNode();\n    root->color = BLACK;\t\t//默认根节点为黑色\n    root->key = kx;\n    return root;\n}\n```\n\n## Insert\n\n```cpp\nbool Insert(rb_node *& tree, KeyType kx)\n{\n    if(tree == nullptr)\n    {\n        tree = MakeRoot(kx);\n        return true;\n    }\n    rb_node * pa = nullptr;\n    rb_node * p = tree;\n    while(p != nullptr && p->key != kx)\n    {\n        pa = p;\n        p = kx < p->key ? p->leftchild : p->rightchild;\n    }\n    if(p != nullptr && p->key == kx) return false;\n    p = BuyNode();\n    p->key = kx;\n    p->parent = pa;\n    if(kx < pa->key)\n    {\n        pa->leftchild = p;\n    }\n    else\n    {\n        pa->rightchild = p;\n    }\n    PassRBTree(tree, p);    //红黑树调整\n    return true;\n}\n```\n\n## 红黑树调整\n\n### 左单旋 - RotateLeft\n\n```cpp\nvoid RotateLeft(rb_node *& tree, rb_node * ptr)\n{\n    rb_node * newroot = ptr->rightchild;\n    newroot->parent = ptr->parent;\n    ptr->rightchild = newroot->leftchild;  //1 原根继承 轴节点的左孩子\n    if(newroot->leftchild != nullptr)\n    {\n        newroot->leftchild->parent = ptr;  \n    }\n    \n    newroot->leftchild = ptr;              //2 轴节点包揽原根\n    //3 处理 原根父节点(或无父节点) 的左右孩子指针(或tree指针)\n    if(ptr == tree)\n    {\n        tree = newroot;\n    }\n    else\n    {\n        if(ptr->parent->leftchild == ptr)\n        {\n            ptr->parent->leftchild = newroot;\n        }\n        else\n        {\n            ptr->parent->rightchild = newroot;\n        }\n    }\n    \n    ptr->parent = newroot;\n}\n```\n\n### 右单旋 - RotateRight\n\n```cpp\nvoid RotateRight(rb_node *& tree, rb_node * ptr)\n{\n    rb_node * newroot = ptr->leftchild;\n    newroot->parent = ptr->parent;\n    ptr->leftchild = newroot->rightchild;\n    if(newroot->rightchild != nullptr)\n    {\n        newroot->rightchild->parent = ptr;\n    }\n    newroot->rightchild = ptr;\n    if(ptr == tree)\n    {\n        tree = newroot;\n    }\n    else\n    {\n        if(ptr->parent->leftchild == ptr)\n        {\n            ptr->parent->leftchild = newroot;\n        }\n        else\n        {\n            ptr->parent->rightchild = newroot;\n        }\n    }\n    ptr->parent = newroot;\n}\n```\n\n### 调整函数\n\n对红黑树修改时, 出现不平衡或颜色冲突, 对其调整使其平衡, 颜色正确的函数\n\n```cpp\nvoid PassRBTree(rb_node *& tree, rb_node *p)\n{\n    rb_node * _X = nullptr;\n    for(; p != tree && p->parent->color == RED; )\n    {\n        if(p->parent->parent->rightchild == p->parent)//说明在爷爷的右边插入\n        {\n            _X = p->parent->parent->leftchild;\n            if(_X->color == RED)\n            {\n                _X->color = BLACK;\n                p->parent->color = BLACK;\n                p->parent->parent->color = RED;\n                p = p->parent->parent;\t//接下来循环看他爷爷的双亲是不是红\n            }\n            else //左单旋\n            {\n                p->parent->color = BLACK;\n                p->parent->parent->color = RED;\n                RotateLeft(tree, p->parent->parent);\n            }\n        }\n        else\n        {\n            \n        }\n        \n    }\n    tree->color = BLACK;\n}\n```\n\n加上双旋的情况\n\n```cpp\nvoid PassRBTree(rb_node *& tree, rb_node *p)\n{\n    rb_node * _X = nullptr;\n    for(; p != tree && p->parent->color == RED; )\n    {\n        if(p->parent->parent->rightchild == p->parent)//说明在爷爷的右边插入\n        {\n            _X = p->parent->parent->leftchild;\n            if(_X->color == RED)\n            {\n                _X->color = BLACK;\n                p->parent->color = BLACK;\n                p->parent->parent->color = RED;\n                p = p->parent->parent;\t//接下来循环看他爷爷的双亲是不是红\n            }\n            else\n            {\n                if(p->parent->leftchild == p)//在父节点的左边, 需要双旋\n                {\n                    p = p->parent;       //关键一步, 偷换p, 以与下面语句串联\n                    RotateRight(tree, p);//这是双旋第1步, 之后p调到其父节点的右边了\n                }\n                //不管上面的情况, 到这一步, p肯定在父节点的右边, 只需要左旋\n                p->parent->color = BLACK;\n                p->parent->parent->color = RED;\n                RotateLeft(tree, p->parent->parent);\n            }\n        }\n        else\n        {\n            _X = p->parent->parent->rightchild;\n            if(_X->color == RED)\n            {\n                \n            }\n            else //要旋转\n            {\n                \n            }\n        }\n        \n    }\n    tree->color = BLACK;\n}\n```\n\n","categories":["高级数据结构","树"]},{"title":"学习muduo库的思想","url":"/项目-muduo/学习muduo库的思想/","content":"# 内容\n\n1. 阻塞、非阻塞、同步、异步\n2. 五种IO模型\n3. 好的网路服务器设计思路\n4. Reactor模型\n5. `select`/`poll`/`epoll`、`LT/ET`模式对比\n6. muduo网络库编程环境配置\n7. muduo网络库的多线程模型\n8. 基于muduo的服务器程序实例\n9. muduo网络库提供的类\n10. muduo网络库中TcpServer类中的回调类型\n11. 代码示例ChatServer及运行测试结果\n\n# 阻塞、非阻塞、同步、异步\n\n网络IO阶段分为两个：数据准备和数据读写\n\n* 数据准备--根据系统IO操作的就绪状态\n    * 阻塞：调用IO方法的线程进入阻塞状态\n    * 非阻塞：不会改变线程的状态，通过返回值判断\n* 数据读写（IO层面的同步和异步）--根据应用程序和内核的交互方式\n    * 同步：用户的recv完成了所有的动作，而且因此阻塞或者空转等待。数据是用户从TCP的接收缓冲区搬移的。\n    * 异步：应用程序把任务交给操作系统，自己去做别的事情，操作系统处理完后，通知用户层“buf的数据已经准备好了”。可以通过sigio通知或者实现约定的回调方式通知\n\n```c\nssize_t recv(int sockfd, void* buf, size_t len, int flags);\nint size = recv(sockfd, buf, 1024, 0);\t//recv阻塞至sockfd上有数据准备好\n//如果recv的属性设置为set non-block，则即使sockfd没有数据也会返回，cpu空转\n\n/*\n\t返回值：\n\t\tsize == -1; # 原因可能为1.系统内部错误; 2.当前处于非阻塞模式，无数据\n\t\t\t若 errno == EAGAIN 则说明 当前的错误是因为处于非阻塞模式。\n\t\tsize == 0;\t# 是由于远端的正常close而返回\n*/\n```\n\n陈硕：**（非）阻塞和异/同步IO的关系：在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO。**\n![image-20220316211609059](../../images/学习muduo库的思想/image-20220316211609059.png)\n\n即使epoll也是同步的IO，返回发生事件的event，读的时候需要调用recv，所以是同步IO。\n\n* 业务层面的一个逻辑处理是同步还是异步？\n    * 同步：A操作等待B操作完毕，得到返回值，继续处理\n    * 异步：A操作告诉B操作它感兴趣的事件及通知方式，A操作继续执行自己的业务逻辑了，等B监听到相应。\n\n## 总结\n\n>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪”和“数据读写”，数据就绪阶\n>段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。\n>\n>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都\n>是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口\n>时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就\n>可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结\n>果。\n\n# 五种IO模型\n\n* 阻塞 blocking\n* 非阻塞 non-blocking\n* IO复用 IO multiplexing\n* 信号驱动 signal-driven\n* 异步 asynchronous\n\n# 好的网络服务器设计\n\n在这个多核时代，服务端网络编程如何选择线程模型？libevent作者的观点：**one loop(事件循环, 一般用IO复用作为事件分发器) per thread** is usually a good model. 多线程服务端编程的问题就转换为如何设计一个高效且易用的event loop，然后每个线程run一个event loop就行了【即muduo库的思想】（当然线程间的同步、互斥少不了，还有其他的耗时事件需要起另外的线程来做）。\n\n* event loop是non-blocking网络编程的核心，在现实生活中，non-blocking几乎总是和IO-multiplexing一起使用，原因有二：\n    * **不要单独使用非阻塞IO**：没有人真的会用轮询(busy-polling)来检查某个non-blocking IO操作是否完成，太浪费CPU资源\n    * **不要单独使用IO复用**（比如阻塞的IO复用）：IO multiplexing一般不能和blocking IO用在一起，因为blocking IO中read()/write()/accept()/connect()都有可能阻塞当前线程，这样线程就没办法处理其他socket上的IO操作了\n    * 所以当我们提到non-blocking的时候，实际上指的是non-blocking + IO multiplexing，单用其中任何一个都没有办法很好地实现功能。\n    * 结论：epoll + 非阻塞IO + 线程池(线程的数目一般对应电脑的CPU核数)\n\n> nginx使用的是epoll + fork，是不是不如epoll + pthread？\n\nnginx采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且**通过一把乐观锁解决了该模型导致的服务器惊群**现象，功能十分强大。\n\n# Reactor模型\n\nmuduo库和libevent库都是“基于事件驱动的Reactor模型”。\n\nWikipedia给出的Reactor Design Pattern的解释：\n\n> The Reactor design pattern is an **event handling pattern** for handling service **requests delivered concurrently** ~~to a service handler~~ by one or more inputs. The service handler then **demultiplexes the incoming requests** and **dispatchers them synchronously** to the associated request handlers.\n\nGoogle Translate:\n\n>Reactor 设计模式是一种事件处理模式，用于处理通过一个或多个输入同时交付给服务处理程序的服务请求。 然后，服务处理程序对传入的请求进行多路分解，并将它们同步分配给相关联的请求处理程序。\n\n* Reactor四个重要组件\n  * Event事件\n  * Reactor反应堆\n  * Demultiplex事件分发器\n  * EventHandler事件处理器\n\n```mermaid\n%%时序图例子\nsequenceDiagram\n\tparticipant Event\n\tparticipant Reactor\n\tparticipant Demultiplex\n\tparticipant EventHandler\n\tEvent ->> Reactor: 注册Event和Handler\n\tloop 事件集合\n\t\tReactor -> Reactor:Event集合\n\tend\n\tReactor ->> Demultiplex: 向Epoll add/mod/del Event\n\tReactor ->> Demultiplex: 启动反应堆\n    loop 事件分发器\n    \tDemultiplex -> Demultiplex:开启事件循环epoll_wait\n    end\n    Demultiplex ->> Reactor: 返回发生事件的Event\n    Reactor ->> EventHandler: 调用Event对应的事件处理器EventHandler\n```\n\n# epoll\n\n## select和poll的缺点\n\n* select的缺点：\n    * 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024（可更改：`#define __FD_SETSIZE 1024`），但由于select采用轮询的方式扫描文件描述符，则文件描述符数量越多，性能就越差。\n    * 内核/用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销\n    * select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件\n    * select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程（意思就是一件事情处理得太拖沓，拖延好几次才完成，影响效率）。其实epoll的LT模式也是这样。但是ET模式效率不一定比LT好。\n* poll\n    * 相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。\n\n>以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核/用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。\n\n## epoll原理及优势\n\nepoll的实现机制与select/poll机制完全不同。\n\nepoll通过在Linux内核中申请一个简易的文件系统，提升了效率。\n\n> 文件系统一般用什么数据结构实现——B+树，磁盘IO消耗低、效率很高。\n\n把原先的select/poll调用分成以下3个部分：\n\n1. 调用`epoll_create()`建立一个`epoll对象`（在`epoll文件系统`中为这个`句柄对象`分配资源）\n\n   * `epoll_create`在内核上创建的`eventpoll`结构如下：\n\n     ```c++\n     struct eventpoll\n     {\n         //...\n         /* 红黑树的根节点，这棵树中存储着所有添加到epoll中的需要监控的事件*/\n         struct rb_root rbr;\n         /* 双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/\n         struct list_head rdlist;\n         //...\n     }\n     ```\n\n     \n\n2. 调用`epoll_ctl`向`epoll`对象中添加这100万个连接的套接字\n\n3. 调用`epoll_wait`收集发生的事件的`fd`资源\n\n> 如此一来，要实现上面说的场景，只需在进程启动时建立一个`epoll对象`，然后在需要时像这个`epoll对象`中添加或者删除事件。同时`epoll_wait`时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的事件。\n\n* LT模式，muduo采用的是LT模式\n    * 特点：内核数据没被读完，就会一直上报数据\n    * 不会丢失数据或者消息\n        * 应用没有读取完数据，内核会不断上报\n    * 低延迟处理\n        * 每次读数据只需要一次系统调用，照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息\n    * 跨平台处理\n        * 像select一样可以跨平台使用\n* ET模式\n    * 特点：内核数据只上报一次，效率相对较高\n\n# muduo网络库编程准备\n\n## 开发环境\n\n1. ubuntu linux\n2. 安装json开发库\n3. 安装boost + muduo网络库开发环境[muduo库源码编译安装](https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980)\n4. 安装redis环境\n5. 安装mysql数据库环境\n6. 安装nginx\n7. 安装cmake环境\n\n* 配置远程开发环境\n  * [windows+vscode配置远程linux开发环境](https://blog.csdn.net/qq756684177/article/details/94236990)\n    1. linux系统运行sshd服务\n    2. 在vscode上安装Remote Development插件，其依赖插件会自动安装\n  * [VS环境创建远程linux跨平台项目](https://blog.csdn.net/QIANGWEIYUAN/article/details/89469717)\n  * vscode在linux环境下直接开发\n## 安装流程\n1. muduo库是基于boost开发的，所以需要先在Linux平台上安装boost库。需要注意，boost库的编译需要安装gcc、make等基础工具才行。环境：Ubuntu 20.04.6，太新的Ubuntu由于无法兼容旧代码，不能安装。\n    1. `tar -xzvf boost_1_69_0.tar.gz`解压\n    2. 执行`./bootstrap.sh`：也可以在后面加`--prefix=/usr/local`指定安装目录（默认路径）\n    3. `./b2`安装（如果Linux系统没有安装g++编译器，需要先安装）\n    4. 最后，再把上面的boost库头文件和lib库文件安装在默认的Linux系统头文件和库文件的搜索路径下，运行下面命令（因为要给/usr目录下拷贝文件，需要先进入root用户）：`sudo ./b2 install`\n    5. sudo ldconfig​更新链接库缓存\n    6. 验证安装boost是否成功，通过下面的代码验证一下：\n\n       ```cpp\n#include <iostream>\n#include <boost/bind.hpp>\n#include <string>\nusing namespace std;\n\nclass Hello\n{\npublic:\n\tvoid say(string name) \n\t{ cout << name << \" say: hello world!\" << endl; }\n};\n\nint main()\n{\n\tHello h;\n\tauto func = boost::bind(&Hello::say, &h, \"zhang san\");\n\tfunc();\n\treturn 0;\n}//运行结果zhang san say: hello world!\n```\n2. `unzip muduo-master.zip`\n3. `cd muduo-master`\n4. muduo库源码编译会编译很多`unit_test`测试用例代码，编译耗时长，我们用不到，vim编辑上面源码目录里面的`CMakeLists.txt`文件，如下修改：\n\n![](../../images/学习muduo库的思想/image-20250712185725471.png)\n7. `./build.sh`源码编译构建程序，运行该程序（注意：muduo是用cmake来构建的，需要先安装cmake，ubuntu下`sudo apt-get install cmake`就可以，redhat或者centos可以从yum仓库安装）\n8. 编译完成后，输入`./build.sh install`命令进行muduo库安装。但这个`./build.sh install`实际上把muduo的头文件和lib库文件放到了`muduo-master`同级目录下的`build`目录下的`release-install-cpp11`文件夹下面了\n\n   ```bash\nroot@tony-virtual-machine:/home/tony/package# ls\nbuild  muduo-master  muduo-master.zip\nroot@tony-virtual-machine:/home/tony/package# cd build/\nroot@tony-virtual-machine:/home/tony/package/build# ls\nrelease-cpp11  release-install-cpp11\nroot@tony-virtual-machine:/home/tony/package/build# cd release-install-cpp11/\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11# ls\ninclude  lib\n   ```\n   所以上面的install命令并没有把它们拷贝到系统路径下，导致我们每次编译程序都需要指定muduo库的头文件和库文件路径，很麻烦，所以我们选择直接把inlcude（头文件）和lib（库文件）目录下的文件拷贝到系统目录下（需要sudo）：\n   ```bash\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11# ls\ninclude  lib\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11# cd include/\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11/include# ls\nmuduo\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11/include# mv muduo/ /usr/include/\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11/include# cd ..\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11# ls\ninclude  lib\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11# cd lib/\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11/lib# ls\nlibmuduo_base.a  libmuduo_http.a  libmuduo_inspect.a  libmuduo_net.a\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11/lib# mv * /usr/local/lib/\nroot@tony-virtual-machine:/home/tony/package/build/release-install-cpp11/lib# \n   ```\n   拷贝完成以后使用muduo库编写`C++`网络程序，不用在指定头文件和lib库文件路径信息了，因为`g++`会自动从`/usr/include`和`/usr/local/lib`路径下寻找所需要的文件。\n## 测试代码\n测试muduo是否能够正常使用，编写一个简单的echo回显服务器，如下：\n```cpp\n#include <muduo/net/TcpServer.h>\n#include <muduo/base/Logging.h>\n#include <boost/bind.hpp>\n#include <muduo/net/EventLoop.h>\n\n// 使用muduo开发回显服务器\nclass EchoServer\n{\n public:\n  EchoServer(muduo::net::EventLoop* loop,\n             const muduo::net::InetAddress& listenAddr);\n\n  void start(); \n\n private:\n  void onConnection(const muduo::net::TcpConnectionPtr& conn);\n\n  void onMessage(const muduo::net::TcpConnectionPtr& conn,\n                 muduo::net::Buffer* buf,\n                 muduo::Timestamp time);\n\n  muduo::net::TcpServer server_;\n};\n\nEchoServer::EchoServer(muduo::net::EventLoop* loop,\n                       const muduo::net::InetAddress& listenAddr)\n  : server_(loop, listenAddr, \"EchoServer\")\n{\n  server_.setConnectionCallback(\n      boost::bind(&EchoServer::onConnection, this, _1));\n  server_.setMessageCallback(\n      boost::bind(&EchoServer::onMessage, this, _1, _2, _3));\n}\n\nvoid EchoServer::start()\n{\n  server_.start();\n}\n\nvoid EchoServer::onConnection(const muduo::net::TcpConnectionPtr& conn)\n{\n  LOG_INFO << \"EchoServer - \" << conn->peerAddress().toIpPort() << \" -> \"\n           << conn->localAddress().toIpPort() << \" is \"\n           << (conn->connected() ? \"UP\" : \"DOWN\");\n}\n\nvoid EchoServer::onMessage(const muduo::net::TcpConnectionPtr& conn,\n                           muduo::net::Buffer* buf,\n                           muduo::Timestamp time)\n{\n  // 接收到所有的消息，然后回显\n  muduo::string msg(buf->retrieveAllAsString());\n  LOG_INFO << conn->name() << \" echo \" << msg.size() << \" bytes, \"\n           << \"data received at \" << time.toString();\n  conn->send(msg);\n}\n\n\nint main()\n{\n  LOG_INFO << \"pid = \" << getpid();\n  muduo::net::EventLoop loop;\n  muduo::net::InetAddress listenAddr(8888);\n  EchoServer server(&loop, listenAddr);\n  server.start();\n  loop.loop();\n}\n```\n\n使用g++进行编译，注意链接muduo和pthread的库文件，编译命令如下：\n```bash\ng++ main.cpp -lmuduo_net -lmuduo_base -lpthread -std=c++11\n```\n编译链接完成，生成a.out可执行程序，上面的echo服务器监听8888端口，运行上面的a.out回显服务器如下：\n```bash\nroot@tony-virtual-machine:/home/tony/code# ./a.out \n20190404 08:00:15.254790Z 42660 INFO  pid = 42660 - main.cpp:61\n```\n等待客户端连接，可以打开一个新的shell命令行用netcat命令模拟客户端连接echo服务器进行功能测试，命令如下：\n```bash\ntony@tony-virtual-machine:~$ echo \"hello world\" | nc localhost 8888\n\nhello world #客户端数据回显\n```\n客户端数据回显正确，看看服务器接日志信息打印如下：\n```bash\nroot@tony-virtual-machine:/home/tony/code# ./a.out \n20190404 08:00:15.254790Z 42660 INFO  pid = 42660 - main.cpp:61\n20190404 08:00:59.438626Z 42660 INFO  TcpServer::newConnection [EchoServer] - new connection [EchoServer-0.0.0.0:8888#1] from 127.0.0.1:33480 - TcpServer.cc:80\n20190404 08:00:59.438707Z 42660 INFO  EchoServer - 127.0.0.1:33480 -> 127.0.0.1:8888 is UP - main.cpp:42\n20190404 08:00:59.438812Z 42660 INFO  EchoServer-0.0.0.0:8888#1 echo 12 bytes, data received at 1554364859.438723 - main.cpp:53\n```\n到此，muduo安装成功，能够正常进行C++网络程序开发！\n## 配置链接库、头文件\n\nmuduo库的使用需要链接`lib`库文件，一般为`.so`文件。一般`.so`文件都在`/usr/lib或/usr/local/lib`路径下。\n\n编译链接使用muduo库的程序需要加后缀`-l ...`\n\n```bash\n# /usr/lib or /usr/local/lib\n# 3 lib: libmuduo_base.so; libmuduo_net.so; libpthread.so\n-lmuduo_net -lmuduo_base -lpthread\n# 注意顺序，net需要写在前面，因为net依赖base；base写中间，因为依赖phtread\n```\n\n### 如何在vscode配置这三个库？\n\nvscode中按`F1`键，搜索`edit configurations`，将会打开：\n\n项目目录下的`.vscode`文件夹下的`c_cpp_properties.json`\n\n```json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Linux\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\"\n            ],\n            \"defines\": [],\n            \"compilerPath\": \"/usr/bin/gcc\",\n            \"cStandard\": \"c17\",\n            \"cppStandard\": \"c++20\",\n            \"intelliSenseMode\": \"linux-gcc-x64\"\n        }\n    ],\n    \"version\": 4\n}\n```\n\nbuild构建项目的快捷键是`ctrl+shift+B`键，但若你没有配置过build流程，将会弹出选项让你配置。实际上就是让你配置`.vscode`下的`tasks.json`。\n\n> 除了上面这两个json文件，vscode下的cpp项目中还有一个json配置文件是launch.json，是关于调试的配置信息。\n\n```json\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"type\": \"shell\",\n            \"label\": \"build\",\n            \"command\": \"/usr/bin/g++\",\n            \"args\": [\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\",\n            ],\n            \"options\": {\n                \"cwd\": \"/usr/bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": \"build\"\n        }\n    ]\n}\n```\n\n其中，`args`键就是build时编译链接命令后面加的参数。\n\n我们在此使用muduo库，若想用vscode来一键build，则可以在args里加上三个参数。\n\n```json\n\t\t{\n            // ...\n\t\t\t\"args\": [\n                // ...\n                \"-lmuduo_net\",\n                \"-lmuduo_base\",\n                \"-lpthread\"\n            ],\n            // ...\n        }\n```\n\n如果配置文件写好了，则就可以在vscode下一键build。\n\n# muduo网络库的多线程模型\n\n* 网络服务器编程常用模型\n    1. accept + read/write : 不是并发服务器\n    2. accpet + fork (process-pre-connection) : 适合并发连接数不大，计算任务工作量大于fork的开销\n    3. accept + thread (thread-pre-connection) : 比方案2的开销小了一点，但是并发造成线程堆积过多\n    4. reactors in threads (one loop per thread) : 是muduo的网络设计。有一个main reactor负载accept连接，然后把连接分发到某个sub reactor(采用round-robin的方式来选择sub reactor)，该连接的操作都在sub reactor所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用CPU。\n    5. reactors in process  (one loop pre process) : 是nginx服务器的网络模块设计，基于进程设计，采用多个Reactors充当I/O进程和工作进程，通过一把accept锁完美解决多个Reactors的“惊群现象”。\n* muduo底层的模型\n\nmuduo的网络设计：reactors in threads - one loop per thread.\n\n方案的特点是\"one loop per thread\"，有一个main reactor负责accept连接，然后把连接分发到某个sub reactor（轮询方式选择）。该连接的所有操作都在该reactor所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用CPU。如果有过多的耗费CPU IO的计算任务，可以设置一个专门处理耗时计算任务的线程负责处理该类任务。\n\nreactor poll的大小根据CPU核心的数目确定。\n\n```cpp\n//设置EventLoop的线程个数，底层通过EventLoopThreadPool线程池管理线程类EventLoopThread\n_server.setThreadNum(10);\n```\n\n# 基于muduo的服务器程序\n\n## muduo网络库提供的类\n\n1. TcpServer：用于编写服务器程序的。\n2. TcpClient：用于编写客户端程序的。\n\n这两个类，实际上就是把`epoll+线程池`封装在一起了。好处就是把网络IO代码和业务代码区分开，使程序员可以专心开发业务代码。\n\n业务代码关注的两件事情：\n\n1. 用户的连接与断开\n2. 用户的可读写事件\n\n但这两件事情，如果我们使用了网络库，则如何监听、何时发生事件全都由网络库给程序员上报。\n\n## muduo库中TcpServer类中重要的回调属性\n\n```cpp\nvoid setConnectionCallback(const ConnectionCallback& cb)\n{\n    connectionCallback_ = cb;\n}\nvoid setMessageCallback(const MessageCallback & cb)\n{\n    messageCallback_ = cb;\n}\n```\n\n```cpp\ntypedef std::function<void (const TcpConnectionPtr&)> ConnectionCallback;\ntypedef std::function<void (const TcpConnectionPtr&, Buffer*, Timestamp)> MessageCallback;\n```\n\n## 代码示例 - ChatServer\n\n需要包含的头文件\n\n```cpp\n#include<muduo/net/TcpServer.h>\n#include<muduo/net/EventLoop.h>\n#include<functional>\nusing namespace std::placeholders;\n#include<iostream>\n```\n\n```cpp\nclass ChatServer\n{\npublic:\n    /* 在其中：\n     * 1、类内构造TcpServer，初始化EventLoop指针\n     * 2、给TcpServer注册用户连接的创建、连接的断开回调\n     * 3、给TcpServer注册用户读写事件回调\n     * 4、设置TcpServer的线程数量，muduo库会自己分配IO线程和工作线程\n     */\n    ChatServer(muduo::net::EventLoop* loop, //事件循环\n               const muduo::net::InetAddress& listenAddr,   //IP+port\n               const std::string& nameArg)  //服务器的名字\n        : m_server(loop, listenAddr, nameArg),\n          m_loop(loop)\n    {\n        m_server.setConnectionCallback(std::bind(&ChatServer::onConnection, this, _1));\n        m_server.setMessageCallback(std::bind(&ChatServer::onMessage, this, _1, _2, _3));\n        m_server.setThreadNum(4);\n    }\n    //开启事件循环\n    void start()\n    {\n        m_server.start();\n    }\nprivate:\n    //当发生用户的连接创建、连接断开事件后，调用函数\n    void onConnection(const muduo::net::TcpConnectionPtr &conn)\n    {\n\n    }\n    //读写事件发生后，调用函数\n    void onMessage(const muduo::net::TcpConnectionPtr &conn,\n                   muduo::net::Buffer * buffer,\n                   muduo::Timestamp time)\n    {\n\n    }\nprivate:\n    muduo::net::TcpServer m_server;\n    muduo::net::EventLoop * m_loop;\n};\n```\n\n### 编写回调函数\n\nOnConnection和OnMessage\n\n```cpp\n    //当发生用户的连接创建、连接断开事件后，调用函数\n    void onConnection(const muduo::net::TcpConnectionPtr &conn)\n    {\n        std::cout << conn->peerAddress().toIpPort() << \" -> \" <<\n            conn->localAddress().toIpPort() << \" state:\";\n        if(conn->connected())\n        {\n            std::cout << \" online.\";\n        }\n        else\n        {\n            std::cout << \" offline.\"\n            conn->shutdown();\n            //_loop->quit();\n        }\n        std::cout << std::endl;\n    }\n    //读写事件发生后，调用函数\n    void onMessage(const muduo::net::TcpConnectionPtr &conn,\n                   muduo::net::Buffer * buffer,\n                   muduo::Timestamp time)\n    {\n        std::string buf = buffer->retrieveAllAsString();\n        std::cout << \"recv data: \" << buf << \" time: \" << time.toString() << std::endl;\n        conn->send(buf);\n    }\n```\n\n### 主函数\n\n```cpp\nint main()\n{\n    muduo::net::EventLoop loop; //相当于创建了一个epoll\n    muduo::net::InetAddress addr(\"127.0.0.1\", 6000);\n    ChatServer chatserver(&loop, addr, \"mychat\");\n    chatserver.start();\n    loop.loop();    //相当于调用epoll_wait，以阻塞方式等待新用户连接事件、已连接用户的读写事件\n}\n```\n\n### 测试服务器程序\n\n首先，编译链接需要加后缀`-lmuduo_net -lmuduo_base -lpthread`。\n\n编译链接后，执行程序。\n\n```bash\n./chatserver\n```\n\n可以通过telnet连接服务器。\n\n```bash\ntelnet 127.0.0.1 6000\n```\n\n#### 运行结果\n\n```\nxcg@ubuntu:~$ telnet 127.0.0.1 6000\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is '^]'.\nhello!\t\t\t\t\t#客户端输入显示到屏幕上的，发送给服务器的内容\nhello!\t\t\t\t\t#收到的服务器复制后回发的一模一样的内容。\n^]\ntelnet> quit\nConnection closed.\n```\n\n```\nxcg@ubuntu:~/muduo-0528$ ./chatserver \n20220528 08:10:49.554317Z  8116 INFO  TcpServer::newConnection [mychat] - new connection [mychat-127.0.0.1:6000#1] from 127.0.0.1:60338 - TcpServer.cc:80\n127.0.0.1:60338 -> 127.0.0.1:6000 state: online.\nrecv data: hello!\n time: 1653725453.563665\n127.0.0.1:60338 -> 127.0.0.1:6000 state: offline.\n20220528 08:10:56.835295Z  8116 INFO  TcpServer::removeConnectionInLoop [mychat] - connection mychat-127.0.0.1:6000#1 - TcpServer.cc:109\n```\n\n","categories":["项目","muduo"]},{"title":"Cpp_线程库","url":"/Cpp/Cpp_线程库/","content":"# 内容\n\n1. 线程的构造\n2. detach、join\n3. `mutex`、`recursive_mutex`、`shared_mutex`\n4. `lock_guard`、`unique_lock`、`shared_lock`\n5. chrono\n6. `std::ref`\n7. jthread\n    1. 线程取消\n8. 条件变量\n    1. wait、`wait_for`、`wait_until`\n9. future、promise\n    1. `packaged_task`\n    2. async\n10. 信号量\n11. 闩锁（latch）、屏障（Barrier）\n# chrono\n`std::this_thread::sleep_for`可以用于线程睡眠。\n1. 可以使用`<chrono>`库下的`std::chrono::milliseconds(n)`来指定时间单位。\n2. `C++17`之后可以使用`using namespace std::chrono_literals`用于把字面常量标识符映射为秒、毫秒等。\n\n![](../../images/Cpp_线程库/image-20240722225224344.png)\n# thread创建线程 - 卖票程序\n1. 用`std::thread`构造。\n    1. 参数1填函数地址。\n    2. 参数2填函数参数，没有则不填。\n    3. 遵循的是RAII，构造完即开始运行。\n2. 线程对象有`detach`方法用来脱离主线程的管理。防止主线程先于子线程结束导致线程因为整个进程提前终止而未执行完毕。\n3. 也可以使用`th.join()`方法来让主线程等待子线程执行结束。相当于WaitForSingleObject\n\n```cpp\n#include <thread>\n#include <chrono>\nconstinit int tickets = 100;\nvoid station(void);\nvoid station2(void);\n\nint main()\n{\n    std::thread th(&station);\n    std::thread th2(&station2);\n    th.detach();\n    th2.detach();\n    //std::this_thread::sleep_for(std::chrono::milliseconds(5000));\n    std::this_thread::sleep_for(5000ms);\n}\nvoid station(void)\n{\n    while (true)\n    {\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\nvoid station2(void)\n{\n    while (true)\n    {\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #2: \" << tickets-- << std::endl;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n```\n## 输出\n```\nStation #1: 100\nStation #1: 99\n...\nStation #1: ...\n...\nStation #1: 89\nStation #1: 88\nStation #1: 87\nStation #2: 86\nStation #2: 85\n...\nStation #2: ...\n...\nStation #2: 67\nStation #2: 66\nStation #2: 65\nStation #2: 64\nStation #2: 63\nStation #2: 62\nStation #1: 61\nStation #1: 60\n...\nStation #1: ...\n...\nStation #1: 5\nStation #1: 4\nStation #1: 3\nStation #1: 2\nStation #1: 1\nStation #2: 0\n```\n发现把0号票卖掉了，错误。\n# mutex（互斥量）\n定义于`<mutex>`中。\n## mutex特性：构造函数以及不可复制性\n在[mutex构造函数](https://legacy.cplusplus.com/reference/mutex/mutex/mutex/)中指出，构造一个mutex对象，初始状态是解锁。\nmutex对象不能被复制、移动（复制构造函数和赋值运算符都被删除）\n因此，要特别注意你创建的mutex的生命周期，不建议建立在栈帧随时塌陷的位置。\n## recursive_mutex（多次互斥量）\n单纯的mutex只能锁一次。\n`recursive_mutex`可以锁多次，也可以解锁多次。\n## 基于C++标准线程库互斥量的卖票程序\n```cpp\n#include <iostream>\n#include <print>\n#include <thread>\n#include <mutex>\n#include <vector>\n#include <chrono>\nusing namespace std::literals;\nvoid seller(std::string const& name, int& ticketsNum, std::mutex& mx);\nint main()\n{\n    std::vector<std::jthread> vec_jthreads;\n    int tickets = 1000;\n    std::mutex mx;\n    // start new thread\n    for (int i = 0; i < 10; ++i)\n    {\n        std::stringstream ss;\n        ss << \"seller \" << i;\n        vec_jthreads.emplace_back(seller, ss.str(), std::ref(tickets), std::ref(mx));\n    }\n    \n    for (auto& jth : vec_jthreads)\n    {\n        jth.join();\n    }\n\n    std::println(\"Finally, tickets remain: {}\", tickets);\n    return 0;\n}\nvoid seller(std::string const& name, int& tickets, std::mutex& mx)\n{\n    std::this_thread::sleep_for(1000ms);\n    while (true)\n    {\n        mx.lock();\n        if (tickets > 0)\n        {\n            std::println(\"{}: {}\", name, tickets);\n            --tickets;\n            mx.unlock();\n        }\n        else\n        {\n            mx.unlock();\n            break;\n        }\n    }\n}\n```\n## 输出\n```\nStation #1: 500\nStation #1: 499\n...\nStation #1: ...\n...\nStation #1: 394\nStation #1: 393\n----------------------\nStation #2: 392\nStation #2: 391\n...\nStation #2: ...\n...\nStation #2: 5\nStation #2: 4\nStation #2: 3\nStation #2: 2\nStation #2: 1\n```\n## 分析\n可以看到线程1、2各自持有锁的跨度还是挺大的，这是因为在`跨平台C++线程库`在Windows下的执行是用`Windows临界区`实现的。\n# 作为引用传入线程函数参数（`std::ref`）\n1. `std::mutex`锁是不可复制的。只能通过引用传递。\n\n```cpp\nvoid station(std::mutex& mx);\nint main()\n{\n    std::mutex mx;\n    std::thread th(&station, mx); // error\n    th.join();\n}\nvoid station(std::mutex& mx)\n{\n    // ...\n}\n```\n此时，虽然线程函数参数类型为引用，但实际写的代码中，“mx”这个形式和值类型的形式不能区分，编译器无法对其直接解析为引用，产生二义性。（即编译器默认都先按照值传递处理，之后才去处理、区分是否为引用）\n2. 因此不能直接裸传，为了显式指出此变量为引用类型，要包装一层“引用包裹器”。`std::reference_wrapper(mx)`，也可以简写为`std::ref(mx)`。在实际使用到该引用类型变量时，包裹器会自己释放出实际内容。\n\n```cpp\nvoid station(std::mutex& mx);\nvoid station2(std::mutex& mx);\nint main()\n{\n    std::mutex mx;\n    std::thread th(&station, std::ref(mx));\n    std::thread th2(&station2, std::ref(mx));\n    th.join();\n    th2.join();\n}\nvoid station(std::mutex& mx)\n{\n    // ...\n}\nvoid station2(std::mutex& mx)\n{\n    // ...\n}\n```\n## 解析`std::ref`\n\n```c++\nvoid fun(int n, int & ret)\n{\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcout << \"thread fun\" << endl;\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(100));\n\t}\n\tret = n;\n\tcout << \"thread fun end\" << endl;\n\treturn n;\n}\nint main()\n{\n\tint x = 10;\n\tstd::thread tha(fun, 5, std::ref(x));\n\ttha.join();\n\tcout << x << endl;\t\t//输出5\n}\n```\n\n```c++\nint main()\n{\n\tint x = 10;\n\tstd::thread tha(fun, 5, x);\t\t//编译不通过\n\ttha.join();\n\tcout << x << endl;\n}\n```\n\n为什么直接传x不能编译通过呢？因为thread的构造距离start线程中间有一层可变参模板组件：\n\n```c++\ntemplate<class Function, class... Args>\nexplicit thread(Function&& f, Args&&... args);\n```\n\n```c++\ntemplate <class _Fn, class... _Args>\nexplicit thread(_Fn&& _Fx, _Args&&... _Ax)\n{\n    _Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);\n}\n```\n\nthread的构造需要先通过这个组件，则由于`args`是按`[模板 &&]`接收，如果直接单纯传`x`，则会识别为普通的`int`值传递，在到达`_Start`接口后，`x`的`int`类型与参数类型`int &`不匹配，无法编译通过。\n\n所以需要一个特殊的机制，用`std::ref`显式指出把`x`按引用方式传递（传地址），如此，在经过模板时，按转发引用处理，经过`_Start`接口的完美转发后作为右值**隐式转换**为`int &`类型，如此便可编译通过，达到按引用传参的目的。\n\n为什么是隐式转换？\n```c++\n//std::ref的底层是reference_wrapper类，其中有隐式转换\ntemplate <class _Ty>\nclass reference_wrapper\n{\npublic:\n    using type = _Ty;\n    \n    template <class _Uty>\n    reference_wrapper(_Uty&& _Val)\n    {\n        _Ty& _Ref = static_cast<_Uty&&>(_Val);\n        _Ptr      = &_Ref;\t/*_STD addressof(_Ref);*/\n    }\n    \n    operator _Ty&() const noexcept\n    {\n        return *_Ptr;\n    }\nprivate:\n    _Ty* _Ptr{};\n};\n```\n\n测试\n```c++\n#include<iostream>\n#include<thread>\nusing namespace std;\n//std::ref的底层是reference_wrapper类，其中有隐式转换\n\ntemplate <class _Ty>\nclass my_reference_wrapper\n{\npublic:\n    using type = _Ty;\n\n    template <class _Uty>\n    my_reference_wrapper(_Uty&& _Val)\n    {\n        _Ty& _Ref = static_cast<_Uty&&>(_Val);\n        _Ptr = &_Ref;\t/*_STD addressof(_Ref);*/\n    }\n\n    operator _Ty&() const noexcept\n    {\n        return *_Ptr;\n    }\nprivate:\n    _Ty* _Ptr{};\n};\nint fun(int n, int& x)\n{\n    for (int i = 1; i <= n; ++i)\n    {\n        cout << \"thread fun\" << endl;\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n    x = n;\n    cout << \"thread fun end\" << endl;\n    return n;\n}\nint main()\n{\n    int x = 10;\n    \n    std::thread tha(fun, 5, my_reference_wrapper<int>(x));\n    tha.join();\n    cout << x << endl;\n}\n```\n\n```c++\ntemplate <class _Fn, class... _Args>\nexplicit thread(_Fn&& _Fx, _Args&&... _Ax)\n{\n    _Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);\n}\n```\n\n构造tha时的第三个参数是`my_reference_wrapper<int>(x)`，是个右值！传入thread可变参模板函数，完美转发，右值叠加右值，依然是右值，调用`_Start`时优先匹配`&&`类型的参数，但是发现没有，而且只有一个匹配的选项是：`(int n, int & x)`，是`int&`类型，于是乎，无奈之举，调用成员函数`operator _Ty()`，即为隐式转换为`&Ty`的左值引用类型。\n\n如此一来，即可把线程函数外部的`x`按引用传递。\n# 变量的作用域\nModern Cpp引入了一些变量的作用域关键字。\n变量的作用域类型：\n1. 全局\n2. auto（局部）：在当前栈帧下\n3. thread_local：用于修饰全局变量。不同线程访问相同名字的全局变量，会自动生成副本，对此名字变量的操作只在当前线程有效，不会影响到其他人。\n# lock_guard\n定义于`<mutex>`中。用于帮助管理mutex。\nRAII对象。自动管理生命周期。\n需要一个mutex锁来构造。构造后立刻对mutex上锁，直到`lock_guard`自身析构时对mutex解锁。\n与mutex一样，`lock_guard`对象无法复制/移动。\n\n>`lock_guard`是一个模板类，需要一个模板参数，如填写`<std::mutex>`。在`C++17`后，不用填写模板参数，可以自动判断程序代码大括号中的参数类型。\n\n```cpp\nvoid station(std::mutex& mx);\nvoid station2(std::mutex& mx);\nint main()\n{\n    std::mutex mx;\n    std::thread th(&station, std::ref(mx));\n    std::thread th2(&station2, std::ref(mx));\n    th.join();\n    th2.join();\n}\nvoid station(std::mutex& mx)\n{\n    while (true)\n    {\n        std::lock_guard<std::mutex> lck{ mx };\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n        }\n        else\n        {\n            break;\n        }\n    } // 退出此括号时，lck析构\n}\nvoid station2(std::mutex& mx)\n{\n    while (true)\n    {\n        std::lock_guard lck{ mx }; // 在`C++17`后，不用填写模板参数，可以自动判断程序代码大括号中的参数类型。\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #2: \" << tickets-- << std::endl;\n        }\n        else\n        {\n            break;\n        }\n    } // 退出此括号时，lck析构\n}\n```\n# unique_lock\n是`lock_guard`的多功能版，可以自己控制unlock、转移所有权。\n定义于`<mutex>`中\n1. 和`lock_guard`用法一样，但是`unique_lock`支持转移给另一个`unique_lock`。（需要使用`std::move`）\n2. 有unlock、release、swap方法。\n3. 可以管理普通`mutex`，也可以管理`shared_mutex`。\n\n```cpp\nvoid station(std::mutex& mx);\nvoid station2(std::mutex& mx);\nint main()\n{\n    std::mutex mx;\n    std::thread th(&station, std::ref(mx));\n    std::thread th2(&station2, std::ref(mx));\n    th.join();\n    th2.join();\n}\nvoid station(std::mutex& mx)\n{\n    while (true)\n    {\n        std::unique_lock lck{ mx };\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n            std::unique_lock lck2 = std::move(lck);\n        }\n        else\n        {\n            break;\n        }\n    } // 退出此括号时，lck2、lck析构\n}\n// station2 ...\n```\n## 输出\n```\nStation #1: 100\nStation #1: 99\n...\nStation #1: ...\n...\nStation #1: 67\nStation #1: 66\nStation #2: 65\nStation #2: 64\n...\nStation #2: ...\n...\nStation #2: 8\nStation #2: 7\nStation #2: 6\nStation #2: 5\nStation #2: 4\nStation #2: 3\nStation #2: 2\nStation #2: 1\n```\n# shared_mutex（共享互斥量）\n定义于`<shared_mutex>`，`C++17`给出的共享互斥量。\n\nShared mutexes are especially useful when shared data can be safely read by any number of threads simultaneously, but a thread may only write the same data when no other thread is reading or writing at the same time.\n\n消费者可以共同访问，但不能和生产者一起共享。\n1. 提供的方法：\n    1. `lock_shared`用于消费者共享互斥量。\n    2. `lock`用于生产者独占互斥量。\n    3. `lock`和`lock`，`lock`和`lock_shared`都互斥。\n2. 在生产者消费者模型中，`lock_shared`、`unlock_shared`用于`n`个消费者一起进入消费。`lock`、`unlock`用于阻断**所有消费者、其他生产者**进入。\n\n```cpp\n#include <shared_mutex>\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <mutex>\nconstinit int tickets{ 0 };\nvoid station(std::shared_mutex& mx);\nvoid station2(std::shared_mutex& mx);\nvoid produce(std::shared_mutex& mx);\nusing namespace std::chrono_literals;\n\nint main()\n{\n    std::shared_mutex mx;\n    std::thread consumer(&station, std::ref(mx));\n    std::thread consumer2(&station2, std::ref(mx));\n    std::thread producer(&produce, std::ref(mx));\n\n    consumer.join();\n    consumer2.join();\n    producer.join();\n}\nvoid produce(std::shared_mutex& mx)\n{\n    while (true)\n    {\n        mx.lock();\n        std::wcout << L\"Producer: \" << ++tickets << std::endl;\n        std::this_thread::sleep_for(500ms);\n        mx.unlock();\n\n    }\n}\nvoid station(std::shared_mutex& mx)\n{\n    while (true)\n    {\n        mx.lock_shared();\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n            mx.unlock_shared();\n        }\n        else\n        {\n            mx.unlock_shared();\n        }\n    }\n}\nvoid station2(std::shared_mutex& mx)\n{\n    while (true)\n    {\n        mx.lock_shared();\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #2: \" << tickets-- << std::endl;\n            mx.unlock_shared();\n        }\n        else\n        {\n            mx.unlock_shared();\n        }\n    }\n}\n```\n## 输出\n```\nProducer: 1\nStation #2: 1\nStation #1: 0\nProducer: 0\nProducer: 1\nProducer: 2\nProducer: 3\nStation #2: 3\nStation #1: 2\nStation #1: 1\nProducer: 1\nProducer: 2\nProducer: 3\nStation #2: 3\nStation #2: 2\nStation #2: 1\nProducer: 1\nStation #2: 1\nProducer: 1\nProducer: 2\nProducer: 3\nProducer: 4\n ...\n```\n## 分析\n1. 输出中看到1个producer和2个consumer是互斥的，有一方在则另一方不动。\n2. 输出中看到0号票有时候也会被卖掉。证明了`mx.lock_shared()`只是让n个消费者同时拿到锁，并且没有做进一步的同步管理。\n# shared_lock和unique_lock搭配管理shared_mutex\n1. 把`shared_mutex`的开锁解锁的动作让锁管理器（`shared_lock`和`unique_lock`）接管。\n2. `shared_mutex`的lock、unlock动作让`unique_lock`接管\n3. `shared_mutex`的lock_shared、unlock_shared动作让`shared_lock`接管。\n\n```cpp\n#include <shared_mutex>\n#include <iostream>\n#include <thread>\n#include <chrono>\n#include <mutex>\nconstinit int tickets{ 0 };\nvoid station(std::shared_mutex& mx);\nvoid station2(std::shared_mutex& mx);\nvoid produce(std::shared_mutex& mx);\nusing namespace std::chrono_literals;\n\nint main()\n{\n    std::shared_mutex mx;\n    std::thread consumer(&station, std::ref(mx));\n    std::thread consumer2(&station2, std::ref(mx));\n    std::thread producer(&produce, std::ref(mx));\n\n    consumer.join();\n    consumer2.join();\n    producer.join();\n}\nvoid produce(std::shared_mutex& mx)\n{\n    while (true)\n    {\n        std::unique_lock lck{ mx };\n        std::wcout << L\"Producer: \" << ++tickets << std::endl;\n        std::this_thread::sleep_for(500ms);\n    }\n}\nvoid station(std::shared_mutex& mx)\n{\n    while (true)\n    {\n        std::shared_lock lck{ mx };\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #1: \" << tickets-- << std::endl;\n        }\n        else\n        {\n        }\n    }\n}\nvoid station2(std::shared_mutex& mx)\n{\n    while (true)\n    {\n        std::shared_lock lck{ mx };\n        if (tickets > 0)\n        {\n            std::wcout << L\"Station #2: \" << tickets-- << std::endl;\n        }\n        else\n        {\n        }\n    }\n}\n```\n# `C++`多线程与lambda表达式结合\n使用lambda表达式定义一个线程函数：每100ms打印从0到100。\n```cpp\n#include <iostream>\n#Include <thread>\n#include <chrono>\n\nusing namespace std::chrono_literals;\nint main()\n{\n    std::thread t1([]() -> void\n    {\n        for (int i = 0; i <= 100; ++i)\n        {\n            std::cout << i << std::endl;\n            std::this_thread::sleep_for(100ms);\n        }\n    });\n    t1.join();\n}\n```\n## lambda函数参数的处理\nlambda表达式作为线程函数，如果有其自己的内部参数，那么就需要传入lambda表达式后，再传入其使用的参数。\n```cpp\n#include <iostream>\n#Include <thread>\n#include <chrono>\n\nusing namespace std::chrono_literals;\nint main()\n{\n    auto nums{ 100 };\n    std::thread t1([](auto nu) -> void\n        {\n            for (int i = 0; i <= nu; ++i)\n            {\n                std::cout << i << std::endl;\n                std::this_thread::sleep_for(100ms);\n            }\n            nu = 50; // 带不回去\n        }, nums);\n    std::thread t2([](int& nu) -> void\n        {\n            for (int i = 0; i <= nu; ++i)\n            {\n                std::cout << i << std::endl;\n                std::this_thread::sleep_for(100ms);\n            }\n            nu = 50;  // 带回去修改了nums的值\n        }, std::ref(nums));\n    t1.join();\n    t2.join();\n}\n```\n1. 参数按值传递：lambda形参类型可以用auto。\n2. 参数按引用传递：传参时必须用`std::ref`。此时由于有引用包裹器，auto不能推导。所以lambda形参类型不可以用`auto &`，也不可以用`auto &&`，必须明确`ClassName &`\n# jthread\n`C++20`下的加强版thread类\n1. 如果main函数中没写t1的join，那么会先到`return 0;`，之后在main即将return 0时，t1析构时，自动地为t1调用join，则最后主线程等待t1结束后一起退出。如果明确写了join则按照普通thread的join时机。\n2. 如果只写detach，那么最后就不会自动加join，主线程退出时子线程也会退出。\n## 线程取消\n![](../../images/Cpp_线程库/image-20240723044901963.png)\n这些 `stop_XXX` 类型都在`<stop_token>`中定义，旨在使`jthread`取消，尽管它们也可以独立使用 `std::jthread` - 例如，中断`std::condition_variable_any`等待函数，或用于自定义线程管理实现。事实上，它们甚至不需要用于“停止”任何东西，而是可以用于线程安全的一次性函数调用触发器。（这段话的意思大概是，`stop_token`只是叫做“停止”，但实际上没有真的停止动作）\n### stop_token、stop_requested\n1. token会共享一个标记性的对象\n2. 线程可以`get_stop_token`获得token\n3. 线程可以`request_stop`通知停止\n    1. 旧的让线程停止的手段：需要建立如Windows下的Event，通过Event让线程停止。现在这种`stop_token`方法使线程停止更简洁了。\n\n\n1. 如果要传入`stop_token`，jthread的线程函数中内部的第1个参数必须写`std::stop_token`\n2. jthread提供了`request_stop`函数。提供了`get_stop_token`函数。\n\n以下程序表示：\n1. 主线程创建t1，内部有一个tok每100ms查看是否有外部请求停止。\n2. 程序执行3s后，主线程调用`t1.request_stop()`请求t1停止。\n```cpp\n#include <iostream>\n#include <thread>\n\nusing namespace std::chrono_literals;\nint main()\n{\n    std::jthread t1([](std::stop_token tok) -> void\n        {\n            for (int i = 0; i <= 100; ++i)\n            {\n                std::cout << i << std::endl;\n                if (tok.stop_requested())\n                {\n                    break;\n                }\n                std::this_thread::sleep_for(100ms);\n            }\n        });\n        \n    std::this_thread::sleep_for(3s);\n    t1.request_stop();\n    \n    t1.join();\n    return 0;\n}\n```\n### 应用场景\n传输文件过程中，通过token这种类似于信号的东西，用于控制另一个线程。（传统方法是需要WaitForSingleObject，较为繁琐）\n这是一种面向对象的设计，token可以通过传参传递，按照事件通知的方式，按需快速使用。\n### stop_possible\n可看[std::stop_token::stop_possible](https://en.cppreference.com/w/cpp/thread/stop_token/stop_possible)中的代码示例。\n### stop_source\n\njthread对象可以通过调用`get_stop_source`，返回与 `jthread` 对象内部保存的相同共享停止状态关联的 `std::stop_source`。\n\n获取到jthread的source后就不用操作jthread了，可以通过source进行：\n1. `source.get_token()`，就相当于`t1.get_stop_token()`\n2. `source.request_stop()`\n\n```cpp\n#include <iostream>\n#include <thread>\n#include<stop_token>\nusing namespace std::chrono_literals;\nint main()\n{\n    std::jthread t1([](std::stop_token tok) -> void\n        {\n            for (int i = 0; i <= 100; ++i)\n            {\n                std::cout << i << std::endl;\n                if (tok.stop_requested())\n                {\n                    break;\n                }\n                std::this_thread::sleep_for(100ms);\n            }\n        });\n    \n    auto source = t1.get_stop_source();\n    std::this_thread::sleep_for(3s);\n    source.request_stop();\n}\n```\n### stop_callback\n定义于`<stop_token>`，用于搭配`stop_token`使用，指示线程取消后进行的回调操作。\n1. 需要一个`stop_token`和一个函数作为构造\n2. 当该`stop_token`对应的线程得到`stop_requested`信号时，调用`stop_callback`构造时绑定的函数。\n\n```cpp\n#include <iostream>\n#include <thread>\n#include <stop_token>\nusing namespace std::chrono_literals;\nint main()\n{\n    std::jthread t1([](std::stop_token tok) -> void\n        {\n            for (int i = 0; i <= 100; ++i)\n            {\n                std::cout << i << std::endl;\n                if (tok.stop_requested())\n                {\n                    break;\n                }\n                std::this_thread::sleep_for(100ms);\n            }\n        });\n\n    std::stop_callback cb{ t1.get_stop_token(), []() -> void\n        {\n            std::wcout << L\"Stopped!\" << std::endl;\n        } };\n\n    std::this_thread::sleep_for(3s);\n    t1.request_stop();\n}\n```\n可能的输出：\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nStopped!\n28\n```\n# 条件变量（wait）\n从`C++11`就开始引入了\n\n类似于Windows下的信号（事件）。\n\n`Modern C++`中通用的用于通知、等待的工具。\n\n需要和锁配套使用，因为cv的wait方法需要传入一个`std::unique_lock<std::mutex>`参数\n\n以下程序说的是：\n1. 创建一个t1线程\n2. t1线程尝试拿mx锁\n3. 拿到mx后，在mx锁上面wait，释放锁，之后休眠（进入等待队列）\n4. 如果没有通知则一直阻塞。\n5. 主线程休眠3s\n6. 主线程notify通知等待队列，唤醒了t1线程。\n7. 子线程t1被唤醒后，必须重新获取锁，才能返回从而继续下一步。\n\n综上所述，wait有三大步骤：\n1. 释放锁\n2. 休眠，进入等待队列\n3. 被唤醒，尝试获取锁。\n    1. 如果成功则进行下一步操作。\n    2. 如果暂时没拿到锁则阻塞，直到拿到锁后才能进行下一步。\n        1. 但这是因抢锁而导致阻塞，和wait的等待队列是两码事！\n        2. 也就是说（再次强调）：wait是主动阻塞（wait之前拿到了锁，但是条件为假，主动放弃了锁）。而一旦条件为真，且被唤醒后，抢锁没抢到，则是被动阻塞。\n\n除了这三大步骤，还有一大前提：系统假定在wait调用前，其中的mx互斥量已上锁。所以必须在拿到锁之后才能wait。\n```cpp\n#include <condition_variable>\n#include <mutex>\nstd::mutex mx;\nstd::condition_variable cv;\nusing namespace std::chrono_literals;\nint main()\n{\n    std::jthread t1([]() -> void\n    {\n        std::unique_lock lck{ mx };\n        cv.wait(lck);\n        for (int i = 0; i <= 100; ++i)\n        {\n            std::cout << i << std::endl;\n            \n            std::this_thread::sleep_for(100ms);\n        }\n    });\n    std::this_thread::sleep_for(3s);\n    cv.notify_one();\n}\n```\n### 注意事项\n据《操作系统导论》P252 30.1节 中的提示：\n>推荐在发notify信号时总是持有锁\n>\n>尽管并不是所有情况下都严格需要，但有效且简单的做法还是在使用条件变量发送notify信号时持有锁（指要发送notify的线程）。有的例子是必须加锁的情况，但也有一些情况可以不加锁，而这可能是你应该避免（避免再去分情况考虑）的。因此，**为了简单**，请在调用 signal（也就是notify） 时持有锁（hold the lock when calling signal）。\n>\n>这个提示的反面，即调用 wait 时持有锁，但这就不只是建议了，wait 的语义是强制要求前提持有锁的。因为 wait 调用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。\n>\n>因此，可以提出一般化形式，保证程序正确：调用 signal 和 wait 时都要持有锁（hold the lock when calling signal or wait）。\n\n就拿上面的例子来说，如果不对`notify_one`加以同步控制的话，有可能t1线程在lck上锁的时候，主线程恰好`notify_one`，导致在其wait之前唤醒，则wait之后再也没有唤醒的机会，程序就一直阻塞了。\n\n所以，在主线程中的`cv.notify_one()`语句之前加锁（记得和t1中mutex变量一致）。\n而且既然在`cv.notify_one()`之前加了锁，就要在`cv.notify_one()`之后解锁，是因为wait被唤醒之后还需要得到锁才能脱离阻塞继续下一步操作。\n```cpp\nint main()\n{\n    // t1 ...\n\n    std::this_thread::sleep_for(3s);\n    \n    std::unique_lock lck{ mx };    // add\n    cv.notify_one();\n    lck.unlock();                  // add\n    \n}\n```\n## wait_for\n```cpp\ntemplate <class Rep, class Period>\ncv_status wait_for (unique_lock<mutex>& lck, const chrono::duration<Rep,Period>& rel_time);\n```\n在wait的基础上，既可以通过获得通知得到唤醒，也可以计时超时得到唤醒。\n即：超时后与**被notify**的行为一样，尝试获取锁，如果成功则下一步，如果失败则阻塞。\n但返回值有特点，超时则返回`std::cv_status::timeout`，其他情况返回`std::cv_status::no_timeout`\n### 用处：结合notify来停止线程\nwait是用于通知线程**开始**下一步动作。\n而`wait_for`则可以用于通知线程**停止**。\n\n以下程序是说：2个条件变量，`cv`和`cv2`，`cv`用于`wait`，以决定何时开始。`cv2`用于`wait_for`，结合返回值status，在一段时间等待停止的信号。\n主线程：\n1. 在释放了cv对应的lck后，子线程wait成功获取到锁开始下一步。\n2. 休眠3s，保证子线程可以至少执行3s。\n3. 之后与子线程竞争lck2锁，一旦主线程拿到了，当即notify给cv2，之后释放锁。\n\n子线程：\n1. 在cv上等待，一旦获取lck则下一步。\n2. 每次for循环都先抢lck2锁\n    1. 在主线程休眠的3s内，肯定能抢到。并且每次wait_for释放锁也不会被别人抢，即不会被notify，所以返回值应该都是timeout\n    2. 3s主线程唤醒后，与主线程竞争lck2锁\n        1. 如果子先抢到了，则这一次for循环在wait_for时lck2释放50ms，如果主线程在此期间抢到了，并且发了notify，则status为`no_timeout`，子线程break结束。此情况下只能打印一半。\n        2. 也有可能：for每次循环结束时，释放锁，主线程在很小很小的空挡内抢到锁，导致提前notify，错过cv2等待的时机，但是这个可能很小。此情况下1000个数全部输出。\n\n```cpp\n#include <condition_variable>\n#include <mutex>\n#include <iostream>\nstd::mutex mx, mx2;\nstd::condition_variable cv, cv2;\nusing namespace std::chrono_literals;\nint main()\n{\n    std::jthread t1([]() -> void\n    {\n        std::unique_lock lck{ mx };\n        cv.wait(lck);\n        std::cout << \"Got the Notify to Start!\" << std::endl;\n\n        for (int i = 0; i <= 1000; ++i)\n        {\n            std::cout << i << std::endl;\n\n            std::unique_lock lck2{ mx2 };\n            if (auto status = cv2.wait_for(lck2, 50ms);\n                status == std::cv_status::no_timeout)\n            {\n                std::cout << \"Got the Notify to Out!\" << std::endl;\n                break;\n            }\n            else\n            {\n                std::cout << \"Timeout: No Notify\" << std::endl;\n            }\n        }\n    });\n    std::this_thread::sleep_for(1s);\n    std::unique_lock lck{ mx };\n    cv.notify_one();\n    lck.unlock();\n    std::this_thread::sleep_for(3s);\n    std::unique_lock lck2{ mx2 };\n    cv2.notify_one();\n    lck2.unlock();\n}\n```\n输出\n```\nGot the Notify to Start!\n0\nTimeout: No Notify\n1\nTimeout: No Notify\n2\nTimeout: No Notify\n3\nTimeout: No Notify\n4\nTimeout: No Notify\n5\nTimeout: No Notify\n6\nTimeout: No Notify\n7\nTimeout: No Notify\n8\nTimeout: No Notify\n9\nTimeout: No Notify\n10\nTimeout: No Notify\n11\nTimeout: No Notify\n12\nTimeout: No Notify\n13\nTimeout: No Notify\n14\nTimeout: No Notify\n15\nTimeout: No Notify\n16\nTimeout: No Notify\n17\nTimeout: No Notify\n18\nTimeout: No Notify\n19\nTimeout: No Notify\n20\nTimeout: No Notify\n21\nTimeout: No Notify\n22\nTimeout: No Notify\n23\nTimeout: No Notify\n24\nTimeout: No Notify\n25\nTimeout: No Notify\n26\nTimeout: No Notify\n27\nTimeout: No Notify\n28\nTimeout: No Notify\n29\nTimeout: No Notify\n30\nTimeout: No Notify\n31\nTimeout: No Notify\n32\nTimeout: No Notify\n33\nTimeout: No Notify\n34\nTimeout: No Notify\n35\nTimeout: No Notify\n36\nTimeout: No Notify\n37\nTimeout: No Notify\n38\nTimeout: No Notify\n39\nTimeout: No Notify\n40\nTimeout: No Notify\n41\nTimeout: No Notify\n42\nTimeout: No Notify\n43\nTimeout: No Notify\n44\nTimeout: No Notify\n45\nTimeout: No Notify\n46\nTimeout: No Notify\n47\nTimeout: No Notify\n48\nGot the Notify to Out!\n```\n### 问题\n上面那个程序，经过VS编译运行在Windows11时，很有可能会出现这种情况：\n（为了让问题更加明显，主线程部分代码改为以下：加长了第二段睡眠时间，并且在睡眠前后加输出提示）\n```cpp\nint main()\n{\n    // ...\n    std::this_thread::sleep_for(1s);\n    std::wcout << L\"After Sleep 1s...\" << std::endl;\n    \n    std::unique_lock lck{ mx };\n    cv.notify_one();\n    lck.unlock();\n    \n    std::wcout << L\"Before Sleep 8s...\" << std::endl;\n    std::this_thread::sleep_for(8s);\n    std::wcout << L\"After Sleep 8s...\" << std::endl;\n    std::unique_lock lck2{ mx2 };\n    cv2.notify_one();\n    lck2.unlock();\n}\n```\n主线程明明8秒后才会notify_one，但是某时的输出结果下，居然很快就让子线程停止了，这是怎么回事？\n观察输出信息，发现，主线程还没输出`After Sleep 8s...`，子线程就被通知了，证明notify肯定不是主线程发出的。\n```\nAfter Sleep 1s...\nBefore Sleep 8s...\nGot the Notify to Start!\n0\nTimeout: No Notify\n1\nTimeout: No Notify\n2\nTimeout: No Notify\n3\nTimeout: No Notify\n4\nTimeout: No Notify\n5\nGot the Notify to Out!\n\n```\n## 假唤醒\n在wait（普通、for、until）等待过程中，线程可能会因为假唤醒而提前被唤醒，而不是因为条件变量被通知。\n\n假唤醒可以看作是操作系统故意替程序员`notify_one`，会让子线程会认为`wait_for`已经被唤醒，从而退出循环。\n\n>普通的`wait`在Windows下不会假唤醒。而在Unix、Linux、Solaris、AIX中行为可能会不同。\n\n在当前的代码中，当`wait_for`返回时，仅通过检查`timeout`与否来决定是否退出循环。如果是因为假唤醒而返回，`status == std::cv_status::no_timeout`可能依然为真，这会导致线程提前结束。\n\n为了防止假唤醒带来的问题，通常的做法是在等待后检查共享条件变量状态是否满足。你可以通过在`wait_for`之后再检查一个bool标志（例如`stop_requested`）来决定是否退出循环。\n在上面的程序中，在全局区定义它，初值为false，并且在`cv2.notify_one`语句之前置为true。这样，不仅要通过判断是否timeout，还要判断bool标志，以确信是我们自己发出的唤醒。\n```cpp\n#include <condition_variable>\n#include <mutex>\n#include <iostream>\nstd::mutex mx, mx2;\nstd::condition_variable cv, cv2;\nbool stop_requested = false;\nusing namespace std::chrono_literals;\nint main()\n{\n    std::jthread t1([]() -> void\n    {\n        std::unique_lock lck{ mx };\n        cv.wait(lck);\n        std::cout << \"Got the Notify to Start!\" << std::endl;\n\n        for (int i = 0; i <= 1000; ++i)\n        {\n            std::cout << i << std::endl;\n\n            std::unique_lock lck2{ mx2 };\n            if (auto status = cv2.wait_for(lck2, 50ms);\n                status == std::cv_status::no_timeout && stop_requested == true)\n            {\n                std::cout << \"Got the Notify to Out!\" << std::endl;\n                break;\n            }\n            else\n            {\n                std::cout << \"Timeout: No Notify\" << std::endl;\n            }\n        }\n    });\n    std::this_thread::sleep_for(1s);\n    std::wcout << L\"After Sleep 1s...\" << std::endl;\n\n    std::unique_lock lck{ mx };\n    cv.notify_one();\n    lck.unlock();\n\n    std::wcout << L\"Before Sleep 8s...\" << std::endl;\n    std::this_thread::sleep_for(8s);\n    std::wcout << L\"After Sleep 8s...\" << std::endl;\n    \n    std::unique_lock lck2{ mx2 };\n    stop_requested = true;\n    cv2.notify_one();\n    lck2.unlock();\n}\n```\n### 可用lambda表达式作为谓词简化代码\n```cpp\nwait(lck, [&stop_requested]() -> bool { return stop_requested; });\n```\n输出\n```\nAfter Sleep 1s...\nBefore Sleep 8s...\nGot the Notify to Start!\n0\nTimeout: No Notify\n1\nTimeout: No Notify\n2\nTimeout: No Notify\n3\nTimeout: No Notify\n4\nTimeout: No Notify\n5\nTimeout: No Notify\n6\nTimeout: No Notify\n7\nTimeout: No Notify\n8\nTimeout: No Notify\n9\nTimeout: No Notify\n10\nTimeout: No Notify\n11\nTimeout: No Notify\n12\nTimeout: No Notify\n13\nTimeout: No Notify\n14\nTimeout: No Notify\n15\nTimeout: No Notify\n16\nTimeout: No Notify\n17\nTimeout: No Notify\n18\nTimeout: No Notify\n19\nTimeout: No Notify\n20\nTimeout: No Notify\n21\nTimeout: No Notify\n22\nTimeout: No Notify\n23\nTimeout: No Notify\n24\nTimeout: No Notify\n25\nTimeout: No Notify\n26\nTimeout: No Notify\n27\nTimeout: No Notify\n28\nTimeout: No Notify\n29\nTimeout: No Notify\n30\nTimeout: No Notify\n31\nTimeout: No Notify\n32\nTimeout: No Notify\n33\nTimeout: No Notify\n34\nTimeout: No Notify\n35\nTimeout: No Notify\n36\nTimeout: No Notify\n37\nTimeout: No Notify\n38\nTimeout: No Notify\n39\nTimeout: No Notify\n40\nTimeout: No Notify\n41\nTimeout: No Notify\n42\nTimeout: No Notify\n43\nTimeout: No Notify\n44\nTimeout: No Notify\n45\nTimeout: No Notify\n46\nTimeout: No Notify\n47\nTimeout: No Notify\n48\nTimeout: No Notify\n49\nTimeout: No Notify\n50\nTimeout: No Notify\n51\nTimeout: No Notify\n52\nTimeout: No Notify\n53\nTimeout: No Notify\n54\nTimeout: No Notify\n55\nTimeout: No Notify\n56\nTimeout: No Notify\n57\nTimeout: No Notify\n58\nTimeout: No Notify\n59\nTimeout: No Notify\n60\nTimeout: No Notify\n61\nTimeout: No Notify\n62\nTimeout: No Notify\n63\nTimeout: No Notify\n64\nTimeout: No Notify\n65\nTimeout: No Notify\n66\nTimeout: No Notify\n67\nTimeout: No Notify\n68\nTimeout: No Notify\n69\nTimeout: No Notify\n70\nTimeout: No Notify\n71\nTimeout: No Notify\n72\nTimeout: No Notify\n73\nTimeout: No Notify\n74\nTimeout: No Notify\n75\nTimeout: No Notify\n76\nTimeout: No Notify\n77\nTimeout: No Notify\n78\nTimeout: No Notify\n79\nTimeout: No Notify\n80\nTimeout: No Notify\n81\nTimeout: No Notify\n82\nTimeout: No Notify\n83\nTimeout: No Notify\n84\nTimeout: No Notify\n85\nTimeout: No Notify\n86\nTimeout: No Notify\n87\nTimeout: No Notify\n88\nTimeout: No Notify\n89\nTimeout: No Notify\n90\nTimeout: No Notify\n91\nTimeout: No Notify\n92\nTimeout: No Notify\n93\nTimeout: No Notify\n94\nTimeout: No Notify\n95\nTimeout: No Notify\n96\nTimeout: No Notify\n97\nTimeout: No Notify\n98\nTimeout: No Notify\n99\nTimeout: No Notify\n100\nTimeout: No Notify\n101\nTimeout: No Notify\n102\nTimeout: No Notify\n103\nTimeout: No Notify\n104\nTimeout: No Notify\n105\nTimeout: No Notify\n106\nTimeout: No Notify\n107\nTimeout: No Notify\n108\nTimeout: No Notify\n109\nTimeout: No Notify\n110\nTimeout: No Notify\n111\nTimeout: No Notify\n112\nTimeout: No Notify\n113\nTimeout: No Notify\n114\nTimeout: No Notify\n115\nTimeout: No Notify\n116\nTimeout: No Notify\n117\nTimeout: No Notify\n118\nTimeout: No Notify\n119\nTimeout: No Notify\n120\nTimeout: No Notify\n121\nTimeout: No Notify\n122\nTimeout: No Notify\n123\nTimeout: No Notify\n124\nTimeout: No Notify\n125\nTimeout: No Notify\n126\nTimeout: No Notify\n127\nTimeout: No Notify\n128\nTimeout: No Notify\n129\nAfter Sleep 8s...\nGot the Notify to Out!\n\n```\n## wait_until\n```cpp\ntemplate <class Clock, class Duration>\ncv_status wait_until (unique_lock<mutex>& lck, const chrono::time_point<Clock,Duration>& abs_time);\n```\n和`wait_for`行为一样，不同点在于：\n1. `wait_for`的时间是时间段、间隔。\n2. `wait_until`的时间是时间点。\n# future\n在标头 `<future>` 中定义\n\n顾名思义，future就是为了用于获取返回值的。内部包装了一个任务或函数。\n\nfuture是给期待方使用来get获取值的。\npromise是给承诺方使用来set设置值的。\n\n以下程序表示：子线程期待一个值，此值由主线程提供。通过给子线程传入future实现。\n主线程定义一个promise，生成一个该promise的future传给t子线程函数。\n子线程调用`fut.get()`阻塞式等待主线程对fut相应的promise发送信息。\n一旦主线程向promise发送信息，子线程就会被通知，随后返回得到val。\n```cpp\n#include <future>\n#include <chrono>\nusing namespace std::chrono_literals;\nint main()\n{\n    std::promise<int> prom;\n    std::future<int> fut = prom.get_future();\n    std::jthread t([](std::future<int> fut) -> void\n        {\n            std::wcout << L\"Start & Wait...\" << std::endl;\n            int val = fut.get();\n            std::wcout << L\"Got a value: \" << val << std::endl;\n        }, std::move(fut));\n        \n    std::this_thread::sleep_for(5s);\n    prom.set_value(50);\n    std::this_thread::sleep_for(1s);\n}\n```\n输出：\n```\nStart & Wait...\nGot a value: 50\n```\n## shared_future\n用`shared_future`可以让多个线程同时监听一个共享的future。\n调用`fut.share()`即可获得`shared_future`类型的future，可以传入到线程函数中使用。\n\n不要多次调用`fut.share()`，否则之前的`shared_future`会失效。\n\n```cpp\nint main()\n{\n    std::promise<int> prom;\n    auto fut = prom.get_future();\n    auto shared_fut = fut.share();\n\n    std::jthread t1([](std::shared_future<int> shared_fut) -> void\n        {\n            std::wcout << L\"t1 Start & Wait...\" << std::endl;\n            auto val = shared_fut.get();\n            std::wcout << L\"t1 Got a value: \" << val << std::endl;\n        }, shared_fut);\n    std::jthread t2([](std::shared_future<int> shared_fut) -> void\n        {\n            std::wcout << L\"t2 Start & Wait...\" << std::endl;\n            auto val = shared_fut.get();\n            std::wcout << L\"t2 Got a value: \" << val << std::endl;\n        }, shared_fut);\n    std::this_thread::sleep_for(5s);\n    prom.set_value(50);\n    std::this_thread::sleep_for(1s);\n}\n```\n输出：\n```\nt2 Start & Wait...\nt1 Start & Wait...\nt2 Got a value: 50\nt1 Got a value: 50\n```\n## packaged_task\n用于从子线程获得输出值。\n\n与promise一样，packaged_task 是承诺方，是给出值的。可以调用get_future获得其对应的future。期待方可以通过此future获取其返回值。\n\n创建子线程时，传入定义好的 packaged_task，需要`std::move`移动。\n\n以下程序表示：主线程期待一个值，此值由子线程提供。通过给子线程传入 packaged_task 实现。\n```cpp\n#include <future>\nusing namespace std::chrono_literals;\nint main()\n{\n    std::packaged_task<int(int)> pkg{ [](int v) -> int\n        {\n            for (auto i = v; i >= 0; --i)\n            {\n                std::cout << i << std::endl;\n                std::this_thread::sleep_for(200ms);\n            }\n            return 3;\n        }};\n    \n    auto fut = pkg.get_future();\n    \n    std::jthread t(std::move(pkg), 50);\n    \n    int v = fut.get();          // block\n    std::wcout << L\"main thread got a value: \" << v << std::endl;\n}\n```\n## async\n相当于包装好的`thread(packaged_task, ...)`。可以直接返回一个future。并且定义后相当于直接创建了子线程。\n1. 参数1：Launch Policy\n    1. 有两个选项：`std::launch::deferred`、`std::launch::async`。\n    2. 默认是`std::launch::async`，意为立即执行。\n    3. `std::launch::deferred`意为在他人`fut.get()`时才执行。\n2. 参数2：fn\n3. 参数3：函数参数\n\n以下程序表示：主线程期待一个值，此值由子线程提供。通过async创建子线程实现。\n```cpp\nint main()\n{\n    auto fut = std::async([](int v) -> int\n        {\n            for (auto i = v; i > 0; --i)\n            {\n                std::cout << i << std::endl;\n                std::this_thread::sleep_for(200ms);\n            }\n            return 3;\n        }, 50);\n    int v = fut.get();\n    std::wcout << L\"main thread got a value: \" << v << std::endl;\n}\n```\n以上是async的简单应用。\n### 异步特性（async）\n还有一些特性：所谓异步，就是主线程、async动作互不干扰。比如：\nasync启动后，主线程打印内容至屏幕、Sleep等等，不会出现和子线程输出的错乱（除了换行以外）。\n```cpp\nint main()\n{\n    auto fut = std::async([](int v) -> int\n        {\n            for (auto i = v; i > 0; --i)\n            {\n                std::cout << i << std::endl;\n                std::this_thread::sleep_for(200ms);\n            }\n            return 3;\n        }, 50);\n    \n    std::wcout << L\"main thread begin to Sleep...\" << std::endl;\n    std::this_thread::sleep_for(5s);\n    std::wcout << L\"main thread Wake up\" << std::endl;\n    int v = fut.get();\n    std::wcout << L\"main thread got a value: \" << v << std::endl;\n}\n```\n输出：\n```\nmain thread begin to Sleep...50\n\n49\n48\n47\n46\n45\n44\n43\n42\n41\n40\n39\n38\n37\n36\n35\n34\n33\n32\n31\n30\n29\n28\n27\n26\nmain thread Wake up\n25\n24\n23\n22\n21\n20\n19\n18\n17\n16\n15\n14\n13\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\nmain thread got a value: 3\n\n```\n### deferred特性\n至于`std::launch::deferred`。经过测试：\n```cpp\nint main()\n{\n    auto fut = std::async(std::launch::deferred,\n        [](int v) -> int\n        {\n            for (auto i = v; i > 0; --i)\n            {\n                std::cout << i << std::endl;\n                std::this_thread::sleep_for(200ms);\n            }\n            return 3;\n        }, 50);\n    \n    std::wcout << L\"main thread begin to Sleep...\" << std::endl;\n    std::this_thread::sleep_for(5s);\n    std::wcout << L\"main thread Wake up\" << std::endl;\n    int v = fut.get();\n    std::wcout << L\"main thread got a value: \" << v << std::endl;\n}\n```\n发现，输出：\n```\nmain thread begin to Sleep...\nmain thread Wake up\n50\n49\n48\n47\n46\n45\n44\n43\n42\n41\n40\n39\n38\n37\n36\n35\n34\n33\n32\n31\n30\n29\n28\n27\n26\n25\n24\n23\n22\n21\n20\n19\n18\n17\n16\n15\n14\n13\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\nmain thread got a value: 3\n\n```\n意味着，该启动策略表示等待主线程先执行一部分内容，直到主线程开始`fut.get()`时，async再启动。\n# 信号量\n## 信号量和条件变量的对比\n条件变量的场景用于精确控制线程的同步，适合同步条件更复杂的场景（条件变量可以搭配一个计数器来达到信号量的效果）。\n\n信号量的使用场景是可以简单地控制对资源的并发访问数量。\n\n条件变量的使用较为灵活，需要手动精确控制加锁。\n而信号量的使用就很简单，简单地对计数器加减就是线程安全的。\n## API\n`C++20`开始。定义于`<semaphore>`\n根据cppreference，信号量是一种轻量级同步原语，用于限制对共享资源的并发访问。信号量相比条件变量更高效，因为条件变量用到了mutex。\n分两种：\n1. `counting_semaphore`，非负值。\n2. `binary_semaphore`，二值。\n\n```cpp\ntemplate<std::ptrdiff_t = /* implementation-defined */>\nclass counting_semaphore;\n\nusing binary_semaphore = std::counting_semaphore<1>;\n```\n## 示例：改写Windows信号量API\n用`C++`线程库信号量改写——《Windows_多线程》中[示例：多个进度条同时动画](#示例：多个进度条同时动画)\n比如：`std::counting_semaphore<5> semaphore(3);`代表最大值为5，初始值为3。如果最大值不填，则默认给一个超大的数。\n以下例子：`std::counting_semaphore<2> semaphore(2);`代表最大值为2，初始值为2。\n```cpp\n#include <semaphore>\nstd::counting_semaphore<2> semaphore(2);\n\n// ...\n{\n    {\n        std::jthread t([]() -> void\n        {\n            std::unique_lock lck{ start_mx };\n            start_cv.wait(lck);\n            lck.unlock();\n            semaphore.acquire();\n            for (int i = 0; i < 100; ++i)\n            {\n                // ...\n            }\n            semaphore.release();\n        });\n    }\n}\n```\n## 二值信号量当作条件变量使用\n其实就是：`using binary_semaphore = std::counting_semaphore<1>;`\n```cpp\nstd::binary_semaphore bin_sema{ 0 };\n// ...\n{\n    // ...\n    case /* ... */:\n    {\n        std::jthread t([]() -> void\n        {\n            bin_sema.acquire();\n            bin_sema.release(1);\n            \n            semaphore.acquire();\n            for (int i = 0; i < 100; ++i)\n            {\n                // ...\n            }\n            semaphore.release();\n        });\n    }\n    // ...\n    case WM_KETDOWN:\n    {\n        if (wParam == 'F')\n        {\n            bin_sema.release(1);\n        }\n    }\n    \n}\n```\n# 闩锁（Latch）、屏障（Barrier）\n闩锁和屏障是线程协调机制，允许任意数量的线程阻塞，直到预期数量的线程到达。闩锁不能重复使用，而屏障可以重复使用。\n\n主要用于等待n个线程到位，之后做一些事情。\n屏障（Barrier）使用之后可以reset重新使用。","categories":["操作系统","多线程","Cpp","Modern"]},{"title":"Cpp_右值引用_move的实现","url":"/Cpp/Cpp_右值引用_move的实现/","content":"# 内容\n\n1. 右值引用的例子\n2. 右值引用的实现\n\n# 右值引用的例子\n\n```c++\nusing namespace std;\nclass MyString\n{\n    char* str;\npublic:\n    MyString(const char* p = NULL) : str(NULL)\n    {\n        if(p != NULL)\n        {\n            int len = strlen(p) + 1;\n            str = new char[len];\n            strcpy_s(str, len, p);\n        }\n    }\n    MyString(const MyString & src) : str(NULL)\n    {\n        if(src.str != NULL)\n        {\n            int len = strlen(src.str) + 1;\n            str = new char[len];\n            strcpy_s(str, len, src.str);\n        }\n    }\n    MyString(MyString && src) : str(src.str)\n    {\n        src.str = NULL;\n    }\n    ~MyString()\n    {\n        if(str != NULL)\n        {\n            delete[]str;\n        }\n        str = NULL;\n    }\n}\nint main()\n{\n    MyString s1(\"xcgong\");\n    MyString s2(s1);\n    MyString s3(std::move(s1));\t//实质上是把s1“强转”为 右值引用 才能进行移动构造\n    \n    \n}\n```\n\n# move的实现\n\n```c++\ntemplate<class _Ty>\nstruct my_remove_reference\n{\n    using type = _Ty;\n    using _Const_thru_ref_type = const _Ty;\n}\ntemplate<class _Ty>\nstruct my_remove_reference<_Ty&>\n{\n    using type = _Ty;\n    using _Const_thru_ref_type = const _Ty &;\n}\ntemplate<class _Ty>\nstruct my_remove_reference<_Ty&&>\n{\n    using type = _Ty;\n    using _Const_thru_ref_type = const _Ty &&;\n}\n\ntemplate<class _Ty>\nusing my_remove_reference_t = typename my_remove_reference<_Ty>::type;\n//my_remove_reference_t<Object> --> my_remove_reference<Object>::type;\ntemplate<class _Ty>\nmy_remove_reference_t<_Ty>&& my_move(_Ty && _Arg)\n{\n    \t\t\t\t\t\t\t\t//强转为_Ty纯粹类型的右值引用形式\n    return static_cast<my_remove_reference_t<_Ty> &&>(_Arg);\n}\nint main()\n{\n    MyString s1(\"xcgong\");\n    MyString s2(xcg::my_move(s1));\n/*\n\tmy_move  ->\n\t    return static_cast<my_remove_reference_t<_Ty> &&>(_Arg);\n\t\t\tmy_remove_reference_t<_Ty>  ->\n\t\t\t\tmy_remove_reference<_Ty>::type  ->\n\t\t\t\t\tmy_remove_reference<MyString>::type  ->\n\t\t\t\t\t\ttype == _Ty -> \"MyString\"\n\t--> return static_cast<MyString &&>(_Arg);\n\t效果: _Arg 由 MyString 转为 MyString &&\t\n则--MyString s2(xcg::my_move(s1))--等效于:\n\tMyString s2( (MyString &&)s1);\n\t\t调用：MyString(MyString && src), 即移动构造。进行资源拥有权的转移\n*/\n}\n```\n\n# 引用类型与模板结合\n\n可测试`is_lvalue_reference`，这是个模板类，定义于`<type_traits>`中。\n```cpp\n#include <iostream>\n#include <type_traits>\n \nclass A {};\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << std::is_lvalue_reference<A>::value << '\\n';\n    std::cout << std::is_lvalue_reference<A&>::value << '\\n';\n    std::cout << std::is_lvalue_reference<A&&>::value << '\\n';\n    std::cout << std::is_lvalue_reference<int>::value << '\\n';\n    std::cout << std::is_lvalue_reference<int&>::value << '\\n';\n    std::cout << std::is_lvalue_reference<int&&>::value << '\\n';\n}\n/* Output:\n    false\n    true\n    false\n    false\n    true\n    false\n*/\n```\n可测试`is_rvalue_reference`，这是个模板类，定义于`<type_traits>`中。\n```cpp\n#include <type_traits>\n#include <iostream>\n \nclass A {};\n \nstatic_assert\n(\n    std::is_rvalue_reference_v<A> == false and\n    std::is_rvalue_reference_v<A&> == false and\n    std::is_rvalue_reference_v<A&&> != false and\n    std::is_rvalue_reference_v<char> == false and\n    std::is_rvalue_reference_v<char&> == false and\n    std::is_rvalue_reference_v<char&&> != false\n);\n \n \n \ntemplate <typename T>\nvoid test(T&& x)\n{\n    static_assert(std::is_same_v<T&&, decltype(x)>);\n    std::cout << \"T\\t\" << std::is_rvalue_reference<T>::value << '\\n';\n    std::cout << \"T&&\\t\" << std::is_rvalue_reference<T&&>::value << '\\n';\n    std::cout << \"decltype(x)\\t\" << std::is_rvalue_reference<decltype(x)>::value << '\\n';\n}\n \nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << \"A\\t\" << std::is_rvalue_reference<A>::value << '\\n';\n    std::cout << \"A&\\t\" << std::is_rvalue_reference<A&>::value << '\\n';\n    std::cout << \"A&&\\t\" << std::is_rvalue_reference<A&&>::value << '\\n';\n    std::cout << \"char\\t\" << std::is_rvalue_reference<char>::value << '\\n';\n    std::cout << \"char&\\t\" << std::is_rvalue_reference<char&>::value << '\\n';\n    std::cout << \"char&&\\t\" << std::is_rvalue_reference<char&&>::value << '\\n';\n \n    std::cout << \"\\ntest(42)\\n\";\n    test(42);\n \n    std::cout << \"\\ntest(x)\\n\";\n    int x = 42;\n    test(x);\n}\n/*\n    A\tfalse\n    A&\tfalse\n    A&&\ttrue\n    char\tfalse\n    char&\tfalse\n    char&&\ttrue\n     \n    test(42)\n    T\tfalse\n    T&&\ttrue\n    decltype(x)\ttrue\n     \n    test(x)\n    T\tfalse\n    T&&\tfalse\n    decltype(x)\tfalse\n*/\n```\n\n```cpp\ntemplate<class T>\nvoid fac(T &&a)\n{\n    \n}\n```","categories":["Cpp","右值引用"]},{"title":"Cpp_类型转换","url":"/Cpp/Cpp_类型转换/","content":"# 内容\n1. 总述\n2. 通过单参数的构造函数实现类型转换\n3. 通过类型转换运算符实现类型转换\n4. explicit\n5. 隐式转换\n6. 四个关键字\n    1. `static_cast`\n    2. `const_cast`\n    3. `reinterpret_cast`\n    4. `dynamic_cast`\n# 类型转换运算符\n使用接收单参数的构造函数执行类型转换虽然便捷，但有时候并非如愿。\n并且构造函数无法指定：\n1. 从用户自定义类型向内置类型的隐式转换（因为内置类型不是类）\n2. 从新类到先前定义的类的转换，（而不修改旧类的声明？）。\n\n我们可以通过为源类型定义一个类型转换运算符(conversion operator)来解决上述问题。成员函数`X::operator T()`定义了从X到T的类型转换，其中T是一个类型名。例如，我们定义一种只占6个二进制位的整数Tiny。我们希望在算术运算中它可以和普通的整数完美地融合在一起，并且当Tiny的值超出其范围时抛出`Bad_range`异常：\n\n```c++\nclass Tiny\n{\n    char v;\n    void assign(int i)\n    {\n        // 检查是否越界\n        if(i & ~077) throw Bad_range();\n        v = i;\n    }\n    class Bad_range{};\n    Tiny(int i)\t\t\t\t//用int构造Tiny\n    {\n        assign(i);\n    }\n    Tiny & operator=(int i)\t//int赋值给Tiny\n    {\n        assign(i);\n        return *this;\n    }\n    //默认的拷贝构造 和 同类赋值重载\n    Tiny(const Tiny&) = default;\n    Tiny & operator=(const Tiny&) = default;\n    operator int() const\n    {\n        return v;\t//conversion to int\n    }\n}\n```\n\n用int初始化Tiny或者给它赋值时进行越界检查（溢出，包括上溢、下溢）。相反，当拷贝Tiny的时候无须检查是否越界，因此默认的拷贝构造函数和赋值运算是正确的，无须修改。\n\n为了让Tiny可以使用int的常规操作，我们定义了从Tiny向int的隐式类型转换`Tiny::operator int()`。请注意，目标类型已经作为运算符名字的一部分出现，因此不必再重复出现在转换函数返回值的位置了。\n\n```c++\nTiny::operator int() const {return v;}\t\t//正确\nint Tiny::operator int() const {return v;}\t//错误，没必要加返回类型\n```\n\n从这层意义上来说，类型转换运算符类似于构造函数。\n\n如果在需要int的地方出现了Tiny，它会自动转换为对应的int值。例如：\n\n```c++\nint main()\n{\n    Tiny c1 = 2;\t\t//调用 Tiny(int)\n    Tiny c2 = 62;\n    Tiny c3 = c2 - c1;\n    Tiny c4 = c3;\n    int i = c1 + c2;\t//调用 operator int()\n    c1 = c1 + c2;\t\t\n    i = c3 - 64;\t\t//调用 operator int()\n    c2 = c3 - 64;\n    c3 = c4;\n}\n```\n\n通常情况下，最好尽量避免使用类型转换运算符，一旦过度使用的话可能引起程序的二义性。如果既有用户自定义的类型转换函数，又有用户自定义的运算符，则这两者间可能产生二义性。例如：\n\n```c++\nint operator+(Tiny, Tiny);\nvoid f(Tiny t, int i)\n{\n    t + i;\t//错误，二义性问题：\"operator+(t, Tiny(i))\" 还是 \"int(t)+i\" ?\n}\n```\n\n因此，对于某种给定的数据类型，最好不要同时提供用户自定义的类型转换和用户自定义的运算符，在它们之间选择一种即可。\n\n# explicit类型转换运算符\n\n类型转换运算符也许能用在代码的任何地方。然而，最优的选择是把类型转换运算符声明成explicit并且明确只有当**直接初始化**时才能使用它，当然我们也可以在此处使用等价的excplict构造函数。例如，标准库unique_ptr含有一个转换目标为bool的转换运算符。\n\n```c++\ntemplate<typename T, typename D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    // ...\n    explicit operator bool() const noexcept;\t//\n};\n```\n\n之所以把这个类型转换运算符声明成explicit是因为他可能出现在某些意想不到的上下文中。\n\n```c++\nvoid use(unique_ptr<Record> p, unique_ptr<int> q)\n{\n    if(!p)\t\t\t//这是正确的用法，!p 调用 operator bool()\n        throw Invalid_unique_ptr{};\n    bool b = p;\t\t//禁止的用法\t禁止把p隐式转换为bool\n    int x = p+q;\t//禁止的用法\t禁止把p、q隐式转换为bool/int\n}\n```\n# 四个cast关键字\n## static_cast\n### 用与基本类型间的转换\n这些基本类型大都可以进行隐式转换。如把int转换为char，把int转换为float/double。\n\n```c++\nint main()\n{\n    float f = 12.23;\n    int a = (int)f;\t\t//虽然达到了强转的效果，但是强转的目的没有写出\n    int b = static_cast<int>f;\n}\n```\n\n```cpp\nint main()\n{\n    int a = 10;\n    char ch = 'a';\n    double dx = 12.23;\n    \n    a = ch;//ok\n    ch = a;//ok\n    a = static_cast<int>(ch);//ok\n    ch = static_cast<char>(a);//ok\n    \n    a = dx;//ok\n    dx = a;//ok\n    a = static_cast<int>(dx);//ok\n    dx = static_cast<double>(dx);//ok\n}\n```\n### 用于指针转换\n\n```cpp\nint main()\n{\n    int a = 10;\n    int * ip = nullptr;\n    ip = &a;//ok\n    ip = (int*)&a;//有脱裤子放屁的嫌疑;\n    ip = static_cast<int*>(&a);//ok\n}\n```\n\n```cpp\nint main()\n{\n    const int a = 10;\n    int * ip = nullptr;\n    ip = &a;//error\n    ip = (int*)&a;//ok, c语言原生方法\n    ip = static_cast<int*>(&a);//error, a是一个const量\n    return 0;\n}\n```\n\n```cpp\nint main()\n{\n    const int a = 10;\n    const int * ip = nullptr;\n    ip = &a;//ok\n    ip = (int*)&a;//ok, const int * 可以接收int *\n    ip = static_cast<const int*>(&a);//ok\n}\n```\n\n```cpp\nint main()\n{\n    int a = 10;\n    char * cp = nullptr;\n    cp = static_cast<char*>(&a);//error, 对于指针类型, int*和char*不同。\n}\n```\n### 总结\n综上所述，`static_cast`不仅能针对基本类型，还可以进行针对指针类型，要求只有一个，即`static_cast`进行的类型转换，结果接受者和转换者的类型要相同，或相互之间可以进行隐式转换。\n### static_cast不能去常性\n\n```cpp\nint main()\n{\n    const int a = 10;\n    int * p = nullptr;\n    p = static_cast<const int*>(&a);//error, p是int *, 而&a是const int *类型, int *不能接收const int *\n    p = static_cast<int*>(&a);//error, static_cast没有去常性的用法, 要用const_cast才行。\n}\n```\n### 引用之间的转换\n\n可以把左值强转为右值引用。\n\n```cpp\nint main()\n{\n    int a = 10;\n    int & b = static_cast<int&>(a);\n    int && c = static_cast<int&&>(a);//相当于int && c = (int&&)a;\n}\n```\n\n### `void*`之间的转换 - 不安全\n\n```cpp\nint main()\n{\n    int a = 10;//占4个字节\n    void * vp = &a;\n    char * cp = static_cast<char*>(vp);//把无类型指针转为了char*类型, 以1字节解析原来的4字节\n    float * fp = static_cast<float*>(vp);//把无类型指针转为了float*类型, 以4字节解析原来的4字节, 但是解析方式是把原来的4字节int内容看作float内容\n    double * dp = static_cast<double*>(vp);//把无类型指针转为了double*类型, 以8字节解析原来的4字节\n}\n```\n\n### 转为void - 以弃值为目的的转换\n\n把一个值转为void类型，语义是我们不需要这个值，即废弃。\n\n```cpp\nint main()\n{\n    int a = 10, b = 20;\n    static_cast<void>(a + b);\n}\n```\n\n### 继承关系中的转换\n\n```cpp\nclass Base\n{\nprivate:\n    int value;\npublic:\n    Base(int x = 0) : value(x) {}\n}\nclass Derived : public Base\n{\nprivate:\n    int num;\npublic:\n    Derived(int x = 0) : Base(x + 10), num(x) {}\n}\n```\n\n基于公有继承，父对象和子对象之间具备赋值兼容性规则。\n\n```cpp\nint main()\n{\n    Base * bp = nullptr;\n    Derived * dp = nullptr;\n    Base b;\n    Derived d;\n    \n    bp = &b;//ok, 父指针指向父对象\n    bp = &d;//ok, 父指针指向子对象\n    \n    bp = static_cast<Base*>(&b);//ok\n    bp = static_cast<Derived*>(&d);//ok\n    \n}\n```\n\n通过以上代码，我们可以得出，子对象指针可赋给父指针，这在继承关系中是上行转换。这在`static_cast`中是合法的、安全的。那么下行转换呢？\n\n```cpp\nint main()\n{\n    Base * bp = nullptr;\n    Derived * dp = nullptr;\n    Base b;\n    Derived d;\n    \n    dp = static_cast<Base*>(bp);//可以编译通过, 但是语义上是错误的。相当于用8字节的derived强行解释base的4字节内容被。\n}\n```\n\n![解释越界](../../images/Cpp_类型转换/解释越界.png)\n\n如图所示，dp本以为它指向的区域是一个derived对象，实际上，它指向的只是一个base对象，只拥有4字节。则dp解释此区域时，会把value4字节下面的4字节也解释到。实际上，下面额外的4个字节不归这个对象管理，这就造成了语义错误。因此，不可以把父地址传给子指针。但是`static_cast`不能检查这个错误的语义。\n\n要检查这个语义错误，需要使用`dynamic_cast`动态转换。\n## const_cast\n该关键字可以用来修改类型的const属性或volatile属性。\n```c++\nint main()\n{\n    const int a = 10;\n    int * p = (int*)&a;\t//虽然达到了强转的效果，但是强转的目的没有写出\n    int * q = const_cast<int*>&a;\t//此处明确指出const_cast:目的是去常性。\n}\n```\n\n```cpp\nint main()\n{\n    const int a = 10;\n    int x = const_cast<int>(a);//error, 脱裤子放屁, 多此一举, a本来就是int不带常性。\n}\n```\n\n```cpp\nint main()\n{\n    const int a = 10;\n    const int * cp = &a;\n    int * p = const_cast<int*>(&a);//ok\n    int * p = const_cast<int*>(cp);//ok\n}\n```\n\n```cpp\nint main()\n{\n    const int & cr = a;\n    int & r = const_cast<int&>(cr);//ok\n    int && rr = const_cast<int&&>(cr);//ok\n}\n```\n## reinterpret_cast\n\n指明了我们要拿新类型方式去解释原有数据。比如下面代码，原来cp的类型是`char *`指针，解释内存内容是按照一字节解释，并且输出时还会转义为相应字符。\n\n和c语言的强转有一拼，但是只适用于指针和引用，不适用于基本数据类型。\n\n而经过类型强转，用`int *`指针去解释cp指向的原始内容，比如`'a'`就变为了97。\n\n```c++\nint main()\n{\n    char c = 'a';\n    char * cp = &c;\n    //int * ip = (int*)cp;\t//虽然达到了强转的效果，但是强转的目的没有写出\n    int * ip = reinterpret_cast<int*>cp;\n}\n```\n\n```cpp\nint main()\n{\n    int a = 10;\n    char ch = 'x';\n    a = static_cast<int>(ch);//ok\n    a = reinterpret_cast<int>(ch);//error, 此关键字只适用于指针的重新解释(强转)\n}\n```\n\n```cpp\nint main()\n{\n    char ch = 'x';\n    int * ip = static_cast<int*>(&ch);//ok, 即拿int来解释ch的地址开始的4个字节。\n}\n```\n\n```cpp\nint main()\n{\n    char ch = 'x';\n    int &ra = static_cast<int&>(ch);//error, 因为static限制两方类型一致。\n    int &rb = reinterpret_cast<int&>(ch);//ok, 即拿int&来解释、引用ch的地址开始的4个字节\n}\n```\n\n## dynamic_cast\n\n对于内置类型（基本数据类型、指针类型）都是静态转换。\n\n对于自定义、自设计类型，如果不存在虚函数甚至不存在继承关系，则仍是静态转换；如果有继承关系且存在虚函数、多态性质，则需要动态转换，转换过程需要查虚表。\n\n通常用于有继承关系类型的指针类型之间的下行转换（比如，原本是父指针，但实际上是子对象，则可以用此关键字转为子指针类型）。\n\n```c++\nclass Base\n{\npublic:\n    virtual void fun() {}\n};\nclass Derived : public Base\n{\npublic:\n    virtual void fun() {}\n};\nint main()\n{\n    Base base;\n    Derived derived;\n    Base * bp;\n    Derived * dp;\n    bp = &derived;\n    dp = dynamic_cast<Derived*>(bp);\n}\n```\n\n除此之外，dynamic_cast还可以用于类层次间的上行转换（子指针换为父指针），和类之间的交叉转换（？）。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。\n\n### dynamic_cast自实现\n\n```c++\n#include<iostream>\nusing namespace std;\nclass Base\n{\npublic:\n    virtual void fun() {}\n};\nclass Derived : public Base\n{\npublic:\n    virtual void fun() {}\n};\ntemplate<class _Ty_dest, class _Ty_src>\n_Ty_dest my_dynamic_cast(_Ty_src src)\n{\n    _Ty_dest tmp = (_Ty_dest)src;\n    //cout << typeid(*tmp).name() << endl;\n    //cout << typeid(*src).name() << endl;\n    if (typeid(*tmp) == typeid(*src))\n        return (_Ty_dest)src;\n    else\n        return NULL;\n}\nint main()\n{\n    Base base;\n    Derived derived;\n    Base* bp = &derived;\n    Derived* dp;\n    bp = &derived;\n    //cout << typeid(Derived).name() << endl;\n    //cout << typeid(*bp).name() << endl;\n    dp = my_dynamic_cast<Derived*>(bp);\n    cout << dp << endl;\n}\n```\n\n# RTTI\n\n全名Run Time Type identification。运行时类型识别。通常以指针形式存在虚表中，实际内容存储在rodata区中，对象类型是type_info类型，成员有：`==、!=、name()、before(type_info)`。\n\ndynamic_cast的运行需要检查传入的参数的实际类型是否与模板参数类型一致。\n\n运行时类型识别的功能由两个运算符实现：\n\n1. `typeid`运算符，用于返回表达式的类型；\n2. `dynamic_cast`运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。\n\n## 对于内置类型、指针的类型识别\n\n属于静态识别范畴，即编译时识别。\n\n```cpp\nint main()\n{\n    int * ip = new int(10);\n    int ar[10] = {1, 2, 3};\n    int(*par)[10] = &ar;\n    cout << typeid(ip).name() << endl;  //\"int *\"\n    cout << typeid(*ip).name() << endl; //\"int\"\n    cout << typeid(par).name() << endl; //\"int (*) [10]\"\n    cout << typeid(*par).name() << endl;//\"int [10]\"\n}\n```\n\n## 对于自定义类型\n\n```cpp\nclass Object\n{\nprivate:\n    int value;\npublic:\n    Base(int x = 0) : num(x) {}\n    ~Base() {}\n}\n```\n\n### 不带const的情况\n\n```cpp\nint main()\n{\n    Object obj;\n    Object * op = &obj;\n    cout << typeid(op).name() << endl; //class Object *\n    cout << typeid(*op).name() << endl;//class Object\n}\n```\n\n### 带const的情况\n\n不管Object对象带不带const修饰，`typeid`对顶层类型的描述都不会带const字眼，但`*cop`（即所指之物）实际上是可能有const属性的。\n\n```cpp\nint main()\n{\n    Object obj;\n    const Object * cop = &obj;\n    cout << typeid(cop).name() << endl; //class Object const *\n    cout << typeid(*cop).name() << endl;//class Object\n}\n```\n\n```cpp\nint main()\n{\n    const Object cobj;\n    const Object * cop = &cobj;\n    cout << typeid(cop).name() << endl; //class Object const *\n    cout << typeid(*cop).name() << endl;//class Object\n}\n```\n\n#### 引申 - 模板\n\n```cpp\ntemplate<class T>\nvoid fun(T & a)\n{\n    cout << typeid(T).name() << endl;\n    cout << typeid(a).name() << endl;\n}\n```\n\n以下程序：T实际上是int ; 而a实际上是int &，但输出时，T和a类型输出的都是int。说明顶层形式（即非指针、引用）时，只输出纯粹类型int，所以，a不输出引用。\n\n```cpp\nint main()\n{\n    int x = 10;\n    fun(x);//输出int int\n}\n```\n\n以下程序：T实际上是const int，a实际上是const int &，但输出时T和a类型输出的都是int。说明顶层形式（即非指针、引用）时，只输出纯粹类型int，所以，T和a均不输出const和引用。\n\n```cpp\nint main()\n{\n    const int x = 10;\n    fun(x);//输出int int\n}\n```\n\n要怎么验证T实际上是一个const int类型呢？可以尝试在fun函数中定义一个T类型的未初始化变量。会发生错误，因为编译器判定此处T为一个引用类型，必须在定义时予以初始化。也就验证了T类型为带const的int，只是在typeid输出时没有输出&。\n\n```cpp\nint main()\n{\n    const int x = 10;\n    fun(x);\n}\ntemplate<class T>\nvoid fun(T & a)\n{\n    T b;//error, T是一个const int &, 引用变量必须在定义时初始化。\n    cout << typeid(T).name() << endl;\n    cout << typeid(a).name() << endl;\n}\n```\n\n## typeid的应用 - 用于比较是否是相同类型\n\n```cpp\nint main()\n{\n    int a = 10, b = 20;\n    const int * ap = &a;\n    int * bp = &b;\n    cout << (typeid(ap) == typeid(bp)) << endl;//不等于, 因为ap为const int *, bp为int *\n    cout << (typeid(*ap) == typeid(*bp)) << endl;//等于, 因为*ap和*bp的typeid.name均为int\n}\n```\n\n## typeid在继承关系中\n\n### 有继承但无多态关系（无虚函数）\n\n有继承但无多态关系（无虚函数）中的typeid类型输出仍为静态识别。\n\n```cpp\nclass Base\n{\n    int value;\npublic:\n    Base(int x = 0) : value(x) {}\n    ~Base() {}\n}\nclass Derived : public Base\n{\n    int num;\npublic:\n    Derived(int x = 0) : num(x) {}\n    ~Derived() {}\n}\n```\n\n如以下程序，`*bp`输出的是Base，而实际上bp所指之物为Derived类型对象。这是因为Base和Derived有继承但无多态关系，因此typeid只根据指针类型来静态输出，而未能识别所指之物的真实类型。\n\n```cpp\nint main()\n{\n    Derived d;\n    Derived * dp = &d;  //子指针指向子对象 ok\n    Base * bp = &d;     //父指针指向子对象 ok\n    cout << typeid(dp).name() << endl; //class Derived *\n    cout << typeid(bp).name() << endl; //class Base *\n    cout << typeid(*dp).name() << endl;//class Derived\n    cout << typeid(*bp).name() << endl;//class Base\n}\n```\n\n### 有继承且有多态关系（有虚函数）\n\n```cpp\nclass Base\n{\n    int value;\npublic:\n    Base(int x = 0) : value(x) {}\n    virtual ~Base() {}//此处, 定义了一个虚函数。自此, Base和Derived类就存在多态关系了。\n}\nclass Derived : public Base\n{\n    int num;\npublic:\n    Derived(int x = 0) : num(x) {}\n    ~Derived() {}\n}\n```\n\n```cpp\nint main()\n{\n    Derived d;\n    Derived * dp = &d;  //子指针指向子对象 ok\n    Base * bp = &d;     //父指针指向子对象 ok\n    cout << typeid(dp).name() << endl; //class Derived *\n    cout << typeid(bp).name() << endl; //class Base *\n    cout << typeid(*dp).name() << endl;//class Derived\n    cout << typeid(*bp).name() << endl;//class Derived, 此处变为了Derived, 即bp指向的对象的实际类型\n}\n```\n\n如以上程序，`*bp`输出的是Derived，正确对应了实际上bp所指之物为Derived类型对象。这是因为Base和Derived有继承且有多态关系，因此typeid根据bp所指对象的实际类型来输出。\n\n怎么根据bp所指对象的实际类型来输出呢？原理是查虚表。\n\n> 在继承且多态关系中，但凡通过指针、引用的方式操作时，都会引发查虚表的动作。\n```cpp\ntypeid(*op)//*op解引用了指针，查虚表\nop->fun();//通过op指针调用函数，查虚表。\n```\n\n虚表的结构：虚表包含的内容，除了我们熟悉的虚成员函数指针外，在虚函数表的若干虚成员函数指针之前，即虚函数表的前4个字节，存放了一个RTTI指针。这个指针即指向了当前对象的真实类型信息，即`type_info`结构体。这个结构体存放了此类型的类型名等信息。\n\n所以，在继承且有多态关系中进行`typeid`查询时，是一种动态的查询方案，即通过虚表指针，找到相应的虚表，虚表头部有个RTTI，即当前对象的类型信息。\n\n#### 隐患：谨防空指针\n\n```cpp\nclass Base\n{\n    int value;\npublic:\n    Base(int x = 0) : value(x) {}\n    virtual ~Base() {}//此处, 定义了一个虚函数。自此, Base和Derived类就存在多态关系了。\n}\nclass Derived : public Base\n{\n    int num;\npublic:\n    Derived(int x = 0) : num(x) {}\n    ~Derived() {}\n}\n```\n\n```cpp\nint main()\n{\n    Base * bp = nullptr;\n    cout << typeid(bp).name() << endl;\n    cout << typeid(*bp).name() << endl;//崩溃\n}\n```\n\n以上程序中，Base和Derived类有多态关系（有虚函数表指针），`*bp`将会引起查虚表操作。但是，查对象虚表指针时，进入了陷阱，bp本应该指向虚函数表地址，但它居然指向的是一个空指针！于是进行了对空指针的操作导致程序崩溃。\n\n> 实际上，如果Base和Derived只有继承关系而没有多态关系（即两个对象没有虚函数表指针），则不会引起空指针异常，因为不涉及到查虚表，typeid只是一个静态类型识别，只根据bp的指针类型输出指针对应的类型。这也验证了前面提到的，“有继承但无多态关系（无虚函数）中的typeid类型输出仍为静态识别。”\n\n所以我们在多态关系中要谨防所有涉及到查虚表操作引起的空指针异常。\n\n```cpp\nint main()\n{\n    Base * bp = nullptr;\n    cout << typeid(bp).name() << endl;\n    try\n    {\n        cout << typeid(*op).name() << endl;//抛出异常\n    }\n    catch(std::bad_typeid& e)\n    {\n        cout << e.what() << endl;\n    }\n}\n//输出：\n//class Object *\n//Attempted a typeid of nullptr pointer!\n```\n\n# dynamic_cast应用场景 - 下行转换\n\n在继承关系的上行转换中。`static_cast`和`dynamic_cast`均是可以的，而且不管有无多态关系（有无虚函数）也是无所谓的。\n\n现在我们来讨论下行转换的情况。\n\n## 无多态\n\n```cpp\nclass Base\n{\n    int value;\npublic:\n    Base(int x = 0) : value(x) {}\n    ~Base() {}\n}\nclass Derived : public Base\n{\n    int num;\npublic:\n    Derived(int x = 0) : num(x) {}\n    ~Derived() {}\n}\n```\n\n```cpp\nint main()\n{\n    Derived d;\n    Base * bp = &d;\n    Derived * dp = nullptr;\n    dp = bp;//error, 用子指针指向子对象, 语义正确, 但编译不通过。因为Base *和Derived *类型不一致。\n}\n```\n\n以上程序因为Base *和Derived *类型不一致，所以无法直接`dp = bp;`，我们可以暂时用`static_cast`解决。\n\n```cpp\nint main()\n{\n    Derived d;      //子对象\n    Base * bp = &d; //取子对象地址传给父指针\n    Derived * dp = nullptr;//定义一个子指针\n    dp = static_cast<Derived*>(bp);//使用了static_cast, 编译通过。用子指针指向子对象。语义正确。\n}\n```\n\n`static_cast`在继承关系中，只能解决上行转换，对于下行转换（子指针指向父对象）则将会导致语义错误！所以在继承关系中，`static_cast`慎用！\n\n```cpp\nint main()\n{\n    Base b;        //父对象\n    Base * bp = &b;//父指针\n    Derived * dp = nullptr;\n    dp = static_cast<Derived*>(bp);//使用了static_cast, 编译通过。但是! 用子指针指向父对象，语义不正确，即解释越界。\n}\n```\n\n## 使用dynamic_cast的场景（必须有多态）\n\n上面的错误，需要使用`dynamic_cast`来解决。相比于上一个程序，此处是dynamic_cast, 它会有一个处理, 如果发现了“用子指针指向父对象”的行为，则给dp返回一个nullptr指针。\n\n> 但是要注意的是，**要使用`dynamic_cast`进行下行转换的前提是，类之间必须要有多态关系**，才能使用`dynamic_cast`进行下行转换。否则编译出错。\n>\n> ````cpp\n> class Base\n> {\n>     int value;\n> public:\n>     Base(int x = 0) : value(x) {}\n>     virtual ~Base() {}//此处, 定义了一个虚函数。自此, Base和Derived类就存在多态关系了。\n> }\n> class Derived : public Base\n> {\n>     int num;\n> public:\n>     Derived(int x = 0) : num(x) {}\n>     ~Derived() {}\n> }\n> ````\n\n```cpp\nint main()\n{\n    Base b;\n    Base * bp = &b;\n    Derived * dp = nullptr;\n    dp = dynamic_cast<Derived*>(bp);//编译通过。相比于上一个程序，此处是dynamic_cast, 它会有一个处理, 如果发现了“用子指针指向父对象”的行为，则给dp返回一个nullptr指针。\n}\n```\n\n```cpp\nint main()\n{\n    Derived d;\n    Base * bp = &d;\n    Derived * dp = nullptr;\n    dp = dynamic_cast<Derived*>(bp);//编译通过。相比于上一个程序，用子指针指向子对象，语义正确，则给dp返回一个非nullptr的Derived*指针。\n}\n```\n\n## 如果使用引用需要处理异常\n\n上面讨论到了，如果`dynamic_cast`发现了“用子指针指向父对象”的行为，则返回一个nullptr指针。但是如果我们使用的是引用呢？——肯定不存在空引用，因此需要处理异常。\n\n```cpp\nint main()\n{\n    Derived d;\n    Base b;\n    Base & rb = b;//父引用 引用 父对象\n    try\n    {\n        Derived & rd = dynamic_cast<Derived&>(rb);//欲用\"子引用 引用 父对象\", 抛异常\n    }\n    catch(std::bad_cast &e)\n    {\n        cout << e.what() << endl;\n    }\n}\n```\n\n# 应用 - 如何在常方法中修改对象\n\n```cpp\nclass Object\n{\n    int value;\npublic:\n    Object(int x = 0) : value(x) {}\n    void fun() const\n    {\n        int x = value;\n        value = 100;//常方法中修改属性值\n    }\n}\n```\n\n方法一：给要修改的值加mutable关键字。\n\n```cpp\n    mutable int value;\n```\n\n方法二：对要修改的值取地址，并强转为不带const的指针属性，再解引用。可用`const_cast`\n\n```cpp\n    void fun() const\n    {\n        int x = value;\n        *(int*)&value = 100;\n        *(const_cast<int*>(&value)) = 100;\n    }\n```\n\n方法三：对this指针下手。同方法二。\n\n```cpp\n    void fun() const\n    {\n        int x = value;\n        (const_cast<Object*>(this))->value = 100;\n    }\n```\n\n# 动态转换的应用 - 垃圾分类\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\nclass Trash\n{\n    float m_weight;\npublic:\n    Trash(float wt) : m_weight(wt) {}\n    virtual ~Trash()\n    {\n        cout << \"~Trash()\" << endl;\n    }\n    float getWeight() const\n    {\n        return m_weight;\n    }\n    virtual float getPrice() const = 0;\n};\n```\n\n```cpp\n//铜\nclass Copper : public Trash\n{\n    static float price;\npublic:\n    Copper(float wt) : Trash(wt) {}\n    float getPrice() const\n    {\n        return price;\n    }\n    static void setPrice(float newPrice)\n    {\n        price = newPrice;\n    }\n};\nfloat Copper::price = 2.80;\n```\n\n```cpp\n//纸\nclass Paper : public Trash\n{\n    static float price;\npublic:\n    Paper(float wt) : Trash(wt) {}\n    float getPrice() const\n    {\n        return price;\n    }\n    static void setPrice(float newPrice)\n    {\n        price = newPrice;\n    }\n};\nfloat Paper::price = 0.20;\n```\n\n```cpp\n//玻璃\nclass Glass : public Trash\n{\n    static float price;\npublic:\n    Glass(float wt) : Trash(wt) {}\n    float getPrice() const\n    {\n        return price;\n    }\n    static void setPrice(float newPrice)\n    {\n        price = newPrice;\n    }\n};\nfloat Glass::price = 0.32;\n```\n\n```cpp\ntemplate<class Container>\nvoid sumPrice(Container & bin)\n{\n    float total = 0;\n    for(auto p : bin)\n    {\n        total += p->getPrice() * p->getWeight();\n        cout << \"weight of \" << typeid(*p).name() << \" = \"\n            << p->getWeight() << endl;\n    }\n    cout << \"Total price = \" << total << endl;\n}\n```\n\n```cpp\nint main()\n{\n    srand(time(NULL));\n    vector<Trash*> bin;//父类指针。可指向具体的垃圾类。\n    int n = rand() % 50;\n    for(int i = 0; i < n; ++i)\n    {\n        switch(rand() % 3)\n        {\n        case 0:\n            bin.push_back(new Copper((rand() % 1000) / 10.0)));\n            break;\n        case 1:\n            bin.push_back(new Paper((rand() % 1000) / 10.0)));\n            break;\n        case 2:\n            bin.push_back(new Glass((rand() % 1000) / 10.0)));\n            break;\n        }\n    }\n    \n    vector<Copper*> coppBin;\n    vector<Paper*>  paperBin;\n    vector<Glass*>  glassBin;\n    vector<Trash*>::iterator sorter = bin.begin();\n    while(sorter != bin.end())\n    {\n        Copper *cp = dynamic_cast<Copper*>(*sorter);\n        Paper  *pp = dynamic_cast<Paper*>(*sorter);\n        Glass  *gp = dynamic_cast<Glass*>(*sorter);\n        if(cp)\n        {\n            coppBin.push_back(cp);\n        }\n        else if(pp)\n        {\n            paperBin.push_back(pp);\n        }\n        else if(gp)\n        {\n            glassBin.push_back(gp);\n        }\n        ++sorter;\n    }\n    sumPrice(coppBin);\n    sumPrice(paperBin);\n    sumPrice(glassBin);\n    sumPrice(bin);\n    for(auto x : bin)\n    {\n        delete x;\n        x = nullptr;\n    }\n}\n```\n\n","categories":["Cpp"]},{"title":"高级数据结构_平衡搜索树","url":"/高级数据结构/高级数据结构_平衡搜索树/","content":"\n# 内容\n\n1. AVL - 平衡搜索树\n2. 单旋转\n3. 双旋转\n\n# 平衡搜索树\n\n在计算机科学中，AVL树（以发明者Adelson-Velsky和Landis 命名）是一种**自平衡-二叉搜索树(BST)**。在AVL树中，任何节点的两个子树的高度最多相差1；如果在任何时候它们的差异超过1，则会进行重新平衡以恢复此属性。在平均情况和最坏情况下，查找、插入和删除都需要$O(\\log n)$时间，其中$n$是操作之前树中的节点数。插入和删除可能需要通过一个或多个树旋转来重新平衡树。\n\nAVL树以其两位苏联发明家Georgy Adelson-Velsky和Evgenii Landis的名字命名;\n\nAVL树经常与红黑树进行比较，因为它们都支持相同的操作集并且采用$O(\\log n)$基本操作的时间。对于查找密集型应用程序，AVL树比红黑树更快，因为它们更严格地平衡。\n\n# 类C实现方式\n\n## 节点结构\n\n可以看到, 相比于二叉搜索树只多出一个balance因子, 这个平衡因子将带来什么魔力呢?\n\n```c++\ntypedef int KeyType;\ntypedef struct AVLNode\n{\n    struct AVLNode* leftchild;\n    struct AVLNode* parent;\n    struct AVLNode* rightchild;\n\tKeyType key;\n    int balance;\t//-1,0,1\n}AVLNode, *AVLTree;\n```\n\n# 旋转\n\n如果在一棵平衡的二叉搜索树中插入一个新节点，造成了不平衡。此时必须调整树的结构，使之平衡化。\n\n平衡化旋转有两类：\n\n1. 单旋转（左旋和右旋）\n2. 双旋转（左平衡和右平衡）\n\n* 每插入一个新节点时，AVL树中相关节点的平衡状态会发生改变。因此，在插入一个新节点后，需要从插入位置沿通向根的路径回溯，检查各结点的平衡因子（左、右子树的高度差）。\n  * 如果在某一节点发现高度不平衡，停止回溯。\n  * 从发生不平衡的节点起，沿刚才回溯的路径取直接下两层的节点。\n  * 如果这三个节点处于一条直线上，则采用单旋转进行平衡化。单旋转可按其方向分为左单旋转和右单旋转，其中一个是另一个的镜像，其方向与不平衡的形状相关。\n  * 如果这三个节点处于一条折线上，则采用双旋转进行平衡化。双旋转分为先左后右和先右后左两类。\n\n## 单旋转\n\n| 要达到平衡需要的旋转操作 | 例子                                                         | 原因                        |\n| ------------------------ | ------------------------------------------------------------ | --------------------------- |\n| 右单旋转(顺时针)         | ![image-20220314155058162](../../images/高级数据结构_平衡搜索树/image-20220314155058162.png) | 左孩子的左子树高 - 左左旋转 |\n| 左单旋转(逆时针)         | ![image-20220314155134839](../../images/高级数据结构_平衡搜索树/image-20220314155134839.png) | 右孩子的右子树高 - 右右旋转 |\n\n## 左单旋转(右右旋转) - 逆时针\n\n![image-20220314163614131](../../images/高级数据结构_平衡搜索树/image-20220314163614131.png)\n\n此图为例，插入100后，56的平衡因子为2，78为1，89为1。则我们需要以78为轴，将56进行左单旋转。\n\n左单旋转会是什么效果？先看简单的情况\n\n![image-20220314163747839](../../images/高级数据结构_平衡搜索树/image-20220314163747839.png)\n\n以此为启发，进行旋转\n\n![image-20220314164516467](../../images/高级数据结构_平衡搜索树/image-20220314164516467.png)\n\n再来看一个与代码步骤有关的图例\n\n![image-20220314164731464](../../images/高级数据结构_平衡搜索树/image-20220314164731464.png)\n\n1. newroot指针指向ptr的右子树（轴）\n2. ptr的右孩子指针指向newroot的左子树（承）\n3. newroot的左孩子指针指向ptr（揽）\n\n以下为最基本的三步走：\n\n```c++\nvoid RotateLeft(AVLTree& tree, AVLNode* ptr)\n{\n\tAVLNode* newroot = ptr->rightchild;\t  //1:以ptr右子树为轴\n\tptr->rightchild = newroot->leftchild; //2:ptr的右指针承接newroot的左孩子\n\tnewroot->leftchild = ptr;             //3:newroot的左指针包揽ptr为首的子树，揽为已有\n}\n```\n\n在这三步中，每一步的后面都要做相应的对parent的维护\n\n1. newroot的父指针指向ptr的父节点（ptr的父节点代替了newroot的父）\n2. 若newroot有左孩子，则左孩子的父指针指向ptr的节点\n3. ptr的父指针指向newroot\n\n```c++\nvoid RotateLeft(AVLTree& tree, AVLNode* ptr)\n{\n\tAVLNode* newroot = ptr->rightchild;\t\t//1.1:\n    newroot->parent = ptr->parent\t\t\t//1.2:\n\n\tptr->rightchild = newroot->leftchild;\t//2.1:ptr右指针承接newroot左孩\n    if(newroot->left != nullptr)newroot->leftchild->parent = ptr;//2.2:\n\t\n    newroot->leftchild = ptr;\t\t\t\t//3.1:newroot左指针包揽ptr子树\n    ptr->parent = newroot;\t\t\t\t\t//3.2\n}\n```\n\n在最后一步，处理ptr的parent指针之前，还要处理**ptr的父节点的某一孩子指针**指向问题，**原本是指向50的(即ptr)**，但70(newroot)包揽了50(ptr)的地位，则原本50(ptr)的父节点的一个孩子指针就要指向70(newroot)，**至于是左孩子指针还是右孩子指针，需要根据是否和ptr地址是否相等判断**。\n\n```c++\nvoid RotateLeft(AVLTree& tree, AVLNode* ptr)\n{\n\tAVLNode* newroot = ptr->rightchild;\t\t//1.1:\n    newroot->parent = ptr->parent;\t\t\t//1.2:\n\n\tptr->rightchild = newroot->leftchild;\t//2.1:ptr右指针承接newroot左孩\n    if(newroot->left != nullptr)newroot->leftchild->parent = ptr;//2.2:\n\t\n    newroot->leftchild = ptr;\t\t\t\t//3.1:newroot左指针包揽ptr子树\n    \n    //??? : 此处是否需要判空\n    if(ptr->parent->leftchild == ptr)ptr->parent->leftchild = newroot;\n    else ptr->parent->rightchild = newroot;\t//4:\n    \n    ptr->parent = newroot;\t\t\t\t\t//3.2:\n}\n```\n\n代码还没完，还要处理根节点的变化\n\n```c++\nvoid RotateLeft(AVLTree& tree, AVLNode* ptr)\n{\n\tAVLNode* newroot = ptr->rightchild;\t\t//1.1:\n    newroot->parent = ptr->parent;\t\t\t//1.2:\n\n\tptr->rightchild = newroot->leftchild;\t//2.1:ptr右指针承接newroot左孩\n    if(newroot->left != nullptr)newroot->leftchild->parent = ptr;//2.2:\n\t\n    newroot->leftchild = ptr;\t\t\t\t//3.1:newroot左指针包揽ptr子树\n    \n    if(ptr == tree)tree = newroot;\t\t\t//4:如果ptr正好是根，则newroot替代root\n    else\t\t\t\t\t\t\t\t\t//5:若ptr不是根，则处理其父节点的左右孩子指针\n    {\t//此处不用判空，既然ptr不是根则ptr->parent一定不为空！\n        if(ptr->parent->leftchild == ptr)ptr->parent->leftchild = newroot;\n        else ptr->parent->rightchild = newroot;\t\n    }\n\n    ptr->parent = newroot;\t\t\t\t\t//3.2:\n}\n```\n\n## 双旋转\n\n| 旋转方向   | 例子                                                         | 原因             |\n| ---------- | ------------------------------------------------------------ | ---------------- |\n| 左右双旋转 | ![image-20220314155238443](../../images/高级数据结构_平衡搜索树/image-20220314155238443.png) | 左孩子的右子树高 |\n| 右左双旋转 | ![image-20220314155251894](../../images/高级数据结构_平衡搜索树/image-20220314155251894.png) | 右孩子的左子树高 |\n\n## 左右旋转 - 先左旋后右旋\n\n先以左孩子节点为根节点, 左孩子节点的右孩子节点为轴, 进行左单旋转;\n\n再, 以父节点为根节点, 左孩子节点为轴, 进行右单旋转;\n\n# Insert\n\n在向一棵本来是高度平衡$(balance = 0,1,-1)$的AVL树中插入一个新节点和在BST树一样，区别是如果树中某个节点的平衡因子$|balance| > 1$，则出现了不平衡，需要做平衡化处理，使得树中各节点重新平衡化。\n\n```cpp\nAVLNode * Buynode(KeyType kx)\n{\n    AVLNode * s = (AVLNode*)malloc(sizeof(AVLNode));\n    if(nullptr == s) exit(1);\n    memset(s, 0, sizeof(AVLNode));\n    s->key = kx;\n    s->balance = 0;\n    return s;\n}\nbool Insert(AVLNode *& tree, KeyType kx)\n{\n    if(tree == nullptr)\n    {\n        tree = MakeRoot(val);\n        return true;\n    }\n    AVLNode * pa = nullptr;\n    AVLNode * p = tree;\n    while(p != nullptr && p->key != kx)\n    {\n        pa = p;\n        p = kx < p->key ? p->leftchild : p->rightchild;\n    }\n    if(p != nullptr && p->key == kx) //已存在重复值\n        return false;\n\n    p = Buynode(kx);\n    \n    p->parent = pa;\n    \n    if(kx < pa->key)\n    {\n        pa->leftchild = p;\n    }\n    else\n    {\n        pa->rightchild = p;\n    }\n    return true;\n}\n```\n\n## 回溯平衡\n\n对于AVL树来说, 单纯的Insert是不够的, 还需要依靠四个函数 - 左旋/右旋/左右旋转/右左旋转, 来达到对树结构的平衡化;\n\n需要考虑的一个关键点: 回溯的终止条件是什么? 即for循环终止判断语句; \n\n```cpp\nvoid PassBalance(AVLNode &tree, AVLNode * ptr)\n{\n    AVLNode * pa = p->parent;\n    for(; pa != nullptr; )\n    {\n        if(pa->leftchild == p) //p在pa的左边\n        switch(pa->balance)\n        {\n            case 0: //本来平衡, 插到左, -1\n                pa->balance = -1;     break;\n            case 1: //本来右1, 插到左, 0\n                pa->balance = 0;      break;\n            case -1://本来左1, 插到左, 需要平衡\n                LeftBalance(tree, pa);break;\n        }\n        else //p在pa的右边\n        switch(pa->balance)\n        {\n            case 0: //本来平衡, 插到右, 1\n                pa->balance = 1;      break;\n            case -1://本来左1, 插到右, 平衡\n                pa->balance = 0;      break;\n            case 1: //本来右1, 插到右, 需要平衡\n                RightBalance(tree, pa);break;\n        }\n        \n        p = pa;\n        pa = p->parent;\n    }\n}\n```\n\n还可以进一步做优化: 循环不一定要一直继续 - 有可能节点在插入之后, 整个树的高度没有发生变化, 此时无需进行全部的回溯;\n\n```cpp\nvoid PassBalance(AVLNode &tree, AVLNode * ptr)\n{\n    AVLNode * pa = p->parent;\n    bool taller = true;\n    for(; pa != nullptr && taller; )\n    {\n        if(pa->leftchild == p) //p在pa的左边\n        switch(pa->balance)\n        {\n            case 0: //本来平衡, 插到左, -1\n                pa->balance = -1;     break;\n            case 1: //本来右1, 插到左, 0, 因此树高无变化, 无需回溯\n                pa->balance = 0;\n                taller = false;       break;\n            case -1://本来左1, 插到左, 需要平衡, 进行旋转后, 树高也平衡了, 无需回溯\n                LeftBalance(tree, pa);\n                taller = false;       break;\n        }\n        else //p在pa的右边\n        switch(pa->balance)\n        {\n            case 0: //本来平衡, 插到右, 1\n                pa->balance = 1;      break;\n            case -1://本来左1, 插到右, 平衡, 因此树高无变化, 无需回溯\n                pa->balance = 0;\n                taller = false;       break;\n            case 1: //本来右1, 插到右, 需要平衡, 进行旋转后, 树高也平衡了, 无需回溯\n                RightBalance(tree, pa);\n                taller = false;       break;\n        }\n        \n        p = pa;\n        pa = p->parent;\n    }\n}\n```\n\n这样一来, 此循环最多进入两次即可退出, 因为, 不管你把`pa->balance`调为`-1`或`1`, 下次循环中的`pa->balance`肯定不会是上次的值, 而某一case中, 除了第一种情况taller为true, 其他两种均为false; \n\n### 左平衡\n\n```cpp\nvoid LeftBalance(AVLTree & tree, AVLNode * ptr)\n{\n    AVLNode * leftsub = ptr->leftchild;\n    AVLNode * rightsub = nullptr;\n    switch(leftsub->balance)\n    {\n        case 0: /* left balance, but maybe a fault */ break;\n        case -1:/* 左直线, 需要右单旋转 */\n            RotateLeft(tree, ptr);\n            ptr->balance = 0;\n            leftsub->balance = 0;                     break;\n        case 1: /* 左右折线, 需要双旋转 */\n            rightsub = leftsub->rightchild;\n            switch(rightsub->balance)\n            {\n                case -1:/* 在根的左孩子的右孩子的左边插入 */\n                    leftsub->balance = 0;\n                    ptr->balance = 1;                 break;\n                case 1: /* 在根的左孩子的右孩子的右边插入 */\n                    leftsub->balance = -1;\n                    ptr->balance = 0;                 break;\n                case 0: /* */\n                    leftsub->balance = 0;\n                    ptr->balance = 0;                 break;\n            }\n            /* 先以根的左孩子为根节点, 以其右孩子为轴, 进行左单旋转 */\n            RotateLeft(tree, leftsub);\n            /* 再以根(ptr)作为根节点, 以其左孩子为轴, 进行右单旋转 */\n            RotateRight(tree, ptr);\n            rightsub->balance = 0;\n            break;//case 1, end\n    }\n}\n```\n\n\n\n# Delete\n\n* 如果被删结点x最多只有一个孩子，那么问题比较简单。如果被删结点x有两个孩子，首先搜索在中序次序下的直接前驱y（同样可以找直接后继）。再把结点y的内容传送给结点x，现在问题转移到删除结点y。\n  * 把结点y当作被删结点x。\n* 将结点x从树中删去。因为结点x最多有一个孩子，我们可以简单地把x的双亲结点中原来指向x的指针改指到这个孩子结点；如果结点x没有孩子，x双亲结点的相应指针置为NULL。然后将原来以结点x为根的子树的高度减1，\n\n* 必须沿x通向根的路径反向追踪高度的变化对路径上各个结点的影响。\n* 用一个布尔变量shorter来指明子树的高度是否被缩短。在每个结点上要做的操作取决于shorter的值和结点的balance，有时还要依赖子女的balance。\n* 布尔变量shorter的值初始化为True。然后对于从x的双亲到根的路径上的各个结点p，在shorter保持为True时执行下面的操作。如果shorter变成False，算法终止。\n\n* case 1：当前节点p的balance为0。\n  * 如果它的左子树或右子树被缩短，则它的balance改为1或-1，同时shorter置为false。\n* case 2：节点p的balance不为0，且较高的子树被缩短，则p的balance改为0，同时shorter置为true。\n\n![image-20220320184924205](../../images/高级数据结构_平衡搜索树/image-20220320184924205.png)\n","categories":["高级数据结构","树"]},{"title":"Cpp_值类型_引用折叠","url":"/Cpp/Cpp_值类型_引用折叠/","content":"# `static_cast`\n\n`int a`不能直接用`int && e`接收。\n```cpp\nint main()\n{\n    int a = 12;\n    int && e = a;  // error\n    e = 13;\n}\n```\n\n`int a`强转为`int&&`时，可以用`int && e`接收，修改e，会连带修改a。\n```cpp\nint main()\n{\n    int a = 12;\n    int && e = static_cast<int&&>(a);\n    e = 13;     // e = 13; a = 13\n}\n```\n`int a`强转为`int`时，可以用`int && e`接收，修改e，不会连带修改a。\n\n> 为什么？\n> 强转为值类型时，相当于拷贝了一份临时对象（另创空间）。\n\n```cpp\nint main()\n{\n    int a = 12;\n    int && e = static_cast<int>(a);\n    e = 13;     // e = 13; a = 12\n}\n```\n\n# 移动构造（拷贝右值构造）\n1. 参数不能加const，因为语义上，是要把other对象的资源移动过来，是需要改动other的。\n2. 经验上，要把移动构造函数声明为noexcept，因为涉及到资源的移动的动作过程中即使出现了异常也无法处理、修复。\n\n```cpp\nclass Test\n{\npublic:\n    Test(int val) : _val { new int(val) }\n    {}\n    // 以非右值对象拷贝构造\n    Test(Test const & other)\n    {\n        _val = new int(*other._val);\n    }\n    // 以右值对象移动构造\n    Test(Test && other) noexcept\n    {\n        _val = other._val;\n        other._val = nullptr;\n    }\n    ~Test()\n    {\n        if(_val)\n        {\n            delete _val;\n            _val = nullptr;\n        }\n    }\n    void set_value(int v)\n    {\n        if(_val)\n        {\n            *_val = v;\n        }\n    }\nprivate:\n    int * _val;\n};\n```\n测试移动构造：以下代码未能走到移动构造函数的断点——编译器优化了\n\n> 编译器优化了：`Test test{ get_test() }`。没走移动构造，而是直接把`Test test{5}`在main函数中的test上构造了。\n> 这个现象叫做：具名的返回值优化。\n\n```cpp\nTest get_test(void)\n{\n    Test test{5};\n    return test;\n}\nint main()\n{\n    Test test{ get_test() };\n}\n```\n如果不优化的话，会是以下的情况：一共创建了3个对象，有2个是中间无用的临时对象\n```cpp\nTest get_test(void)\n{\n    Test test{ 5 };         // create a new test object\n    return test;            // generated a temporary test object\n}\nint main()\n{\n    Test test{ get_test() };// create a new object by calling copy-constructor\n}\n```\n为了能看到移动构造函数的断点：不通过函数返回的临时值，通过自己手动创建一个test，来强转为右值引用，从而移动构造新的test。\n```cpp\nint main()\n{\n    Test test2{ static_cast<Test&&>(test) };\n}\n```\n# 赋值重载\n\n以非右值对象赋值\n```cpp\nTest & operator=(Test const& other)\n{\n    if(&other == this) return *this;\n    if(_val != nullptr)\n    {\n        delete _val;\n        _val = nullptr;\n    }\n    if(other._val != nullptr) \n    {\n        _val = new int { *other._val };\n    }\n    return *this;\n}\n```\n\n以右值对象赋值\n```cpp\nTest & operator=(Test && other)\n{\n    if(&other == this) return *this;\n    if(_val != nullptr)\n    {\n        delete _val;\n        _val = nullptr;\n    }\n    _val = other._val;\n    return *this;\n}\n```\n\n# `static_cast`三种值类型的行为\n\n没有变量接收时的行为：\n```cpp\nint main()\n{\n    Test test{ 2 };\n\n    static_cast<Test>(test);\n    static_cast<Test&>(test);\n    static_cast<Test&&>(test);\n    \n}\n```\n\n通过断点调试，发现，强转为普通值类型`<Test>`时，而且是在不进行其他操作的情况下，仍会调用一次普通拷贝构造函数。其他两句不会进行拷贝。\n\n接下来研究其他两个语句——在有变量接收时的行为。\n## 强转为普通值类型\n1. 以普通值类型接收时，会拷贝，调用的是普通拷贝构造；\n2. 不可以左值引用接收普通值类型。\n3. 以右值引用接收时，**也会拷贝**，调用的是普通拷贝构造。\n\n```cpp\nint main()\n{\n    Test test{ 2 };\n\n    Test    test11 = static_cast<Test>(test);\n    Test &  test12 = static_cast<Test>(test);\n    Test && test13 = static_cast<Test>(test);\n}\n```\n## 强转为左值\n1. 以普通值类型接收时，会拷贝，调用的是普通拷贝构造；\n2. 以左值引用接收时，不会拷贝，**是高效的用法**。\n3.  不可以右值引用接收左值。\n\n```cpp\nint main()\n{\n    Test test{ 2 };\n\n    Test    test21 = static_cast<Test&>(test);\n    Test &  test22 = static_cast<Test&>(test);\n  //Test && test23 = static_cast<Test&>(test);  // error\n}\n```\n## 强转为右值\n1. 以普通值类型接收时，会拷贝，**调用右值构造**（如果右值构造较好地处理了资源的移动，则较高效。**若没有明确写右值构造，则仍会进行普通拷贝，则降低了效率**）；\n2. 不可以左值引用接收右值。\n3. 以右值引用接收时，不会拷贝，**是高效的用法**。\n\n```cpp\nint main()\n{\n    Test test{ 2 };\n\n    Test    test31 = static_cast<Test&&>(test);  // decide on Move Constructor\n  //Test &  test32 = static_cast<Test&&>(test);  // error\n    Test && test33 = static_cast<Test&&>(test);\n}\n```\n\n其中，以“右值引用类型”接收“强转为右值的对象”（或者`std::move`后的对象），这个行为其实是对“右值对象”的生命期的延展。如果通过右值引用来修改对象，那么对象源值也会修改。这才是右值引用最本原的功能。\n```cpp\nint main()\n{\n    Test test{ 2 };\n    // test    : _val : 2\n\n    Test && test33 = static_cast<Test&&>(test);\n    test33.set_value(4);\n    // test.33 : _val : 4\n    // test    : _val : 4\n}\n```\n## 总结\n\nModern Cpp引入了值类型的细分，不是让你装逼的，也不是为了给程序员增加痛苦的，而是为了让各种类型都有它最好的归宿：\n1. 左值交给左值引用（不会有任何其他多余的操作，高效转手）\n2. 右值交给右值引用（不会有任何其他多余的操作，高效转手）\n3. 右值交给普通类型（调用右值构造，如果右值构造较好地处理了资源的移动，则较高效）\n\n1. 对于前两种来说，只要引用类型匹配，则无需程序员费心，便可提高效率。\n2. 而对于程序员来说，最要注意的就是第三种情况，即右值构造函数需要程序员来明确写出，指明资源转移的动作，决定了右值交给普通类型的效率。**如果没有写右值构造函数，则仍会进行普通拷贝，则降低了效率。**\n# `forwarding_reference`\n\n形式上和右值引用一样，但性质、行为是未定义的。\n1. 传入模板的类型，是不确定的，需要接收后另外推断。\n2. 传给auto的类型，亦如此，接收后需要推断。\n\n困扰：\n```cpp\ntemplate<typename T>\nvoid test(T const & t)\n{\n    \n}\n\nint main()\n{\n    const int ca = 10;\n    int a = 11;\n    test(ca);\n    test(a);\n    test(9);\n}\n```\n问题：字面常量无法传递给`T & t`。\n于是加了`T const & t`，可以传递了。\n\n但是，导致，如果传的是const int变量，则T后加const与否对应的行为不一样。\n总结起来就是：\n1. T后无const时\n    1. 传入非常左值，T对应的类型是`const int`，t对应的类型是`const int &`\n    2. 传入常左值，T对应的类型是`int`，t对应的类型是`int &`\n    3. 常性在传入前后始终是对应的，很好。\n    4. 但是：不能接收右值。\n    5. 总结：虽然不怎么通用，但是起码没有很乱。\n2. T后有const时\n    1. 能接收右值了，很好。\n    2. 但是，无论传入的是常左值、非常左值、右值，最后，T对应的类型都会是`int`，t对应的类型都会是`const int &`。\n    3. 那么就导致：如果传入的是非常左值，由于t被污染成了const int，导致t无法修改。\n## 全新的解决方案\n\n使用`T &&`这个形式改进`T const & `。虽然样子看起来是右值引用，但它不是，因为T是不确定类型，而它又常用在参数转发中，所以起了新名叫”转发引用 (Forwarding Reference)“（也有人叫Universal Reference）。根据接收的值类型的不同，T也会跟着变化。\n\n包容度和`T const &`一样，既能接收常左值、非常左值，又能接收右值。\n最终达到的效果却比`T const &`更好：\n1. 常左值，T对应的类型是`const int &`，t对应的类型是`const int &`\n2. 左值，T对应的类型是`int &`，t对应的类型是`int &`\n3. 右值，T对应的类型是`int`，t对应的类型是`int &&`\n\n```cpp\ntemplate<typename T>\nvoid test(T && t)\n{\n    \n}\n\nint main()\n{\n    int a = 11;\n    test(a);\n    test(9);\n}\n```\n## 引用折叠\nReference Collapsed\n## 模板参数中的`&&`\n\n虽然经过传入，变成了对应的引用，在函数中也可以修改t的值（const类型除外），但是其实没啥意义，这个转发引用的意义就是在于让你转发的，不是修改值。\n\n```cpp\ntemplate <typename T>\nvoid test(T && t)\n{\n    t = 8;\n}\nint main()\n{\n    int a = 11;\n    test(a);    // 可以把本身改为8。\n    test(9);    // 9还是9，不变。   t = 8修改的是副本\n}\n```\n## auto后的`&&`\n\n```cpp\nint main()\n{\n    int a = 11;\n  //int  && ri = a;   // error  右值引用无法接收左值\n  //auto &  la = 9;   // error  左值引用无法接收右值\n    auto && ra = a;   // ok     ra : int &  \n    auto && ra2= 9;   // ok     ra2: int && ra2\n}\n```\n# move\n\n把传入的值类型转换为右值。\n\n```cpp\ntemplate<typename T>\nT&& mymove(T && t)\n{\n    return static_cast<T&&>(t);\n}\n```\n\n```\nT: int & + && -> t: int &\nT: int   + && -> t: int && \n```\n现在的问题是：传入不同值类型的变量后，行为不一致。若是左值，则最终只能强转为`int &`；若为右值，则最终只能强转为`int &&`。现在我们想要追求：无论左右值，最终都转为左值。\n\n那么可以考虑用Traits技术，消除左右值的区别、影响，统一。\n```cpp\ntemplate<typename T>\nclass RemoveRefTraits\n{\npublic:\n    using TYPE = T;\n};\n\ntemplate<typename T>\nclass RemoveRefTraits<T&>\n{\npublic:\n    using TYPE = T;\n};\n\ntemplate<typename T>\nclass RemoveRefTraits<T&&>\n{\npublic:\n    using TYPE = T;\n};\n\ntemplate <typename T>\nusing RemRef_t = RemoveRefTraits<T>::TYPE;\n```\n\n```cpp\ntemplate<typename T>\nRemRef_t<T>&& mymove(T && t)\n{\n    return static_cast<RemRef_t<T>&&>(t);\n}\n```\n# 完美转发\nPerfect Forwarding\n\n","categories":["Cpp","Modern"]},{"title":"高级数据结构_搜索树","url":"/高级数据结构/高级数据结构_搜索树/","content":"\n# 内容\n\n1. 各种搜索树之间的关系\n2. 树式查找的总体构思\n3. 树式查找基本算法与数据结构\n4. 二叉搜索树--基于半线性的树形结构\n5. 我们的理想：兼顾动态修改与静态查找操作效率\n6. 理想平衡\n7. 适度平衡\n8. AVL--平衡二叉搜索树--最坏情况下，单次动态修改和静态查找也均可以在O(logn)时间内完成\n\n本文章的搜索树实现有两种方式\n\n1. 类C结构体实现方式，自学习实现。\n2. 模板类实现方式，参考邓俊辉的《数据结构\\_C++语言版\\_第3版》。\n\n## 各种搜索树之间的关系\n\n![image-20220312143749079](../../images/高级数据结构_搜索树/image-20220312143749079.png)\n\n# 二叉搜索树--类C结构体\n\n## 节点结构\n\n* 节点结构\n\n```c++\ntypedef int KeyType;\ntypedef struct BstNode\n{\n\tKeyType key;\n\tBstNode* leftchild;\n\tBstNode* parent;\n\tBstNode* rightchild;\n}BstNode,*BSTree;\n```\n\n* Buynode\n\n```c++\nBstNode* Buynode()\n{\n\tBstNode* s = (BstNode*)malloc(sizeof(BstNode));\n\tif (NULL == s)exit(1);\n\tmemset(s, 0, sizeof(BstNode));\n\treturn s;\n}\n```\n\n## Insert\n\n```c++\nBstNode* MakeRoot(KeyType kx)\n{\n\tBstNode* pnode = Buynode();\n\tpnode->key = kx;\n\treturn pnode;\n}\nbool Insert(BstNode*& ptr, KeyType kx)\n{\n\tif (ptr == NULL)\n\t{\n\t\tptr = MakeRoot(kx);\n\t\treturn true;\n\t}\n\tBstNode* p = ptr;\t//遍历Node的指针\n\tBstNode* pa = NULL;\t//实时追踪p的parent\n\twhile (p != NULL && p->key != kx)\n\t{\n\t\tpa = p;\n\t\tp = kx < p->key ? p->leftchild : p->rightchild;\n\t}\n\t/* 实际上不用再判断p->key == kx, 只要p != NULL就说明找到了相等的节点，\n\t   如果此时p!=NULL的话，上面的while循环的退出就是因为p->key==kx而退出的\n\t*/\n\tif (p != NULL /* && p->key == kx */)return false;\n\n\t// 此时已经找到要插入的位置\n\tp = Buynode();\n\tp->key = kx;\n\tp->parent = pa;\n\t// 更新pa的左或右孩子\n\tif (p->key < pa->key) pa->leftchild = p;\n\telse pa->rightchild = p;\n\treturn true;\n}\n```\n\n代码结构优化--Insert中包含了建根的情况\n\n```c++\nbool Insert(BstNode*& ptr, KeyType kx)\n{\n\tBstNode* p = ptr;\t//遍历Node的指针\n\tBstNode* pa = NULL;\t//实时追踪p的parent\n\twhile (p != NULL && p->key != kx)\n\t{\n\t\tpa = p;\n\t\tp = kx < p->key ? p->leftchild : p->rightchild;\n\t}\n\tif (p != NULL)return false;\n\n\t// 此时已经找到要插入的位置\t\t\t//其中，包括根为空的情况\n\tp = Buynode();\n\tp->key = kx;\n\tp->parent = pa;\n    if(pa == NULL)\t//建根的情况\n    {\n        ptr = p;\n    }\n    else // 更新pa的左或右孩子\n    {\n        if(p->key < pa->key)\n            pa->leftchild = p;\n        else \n            pa->rightchild = p;\n    }\n    return true;\n}\n```\n\n### 测试\n\n```c++\nvoid InOrder(BstNode* ptr)\n{\n\tif (ptr != NULL)\n\t{\n\t\tInOrder(ptr->leftchild);\n\t\tcout << ptr->key << \" \";\n\t\tInOrder(ptr->rightchild);\n\t}\n}\nint main()\n{\n\tBSTree root = NULL;\n\tint ar[] = { 53,17,78,9,45,65,87,23,81,94,88,100 };\n\tint n = sizeof(ar) / sizeof(ar[0]);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcout << Insert(root, ar[i]) << endl;\n\t}\n    InOrder(root);cout << endl;\n\treturn 0;\n}\n```\n\n## Next & NiceInOrder\n\n```c++\nBstNode* First(BstNode* ptr)\n{\n\twhile (ptr != NULL && ptr->leftchild != NULL)\n\t{\n\t\tptr = ptr->leftchild;\n\t}\n\treturn ptr;\n}\n// 找到当前节点的直接后继（按关键码大小）\nBstNode* Next(BstNode* ptr)\n{\n\tif (ptr == NULL)return NULL;\n    // 存在右分支\n\tif (ptr->rightchild != NULL)\n\t{\n\t\treturn First(ptr->rightchild);\n\t}\n\telse // 没有右分支\n\t{\n\t\tBstNode* pa = ptr->parent;\n        // 沿着右子树回溯，直到找到自己作为父节点的左子树\n        // 这一过程可以用中序遍历的次序解释\n        while(pa != NULL && pa->leftchild != ptr)\n        {\n            ptr = pa;\n            pa = ptr->parent;\n        }\n        return pa;\n\t}\n}\n```\n\n```c++\nvoid NiceInOrder(BstNode* ptr)\n{\n    for(BstNode* p = First(ptr); p != NULL; p = Next(p))\n    {\n        cout << p->key << \" \";\n    }\n    cout << endl;\n}\n```\n\n## Prev & NiceRevInOrder\n\n```c++\nBstNode* Last(BstNode* ptr)\n{\n\twhile (ptr != NULL && ptr->rightchild != NULL)\n\t{\n\t\tptr = ptr->rightchild;\n\t}\n\treturn ptr;\n}\nBstNode* Prev(BstNode* ptr)\n{\n    if(ptr == NULL)return NULL;\n    // 存在左分支\n    if(ptr->leftchild != NULL)\n    {\n        return Last(ptr->leftchild);\n    }\n    else\n    {\n        BstNode* pa = ptr->parent;\n        while(pa != NULL && pa->leftchild != ptr)\n        {\n            ptr = pa;\n            pa = ptr->parent;\n        }\n        return pa;\n    }\n}\n```\n\n```c++\nvoid NiceRevInOrder(BstNode* ptr)\n{\n    for(BstNode* p = Last(ptr); p != NULL; p = Prev(p))\n    {\n        cout << p->key << \" \";\n    }\n    cout << endl;\n}\n```\n\n## Remove\n\n```c++\nbool Remove(BstNode*& ptr, KeyType kx)\n{\n    if(ptr == NULL)return false;\n    BstNode* p = ptr;\n    while(p != NULL && p->key != kx)\n    {\n        p = kx < p->key ? p->leftchild : p->rightchild;\n    }\n    if(p == NULL)return false;\n    \n    //双分支的特殊处理，与直接后继节点替换。把删除的目标转向其直接后继节点。进而转为删除单分支节点的情况！\n    if(p->leftchild != NULL && p->rightchild != NULL)\n    {\n        BstNode * psucc = First(p->rightchild);\t//succ: successor,后继\n        p->key = psucc->key;\n        p = psucc;\n    } \n    //单分支、叶子通用\n    BstNode* pa = p->parent;\n    BstNode * newchild = p->leftchild!=NULL ? p->leftchild : p->rightchild;\n    \n    // 使p与newchild解除关系\n    \t//维护newchild的parent\n    if(newchild != NULL)newchild->parent = pa;\n    \t//解除p的child关系，由于将被删去，把p的左右孩子置为NULL\n    p->rightchild = p->leftchild = NULL;\n    \n    //此处：维护pa的左右孩子。维护根节点\n    //如果删除的是根节点：不维护pa的左右孩子(因为pa为空)，替换root\n    if(pa == NULL)\t//pa == NULL则说明删除的是根节点\n    {\n        ptr = newchild;\n    }\n    else\t\t\t//删除非根节点的情况，维护pa的左右孩子，不替换root\n    {\n        // 将newchild替代p的位置\n            //删除单分支节点时，newchild为其分支节点；\n            //删除叶子节点时，newchild为空。不影响。\n        if(pa->leftchild == p)\n            pa->leftchild = newchild;\n        else\n            pa->rightchild = newchild;\n    }\n    //删除结束\n    free(p);\n    return true;\n}\n```\n\n\n\n# 二叉搜索树--模板类\n\n## 顺序性\n\n在二叉搜索树（binary search tree）中，处处都满足顺序性：\n“**任一节点r的左（右）子树中，所有节点（若存在）均不大于（不小于）r**”。\n\n![image-20220312145342588](../../images/高级数据结构_搜索树/image-20220312145342588.png)\n\n为回避边界情况，这里暂且假定所有节点互不相等。\n\n下图左三个示例是二叉搜索树，右三个示例是反例。\n![image-20220312145511100](../../images/高级数据结构_搜索树/image-20220312145511100.png)\n\n当然，在实际应用中，对相等元素的禁止既不自然也不必要。可在代码的基础上继续扩展，使得二叉搜索树的接口支持相等词条的同时并存（习题[7-10]）。在去除掉这一限制之后，图中原先的第一个反例，将转而成为合法的二叉搜索树。\n\n## 中序遍历序列\n\n下图为二叉搜索树的中序遍历序列，单调增。\n![image-20220312145818194](../../images/高级数据结构_搜索树/image-20220312145818194.png)\n\n顺序性是一项很强的条件。实际上，搜索树中节点之间的全序关系，已完全“蕴含”于这一条件之中。以如上图所示的二叉搜索树为例，只需该树做一次中序遍历，即可将该树转换为一个线性序列，且该序列中的节点严格按照其大小次序排列。\n\n这一现象，并非巧合。借助数学归纳法，可以证明更具一般性的结论：**任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降**。\n\n## BST模板类\n\n```c++\n#include \"BinTree.h\"\ntemplate<typename T> class BST : public BinTree<T>\n{\nprotected:\n    BinNodePosi(T) _hot;\t//\"命中\"节点的父亲\npublic:\n    virtual BinNodePosi(T) & search(const T& e);\t//查找\n    virtual BinNodePosi(T) insert(const T& e);\t\t//插入\n    virtual bool remove(const T& e);\t\t\t\t//删除\n};\n```\n\n可见，在继承原模板类BinTree的同时，BST内部也继续沿用了二叉树节点模板类BinNode。按照二叉搜索树的接口规范定义，这里新增了三个标准的对外接口search()、insert()和remove()，分别对应于基本的查找、插入和删除操作。这三个标准接口的调用参数，都是属于元素类型T的对象引用——这正是此类结构“循关键码访问”方式的具体体现。\n\n以后还将以BST为基类，进一步派生出二叉搜索树的多个变种。无论哪一变种，既必须支持上述三个基本接口，同时在内部的具体实现方式又有所不同。因此，它们均被定义为虚成员函数，从而强制要求派生的所有变种，根据各自的规则对其重写。\n\n## 查找算法及其实现\n\n二叉搜索树的查找算法，亦采用了**减而治之**的思路与策略，其执行过程可描述为：**从树根出发，逐步地缩小查找范围，直到发现目标（成功）或缩小至空树（失败）**。\n\n例如，在下图中查找关键码22的过程如下。首先，经与根节点16比较确认目标关键码更大，故深入右子树25递归查找；经比较发现目标关键码更小，故继续深入左子树19递归查找；经再次比较确认目标关键码更大后，深入右子树22递归查找；最终在节点22处匹配，查找成功。\n![image-20220312152123162](../../images/高级数据结构_搜索树/image-20220312152123162.png)\n\n实际上，针对16、25、19的查找，也将经过该路径的某一前缀，成功终止于对应的节点。当然，查找未必成功。比如针对关键码20的查找也会经过同一查找通路并抵达节点22，但在因目标关键码更小而试图继续向左深入时发现左子树为空，至此即可确认查找失败。\n\n> （此类空节点通常对应于空孩子指针或引用，也可假想地等效为“真实”节点，后一方式不仅可简化算法描述以及退化情况的处理，也可直观地解释（B-树之类）纵贯多级存储层次的搜索树。故在后一场合，空节点也称作外部节点（external node），并等效地当作叶节点的“孩子”。返里暂采用前一方式，故空节点不在插图中出现。） \n\n一般地，在上述查找过程中，一旦发现当前节点为NULL，即说明查找范围已经缩小至空，查找失败；否则，视关键码比较结果，向左（更小）或向右（更大）深入，或者报告成功（相等）。\n\n**对照中序遍历序列可见，整个过程与有序向量的二分查找过程等效，故可视作后者的推广**。\n\n### searchIn()算法与search()接口\n\n* searchIn()\n\n  ```c++\n  template<typename T>\n  static BinNodePosi(T) & searchIn(BinNodePosi(T) & v, const T& e, BinNodePosi(T) & hot)\n  {\n      if(v==nullptr || (e == v->data)) return v;\n      hot = v;\n      return searchIn(((e < v->data) ? v->lc : v->rc), e, hot);\n  }\n  ```\n\n* search()\n\n  ```c++\n  template<typename T> BinNodePosi(T) & BST<T>::search(const T& e)\n  {\n      //返回目标节点位置的引用，以便后续插入、删除操作。\n      return searchIn(_root, e, hot = NULL);\n  }\n  ```\n\n### 语义约定\n\n以上查找算法之所以如此实现，是为了统一并简化后续不同搜索树的各种操作接口的实现。其中的技巧，主要体现于返回值和hot变量（即BinTree对象内部的_hot变量）的语义约定。\n\n* 若查找成功，则searchIn()以及search()的返回值都将如图左所示，指向一个关键码为e且真实存在的节点；\n* 若查找失败，则返回值的数值虽然为NULL，但是它作为引用将如图右所示，指向最后一次试图转向的空节点。对于后一种情况，不妨假想地将此空节点转换为一个数值为e的哨兵节点——如此，无论成功与否，查找的返回值总是等效地指向“命中节点”。\n  ![image-20220312160254950](../../images/高级数据结构_搜索树/image-20220312160254950.png)\n* 在调用searchIn()算法之前，search()接口首先将内部变量\\_hot初始化为NULL，然后作为引用型参数hot传递给searchIn()。在整个查找的过程中，hot变量始终指向当前节点的父亲。\n  因此在算法返回时，按照如上定义，\\_hot亦将统一指向“命中节点”的父亲。即便在退化的情况下（比如查找终止并返回于树根处），算法searchIn()的输出依然符合以上语义约定。\n* 请注意，\\_hot节点是否拥有另一个孩子，与查找成功与否无关。查找成功时，节点e可能是\n  叶子，也可能是内部节点；查找失败时，假想的哨兵e等效于叶节点，但可能有兄弟。\n\n### 效率\n\n* 在二叉搜索树的每一层，查找算法至多访问一个节点，且只需常数时间，故**总体所需时间应线性正比于查找路径的长度**，或最终返回节点的深度。\n* 在最好情况下，目标关键码恰好出现在树根处（或其附近），此时只需O(1)时间。\n* 然而不幸的是，对于规模为n的二叉搜索树，深度在最坏情况下可达Ω(n)。比如，当该树退化为（接近于）一条单链时，发生此类情况的概率将很高。此时的单次查找可能需要线性时间并不奇怪，因为实际上这样的一棵“二分”搜索树，已经退化成了一个不折不扣的一维有序列表，而此时的查找则等效于顺序查找。\n* 由此我们可得到启示：若要控制单次查找在最坏情况下的运行时间，须从控制二叉搜索树的**高度**入手。后续将要讨论的平衡二叉搜索树，正是基于这一思路而做的改进。\n\n## 插入算法及其实现\n\n### 算法\n\n* 为了在二叉搜索树中插入一个节点，首先需要利用查找算法search()确定插入的位置及方向，然后才能将新节点作为叶子插入。\n* 以如左图1所示的二叉搜索树为例。若欲插入关键码40，则在执行search(40)之后，如图2所示，\\_hot将指向比较过的最后一个节点46，同时返回其左孩子（此时为空）的位置。于是接下来如图(c)所示，只需创建新节点40，并将其作为46的左孩子接入，拓扑意义上的节点插入即告完成。\n  ![image-20220312162256305](../../images/高级数据结构_搜索树/image-20220312162256305.png)\n* 不过，为保持二叉搜索树作为数据结构的完整性和一致性，还需从节点_hot（46）出发，自底而上地逐个更新新节点40历代祖先的高度。\n* 接下来若欲插入关键码55，则在执行search(55)之后如图3所示，\\_hot将指向比较过的最后一个节点53，同时返回其右孩子（此时为NULL）的位置。于是如图4所示，创建新节点55，并将其作为53的右孩子接入。当然，此后同样需从节点\\_hot出发，逐代更新祖先的高度。\n\n### insert()接口的实现\n\n```c++\ntemplate<typename T>\nBinNodePosi(T) BST<T>::insert(const T& e)\n{\n    BinNodePosi(T) &x = search(e);\t//search的过程中更新了_hot\n    if(x!=nullptr)return x;//如果e值在树中已经存在则不插\n    \n    x = new BinNode<T> (e, _hot);\t//创建新节点x：以e为关键码，以_hot为父\n    _size++;\n    updateHeightAbove(x);\t\t\t//更新x及其历代祖先的高度\n    return x;\n}\n```\n\n* 首先调用search()查找e。若返回位置x非空，则说明已有雷同节点，插入操作失败。否则，\n  **x必是\\_hot节点的某一空孩子**，于是创建这个孩子并存入e。\n* 按照以上实现方式，无论插入操作成功与否，都会返回一个非空位置，且该处的节点与拟插入的节点相等。如此可以确保一致性，以简化后续的操作。\n* 另外，上面的查找算法中的对“首个节点插入空树”等特殊情况的处理手法与这里的类似，可以认真体会一番。\n\n### 效率\n\n由上可见，节点插入操作所需的时间，主要消耗于对算法search()及updateHeightAbove()的调用。后者与前者一样，在每一层次至多涉及一个节点，仅消耗O(1)时间，故其**时间复杂度也同样取决于新节点的深度**，在最坏情况下不超过全树的高度。\n\n## 删除算法及其实现\n\n为从二叉搜索树中删除节点，首先也需要调用算法BST::search()，判断目标节点是否的确存在于树中。若存在，则需返回其位置，然后方能相应地具体实施删除操作。\n\n![image-20220312165938462](../../images/高级数据结构_搜索树/image-20220312165938462.png)\n\n### 单分支情况\n\n以左图1所示二叉搜索树为例，若欲删除节点69，需首先通过search(69)定位待删除的节点69。因该节点的右子树为空，故只需如图2所示，将69替换为64。则拓扑意义上的节点删除即告完成。另外，为保持二叉搜索树作为数据结构的完整性和一致性，还需更新全树的规模记录，释放被摘除的节点69，并自下而上地逐个更新替代节点64历代祖先的高度。**注意，首个需要更新高度的祖先58，恰好由\\_hot指示**。\n\n不难理解，对于没有左孩子的目标节点，也可以对称地予以处理。当然，以上同时也已涵盖了左右孩子均不存在的情况（即目标节点为叶子）。\n\n### 双分支情况\n\n继续上例，设拟再删除二度节点36，如图2所示，首先调用BinNode::succ()算法，找到该节点的直接后继40。然后，只需如图3所示交换二者的数据项即可将后继节点等效地视作待删除的目标节点。不难验证，该后继节点必无左孩子，从而相当于转化为此前相对简单的情况——单分支情况。最后如图4所示，将新的目标节点36替换为其右孩子46。\n\n注意，在互换36和40后，如图3所示，曾经一度并不满足顺序性，但这并不要紧，在按照上述方法完成整个删除动作后，全树的顺序性必然又将恢复。\n\n同样地，除了更新全树规模记录和释放被摘除节点，此时也要更新一系列祖先节点的高度。不难验证，此时首个需要更新高度的祖先53依然恰好由\\_hot指示。\n\n### remove()实现\n\n```c++\ntemplate<typename T>\nbool BST<T>::remove(const T& e)\n{\n    BinNodePosi(T) & x = search(e);\n    if(x == nullptr)return false;\n    removeAt(x, _hot);\n    --_size;\n    updateHeightAbove(_hot);\n    return true;\n}\ntemplate<typename T>\nstatic BinNodePosi(T) removeAt(BinNodePosi(T) & x, BinNodePosi(T) & hot)\n{\n    BinNodePosi(T) w = x;\n    BinNodePosi(T) succ = NULL;\n    if(!HasLChild(*x))\t\t//若要删除的节点没有左孩子\t\n        succ = x = x->rc;\t//直接将x替换为其右子树\n    else if(!HasRChild(*x))\t//若右子树为空\n        succ = x = x->lc;\t//对称地处理，注意：此时succ!=NULL\n    else\t//双分支情况\n    {\t//若左右子树均存在，x和其直接后继w互换，w作为实际被delete节点\n        w = w->succ();\t//寻找x直接后继w -- 只可能发生在x的右子树中\n        swap(x->data, w->data);//交换x和w的data\n        BinNodePosi(T) u = w->parent;\n        ((u == x) ? u->rc : u->lc) = succ = w->rc;\n    }\n    hot = w->parent;\n    if(succ)succ->parent = hot;\n    release(w->data);\n    release(w);\n    return succ;\n}\n```\n\n首先调用search()查找e。若返回位置x为空，则说明树中不含目标节点，故删除操作随即可以失败返回。否则，调用removeAt()删除目标节点x。同样，此后还需更新全树的规模，并调用函数updateHeightAbove(\\_hot)，更新被删除节点历代祖先的高度。\n\n### 效率\n\n删除操作所需的时间，主要消耗于对search()、succ()和updateHeightAbove()的调用。在树中的任一高度，它们至多消耗O(1)时间。故**总体的渐进时间复杂度，亦不超过全树的高度**。\n","categories":["高级数据结构","树"]},{"title":"Cpp_STL_allocator","url":"/Cpp/Cpp_STL_allocator/","content":"\n# 内容\n\n1. 一级配置器和二级配置器的关系\n2. 类型萃取\n3. allocator\n4. `__malloc_alloc_template`静态成员的类外初始化，其中函数指针尤为麻烦\n\n# 空间配置器\n\nSGI STL第一级配置器\n\n```cpp\ntemplate<int inst>\nclass __malloc_alloc_template{ /*...*/ };\n```\n\n1. allocate()直接使用malloc()，deallocate()直接使用free()。\n2. 模拟C++的set\\_new\\_handler() 以处理内存不足的情况。\n\nSGI STL第二级配置器\n\n```cpp\ntemplate<bool threads, int inst>\nclass __default_alloc_template{ /*...*/ };\n```\n\n1. 维护16个自由串列，负责16种小型区块的此配置能力。内存池以malloc配置而得。如果内存不足，转第一级配置器进行oom处理。\n2. 如果需求区块大于128bayes，转第一级配置器（直接malloc）。\n\n# 类型萃取\n\niterator_traits负责萃取迭代器的特性，而SGI的__type_traits把这种技法进一步扩大到迭代器以外的世界。\n\n我们对类型关注的属性有：\n\n1. has_trivial_default_constructor\n2. has_trivial_copy_constructor\n3. has_trivial_assignment_operator\n4. has_trivial_destructor\n5. is_POD_type\n\n如果某种类型的构造、拷贝、赋值、析构函数是不必要的，那么我们在对这个类型进行以上动作时，就可以采用最原始化、最有效率的措施，如malloc、memcpy等。这就是对类型属性萃取的意义。\n\n```c++\nstruct __true_type {};\nstruct __false_type {};\n```\n\n## 小试牛刀\n\n```c++\n#pragma once\nnamespace xcg\n{\n\nstruct __true_type {};\nstruct __false_type {};\n\ntemplate<class T>\nstruct __type_traits\n{\n\ttypedef __true_type\t\tthis_dummy_member_must_be_first;\n\ttypedef __false_type\thas_trivial_default_constructor;\n\ttypedef __false_type\thas_trivial_copy_constructor;\n\ttypedef __false_type\thas_trivial_assignment_operator;\n\ttypedef __false_type\thas_trivial_destructor;\n\ttypedef __false_type\tis_POD_type;\n};\n\ntemplate<>\nstruct __type_traits<char>\n{\n\ttypedef __true_type\t\thas_trivial_default_constructor;\n\ttypedef __true_type\t\thas_trivial_copy_constructor;\n\ttypedef __true_type\t\thas_trivial_assignment_operator;\n\ttypedef __true_type\t\thas_trivial_destructor;\n\ttypedef __true_type\t\tis_POD_type;\n};\n\ntemplate<>\nstruct __type_traits<int>\n{\n\ttypedef __true_type\t\thas_trivial_default_constructor;\n\ttypedef __true_type\t\thas_trivial_copy_constructor;\n\ttypedef __true_type\t\thas_trivial_assignment_operator;\n\ttypedef __true_type\t\thas_trivial_destructor;\n\ttypedef __true_type\t\tis_POD_type;\n};\n\ntemplate<class T>\nstruct __type_traits<T*>\n{\n\ttypedef __true_type\t\thas_trivial_default_constructor;\n\ttypedef __true_type\t\thas_trivial_copy_constructor;\n\ttypedef __true_type\t\thas_trivial_assignment_operator;\n\ttypedef __true_type\t\thas_trivial_destructor;\n\ttypedef __true_type\t\tis_POD_type;\n};\n\n}\n```\n\n# allocator\n\n## STL处理内存的三大部分\n\nSTL的allocator把分配空间、释放空间分工了。分配是alloc::allocate()负责，释放是alloc::deallocate()负责；对象构建是::construct()负责，对象析构是::delete()负责，new和delete往往是全局函数。\n\nSTL标准规格的配置器定义于\\<memory\\>中，SGI\\<memory\\>内含以下两个文件：\n\n```c++\n#include<stl_alloc.h>\n#include<stl_construct.h>\n```\n\n实际上，STL除了以上两个重要部分，还有stl_uninitialized.h，是处理大块内存的。\n\n这个切入点，就可以直接把话题导向内存池了，我们可以根据具体类型的构造、析构、赋值函数是否无关紧要而采取最有效率的措施。\n\n## 空间的配置与释放std::alloc\n\n对象构建前的空间配置、对象析构后的空间释放，两个动作都由<stl_alloc.h>负责。SGI对此的设计哲学如下：\n\n1. 向system heap申请空间；\n2. 考虑多线程状态；\n3. 考虑内存不足时的应对措施；\n4. 考虑内存碎片问题\n\n对于第四个问题——内存碎片问题，SGI设计了两级配置器。第一级是对于足够大的内存块处理方式。第二级是对于太小的内存块处理方式。这个大小的标准以128bytes为界。\n\n一级配置器：\n\n1. 直接malloc\n2. 直接free\n3. 模拟c++的set_new_handler处理内存不足情况\n\n二级配置器：\n\n1. 维护16个自由链表(free lists)，内存池以malloc获取，内存不足则用一级配置器处理。\n2. 如果需求区块大于128bytes，转调用一级配置器。\n\n## 一级配置器的静态成员及其初始化\n\n先以一个简单的例子说明静态成员的类外初始化。\n\n```c++\nclass Object\n{\nprivate:\n    static int num;\n    static void (*pfun)();\n};\n\nint Object::num = 0;\n//void (*pfun)() = nullptr;\t\t\t//error\n//要告诉编译器，pfun来自哪个类。\nvoid (* Object::pfun)() = nullptr;\t//correct\n```\n\n其中，template\\<int inst\\>代表“非类型”模板，模板中的参数只是用于标识的。\n\n```c++\ntemplate<int inst>\nclass Object\n{\nprivate:\n    static int num;\n    static void (*pfun)();\n};\ntemplate<int inst>\nint Object<inst>::num = 0;\ntemplate<int inst>\nvoid (* Object<inst>::pfun)() = nullptr;\n```\n\n### alloc类的静态成员\n\n```c++\ntemplate<int inst>\nclass __malloc_alloc_template\n{\nprivate:\n    static void * oom_malloc(size_t n);\n    static void * oom_realloc(void * p, size_t new_sz);\n    static void (*__malloc_alloc_oom_handler)();\npublic:\n    static void * allocate(size_t n);\n    static void deallocate(void * p, size_t n);\n    static void * reallocate(void * p, size_t old_sz, size_t new_sz);\n    //static ? set_malloc_handler(void (*f)());\n    //函数名是set_malloc_handler，参数是一个void(*)()类型的变量，参数名字是f。\n    //其欲返回函数指针void (*)()。\n    //但是不能这样写：static void(*)() set_malloc_handler(void (*f)());\n    //下面是正确写法\n    static void(* set_malloc_handler(void(*f)()) ) ();\n};\n//此时的类外初始化\n//__malloc_alloc_template类的私有成员__malloc_alloc_oom_handler\ntemplate<int inst>\nvoid(* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = nullptr;\n```\n\n为了解决函数指针类型的可读性问题，使用typedef或using重定义类型名字。瞬间清爽了许多。\n\n```c++\nclass __malloc_alloc_template\n{\npublic:\n    using PFUN = void(*)();\nprivate:\n    static PFUN __malloc_alloc_oom_handler;\npublic:\n    static PFUN set_malloc_handler(PFUN p);\n};\n```\n\n接下来进行类外初始化：\n\n```c++\n//__malloc_alloc_template类的私有成员__malloc_alloc_oom_handler\ntemplate<int inst>\ntypename __malloc_alloc_template<inst>::PFUN __malloc_alloc_template<inst>::__malloc_alloc_oom_handler = nullptr;\n/*\n别看名字过长，实际和之前的形式一样。\n仿照以下方式写，成员类型+哪个类<T>::成员名 = ...\ntemplate<int inst>\nint Object<inst>::num = 0;\n/*\n```\n\n# 一级配置器函数实现\n\n函数成员总览：\n\n```c++\ntemplate<int inst>\nclass __malloc_alloc_template\n{\nprivate:\n    static void * oom_malloc(size_t n);\n    static void * oom_realloc(void * p, size_t new_sz);\n    static void (*__malloc_alloc_oom_handler)();\npublic:\n    static void * allocate(size_t n);\n    static void deallocate(void * p, size_t n);\n    static void * reallocate(void * p, size_t old_sz, size_t new_sz);\npublic:\n    using PFUN = void(*)();\n    static PFUN set_malloc_handler(PFUN p);\n};\n```\n\n## oom_handler\n\noom_handler，指out of memory时的处理。\n\n```c++\nstatic PFUN set_malloc_handler(PFUN p)\n{\n    PFUN old = __malloc_alloc_oom_handler;\n    __malloc_alloc_oom_handler = p;\n    return old;\n}\n```\n\n```c++\nstatic void * oom_malloc(size_t size)\n{\n    void* result = NULL;\n    void (*my_malloc_handler)() = nullptr;\n    for(;;) //infinite loop\n    {\n        my_malloc_handler = __malloc_alloc_oom_handler;\n    \tif(nullptr == my_malloc_handler)\n        {\n            __THROW_BAD_ALLOC;\n        }\n        my_malloc_hanler();\n        result = malloc(size);\t//after handling, retry to malloc\n        if(nullptr != result)\n        {\n            return result;\n        }\n    }\n}\n```\n\n```c++\nstatic void * oom_realloc(void * p, size_t new_sz)\n{\n    void* result = NULL;\n    void (*my_malloc_handler)() = nullptr;\n    for(;;) //infinite loop\n    {\n        my_malloc_handler = __malloc_alloc_oom_handler;\n    \tif(nullptr == my_malloc_handler)\n        {\n            __THROW_BAD_ALLOC;\n        }\n        my_malloc_hanler();\n        result = realloc(p, new_sz);\t//after handling, retry to malloc\n        if(nullptr != result)\n        {\n            return result;\n        }\n    }\n}\n```\n\n## allocate\n\n```c++\nstatic void* allocate(size_t size)\n{\n    void* result = malloc(size);\n    if(nullptr == result)\n    {\n        result = oom_malloc(size);\n    }\n    return result;\n}\n```\n\n## 对oom_handler的简要测试\n\n```c++\n#include\"my_alloc.h\"\n\nchar* chunk1 = (char*)malloc(sizeof(char)*10000000);\nvoid handler1()\n{\n    if(chunk1!=nullptr)\n    {\n        free(chunk1);\n    }\n    chunk1 = nullptr;\n    xcg::malloc_alloc::set_malloc_handler(nullptr);\n}\nint main()\n{\n    //设置hanler函数\n    xcg::malloc_alloc::set_malloc_handler(handler1);\n    //尝试申请100个int空间\n    //在allocate函数中，可以通过调试器强制将result赋为nullptr则可进行oom处理测试。\n    int * p = (int*)xcg::malloc_alloc::allocate(sizeof(int)*100);\n    return 0;\n}\n```\n\n## deallocate\n\n```c++\nstatic void deallocate(void * p, size_t n)\n{\n    free(p);\n}\n```\n\n## reallocate\n\n```c++\nstatic void * reallocate(void * p, size_t old_sz, size_t new_sz)\n{\n    void * result = realloc(p, new_sz);\n    if(nullptr == result)\n    {\n        result = oom_realloc(p, new_sz);\n    }\n    return result;\n}\n```\n\n# 二级配置器\n\n* 一级配置器的问题\n  * 直接的malloc后的数据上下各有一个越界标记。上越界标记之外还有信息，包括申请了多少字节，还有next域、prev域以便连接到链表中进行内存管理。除此之外可能还有有效/失效(是否释放)的标记。\n  * 除了包装信息占空间较多之外，还有malloc时花费的时间也多。这样就造成对于比较小的对象数据在malloc时入不敷出。\n  * 结论就是：对于较小数据，适用于内存池来进行内存管理。\n\n* **对于客户端申请较小空间（128bytes）的具体处理流程**：\n  1. 每次配置一大块内存，并维护对应的自由链表(free-list)\n  2. 下次如果再有相同大小的内存需求，直接从free-list中取出若干小块。\n  3. 如果客户端释放小块内存，就由配置器回收到free-list中。所以配置器除了分配空间，还负责回收空间。\n\n* 为了方便管理，SGI第二级配置器会主动按任何小块内存的内存需求量计算成8的倍数。（比如客户端要求30bytes，则计算为32bytes。\n\n* 共维护16个free-lists，各自管理大小分别为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128的小额区块。\n\n* free-lists的单结点结构如下：\n\n  ```cpp\n  union obj\n  {\n      union obj * free_list_link;\n      char client_data[1];\t//the client sees this\n  }\n  ```\n\n## 总览\n\n```c++\nenum { __ALIGN = 8};\nenum { __MAX_BYTES = 128};\nenum { __NFREELISTS = __MAX_BYTES / __ALIGN};\t// 128 / 8 = 16\n```\n\n```c++\ntemplate<bool threads, int inst>\t//参数1：是否考虑多线程，参数2：标识\nclass __default_alloc_template\n{\nprivate:\n    union obj\t/* 只是类型定义 */\n    {\n        union obj * free_list_link;\t//next\n        char client_data[1];\n    };\nprivate:\n    static obj * volatile free_list[__NFREELISTS];//volatile修饰obj*，即free_list数组中对于的数据内容。\n    static char* start_free;//每次配置的一大块'内存' 的内存来源的剩余部分的起始\n    static char* end_free;\t//每次配置的一大块'内存' 的内存来源的剩余部分的末尾\n    static size_t heap_size;//上面提到的都是内存来源，而这个内存来源都是从堆区申请的，堆区申请的总空间数要记录在案\n    static size_t ROUNT_UP(size_t bytes);\n    static size_t FREELIST_INDEX(size_t bytes);\t//hash\n    static char* chunk_alloc(size_t size, int & nobjs);//size - 对象的大小，nobjs对象的个数\n    static void* refill(size_t size);\t//重新填充\npublic:\t/* 用户调用 */\n    static void* allocate(size_t size);\n    static void deallocate(void* p, size_t n);\n    static void* reallocate(void* p, size_t old_sz, size_t new_sz);\n};\n```\n\n## 成员初始化\n\n```c++\n// 对free_list[__NFREELISTS]进行初始化。\ntemplate<bool threads, int inst> //\t1: __default_alloc_template是模板类，需要声明\ntypename __default_alloc_template<threads, inst>::obj * volatile // 2: obj是__default_alloc_template<threads, inst>类内的类，需要加上“哪个类”，并且要加上\"typename\"以示\"obj\"是个类名，而非成员。\n    __default_alloc_template<threads, inst>::free_list[__NFREELISTS] = {};\t// 3: free_list[__NFREELISTS]是__default_alloc_template<threads, inst>类内的成员，需要加上“哪个类”，但无需加\"typename\"。\n// 对start_free进行初始化\ntemplate<bool threads, int inst>\nchar* __default_alloc_template<threads, inst>::start_free = nullptr;\n// 对end_free进行初始化\ntemplate<bool threads, int inst>\nchar* __default_alloc_template<threads, inst>::end_free = nullptr;\n// 对heap_size进行初始化\ntemplate<bool threads, int inst>\nsize_t __default_alloc_template<threads, inst>::heap_size = 0;\n```\n\n## 函数实现\n\n准备工作\n\n```c++\nusing malloc_alloc = __malloc_alloc_template<0>;\n```\n\n### allocate\n\n相当于单链表的头删法，返回删了的节点的地址给用户用。\n\n```c++\nstatic void * allocate(size_t size)\n{\n    if(size > (size_t)__MAX_BYTES)\n    {\n        return malloc_alloc::allocate(size);\t//转给一级配置器。\n    }\n    obj * result = nullptr;\n    obj * volatile * my_free_list = nullptr;\t//是二级指针，要指向obj*\n    my_free_list = free_list + FREELIST_INDEX(size);\n    result = *my_free_list;\n    if(nullptr == result)\t//说明此下标处无内存块了，需要申请。\n    {\n        void * r = refill(ROUND_UP(size));\n        return r;\n    }\n    *my_free_list = result->free_list_link;\t//把free_list此下标的指针更新到下一个节点。相当于链表的头删法。\n    return result;\n}\n```\n\n### refill\n\n```c++\nstatic void * refill(size_t size)\n{\n    int nobjs = 20;\n    char * chunk = chunk_alloc(size, nobjs);\n    //chunk_alloc运行之后，nobjs值可能发生改变。\n    if(1 == nobjs)\n    {\n        //如果nobjs是1，则说明内存块正好用完，不用再处理后续内存区域的链接、移动\n        return chunk;\n    }\n    \n    //接下来，把内存块分崩离析，依次串联。\n    obj * volatile * my_free_list = NULL;\n    obj * result = (obj*)chunk;\n    obj * current_obj = NULL, * next_obj = NULL;\n    my_free_list = free_list + FREELIST_INDEX(size);\n    *my_free_list = next_obj = (obj*)(chunk+size);\n    for(int i = 1; ; ++i)\n    {\n        current_obj = next_obj;\n        next_obj = (obj*)((char*)next_obj + size);\n        if(i == nobjs-1)//最后一块\n        {\n            current_obj->free_list_link = NULL;\n            break;\n        }\n        current_obj->free_list_link = next_obj;\n    }\n    return result;\n}\n```\n\n### chunk_alloc\n\n```c++\nstatic char* chunk_alloc(size_t size, int & nobjs)\n{\n    char * result = NULL;\n    size_t total_bytes = size * nobjs;\n    size_t bytes_left = end_free - start_free;\n    if(bytes_left >= total_bytes)\n    {\n        result = start_free;\n        start_free = start_free + total_bytes;\n        return result;\n    }\n    else if(bytes_left >= size)\n    {\n        nobjs = bytes_left / size;\n        total = size * nobjs;\n        \n        result = start_free;\n        start_free = start_free + total_bytes;\n        return result;\n    }\n    else //内存不足以分配1个对象，把剩余的插入到其他下标(剩8字节插到0, 16字节插到1, ...)，然后再另外申请一个大的\n    {\n        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size >> 4);\n        if(bytes_left > 0)\n        {\n            obj * volatile * my_free_list = free_list + FREELIST_INDEX(bytes_left);\n            //头插\n            ((obj*)start_free)->free_list_link = *my_free_list;\n            *my_free_list = (obj*)start_free;\n        }\n        //剩余的残存空间 处理完毕，接下来申请大块内存\n        start_free = (char*)malloc(bytes_to_get);\n        if(NULL == start_free)\t//堆区居然没有资源了！无奈之计，只能向比他之后的链表找有无剩余块。\n        {\n            obj * volatile * my_free_list = NULL;\n            for(int i = size; i <= __MAX_BYTES; i += __ALIGN)\t//注意，i从size开始，而不一定从最小的块大小8开始，因为找比你小的没有用处。得找大的。\n            {\n                my_free_list = free_list + FREELIST_INDEX(i);\n                obj * p = NULL;\n                if(NULL != p)\t//找到了比他大的的剩余的了！\n                {\n                    *my_free_list = (*my_free_list)->free_list_link;\n                    start_free = (char*)p;\n                    end_free = start_free + i;\n                    return chunk_alloc(size, nobjs);\n                }\n            }\n            //如果上面的for循环没能使得其找到合适的内存块，则说明真的是“山穷水尽疑无路”了，只能转1级配置器，抛出异常或者通过handler处理。\n            start_free = malloc_alloc::allocate(bytes_to_get);\n        }\n        end_free = start_free + bytes_to_get;\n        heap_size += bytes_to_get;\n        return chunk_alloc(size, nobjs);\t//递归此函数，相当于重新来一遍流程\n    }\n}\n```\n\n### ROUND_UP & INDEX\n\n```c++\nstatic size_t ROUNT_UP(size_t bytes)\n{\n    // 0 -> 0, 1~8 -> 8, 9~16 - > 16, 17~24 -> 24, ...\n    return (bytes+ __ALIGN-1) & ~(__ALIGN - 1);\n}\nstatic size_t FREELIST_INDEX(size_t bytes)\n{\n    // 1~8 -> 0, 9~16 -> 1, 17~24 -> 2, ...\n    return ((bytes+ __ALIGN-1) / __ALIGN) - 1;\n}\n```\n\n### 测试allocate\n\n```c++\n#ifdef __USE_MALLOC\ntypedef __malloc_alloc_template<0> malloc_alloc;\ntypedef malloc_alloc alloc;\n#else\ntypedef __default_alloc_template<0, 0> alloc;\n#endif\n```\n\n```c++\ntemplate<class T, class Alloc>\nclass simple_alloc\n{\npublic:\n    static T* allocate(size_t n)\t//申请n个T对象\n    {\n        return Alloc::allocate(sizeof(T)*n);\n    }\n    static T* allocate()\n    {\n        return Alloc::allocate(sizeof(T));\n    }\n    void deallocate(T *p, size_t n)\n    {\n        if(NULL == p)return;\n        Alloc::deallocate(p, sizeof(T)*n);\n    }\n    void deallocate(T* p)\n    {\n        if(NULL == p)return;\n        Alloc::deallocate(p, sizeof(T));\n    }\n};\n```\n\n引入list进行测试\n\n```c++\n#include\"my_list.h\"\nusing namespace std;\nint main()\n{\n    xcg::my_list<char> mylist;\n    \n    for(int i = 0; i < 23; ++i)\n    {\n        mylist.push_back(i + 'a');\n    }\n    return 0;\n}\n```\n\nlist构建流程：\n\n```c++\ntemplate<class _Ty, class _A = xcg::alloc>\nclass my_list\n{\npublic:\n    typedef _Ty\t\t\t\t\t\t\t value_type;\n    typedef _Ty&\t\t\t\t\t\t reference;\n    typedef _Ty*\t\t\t\t\t\t pointer;\n    typedef const _Ty&\t\t\t\t\t const_reference;\n    typedef const _Ty*\t\t\t\t\t const_pointer;\n    \n    typedef _A\t\t\t\t\t\t\t allocator_type;\n    typedef xcg::simple_alloc<_Node, _A> data_allocate;\t\t//simple_alloc中使用的是第二个参数的allocate。在这里即使用_A::allocate，默认参数是xcg::alloc，而根据开关语句，若是使用malloc_alloc则为一级配置器，若为default_alloc则用二级配置器。我们默认使用的是__default_alloc_template<0, 0>。\n    \npublic:\n    my_list() : _Head(_Buynode()), _Size(0) {}\nprotected:\n    _Nodeptr _Buynode(_Nodeptr _parg = NULL, _Nodeptr _narg = NULL)\n    {\n        _Nodeptr _S = data_allocate::allocate();\n        _Acc::_Prev(_S) = _parg == NULL ? _S : _parg;\n        _Acc::_Next(_S) = _narg == NULL ? _S : _narg;\n        return _S;\n    }\nprivate:\n    _Nodeptr _Head;\n    size_t _Size;\n};\n```\n\n### deallocate\n\n```c++\nstatic void deallocate(void * p, size_t size)\t// n 表示空间大小\n{\n    if(size > (size_t)__MAX_BYTES)\n    {\n        malloc_alloc::deallocate(p, size);\n        return;\n    }\n    //归还给配置器\n    obj * q = (obj*)p;\n    obj * volatile * my_free_list = free_list + FREELIST_INDEX(size);\n    //头插\n    q->free_list_link = *my_free_list;\n    *my_free_list = q;\n    return;\n}\n```\n\n### 测试deallocate\n\n```c++\niterator erase(iterator _P)\n{\n    _Nodeptr _S = _P++._Mynode();\n    _Acc::_Next(_Acc::_Prev(_S)) = _Acc::_Next(_S);\n    _Acc::_Prev(_Acc::_Next(_S)) = _Acc::_Prev(_S);\n    destroy(&_Acc::_Value(_S));\t//不删除节点，而是释放value域。\n    _Freenode(_);\n    \n    return _P;\n}\nvoid _Freenode(_Nodeptr _P)\n{\n    data_allocate::deallocate(_P);\n}\nvoid pop_back()\n{\n    erase(--end());\n}\nvoid pop_front()\n{\n    erase(begin());\n}\n```\n\n```c++\nclass Object\n{\nprivate:\n    int value;\npublic:\n    Object(int x = 0) : value(x)\n    {\n        cout << \"create object\" << this << endl;\n    }\n    ~Object()\n    {\n        cout << \"destroy object\" << this << endl;\n    }\n};\nint main()\n{\n    xcg::my_list<Object> objlist;\n    for(int i = 0; i < 10; ++i)\n    {\n        objlist.push_back(Object(i));\n    }\n    objlist.pop_back();\n    return 0;\n}\n```\n\n### reallocate\n\n```c++\nstatic void* reallocate(void * p, size_t old_sz, size_t new_sz)\n{\n    if(old_sz > (size_t)__MAX_BYTES && new_sz > (size_t)__MAX_BYTES)\n    {\n        return malloc_alloc::reallocate(p, old_sz, new_sz);\n    }\n    // old_sz == 20, new_sz == 22\t-->24, 24\n    if(ROUND_UP(old_sz) == ROUND_UP(new_sz))\n    {\n        return p;\n    }\n    // old_sz > 128, new_sz < 128\n    // old_sz < 128, new_sz < 128\n    // old_sz < 128, new_sz > 128\n    size_t sz = old_sz < new_sz ? old_sz : new_sz;\n    void * s = allocate(new_sz);\n    memmove(s, p ,sz);\n    deallocate(p, old, sz);\n    return s;\n}\n```\n\n","categories":["Cpp","STL","项目","内存池"]},{"title":"Cpp_STL_iterator","url":"/Cpp/Cpp_STL_iterator/","content":"\n# 内容\n\n1. iterator的分类\n2. iterator的属性\n3. advance--使迭代器移动n步\n4. 针对迭代器的类型萃取\n5. SGI萃取的写法\n6. distance--计算两迭代器之间的距离\n\n# iterator\n\n```c++\n#pragma once\nnamespace xcg\n{\nstruct input_iterator_tag {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag : public input_iterator_tag {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\nusing ptrdiff_t = int;\n\ntemplate<class _C, class _Ty, class _D = ptrdiff_t, class _Pointer = _Ty*,\n\tclass _Reference = _Ty&>\n\tstruct iterator\n{\n\ttypedef _C\t\t\titerator_category;\n\ttypedef _Ty\t\t\tvalue_type;\n\ttypedef _D\t\t\tdifference_type;\n\ttypedef _Pointer\tpointer;\n\ttypedef _Reference\treference;\n};\ntemplate<class _Ty, class _D = ptrdiff_t>\nstruct _Forit : public iterator<forward_iterator_tag, _Ty, _D> {};\ntemplate<class _Ty, class _D = ptrdiff_t>\nstruct _Bidit : public iterator<bidirectional_iterator_tag, _Ty, _D> {};\ntemplate<class _Ty, class _D = ptrdiff_t>\nstruct _Ranit : public iterator<random_access_iterator_tag, _Ty, _D> {};\n\ntemplate<class _II, class _D>\ninline void __advance(_II& i, _D n, input_iterator_tag)\n{\n\twhile (n--) ++i;\n}\ntemplate<class _BI, class _D>\ninline void __advance(_BI& i, _D n, bidirectional_iterator_tag)\n{\n\tif (n >= 0)\n\t{\n\t\twhile (n--) ++i;\n\t}\n\telse\n\t{\n\t\twhile (n++) --i;\n\t}\n}\ntemplate<class _RAI, class _D>\ninline void __advance(_RAI& i, _D n, input_iterator_tag)\n{\n\ti += n;\n}\ntemplate<class _II, class _D>\ninline void advance(_II& i, _D n)\n{\n\n}\n}\n```\n\n```c++\ntemplate<class _Iterator>\nstruct iterator_traits\n{\n    iterator_traits() {}\n\ttypedef typename _Iterator::iterator_category\titerator_category;\n\ttypedef typename _Iterator::value_type\t\t\tvalue_type;\n\ttypedef typename _Iterator::difference_type\t\tdifference_type;\n\ttypedef typename _Iterator::pointer\t\t\t\tpointer;\n\ttypedef typename _Iterator::reference\t\t\treference;\n};\n```\n\n## advance\n\n```c++\ninline void advance(_II& i, _D n)\n{\n\titerator_traits<_II>();\n\ttypedef typename iterator_traits<_II>::iterator_category cate;\n\t__advance(i, n, cate());\n}\n```\n\n## 萃取器\n\n首先是针对泛型iterator，其是标准的迭代器，重载了\\*和->运算符。这里的萃取器可容纳的不包括裸指针。\n\n```c++\ntemplate<class _Iterator>\nstruct iterator_traits\n{\n    iterator_traits() {}\n\ttypedef typename _Iterator::iterator_category\titerator_category;\n\ttypedef typename _Iterator::value_type\t\t\tvalue_type;\n\ttypedef typename _Iterator::difference_type\t\tdifference_type;\n\ttypedef typename _Iterator::pointer\t\t\t\tpointer;\n\ttypedef typename _Iterator::reference\t\t\treference;\n};\n```\n\n接下来是针对裸指针作出的模板特化。裸指针可看作是可随机访问的迭代器。\n\n```c++\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n\titerator_traits() {}\n\ttypedef typename random_access_iterator_tag\t\titerator_category;\n\ttypedef typename T\t\tvalue_type;\n\ttypedef typename int\tdifference_type;\n\ttypedef typename T*\t\tpointer;\n\ttypedef typename T&\t\treference;\n};\n```\n\n接着再次对裸指针的萃取器模板作出部分特化，可处理常裸指针。\n\n```c++\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n\titerator_traits() {}\n\ttypedef typename random_access_iterator_tag\t\titerator_category;\n\ttypedef typename T\t\t\t\tvalue_type;\n\ttypedef typename int\t\t\tdifference_type;\n\ttypedef typename const T*\t\tpointer;\n\ttypedef typename const T&\t\treference;\n};\n```\n\n## 至此代码版本v1\n\n```c++\n#pragma once\nnamespace xcg\n{\nstruct input_iterator_tag {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag : public input_iterator_tag {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\nusing ptrdiff_t = int;\n\ntemplate<class _C, class _Ty, class _D = ptrdiff_t, class _Pointer = _Ty*,\n\tclass _Reference = _Ty&>\n\tstruct iterator\n{\n\ttypedef _C\t\t\titerator_category;\n\ttypedef _Ty\t\t\tvalue_type;\n\ttypedef _D\t\t\tdifference_type;\n\ttypedef _Pointer\tpointer;\n\ttypedef _Reference\treference;\n};\n\ntemplate<class _Iterator>\nstruct iterator_traits\n{\n\titerator_traits() {}\n\ttypedef typename _Iterator::iterator_category\titerator_category;\n\ttypedef typename _Iterator::value_type\t\t\tvalue_type;\n\ttypedef typename _Iterator::difference_type\t\tdifference_type;\n\ttypedef typename _Iterator::pointer\t\t\t\tpointer;\n\ttypedef typename _Iterator::reference\t\t\treference;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n\titerator_traits() {}\n\ttypedef typename random_access_iterator_tag\t\titerator_category;\n\ttypedef typename T\t\tvalue_type;\n\ttypedef typename int\tdifference_type;\n\ttypedef typename T*\t\tpointer;\n\ttypedef typename T&\t\treference;\n};\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n\titerator_traits() {}\n\ttypedef typename random_access_iterator_tag\t\titerator_category;\n\ttypedef typename T\t\t\t\tvalue_type;\n\ttypedef typename int\t\t\tdifference_type;\n\ttypedef typename const T*\t\tpointer;\n\ttypedef typename const T&\t\treference;\n};\n\ntemplate<class _Ty, class _D = ptrdiff_t>\nstruct _Forit : public iterator<forward_iterator_tag, _Ty, _D> {};\ntemplate<class _Ty, class _D = ptrdiff_t>\nstruct _Bidit : public iterator<bidirectional_iterator_tag, _Ty, _D> {};\ntemplate<class _Ty, class _D = ptrdiff_t>\nstruct _Ranit : public iterator<random_access_iterator_tag, _Ty, _D> {};\n\ntemplate<class _II, class _D>\ninline void __advance(_II& i, _D n, input_iterator_tag)\n{\n\twhile (n--) ++i;\n}\ntemplate<class _BI, class _D>\ninline void __advance(_BI& i, _D n, bidirectional_iterator_tag)\n{\n\tif (n >= 0)\n\t{\n\t\twhile (n--) ++i;\n\t}\n\telse\n\t{\n\t\twhile (n++) --i;\n\t}\n}\ntemplate<class _RAI, class _D>\ninline void __advance(_RAI& i, _D n, input_iterator_tag)\n{\n\ti += n;\n}\ntemplate<class _II, class _D>\ninline void advance(_II& i, _D n)\n{\n\titerator_traits<_II>();\n\ttypedef typename iterator_traits<_II>::iterator_category cate;\n\t__advance(i, n, cate());\n}\n}\n```\n\n## SGI的做法\n\n```c++\n//以下三个函数是SGI比较重要的写法模式\ntemplate<class _II>\ninline typename iterator_traits<_II>::iterator_category\niterator_category(const _II&)\n{\n\ttypedef typename iterator_traits<_II>::iterator_category cate;\n\treturn cate();\n}\ntemplate<class _II>\ninline typename iterator_traits<_II>::value_type*\nvalue_type(const _II&)\n{\n\treturn static_cast<typename iterator_traits<_II>::value_type*>(0);\n}\ntemplate<class _II>\ninline typename iterator_traits<_II>::difference_type*\ndifference_type(const _II &)\n{\n\treturn static_cast<typename iterator_traits<_II>::difference_type*>(0);\n}\n```\n\n```c++\ntemplate<class _II, class _D>\ninline void advance(_II& i, _D n)\n{\n    //这里是SGI的写法，使代码更加灵活。\n\t__advance(i, n, iterator_category(i));\n}\n```\n\n## distance\n\n```c++\ntemplate<class _II>\ninline typename iterator_traits<_II>::difference_type\n__distance(_II _F, _II _L, input_iterator_tag)\n{\n\ttypename iterator_traits<_II>::difference_type n = 0;\n\twhile (_F != _L)\n\t{\n\t\t++_F;\n\t\t++n;\n\t}\n\treturn n;\n}\ntemplate<class _RAI>\ninline typename iterator_traits<_RAI>::difference_type\n__distance(_RAI _F, _RAI _L, input_iterator_tag)\n{\n\ttypename iterator_traits<_RAI>::difference_type n = 0;\n\treturn _L - _F;\n}\n\ntemplate<class _II>\ninline typename iterator_traits<_II>::difference_type\ndistance(_II _F, _II _L, input_iterator_tag)\n{\n\treturn __distance(_F, _L, iterator_category(_F));\n}\n```\n\n# 迭代器失效的场景\n可以指向元素的工具：迭代器、指针和引用。有时，虽然迭代器失效，但指针和引用不一定失效。\n\n除了元素的迭代器失效的问题，还要考虑容器end这个迭代器是否失效的问题。**`end()` 特性**：只要元素数变了，之前拿到的 `end()` 立刻失效。\n## vector、string\n1. 只要涉及到扩容，全部迭代器都会失效（包括迭代器、指针和引用）。\n2. insert、push_back：之后，插入点（插入后，放的是新元素）到末尾，这一范围全失效（迭代器、指针和引用）。插入点之前的不受影响。\n    1. `end()` 迭代器失效\n3. erase：之后，删除点（删除后，放的是下一个元素）到末尾，这一范围全失效（迭代器、指针和引用）。删除点之前的不受影响。\n    1. `end()` 迭代器失效\n## deque\n`deque` 不是一整块连续内存，而是**多块定长缓冲区 + 一张“块索引表”(map)**。\n插入可能导致扩容（新分配一个连续内存段）。\n\n迭代器里不仅有元素指针，还带着指向块及索引表的位置；**一旦在两端扩展需要改动索引表，所有迭代器都会失效**。但元素本身通常没搬家，所以**引用/指针多数仍然有效**（除非你删的就是它，或在中间插入/删除导致元素搬动）。这正是它与 `vector`/`list` 最大的差异。\n1. 插入\n    1. 首尾插入\n        1. 规定所有的**迭代器**失效（不包括指针、引用）。\n        2. 引用/指针通常仍指向原元素，不失效！\n            1. 无论是否扩容，其他的元素都是保留在原位置的，因此**其他元素的引用/指针不受影响**。\n    2. 在中间插入\n        1. **所有全失效**（包括迭代器、指针和引用）。\n2. 删除\n    1. 首尾元素\n        1. 被删除元素的迭代器、指针和引用失效。其他元素不影响！\n        2. 如果删除的是首元素，容器的end迭代器不失效（不包括指针、引用）。\n            1. 只有这一种情况不使 `end()` 失效，其他情况都不要用旧的end。\n                1. 但是，有可能虽然是pop_front，但恰好容器中只有一个元素，此时end也会失效。\n        3. 如果删除的是尾元素，容器的end迭代器会失效（不包括指针、引用）。\n    2. 删除中间元素\n        1. **所有全失效**（包括迭代器、指针和引用）。\n\n![](../../images/Cpp_STL_iterator/image-20250822003024458.png)\n\n## list\n1. insert：不会让迭代器失效（所有元素，包括新插入的，都不会失效）。\n    1. 但是，插入后，插入点放的是新元素，原来位置的元素被挤到了右边。如果需要继续向右遍历，记得在插入之后单独做一次`++`。\n2. erase：之后，仅对删除的元素的迭代器失效。其他仍有效。\n## map、multimap、set、multiset\n1. insert：无影响：不会让迭代器、指针、引用失效（所有元素，包括新插入的，都不会失效）。\n2. erase：仅对删除的元素的迭代器、指针、引用失效。其他元素仍有效。\n## unordered_map、unordered_set\n哈希表的插入，可能会存在容器增长导致重新哈希。\n插入后，新容器的尺寸超过其容量阈值（计算方式为容器的 `bucket_count` 乘以其 `max_load_factor`），则会强制执行重新哈希。删除不涉及重新哈希。\n在重新哈希后，容器中的所有迭代器都会失效。（指针、引用仍有效，即使重新哈希）\n\n1. insert：\n    1. 如果不涉及到重新哈希。不会让迭代器、指针、引用失效（所有元素，包括新插入的，都不会失效）。\n    2. 如果重新哈希，容器中的所有迭代器失效。（**但指针、引用仍有效，即使重新哈希**）\n    3. 元素的指针、引用在所有情况下都保持有效，即使在重新哈希之后也是如此。\n2. erase：仅对删除的元素的迭代器、指针、引用失效。其他元素仍有效。\n\n## 其他如queue、stack、`priority_queue​`\n没有提供迭代器。不用谈失效的概念。\n## Array\n1. 固定大小；不会插/删；\n2. 修改元素值**不**使迭代器失效。\n3. `swap(array)` 不失效迭代器（指向同一块内存）。","categories":["Cpp","STL"]},{"title":"练习_Cpp_多线程","url":"/多线程/练习_Cpp_多线程/","content":"# 内容\n\n1. 打印奇偶数\n2. 打印0~100\n3. 三线程依次打印A、B、C\n# 两线程交替打印奇偶数\n\n```c\n#include<thread>\n#include<mutex>\n#include<condition_variable>\n#include<iostream>\nstd::mutex data_mutex;\nstd::condition_variable data_cv;\nbool oddtag = true;\nvoid printodd()//打印奇数\n{\n    std::unique_lock<std::mutex> ulock(data_mutex);\n    for(int odd = 1; odd <= 100; odd+=2)\n    {\n        while(oddtag != true)\n        {\n            data_cv.wait(ulock);\n        }\n        std::cout << \"odd: \" << odd << std::endl;\n        oddtag = false;\n        data_cv.notify_all();\n    }\n}\nvoid printeven()//打印偶数\n{\n    std::unique_lock<std::mutex> ulock(data_mutex);\n    for(int even = 2; even <= 100; even+=2)\n    {\n        while(oddtag == true)\n        {\n            data_cv.wait(ulock);\n        }\n        std::cout << \"even: \" << even << std::endl;\n        oddtag = true;\n        data_cv.notify_all();\n    }\n}\nint main()\n{\n    std::thread thodd(printodd);\n    std::thread theven(printeven);\n\n    thodd.join();\n    theven.join();\n    return 0;\n}\n```\n\n# 三线程打印0~100\n\n## 最原始的忙等待版本\n\n```cpp\n#include<iostream>\nusing namespace std;\nstd::mutex g_mtx;\nstd::condition_variable cv;\nint number = 0;\nvoid fun0()\n{\n    while(number <= 100)\n    {\n        while(number%3 == 0 && number <= 100)\n        {\n            cout << \"fun0 : \" << number << endl;\n            number += 1;\n        }\n    }\n}\nvoid fun1()\n{\n    while(number <= 100)\n    {\n        while(number%3 == 1 && number <= 100)\n        {\n            cout << \"fun0 : \" << number << endl;\n            number += 1;\n        }\n    }\n}\nvoid fun2()\n{\n    while(number <= 100)\n    {\n        while(number%3 == 2 && number <= 100)\n        {\n            cout << \"fun0 : \" << number << endl;\n            number += 1;\n        }\n    }\n}\n```\n\n以上虽然也可以达到多线程打印0~100，但是存在忙等待问题。\n\n## 尝试加锁\n\n```cpp\n#include<iostream>\nstd::mutex g_mtx;\nstd::condition_variable cv;\nint number = 0;\nvoid fun0()\n{\n    unique_lock<std::mutex> locker(g_mtx);\n    while(number <= 100)\n    {\n        while(number%3==0 && number <= 100)\n        {\n            cout << \"fun : 0\" << number << endl;\n            number += 1;\n            cv.notify_one();\n        }\n        cv.wait(locker);\n    }\n}\n//...\n```\n\n但是这里又有问题了，有时候程序可以正常地打印完毕，而有时候则会死在某个位置。\n\n因为`notify_one`有可能没有叫醒那个让程序正常运行下去的线程。\n\n所以需要用到`notify_all()`。\n\n```cpp\n#include<iostream>\nstd::mutex g_mtx;\nstd::condition_variable cv;\nint number = 0;\nvoid fun0()\n{\n    unique_lock<std::mutex> locker(g_mtx);\n    while(number <= 100)\n    {\n        while(number%3==0 && number <= 100)\n        {\n            cout << \"fun : 0\" << number << endl;\n            number += 1;\n            cv.notify_all();\n        }\n        cv.wait(locker);\n    }\n}\n//...\n```\n\n又有了新问题，为什么程序结束不了了？\n\n最后一个人（其实是线程fun1）把自己wait挂起了，睡在了那里。因为它是最后打印的，wait了。别人都因为while退出了，没人去管他了。\n\n所以需要在fun0或fun2线程退出外层while循环时进行再次notify_all进行解除。\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\nusing namespace std;\nmutex mtx;\ncondition_variable cv;\nint count = 1;\n\nvoid print_1()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count <= 100)\n    {\n        while(count%3 == 1 && count <= 100)\n        {\n            cout << \"print_1 : \" << count << endl;\n            count += 1;\n            cv.notify_all();\n        }\n        cv.wait(locker);\n    }\n}\nvoid print_2()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count <= 100)\n    {\n        while(count%3 == 2 && count <= 100)\n        {\n            cout << \"print_2 : \" << count << endl;\n            count += 1;\n            cv.notify_all();\n        }\n        cv.wait(locker);\n    }\n}\nvoid print_3()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count <= 100)\n    {\n        while(count%3 == 0 && count <= 100)\n        {\n            cout << \"print_3 : \" << count << endl;\n            count += 1;\n            cv.notify_all();\n        }\n        cv.wait(locker);\n    }\n    cv.notify_all();\n}\nint main()\n{\n    thread t1(print_1);\n    thread t2(print_2);\n    thread t3(print_3);\n    t1.join();\n    t2.join();\n    t3.join();\n}\n```\n\n## 问题代码 - 未过滤边界, 造成数据溢出\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\nusing namespace std;\nmutex mtx;\ncondition_variable cv;\nint count = 1;\n\nvoid print_1()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 1)\n        {\n            cv.wait(locker);\n        }\n        cout << count << endl;\n        ++count;\n        cv.notify_all();\n    }\n}\nvoid print_2()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 2)\n        {\n            cv.wait(locker);\n        }\n        cout << count << endl;\n        ++count;\n        cv.notify_all();\n    }\n}\nvoid print_3()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 0)\n        {\n            cv.wait(locker);\n        }\n        cout << count << endl;\n        ++count;\n        cv.notify_all();\n    }\n}\nint main()\n{\n    thread t1(print_1);\n    thread t2(print_2);\n    thread t3(print_3);\n    t1.join();\n    t2.join();\n    t3.join();\n}\n```\n\n运行结果是打印`1`到`102`。为什么呢？因为在`while(count%3 != x){cv.wait(locker)}`跳出后没有过滤`count`的大小是否超过了`100`。最外层的`while(count <= 100)`时，`count==99`时，线程1、线程2、线程3都进入其中，线程1顺利执行完毕，线程2、线程3被唤醒后，由于没有判断、过滤`count`的大小是否超过了`100`，则顺利走到下面打印代码部分，相当于漏网之鱼。\n\n## 问题代码 - 某线程退出时未及时更新标识变量导致其他线程阻塞\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\nusing namespace std;\nmutex mtx;\ncondition_variable cv;\nint count = 1;\n\nvoid print_1()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 1)\n        {\n            cv.wait(locker);\n        }\n        if(count <= 100)\n        {\n            cout << count << endl;\n            ++count;\n        }\n        cv.notify_all();\n    }\n}\nvoid print_2()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 2)\n        {\n            cv.wait(locker);\n        }\n        if(count <= 100)\n        {\n            cout << count << endl;\n            ++count;\n        }\n        cv.notify_all();\n    }\n}\nvoid print_3()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 0)\n        {\n            cv.wait(locker);\n        }\n        if(count <= 100)\n        {\n            cout << count << endl;\n            ++count;\n        }\n        cv.notify_all();\n    }\n}\nint main()\n{\n    thread t1(print_1);\n    thread t2(print_2);\n    thread t3(print_3);\n    t1.join();\n    t2.join();\n    t3.join();\n}\n```\n\n这次的打印效果是：`1`到`100`，数目是正确的，不多不少。但是，更尴尬的问题来了，居然在打印100之后阻塞死了！这说明有的线程再也跳不出条件变量上的等待队列了。\n\n关键的解决方法：把每条线程中最后的`++count`语句放到`if(count <= 100)`语句外边。\n\n为什么呢？因为如果`++count`在`if(count <= 100)`才能执行时，就会造成一个问题：线程1判断`count <= 100`通过，可以打印100，之后，`++count`，此时count为101；**此时关键处**：线程2，判断`count <= 100`不通过，那么，`++count`未能执行；这给线程3造成了很大的麻烦：来到了线程3，由于它处在`while(count%3 != x){cv.wait(locker)}`语句中，被线程2唤醒后判断`count%3 == 0`，由于count在上个线程没有更新，所以`count%3 != 0`，这让线程3没能够跳出wait的魔爪。之后，线程1、线程2开心的自己走了，丢下线程3沉睡致死，没人再去唤醒她了......\n\n## 改进版 - 更符合套路的\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\nusing namespace std;\nmutex mtx;\ncondition_variable cv;\nint count = 1;\n\nvoid print_1()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 1)\n        {\n            cv.wait(locker);\n        }\n        if(count <= 100)\n        {\n            cout << count << endl;\n        }\n        ++count;\n        cv.notify_all();\n    }\n}\nvoid print_2()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 2)\n        {\n            cv.wait(locker);\n        }\n        if(count <= 100)\n        {\n            cout << count << endl;\n        }\n        ++count;\n        cv.notify_all();\n    }\n}\nvoid print_3()\n{\n    unique_lock<mutex> locker(mtx);\n    while(count<= 100)\n    {\n        while(count%3 != 0)\n        {\n            cv.wait(locker);\n        }\n        if(count <= 100)\n        {\n            cout << count << endl;\n        }\n        ++count;\n        cv.notify_all();\n    }\n}\nint main()\n{\n    thread t1(print_1);\n    thread t2(print_2);\n    thread t3(print_3);\n    t1.join();\n    t2.join();\n    t3.join();\n}\n```\n\n# 三线程循环打印若干次ABC\n\n如果不加任何控制，则代码如下\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\nusing namespace std;\nvoid print_a()\n{\n    for(int i = 0; i < 10; ++i)\n    {\n        cout << \"A\";\n    }\n}\nvoid print_b()\n{\n    for(int i = 0; i < 10; ++i)\n    {\n        cout << \"B\";\n    }\n}\nvoid print_c()\n{\n    for(int i = 0; i < 10; ++i)\n    {\n        cout << \"C\";\n    }\n}\nint main()\n{\n    thread t1(print_a);\n    thread t2(print_b);\n    thread t3(print_c);\n    t1.join();\n    t2.join();\n    t3.join();\n}\n```\n\n这样的打印将会错乱无章。\n\n需要加线程控制。\n\n下面来说一种方案 - **互斥量+条件变量+标记**\n\n```cpp\nstd::mutex mtx;\nstd::condition_variable cv;\nint isReady = 0;\t//标记该打印第几个字母了\n```\n\n## 常犯的错误\n\n### 没有初始化locker\n\n应在三个函数最开始初始化locker。\n\n```cpp\nmutex mtx;\nvoid print_a()\n{\n    unique_lock<mutex> locker(mtx);\t// must have\n    for(int i = 0; i<10; ++i)\n    {\n        ...\n    }\n}\nvoid print_b()\n{\n    unique_lock<mutex> locker(mtx);\t// must have\n    for(int i = 0; i<10; ++i)\n    {\n        ...\n    }\n}\nvoid print_c()\n{\n    unique_lock<mutex> locker(mtx);\t// must have\n    for(int i = 0; i<10; ++i)\n    {\n        ...\n    }\n}\n```\n\n### wait外围的条件写的是if而不是while\n\n以`print_a`函数举例。\n\n```cpp\nif(isReady%3 != 0)\n{\n    cv.wait(locker);\n}\n```\n\n这是错误的，因为一共有三个线程，每次唤醒时，另外两个人不一定谁能抢到锁，如果唤醒后就直接退出wait，则无法保证线程同步。\n\n## 最终正确的代码\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\nusing namespace std;\nmutex mtx;\ncondition_variable cv;\nint isReady = 0;\n\nvoid print_a()\n{\n    unique_lock<mutex> locker(mtx);\n    for(int i = 0; i < 10; ++i)\n    {\n        while(isReady != 0)\n        {\n            cv.wait(locker);\n        }\n        cout << \"A\";\n        isReady = 1;\n        cv.notify_all();\n    }\n}\nvoid print_b()\n{\n    unique_lock<mutex> locker(mtx);\n    for(int i = 0; i < 10; ++i)\n    {\n        while(isReady != 1)\n        {\n            cv.wait(locker);\n        }\n        cout << \"B\";\n        isReady = 2;\n        cv.notify_all();\n    }\n}\nvoid print_c()\n{\n    unique_lock<mutex> locker(mtx);\n    for(int i = 0; i < 10; ++i)\n    {\n        while(isReady != 2)\n        {\n            cv.wait(locker);\n        }\n        cout << \"C\";\n        isReady = 0;\n        cv.notify_all();\n    }\n}\nint main()\n{\n    thread t1(print_a);\n    thread t2(print_b);\n    thread t3(print_c);\n    t1.join();\n    t2.join();\n    t3.join();\n}\n```\n\n另外，还有一个容易出错的地方，必须`notify_all()`，而不能`notify_one()`。因为如果只唤醒1个的话，有可能是A打印完之后唤醒C，这样C线程不符合条件，继续沉睡，而B线程再也没人唤醒它了，之后三人就都沉睡下去了。\n\n# 打印奇偶数进阶版\n\n现有函数`printNumber`可以用一个整数参数调用，并输出该整数到控制台。\n例如，调用`printNumber(7)`将会输出`7`到控制台。\n\n给你类`ZeroEvenOdd`的一个实例，该类中有三个函数：`zero`、`even`和`odd`。`ZeroEvenOdd`的相同实例将会传递给三个不同线程：\n\n线程`A`：调用`zero()`，只输出`0`\n线程`B`：调用`even()`，只输出偶数\n线程`C`：调用`odd()`，只输出奇数\n修改给出的类，以输出序列`010203040506070809010011012...`，其中总共打印的数字数目必须为`2n`。\n\n实现`ZeroEvenOdd`类：\n\n`ZeroEvenOdd(int n)`用数字`n`初始化对象，表示需要输出的数。\n`void zero(printNumber)`调用`printNumber`以输出一个`0`。\n`void even(printNumber)`调用`printNumber`以输出偶数。\n`void odd(printNumber)`调用`printNumber`以输出奇数。\n\n示例1：\n```\n输入：n = 2\n输出：\"0102\"\n解释：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 \"0102\"。\n```\n\n示例 2：\n```\n输入：n = 5\n输出：\"0102030405\"\n```\n\n提示：`1 <= n <= 1000`\n\n## Leet-code AC版代码\n\n```cpp\nclass ZeroEvenOdd {\nprivate:\n    int n;\n    mutex mtx;\n    condition_variable cv;\n    int num = 1;\n    bool flag = true;\npublic:\n    ZeroEvenOdd(int n) {\n        this->n = n;\n    }\n\n    // printNumber(x) outputs \"x\", where x is an integer.\n    void zero(function<void(int)> printNumber)\n    {\n        unique_lock<mutex> locker(mtx);\n        while(num <= n)\n        {\n            while(flag != true)\n            {\n                cv.wait(locker);\n            }\n            if(num <= n)\n            {\n                printNumber(0);\n            }\n            flag = false;\n            cv.notify_all();\n        }\n    }\n    // 偶数\n    void even(function<void(int)> printNumber)\n    {\n        unique_lock<mutex> locker(mtx);\n        while(num <= n)\n        {\n            while(flag == true || num%2 != 0)\n            {\n                cv.wait(locker);\n            }\n            if(num <= n)\n            {\n                printNumber(num);\n            }\n            ++num;\n            flag = true;\n            cv.notify_all();\n        }\n    }\n    // 奇数\n    void odd(function<void(int)> printNumber)\n    {\n        unique_lock<mutex> locker(mtx);\n        while(num <= n)\n        {\n            while(flag == true || num%2 != 1)\n            {\n                cv.wait(locker);\n            }\n            if(num <= n)\n            {\n                printNumber(num);\n            }\n            ++num;\n            flag = true;\n            cv.notify_all();\n        }\n    }\n};\n```\n\n## 自测试版代码\n\n```cpp\n#include<thread>\n#include<mutex>\n#include<condition_variable>\n#include<functional>\n#include<iostream>\nusing namespace std;\nint n = 100;\nmutex mtx;\ncondition_variable cv;\nint num = 1;\nbool flag = true;\n\nvoid zero()\n{\n    unique_lock<mutex> locker(mtx);\n    while (num <= n)\n    {\n        while (flag != true)\n        {\n            cv.wait(locker);\n        }\n        if (num <= n)\n        {\n            cout << 0;\n        }\n        flag = false;\n        cv.notify_all();\n    }\n}\n// 偶数\nvoid even()\n{\n    unique_lock<mutex> locker(mtx);\n    while (num <= n)\n    {\n        while (flag == true || num % 2 != 0)\n        {\n            cv.wait(locker);\n        }\n        if (num <= n)\n        {\n            cout << num;\n        }\n        ++num;\n        flag = true;\n        cv.notify_all();\n    }\n}\n// 奇数\nvoid odd()\n{\n    unique_lock<mutex> locker(mtx);\n    while (num <= n)\n    {\n        while (flag == true || num % 2 != 1)\n        {\n            cv.wait(locker);\n        }\n        if (num <= n)\n        {\n            cout << num;\n        }\n        ++num;\n        flag = true;\n        cv.notify_all();\n    }\n}\nint main()\n{\n    thread t0(zero);\n    thread t1(odd);\n    thread t2(even);\n\n    t0.join();\n    t1.join();\n    t2.join();\n}\n```\n\n结果\n\n![image-20220525193318608](../../images/多线程练习/image-20220525193318608.png)\n\n","categories":["操作系统","多线程","Cpp","Modern","练习"]},{"title":"Linux_C连接数据库","url":"/数据库/MySQL_Linux下C连接数据库/","content":"\n# 内容\n\n1. C/C++连接数据库 -- C/S结构通式\n2. 基本sql语句\n3. 视图、索引、事务\n\n# 数据库的构成\n\n1. 数据文件--存在磁盘上\n2. 数据库管理系统\n\n# 基本模式\n\n基本模式就是用客户端连接数据库服务器，使用TCP连接。\n\n1. 首先要启动数据库服务，即先把TCP服务端运行起来\n2. 通过客户端连接数据库\n\n\n\n# 相关命令\n\n## linux命令\n\n```bash\nservice mysql status \t# 查看状态\nnetstat -natp\t\t\t# 查看端口状态（看是否有3306即可知mysql服务是否启动）\nservice mysql restart\nservice mysql stop\nservice mysql start\n\n\n```\n\n连接数据库命令\n\n```bash\nmysql -uroot -p\nmysql -u用户名 -h主机地址(省略代表本机) -p密码(最好不要在此明文写出)\n```\n\n## mysql命令\n\n```sql\nselect user,host,plugin from mysql.user;\nALTER user 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY\n'123'; #注册用本地登录方式的root用户，并且设置密码\n```\n\n### 创建数据库\n\n```sql\ncreate database xcg charset=utf8;\nselect database();\ndrop database xcg;\t#删除\n```\n\n### 创建数据表\n\n```sql\n```\n\n### 用户管理与授权\n\n* 查看已注册用户信息\n\n相同名字的user可能有不同的登陆方式，这被认为是两个不同的用户，以host字段区分，有两种host，一种是%，一种是localhost。%是远程登录，localhost是本地登录。\n\n```mysql\nselect user, host, plugin from mysql.user;\n```\n\n![image-20220319085241427](../../images/数据库/image-20220319085241427.png)\n\n* 创建用户\n\n```mysql\n#创建用户示例\ncreate user 'stu'@'localhost' identified by '123';\n#创建用户 并 指定加密方式\ncreate user 'stu1'@'localhost' identified WITH mysql_native_password by '123';\n#创建root的远程登录用户\t'%'\ncreate user 'root'@'%' identified WITH mysql_native_password by '123';\n```\n\n# 远程登录\n\n条件有二\n\n1. 有远程登陆方式的用户以及设置了密码\n2. 配置文件中要设置可以远程登陆\n\n配置文件位置在如下位置，需要修改可以用vi打开。注意，修改前需要切换为管理员模式。\n\n```bash\nvi /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n修改完后，需要重启mysql服务器\n\n```bash\nservice mysql restart\n```\n\n# C语言访问mysql\n\n1. 连接数据库使用的头文件和库文件\n\n   ```c\n   #include<mysql/mysql.h>\t//有的是#include<mysql.h>\n   ```\n\n   注意，程序中使用了访问mysql的有关函数接口，需要在代码链接时指定库名: -lmysqlclient\n\n2. 初始化连接句柄\n\n   ```c\n   MYSQL *mysql_init(MYSQL *mysql);\n   ```\n\n3. 连接数据库\n\n   ```c\n   MYSQL *mysql_real_connect(MYSQL *mysql, const char* host,\n                             const char* user, const char* passwd\n                             const char* db,\tunsigned int port\n                             const char* unix_socket,\n                             unsigned long clientflag);\n   ```\n\n   \n\n## 读\n\n1. 指定select语句\n\n   ```c\n   char * sql = \"select * from student\";\n   if(n != 0)\n   {\n       mysql_close(mysql);\n       exit(1);\n   }\n   ```\n\n2. 获取结果集\n\n   ```c\n   MYSQL_RES * res = mysql_store_result(mysql);\n   if(res == NULL)\n   {\n       mysql_close(mysql);\n       exit(1);\n   }\n   ```\n\n3. 获取结果集的行数、列数\n\n   ```c\n   int num = mysql_num_rows(res);\n   int count = mysql_field_count(mysql);\n   ```\n\n4. 遍历\n\n   ```c\n   for(int i = 0; i<num; ++i)\n   {\n       MYSQL_ROW row = mysql_fetch_row(res);\n       for(int j = 0; j<count; ++j)\n       {\n           printf(\"%s\\t\",row[j]);\n       }\n       printf(\"\\n\");\n   }\n   ```\n\n5. 收尾工作\n\n   ```c\n   mysql_free_result(res);\n   mysql_close(mysql);\n   exit(0);\n   ```\n\n   \n\n# 视图\n\n# 事务\n\n# 索引\n\n创建索引\n\n```mysql\ncreate index t_index on test_index(title(20));\n```\n\n","categories":["Linux","数据库","MySQL"]},{"title":"网络_数据链路层","url":"/网络/网络_数据链路层/","content":"\n# 数据链路层\n\n传输单位：帧\n\n1. 点对点信道和广播信道的特点，及两种信道所使用的协议的特点(PPP和CSMA/DA)\n2. 三个基本问题：\n   1. 封装成帧\n   2. 透明传输\n   3. 差错检测\n3. 以太网MAC层的硬件地址\n4. 适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合\n\n# 点对点信道\n\n点对点信道的数据链路层的协议数据单元——帧。\n\n点对点信道的数据链路层在进行通信时的主要步骤如下：\n\n1. 节点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。\n2. 节点A把封装好的帧发送给节点B的数据链路层。\n3. 若节点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层；否则丢弃这个帧。\n\n# 成帧\n\n什么是成帧？\n\n封装成帧(framing)就是**发送方在一段数据的前后分别添加首部和尾部**，这样就构成了一个帧。**接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束**。\n\n我们知道，分组交换的一个重要概念就是：所有在互联网上传送的数据都以分组（即IP 数据报）为传送单位。网络层的IP数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。\n\n## 帧定界\n\n帧定界是：用于判断帧的边界，从哪开始到哪结束。要用特殊的字符串表示它的开始和特殊的字符串表示结束。\n\n一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行**帧定界**（即确定帧的界限）。此外，首部和尾部还包括许多必要的控制信息。在发送帧时，是从帧首部开始发送的。各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定。显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种**链路层协议都规定了所能传送的帧的数据部分长度上限**——**最大传送单元MTU**(Maximum Transfer Unit)。给出了帧的首部和尾部的位置，以及帧的数据部分与MTU的关系。\n\n* 帧定界的几种方法\n  * 字符填充的首尾界符法\n  * 比特位填充的首位界符法\n  * 字符计数法\n\n当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部开始符SOH而没有传输结束符EOT），必须丢弃。而后面收到的数据有明确的帧定界符（SOH和EOT），因此这是一个完整的帧，应当收下。\n\n## 透明传输\n\n数据部分如果出现和头和尾一样的特殊的字符串或位串的内容，会干扰接收方的定界。\n\n当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。**可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输**。\n\n但当数据部分是非ASCII码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样（如图3-6所示），数据链路层就会错误地“找到帧的边界”，把部分帧收下（误认为是个完整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符SOH）。这样的帧传输不是透明传输。\n\n![image-20220309194235539](../../images/网络_数据链路层/image-20220309194235539.png)\n\n* 理解透明传输\n  * “透明”表示：某一个实际存在的事物看起来却好像不存在一样（例如，你看不见在你前面有块100%透明的玻璃的存在）。\n  * “在数据链路层透明传送数据”——表示无论什么样的比特组合的数据，都**能够按照原样没有差错地通过**这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层有什么妨碍数据传输的东西。或者说，数据链路层对这些数据来说是透明的。\n\n* 解决透明传输问题\n  * 必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符。\n  * 具体的方法是：发送端的数据链路层在**数据中**出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B，二进制是00011011)。\n  * 在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。\n  * 如果转义字符“ESC“也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。\n  * 这种方法称为字节填充(byte stuffing)或字符填充(character stuffing)。\n    ![image-20220309195841138](../../images/网络_数据链路层/image-20220309195841138.png)\n\n## 差错控制：循环冗余校验码计算\n\n被除数是谁？——原始数据+后面补若干个零（生成多项式的最高次幂）。\n\n除数是谁？——生成多项式对应的二进制序列。\n\n商和余数谁是冗余码？——余数。余数位数不够时要在前面补零（最后总位数为生成多项式的最高次幂）\n\nP77 简答题 6 7 8\n\n## 纠错机制-反馈重发机制[传输层]\n\n* 应当明确，“无比特差错”与“无传输差错”是不同的概念。\n  * 在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。\n  * 要做到“无差错传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 \n  * 本章介绍的数据链路层协议都不是可靠传输的协议。\n  * **循环冗余校验码只是在数据链路层保证帧的比特位不出错**，即**无比特差错**。但是复杂的情况如帧丢失、帧重复、帧失序这些复杂错误情况就需要更高层的协议来纠错。这里讨论的反馈重发机制是**传输层的可靠传输的工作原理**。\n\n根据上述，由于检错码不能自动纠正所发现帧乱序的错误，所以当接收方发现错误时，要给发送方反馈信息要求重发。\n\n又叫**自动请求重传ARQ**(Automatic Repeat-reQuest)，重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的帧。\n\n1. 停止-等待方式\n2. 连续工作方式（连续ARQ协议）\n   1. 拉回方式\n   2. 选择性重发方式\n\n### 停止等待协议\n\n* 基本思想\n  * 发送端在**发出一帧后必须停下来等待接收端对所发送的确认帧**进行确认。若确认对方正确收到，则发送方继续发送下一帧，否则，发送方就重发该帧。\n\n* A向B发送帧：\n  * B成功接收到了，且检测后正常，则回传A一个确认帧，被A接收到后，A才继续发送下一个帧。\n  * B接收帧时**检测出错误则丢弃该帧**（或者**帧在传输过程中丢失**），B不会发送任何信息。则A必须重发该帧，直到B成功接收为止。\n    * B等确认要等待多长时间？——A设置了一个**超时计时器**，如果到期之前收到了相应的确认则重置该计时器，继续发送下一个帧。\n    * 若帧正确到达B，但B回送的确认丢失或延迟了，**A未收到B的确认，会超时重发该帧**。**B可能会收到重复的帧**。B如何知道收到了重复的帧，需要丢弃呢？——**编号**。\n      * A为每一个发送的帧都进行编号。若B收到了编号相同的帧，则B认为收到了重复帧，B丢弃重复的帧，**并且B回送确认**。\n      * B为发送的确认也进行编号，指示该确认是对哪一个帧的确认。A根据确认帧及其编号，可以确定它是对哪一个帧的确认，避免重复发送，并且**A可以根据此确认号传送下一个帧**。若为重复的确认，则将其丢弃。\n\n* 确认帧的编号问题\n  * 确认帧（ACKnowledgement, ACK）——正确接收后回传的帧被称为确认帧。\n  * 习惯将确认序号n表示为ACKn，**ACKn表示“第n–1号帧已经收到，现在期望接收第n号帧”**。\n* 性能分析\n  * 停止等待协议实现简单，但**传输距离远时**信道利用率低。\n* 改进\n  * 采用**流水线传输**，就是发送方可连续发送多个帧，不必每发完一个帧就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。从而提高信道利用率。**这是连续ARQ协议的基本思想**。\n* 与ARQ的关系\n  * CRC检验器能够自动丢弃检测到的出错帧。实用的CRC检验器都是用硬件完成的。因此所谓的“丢弃出错帧”，对上层软件或用户来说都是感觉不到的。\n  * 发送端对出错的数据帧进行重传是自动进行的，因而这种**差错控制机制**常简称为ARQ(Automatic Repeat reQuest)，直译是自动重传请求，但意思是自动请求重传。因此**停等协议中包含着ARQ协议**（是一种差错控制机制）\n\n### 连续ARQ\n\n* 基本思想\n  * 发送方在发送一个帧后，**不停下来等待确认帧到来**。而是**连续再发送多个帧**，帧的个数取决于发送方的发送能力和接收端的接收能力。此方式中，必须为不同帧编上序列号作为帧标识。\n  * 接收方一般采用**累积确认**的方式\n\n#### 拉回方式\n\n连续发了多个帧，某一个出错后，从出错的开始需要全部重发，因为要求是按序接收。换言之，一旦接收方发现第n帧出错，则丢弃第n帧及第n帧以后的所有帧。\n\n在等不到2号帧的确认而重传2号数据帧时，虽然结点A已经发完了5号帧，但仍必须向回走，将2号帧及其以后的各帧全部进行重传。连续 ARQ又称为Go-back-N ARQ，意思是当出现差错必须重传时，要向回走N个帧，然后再开始重传。\n\n* 代价：信道的带宽。\n\n#### 选择重发方式\n\n假定发送方连续发送了m帧，而接收方在对收到的数据进行校验后发现第n帧出错(n≤m)，于是**接收方给发送方出错信息要求发送方重发第n帧**。换言之，一旦接收方发现第n帧出错，则丢弃第n帧，但**缓存第n帧以后的所有正确帧**。\n\n选择重发方式与拉回方式比较，前者只重发出错的数据。效率高。\n\n* 代价：存储空间；实现比较复杂\n  * 接收端必须维持一个足够大的缓存以便存储出错帧之后收到的帧，直到出错帧被重传。\n  * 而且它必须具有**将收到的重传帧插入到正确位置**的逻辑功能。发送端也要求更复杂的逻辑功能以便**能够不按顺序发送一个帧**。由于有这样的复杂性，选择重传ARQ远不如go-back-N ARQ用得广泛。\n\n#### 累积确认\n\n即**不必对收到的帧逐个发送确认**，而是对按序到达的**最后一个帧**发送确认，这样就表示：到这个帧为止的所有帧都已正确收到了。\n\n**优点**：容易实现，即使确认丢失也不必重传；**缺点**：不能向发送方反映出接收方已经正确收到的所有帧的信息。\n\n## 流量控制\n\n滑动窗口协议\n\n## 习题\n\n# 使用广播信道的数据链路层\n\n广播信道可以进行一对多的通信。以太网和无线局域网都是广播链路层技术的例子。下面要讨论的局域网使用的就是广播信道。\n\n# 局域网技术\n\n遵循IEEE 802系列标准。实际上局域网体系结构是**物理层和数据链路层**（细分成了MAC[Madium Access Control]子层、LLC[Logical Link Control]子层）。与介质相关的是MAC（与物理层接触），无关的是LLC（与网络层接触）。\n\n## 局域网的特点和分类\n\n局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点\n数目均有限。\n\n局域网可按网络拓扑进行分类。由于集线器(hub)的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了非常广泛的应用。下图为星形网。\n![image-20220309204233779](../../images/网络_数据链路层/image-20220309204233779.png)\n\n下图为总线网，各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。\n![image-20220309204450154](../../images/网络_数据链路层/image-20220309204450154.png)\n\n总线网以传统以太网最为著名，但以太网后来又演变成了星形网。经过四十多年的发展，以太网的速率已大大提高。\n\n## 以太网\n\n现在最常用的以太网的速率是1 Gbit/s（家庭或中小企业）、10 Gbit/s（数据中心）和100 Gbit/s（长距离传输），且其速率仍在继续提高。现在以太网已成为了局域网的同义词，因此谈论局域网可以看作是在谈论以太网。\n\n* 为了通信的简便，以太网的两种措施\n  * 第一，采用较为灵活的**无连接的工作方式**，即不必先建立连接就可以直接发送数据。适配器对发送的数据帧不进行编号，也不要求对方发回确认。这样做可以使以太网工作起来非常简单，而局域网信道的质量很好，因通信质量不好产生差错的概率是很小的。因此，以太网提供的服务是尽最大努力的交付，即**不可靠的交付**。当目的站收到有差错的数据帧时（例如，**用CRC查出差错**），就把帧丢弃，其他什么也不做。**对有差错帧是否需要重传则由高层来决定**。例如，如果高层使用TCP协议，那么TCP就会发现丢失了一些数据。于是经过一定的时间后，TCP就把这些数据重新传递给以太网进行重传。**但以太网并不知道这是重传帧，而是当作新的数据帧来发送**。\n  * 第二，以太网发送的数据都使用**曼彻斯特(Manchester)编码**的信号。我们知道，二进制基带数字信号通常就是高、低电压交替出现的信号。使用这种信号的最大问题就是当出现一长串连续的1或连续的0时，接收端就无法从收到的比特流中提取位同步（即比特同步）信号。如图所示，**曼彻斯特编码的编码方法是把每一个码元再分成两个相等的间隔**。码元1是前一个间隔为低电压而后一个间隔为高电压。码元0则正好相反，从高电压变到低电压（也可采用相反的约定，即1是“前高后低”而0是“前低后高”）。**这样就保证了在每一个比特的正中间出现一次电压的转换，而接收端就利用这种电压的转换很方便地把位同步信号提取出来**。但是从曼彻斯特编码的波形图也不难看出，**其缺点是它所占的频带宽度比原始的基带信号增加了一倍**（因为每秒传送的码元数加倍了）。\n\n## 介质访问控制\n\n介质访问的控制都在MAC子层完成。\n\n最早的以太网是将许多计算机都连接到一根总线上。当初认为这种连接方法既简单又可靠，因为在那个时代普遍认为：“有源器件不可靠，而无源的电缆线才是最可靠的”。\n\n总线的特点是：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。这种就是广播通信方式。\n\n* 为了在总线上实现不干扰他人的一对一的通信，需要采取一些技术措施\n  * 可以使每一台计算机的适配器都拥有一个与其他适配器都不同的地址。在**发送数据帧时，在帧的首部写明接收站的地址**。现在的电子技术可以很容易做到：**仅当数据帧中的目的地址与适配器ROM中存放的硬件地址一致时，该适配器才能接收这个数据帧**，不是发送给自己的数据帧就丢弃。这样，具有广播特性的总线上就实现了一对一的通信。\n  * 除了给每个网络适配器一个单独的地址，还需要解决一个问题，因为**有些节点可能在某一刻同时传输帧，那么所有节点会同时接到多个帧**，这个现象叫做：传输的这些帧在所有的接收方处**碰撞**了。通常，在碰撞发生时，没有一个接收节点能够获得有效帧，因此，涉及此次碰撞的所有帧都消失了，相应的这段时间中广播信道大量带宽会被浪费掉。那么如何来规范广播网络(例如总线网)上的计算机在广播信道上的传输行为呢？这是一个**多路访问问题**。显然需要通过制定**多路访问协议**来解决。\n\n### 适配器的作用\n\n* 重要功能\n  * 进行串行/并行转换\n  * 对数据进行缓存\n  * 在计算机的操作系统安装设备驱动程序\n  * 实现以太网协议\n\n### 媒体共享技术\n\n* 静态划分信道\n  * 频分复用\n  * 时分复用\n  * 波分复用\n  * 码分复用\n* 动态媒体接入控制（多点接入）\n  * 随机接入：所有的用户可随机地发送信息\n  * 受控接入：用户必须服从一定的控制，如轮询(polling)\n\n### 介质访问控制策略\n\n在介质访问控制技术中，最关键的是控制地点和控制方法。\n\n1. 在什么地方对媒体访问进行控制\n\n   * 集中式控制\n     * 指定一个单独的集中控制器或一个具有控制整个网络的能力的节点来管理网络的通信，其将拥有控制网络访问的权利。\n     * 优点\n       * 能提供除了对媒体访问外的其他更高级的功能，如优先级控制、可靠性等。\n       * 每个站点的访问控制逻辑简单\n       * 避免进行分布合作可能带来的协调问题 \n     * 缺点\n       * 如果控制点不能工作，则会导致整个网络瘫痪。\n       * 由于所有访问要经过控制点的允许，可能会形成瓶颈，降低效率。\n   * 分布式控制\n     * 无集中控制节点，各节点均处于平等地位；由各个站点共同完成媒体访问控制功能，动态地确定站点的发送顺序；节点间的通信由各节点自身控制。\n     * 分类\n       * CSMA/CD\n       * 令牌法\n       * 时隙法(Time Slot)\n\n2. 怎么对共享媒体进行控制访问\n\n   * 同步机制：如FDM、TDM等。\n\n   * 异步机制：如时间片轮转（循环式）、预约式、竞争式等。\n\n     |        | 总线拓扑             | 环型拓扑                 |\n     | ------ | -------------------- | ------------------------ |\n     | 循环式 | 令牌总线(IEEE 802.4) | 令牌环(IEEE 802.5; FDDI) |\n     | 预约式 | DQDB(IEEE 802.6)     |                          |\n     | 竞争式 | CSMA/CD(IEEE 802.3)  |                          |\n\n     * 时间片轮转（循环式）\n       * 每个站点按照一定的时间顺序得到传输时间。如果站点利用这个机会发送，则对其发送时间或发送的数据总量有一定限制，超过这个限制的数据只能在下一轮中发送。\n       * 这种顺序控制可能是集中式的，也可能是分布式的。 \n       * 在一段时间内有多个节点要传输数据时，此方式是有效的。\n       * 当要传输数据的节点较少时，时间开销就显得很大。\n     * 预约式\n       * 一般来说，这种技术**把传输媒体的使用时间划分为一些时槽**。一个节点要传输数据时，就可以预约一些时槽进行连续传输。\n       * 适合于传输连续数据的情况。**流式通信就是长时间连续传输**，例如话音通信、遥测通信和长文件的传输等。\n       * 可以是集中式的，也可以是分布式的。\n     * 竞争式\n       * 这种技术并不对各个工作站点的发送权限进行控制，而是由各个工作站点自由竞争发送机会。\n       * 对突发性的数据传输，竞争是最常用的机制。突发式通信就是短时间的少量传输，例如终端和主机之间的通信就是这样的。\n       * 在低负荷时，性能不错。\n       * 是分布式的。\n\n### 多路访问协议\n\n有关多路访问协议方面的研究仍在活跃，所有的多路访问协议可分为三种类型之一：信道划分协议、随机接入协议、轮流协议。\n\n#### 信道划分协议\n\n* 时分多路复用(TDM)\n* 频分多路复用(FDM)\n* 码分多址(Code Division Multiple Access, CDMA)\n\n#### 随机接入协议\n\n在随机接入协议中，一个传输节点总是以信道的全部速率(即R bps)进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧，直到无碰撞地通过为止。但是当一个节点经历一次碰撞时，他不必立刻重发该帧，而是在**重发该帧之前等待一个随机时延**。涉及碰撞的每个节点独立地选择随机时延。因为该随机时延是独立选择的，所以可能：这些节点之一所选择的时延充分小于其他碰撞节点的时延，因此能够无碰撞地将它的帧在信道中发出。\n\n最常用的随机接入协议有**ALOHA协议**和**载波侦听多路访问(CSMA)协议**。以太网是一种流行并广泛部署的CSMA协议。\n\n* ALOHA协议\n  * 访问方式：不监听——随机重发，“发送——冲突——再发送”。\n  * 信道利用率最多为18%\n* 分槽ALOHA协议\n  * 各用户节点只能在下一时间片的起始时刻开始发送信息。\n  * 信道利用率最多为37%\n* CSMA协议\n  * 载波侦听多路访问，Carrier Sense Multiple Access，是一种适合于总线结构的具有信道检测功能的分布式介质访问控制方法，其控制手段称之为“载波侦听”。\n  * 该协议的一般描述非常简单。如果一个站点有一个帧要发送，它遵循下面的规则：1、侦听介质的活动。2、如果没有活动，则立即传送，否则等待。\n  * CSMA分为三种方式，非坚持和坚持CSMA，坚持CSMA又分为“1-坚持CSMA”和“p-坚持CSMA”\n    * 非坚持CSMA：一旦监听到信道忙，就不再监听；延迟一个随机时间后再次监听\n      * 优点：降低了冲突发生概率\n      * 缺点：信道利用率降低\n    * 1-坚持CSMA：监听到信道忙时，仍继续监听，直到信道空闲立即传输。如果冲突，则等待一段随机的时间后重复第一步。\n      * 优点：有利于抢占信道，减少信道空闲时间\n      * 缺点：冲突概率较大\n    * p-坚持CSMA：1、若介质空闲，以概率p传输，以概率(1-p)延迟一个时间单位，该时间单位通常等于最大传播延迟的两倍；2、若介质忙，继续监听直到信道空闲，并重复第1步；3、若传输延迟了一个时间单位，则重复第1步。\n    * 对比：非坚持CSMA协议中的站点是尊重别人的，而“1-坚持”方式是自私的。试图既能如非坚持算法那样减少冲突而又像“1-坚持”算法那样减少空闲时间的一种折衷方案是“p-坚持”协议。\n  * CSMA的意义：在信道忙时不会有其他主机打乱正在进行的发送。由于采用了信道侦听，因此在一定程度上减少了冲突发生的次数，从而提高了信道的利用率和整个网络的吞吐量。\n  * CSMA不能完全避免冲突的原因：当主机A认为信道空闲时，主机B也可能认为信道空闲，因此，两台主机差不多同时发送数据，导致冲突发生。\n\n### 局域网实际常用的访问控制方式\n\n* 目前，计算机局域网常用的访问控制方式有三种，分别用于不同的拓扑结构。\n  * 带有冲突检测的载波侦听多路访问法CSMA/CD (Carrier Sense Multiple Access with Collision Detection)\n  * 令牌环访问控制法(Token Ring)\n  * 令牌总线访问控制法(Token Bus)\n\n|        | 总线拓扑                 | 环型拓扑                     |\n| ------ | ------------------------ | ---------------------------- |\n| 循环式 | **令牌总线**(IEEE 802.4) | **令牌环**(IEEE 802.5; FDDI) |\n| 预约式 | DQDB(IEEE 802.6)         |                              |\n| 竞争式 | **CSMA/CD**(IEEE 802.3)  |                              |\n\n其中CSMA/CD是目前比较流行、应用最广泛的介质访问控制方法，以下重点介绍此访问方法。\n\n#### CSMA/CD协议\n\nCSMA/CD和它之前的ALOHA、CSMA技术都是随机访问和竞争发送协议。随机访问意味着任何节点都无法预计其发送的时刻；竞争发送是指所有发送的节点自由竞争信道的使用权。\n\n回到本原的问题——**如何解决在广播网络中多个帧碰撞的问题**？\n\nCSMA解决的问题只有监听，监听只能把信道冲突率降低。但不能完全避免冲突。关键是：CSMA只是在发送之前进行侦听有无其他占用信道，发送之后就不再侦听了，这样依旧可能会产生碰撞。所以需要发送后也要侦听才行——于是带上了后缀CD，CD指的是Collision Detecion，“带冲突检测”。\n\n> * 数据在发送前监听到信道“空闲”，什么还会产生碰撞？\n>   * 当某站监听到信道是空闲时，可能总线并非真正空闲。电磁波在总线上总是以有限的速率传播。电磁波在1km电缆的传播时延约为5μs。也就是说你听到的已经成为了过去式，不能代表现在进行时。\n\n* CSMA/CD的工作流程\n  1. 先听后发：每个站在发送数据之前先检测总线上是否空闲。如果信道是空闲的，立即抢占总线发送信息。如果信道忙，则退避一段时间再尝试。\n  2. 边听边发：当一个节点将开始发送数据后，在传送的过程中发送者要边发送边监听(listen while talking)\n  3. 冲突停止：如果监测到的信息与发出的不一致，说明发生了冲突，则停止发送，并发送一串阻塞信号以加强冲突。\n  4. 随机延迟后重发：延迟一个随机时间片再去侦听总线，延迟时间短的节点先抢占总线。\n\n##### 争用期\n\n##### 最短帧长\n\n交换机的转发方式有两种：1、直通方式（直接转发）；2、存储转发\n\n直接转发有时只允许转发长度大于64字节的帧，为什么呢？\n\n电磁波在总线上总是以有限的速率传播的，是有时延的。如果总线上传输中的帧很短，可能电磁波侦听不到，就误以为信道是空闲的。\n\n# 交换局域网\n\n## 在数据链路层扩展以太网\n\n### 网桥\n\n* 最初人们使用的是**网桥**，网桥对收到的帧根据其MAC帧的目的地址进行**转发**和**过滤**。当**网桥收到一个帧时，并不是向所有的端口转发此帧，而是根据此帧的目的MAC地址，查找网桥中的地址表，然后确定将该帧转发到哪一个端口**，或者是把它丢弃（即过滤）。\n\n### 交换式集线器\n\n* **交换式集线器(switching hub)**淘汰了网桥，常被称为以太网**交换机(switch)**或**第二层交换机(L2 switch)**，第二层的意思是强调这种交换机工作在数据链路层。以太网交换机的性能远远超过普通的集线器，而且价格也不贵，这就使工作在物理层的集线器逐渐地退出了市场。\n* 以太网交换机实质上就是一个**多端口的网桥**，通常都有十几个或更多的端口，和工作在物理层的转发器、集线器有很大的差别。\n* 以太网交换机的每个端口都直接与一个单台主机或另一个以太网交换机相连，一般都以全双工方式工作。\n* 具有并行性，即可以同时连通多对端口，使多对主机能够同时通信（即可以一次分析、转发多个帧）。\n* 相互通信的主机都独占传输媒体，**无碰撞**地传输数据。换句话说，**每一个端口和连接到端口的主机构成了一个碰撞域，具有N个端口的以太网交换机的碰撞域共有N个**。对于传统的10 Mbit/s 的共享式以太网，若共有10 个用户，则每个用户占有的平均带宽只有1 Mbit/s。\n  * 若使用以太网交换机来连接这些主机，虽然在每个端口到主机的带宽还是10Mbit/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有10个端口的交换机的总容量则为100Mbit/s。这正是交换机的最大优点。\n* 以太网交换机的输出接口设有缓冲存储器，非常类似于路由器接口的缓存。因此，如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的端口繁忙时，发送帧的这两台主机的端口会把收到的帧暂存一下，以后再发送出去。\n\n#### 从总线以太网到星形以太网\n\n传统的电话网是星形结构，其中心就是电话交换机。那么在20世纪70年代中期出现的局域网，为什么不采用这种星形结构呢？这是因为在当时的技术条件下，还很难用廉价的方法制造出高可靠性的以太网交换机。所以那时的以太网就采用无源的总线结构。这种总线式以太网一问世就受到广大用户的欢迎，并获得了很快的发展。\n\n然而随着以太网上站点数目的增多，使得总线结构以太网的可靠性下降。与此同时，大规模集成电路以及专用芯片的发展，使得星形结构的以太网交换机可以做得既便宜又可靠。在这种情况下，采用以太网交换机的星形结构就成为以太网的首选拓扑，而传统的总线以太网也很快从市场上消失了。\n\n总线以太网使用CSMA/CD协议，以半双工方式工作。但以太网交换机不使用共享总线，没有碰撞问题，因此不使用CSMA/CD协议，而是以全双工方式工作。\n\n既然连以太网的重要协议CSMA/CD都不使用了（相关的“争用期”也没有了），为什么还叫作以太网呢？原因就是**它的帧结构未改变，仍然采用以太网的帧结构**。这也就对应了：“交换机对于主机来说是透明的，主机总以为自己在总线上进行通信。”\n\n### 交换机的转发方式（交换方式）\n\n虽然许多以太网交换机对收到的帧采用**存储转发方式**进行转发，但也有一些交换机采用**直通(cut-through)的交换方式**。\n\n直通交换不必把整个数据帧先缓存后再进行处理，而是在**接收数据帧的同时**就**立即**地**按数据帧的目的MAC地址决定该帧的转发端口**，因而提高了帧的转发速度。如果在这种交换机的内部采用基于硬件的交叉矩阵，交换时延就非常小。直通交换的一个缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。\n\n在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如当需要进行线路速率匹配、协议转换或差错检测时。\n\n现在有的厂商已生产出能支持两种交换方式的以太网交换机。以太网交换机的发展与建筑物结构化布线系统的普及应用密切相关。在结构化布线系统中，广泛地使用了以太网交换机。\n\n### 交换机的地址表\n\n以太网交换机是一种即插即用设备，其内部的帧**交换表（又称为地址表）**是通过**自学习算法**自动地逐渐建立起来的。实际上，这种交换表就是一个**内容可寻址存储器CAM(Content Addressable Memory)**。以太网交换机由于使用了专用的交换结构芯片，交换机的硬件转发帧的转发速率要比使用软件转发的网桥快很多。\n\n* 交换机的自学习功能\n  * 假定在图中的以太网交换机有4个端口，各连接一台计算机，其MAC地址分别是A, B, C和D。交换表最重要的就是两个字段：**目的MAC地址**和**相应的转发端口**。在一开始，以太网交换机里面的交换表是空的。\n![image-20220311154911596](../../images/网络_数据链路层/image-20220311154911596.png)\n  * 假定A先向B发送一帧，从端口1进入到交换机。交换机收到帧后，先查找交换表。现在表中没有B的地址。于是，**交换机把此帧的源地址A和端口1写入交换表**中，并**向除端口1以外的所有端口广播这个帧**。如此广播发送就可保证B收到这个帧，而**其他端口**C和D在收到帧后，**因目的地址不匹配将丢弃此帧**。这一过程也称为**过滤**。\n  * 由于在交换表中写入了项目(A, 1)，因此以后不管从哪个端口收到帧，只要其目的地址是A，就把收到的帧从端口1转发出去送交A。\n  * 接下来假定B通过端口3向A发送一帧。交换机查找交换表，发现交换表中的MAC地址有A，表明凡是发给A的帧（即目的地址为A的帧），都应从端口1转发给A。显然，**现在应直接把收到的帧从端口1转发给A，而没有必要再广播收到的帧**。交换表这时用源地址B写入一个项目(B, 3)，表明今后如有发送给B的帧，应从端口3转发给B。\n![image-20220311155521369](../../images/网络_数据链路层/image-20220311155521369.png)\n  * 经过一段时间后，只要主机C和D也向其他主机发送帧，以太网交换机中的交换表就会把转发到C或D应当经过的端口号（2或4）写入交换表中。这样，交换表中的项目就逐渐增多了。\n  * 考虑到有时可能要在交换机的端口更换主机，或者主机要更换其网络适配器，这就需要及时**更新**交换表中的项目。为此，**当交换表中写入一个项目时就记下当时的时间，只要超过预先设定的时间（例如300秒），该项目就自动被删除**。用这样的方法保证交换表中的数据都符合当前网络的实际状况。这就是说，图中的交换表**实际上是有三列，即MAC地址、端口和写入时间**。\n  * 以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。\n\n## 链路层寻址和ARP\n\n# 虚拟局域网\n\n以太网交换机的问世，加速了以太网的普及应用。一个以太网交换机可以非常方便地连接几十台计算机，构成一个星形以太网。但是，当一个以太网包含的计算机太多时，往往会带来两个缺点。\n\n首先，一个以太网是一个广播域。在以太网上经常会出现大量的广播帧。在交换机的交换表的建立过程中要使用许多广播帧。经常使用的ARP和DHCP 协议，也都要在以太网中传送很多的广播帧。在一个主机数量很大的以太网上传播广播帧，必然会消耗很多的网络资源。如果网络的配置出了些差错，就有可能发生广播帧在网络中无限制地兜圈子，形成了“广播风暴”，使整个的网络瘫痪。\n\n其次，一个单位的以太网往往为好几个下属部门所共享。但有些部门的信息是需要保密的（例如，财务部门或人事部门）。许多部门共享一个局域网对信息安全不利。\n\n如果使每一个小部门各拥有自己的较小的局域网，那么这不但可使局域网的广播域范围缩小，同时也提高了局域网的安全性。在以太网交换机出现后，我们可以很方便灵活地建立虚拟局域网VLAN (Virtual LAN)。这样就把一个较大的局域网，分割成为一些较小的局域网，而每一个局域网是一个较小的广播域。\n\n> 在IEEE 802.1Q 标准中，对虚拟局域网VLAN 是这样定义的：\n> 虚拟局域网VLAN是**由一些局域网网段构成的与物理位置无关的逻辑组**，而这些网段具有某些共同的需求。每一个VLAN的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个VLAN。\n\n## 虚拟局域网的以太网帧格式\n\n1988年IEEE批准了802.3ac标准，这个标准定义了以太网的帧格式的扩展，以便支持虚拟局域网。虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN标签(tag)，用来指明发送该帧的计算机属于哪一个虚拟局域网。插入VLAN标签的帧称为802.1Q帧。所以虚拟局域网其实只是局域网给用户提供的一种拓展服务，而并不是一种新型局域网。\n![image-20220311162303692](../../images/网络_数据链路层/image-20220311162303692.png)\n\nVLAN标签字段的长度是4字节，插入在以太网MAC帧的源地址字段和类型字段之间。VLAN标签的前两个字节总是设置为0x8100（即二进制的10000001 00000000），称为IEEE 802.1Q标签类型。\n\nVLAN标签的后两个字节中，前面4位实际上没有什么作用，这里不讨论。**后面的12位是该虚拟局域网VLAN标识符VID (VLAN ID)**，它唯一地标志了802.1Q帧属于哪一个VLAN。12位的VID可识别4096个不同的VLAN。\n\n插入VLAN标签后，802.1Q帧最后的帧检验序列FCS必须重新计算。\n\n当数据链路层检测到MAC帧的源地址字段后面的两个字节的值是0x8100时，就知道现在插入了4字节的VLAN标签。由于用于VLAN的以太网帧的首部增加了4个字节，因此以太网的最大帧长从原来的1518字节（1500字节的数据加上18字节的首部和尾部）变为1522字节。\n\n### 例子\n\n这样的802.1Q帧在什么地方使用呢？用简单例子来说明。\n![image-20220311163430309](../../images/网络_数据链路层/image-20220311163430309.png)\n\n交换机#1连接了7台计算机，组成了一个局域网（一个广播域）。现在把局域网划分为两个虚拟局域网VLAN-10和VLAN-20。这里的10和20是虚拟局域网的编号，即VID字段的值，由交换机管理人员设定。\n\n现在我们有了两个较小的广播域。每台计算机都是通过接入链路(access link)连接到以太网交换机的。管理人员划分虚拟局域网的方法有多种。例如，按交换机的端口划分，或按MAC地址划分。每台主机并不知道自己的VID值（但交换机必须知道这些信息）。这些主机通过接入链路发送到交换机的帧都是标准的以太网帧。\n\n> 在一个用多个交换机连接起来的较大的局域网中，可以灵活地划分虚拟局域网，不受地理位置的限制。一个虚拟局域网的范围可以跨越不同的交换机。当然，所使用的交换机必须要能够识别和处理虚拟局域网。在图中，在另外一层楼的交换机#2连接了5台计算机，并与交换机#1相连接。交换机#2中的两台计算机加入到VLAN-10，而另外3台加入到VLAN-20。这两个虚拟局域网虽然都跨越了两个交换机，但都各自是一个广播域，即VLAN-10是处于同一广播域，VLAN-20处于另一个广播域。\n\n* A给B发（同一交换机，同一VLAN）\n\n现在假定A向B发送帧。由于交换机#1能够根据帧首部的目的MAC地址，识别B属于本交换机管理的VLAN-10，因此就像在普通以太网中那样直接进行帧的转发，不需要使用VLAN标签。这是最简单的情况。\n\n* A给E发（同一VLAN，跨越交换机的情况）\n\n> 连接两个交换机端口之间的链路称为**汇聚链路**(trunk link)或干线链路。\n\n现在假定A向E发送帧。交换机#1查到E并没有连接到本交换机，因此必须从汇聚链路把帧转发到交换机#2，但在**转发之前，要插入VLAN标签**，如果不插入VLAN标签，交换机#2就不知道应把帧转发给哪一个VLAN。因此在有虚拟局域网的以太网中的汇聚链路（两个交换机之间）传送的帧是802.1Q帧。交换机#2在向E转发帧之前，要拿走已插入的VLAN标签，因此E收到的帧就是A发送的标准以太网帧，而不是802.1Q帧。上图说明了这种情况。\n\n> 所以，在有虚拟局域网的以太网中的交换机对于主机来说仍是透明的，交换机在转发给主机前已把VLAN的4字节标签处理。\n\n* A给C发（同一交换机，跨越VLAN）\n\n如果A向C发送帧，情况又怎样呢？这种情况就复杂些了，因为这是在不同网络之间的通信。虽然A和C都连接到同一个交换机，但它们已经处在不同的网络中（VLAN-10和VLAN-20）。这问题是互连网络中的通信问题，已经超过了数据链路层的范围。这要由网络层中的路由器来解决。\n\n不过有的交换机中嵌入了一个用专用芯片构成的转发模块，用来在不同的VLAN之间转发帧。这样就可以不必再使用另外的路由器，而就在交换机中实现了第3层的转发功能（由于使用硬件转发，转发帧的速率提高了，比使用路由器要快）。这种转发功能被称为**第3层交换**，而**这种交换机常称为L3/L2交换机**。\n\n* A给F发（跨越交换机，跨越VLAN）\n\n有了这种第3层交换机，甚至于：连接到不同交换机的A和F，都可以不需要经过另外的路由器而相互通信了。\n","categories":["网络"]},{"title":"Cpp_STL_关联容器","url":"/Cpp/Cpp_STL_关联容器/","content":"# 内容\n\n1. 无序关联容器 - unordered\n    1. 链式哈希表：增删查O(1)。适用于处理海量数据查重复、去重复\n    2. `unordered_set`、`unordered_multiset`\n    3. `unordered_map`、`unordered_multimap`\n2. 有序关联容器\n    1. 红黑树：增删查O($log_2 N$)\n    2. `set`、`multiset`\n    3. `map`、`multimap` \n3. set和map的区别\n    1. set只有key。\n    2. map每一个key都对应一个value。\n# unordered_set\n\n1. 插入：insert\n2. 遍历：iterator\n3. 删除：erase，可按key，也可按iterator\n\n无序set、map的迭代器是forward类型，只能单向，不能双向。\n插入速度快于红黑树，但可能浪费空间。如果hash效果不好，可能效率不高。\n## 插入\n```cpp\n#include<unordered_set>\nusing namespace std;\nint main()\n{\n    unordered_set<int> set1;\n    for(int i = 0; i < 50; ++i)\n    {\n        set1.insert(rand() % 20 + 1)；\n    }\n    cout << set1.size() << endl;\n    cout << set1.count(15) << endl;\n}\n//size是指set容器目前插入了的元素数，可能为小于等于50，因为插入已存在的话则不会重复\n//count是指目标值在set容器中存在的数目，在unordered_set中只可能为1、0，不可能大于1。\n```\n要知道，vector、deque、list的插入都需要一个iterator才能插入，因为它们是顺序容器，没有其他的条件约束，因此要根据程序员的指令用迭代器找位置。\n\n而无序集合底层是红黑树，有严格的约束，要想插入到里面，数据结构本身就会在内部给该值找好位置，因此只需要提供要插入的东西即可。类似地，以哈希表为底层的map也是这样，插入时进行hash运算，已经无形之中确定好了要插入的位置了。因此不需要提供迭代器。\n## 遍历\n\n```cpp\nint main()\n{\n    auto it1 = set1.begin();\n    for(; it1 != set1.end(); ++it1)\n    {\n        cout << *it1 << \" \";\n    }\n    cout << endl;\n}\n```\n\nfor-each语句进行遍历输出：（实际上，for-each的底层就是用迭代器进行的）\n```cpp\nint main()\n{\n    for(int v : set1)\n    {\n        cout << v << \" \";\n    }\n    cout << endl;\n}\n```\n## 删除\n\n删除某值的元素。\n\n```cpp\nint main()\n{\n    for(auto it1 = set1.begin(); it1 != set1.end(); ++it1)\n    {\n        if(*it1 == 30)\n        {\n            // 记得更新迭代器，因为如果不更新的话，it1将会失效\n            it1 = set1.erase(it1);\n        }\n    }\n}\n```\n如果是multiset，则有可能不止一个此值的元素，需要更新迭代器。千万要注意迭代器的`++`操作不再像之前一样无脑地在for的第三个位置`++`，而是下移到else的情况。\n```cpp\nint main()\n{\n    // set2 为 multiset\n    for(auto it2 = set2.begin(); it2 != set2.end(); )\n    {\n        if(*it2 == 30)\n        {\n            // 记得更新迭代器，因为如果不更新的话，it1将会失效\n            it2 = set2.erase(it1);\n        }\n        else\n        {\n            ++it2;\n        }\n    }\n}\n```\n## find\n\n去找指定值的元素，存在则返回其迭代器，不存在则返回`end()`\n```cpp\nint main()\n{\n    it1 = set1.find(20);\n    if(it1 != set1.end())\n    {\n        set1.erase(it1);\n    }\n}\n```\n# unordered_map\n\n```cpp\n#include<unordered_map>\nint main()\n{\n    unordered_map<int, string> map1;\n    map1.insert(1000, \"张三\");\n    map1.insert(make_pair(1001, \"李四\"));\n    // C++11 的便捷方式：括号对\n    map1.insert({1002, \"王五\"});\n    map1.insert({1000, \"老六\"});\n    \n    cout << map1.size() << endl;\n}\n// 结果为3，因为老六的1000号重复了\n```\n## `operator[]`\n\n访问或**插入**数据元素。返回一个对应键值对中的值的引用。\n```cpp\nint main()\n{\n    cout << map1[1000] << endl;\n    map1[1000] = \"张四\";\n}\n```\n如果访问一个不存在的key：\n则创建一个键值对，key为访问的值，value用对应的数据结构的默认构造进行构造。同时，返回一个对应键值对中的值的引用。\n```cpp\nint main()\n{\n    cout << map1.size() << endl;\n    map1[2000];\n    cout << map1.size() << endl;\n}\n// 结果是[]访问2000后，size会在之前的基础上加1。\n```\n## 删除：erase\n\n```cpp\nint main()\n{\n    map1.erase(1002); // {1002, \"王五\"} 被删除\n}\n```\n## find\n\n```cpp\nint main()\n{\n    auto it1 = map1.find(1001);\n    if(it1 != map1.end())\n    {\n        // 如果找到了，则返回的是一个pair对象\n        cout << \"key: \" << it1->first << \", value: \" << it1->second << endl;\n    }\n}\n```\n## 遍历\n\n```cpp\nint main()\n{\n    for(cosnt pair<int, string> &p : map1)\n    {\n        //...\n    }\n}\n```\nfor-each方法：\n```cpp\nint main()\n{\n    auto it = map1.begin();\n    for(; it != map1.end(); ++it)\n    {\n        // ...\n    }\n}\n```\n# 体验无序关联容器（哈希表）的查重能力\n\n```cpp\nint main()\n{\n    const int ARR_LEN = 100000;\n    int arr[ARR_LEN] = { 0 };\n    for(int i = 0; i < ARR_LEN; ++i)\n    {\n        arr[i] = rand() % 10000 + 1;\n    }\n\n    unordered_map<int, int> map1;\n    for(int key : arr)\n    {\n        auto it = map1.find(key);\n        if(it == map1.end())\n        {\n            map1.insert({key, 1});\n        }\n        else\n        {\n            ++it->second;\n        }\n\n        //其实以上这些东西可以用一句话来代替：\n        //++map1[key];\n    }\n    for(const pair<int, intg> &p : map1)\n    {\n        if(p.second > 1)\n        {\n            cout << \"key: \" << p.first << \"重复\" << p.second << \"次\" << endl;\n        }\n    }\n}\n```\n在上面的10万个整数中，统计哪些数字重复了，并且统计数字重复的次数。\n用数组找效率是很低的。则用哈希表。\n## 去重、打印\n\n```cpp\nint main()\n{\n    // arr是有重复数字的数组\n    unordered_set<int> set;\n    for(int v : arr)\n    {\n        set.insert(v);\n    }\n    for(itn v : set)\n    {\n        cout << v << \" \";\n    }\n    cout << endl;\n}\n```\n# set\n有序的map、set的底层都是红黑树。\nset相当于只有键，没有值的map。\n```cpp\nint main()\n{\n    std::set<int> my_set{1, 2, 3, 4, 5, 5, 3};\n    for (auto&& v : my_set)\n    {\n        std::cout << v << std::endl;\n    }\n}\n```\n输出1 2 3 4 5\n## 插入自定义对象\n\n由于是有序容器，所以类对象必须可以做到可比较。因此必须重载比较运算符。\n而具体地，如果不重载运算符，直接插入，报错：\n```\nerror C2676: 二进制“<”:“const _Ty”不定义该运算符或到预定义运算符可接收的类型的转换\n```\n意味着，插入有序容器，必须要重载`<`运算符，且只能是`<`，经测试，只重载`>`仍报错，所以至少要重载`<`运算符。\n\n```cpp\nclass Student\n{\npublic:\n    Student(int id, string name)\n        :_id(id = 0), _name(name = \"\") {}\n    bool operator<(const Student &stu) const\n    {\n        return _id < stu._id;\n    }\nprivate:\n    int _id;\n    string _name;\n    friend ostream &operator<<(ostream &out, const Student &stu);\n};\nostream& operator<<(ostream& out, const Student& stu)\n{\n    out << \"id: \" << stu._id << \" name: \" << stu._name;\n    return out;\n}\nint main()\n{\n    set<Student> set1;\n    set1.insert(Student(1000, \"zhangsan\"));\n    set1.insert(Student(1020, \"lisi\"));\n}\n```\n## 遍历\n```cpp\n#include<set>\nint main()\n{\n    set<int> set1;\n    for(int i = 0; i < 20; ++i)\n    {\n        set1.insert(rand() % 20 + 1);\n    }\n    for(int v : set1)\n    {\n        cout << v << \" \";\n    }\n    cout << endl;\n}\n//将会按序从小到大输出内容：1 2 3 5 6 8 10 12 15 16 17 19\n```\n实际的过程是对该红黑树进行中序遍历。\n### 迭代器遍历\n\n```cpp\nint main()\n{\n    for(auto it = set1.begin(); it != set1.end(); ++it)\n    {\n        // 元素的<<输出操作符已经被重载，所以可以直接写如此。\n        cout << *it << endl;\n    }\n}\n//输出结果：\n//id: 1000 name: zhangsan\n//id: 1020 name: lisi\n```\n# map\n存的是键值对，有序，所以也称为字典。\n遍历时得到的是pair（对儿），定义于`<utility>`中。\n底层结构是红黑树。\n## insert、遍历\ninsert只能接收pair或者`{ 4, 'd' }`。然后系统需要临时构造对象后插入。\n```cpp\nint main()\n{\n    std::map<unsigned, char> my_map{{1, 'a'}, {2, 'b'}, {3, 'c'}};\n\n    std::pair<unsigned, char> pr;\n    pr.first = 4;\n    pr.second = 'd';\n    my_map.insert(pr);\n    \n    for (auto it = my_map.begin(); it != my_map.end(); ++it)\n    {\n        std::cout << (*it).first << \" \" << it->second << std::endl;\n    }\n}\n```\nranged for让遍历更简洁：\n```cpp\nint main()\n{\n    for (auto&& v : my_map)\n    {\n        std::cout << v.first << \" \" << v.second << std::endl;\n    }\n}\n```\n## 结构化绑定\n`C++17`之后，甚至能把key和value分开提取：叫做结构化绑定（structured binding）\n```cpp\nint main()\n{\n    for (auto&& [v, v2] : my_map)\n    {\n        std::cout << v << \" \" << v2 << std::endl;\n    }\n}\n```\n\n```cpp\nstruct A\n{\n    int a;\n    int a2;\n    int a3;\n};\nA bar(void)\n{\n    return {1, 2, 3};\n}\nint main()\n{\n    auto&& [a, b, c] = bar();\n    std::cout << a << ',' << b << ',' << c << std::endl;\n}\n```\n\n```cpp\nA aa{ 4, 5, 6 };\nA& foo(void)\n{\n    return aa;\n}\nint main()\n{\n    auto&& [a, b, c] = foo();\n    std::cout << a << ',' << b << ',' << c << std::endl;\n    a = 9; // 外部aa中的第一个值也会变为9\n}\n```\n### emplace插入\n可以直接拿散装的参数合成pair，就地构造。不会造成多余的复制。\n```cpp\nint main()\n{\n    std::map<unsigned, char> my_map{{1, 'a'}, {2, 'b'}, {3, 'c'}};\n\n    my_map.emplace(5, 'e');\n}\n```\n### 在同一key重复插入\n1. 如果在同一key重复插入其他的value值，不会改变原value值。应该会放弃插入。这种情况包含emplace和insert。（在`C++23`下测试）\n2. 但是如果用`[]`来写入的话，是会被改的。\n3. `insert_or_assign`是插入或修改。如果没有该key则插入，如果存在该key则改变。\n```cpp\nint main()\n{\n    std::map<unsigned, char> my_map{{1, 'a'}, {2, 'b'}, {3, 'c'}};\n\n    my_map.emplace(3, 'e');\n    my_map.emplace(3, 'f');  // 不会把e改为f\n    my_map.insert({3, 'g'}); // 不会改为g\n    my_map[3] = 'h';         // 会改为h\n    my_map.insert_or_assign(3, 'i'); // 会改为i\n}\n```\n## 查询\n### `std::find`\n如果清楚key、value，则可以按照具体的pair进行find。pair必须写明键值类型，否则可能会产生二义性无法推断明确的类型。\n```cpp\nint main()\n{\n    std::map<unsigned, char> my_map( {1, 'a'}, {2, 'b'}, {3, 'c'});\n    std::pair<unsigned, char> pr = {3, 'c'};\n    auto it = std::find(my_map.begin(), my_map.end(), pr);\n}\n```\n如果不记得value值。用find_if。因为map的键是唯一的，只能对应一个值。\n```cpp\nint main()\n{\n    std::map<unsigned, char> my_map( {1, 'a'}, {2, 'b'}, {3, 'c'});\n    auto it = std::find_if(\n        my_map.begin(),\n        my_map.end(),\n        []() -> bool\n        {\n            return v.first == 3;\n        });\n}\n```\n### `map::find`\n这是map自带的find，效率更高，因为利用了自身红黑树的特性。\n```cpp\nint main()\n{\n    std::map<unsigned, char> my_map( {1, 'a'}, {2, 'b'}, {3, 'c'});\n    auto it = my_map.find(3);\n    if (it != my_map.end())\n    {\n        std::cout << it->second << std::endl;\n    }\n```\n### `[]`\n可用`[]`查询，但是有副作用，如果查询一个不存在的key会默认构造一个键值对。\n```cpp\nint main()\n{\n    std::map<unsigned, char> my_map( {1, 'a'}, {2, 'b'}, {3, 'c'});\n    std::cout << my_map[30] << std::endl;\n}\n```\n## 插入需要基于Compare\nmap插入是需要对比key的大小关系的，对于有默认大小关系的可以自然插入。\n但对于自定义类，就需要添加一个仿函数作为比较器了。仿函数中的`()`记得加上const修饰。只需要实现一个`<`关系即可。\n```cpp\nclass A\n{\npublic:\n    A(unsigned val) : _val{ val } {}\n    unsigned _val;\n};\nclass KeyComp\n{\npublic:\n    bool operator (A const& left, A const& right) const\n    {\n        return left._val < right._val;\n    }\n};\nint main()\n{\n    std::map<A, char, KeyComp> my_map{ {{1}, 'a'}, {{2}, 'b'}, {{3}, 'c'} };\n    return 0;\n}\n```\n除了使用仿函数作为比较器，也可以直接在自定义类中定义`<`函数。\n```cpp\nclass A\n{\npublic:\n    A(unsigned val) : _val{ val } {}\n    bool operator() (A const& other) const\n    {\n        return _val < other._val;\n    }\n    unsigned _val;\n};\nint main()\n{\n    std::map<A, char> my_map{ {{1}, 'a'}, {{2}, 'b'}, {{3}, 'c'} };\n    return 0;\n}\n```\n# multimap\n一个键可以对应多个value。\n如果我们使用的是普通map，可以用list作为值类型，嵌套的容器，来实现一键多值。\n```cpp\nint main()\n{\n    std::map<unsigned, std::list<char>> my_container{\n        {1u, {'a', 'b', 'c'}},\n        {2u, {'d', 'e', 'f'}},\n        {3u, {'g', 'h', 'i'}},\n        {4u, {'j', 'k', 'l'}} };\n    for (auto&& v : my_container)\n    {\n        std::cout << \"Key: \" << v.first << \" values: \";\n        for (auto&& v2 : v.second)\n        {\n            std::cout << v2 << \" \";\n        }\n        std::cout << stdd::endl;\n    }\n    \n}\n```\n输出：\n```\nkey: 1 values: a b c\nkey: 2 values: d e f\nkey: 3 values: g h i\nkey: 4 values: j k l\n```\n如果用multimap，将会更简单：\n```cpp\nint main()\n{\n    std::multimap<unsigned, char> multi_map{\n        {1u, 'a'}, {1u, 'b'}, {1u, 'c'},\n        {2u, 'd'}, {2u, 'e'}, {2u, 'f'},\n        {3u, 'g'}, {3u, 'h'}, {3u, 'i'},\n        {4u, 'j'}, {4u, 'k'}, {4u, 'l'} };\n    for(auto&& v : multi_map)\n    {\n        std::cout << v.first << \" \" << v.second << std::endl;\n    }\n}\n```\n## 查询：equal_range\n会返回一个pair，pair的first是查询到的对应key的第一个键值对的迭代器，second是符合要求的键值对的end迭代器。\n同一个key对应的多个键值对是按顺序的。所以可以用`++it`遍历。\n```cpp\nint main()\n{\n    std::multimap<unsigned, char> multi_map{ /* ... */ };\n    auto it_pair = multi_map.equal_range(3u);\n    for(auto it = it_pair.first; it != it_pair.second; ++it)\n    {\n        std::cout << it->first << \" \" << it->second << std::endl;\n    }\n}\n```\n输出：\n```\n3 g\n3 h\n3 i\n```\n用structured binding：\n```cpp\nint main()\n{\n    std::multimap<unsigned, char> multi_map{ /* ... */ };\n    auto && [it, end] = multi_map.equal_range(3u);\n    for(; it != end; ++it)\n    {\n        std::cout << it->first << \" \" << it->second << std::endl;\n    }\n}\n```\n## lower_bound\n返回的是参数key对应的键值对中位置最小的迭代器。比如查的是3u，则返回`{3u, g}`对应的迭代器。\n```cpp\nint main()\n{\n    std::multimap<unsigned, char> multi_map{ /* ... */ };\n    auto lower_it = multi_map.lower_bound(3u);\n    for (auto it = multi_map.begin(); it != lower_it; ++it)\n    {\n        std::cout << it->first << \" \" << it->second << std::endl;\n    }\n}\n```\n输出\n```\n1 a\n1 b\n1 c\n2 d\n2 e\n2 f\n```\n对应的还有upper_bound。比如查的是3u，则返回`{4u, j}`对应的迭代器。即3u所有键值对末尾的下一个迭代器。\n```cpp\nint main()\n{\n    std::multimap<unsigned, char> multi_map{ /* ... */ };\n    auto upper_it = multi_map.upper_bound(3u);\n    // 从\n    for (; upper_it != multi_map.end(); ++upper_it)\n    {\n        std::cout << it->first << \" \" << it->second << std::endl;\n    }\n}\n```\n输出\n```\n4 j\n4 k\n4 l\n```","categories":["Cpp","STL"]},{"title":"Cpp_STL_deque","url":"/Cpp/Cpp_STL_deque/","content":"\n# 内容\n\n1. deque\n\n# 构造\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tvector<int> ar1;\t//空vector\n\tvector<int> ar2 = { 12,23,34,45,56,67,78,89 }; //类似数组的初始化方式\n\tvector<int> ar3(10, 23); //存10个23\n\tvector<int> ar4({ 12,23,34,45,56,67 }); //初始化列表作为参数构造\n\tvector<int> ar5(ar2); //拷贝构造，按ar2的有效size\n\tvector<int> ar6(std::move(ar2)); //移动构造\n}\n```\n\n# emplace和push\n\n首先来看隐式转换的概念：\n\n```c++\nclass Object\n{\n    int val;\npublic:\n    Object(int val) : val(val) { }\n    \n};\nint main()\n{\n    vector<Object> objvec;\n    objvec.push_back(20); //隐式转换20，创建临时对象Object(20)。实际上是：emplace_back(Object(20))\n    objvec.emplace_back(20); //在vec.end()处直接定位new Object(20)\n    \n}\n```\n\n# vector与智能指针结合\n\n```c++\nint main()\n{\n    std::vector<Shape*> shape;\n    string name;\n    while(cin >> name, name != \"end\")\n    {\n        if(name == \"Circle\")\n        {\n            shape.push_back(new Circle());\n        }\n        else if(name == \"Square\")\n        {\n            shape.push_back(new Square());\n        }\n        else\n        {\n            cout << \"input class name error: \" << name << endl;\n        }\n    }\n    for(auto & x : shape)\n    {\n        x->draw();\n        x->erase();\n    }\n}\n```\n\n","categories":["Cpp","STL"]},{"title":"Cpp_STL_list","url":"/Cpp/Cpp_STL_list/","content":"# 内容\n\n1. list\n2. 区分：list是双向迭代器，vector是随机迭代器\n\n# 构造\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tvector<int> ar1;\t//空vector\n\tvector<int> ar2 = { 12,23,34,45,56,67,78,89 }; //类似数组的初始化方式\n\tvector<int> ar3(10, 23); //存10个23\n\tvector<int> ar4({ 12,23,34,45,56,67 }); //初始化列表作为参数构造\n\tvector<int> ar5(ar2); //拷贝构造，按ar2的有效size\n\tvector<int> ar6(std::move(ar2)); //移动构造\n}\n```\n\n# 与vector的区别\n\n1. 底层实现\n2. 空间利用率\n3. 查询元素\n    1. vector：iterator `operator[]`，`find` O(n)，`binary_search` O(logn)\n    2. list：iterator `find` O(n)\n4. 插入和删除\n    1. vector需要分的情况较多\n        1. 看是否需要增容；\n        2. 在中间插入还是在最后插入；\n        3. 删除：最后删除O(1)，中间删除需要内存拷贝；\n        4. resize和reserve的区别\n    2. list：\n        1. 插入O(1)，需要内存申请，\n        2. 删除O(1)，需要内存释放。\n5. 迭代器：\n    1. vector：\n        1. 随机迭代器，可检查越界。支持`++`，`--`，`+`，`+=`，`<`，`>`，`==`，`!=`；\n        2. 插入和删除元素可能导致迭代器失效。\n    2. list：\n        1. 插入元素不会导致迭代器失效，但是是插在当前迭代器指向的位置之前，插入后迭代器指向新插的位置；原位置的被挤到了右面。所以，如果需要在插入后继续遍历， 需要单独`++`1次。\n        2. erase删除元素，被删的元素的迭代器失效。\n# 如何抉择？\n\n什么时候该用vector？什么时候该用list？\n1. 如果需要高效的随机存取，而不在乎插入和删除的效率（很少使用插入和删除操作)。选用vector。\n2. 如果需要大量的插入和删除的操作，随机存取很少使用。选用list。\n## 举例\n\n例1∶比如制作了一个游戏玩家排行榜，那么就要实时刷新这个排行榜，这个时候，如果有人达到排行的条件，那么就要把他加进去，如果人数多出了，那么就把排名靠后的移除掉，这就需要大量的插入删除操作，那么这个时候就应该优先考虑list，而不是vector。\n## 中间插入\n想在某个值的元素前面插入一个元素，首先需要find出位置并得到迭代器it，然后在it位置进行插入。\n```cpp\nint main()\n{\n    std::list<int> lst{ 1, 2, 3, 4, 5, 6, 7, 8 };\n    auto it = std::find(lst.begin(), lst.end(), 5);\n    \n    lst.emplace(it, 50);\n    \n    std::for_each(\n        lst.cbegin(),\n        lst.cend(),\n        [](auto&& v)\n        {\n            std::cout << v << std::endl;\n        });\n}\n```\n>emplace:\n>（1）在位置插入新元素。\n>（2）与其他标准顺序容器不同，`list`和`forward_list`经过专门设计，可以在任何位置高效地插入和删除元素，即使在序列的中间也是如此。\n>（3）就地构造\n>返回值：\n>一个指向新插入元素的迭代器。","categories":["Cpp","STL"]},{"title":"Cpp_STL_vector","url":"/Cpp/Cpp_STL_vector/","content":"\n# 内容\n\nvector\n\n# 构造\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\n\tvector<int> ar1;\t//空vector\n\tvector<int> ar2 = { 12,23,34,45,56,67,78,89 }; //类似数组的初始化方式\n\tvector<int> ar3(10, 23); //存10个23\n\tvector<int> ar4({ 12,23,34,45,56,67 }); //初始化列表作为参数构造\n\tvector<int> ar5(ar2); //拷贝构造，按ar2的有效size\n\tvector<int> ar6(std::move(ar2)); //移动构造\n}\n```\n\n# emplace和push\n\n首先来看隐式转换的概念：\n\n```c++\nclass Object\n{\n    int val;\npublic:\n    Object(int val) : val(val) { }\n    \n};\nint main()\n{\n    vector<Object> objvec;\n    objvec.push_back(20); //隐式转换20，创建临时对象Object(20)。实际上是：emplace_back(Object(20))\n    objvec.emplace_back(20); //在vec.end()处直接定位new Object(20)\n    \n}\n```\n\n# vector与智能指针结合\n\n```c++\nint main()\n{\n    std::vector<Shape*> shape;\n    string name;\n    while(cin >> name, name != \"end\")\n    {\n        if(name == \"Circle\")\n        {\n            shape.push_back(new Circle());\n        }\n        else if(name == \"Square\")\n        {\n            shape.push_back(new Square());\n        }\n        else\n        {\n            cout << \"input class name error: \" << name << endl;\n        }\n    }\n    for(auto & x : shape)\n    {\n        x->draw();\n        x->erase();\n    }\n}\n```\n\n","categories":["Cpp","STL"]},{"title":"Cpp_兼容C和Cpp的思想_完美转发","url":"/Cpp/Cpp_兼容C和Cpp的思想_完美转发/","content":"# 内容\n\n重点是模板的思想，使得Cpp在包罗万象时如虎添翼：模板中的类型，把要用到的类型信息萃取出来给模板函数，而原本的类型信息不丢失。使得在有型和无型之间游离。这达到了很多的效果，包括把c子集和class子集中基本数据类型和自定义类型的鸿沟给填补了。\n# 模板是C范式和Class范式的桥梁\n1. C子集（面向过程）\n2. Class子集（面向对象）\n3. STL\n4. 模板--可以跨越C和Class子集。\n# 模板跨越c和class\n\n先小试牛刀，初次感受。\n\n下面的代码奇妙之处就是：使用了模板后，你并不清楚T是内置类型还是封装类型，所以要完成统一内置类型和封装类型的操作必定很麻烦。模板的强大背后都是心酸。\n```c++\ntemplate<class T>\nvoid fun(T a)\n{\n    \n}\nfun<int>(12);\nfun<Object>(obj);\n```\n\n在谈下一个知识“完美转发”之前，我们先来一段C++11之后，左值右值的重载情况：\n\n```c++\n#include<iostream>\nusing namespace std;\nvoid fun(int& a)\n{\n\tcout << \"fun(int& a)\" << endl;\n}\n// const int&是个万能引用，左右值都可以接收，\n// 但是如果fun有int &&的重载则int &&（如右值10）优先被其接收；\n// 同样的道理，如果fun有int &的重载则int &（如左值a）优先被其接收\nvoid fun(const int& a)\n{\n\tcout << \"fun(const int& a)\" << endl;\n}\nvoid fun(int&& a)\n{\n\tcout << \"fun(int&& a)\" << endl;\n}\n//void fun(int a){} //与fun(int &)冲突\nint main()\n{\n\tint a = 10;\n    const int b = 20;\n\tfun(a);\t\t//fun(int& a)\n\tfun(b);\t\t//fun(const int& a)\n\tfun(10);\t//fun(int&& a) --> 虽然10也可以被const int &接收，但是C++11开始后，重载对值的类型、左右值进行了清晰的划分。以前只按类型重载，之后按左右值也可以重载。\n}\n```\n\n结合下面的情况，我们为了在fac中调用其他函数使用到tmp时保持其右值属性，使用到完美转发\n\n```c++\nvoid fun(int& a)\n{\n\tcout << \"fun(int& a)\" << endl;\n}\nvoid fun(const int& a)\n{\n\tcout << \"fun(const int& a)\" << endl;\n}\nvoid fun(int&& a)\n{\n\tcout << \"fun(int&& a)\" << endl;\n}\ntemplate<class T>\nvoid fac(T && tmp)\n{\n    //cout << std::is_rvalue_reference<T> << endl;\n    //cout << std::is_lvalue_reference<T> << endl;\n    fun(tmp);\n    // 虽然在调用fac时，tmp传入此函数中前是一个右值，但是传参动作完成后tmp成为了一个具名变量，则又退化为了左值，导致只能调用fun(int& a)。\n    //所以我们需要一个机制，来保持变量的左右值属性。即完美转发\n    fun(std::forward<T>(tmp)); //依然保持tmp的右值属性，使其可以调用fun(int&& a)。\n}\nint main()\n{\n    int a = 10;\n    const int b = 20;\n    fac(a);\n    fac(b);\n    fac(20);\n    return 0;\n}\n/* 运行结果\n    fac(a);-----------------\n            fun(int& a)\n            fun(int& a)\n    fac(b);-----------------\n            fun(const int& a)\n            fun(const int& a)\n    fac(20);-----------------\n            fun(int& a)\t\t\t-->***完美转发之前\n            fun(int&& a)\t\t-->***完美转发之后\n*/\n```\n\n有一个很疑惑的问题：既然`fac(a);` `fac(b);`编译通过了，为什么完美转发后运行的结果还是`fun(int& a)`、`fun(const int& a)`？\n\n```c++\nvoid fun(int& a)\n{\n    cout << \"fun(int& a)\" << endl;\n}\nvoid fun(const int& a)\n{\n    cout << \"fun(const int& a)\" << endl;\n}\nvoid fun(int&& a)\n{\n    cout << \"fun(int&& a)\" << endl;\n}\nvoid test(int&& a)\t\t\t//--与上一个例子最大的区别：不是模板函数!\n{\n    fun(a);\n    fun(std::forward<int>(a));\n}\nint main()\n{\n    int a = 10;\n    const int b = 20;\n    //test(a);\t\t\t\t// 参数是左值，是无法调用test(int&& a)的，因为编译器规定:无法将‘右值参数’--‘绑定到左值’。\n    //test(std::move(b));\t// 编译器提示：将\"int &&”类型的引用绑定到\"std:remove_reference_t<const int &>”类型的初始值设定项时，限定符被丢弃   --->意思是，警告我们不要这样做。这样会丢失b的const属性。\n    \n    test(std::move(a));\t\t// 但是我们知道，在平时的书写中，int a = 10; int b = a;这种写法是很普遍的，也就是说，虽然右值不能放在左值的位置上，但是左值是可以充当右值使用的，只不过是编译器规定了我们不能在调用函数时与把左值和右值混淆。\n    \t\t\t\t\t\t// 因为不能直接test(a);说明问题所在，所以我们std::move(a)\t\t\t\t\n}\n/* 运行结果\n    fun(int& a)\n    fun(int&& a)\n我们可以看到，在完美转发前，因为到了fun函数中，a又成为了有名变量，所以再次调用fun(a)退化为左值；而完美转发后，可以保持a的右值性。\n*/\n```\n\n这个结果，与上一个代码中的结果（完美转发后运行的结果依旧是`fun(int& a)`、`fun(const int& a)`）一经对比，发现了问题：就是调用`fac(a);` `fac(b);`之前，由于`fac`是一个模板函数，而且参数类型很特殊！这是最关键的点，参数类型是`T && tmp`，这就要求，不管T是什么类型，不管要传入的实参是否是右值属性，我们都可以让其成功进入到此中，甚至他是一个左值（左值是可以充当右值使用的）。而模板机制中的T是会保留传入实参类型的所有信息的，包括const属性和左右值属性，比如`int a = 10;`的a是非常性左值，`const int b = 20;`的b是常性左值。所以，看上去tmp是一个右值，但是tmp的根源属性是外部a、b原来的属性。所以完美转发后的结果依旧是a的非常性左值`int &`，b的常性左值`const int &`。\n\n通过这个例子，可以得出，模板函数的`<class T> void fun(T && tmp)`并未丢弃T元素原本的的const信息、左右值属性。\n\n那么我们来小试牛刀一下：\n```c++\nvoid fun(int& a)\n{\n\tcout << \"fun(int& a)\" << endl;\n}\nvoid fun(const int& a)\n{\n\tcout << \"fun(const int& a)\" << endl;\n}\nvoid fun(int&& a)\n{\n\tcout << \"fun(int&& a)\" << endl;\n}\ntemplate<class T>\nvoid fac_template(T && tmp)\n{\n    fun(tmp);\n    fun(std::forward<T>(tmp));\n}\nvoid fac_non_template(T && tmp)\n{\n    fun(tmp);\n    fun(std::forward<T>(tmp));\n}\nint main()\n{\n    int a = 10;\n    fac_template(std::move(a));\t\t\t// 注意此处区别，上上个代码中是fac(a),此处是fac(std::move(a))\n    \n    fac_non_template(std::move(a));\n    return 0;\n}\n/* 运行结果\n\t----------------\n\tfac_template(std::move(a));\n\t----------------\n        fun(int& a)\n        fun(int&& a)\t//上上个代码fac(a)的此处的结果是fun(int& a)，而此处是fun(int&& a)\n\t----------------\n    fac_non_template(std::move(a));\n    ----------------\n        fun(int& a)\n        fun(int&& a)\n*/\n```\n# 在cpp文件中调用c文件\n矛盾点：\n1. C++调用C\n    1. C++产生函数符号-（函数名+参数类型列表），C语言产生函数符号-（函数名）\n2. C语言调用C++\n    1. 如果将C++的函数符号改为C语言的函数符号--需要改动C++源文件--不现实。\n    2. 正确解决办法是添加自己实现的C++文件，写**C++函数作为中间层去调用需要的C++函数，然后让自实现的C++函数产生C语言符号（extern C）**。\n\n```c\n#func.c\n\n#include<stdio.h>\nvoid fun_C()\n{\n    printf(\"void fun_C()\");\n}\n#main.cpp\nvoid fun_C();\n//cpp生成的符号的方式是取决于函数名和参数列表。\n//而c生成的符号只是函数名\n//所以导致符号找不到。\nint main()\n{\n    fun_C();\n    return 0;\n}\n//如何解决——使用C语言的方式编译和生成符号。\nextern \"C\"\n{\n    void fun_C();//声明\n}\n```\n\n反过来呢？如何解决？\n\n```c++\n#fun.cpp\nvoid fun_CPP()//生成的符号：fun_CPP_void\n{\n    printf(\"void fun_CPP()\");\n}\n\n#func.c\nvoid fun_CPP();//生成的符号：fun_CPP\nint main()\n{\n    fun_CPP();\n    return 0;\n}\n\n```\n\n\n\n```c++\n//C调用C++的代码方法\n#fun.cpp\nvoid fun_CPP()//生成的符号：fun_CPP_void\n{\n    printf(\"void fun_CPP()\");\n}\n\n#tmp.cpp\nvoid fun_CPP();\nextern \"C\"\n{\n    void fun_CPP_tmp()\n    {\n        fun_CPP();\n    }\n}\n\n#func.c\nvoid fun_CPP_tmp();//生成的符号：fun_CPP\nint main()\n{\n    fun_CPP_tmp();\n    return 0;\n}\n\n```\n\n## extern关键字\n\n两种用法：\n\n1. C++中，干预编译器，`extern \"C\"`是以C方式编译，`extern \"C++\"`是以C++方式编译；\n2. C语言中，告诉编译器，函数是外部函数，既可以用在本文件，也可用在其他文件。","tags":["tulun"],"categories":["Cpp","Modern"]},{"title":"Cpp_完美转发","url":"/Cpp/Cpp_完美转发/","content":"# 内容\n\n1. 为何需要完美转发\n2. 完美转发\n# 为何需要完美转发\n\n```c++\ntemplate<class T>\nvoid fun(T a)\n{\n    // ...\n}\n// 由于T类型有可能是内置类型(C子集)，也有可能是封装类型(C++子集)，所以对于模板来说，实现c子集和class子集上的统一的背后工作必定复杂。\nfun<int>(12);\nfun<Object>(obj);\n```\n\n```c++\n#include<iostream>\nusing namespace std;\nvoid fun(int& a)\n{\n\tcout << \"fun(int& a)\" << endl;\n}\nvoid fun(const int& a)//const int&是个万能引用，左右值都可以接收，但是如果fun有int &&的重载则优先被int &&接收（如右值10）；同样的道理，如果fun有int &的重载则优先被int &接收（如左值a）。\n{\n\tcout << \"fun(const int& a)\" << endl;\n}\nvoid fun(int&& a)\n{\n\tcout << \"fun(int&& a)\" << endl;\n}\n//void fun(int a){} //与fun(int &)冲突\nint main()\n{\n\tint a = 10;\n    const int b = 20;\n\tfun(a);\t\t//fun(int& a)\n\tfun(b);\t\t//fun(const int& a)\n\tfun(10);\t//fun(int&& a) --> 虽然10也可以被const int &接收，但是C++11开始后，重载对值的类型、左右值进行了清晰的划分。以前只按类型重载，之后按左右值也可以重载。\n}\n```\n\n# 完美转发\n\n```c++\nvoid fun(int& a)\n{\n\tcout << \"fun(int& a)\" << endl;\n}\nvoid fun(const int& a)\n{\n\tcout << \"fun(const int& a)\" << endl;\n}\nvoid fun(int&& a)\n{\n\tcout << \"fun(int&& a)\" << endl;\n}\ntemplate<class T>\nvoid fac(T&& tmp)\n{\n    //cout << std::is_rvalue_reference<T> << endl;\n    //cout << std::is_lvalue_reference<T> << endl;\n    fun(tmp);\n    // 虽然在调用fac时，tmp传入此函数中前是一个右值，但是传参动作完成后tmp成为了一个具名变量，则又退化为了左值，导致只能调用fun(int& a)。\n    //所以我们需要一个机制，来保持变量的左右值属性。即完美转发\n    fun(std::forward<T>(tmp)); //依然保持tmp的右值属性，使其可以调用fun(int&& a)。\n}\nint main()\n{\n    int a = 10;\n    const int b = 20;\n    fac(a);\n    fac(b);\n    fac(20);\n    return 0;\n}\n/* 运行结果\n    fun(int& a)\n    fun(int& a)\n    fun(const int& a)\n    fun(const int& a)\n    fun(int& a)\t\t\t-->***完美转发之前\n    fun(int&& a)\t\t-->***完美转发之后\n*/\n```\n\n","categories":["Cpp","Modern","右值引用"]},{"title":"工厂方法模式","url":"/设计模式/工厂方法模式/","content":"\n# 内容\n\n1. 工厂方法模式之前\n2. 工厂方法模式\n\n# 工厂方法模式之前\n\n简单工厂模式虽然简单，但存在一个很严重的问题。**当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码(增加if else)，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？** 工厂方法模式应运而生。\n\n案例分析-**日志记录器的设计**：\n\n某软件公司欲开发一个系统运行日志记录器(Logger)，该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以通过**修改配置文件**灵活地更换日志记录方式。在设计各类日志记录器时，该公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。**如何封装记录器的初始化过程并保证多种记录器切换的灵活性**是该公司开发人员面临的一个难题。\n\n该公司的开发人员通过对该需求进行分析，发现该日志记录器有两个设计要点：\n\n1. 需要封装日志记录器的初始化过程，这些初始化工作较为复杂，例如需要初始化其他相关的类，还有可能需要读取配置文件（例如连接数据库或创建文件），导致代码较长，如果将它们都写在构造函数中，会导致构造函数庞大，不利于代码的修改和维护；\n2. 用户可能需要更换日志记录方式，在客户端代码中需要提供一种灵活的方式来选择日志记录器，尽量**在不修改源代码的基础上更换或者增加日志记录方式**。\n\n该公司开发人员最初使用简单工厂模式对日志记录器进行了设计，初始结构如图所示：\n\n![image-20220225130836527](../../images/工厂方法模式/image-20220225130836527.png)\n\n在上图中，LoggerFactory充当创建日志记录器的工厂，提供了工厂方法createLogger()用于创建日志记录器，Logger是抽象日志记录器接口，其子类为具体日志记录器。其中，工厂类LoggerFactory代码片段如下所示：\n\n```c++\nclass LoggerFactory\n{\npublic:\n    LoggerFactory() {}\n    ~LoggerFactory() {}\n    static Logger* createLogger(const string & args)\n    {\n        if(args == \"db\")\n        {\n            // ... 连接数据库代码\n            Logger* logger = new DatabaseLogger();//创建数据库日志记录器对象\n            // ... 初始化数据库日志记录器代码\n            return logger;\n        }\n        else if(args == \"file\")\n        {\n            // ... 创建日志文件\n            Logger* logger = new DatabaseLogger();//创建文件日志记录器对象\n            // ... 初始化文件日志记录器代码\n            return logger;\n        }\n        return nullptr;\n    }\n}\n```\n\n为了突出设计重点，上述代码省略了具体日志记录器类的初始化代码。在LoggerFactory类中提供了静态工厂方法createLogger()，用于根据所传入的参数创建各种不同类型的日志记录器。通过使用简单工厂模式，我们将日志记录器对象的创建和使用分离，客户端只需使用由工厂类创建的日志记录器对象即可，无须关心对象的创建过程，但是我们发现，虽然简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：\n\n1. 工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大；\n2. 系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了“开闭原则”。\n\n如何解决这两个问题，提供一种简单工厂模式的改进方案？这就是工厂方法模式的动机之一。\n\n# 工厂方法模式的思想\n\n在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。\n\n在工厂方法模式中，我们**不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构**。\n\n# 工厂方法模式的开始\n\n## 工厂方法模式的定义\n\n工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。\n\n工厂方法模式**提供一个抽象工厂接口来声明抽象工厂方法**，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图所示：\n\n![image-20220225132211587](../../images/工厂方法模式/image-20220225132211587.png)\n\n在工厂方法模式结构图中包含如下几个角色：\n\n1. **Factory（抽象工厂）**\n   * 在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。\n   * 抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n2. **ConcreteFactory（具体工厂）**\n   * 它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。\n3. **Product（抽象产品）**\n   * 它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。\n4. **ConcreteProduct（具体产品角色）**\n   * 它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。\n\n**与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色**，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：\n\n```c++\nstruct Factory\n{\npublic:\n    Factory() {cout << \"Factory()\"<<endl;}\n    virtual ~Factory() {cout << \"~Factory\"<<endl;}\n    virtual Product * factoryMethod() = 0;\n}\n```\n\n在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示：\n\n```c++\nclass ConcreteFactoryA : public Factory\n{\npublic:\n    ConcreteFactoryA() {cout << \"ConcreteFactoryA()\"<<endl;}\n    ~ConcreteFactoryA() {cout << \"~ConcreteFactoryA()\"<<endl;}\n    virtual Product * factoryMethod()\n    {\n        return new ConcreteProductA();\n    }\n}\nclass ConcreteFactoryB : public Factory\n{\npublic:\n    ConcreteFactoryB() {cout << \"ConcreteFactoryB()\"<<endl;}\n    ~ConcreteFactoryB() {cout << \"~ConcreteFactoryB()\"<<endl;}\n    virtual Product * factoryMethod()\n    {\n        return new ConcreteProductB();\n    }\n}\n```\n\n产品类（与简单工厂模式无异）\n\n```c++\nclass Product\n{\npublic:\n    Product() { cout << \"Product()\" << endl; }\n    virtual ~Product() { cout << \"~Product\" << endl; }\n    virtual void methodSame()\n    {\n        cout << \"this is Product\" << endl;\n        //公共方法的实现\n    }\n    virtual void methodDiff() = 0;//抽象业务方法\n};\nclass ConcreteProductA : public Product\n{\npublic:\n    ConcreteProductA() { cout << \"ConcreteProductA()\" << endl; }\n    virtual ~ConcreteProductA() { cout << \"~ConcreteProductA\" << endl; }\n    virtual void methodDiff()\n    {\n        cout << \"this is A\" << endl;\n        // 业务方法的覆盖实现\n    }\n};\nclass ConcreteProductB : public Product\n{\npublic:\n    ConcreteProductB() { cout << \"ConcreteProductB()\" << endl; }\n    virtual ~ConcreteProductB() { cout << \"~ConcreteProductB\" << endl; }\n    virtual void methodDiff()\n    {\n        cout << \"this is B\" << endl;\n        // 业务方法的覆盖实现\n    }\n};\n```\n\n在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。\n\n在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示：\n\n```c++\nint main()\n{\n    Factory* factorya = new ConcreteFactoryA();\n    Factory* factoryb = new ConcreteFactoryB();\n    Product* producta = factorya->factoryMethod();\n    Product* productb = factoryb->factoryMethod();\n    delete factorya;\n    delete factoryb;\n    delete producta;\n    delete productb;\n}\n/* 运行结果\n        Factory()\n        ConcreteFactoryA()\n        Factory()\n        ConcreteFactoryB()\n        Product()\n        ConcreteProductA()\n        Product()\n        ConcreteProductB()\n        ~ConcreteFactoryA\n        ~Factory\n        ~ConcreteFactoryB\n        ~Factory\n        ~ConcreteProductA\n        ~Product\n        ~ConcreteProductB\n        ~Product\n*/\n```\n\n可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。\n\n### 思考\n\n工厂方法模式中的工厂方法能否为静态方法？为什么？\n\n## 完整解决方案\n\n该公司开发人员决定使用工厂方法模式来设计日志记录器。其基本结构如图所示：\n\n![image-20220225140347802](../../images/工厂方法模式/image-20220225140347802.png)\n\n在上图中，Logger接口充当抽象产品，其子类FileLogger和DatabaseLogger充当具体产品，LoggerFactory接口充当抽象工厂，其子类FileLoggerFactory和DatabaseLoggerFactory充当具体工厂。完整代码如下所示：\n\n```c++\n//日志记录器接口：抽象产品\ninterface Logger {\n\tpublic void writeLog();\n}\n \n//数据库日志记录器：具体产品\nclass DatabaseLogger implements Logger {\n\tpublic void writeLog() {\n\t\tSystem.out.println(\"数据库日志记录。\");\n\t}\n}\n \n//文件日志记录器：具体产品\nclass FileLogger implements Logger {\n\tpublic void writeLog() {\n\t\tSystem.out.println(\"文件日志记录。\");\n\t}\n}\n \n//日志记录器工厂接口：抽象工厂\ninterface LoggerFactory {\n\tpublic Logger createLogger();\n}\n \n//数据库日志记录器工厂类：具体工厂\nclass DatabaseLoggerFactory implements LoggerFactory {\n\tpublic Logger createLogger() {\n\t\t\t//连接数据库，代码省略\n\t\t\t//创建数据库日志记录器对象\n\t\t\tLogger logger = new DatabaseLogger(); \n\t\t\t//初始化数据库日志记录器，代码省略\n\t\t\treturn logger;\n\t}\t\n}\n \n//文件日志记录器工厂类：具体工厂\nclass FileLoggerFactory implements LoggerFactory {\n\tpublic Logger createLogger() {\n            //创建文件日志记录器对象\n\t\t\tLogger logger = new FileLogger(); \n\t\t\t//创建文件，代码省略\n\t\t\treturn logger;\n\t}\t\n}\n```\n\n编写如下客户端测试代码：\n\n```c++\nint main()\n{\n    LoggerFactory factory;\n    Logger logger;\n    factory = new FileLoggerFactory(); //可引入配置文件实现\n    logger = factory.createLogger();\n    logger.writeLog();\n}\n/* 运行结果\n\n*/\n```\n\n## 与配置文件结合\n\n 为了让系统具有更好的灵活性和可扩展性，Sunny公司开发人员决定对日志记录器客户端代码进行重构，使得可以在不修改任何客户端代码的基础上更换或增加新的日志记录方式。\n\n在客户端代码中将不再使用new关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（如XML文件）中，通过读取配置文件获取类名字符串，再使用Java的反射机制，根据类名字符串生成对象。在整个实现过程中需要用到两个技术：Java反射机制与配置文件读取。软件系统的配置文件通常为XML文件，我们可以使用DOM (Document Object Model)、SAX (Simple API for XML)、StAX (Streaming API for XML)等技术来处理XML文件。关于DOM、SAX、StAX等技术均可充当配置文件技术。\n\n# 参考文献\n\n```\n[1] 刘伟. 设计模式.\n```\n","categories":["设计模式","创建型模式"]},{"title":"排序_堆排序","url":"/算法/排序_堆排序/","content":"# 内容\n\n1. 默认划分法\n\n# 代码逻辑\n\n```c++\n\n```\n# 非递归形式\n\n```c++\n\n```\n# 堆排序的应用\n\n堆排序主要服务于优先队列，于是堆排序的应用便是优先队列的应用，用到优先队列的都有堆排序。\n\n1. 优先队列的底层是堆排序，关键部分是从下到上、从上到下调整函数\n2. 哈夫曼树\n3. 搜索算法，广度搜索，A星算法（每次取出代价最低的方块）\n4. 外排序中的败者树是堆的一个变种形式，堆的普通应用是取一个数据，对于败者树来说是取一组数据。\n5. 适于找第k数，但是整体性能劣于快速排序方法找第k数，虽然都是按划分寻找的（一半的一半），但是堆排序要把整个都排完，时间复杂度是$O(nlogk)$，而快排找第k数的复杂度是$O(n)$\n# 适用思想的题\n\n","categories":["算法","排序"]},{"title":"算法_动态规划","url":"/算法/算法_动态规划/","content":"# 内容\n1. \n# 动态规划适用的问题\n求解最优化问题\n# 解题过程\n找到规模缩减的方案\n# 经典题目\n\n## 最长公共子序列\n\n假设有X数组规模是m，Y数组规模是n，最长公共子序列为Z，规模为k(>=0)。\n\n```c++\nX={x1, x2, x3, ..., xm-1, xm};\nY={y1, y2, y3, ..., yn-1, yn};\nZ={z1, z2, z3, ..., zk-1, zk};\n```\n\n```c++\n1.若xm == xn, 则xm == yn == zk\t//小写x，y，z表示某一字符\n    则可以把问题的解规模解释为：Zk-1 = Xm-1 && Yn-1\t//大写X,Y,Z表示数组规模问题\n2.若xm != yn, xm != zk，\n    则Zk = Xm-1 && Yn\n3.若xm != yn, yn != zk，\n    则Zk = Xm && Yn-1\n```\n\n```c++\nc[m][n]表示MAXLEN\n    c[m][n] = (m == 0 || n == 0) ? 0 : ...\n    m > 1, n > 1\n    c[m][n] = (xm == yn) ? c[m-1][n-1] + 1 : ...\n    c[m][n] = (xm != yn) ? Max(c[m-1][n],c[m][n-1]) : ...\n```\n### 递归版本\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint LCSLength(const char* X, int m, const char* Y, int n)\n{\n\tif (m == 0 || n == 0)return 0;\n\telse\n\t{\n\t\tif (X[m] == Y[n])return LCSLength(X, m - 1, Y, n - 1) + 1;\n\t\telse\n\t\t{\n\t\t\tint max1 = LCSLength(X, m - 1, Y, n);\n\t\t\tint max2 = LCSLength(X, m, Y, n - 1);\n\t\t\treturn max1 > max2 ? max1 : max2;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar X[] = { \"#ABCBDAB\" };\n\tchar Y[] = { \"#BDCABA\" };\n\tint xm = strlen(X) - 1;\n\tint yn = strlen(Y) - 1;\n\tvector<vector<int>> c;\n\tc.resize(xm + 1);\n\tfor (int i = 0; i < xm + 1; ++i)\n\t{\n\t\tc[i].resize(yn + 1);\n\t}\n\tint maxlen = LCSLength(X, xm, Y, yn);\n}\n```\n### 传入vector\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint LCSLength(const char* X, int m, const char* Y, int n, vector<vector<int>> &c)\n{\n\tif (m == 0 || n == 0)return 0;\n\telse\n\t{\n\t\tif (X[m] == Y[n])return LCSLength(X, m - 1, Y, n - 1) + 1;\n\t\telse\n\t\t{\n\t\t\tint max1 = LCSLength(X, m - 1, Y, n);\n\t\t\tint max2 = LCSLength(X, m, Y, n - 1);\n\t\t\treturn max1 > max2 ? max1 : max2;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar X[] = { \"#ABCBDAB\" };\n\tchar Y[] = { \"#BDCABA\" };\n\tint xm = strlen(X) - 1;\n\tint yn = strlen(Y) - 1;\n\tvector<vector<int>> c;\n\tc.resize(xm + 1);\n\tfor (int i = 0; i < xm + 1; ++i)\n\t{\n\t\tc[i].resize(yn+1, 0); //第二个参数代表每一个int都初始化为0\n\t}\n\tint maxlen = LCSLength(X, xm, Y, yn);\n}\n```\n# 古典问题-兔子\n\n有一对兔子，从出生后第3个月起，每个月都生一对兔子，小兔子长到第三个月开始每个月又生一对兔子，假如兔子不死，问第24个月的兔子总数为多少？\n\n```c++\nint dp[25];\ndp[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]\n       1   1   2   3   5   \n    发现，dp[i] = dp[i-1] + dp[i-2]\n```","categories":["算法","动态规划"]},{"title":"简单工厂模式","url":"/设计模式/简单工厂模式/","content":"\n# 内容\n\n1. 简单工厂模式之前\n2. 简单工厂模式\n\n# 简单工厂模式之前\n\n案例分析：\n\n某软件公司欲开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。该公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且**可以较为方便地对图表库进行扩展**，以便能够在将来增加一些新类型的图表。\n\n该软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：\n\n```c++\nclass Chart\n{\nprivate:\n    string type;\npublic:\n    Chart(const string & type) : type(type)\n    {\n        if(type == \"histogram\")\n        {\n            //初始化柱状图\n        }\n        else if(type == \"pie\")\n        {\n            //初始化饼状图\n        }\n        else if(type == \"line\")\n        {\n            //初始化折线图\n        }\n    }\n    void display()\n    {\n        if(type == \"histogram\")\n        {\n            //显示柱状图\n        }\n        else if(type == \"pie\")\n        {\n            //显示饼状图\n        }\n        else if(type == \"line\")\n        {\n            //显示折线图\n        }\n    }\n};\nint main()\n{\n    Chart(\"pie\");\n}\n```\n\n客户端代码通过调用Chart类的构造函数来创建图表对象，根据参数type的不同可以得到不同类型的图表，然后再调用display()方法来显示相应的图表。\n\nChart类是一个“巨大的”类，在该类的设计中存在如下几个问题：\n\n1. 在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。\n2. Chart类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，**违反了“单一职责原则”**，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。\n3. 当需要增加新类型的图表时，必须修改Chart类的源代码，**违反了“开闭原则”**。\n4. 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离。\n5. 客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建Chart对象时都会出现，导致代码的重复。\n\n面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？简单工厂模式将在一定程度上解决上述问题。\n\n# 简单工厂模式的思想\n\n## 为何需要工厂[Java代码讲解]\n\n在开始简单工厂模式前，我们先探究一个问题——创建对象可以很灵活，为什么还需要工厂？\n\n与一个对象相关的职责通常有三类：**对象本身所具有的职责、创建对象的职责和使用对象的职责**。对象本身的职责比较容易理解，就是对象自身所具有的一些数据和行为，可通过一些公开的方法来实现它的职责。在本文，我们将简单讨论一下对象的创建职责和使用职责。\n\n创建对象的方式有很多，譬如在Java语言中，有以下几种创建对象的方式：\n\n1. new关键字\n2. 反射机制\n3. clone()方法\n4. 通过工厂类创建对象\n\n毫无疑问，在客户端代码中直接使用new关键字是最简单的一种创建对象的方式，但是它的灵活性较差，下面通过一个简单的示例来加以说明： \n\n```c++\nclass LoginAction\n{\n    private UserDAO udao;\n    public LoginAction()\n    {\n        udao = new JDBCUserDAO();\t//创建对象\n    }\n    public void execute()\n    {\n        // ...\n        udao.findUserById();\t\t//使用对象\n    \t// ...\n    }\n}\n```\n\n在LoginAction类中定义了一个UserDAO类型的对象udao，在LoginAction的构造函数中创建了JDBCUserDAO类型的udao对象，并在execute()方法中调用了udao对象的findUserById()方法，这段代码看上去并没有什么问题。\n\n下面分析以下LoginAction和UserDAO之间的关系，LoginAction类负责创建了一个UserDAO子类的对象并使用UserDAO的方法来完成相应的业务处理，也就是说**LoginAction即负责udao的创建又负责udao的使用**。创建对象和使用对象的职责耦合在一起，这样的设计会导致一个很严重的问题：如果在LoginAction中希望能够使用UserDAO的另一个子类如HibernateUserDAO类型的对象，必须修改LoginAction类的源代码（比如，修改构造函数，udao=new HibernateUserDAO();），**违反了“开闭原则”**。\n\n## 如何解决该问题？\n\n最常用的一种解决方法是将udao对象的创建职责从LoginAction类中移除，在LoginAction类之外创建对象，那么谁来负责创建UserDAO对象呢？答案是工厂类。\n\n通过引入工厂类，客户类（如LoginAction）不涉及对象的创建，对象的创建者也不需设计对象的使用。引入工厂类UserDAOFactory之后的结构如图\n\n![image-20220224235938416](../../images/简单工厂模式/image-20220224235938416.png)\n\n## 好处\n\n### 好处1-分离创建职责和使用职责\n\n工厂类的引入降低了因为产品或工厂类改变所造成的维护工作量。如果UserDAO的某个子类的构造函数发生改变或者要需要添加或移除不同的子类，只要维护UserDAOFactory的代码，而不会影响到LoginAction；如果UserDAO的接口发生改变，例如添加、移除方法或改变方法名，只要修改LoginAction（譬如execute函数内部调用udao的方法），不会给UserDAOFactory带来任何影响。\n\n工厂模式说来说去，只强调了一点：两个类A和B之间的关系应该仅仅是A创建B或者是A使用B，而不能两种关系都有。**将对象的创建和使用分离**。使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。\n\n### 好处2-工厂类将对象的创建代码、配置环境封装\n\n此外，将对象的创建和使用分离还有一个好处：**防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中**。这在Joshua Kerievsky的《重构与模式》一书中有专门的一节来进行介绍。因为有时候我们创建一个对象不只是简单调用其构造函数，还需要设置一些参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入**工厂类来封装对象的创建逻辑和客户代码的实例化/配置选项**。\n\n### 好处3-可以增加代码可读性\n\n使用工厂类还有一个“不是特别明显的”优点，一个类可能拥有多个构造函数，而在Java、C++等语言中构造函数名字都与类名相同，客户端只能通过传入不同的参数来调用不同的构造函数创建对象，**从构造函数和参数列表中也许大家根本不了解不同构造函数所构造的产品的差异。但如果将对象的创建过程封装在工厂类中，我们可以提供一系列名字完全不同的工厂方法**，每一个工厂方法对应一个构造函数，客户端可以以一种更加可读、易懂的方式来创建对象，而且，从一组工厂方法中选择一个意义明确的工厂方法，比从一组名称相同参数不同的构造函数中选择一个构造函数要方便很多。\n\n在下图，矩形工厂类RectangleFactory提供了两个工厂方法createRectangle()和createSquare()，一个用于创建长方形，一个用于创建正方形，这两个方法比直接通过构造函数来创建长方形或正方形对象意义更加明确，也在一定程度上降低了客户端调用时出错的概率。![image-20220225002101931](../../images/简单工厂模式/image-20220225002101931.png)\n\n## 何时不需要\n\n那么，是否需要为设计中的每一个类都配备一个工厂类？答案是：具体情况具体分析。如果产品类很简单，而且不存在太多变数，其构造过程也很简单，此时无须为其提供工厂类，直接在使用之前实例化即可，例如Java语言中的String类，我们就无须为它专门提供一个StringFactory，这样做反而有点像杀鸡用牛刀，大材小用，而且会导致工厂泛滥，增加系统的复杂度。\n\n# 简单工厂模式的开始\n\n## 简单工厂模式的定义\n\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。**在简单工厂模式中用于创建实例的方法是静态(static)方法**，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n\n在简单工厂模式结构图中包含如下几个角色：\n\n1. **Factory（工厂角色）**\n   * 工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑\n   * 工厂类**可以被外界直接调用**，创建所需的产品对象\n   * 在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为**抽象产品类型**Product\n2. **Product（抽象产品角色）**\n   * 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法\n   * 它的引入将提高系统的灵活性，**使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象**。\n3. **ConcreteProduct（具体产品角色）**\n   * 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例\n   * 每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n## 简单工厂模式的设计步骤\n\n在使用简单工厂模式时，首先需要对产品类进行重构，**不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构**，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现。\n\n1. 首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为**具体产品类**，而将它们公共的代码进行抽象和提取后封装在一个**抽象产品类**中，每一个具体产品类都是抽象产品类的子类；\n2. 然后提供一个**工厂类**用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；\n3. **客户端**只需调用工厂类的工厂方法并**传入相应的参数**即可得到一个产品对象。\n\n典型的抽象产品类代码如下所示：\n\n```c++\nclass Product\n{\npublic:\n    Product() {cout << \"Product()\" << endl;}\n    virtual ~Product() {cout << \"~Product\" << endl;}\n    virtual void methodSame()\n    {\n        cout << \"this is Product\" << endl;\n        //公共方法的实现\n    }\n    virtual void methodDiff() = 0;//抽象业务方法\n};\n```\n\n在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：\n\n```c++\nclass ConcreteProductA : public Product\n{\npublic:\n    ConcreteProductA() {cout << \"ConcreteProductA()\" << endl;}\n    ~ConcreteProductA() {cout << \"~ConcreteProductA\" << endl;}\n    virtual void methodDiff()\n    {\n        cout << \"this is A\" << endl;\n        // 业务方法的覆盖实现\n    }\n};\nclass ConcreteProductB : public Product\n{\npublic:\n    ConcreteProductB() {cout << \"ConcreteProductB()\" << endl;}\n    ~ConcreteProductB() {cout << \"~ConcreteProductB\" << endl;}\n    virtual void methodDiff()\n    {\n        cout << \"this is B\" << endl;\n        // 业务方法的覆盖实现\n    }\n};\n```\n\n简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：\n\n```c++\nclass Factory\n{\npublic:\n    Factory() {cout << \"Factory()\" << endl;}\n    ~Factory() {cout << \"~Factory\" << endl;}\n    static Product* getProduct(const string & arg)\n    {\n        Product* product = nullptr;\n        if(arg == \"A\")\n        {\n            product = new ConcreteProductA();\n            // ... 初始化设置product\n        }\n        else if(arg == \"B\")\n        {\n            product = new ConcreteProductB();\n            // ... 初始化设置product\n        }\n        return product;\n    }\n};\n```\n\n在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：\n\n```c++\nint main()\n{\n    unique_ptr<Product> pA = unique_ptr<Product>(Factory::getProduct(\"A\"));\n    unique_ptr<Product> pB = unique_ptr<Product>(Factory::getProduct(\"B\"));\n    pA->methodSame();\n    pA->methodDiff(); \n    pB->methodSame();\n    pB->methodDiff();\n\n    return 0;\n}\n```\n\n\n\n## 示例结构\n\n 简单工厂模式的要点在于：**当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。** 简单工厂模式结构比较简单，其核心是工厂类的设计![image-20220225002900697](../../images/简单工厂模式/image-20220225002900697.png)\n\n# 参考文献\n\n```\n[1] 刘伟. 设计模式.\n```\n","categories":["设计模式","创建型模式"]},{"title":"设计原则","url":"/设计模式/设计原则/","content":"# 内容\n\n1. 面向对象的设计原则\n2. 常见七种设计原则\n# 面向对象的设计原则：可维护性的复用\n\n对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题。\n如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。\n在面向对象设计中，可维护性的复用是以设计原则为基础的。\n\n面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是用于评价一个设计模式的重要指标之一，在设计面向对象软件系统的过程中，要多思考，“XXX模式符合XXX原则吗？”、“XXX模式违反了XXX原则吗？”。\n# 常见设计原则 - SOLID\n\n1. Robert C. Martin（“Uncle Bob”）在2000年代初期提出并推广了SOLID原则，《Agile Software Development, Principles, Patterns, and Practices》一书中，对这些原则进行了详细的解释和讨论。\n2. 里氏代换原则（LSP）由计算机科学家Barbara Liskov在1987年的一篇名为《Data Abstraction and Hierarchy》的论文中首次提出。虽然Liskov并没有明确提出SOLID这个术语，但她的工作为其中的LSP原则奠定了基础。\n\n| 设计原则名称                             | 定义                                                                                                      | 使用频率  |\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------- | ----- |\n| 单一职责原则, Single Responsibility, SRP | 一个类只负责一个功能领域中的相应职责                                                                                      | ★★★★☆ |\n| 开闭原则, Open-Closed, OCP             | 软件实体应对扩展开放，而对修改关闭                                                                                       | ★★★★★ |\n| 里氏代换原则, Liskov Substitution, LSP   | 如果一个子类可以替换其父类，并且程序的行为没有发生变化，那么这个子类是符合里氏代换原则的。<br>换句话说，子类对象必须能够替换父类对象，并且不影响程序的正确性。                       | ★★★★★ |\n| 接口隔离原则, Interface Segregation, ISP | 客户端不应该被迫依赖它们不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。<br>具体来说，接口隔离原则提倡将臃肿的接口拆分为多个小型的、特定客户的接口，这样每个接口只包含客户端真正需要的方法。 | ★★☆☆☆ |\n| 依赖倒转原则, Dependence Inversion, DIP  | （软件设计的灵魂）高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。                                                | ★★★★★ |\n## 开闭原则\n一个软件实体（类、模块、函数等）应该在不修改其源代码的情况下，扩展或增强其行为。\n通过在不修改现有代码的情况下增加新功能，减少对已稳定系统的影响，避免引入新的错误。这可以通过使用接口、抽象类和多态等面向对象的设计机制来实现。\n### 示例\n假设我们有一个简单的图形绘制程序，最初只支持绘制圆形。为了遵循开闭原则，我们首先定义一个图形接口，并实现一个圆形类：\n```java\n// 图形接口\ninterface Shape {\n    void draw();\n}\n\n// 圆形类\nclass Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a Circle\");\n    }\n}\n\n// 绘制类\nclass Drawing {\n    private List<Shape> shapes;\n\n    public Drawing() {\n        shapes = new ArrayList<>();\n    }\n\n    public void addShape(Shape shape) {\n        shapes.add(shape);\n    }\n\n    public void drawShapes() {\n        for (Shape shape : shapes) {\n            shape.draw();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Drawing drawing = new Drawing();\n        drawing.addShape(new Circle());\n        drawing.drawShapes();\n    }\n}\n```\n在这个例子中，我们的绘制程序可以绘制圆形。如果我们需要添加新的图形，例如矩形，我们可以通过扩展而不是修改现有代码来实现：\n```java\n// 矩形类\nclass Rectangle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a Rectangle\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Drawing drawing = new Drawing();\n        drawing.addShape(new Circle());\n        drawing.addShape(new Rectangle());\n        drawing.drawShapes();\n    }\n}\n```\n通过添加一个实现了Shape接口的新类Rectangle，我们可以扩展绘制程序的功能，而不需要修改现有的Drawing类和Circle类。这种设计符合开闭原则，因为我们通过扩展（添加新类）而不是修改现有代码来增加新功能。\n## 依赖倒转原则（DIP）\n![](../../images/设计原则/image-20240730194118409.png)\n1. 从项目管理的角度来说，如果A直接依赖B，那么开发周期就会被B模块拖累，A模块闲置，人力效率不高，从甘特图看需要开发28天。\n    1. 而如果A、B在事先经过良好的协商，规范出一套接口的话，A、B就可以共同依赖这个接口，各自同时开发。假如协商需要3天，那么开发周期只需要$3+14=17$天。\n1. 从软件的扩展性来说，如果A直接依赖于B，没有事先协商好，那么B可能不能完全满足A的需求，到时候还是需要不断修改代码，开发效率低下。\n    1. 如果都依赖一个接口，那么后期的扩展只需要在接口上增设方法即可。\n### 示例\n假设有一个简单的场景，一个Service类依赖于一个Repository类：\n```java\npublic class Repository {\n    public void save(Object data) {\n        // 保存数据的实现\n    }\n}\n\npublic class Service {\n    private Repository repository;\n\n    public Service() {\n        this.repository = new Repository();\n    }\n\n    public void process(Object data) {\n        // 处理数据\n        repository.save(data);\n    }\n}\n```\n在这个例子中，Service类直接依赖于具体的Repository类。这种设计违反了依赖倒转原则。如果我们想要更改数据存储的方式，比如使用另一个数据存储实现，就必须修改Service类的代码。\n\n按照依赖倒转原则，我们可以使用接口来实现依赖注入，将Repository的实现抽象化：\n```java\npublic interface IRepository {\n    void save(Object data);\n}\n\npublic class Repository implements IRepository {\n    @Override\n    public void save(Object data) {\n        // 保存数据的实现\n    }\n}\n\npublic class Service {\n    private IRepository repository;\n\n    public Service(IRepository repository) {\n        this.repository = repository;\n    }\n\n    public void process(Object data) {\n        // 处理数据\n        repository.save(data);\n    }\n}\n```\n在这个设计中，Service类依赖于IRepository接口，而不是具体的Repository类。这样，如果我们想要更改数据存储的方式，只需要提供一个实现IRepository接口的新类即可，而不需要修改Service类的代码。通过这种方式，高层模块（Service）和低层模块（Repository）都依赖于抽象（IRepository），细节（Repository的具体实现）依赖于抽象（IRepository），符合依赖倒转原则。\n\n这种设计提高了系统的灵活性和可维护性，使得代码更容易扩展和修改。\n## 接口隔离原则\n### 示例\n假设有一个大型接口IMultiFunctionDevice，其中包含多种功能的方法：\n```java\npublic interface IMultiFunctionDevice {\n    void print();\n    void scan();\n    void fax();\n    void copy();\n}\n```\n如果某个客户端只需要打印功能，那么它必须实现所有的方法，即使不需要扫描、传真和复印功能。这违反了接口隔离原则。\n\n按照接口隔离原则，我们可以将这个大接口拆分为多个小接口：\n```java\npublic interface IPrinter {\n    void print();\n}\n\npublic interface IScanner {\n    void scan();\n}\n\npublic interface IFax {\n    void fax();\n}\n\npublic interface ICopier {\n    void copy();\n}\n```\n然后，对于只需要打印功能的客户端，它只需要依赖IPrinter接口：\n```java\npublic class SimplePrinter implements IPrinter {\n    @Override\n    public void print() {\n        // 实现打印功能\n    }\n}\n```\n这样，客户端只依赖于它需要的接口，实现了接口隔离原则的目标。\n## 里氏替换原则\n子类对象必须能够替换父类对象（兼容父类对象的功能），并且不影响程序的正确性。\n里氏代换原则主要有以下几个要点：\n1. **子类必须完全实现父类的方法**：子类不能抛出父类没有抛出的异常，子类的方法参数要与父类方法参数类型一致，返回值类型也要一致或是其子类型。\n2. **子类可以有自己的特性**，但这些特性不能改变父类原有功能的含义和行为。\n3. **继承的原则**：子类应该扩展父类的功能，而不是削弱父类的功能。也就是说，子类不应该删除父类中已有的功能。\n\n比如：Old Bank的add行为结果是3，而New Bank的add虽然形式上一致，但行为却不正确。违反了里氏替换原则。猜测New Bank在重写add方法后，优化代码或更新、升级组件后造成了副作用，导致运行时行为不一致、结果不正确。\n![](../../images/设计原则/image-20240730201816875.png)\n### 示例\n考虑一个父类Bird和一个子类Penguin的例子：\n```java\npublic class Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\npublic class Penguin extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Penguins cannot fly\");\n    }\n}\n```\n在这个例子中，Penguin不能替换Bird，因为企鹅不能飞。这违反了里氏代换原则。正确的做法是重新设计类结构，使得企鹅和其他鸟类能够更好地反映现实中的行为：\n```java\npublic class Bird {\n    public void move() {\n        System.out.println(\"Bird is moving\");\n    }\n}\n\npublic class FlyingBird extends Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\npublic class Penguin extends Bird {\n    @Override\n    public void move() {\n        System.out.println(\"Penguin is walking or swimming\");\n    }\n}\n```\n在这个设计中，FlyingBird继承了Bird，并增加了fly方法，而企鹅只是继承了Bird，并重写了move方法。这样，企鹅和其他鸟类都能正确替换Bird，符合里氏代换原则。\n# 其他设计原则\n\n| 设计原则名称                       | 定义                                    | 使用频率  |\n| ---------------------------- | ------------------------------------- | ----- |\n| 合成复用原则, Composite Reuse, CRP | 尽量使用对象组合，而不是继承来达到复用的目的                | ★★★★☆ |\n| 迪米特法则, Law of Demeter, LoD   | 一个软件实体应当尽可能少地与其他实体发生相互作用，只与最近关系的实体关联。 | ★★★☆☆ |\n## 迪米特法则\n迪米特法则由Ian Holland在1987年提出，并首次在Northeastern University（美国东北大学）的Demeter Project中得到应用，因此得名。\n该原则被认为是一种促进模块化和高内聚低耦合设计的重要策略，广泛应用于面向对象的软件设计中。\n\n**核心思想是：一个对象应当对其他对象有最少的了解**，具体来说：\n1. **一个对象只应与直接的朋友通信**：即仅与自己直接持有的对象或在方法中创建的对象通信，而不应与被间接持有的对象通信。\n2. **避免“火车式”方法调用**：不要通过一个对象链式地调用多个对象的方法，例如 a.getB().getC().doSomething()。\n3. **通过引入中介减少对象间的直接依赖**：通过封装对象之间的关系，使得对象之间的通信通过中介完成，从而减少直接依赖。\n### 示例\n假设有以下类结构：\n```java\nclass Engine {\n    public void start() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Car {\n    private Engine engine;\n\n    public Car() {\n        this.engine = new Engine();\n    }\n\n    public Engine getEngine() {\n        return engine;\n    }\n}\n\nclass Driver {\n    public void startCar(Car car) {\n        car.getEngine().start(); // 违反了迪米特法则\n    }\n}\n```\n在这个例子中，Driver类通过Car类访问Engine类的方法，违反了迪米特法则。我们可以通过引入一个中介方法来改进：\n```cpp\nclass Car {\n    private Engine engine;\n\n    public Car() {\n        this.engine = new Engine();\n    }\n\n    public void startEngine() {\n        engine.start();\n    }\n}\n\nclass Driver {\n    public void startCar(Car car) {\n        car.startEngine(); // 符合迪米特法则\n    }\n}\n```\n在改进后的设计中，Driver类不再直接访问Engine类的方法，而是通过Car类的startEngine方法来启动引擎。这符合迪米特法则，降低了对象之间的耦合性，提高了系统的可维护性。\n# 设计原则的价值\n\n优秀的面向对象的程序应该是有以下五个特征的：低耦合，高内聚，高复用，易维护，易扩展。\n\n1. 开闭原则让程序易扩展，易维护。\n2. 里氏替换原则、依赖倒置和合成复用原则可以降低耦合。\n3. 接口隔离、单一职责原则和迪米特原则可以提高内聚性。\n\n而低耦合，高内聚的代码才能实现高复用。\n\n","categories":["设计模式"]},{"title":"设计模式概述","url":"/设计模式/设计模式概述/","content":"# 内容\n\n1. 模式是什么\n2. 软件模式的由来\n3. 软件模式的构成\n4. 设计模式是什么\n5. 设计模式用途分类，常用模式一览\n6. 设计模式的价值\n7. 如何学习设计模式\n# 模式是什么\n\n美国Christopher Alexander博士及其研究团队用了约20年的时间，对住宅和周边环境进行了大量的调查研究和资料收集工作，发现人们对舒适住宅和城市环境存在一些共同的认同规律，Christopher Alexander在著作A Pattern Language: Towns, Buildings, Construction中把这些认同规律归纳为253个模式，对每一个模式(Pattern)都从Context（前提条件）、Theme或Problem（目标问题）、 Solution（解决方案）三个方面进行了描述，并给出了从用户需求分析到建筑环境结构设计直至经典实例的过程模型。\n\n在Christopher Alexander的另一部经典著作《建筑的永恒之道》中，他给出了关于模式的定义：\n\n每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。\n\n这个定义可以简单地用一句话表示：\n\n**模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。**\nA pattern is a successful or efficient **solution to a recurring problem** within a context.\n\n# 软件模式的由来（23种）\n\n1990年，软件工程界开始关注Christopher Alexander等在这一住宅、公共建筑与城市规划领域的重大突破。最早将模式的思想引入软件工程方法学的是1991-1992年以“四人组”自称的四位著名软件工程学者。\n>Gang of Four，简称**GoF**，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides。\n>书名：Design Patterns: Elements of Reusable Object-Oriented Softwarec - 设计模式：可复用面向对象软件的基础\n\n\n他们在1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来**统一沟通面向对象方法在分析、设计和实现间的鸿沟**。\n\nGoF将模式的概念引入软件工程领域，这标志着软件模式的诞生。软件模式是将模式的一般概念应用于软件开发领域，即**软件开发的总体指导思路或参照样板**。软件模式**并非仅限于设计模式，还包括架构模式、分析模式和过程模式**等，实际上，**在软件开发生命周期的每一个阶段都存在着一些被认同的模式**。\n\n# 软件模式的构成\n\n软件模式是在软件开发中某些可重现问题的一些有效解决方法，软件模式的基础结构主要由四部分构成，包括问题描述（**待解决的问题是什么**）、前提条件（**在何种环境或约束条件下使用**）、解法（**如何解决**）和效果（**有哪些优缺点**）。\n\n# 设计模式是什么\n\n在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案，它**融合了众多专家的设计经验**，已经在成千上万的软件中得以应用。 1995年， GoF将收集和整理好的23种设计模式汇编成Design Patterns: Elements of Reusable Object-Oriented Software（《设计模式：可复用面向对象软件的基础》）一书，该书的出版也标志着设计模式正式成为面向对象软件工程的一个重要研究分支。\n\n设计模式的一般定义如下：\n\n**设计模式**（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的**总结**，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。\n## 设计模式的要素\n\n设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。\n\n1. **模式名称**(Pattern Name)通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的（GoF设计模式中没有一个模式用人名命名）\n2. **问题**(Problem)描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因\n3. **解决方案**(Solution)描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述\n4. **效果**(Consequences)描述了模式的优缺点以及在使用模式时应权衡的问题。\n# 设计模式的用途分类\n\n虽然GoF设计模式只有23个，但是它们各具特色，每个模式都为某一个可重复的设计问题提供了一套解决方案。\n\n根据它们的用途，设计模式可分为**创建型**(Creational)，**结构型**(Structural)和**行为型**(Behavioral)三种。\n\n1. **创建型**模式主要用于描述**如何创建对象**；\n2. **结构型**模式主要用于描述**如何实现类或对象的组合**；\n3. **行为型**模式主要用于描述**类或对象怎样交互以及怎样分配职责**。\n\n在GoF 23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式。\n\n此外，根据某个模式主要是用于**处理类之间的关系还是对象之间的关系**，设计模式还可以分为**类模式**和**对象模式**。\n\n我们经常将两种分类方式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为型模式。\n\n## 常用设计模式一览表\n\n值得一提的是，有一个设计模式虽然不属于GoF 23种设计模式，但一般在介绍设计模式时都会对它进行说明，它就是**简单工厂模式**，也许是太“简单”了，GoF并没有把它写到那本经典著作中，不过现在大部分的设计模式书籍都会对它进行专门的介绍。\n\n（以下难度、频率统计结果来自刘伟）\n\n<table>\n\t<tr>\n\t    <th>类型</th>\n\t    <th>模式名称</th>\n\t    <th>学习难度</th>\n        <th>使用频率</th>\n\t</tr>\n\t<tr>\n\t    <td rowspan=\"6\">创建型模式 Creational</td>\n\t    <td>单例模式 Singleton</td>\n\t    <td>★☆☆☆☆</td>\n        <td>★★★★☆</td>\n\t</tr>\n\t<tr>\n\t    <td>简单工厂模式</td>\n\t    <td>★★☆☆☆</td>\n        <td>★★★☆☆</td>\n\t</tr>\n\t<tr>\n\t    <td>工厂方法模式 Factory Method</td>\n\t    <td>★★☆☆☆</td>\n        <td>★★★★★</td>\n\t</tr>\n\t<tr>\n\t    <td>抽象工厂模式 Abstract Factory</td>\n\t    <td>★★★★☆</td>\n        <td>★★★★★</td>\n\t</tr>\n    <tr>\n\t    <td>原型模式 Prototype</td>\n\t    <td>★★★☆☆</td>\n        <td>★★★☆☆</td>\n\t</tr>\n    <tr>\n\t    <td>建造者模式 Builder</td>\n\t    <td>★★★★☆</td>\n        <td>★★☆☆☆</td>\n\t</tr>\n    <tr>\n        <td rowspan=\"7\">结构型模式 Structural</td>\n        <td>适配器模式 Adapter</td>\n        <td>★★☆☆☆</td>\n        <td>★★★★☆</td>\n    </tr>\n    <tr>\n        <td>桥接模式 Bridge</td>\n        <td>★★★☆☆</td>\n        <td>★★★☆☆</td>\n    </tr>\n    <tr>\n        <td>组合模式 Composite</td>\n        <td>★★★☆☆</td>\n        <td>★★★★☆</td>\n    </tr>\n    <tr>\n        <td>装饰模式 Decorator</td>\n        <td>★★★☆☆</td>\n        <td>★★★☆☆</td>\n    </tr>\n    <tr>\n        <td>外观模式 Facade</td>\n        <td>★☆☆☆☆</td>\n        <td>★★★★★</td>\n    </tr>\n    <tr>\n        <td>享元模式 Flyweight</td>\n        <td>★★★★☆</td>\n        <td>★☆☆☆☆</td>\n    </tr>\n    <tr>\n        <td>代理模式 Proxy</td>\n        <td>★★★☆☆</td>\n        <td>★★★★☆</td>\n    </tr>\n    <tr>\n        <td rowspan=\"11\">行为型模式 Behavioral</td>\n        <td>职责链模式 Chain of Responsibility</td>\n        <td>★★★☆☆</td>\n        <td>★★☆☆☆</td>\n    </tr>\n    <tr>\n        <td>命令模式 Command</td>\n        <td>★★★☆☆</td>\n        <td>★★★★☆</td>\n    </tr>\n    <tr>\n        <td>解释器模式 Interpreter</td>\n        <td>★★★★★</td>\n        <td>★☆☆☆☆</td>\n    </tr>\n    <tr>\n        <td>迭代器模式 Iterator</td>\n        <td>★★★☆☆</td>\n        <td>★★★★★</td>\n    </tr>\n    <tr>\n        <td>中介者模式 Mediator</td>\n        <td>★★★☆☆</td>\n        <td>★★☆☆☆</td>\n    </tr>\n    <tr>\n        <td>备忘录模式 Memento</td>\n        <td>★★☆☆☆</td>\n        <td>★★☆☆☆</td>\n    </tr>\n    <tr>\n        <td>观察者模式 Observer</td>\n        <td>★★★☆☆</td>\n        <td>★★★★★</td>\n    </tr>\n    <tr>\n        <td>状态模式 State</td>\n        <td>★★★☆☆</td>\n        <td>★★★☆☆</td>\n    </tr>\n    <tr>\n        <td>策略模式 Strategy</td>\n        <td>★☆☆☆☆</td>\n        <td>★★★★☆</td>\n    </tr>\n    <tr>\n        <td>模板方法模式 Template Method</td>\n        <td>★★☆☆☆</td>\n        <td>★★★☆☆</td>\n    </tr>\n    <tr>\n        <td>访问者模式 Visitor</td>\n        <td>★★★★☆</td>\n        <td>★☆☆☆☆</td>\n    </tr>\n</table>\n\n# 1句话描述23个设计模式\n## 结构型\n\n1. **适配器模式（Adapter）**：将一个类的接口转换成客户希望的另一个接口。\n    - 例子：电源适配器，将两孔插头适配成三孔插头。\n\n2. **桥接模式（Bridge）**：将抽象部分与它的实现部分分离，使它们可以独立变化。\n    - 例子：遥控器（抽象部分）和不同类型的电视机（实现部分）。\n    - 苹果系统中OC和C语言之间的桥梁。\n\n3. **组合模式（Composite）**：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。\n    - 例子：文件夹和文件的结构，一个文件夹可以包含文件或子文件夹。\n\n4. **装饰模式（Decorator）**：动态地给对象添加一些额外的职责。\n    - 例子：给圣诞树添加装饰品，每个装饰品增加新的特性。\n\n5. **外观模式（Facade）**：为子系统中的一组接口提供一个一致的界面，使子系统更容易使用。\n    - 例子：餐厅服务员，统一点菜、送菜和结账的接口。\n\n6. **享元模式（Flyweight，也叫轻量对象模式）**：通过共享大量细粒度对象来节省内存。\n    - 例子：围棋棋子，黑白棋子共享一个对象，节省内存。\n\n7. **代理模式（Proxy）**：为其他对象提供一种代理，以控制对这个对象的访问。\n    - 例子：明星的经纪人，代理处理事务和安排活动。\n## 行为型\n\n1. **责任链模式（Chain of Responsibility）**：将请求消息沿着处理者链传递，直到有处理者处理它。\n    - 例子：公司请假审批流程，依次由主管、经理、总监审批。\n\n2. **命令模式（Command）**：将请求封装成对象，使不同的请求、队列或日志参数化。\n    - 例子：遥控器上的按钮，每个按钮封装一个命令。\n\n3. **解释器模式（Interpreter）**：给定一个语言，定义它的文法表示，并定义一个解释器来处理这些表示。\n    - 例子：正则表达式解析器，解释和处理正则表达式。\n    - 3D软件中通过脚本或命令按钮控制界面，或控制物体运动。\n\n4. **迭代器模式（Iterator）**：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示。\n    - 例子：图书馆的书架，使用迭代器遍历书籍。\n    - STL中容器和算法之间的桥梁。\n\n5. **中介者模式（Mediator）**：用一个中介对象来封装一系列对象的交互。\n    - 例子：机场的塔台，调度和管理飞机的起降。\n    - 游戏引擎中用的居多。\n\n6. **备忘录模式（Memento）**：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。\n    - 例子：电脑的系统还原点，记录系统状态以便将来恢复。\n    - Word编辑过程中的undo、redo。\n\n7. **观察者模式（Observer）**：定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。\n    - 例子：订阅报纸，当报纸有新内容时，通知所有订阅者。\n\n8. **状态模式（State）**：允许对象在内部状态改变时改变它的行为。\n    - 例子：电梯的状态，不同状态（上下楼、开关门）下电梯行为不同。\n\n9. **策略模式（Strategy）**：定义一系列算法，将每个算法封装起来，并使它们可以互换。\n    - 例子：旅游出行策略，根据情况选择不同的出行方式（开车、坐公交、骑自行车）。\n    - 比如HDC，不同的设备对应不同的DC。\n\n10. **模板方法模式（Template Method）**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法的某些步骤。\n    - 例子：制作咖啡的步骤，具体的咖啡制作细节由不同种类的咖啡决定。\n    - [Windows_面向对象程序设计](../Windows/Windows_面向对象程序设计.md)中建立的Window框架就是模板方法模式。\n\n11. **访问者模式（Visitor）**：表示一个作用于某对象结构中的各元素的操作，使得可以在不改变各元素类的前提下定义作用于这些元素的新操作。\n    - 例子：博物馆导览员，不同导览员为游客讲解不同展品的信息。\n## 创建型\n1. **单例模式（Singleton）**：确保一个类只有一个实例，并提供全局访问点。\n    - 例子：总统办公室（全国只有一个总统）。\n\n2. **工厂方法模式（Factory Method）**：定义一个创建对象的接口，但让子类决定实例化哪个类。\n    - 例子：披萨店，根据订单制作不同类型的披萨。\n\n3. **抽象工厂模式（Abstract Factory）**：提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。\n    - 例子：家具工厂，可以创建一整套风格一致的家具（如现代风格或古典风格）。\n\n4. **建造者模式（Builder）**：将一个复杂对象的构建过程拆解，与其表示分离，使同样的构建过程可以创建不同的表示。\n    - 例子：建筑工人，按照设计图纸建造不同的房屋。\n\n5. **原型模式（Prototype）**：通过复制现有对象来创建新对象。\n    - 例子：细胞分裂，通过复制自身产生新细胞。\n\n# 设计模式的价值\n\n大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。\n\n此外，随着软件规模日益增大，系统的可维护性和可扩展性也越来越重要，许多设计模式将有助于提高系统的灵活性和可扩展性，让我们在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块。\n\n# 如何学习设计模式\n\n1. 在学习每一个设计模式时至少应该掌握如下几点：当你能够回答所有问题时，恭喜你，你了解一个设计模式了，至于掌握它，那就在开发中去使用吧，用多了你自然就掌握了。\n    1. 这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；\n    2. 它是如何解决的，掌握它的结构图，记住它的关键代码；\n    3. 能够想到至少两个它的应用实例，一个生活中的，一个软件中的；\n    4. 这个模式的优缺点是什么，在使用时要注意什么。\n2. “如果想体验一下运用模式的感觉，那么最好的方法就是运用它们。”正如在本章最开始所说的，设计模式是“内功心法”，它还是要与“实战招式”相结合才能够相得益彰。学习设计模式的目的在于应用，如果不懂如何使用一个设计模式，而只是学过，能够说出它的用途，绘制它的结构，充其量也只能说你了解这个模式，严格一点说：不会在开发中灵活运用一个模式基本上等于没学。所以一定要做到：少说多做。\n3. 不要滥用模式，不要试图在一个系统中用上所有的模式。每个模式都有自己的适用场景，不能为了使用模式而使用模式。\n4. 如果将设计模式比喻成“三十六计”，那么每一个模式都是一种计策，它为解决某一类问题而诞生，不管这个设计模式的难度如何，使用频率高不高，都应该好好学学，多学一个模式也就意味着你多了“一计”，说不定什么时候就用上了。\n5. 设计模式的“上乘”境界：“手中无模式，心中有模式”。模式使用的最高境界是你已经不知道具体某个设计模式的定义和结构了，但你会灵活自如地选择一种设计方案（其实就是某个设计模式）来解决某个问题，设计模式已经成为你开发技能的一部分，能够手到擒来，“内功”与“招式”已浑然一体，要达到这个境界并不是看完某本书或者开发一两个项目就能够实现的，它需要不断沉淀与积累，所以，对模式的学习不要急于求成。\n6. GoF已故成员、软件工程大师之一John Vlissides的著作《设计模式沉思录》(Pattern Hatching Design Patterns Applied)：模式从不保证任何东西，它不能保证你一定能够做出可复用的软件，提高你的生产率，更不能保证世界和平；模式并不能替代人来完成软件系统的创造，它们只不过会给那些缺乏经验但却具备才能和创造力的人带来希望。\n","categories":["设计模式"]},{"title":"归并排序","url":"/算法/排序_归并排序/","content":"# 代码逻辑\n\n```c++\nvoid Merge(int* dest, int* src, int left, int mid, int right)\n{\n    \n}\n```\n\nsrc表示源数据，dest表示目标空间。left表示源数据的最左位置，mid表示源数据的中间位置，right表示源数据的最右位置。其中，left到mid数据要满足有序，mid到right要满足同向有序。\n\n此函数欲将src中的数据归并到dest中，使整体有序。\n\n```c++\nvoid Copy(int* src, int* dest, int left, int right)\n{\n    while(left <= right)\n    {\n        dest[left] = src[left];\n        ++left;\n    }\n}\nvoid Merge(int* src, int* tmp, int left, int mid, int right)\n{\n    int i = left, j = mid + 1;\n    int k = left;\n    while(i <= mid && j <= right)\n    {\n        tmp[k++] = src[i] <= src[j] ? src[i++] : src[j++];\n    }\n    while(i <= mid)\n    {\n        tmp[k++] = src[i++];\n    }\n    while(j <= right)\n    {\n        tmp[k++] = src[j++];\n    }\n}\nvoid MergePass(int* src, int* tmp, int left, int right)\n{\n    if(left < right)\n    {\n        int mid = (right + left) / 2;\n        MergePass(src, tmp, left, mid);\t     //左部分\n        MergePass(src, tmp, mid + 1, right); //右部分\n        \n        Merge(src, tmp, left, mid, right);\t //左右两部分比对合并，tmp临时存储\n        Copy(tmp, src, left, right);         //将tmp内容导到src，便于下次两部分均有序\n    }\n}\nvoid MergeSort(int* br, int n)\n{\n    if(br == NULL || n <= 1)return;\n    int* tmp = new int[n];\n    MergePass(br, tmp, 0, n - 1);\n    delete[]tmp;\n}\n```\n\n# 非递归形式\n\n```c++\n/*\n假设对0 1 2 3 4 5 6 7 8排序\nMerge(src, dest, 0, 0, 1)  --s=1\n\t\t\t\t 2\t2  3\n\t\t\t\t 4  4  5\n\t\t\t\t 6  6  7\nMerge(src, dest, 0, 1, 3)  --s=2\n\t\t\t\t 4, 5, 7\nMerge(src, dest, 0, 3, 7)  --s=4\n\n*/\nvoid Merge(int * src, int * dest, int left, int mid, int right);\n// s代表当前一轮归并的元素数（一半规模）\nvoid MergePass(int* src, int* dest, int n, int s)\n{\n    int i = 0;\n    // for的条件判断是看 剩下的元素数还够不够凑一个2 * s（s是要归并的半块）\n    for(i = 0; i + 2 * s - 1 <= n - 1; i += 2 * s)\n    {\n        Merge(src, dest, i, i + s - 1, i + 2 * s - 1);\n    }\n    if(n - 1 > i + s - 1)//对于[0 1]-[2 3] [4 5]-[6 7] [8 9]-[10]而言(11-1>8+2-1)，即[8 9][10]还需要再合并：即此处处理的是剩下的两块，右部分的一块不整齐（10）\n    {\n        Merge(src, dest, i, i + s - 1, n - 1);\n    }\n    else//[0 1 2 3]-[4 5 6 7] [8 9 10]而言(不满足if的11-1>10+1-1)，也就是说，8 9 10落单了，没有下一组与它们合并，则原样复制\n    {\n        for(int j = i; j < n; ++j)\n        {\n            dest[j] = src[j];\n        }\n    }\n}\nvoid MergeSort(int * ar, int n)\n{\n    if(ar == NULL || n <= 1)return;\n    int * tmp = new[n];\n    // s代表当前一轮归并的元素数（一半规模）\n    int s = 1;\n    while(s < n)\n    {\n        MergePass(ar, tmp, n, s);\n        s += s;\n        MergePass(tmp, ar, n, s);\n        s += s;\n    }\n    delete[]tmp;\n}\n```\n\n# 适用思想的题\n\n","categories":["算法","排序"]},{"title":"排序_快速排序","url":"/算法/排序_快速排序/","content":"# 内容\n\n1. 默认划分法\n2. 非递归形式\n3. 随机划分法\n4. 三位取中法\n5. 单向划分法\n6. 单链表快排（单向划分法）\n\n# 原始代码\n\n```c++\n//划分函数\nvoid Partition(int * ar, int left, int right)\n{\n    int tmp = ar[left];\n    while(left < right)\n    {\n        while(left<right && ar[right]>tmp)--right;\n        if(left < right) ar[left] = ar[right];\n        while(left<right) && ar[left]<=tmp)++left;\n        if(left < right) ar[right] = ar[left];\n    }\n    ar[left] = tmp;//left == right\n    return left;\n}\nvoid PassQuick(int * ar, int left, int right)\n{\n    if(left < right)\n    {\n        int pos = Partition(ar, left, right);\n        PassQuick(ar, left, pos-1);\n        PassQuick(ar, pos+1, right);\n    }\n}\nvoid QuickSort(int * ar, int n)\n{\n    if(ar==NULL || n<=1)return;\n    PassQuick(ar, 0, n-1);\n}\n```\n\n# 让函数不再任性-非递归\n\n```c++\nvoid Partition(int* ar, int left, int right)\n{\n    int tmp = ar[left];\n    while(left < right)\n    {\n        while(left<right && br[right]>tmp)--right;\n        if(left < right) br[left] = br[right];\n        while(left<right) && br[left]<=tmp)++left;\n        if(left < right) br[right] = br[left];\n    }\n    br[left] = tmp;//left == right\n    return left;\n}\nvoid QuickSort(int* ar, int n)\n{\n    if(ar==NULL || n<=1)return;\n    queue<int> qu;\n    qu.push(0);\n    qu.push(n - 1);\n    while(!qu.empty())\n    {\n        int left = qu.front(); qu.pop();\n        int right = qu.front();qu.pop();\n        int pos = Partition(ar, left, right);\n        if(left < pos-1)\n        {\n            qu.push(left);\n            qu.push(pos-1);\n        }\n        if(pos+1 < right)\n        {\n            qu.push(pos+1);\n            qu.push(right);\n        }\n    }\n}\n```\n\n使用别名之后, 程序更为简洁;\n\n```c++\nvoid QuickSort(int * ar, int n)\n{\n    if(ar==NULL || n<=1)return;\n    using Pair = std::pair<int,int>;\n    queue<Pair> qu;\n    qu.push(Pair(0, n-1));\n    while(!qu.empty())\n    {\n        Pair pos = qu.front();qu.pop();\n        int mid = Partition(ar, pos.first, pos.second);\n        if(pos.first < mid-1)\n            qu.push(Pair(pos.first, mid-1));\n        if(mid+1 > pos.second)\n            qu.push(Pair(mid+1, pos.second));\n    }\n}\n```\n\n# 从“选取划分基准”入手优化\n\n## 随机划分\n\n这样做是为了让划分点无序, 以模拟数据的无序性, 防止数据有序情况下快排性能的退化; \n\n实现方法: 在Partition之外再封装一层随机选取一个位置, 把这个位置与`ar[left]`值交换, 然后再调用Partition; 这样的好处就是, 不用修改Partition函数;\n\n```c++\nint RandPartition(int * ar, int left, int right)\n{\n    srand(time(NULL));\n    int pos = rand() % (right-left+1) + left;//记得取模后+left，不加left是相对位置。\n    std::swap(ar[left], ar[pos]);\t\t//偷梁换柱\n    return Partiton(ar, left, right);\n}\n```\n\n## 三位取中法\n\n```c++\nint MidPartition(int* ar, int left, int right)\n{\n    int midpos = (right - left)/2 + left;\n    struct IndexNode\n    {\n        int key;\n        int index;\n        operator int() const {return key;}\n    };\n    struct IndexNode kL = {ar[left], left};\n    struct IndexNode kM = {ar[midpos], midpos};\n    struct IndexNode kR = {ar[right],right};\n\tstd::priority_queue<IndexNode> hp;\n    //kL,kM,kR入堆时，由于IndexNode类型重载了int()强转运算符，所以入堆按其key大小排序。则堆中第二个元素为key第二小的。\n    hp.push(kL); hp.push(kM); hp.push(kR);\n    hp.pop();\n    struct IndexNode pos = hp.top();\n    std::swap(ar[kL.index], ar[pos.index]);\t//偷梁换柱\n    return Partition(ar, left, right);\n}\n```\n\n# 应对特殊数据结构-单向划分\n\n可以处理单链表场景下的快排。\n\n先拿数组练。\n\n```c++\nint ForwardPartition(int * ar, int left, int right)\n{\n    int j = left - 1;//慢指针\n    int i = left;    //快指针\n    int tmp = ar[i];\n    while(i <= right)\n    {\n        if(ar[i] <= tmp)\n        {\n            ++j;\n            swap(ar[j],ar[i]);\n        }\n        ++i;\n    }\n    swap(ar[left], ar[j]);  //单向划分，以left为基准，过程中要保证left值不会变化。最后，找到j的位置(划分之后的中间位置)后，替换，返回。\n    return j;\n}\n```\n\n## 单链表的划分（带头节点）\n\n```c++\ntypedef int ElemType;\ntypedef struct ListNode\n{\n    ElemType data;\n    struct ListNode* next;\n}ListNode, *LinkList;\n//head表示这个划分区间的第一个有效节点的前一个；end表示这个划分区间最后一个有效节点的后一个（有可能为NULL）。\nvoid ForwoadListPartition(ListNode* head,ListNode *end)\n{\n    ListNode* j = head;\n    ListNode* i = head->next;\n    ElemType tmp = i->data;\n    while(i != end)\n    {\n        if(i->data <= tmp)\n        {\n            j = j->next;\n            swap(j->data, i->data);\n        }\n        i = i->next;\n    }\n    swap(head->next->data, j->data);\n    //不再像数组那样，不用对中间位置进行mid-1,mid+1。因为此时的head,end已代表不同意义，j正好可以充当-1和+1。\n    ForwoadListPartition(head, j);\n    ForwoadListPartition(j, end);\n}\n```\n\n# 适用分治策略-“划分”思想的场景\n\n## 找到第K小/大数\n\n不能有重复值。\n\n```c++\nint FindK(int * ar, int left, int right, int k)//k是相对位置\n{\n    if(left==right && k==1)return ar[left];\n    int pos = Partition(ar, left, right);\t//返回的pos是绝对下标\n    int j = pos - left + 1;\t\t\t\t\t//j和k一样，是相对left的位置\n    if(k<=j)return FindK(ar, left, pos, k);\t //当k还在j之左时，在left~pos继续划分寻找第k小\n    else return Findk(ar, pos+1, right, k-j);//当k在j之右时，在pos+1~right寻找第k-j小，因为换到右边时，\"k\"的值发生变化。\n}\nint FindK_Min(int * ar, int n, int k)//第k小\n{\n    if(ar==NULL || k<0 || k>n)return -1;\n    return FindK(ar, 0, n-1, k);\n}\n```\n## 无序数组中找两个差值最小\n\n非负数。\n\n即找最接近点对，以一维为例。\n\n```c++\nint FindK_Min(int * ar, int n, int k)\n{\n    if(ar==NULL || k<0 || k>n)return -1;\n    return FindK(ar, 0, n-1, k);\n}\nint MaxS1(const int* ar, int left, int right)\n{\n    return ar[right];\n}\nint MinS2(const int* ar, int left, int right)\n{\n    int min = ar[left];\n    for(int i = left + 1; i<=right; ++i)\n    {\n        if(min > ar[i])\n        {\n            min = ar[i];\n        }\n    }\n    return min;\n}\nint Min(int a, int b)\n{\n    return a < b ? a : b;\n}\nint Min(int a, int b, int c)\n{\n    return Min(a, Min(b, c));\n}\nint Cpair(int * ar, int left, int right)\n{\n    if((right-left) <= 0) return INT_MAX;\n    int mid = (right-left+1)/2;\n    FindK(ar, left, right, mid);//mid为相对位置，正好是s1中最大的。\n    int pos = left + mid - 1;//pos为绝对下标。\n    int d1 = Cpair(ar, left, pos);\t//在左部分找到点对的最小差值\n    int d2 = Cpair(ar, pos+1,right);//在右部分找到点对的最小差值\n    int maxs = MaxS1(ar, left, pos);\n    int mins = MinS2(ar, pos+1, right);\n    return Min(d1, d2, mins-maxs);\n}\nint Cpair_Ar(int * ar, int n)\n{\n    if(ar==NULL || n<1)return INT_MAX;\n    else return Cpair(ar, 0, n-1);\n}\n```\n\n# 不同场景下的对策\n\n1. 数组相对有序：随机划分法。在每次划分之前在left和right之前rand计算一个pos，使该值与left对应的值交换，进而以其为基准进行划分。\n2. \n","categories":["算法","排序"]},{"title":"Linux_Shell编程","url":"/Linux/Linux_Shell编程/","content":"# 内容\n\n1. 编译型语言\n2. 解释器\n3. 变量：本地变量、环境变量、参数变量\n4. 条件：字符串判断、算术、文件测试\n5. 控制结构：循环、case\n6. 函数\n7. 脚本调用脚本，c语言调用脚本\n8. awk，sed\n# 环境变量\n\n| 类型     | 语法                       | 注意点                               |\n| ------ | ------------------------ | --------------------------------- |\n| 赋值     | `var=value`              | 不能有空格                             |\n| 引用     | `$var`                   | 用双引号包裹是读var的值，用单引号包裹是`$var`这4个字符。 |\n| 删除     | unset var                | 不要加`$`符                           |\n| 输入     | read `var1` `var2` `...` | 按顺序写入变量，类似于scanf，以回车或者空格分隔        |\n| 列出所有变量 | set                      |                                   |\n| 全局化变量  | export var               |                                   |\n## 特殊变量\n\n都需要搭配`$`使用\n\n| 特殊变量    | 定义           | 注意点                              |\n| ------- | ------------ | -------------------------------- |\n| ?       | 前一命令的退出状态    | 0代表成功、真；其他非0数代表失败、假的某一状态         |\n| $       | 当前Shell的进程ID | echo `$$`才能输出                    |\n| !       | 后台运行命令的进程ID  |                                  |\n| `1 ~ 9` | 当前脚本的第1到9个参数 |                                  |\n| `_`     | 上一个命令的最后一个参数 | 比如在命令行敲入`ls -a`，则echo `$_`输出`-a` |\n| PS1     | Shell主提示符    |                                  |\n| PS2     | Shell次提示符    |                                  |\n## 字符串处理\n\n1. 注意双引号、单引号的功能，双引号引起主要是为了消除空格的影响，保留转义效果；而单引号是把所引的内容**原封不动地**保留。\n\n```sh\na=\"xcg\"\nstr=\"$a\"\t#把a的值赋给了str\necho \"$str\" #实际输出: xcg\n\nstr='$a'\t#把\"$a\"这个 原本的字符串 赋给了str\necho \"$str\"\t#实际输出: $a\n```\n\n2. 如果想把某一个命令的运行结果作为字符串返回给str，则有两种方式。\n    1. $( )\n\n```sh\nstr=$(ls)\t#把当前目录的文件信息字符串赋给str\n```\n\n    2. 反引号\n\n```sh\nstr=`ls`\t##把当前目录的文件信息字符串赋给str\n```\n## export\n在当前shell可以再启动一个shell。如果我们在之前的shell中定义了局部变量，比如`var=hello`，在新启动的shell是看不到的。如果要新shell看到，需要`export var`。\n其实新开的这个shell是在之前的shell新运行的一个程序。他俩是不同的进程。同理，如果想让其他进程也能看到之前shell的环境变量，此时就需要export。\n# 第一行注释\n第一行需要添加注释，指示使用哪个shell程序运行该脚本。\n```sh\n#! /bin/sh\n\n# ...\n```\n# C语言编程main函数的参数 - 结合环境变量\n```c\n// c.c\n#include <stdio.h>\nint main (int ac, char * av[])\n{\n    if (ac > 1)\n    {\n        printf(\"%s\\n\", av[1]);\n    }\n    return 0;\n}\n```\n运行结果：\n```sh\nmrcan@ubuntu:~$ ./c.out var\nvar\n```\n如上，var是命令中的参数，程序输出了var这个参数名。\n```sh\nmrcan@ubuntu:~$ VAR=ThisIsMyVar\nmrcan@ubuntu:~$ ./c.out $VAR\nThisIsMyVar\n```\n如上，也可以先定义环境变量VAR。然后再通过`$VAR`传到main函数。\n## 结合重定向 - 把另一个程序的结果作为参数传到main\n结合《Linux_重定向》一文中的知识。\n可以利用“命令代换”（形如`$(./a.out)`）。\n```sh\nmrcan@ubuntu:~$ ./a.out \nC Program!  # 这是a.out的执行结果\nmrcan@ubuntu:~$ ./c.out $(./a.out)\nC           # 把a.out的输出传给了c.c的main函数\n```\n如上，把`a.out`的输出结果通过`$(a.out)`传到了`c.c`的main函数。\n![](../../images/Linux_Shell编程/image-20250716173158651.png)\n\n系统中的小程序，也可以作为命令代换的参数。\n```sh\npwd # 输出结果 /home/mrcan\nls $(pwd)\n```\n输出结果：\n```sh\nmrcan@ubuntu:~$ pwd\n/home/mrcan\nmrcan@ubuntu:~$ ls $(pwd)\na.c    b.out  c.out    Documents  Music     Public     test.cpp\na.out  build  c.sh     Downloads  packages  Templates  test_muduo.cpp\nb.c    c.c    Desktop  mprpc      Pictures  test       Videos\n```\n# Operator - 操作符\n## Equal Operator\n1. `=` string。注意，`=`前后必须有空格分隔。不然就成了环境变量赋值了。\n2. `!=` string\n3. `-eq` numeral\n4. `-ne` numeral\n\n```sh\n```\n## Logical Operator\n1. `-a`：and\n2. `-o`：or\n3. `!`：not\n\n## Relation Operator\n1. `-gt`：greater than\n2. `-ge`：greater equal\n3. `-lt`：less than\n4. `-le`：less equal\n# if语句\n```sh\n#! /bin/sh\nVAR1=\"COMPUTER\"\nif [ $VAR! = \"COM\" ]\nthen\n    echo \"Y\"\nelse\n    echo \"N\"\nfi\n```\n注意点：\n1. `=`前后有无空格的行为是不一样的。\n2. 中括号的前后最好也留上空格，避免无法分辨。\n\n```sh\n#! /bin/sh\nVAR1=\"COMPUTER\"\n if [ $VAR1=\"COM\" ]\n# if (test $VAR1=\"COM\")\nthen\n    echo \"Y\"\nelse\n    echo \"N\"\nfi\n```\n以上程序输出Y，即使VAR1不是\"COM\"。就是因为`=`前后无空格。\n\n2. if后跟的`[ ... ]`相当于：`(test ...)`\n\n# 循环\n\n## 要注意的是对计数变量的处理\n\n有2种方式：\n\n1. `let`\n\n```sh\ni=1\nlet \"i+=1\"\n```\n\n2. `(( ))`，双括号中是想要执行的命令/表达式，可以用$取表达式的值。\n\n```sh\ni=1\na=$((i++))\n```\n\n3. 反引号：\\`expr ...\\`\n\n```sh\ni=1\na=`expr $i \\* 2`\t#*在脚本中有其他意义，需要加\\转义为'*'，在此表示乘号\ni=`expr $i + 1`\t\t#此方式i自增的方法\n```\n\n\n\n\n## for\n![](../../images/Linux_Shell编程/image-20250716194411584.png)\n\nfor循环的次数由in后面值的数目决定\n\n```sh\nfor i in 1 2 3\ndo\n\techo i=$i\n\tsleep 1\ndone\n\nfor name in $(ls)\ndo\n\techo \"filename: $name\"\ndone\n```\n### `$@`\n```sh\n#! /bin/sh\nfor x in $@\ndo\n    echo $x\ndone\n```\n\n```sh\n./test.sh 1 2 3 4\n```\n输出结果\n```\n1\n2\n3\n4\n```\n## while\n![](../../images/Linux_Shell编程/image-20250716203447090.png)\n\n\n判断条件，满足则循环执行。\n\n```sh\n#死循环示例\nwhile [ 1 ]\ndo\n\techo \"run\"\n\tsleep 1\ndone\n#死循环输出输入的内容，直到输入end\nwhile true\ndo\n\techo \"input\"\n\tread line\n\tif [ \"$line\" = end ]\n\tthen\n\t\tbreak\n\tfi\n\techo \"line=$line\"\ndone\n#输出0-9\nwhile [ \"$i\" -lt 10 ]\ndo\n\techo \"i=$i\"\n\t#let \"i+=1\"\n\t#((++i))\n\ti=`expr $i + 1`\ndone\n```\n\n## until\n![](../../images/Linux_Shell编程/image-20250716203453605.png)\n\n\n条件没满足时，循环执行；一旦条件满足则退出。\n\n```sh\n#本地找file.txt文件，隔一秒找一遍，直到找到，退出。\nuntil [ -f file.txt ]\ndo\n\techo \"not find file.txt\"\n\tsleep 1\ndone\necho \"find file.txt\"\n```\n\n# read\n\n read命令 -n(不换行) -p(提示语句) -n(字符个数)-t(等待时间) -s(不回显)\n# case\n![](../../images/Linux_Shell编程/image-20250716203511779.png)\n## 结合正则表达式的示例\n\n```sh\nwhile true\ndo\n    echo \"input:\"\n    read line\n    case \"$line\" in\n        yes | Y) \techo \"this is yes\";;\n        no\t| N)\techo \"this is no\";;\n        end)\t\tbreak;;\n        *)\t\t\techo \"$line\";;\n    esac\ndone\n#可以搭配正则表达式使用。\nread line\ncase \"$line\" in\n    [Yy][Ee][Ss] | [Yy])echo \"this is yes\";;\n    [Nn][Oo] | [Nn])\techo \"this is no\";;\n    end)\t\t\t\tbreak;;\n    *)\t\t\t\t\techo \"$line\";;\nesac\n```\n\n# 练习：把多行IP地址转换为10进制\n1. 先生成n行（192.168.0.1开始）\n2. 对n个ip地址进行转换，转换后的数据放在`IPint.txt`文件内。\n\n## 生成n行IP\n```sh\n#! /bin/sh\n# $1: nums of ip address\nFILE=\"IPs.txt\"\nI=1\nif [ -e $FILE ]\nthen\n    rm $FILE\nfi\n\nwhile [ $I -le $1 ]\ndo\n    echo \"192.168.0.$I\" >> $FILE\n    I=$(expr $I + 1)\ndone\n```\n\n```sh\nmrcan@ubuntu:~$ ./generateIP.sh 10\nmrcan@ubuntu:~$ cat IPs.txt \n192.168.0.1\n192.168.0.2\n192.168.0.3\n192.168.0.4\n192.168.0.5\n192.168.0.6\n192.168.0.7\n192.168.0.8\n192.168.0.9\n192.168.0.10\n```\n## 什么是IP地址的10进制？\n不是简单的每个分段的10进制（`192/168/0/1`这些）\n而是要一个32位无符号整型数十进制表示的：从32个0到32个1的这之间的某一个数。\n其实可以直接把IP地址看作**32位2进制数**，来转换、计算为其十进制值。\n但是过程不太美观。\n![](../../images/Linux_Shell编程/image-20250717012003686.png)\n如以上过程，太复杂！\n\n有可读性更好的方法：把IP地址看作**4位256进制数**。来转换、计算为其十进制值。\nIPv4地址每一个分段的数的大小范围：0到255，因此现在形式下的IPv4每位数属于256进制，是用`.`分开了。\n![](../../images/Linux_Shell编程/image-20250717012039244.png)\n如上，很香！\n\n那么我们平时说的“一百二十三”，这个3位数，就可以看作：1.2.3，每一个分段的大小范围是0到9，属于10进制。怎么计算其10进制数？power是10，\n$$\n\\begin{align}\n1 * 10 ^ 2 &= 100 \\\\\n2 * 10 ^ 1 &= 20 \\\\\n3 * 10 ^ 0 &= 3 \\\\\n100 + 20 + 3 &= 123\n\\end{align}\n$$\n\n那么，4位256进制，转为10进制的算法：\n$$\n\\begin{align}\n192 * 256 ^ 3 &= a\\\\\n168 * 256 ^ 2 &= b\\\\\n0 * 256 ^ 1   &= c\\\\\n1 * 256 ^ 0   &= d\\\\\nresult &= a + b + c + d\n\\end{align}\n$$\n## 编写转换进制\n需要切分IP地址的4段。\n用到了cut：见《[[Linux_cut命令]]》\n\n```sh\n#! /bin/sh\nINPUT=IPs.txt\nOUTPUT=IPint.txt\n\nSUM=0\n\nif [ -e $OUTPUT ]\nthen\n    rm $OUTPUT\nfi\n\ncat $INPUT |           # 精髓\nwhile read IP\ndo\n    I=1\n    SUM=0\n    while [ $I -le 4 ]\n    do\n        NUM=$(echo $IP | cut -d. -f$I)\n        case $I in\n            1)\n            SUM=$(expr $NUM \\* 256 \\* 256 \\* 256)\n            ;;\n            2)\n            SUM=$(expr $SUM + $NUM \\* 256 \\* 256)\n            ;;\n            3)\n            SUM=$(expr $SUM + $NUM \\* 256)\n            ;;\n            4)\n            SUM=$(expr $SUM + $NUM)\n            ;;\n        esac\n        I=$(expr $I + 1)\n    done\n    echo $IP $SUM >> $OUTPUT\ndone\n```\n输出结果：\n```\n192.168.0.1 3232235521\n192.168.0.2 3232235522\n192.168.0.3 3232235523\n192.168.0.4 3232235524\n192.168.0.5 3232235525\n192.168.0.6 3232235526\n192.168.0.7 3232235527\n192.168.0.8 3232235528\n192.168.0.9 3232235529\n192.168.0.10 3232235530\n```\n## 注意点\n1. 没有`+=`这个形式\n2. `expr` 的设计中没有包含幂运算符（如 `**` 或 `^`），因此只能用`num \\* 256 \\* 256 \\* 256`这样连乘。\n3. case结束别忘记esac\n## 知识点\n程序的精髓在于，怎么循环read读取一个文件中的每一行，我们用`cat $INPUT | `管道传入read，再给read加一层循环，这样，只要管道中还有内容，while循环就不会停止。\n\n# 函数\n\n三个问题：1、如何传参的问题；2、函数返回值如何获得；3、如何看待函数内定义的变量\n\n## 特点\n\n1. shell脚本中的函数没有声明，需要直接定义在最前面。\n2. 调用函数不用加圆括号，而是只有函数名\n\n```sh\nfun()\n{\n\techo \"fun run\"\n}\nfun\n```\n\n## 参数\n\n注意`$#/$1/$2`在函数中、函数外的区别：在函数中代表函数的参数；而在函数外代表此shell脚本的参数。\n\n```sh\nfun()\n{\n\techo \"fun run\"\n\techo \"fun: \\$#=$#\"\t# \"$#\"代表参数个数\n\techo \"fun: \\$1=$1\"\t# \"$1\"表示该函数的第一个参数\n\techo \"fun: \\$2=$2\"\n}\nfun hello 123\n#此处就要注意与上面函数中$#/$1/$2的区别了，在函数中代表函数的参数；而在函数外代表此shell脚本的参数。\necho \"my.sh: \\$#=$#\"\necho \"my.sh: \\$1=$1\"\necho \"my.sh: \\$2=$2\"\n\n# 在外部执行脚本时：\n# ./my.sh xcg test\n\t# 输出:\n        # fun: $#=2\n        # fun: $1=hello\n        # fun: $2=123\n        # my.sh: $#=2\n        # my.sh: $1=xcg\n        # my.sh: $2=test\n```\n\n## 返回值\n\n```sh\nmy_add()\n{\n\tif [ \"$#\" -ne 2 ]\t# -ne : not equal\n\tthen\n\t\techo \"参数有误\"\n\t\treturn 0\n\tfi\n\tres=`expr $1 + $2`\n\treturn $res\n}\nres=my_add\necho \"$res\"\n# 或者写为\n\t# my_add\n\t# echo \"$?\"\n\t\t# \"$?\"代表上一行语句执行的结果(返回值)。\n# 如果想保存返回值，可以：\n\t# my_add 123 234\n\t# result=$?\n\t\t# 如果连续写两行\"$?\"，则第二行的结果是0，因为\"$?\"的执行结果是0，代表执行成功。\n```\n\n## 变量生存期问题\n\n函数中的变量可能污染到函数外\n\n```sh\nmy_test()\n{\n\tstr=hello\n\techo \"my_test:str=$str\"\n}\nmy_test\necho \"str=$str\"\n# 打印结果\n\t# my_test:str=hello\n\t# str=hello\n# 由此可见，函数中的变量污染到了函数外。\n```\n\n此问题的原因：\n脚本程序的概念并不存在作用域的概念。所以，函数中定义、赋值str语句**执行**后，不管是函数中，还是bash解释器，也就都存在str这个变量。\n\n```sh\nmy_test()\n{\n\tstr=hello\n\techo \"my_test:str=$str\"\n}\ntest2()\n{\n\techo \"test2:str=$str\"\n}\nmy_test\necho \"str=$str\"\ntest2\n# 执行结果\n\t# my_test:str=hello\n\t# str=hello\n\t# test2:str=hello\n```\n\n```sh\nmy_test()\n{\n\tstr=hello\n\techo \"my_test:str=$str\"\n}\ntest2()\n{\n\techo \"test2:str=$str\"\n}\n\necho \"str=$str\"\ntest2\nmy_test\n# 执行结果\n\t# str=\n\t# test2:str=\n\t# my_test:str=hello\n# 在执行my_test前，还没有str变量给出，所以，test2和函数外的str都打印为空\n```\n\n### 解决变量污染的方法\n\n> 1、可以通过unset在用完变量后，销毁之。\n\n```sh\nmy_test()\n{\n\tstr=hello\n\techo \"my_test:str=$str\"\n\tunset str\n}\nmy_test\necho \"str=$str\"\n# 执行结果\n\t# my_test:str=hello\n\t# str=\n```\n\n> 2、可以在变量名前加local\n\n```sh\nstr=\"abcdef\"\nmy_test()\n{\n\tlocal str=hello\n\techo \"my_test:str=$str\"\n}\nmy_test\necho \"str=$str\"\n# 执行结果\n\t# my_test:str=hello\n\t# str=abcdef\n```\n\n> 注意事项：unset对于local变量，只会局部地销毁这个变量，不影响全局的同名变量。\n\n```sh\n#################### 程序1\nstr=\"abcdef\"\nmy_test()\n{\n\tlocal str=hello\n\techo \"my_test:str=$str\"\n\tunset str\n}\nmy_test\necho \"str=$str\"\n# 执行结果\n\t# my_test:str=hello\n\t# str=abcdef\n\n#################### 程序2\nstr=\"abcdef\"\nmy_test()\n{\n\tstr=hello\n\techo \"my_test:str=$str\"\n\tunset str\n}\nmy_test\necho \"str=$str\"\n# 执行结果\n\t# my_test:str=hello\n\t# str=\n```\n\n# 脚本间的调用\n\n```sh\n###################### b.sh\n#!/usr/bin/bash\necho \"b.sh run pid=$$\"\t# \"$$\"代表本bash脚本的pid\n./d.sh\nexit 0\n###################### d.sh\n#!/usr/bin/bash\necho \"d.sh run pid=$$\"\t# \"$$\"代表本bash脚本的pid\nexit 0\n###################### 外部执行: ./b.sh\n###################### 执行结果:\n        # b.sh run pid=5346\n        # d.sh run pid=5347\n```\n\n### 脚本间变量的传递问题\n\n```sh\n###################### b.sh\n#!/usr/bin/bash\necho \"b.sh run pid=$$\"\t# \"$$\"代表本bash脚本的pid\nmystr=hello\necho \"b.sh mystr=$mystr\"\n./d.sh\nexit 0\n###################### d.sh\n#!/usr/bin/bash\necho \"d.sh run pid=$$\"\t# \"$$\"代表本bash脚本的pid\necho \"d.sh mystr=$mystr\"\nexit 0\n###################### 外部执行: ./b.sh\n###################### 执行结果:\n        # b.sh run pid=5368\n        # b.sh mystr=hello\n        # d.sh run pid=5369\n        # d.sh mystr=\n# 注意，此时d.sh没有打印出来b.sh中的mystr，说明两个脚本程序各自运行在不同的进程空间内，变量互不污染。\n```\n\n为了在脚本间可以传递变量，可有以下方式\n\n> 1、在一个sh中调用另一个sh时，后面加参数。但是只是能拿到值，变量名字不能通用，需要用“$1”来取出。\n\n```sh\n###################### b.sh\n#!/usr/bin/bash\necho \"b.sh run pid=$$\"\nmystr=hello\necho \"b.sh mystr=$mystr\"\n./d.sh $mystr\t\t\t#!!! 后面加参数\nexit 0\n###################### d.sh\n#!/usr/bin/bash\necho \"d.sh run pid=$$\"\necho \"d.sh mystr=$1\"\t#!!! 需要用“$1”来取出\nexit 0\n###################### 外部执行: ./b.sh\n###################### 执行结果:\n        # b.sh run pid=5380\n        # b.sh mystr=hello\n        # d.sh run pid=5381\n        # d.sh mystr=hello\n```\n\n> 2、如果想要变量名字通用，可以export改变mystr为环境变量，因为环境变量可以被继承，所以让变量名字通用了。\n\n```sh\n##################### b.sh\n#!/usr/bin/bash\necho \"b.sh run pid=$$\"\nmystr=hello\nexport mystr\t\t\t#export改变mystr为环境变量\necho \"b.sh mystr=$mystr\"\n./d.sh\nexit 0\n###################### d.sh\n#!/usr/bin/bash\necho \"d.sh run pid=$$\"\necho \"d.sh mystr=$mystr\"\nexit 0\n###################### 外部执行: ./b.sh\n###################### 执行结果:\n        # b.sh run pid=5380\n        # b.sh mystr=hello\n        # d.sh run pid=5381\n        # d.sh mystr=hello\n```\n\n> 3、通过source。source的作用是在调用另一个脚本时，不启动另外的sh，而是在自身的解释器中去运行另一个脚本的命令。相当于内联展开于此，所以原来的变量可以复用。但是问题的隐患很多，因为调用的脚本会对原来的脚本造就的环境造成影响。\n\n```sh\n##################### b.sh\n#!/usr/bin/bash\necho \"b.sh run pid=$$\"\nmystr=hello\necho \"b.sh mystr=$mystr\"\n. ./d.sh\t# 前面的“.+空格”中的“.”即代表source\n# source ./d.sh\nexit 0\n###################### d.sh\n#!/usr/bin/bash\necho \"d.sh run pid=$$\"\necho \"d.sh mystr=$mystr\"\nexit 0\n###################### 外部执行: ./b.sh\n###################### 执行结果: !!!发现pid一样！\n        # b.sh run pid=5448\n        # b.sh mystr=hello\n        # d.sh run pid=5448\n        # d.sh mystr=hello\n```\n\nsource的作用：有时需要对当前的bash进行环境变量的初始化，可以用source(. ./xx.sh)来在本sh直接运行提前写好的配置脚本。\n\n# C程序和脚本间的调用\n\n脚本调用C程序显而易见。\n\n我们讨论C程序调用脚本。\n\n```sh\n#!/usr/bin/bash\necho \"my.sh pid=$$\"\nmystr=\"hello^_^\"\necho \"mystr=$mystr\"\nexit 0\n\n```\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<string.h>\nint main()\n{\n    printf(\"main pid=%d\\n\",getpid());\n    execl(\"./my.sh\",\"my.sh\",(char*)0);\n    printf(\"execl err\\n\");\n    exit(0);\n}\n// 执行结果\n\t// main pid=5607\n\t// my.sh pid=5607\n\t// mystr=hello^_^\n// 为什么pid一样呢？因为在main函数中exec了自身。\n```\n\n表面上启动的是my.sh，实际上启动的是/usr/bin/bash。\n\n# 练习\n\n* 从键盘读取一个成绩，0~100之外的不可以。把整数值转为等级A、B、C、D。\n\n| 成绩  | 等级 |\n| ----- | ---- |\n| >= 90 | A    |\n| >= 80 | B    |\n| >= 70 | C    |\n| >= 60 | D    |\n| < 60  | E    |\n\n```sh\n#!/usr/bin/bash\n\nwhile [ 1 ]; do\n  printf 'please input your score:'\n  read score\n  if [ $score -ge 0 ] && [ $score -le 100 ]\n  then\n    grade=$(($score/10))\n    #echo $grade\n    printf 'your grade is:'\n    case $grade in\n      9 | 10 ) echo \"A\";;\n      8 ) echo \"B\";;\n      7 ) echo \"C\";;\n      6 ) echo \"D\";;\n      * ) echo \"E\";;\n    esac\n  else\n    echo \"error in your input!\"\n  fi\ndone\n\nexit 0\n```\n\n测试结果：\n\n![image-20220215130731237](../../images/Linux_Shell编程/image-20220215130731237.png)\n\n* 第一题的优化\n\n```bash\n#!/usr/bin/bash\nprintf '输入你的成绩：'\nread score\ncase $score in\n    [0-9] | [1-9][0-9] | 100)\n        grade=$(($score/10))\n        #echo $grade\n        printf \"你的成绩是$score，等级：\"\n        case $grade in\n            9 | 10 ) echo \"优\";;\n            8 ) echo \"良\";;\n            7 ) echo \"中\";;\n            6 ) echo \"及格\";;\n            * ) echo \"不及格\";;\n        esac;;\n    *) echo \"error in your input!\";;\nesac\nexit 0\n```\n\n* 循环接收用户输入的学生成绩（百分制），若成绩小于60，输出“不及格”；若成绩大于等于60，输出“及格”，按Q(q)键退出。\n\n```bash\n#!/bin/bash\nwhile true\ndo\n    read -p \"输入成绩：\" score\n    case $score in\n        [Qq]) exit;;\n        [0-9] | [1-5][0-9]) echo \"不及格\";;\n        100 | [6-9][0-9])   echo \"及格\";;\n        *)  echo \"不合法，请输入0~100\";;\n    esac\ndone\n```\n\n* 循环接收某门课程的成绩，计算用户已输入的最高分、最低分、平均分，按P(p)键输出计算结果，按Q(q)键退出。\n\n```bash\n#!/bin/bash\nmin=100\nmax=0\nsum=0\ncount=0\nwhile true\ndo\n    read -p \"输入分数：\" score\n    case $score in\n        [0-9] | [1-9][0-9] | 100)\n            echo \"$score 已录入\"\n            sum=$(($sum+$score))\n            count=$(($count+1))\n            if [ $score -gt $max ]\n            then max=$score\n            fi\n            if [ $score -lt $min ]\n            then min=$score\n            fi;;\n        [Pp])\n            echo \"max = $max\"\n            echo \"min = $min\"\n            echo \"avg = $(($sum/$count))\"\n            continue;;\n        [Qq])   exit;;\n        *)      echo \"$score 不合法，请重新输入。\"\n    esac\ndone\n```\n\n\n\n# 注意\n\n例：输入一个正整数，判断其是否为质数。正确的程序如下：\n\n```bash\n#!/bin/bash\n\nread -p \"请输入一个正整数：\" number\n[ $number -eq 1 ] && echo \"$number 不是质数\" && exit\nfor i in `seq 2 $(($number-1))`\ndo\n    [ $[$number % $i] -eq 0 ] && echo \"$number不是质数\" $$ exit\ndone\necho \"$number是质数\" && exit\n# 正确的测试结果：\n# \t输入 1\n# \t输出 1不是质数\n# 正确的测试结果：\n# \t输入 7\n# \t输出 7是质数\n```\n\n其中，判断语句如[ \\$number -eq 1 ]必须在首尾中括号之间有空格，不然找不到命令。如下是错误的。\n\n```bash\nread -p \"请输入一个正整数：\" number\n[$number -eq 1] && echo \"$number 不是质数\" && exit\t#错误\nfor i in `seq 2 $(($number-1))`\ndo\n    [$[$number % $i] -eq 0] && echo \"$number不是质数\" $$ exit #错误\ndone\necho \"$number是质数\" && exit\n# 测试：\n# \t输入 1\n# \t输出 ./zhishu.sh: line 4: [1: command not found\n# \t\t 1是质数\n# 测试：\n# \t输入 7\n# \t输出 ./zhishu.sh: line 7: [1: command not found\n#\t\t./zhishu.sh: line 7: [1: command not found\n#\t\t./zhishu.sh: line 7: [3: command not found\n#\t\t./zhishu.sh: line 7: [2: command not found\n#\t\t./zhishu.sh: line 7: [1: command not found\n#\t\t7是质数\n```\n\n","categories":["Linux"]},{"title":"算法_递归_分治","url":"/算法/算法_递归_分治/","content":"# 内容\n\n# 阶乘(factorial)\n```\n阶乘可递归地定义为:\nfac(n) = \n\t1;                 当n=1时\n\tfac(n-1)*n;        当n>1时\n```\n\n此处, `fac(n-1)`代表什么意思呢? 是: `1 * 2 * ... * (n-1)`\n\n## 代码\n\n非递归版\n\n```c\nint factorial(int n)\n{\n    int res = 1;\n    for(int i = 1; i <= n; ++i)\n    {\n        res = res * i;\n    }\n    return res;\n}\n```\n\n递归版\n\n```c\nint factorial(int n)\n{\n    if(n <= 1)\n        return 1;\n    else\n        return factorial(n - 1) * n;\n}\n```\n\n# 死递归和死循环的区别\n\n## 死循环\n\n若把上面阶乘的代码, 稍做改动:\n\nfor循环中间的条件去掉 - 变为死循环\n\n```c\nint factorial(int n)\n{\n    int res = 1;\n    for(int i = 1;  ; ++i)\n    {\n        res = res * i;\n    }\n    return res;\n}\n```\n\n但是, 死循环除了会耗费单核的CPU, 不会对内存空间产生伤害;\n\n```c\nint main()\n{\n    int sum = fun(4);\n}\n```\n\n## 死递归\n\n若把上面递归版本阶乘的代码, 稍做改动, 把`if`判断条件改为永假:\n\n```c\nint factorial(int n)\n{\n    if(false)\n        return 1;\n    else\n        return factorial(n - 1) * n;\n}\n```\n\n则递归将没有一个出口;\n\n而且更严重的是, 由于每一次的递归调用都需要开辟栈帧, 所以不久之后栈将会溢出, 程序崩溃;\n\n## 思考\n\n就这个现象, 其实说明了背后的一些更重要的意义, 一般, 非递归算法的空间复杂度最低可为O(1), 而递归算法的空间复杂度最低为O(n), 递归的特性势必造成额外的空间;\n\n# 遍历打印数组\n\n假如有一int数组为`{12,23,34}`, 要求打印出来\n\n## 非递归 - 能不能把它改成递归?\n\n```c++\nvoid Print_Ar(const int * ar, int n)\n{\n    assert(ar != NULL);\n    for(int i = 0; i < n; ++i)\n    {\n        cout << ar[i] << \" \";\n    }\n    cout << endl;\n}//12 23 34\n```\n\n## 递归初版 - 逆序\n\n```c++\nvoid Print(const int * ar, int n)\n{\n    if(n > 0)\n    {\n        cout << ar[n-1] << \" \";\n        Print(ar, n-1);\n    }\n}\nvoid Print_Ar_recur(const int * ar, int n)\n{\n    assert(ar != NULL);\n    if(n < 1) return;//the length must > 0\n    Print(ar, n);\n    cout << endl;\n}\nint main()\n{\n    int ar[] = {12, 23, 34};\n    int n = sizeof(ar) / sizeof(ar[0]);\n    Print_Ar_recur(ar, n);\n    return 0;\n}//34 23 12\n```\n\n## 递归2版 - 正序-✔\n\n看到没? 只是把5行和6行的代码调了个序, 效果就截然不同, 这就是递归的神奇之处;\n\n当`n > 0`时, 将一直递归下去, 直到n等于0, 之后, 随着递归栈帧的回退, 将从0到`n-1`逐一打印出来;\n\n```c++\nvoid Print(const int * ar, int n)\n{\n    if(n > 0)\n    {\n        Print(ar, n - 1);\n        cout << ar[n-1] << \" \";\n    }\n}\nvoid Print_Ar_recur(const int * ar, int n)\n{\n    assert(ar != NULL);\n    if(n < 1) return;//the length must > 0\n    Print(ar, n);\n    cout << endl;\n}\nint main()\n{\n    int ar[] = {12, 23, 34};\n    int n = sizeof(ar) / sizeof(ar[0]);\n    Print_Ar_recur(ar, n);\n    return 0;\n}//12 23 34\n```\n\n## 总结 - 递归的范式\n\n递归的题解有两部分组成, 将会把代码划分的清清楚楚;\n\n1. 第一个函数过滤掉不合法的参数, 同时作为开始调用递归的调用者;\n2. 第二个函数才是真正的递归函数;\n\n## 总结 - 递归的分析\n\n递归函数的执行分为“递推”和“回归”两个过程，这两个过程由递归终止条件控制，即逐层递推，直至递归终止条件满足，终止递归，然后逐层回归。\n\n递归调用同普通的函数调用一样，每当调用发生时，就要**分配新的栈帧**（形参数据，现场保护，局部变量）, **所以, 每个栈帧中的数据都是本层独有的!**；\n\n而与普通的函数调用不同的是，由于递推的过程是一个逐层调用的过程，因此存在一个逐层连续的分配栈帧过程，直至遇到递归终止条件时，才开始回归，这时才逐层释放栈帧空间，返回到上一层，直至最后返回到主调函数。\n\n## 错误版本1-不要使用后置自减\n\n这个浅看看不出来, 实际上是一个必死的结局;\n\n这个会导致**栈溢出**;\n\n因为, `n--`会导致每次前一个栈帧给下一个函数传递的是n原本的值, 才去`--`, 这是后置自减的语义, 然后, 就相当于n原地不变, 所以一直到不了栈帧回退的出口;\n\n```c\nvoid Print(const int * br, int n)\n{\n    if(n > 0)\n    {\n        Print(br, n--);\n        cout << br[n - 1] << \" \";\n    }\n}\n```\n\n## 错误版本2-不要使用前置自减\n\n会导致越界, 并且前面多打了一个(`br[-1]`), 后面少打了一个(`br[n-1]`); \n\n因为他把n减1并传过去了, 就缺少了n的情况, 并且, 由于前面做了n值的判断, 而又在if里面改值, 这是不妥的; 即, 最好不要在判断n的合法性后对n进行改动, 这是递归程序的忌讳; \n\n```c\nvoid Print(const int * br, int n)\n{\n    if(n > 0)\n    {\n        Print(br, --n);\n        cout << br[n - 1] << \" \";\n    }\n}// [?随机值] 12 23 [缺34]\n```\n\n但是这种情况, 也可以把程序改正确, 即: 把打印`br[n-1]`改为`br[n]`\n```c\nvoid Print(const int * br, int n)\n{\n    if(n > 0)\n    {\n        Print(br, --n);\n        cout << br[n] << \" \";\n    }\n}// 12 23 34\n```\n\n但还是不建议在递归程序的变量上进行前置自减;\n\n## 错误版本3-引用\n\n```c++\nvoid Print(const int * br, int & n)\n{\n    if(n > 0)\n    {\n        Print(br, --n);\n        cout << br[n] << \" \";\n    }\n}\nvoid Print_Ar_recur(const int * br, int n)\n{\n    assert(br != NULL);\n    if(n < 1)return;//the length must > 0\n    Print(br, n);\n    cout << endl;\n}\n//12 12 12\n```\n\n因为栈帧递进时, 所有栈帧中的n都一直在动态改变, 最终所有栈帧的n值都变为0了, 即**所有的n都保持一致了**,  因此, 打印的都是`br[0]`, 这是引用的影响;\n\n尽量在递归中少用引用，只有在线索二叉树才会用到\n\n# FindPos\n\n传入数据指针, 长度, 和要找到val值, 返回下标\n\n## 非递归版\n\n```c++\nint FindPos(const int * br, int n, int val)\n{\n    if(br == NULL || n < 1)return -1;\n    int pos = n - 1;\n    while(pos >= 0 && br[pos]!=val)\n    {\n        --pos;\n    }\n    return pos;\n}\nint main()\n{\n    int ar[] = {12,56,34,78};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    int val = 78;\n    int pos = FindPos(ar,n,val);\n    cout << pos << endl;\n}\n```\n\n## 递归版本-自己写的初版\n\n```c++\nint Find(const int * br, int n, int val)\n{\n    if(n > 0)\n    {\n        if(br[n - 1] == val) return n - 1;\n        return Find(br, n - 1, val);\n    }\n}\nint FindPos(const int * br, int n, int val)\n{\n    if(br == NULL || n < 1) return -1;\n    return Find(br, n, val);\n}\n```\n\n错误点：如果没有找到val，没有返回值。即, 如果走到`n==-1`, 则没有return的值, 可视为获取到了一个随机值\n\n## 递归版本-正确版本\n\n```c++\n//杨版\nint Find(const int * br, int n, int val)\n{\n    if(n <= 0 || br[n-1] == val)\n    {\n        return n - 1;\n    }\n    else\n    {\n        return Find(br, n - 1, val);\n    }\n}\nint FindPos(const int * br, int n, int val)\n{\n    if(br==NULL || n<1)return -1;\n    return Find(br,n,val);\n}\n```\n\n## 递归版本-标准版本\n\n```c\n//初版和杨版结合、改进\n//杨版\nint Find(const int * br, int n, int val)\n{\n    if(n > 0)\n    {\n        if(br[n-1] == val) return n - 1;\n        else return Find(br, n - 1, val);\n    }\n    return -1;\n}\nint FindPos(const int * br, int n, int val)\n{\n    if(br==NULL || n < 1)return -1;\n    return Find(br, n, val);\n}\n```\n\n# 排序\n\n快排、归并、堆排\n\n## 问题\n\n1. 时间复杂度是多少？\n2. 空间复杂度是多少？\n3. 是否稳定？怎样可以稳定？什么时候需要稳定，什么时候不需要稳定？\n4. 什么情况下性能会退化？\n5. 三个排序的适用场景？\n6. 如果你的排序的递归的，怎么改为非递归？\n\n## 快排\n\n1. 为什么数据有序的时候, 快排时间复杂度为$O(n^2)$?\n   1. 这个仅限于每次只从最边缘数据作为划分, 才出现这种情况\n   2. 每次划分时, 相当于只划分出了一个数据和剩余的数据, 规模并没有有效的减小, 仍需要划分$n$次; 而不是像最好的情况 - 每次正好把数据划分在中间, 规模减小, 此时只需划分$\\log_2n$次; \n   3. 放在二叉树上的形象图示就是: 最差情况下的快排就是一个极端不平衡的二叉树, 最好情况下的快排就是一个很平衡的二叉树;\n\n# 快排\n\n## 划分函数\n\n```c++\nint Partition(int *ar, int left, int right)\n{\n    int tmp = ar[left];\n    while(left < right)\n    {\n        while(left < right && ar[right] > tmp)\n        {\n            --right;\n        }\n        if(left < right) ar[left] = ar[right];\n        while(left < right && ar[right] <= tmp)\n        {\n            ++left;\n        }\n        if(left < right) ar[right] = ar[left];\n    }\n    ar[left] = tmp;\t//最后, left成为中间位置\n    return left;\n}\n```\n\n## 思考 - 为什么一直要强调`left < right`?\n\n因为, 如果不加这种条件的话, left或right可能就会一直贪婪地, 不着边际地走下去, **最终left和right有可能错位**!\n\n如果产生了错位, left的right下标的值相互赋值将没有意义;\n\n反之, 如果很好地控制了left和right的位置, 最终退出整个while循环后, left和right的位置一定指向的是同一个位置; 即, 最后两句的`ar[left] = tmp`和`return left`同样可以换为`ar[right] = tmp`和`return left`!\n\n## 递归函数\n\n```c\nvoid PassQuick(int *ar, int left, int right)\n{\n    if(left < right)\t//如果left == right 相当于只有一个元素, 不需排序\n    {\n        int pos = Partition(ar, left, right);//上一个划分出来的下标\n        \n        PassQuick(ar, left, pos - 1);       //对left ~ pos-1再划分\n        PassQuick(ar, pos + 1, right);      //对pos+1 ~ right再划分\n    }\n}\nvoid QuickSort(int * ar, int n)\n{\n    if(ar == NULL || n < 2)return;\n    PassQuick(ar, 0, n-1);\n}\n```\n\n## 测试\n\n```c\nvoid Print_Ar(const int * ar, int n)\n{\n    if(ar == NULL || n < 1)return;\n    for(int i = 0; i < n; ++i)\n    {\n        cout << ar[i] << \" \";\n    }\n    cout << endl;\n}\nint main()\n{\n    int ar[] = {56, 12, 78, 90, 34, 23, 100, 56, 45, 67, 89};\n    int n = sizeof(ar) / sizeof(ar[0]);\n    Print_Ar(ar, n);\n    QuickSort(ar, n);\n    Print_Ar(ar, n);\n}\n```\n\n同时, 也可以在`PassQuick`函数中`Partition`语句的下一行加个`Print_Ar(ar, 11)`; 这样就能在每次划分完毕之后, 清楚地看到数组的状态;\n\n![image-20220616101832798](../../images/递归&分治/image-20220616101832798.png)\n\n## 非递归 - 使用STL的queue\n\n```cpp\nvoid QuickSort(int * ar, int n)\n{\n    if(ar == NULL || n < 2) return;\n    queue<int> qu;\n    qu.push(0);\n    qu.push(n - 1);\n    while(!qu.empty())\n    {\n        int left = qu.front(); qu.pop();\n        int right = qu.front(); qu.pop();\n        \n        int pos = Partition(ar, left, right);\n        if(left < pos - 1)\n        {\n            qu.push(left);\n            qu.push(pos - 1);\n        }\n        if(pos + 1 < right)\n        {\n            qu.push(pos + 1);\n            qu.push(right);\n        }\n    }\n}\n```\n\n### 使用对儿 - pair\n\n```cpp\nvoid QuickSort(int * ar, int n)\n{\n    if(ar == NULL || n < 2) return;\n    queue<std::pair<int, int>> qu;\n    qu.push(std::pair<int, int>(0, n-1));\n    while(!qu.empty())\n    {\n        std::pair<int, int> record = qu.front(); qu.pop();\n        int pos = Partition(ar, record.first, record.second);\n        if(record.first < pos - 1)\n        {\n            qu.push(std::pair<int, int>(record.first, pos-1));\n        }\n        if(pos + 1 < record.second)\n        {\n            qu.push(std::pair<int, int>(pos+1, record.second));\n        }\n    }\n}\n```\n\n可以使用别名使程序简化 - `using idxPair = std::pair<int, int>`\n\n```cpp\nvoid QuickSort(int * ar, int n)\n{\n    if(ar == NULL || n < 2) return;\n    using idxPair = std::pair<int, int>;\n    \n    queue<idxPair> qu;\n    qu.push(idxPair(0, n-1));\n    while(!qu.empty())\n    {\n        idxPair record = qu.front(); qu.pop();\n        int pos = Partition(ar, record.first, record.second);\n        if(record.first < pos - 1)\n        {\n            qu.push(idxPair(record.first, pos-1));\n        }\n        if(pos + 1 < record.second)\n        {\n            qu.push(idxPair(pos+1, record.second));\n        }\n    }\n}\n```\n\n## 划分函数 - 单向划分 - 特别适于单链表\n\n详见 \"快速排序\" 一文;\n\n# 全排列、子集树\n\n## 全排列\n\n```c++\nvoid Perm(int * ar, int i, int m)\n{\n    if(i == m)\n    {\n        for(int j = 0;j <= m;++j)\n        {\n            cout << ar[j] << \" \";\n        }\n        cout << endl;\n    }\n    else\n    {\n        for(int j = i;j <= m;++j)\n        {\n            std::swap(ar[i],ar[j]);\n            Perm(ar,i+1,m);\n            std::swap(ar[i],ar[j]);\n        }\n    }\n}\nint main()\n{\n    int ar[] = {1,2,3};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    Perm(ar, 0, n-1);\n}\n/*\n1 2 3\n1 3 2\n2 1 3\n2 3 1\n3 2 1\n3 1 2\n*/\n```\n\n![全排列](../../images/递归&分治/全排列.png)\n\n## 子集树\n\n```c++\nvoid fun(int i, int n)\n{\n    if(i >= n)return;\n    else\n    {\n        fun(i+1, n);\n        fun(i+1, n);\n    }\n}\n\n\nvoid Print(int *ar, int * br, int i, int n)\n{\n    if(i >= n)\n    {\n        for(int j = 0;j < n;++j)\n        {\n            if(br[j] == 1)\n            {\n                cout << ar[j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n    else\n    {\n        br[i] = 1;\n        Print(ar, br, i+1, n);\n        br[i] = 0;\n        Print(ar, br, i+1, n);\n    }\n}\nint main()\n{\n    int ar[] = {1,2,3};\n    int br[] = {0,0,0};\n    Print(ar, br, 0, 3);\n    return 0;\n}\n/*\n1 2 3\n1 2\n1 3\n1\n2 3\n2\n3\n*/\n```\n\n","categories":["算法","分治策略"]},{"title":"Cpp_友元","url":"/Cpp/Cpp_友元/","content":"# 特点\n1. 不具有自反性\n2. 不具有传递性\n3. 不具有继承性\n# 三种形式\n1. 外部函数友元\n2. 成员函数友元\n3. 类友元\n## 外部函数友元\n\n## 成员函数友元\n\n```c++\nclass Object\n{\nprivate:\n    int value;\npublic:\n    Object(int x):value(x)\n    {\n        \n    }\n};\nclass Base\n{\nprivate:\n    int sum;\npublic:\n    Base(int x = 0):sum(x)\n    {\n        \n    }\n    void fun(Object& obj)\n    {\n        obj.value = obj.value + sum;//error\n    }\n};\n```\n\n```c++\nclass Object;//在Base前要声明\nclass Base\n{\nprivate:\n    int sum;\npublic:\n    Base(int x = 0):sum(x)\n    {\n        \n    }\n    void fun(Object& obj);\n};\nclass Object\n{\nprivate:\n    int value;\npublic:\n    Object(int x):value(x)\n    {\n        \n    }\n    friend\n};\nvoid Base::fun(Object& obj)\n{\n    obj.value = obj.value + sum;//error\n}\nint main()\n{\n    Base base(10);\n    Object obja(20);\n    base.fun(obja);\n    return 0;\n}\n```\n\n\n\n","categories":["Cpp"]},{"title":"练习_Cpp_20220107","url":"/Cpp/练习_Cpp_20220107/","content":"# 题目\n\n1. 总结const 与指针的关系\n2. 总结const 与引用的关系\n3. 总结this指针\n4. 设计矩形类\n\n   ```c++\n   //left：指定矩形左上角的逻辑X坐标。\n   //top：指定矩形左上角的逻辑Y坐标。\n   //right：指定矩形右下角的逻辑X坐标。\n   //bottom：指定矩形右下角的逻辑Y坐标。\n   class Rectangle \n   {\n   private:\n       int left, top, right, bottom;\n   public:\n       //实现默认构造函数和带参的构造函数\n       //实现Set函数\n       SetLeft;\n       SetTop;\n       SetRight;\n       SetBottom;\n       // 实现Get函数\n       GetLeft;\n       GetTop;\n       GetRight;\n       SetBottom;  \n       void Show() const \n       {\n           cout<<\"left-top point is (\"<<left<<\",\"<<top<<:\")\"<<endl;\n           cout<<\"right-bottom point is (\"<<right<<\",\"<<bottom<<\")\"<<endl;\n       }\n   };\n   ```\n\n5. 实现双向函数\n\n   ```c++\n   class Object\n   {\n   private:\n       int value;\n   public:\n       Object(int x = 0):value(x) {}\n       ~Object() {}\n       void SetValue(int x) {value = x;}\n       int GetValue() {return value;}\n       // 使用一个函数实现 SetValue 和 GetValue() 函数的功能\n   };\n   ```\n\n6. 实现Stack\n\n   ```c++\n   #define SEQ_INIT_SIZE 10\n   #define SEQ_INC_SIZE 2\n   class SeqStack\n   {\n   private:\n       int *base;\n       int *pos;\n       int maxsize;\n   public:\n       SeqStack(int sz = SEQ_INIT_SIZE):maxsize(sz>SEQ_INIT_SIZE? sz:SEQ_INIT_SIZE)\n       {\n           base = pos = (int*)malloc(sizeof(int)*maxsize);\n           if(NULL == base) exit(1);    \n       }\n       //实现函数有：\n       ~SeqStack; // 析构函数\n       Get_Size; // 返回数据的个数\n       Get_Capacity; // 返回容量\n       Is_Empty; // 判空\n       Is_Full; // 判满\n       Push;   // 入栈\n       Pop;   // 出栈\n       Top;   // 取栈顶数据 ，但不出栈   \n   };\n   ```\n\n7. STL string - [std::basic_string - cppreference.com](https://zh.cppreference.com/w/cpp/string/basic_string)\n   1. 预习 STL中的string类型；\n   2. 熟练掌握string类型中的方法。","categories":["Cpp","练习"]},{"title":"Cpp_名字粉碎技术","url":"/Cpp/Cpp_名字粉碎技术/","content":"\n# 以函数的重载引出\n\n众所周知，C中函数不可以重载而C++中可以。\n\n函数的重载指：函数的重载就要看准函数的原型：包括函数返回类型、函数名、形参列表（其中形参名可省略），且不需要函数体。\n\n例：\n\n```c++\n\n```\n\n# 2","categories":["Cpp"]},{"title":"md语法积累","url":"/一些工具的使用/md语法积累/","content":"# 内容\n\n1. latex语法\n2. md语法\n\n# latex语法\n\n## 符号\n\n### 运算符\n\n| 含义                        | 语法  | 效果  |\n| --------------------------- | ----- | ----- |\n| 大于等于(greater equal, ge) | `\\ge` | $\\ge$ |\n| 小于等于(less equal, le)    | `\\le` | $\\le$ |\n| 不等于(not equal, ne)       | `\\ne` | $\\ne$ |\n\n| 含义            | 语法                | 效果                |\n| --------------- | ------------------- | ------------------- |\n| 向上取整(ceil)  | `\\lceil x \\rceil`   | $\\lceil x \\rceil$   |\n| 向下取整(floor) | `\\lfloor x \\rfloor` | $\\lfloor x \\rfloor$ |\n\n### 箭头\n\n更多箭头参考：https://www.sascha-frank.com/Arrow/latex-arrows.html\n\n| 含义   | 语法                                                       | 效果                                                       |\n| ------ | ---------------------------------------------------------- | ---------------------------------------------------------- |\n| 等效于 | `\\Leftrightarrow`、`\\leftrightarrow`、`\\rightleftharpoons` | $\\Leftrightarrow$、$\\leftrightarrow$、$\\rightleftharpoons$ |\n| 可推出 | ` \\Rightarrow`、`\\rightarrow`、`\\longrightarrow`           | $ \\Rightarrow$、$\\rightarrow$、$\\longrightarrow$           |\n\n### 波浪线\n\n由于latex中`~`符号有特殊用途（强制空格）， 因此需要用其他方式才能打出。\n\n方式1：一般文字环境下，`\\textasciitilde`。效果：$\\textasciitilde$\n\n方式2：公式环境下，`\\sim`。效果：$\\sim$\n\n区别：用公式环境下打出，波浪线会大一些。\n\n## 对数\n\n1. `\\log_2 ...` => $\\log_2(n+1)$\n2. `\\ln ...` => $\\ln(n+1)$\n3. `\\lg ...` => $\\lg(n+1)$\n\n## 多行公式\n\n### 左对齐\n\n```\n证明：设完全二叉树的高度为$h$，则有\n$$\n\\begin{flalign}\n&~~~~~~2^h-1<n\\le2^{h+1}-1\\\\\n&\\Leftrightarrow 2^h<n+1\\le2^{h+1}\\\\\n取对数&\\Leftrightarrow h<\\log_2(n+1)\\le h+1&\n\\end{flalign}\n$$\n```\n\n#### 要点\n\n1. 开头独行，`\\begin{flalign}`；结尾独行，`\\end{flalign}`\n2. **公式换行符：`\\\\`**\n\n#### 左对齐效果\n\n证明：设完全二叉树的高度为$h$，则有\n$$\n\\begin{flalign}\n&~~~~~~2^h-1<n\\le2^{h+1}-1\\\\\n&\\Leftrightarrow 2^h<n+1\\le2^{h+1}\\\\\n取对数&\\Leftrightarrow h<\\log_2(n+1)\\le h+1&\n\\end{flalign}\n$$","categories":["一些工具的使用"]},{"title":"生产者消费者","url":"/多线程/生产者消费者/","content":"# 简单的模型 - 产1消1\n基于互斥量、条件变量以及全局标志。\n\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\n#include<semaphore.h>\nusing namespace std;\nmutex mtx;\ncondition_variable cv;\nint number = 0;\nbool full = false;\n\nvoid produce()\n{\n    unique_lock<mutex> locker(mtx);\n    for(int i = 0; i < 10; ++i)\n    {\n        while(full)\n        {\n            cv.wait(locker);\n        }\n        number = i;\n        full = true;\n        cout << this_thread::get_id() << \"produce: \" << number << endl;\n        cv.notify_all();\n    }\n}\nvoid consume()\n{\n    unique_lock<mutex> locker(mtx);\n    for(int i = 0; i < 10; ++i)\n    {\n        while(!full)\n        {\n            cv.wait(locker);\n        }\n        cout << this_thread::get_id() << \"consume: \" << number << endl;\n        full = false;\n        cv.notify_all();\n    }\n}\nint main()\n{\n    thread producer1(produce);\n    thread producer2(produce);\n    thread producer3(produce);\n    thread consumer1(consume);\n    thread consumer2(consume);\n    thread consumer3(consume);\n    producer1.join();\n    producer2.join();\n    producer3.join();\n    consumer1.join();\n    consumer2.join();\n    consumer3.join();\n}\n```\n\n```\n139780600784640produce: 0\n139780592391936consume: 0\n139780609177344produce: 0\n139780575606528consume: 0\n139780617570048produce: 0\n139780575606528consume: 0\n139780600784640produce: 1\n139780592391936consume: 1\n139780617570048produce: 1\n139780592391936consume: 1\n139780617570048produce: 2\n139780592391936consume: 2\n139780617570048produce: 3\n139780592391936consume: 3\n139780617570048produce: 4\n139780592391936consume: 4\n139780617570048produce: 5\n139780592391936consume: 5\n139780617570048produce: 6\n139780592391936consume: 6\n139780617570048produce: 7\n139780592391936consume: 7\n139780617570048produce: 8\n139780592391936consume: 8\n139780600784640produce: 2\n139780583999232consume: 2\n139780609177344produce: 1\n139780583999232consume: 1\n139780609177344produce: 2\n139780583999232consume: 2\n139780600784640produce: 3\n139780583999232consume: 3\n139780600784640produce: 4\n139780583999232consume: 4\n139780609177344produce: 3\n139780575606528consume: 3\n139780600784640produce: 5\n139780583999232consume: 5\n139780600784640produce: 6\n139780575606528consume: 6\n139780600784640produce: 7\n139780583999232consume: 7\n139780600784640produce: 8\n139780575606528consume: 8\n139780600784640produce: 9\n139780583999232consume: 9\n139780609177344produce: 4\n139780575606528consume: 4\n139780609177344produce: 5\n139780575606528consume: 5\n139780609177344produce: 6\n139780583999232consume: 6\n139780609177344produce: 7\n139780575606528consume: 7\n139780609177344produce: 8\n139780583999232consume: 8\n139780609177344produce: 9\n139780575606528consume: 9\n139780617570048produce: 9\n139780575606528consume: 9\n```\n\n# 循环队列+信号量\n\n# 图示\n\n![image-20211224144301657](../../images/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/image-20211224144301657.png)\n\n# 线程不安全代码\n这是线程不安全的版本。\n\n```c++\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<semaphore>\ntemplate<class Type>\nclass Queue\n{\nprivate:\n    Queue(const Queue&) = delete;\n    Queue& operator=(const Queue&) = delete;\npublic:\n    Queue(int sz = 8) :data(NULL), maxsize(sz), front(0), tail(0), cursize(0)\n    {\n        data = (Type*)malloc(sizeof(Type) * maxsize);\n        if (NULL == data) exit(1);\n    }\n    ~Queue()\n    {\n        free(data);\n        data = NULL;\n        maxsize = cursize = front = tail = 0;\n    }\n    int Cursize() const { return cursize; }\n    bool IsEmpty() const { return cursize == 0; }\n    int MaxSize() const { return maxsize; }\n    bool IsFull() const { return cursize == maxsize; }\n    Type& Front() { return data[front]; }\n    const Type& Front() const { return data[front]; }\n    Type& Back() { return data[tail]; }\n    const Type& Back() const { return data[tail]; }\n\n    bool Push(const Type& x)\n    {\n        if (IsFull()) return false;\n        data[tail] = x;\n        cursize += 1;\n        tail = (tail + 1) % maxsize;   // 确保了取值范围在 0 ~ 7\n        return true;\n    }\n    bool Pop()\n    {\n        if (IsEmpty()) return false;\n        front = (front + 1) % maxsize; // 确保了取值范围在 0 ~ 7\n        cursize -= 1;\n        return true;\n    }\n\nprivate:\n    Type* data;\n    int maxsize;\n    // 队头\n    int front;\n    // 队尾\n    int tail;\n    int cursize;\n    mutable std::mutex mtx;\n};\nconstinit int product_num = 100;\nconstinit int n = 8;\nQueue<int> qu(n);\nstd::counting_semaphore produce_sema(8); // 生产者信号量\nstd::counting_semaphore consume_sema(0); // 消费者信号量\n// 下载器\nvoid produce()\n{\n    for (int i = 0; i < product_num; ++i)\n    {\n        produce_sema.acquire();\n        std::cout << \"producer: \" << i << std::endl;\n        qu.Push(i);\n        consume_sema.release();\n    }\n}\n// 播放器\nvoid consume()\n{\n    for (int i = 0; i < product_num; ++i)\n    {\n        consume_sema.acquire();\n        std::cout << \"consumer: \" << qu.Front() << std::endl;\n        qu.Pop();\n        produce_sema.release();\n    }\n}\nint main()\n{\n    std::thread produce_th(produce);\n    std::thread consume_th(consume);\n\n    produce_th.join();\n    consume_th.join();\n}\n```\n结果\n\n```\nproducer: 0\nproducer: 1\nproducer: 2\nproducer: 3\nconsumer: 0\nconsumer: 1\nconsumer: 2\nconsumer: 3\nproducer: 4\nproducer: 5\nproducer: 6\nproducer: 7consumer: 4\nconsumer: 5\nconsumer: 6\n\nproducer: 8\nproducer: 9\nproducer: 10\nproducer: 11\nproducer: 12\nproducer: 13\nproducer: 14\nconsumer: 7\nconsumer: 8\nconsumer: 9\nconsumer: 10\nconsumer: 11\nconsumer: 12\nconsumer: 13\nconsumer: 14\nproducer: 15\nproducer: 16\nproducer: 17\nproducer: 18\nproducer: 19\nproducer: 20\nconsumer: 15\nconsumer: 16\nconsumer: 17\nconsumer: 18\nconsumer: 19\nconsumer: 20\nproducer: 21\nproducer: 22\nproducer: 23\nproducer: 24\nconsumer: 21\nconsumer: 22\nconsumer: 23\nconsumer: 24\nproducer: 25\nproducer: 26\nproducer: 27\nconsumer: 25\nconsumer: 26\nconsumer: 27\nproducer: 28\nproducer: 29\nproducer: 30\nproducer: 31\nproducer: 32\nproducer: 33\nproducer: 34\nproducer: 35\nconsumer: 28\nconsumer: 29\nconsumer: 30\nconsumer: 31\nconsumer: 32\nconsumer: 33\nproducer: 36\nproducer: 37\nproducer: 38\nproducer: 39\nconsumer: 34\nconsumer: 35\nconsumer: 36\nconsumer: 37\nconsumer: 38\nconsumer: 39\nproducer: 40\nproducer: 41\nproducer: 42\nproducer: 43\nproducer: 44\nproducer: 45\nproducer: 46\nproducer: 47\nconsumer: 40\nconsumer: 41\nconsumer: 42\nconsumer: 43\nconsumer: 44\nconsumer: 45\nconsumer: 46\nproducer: 48\nproducer: 49\nproducer: 50\nproducer: 51\nproducer: 52\nproducer: 53\nconsumer: 47\nconsumer: 48\nconsumer: 49\nproducer: 54\nproducer: 55\nproducer: 56\nproducer: 57\nconsumer: 50\nconsumer: producer: 58\n51\nconsumer: 52\nconsumer: 53\nproducer: 59\nproducer: 60\nproducer: 61\nconsumer: 54\nconsumer: 55\nconsumer: 56\nconsumer: 57\nconsumer: 58\nconsumer: 59\nconsumer: 60\nconsumer: 61\nproducer: 62\nproducer: 63\nproducer: 64\nconsumer: 62\nconsumer: 63\nconsumer: 64\nproducer: 65\nproducer: 66\nproducer: 67\nproducer: 68\nproducer: 69\nproducer: 70\nproducer: 71\nproducer: 72\nconsumer: 65\nconsumer: producer: 73\n66\nconsumer: 67\nconsumer: 68\nconsumer: 69\nconsumer: 70\nconsumer: 71\nconsumer: 72\nconsumer: 73\nproducer: 74\nproducer: 75\nproducer: 76\nproducer: 77\nproducer: 78\nproducer: 79\nproducer: 80\nproducer: 81\nconsumer: 74\nconsumer: 75\nconsumer: 76\nconsumer: 77\nconsumer: 78\nconsumer: 79\nconsumer: 80\nconsumer: 81\nproducer: 82\nproducer: 83\nproducer: 84\nproducer: 85\nproducer: 86\nproducer: 87\nproducer: 88\nproducer: 89\nconsumer: 82\nconsumer: 83\nconsumer: 84\nconsumer: 85\nconsumer: 86\nconsumer: 87\nconsumer: 88\nconsumer: 89\nproducer: 90\nproducer: 91\nproducer: 92\nproducer: 93\nproducer: 94\nproducer: 95\nproducer: 96\nproducer: 97\nconsumer: 90\nconsumer: 91\nconsumer: 92\nconsumer: 93\nconsumer: 94\nconsumer: 95\nconsumer: 96\nconsumer: 97\nproducer: 98\nproducer: 99\nconsumer: 98\nconsumer: 99\n\n```\n# 加mutex代码\n```cpp\n#include<iostream>\n#include<thread>\n#include<mutex>\n#include<semaphore>\n#include<print>\ntemplate<class Type>\nclass Queue\n{\nprivate:\n    Queue(const Queue&) = delete;\n    Queue& operator=(const Queue&) = delete;\npublic:\n    Queue(int sz = 8) :data(NULL), maxsize(sz), front(0), tail(0), cursize(0)\n    {\n        data = (Type*)malloc(sizeof(Type) * maxsize);\n        if (NULL == data) exit(1);\n    }\n    ~Queue()\n    {\n        free(data);\n        data = NULL;\n        maxsize = cursize = front = tail = 0;\n    }\n    int Cursize() const \n    {\n        std::lock_guard<std::mutex> lock(mtx);\n        return cursize;\n    }\n    bool IsEmpty() const\n    {\n        return Cursize() == 0;\n    }\n    int MaxSize() const\n    {\n        return maxsize;\n    }\n    bool IsFull() const\n    {\n        return Cursize() == maxsize;\n    }\n    Type& Front()\n    {\n        std::lock_guard<std::mutex> lock(mtx);\n        return data[front];\n    }\n    const Type& Front() const\n    {\n        std::lock_guard<std::mutex> lock(mtx);\n        return data[front];\n    }\n    Type& Back()\n    {\n        std::lock_guard<std::mutex> lock(mtx);\n        return data[tail];\n    }\n    const Type& Back() const\n    {\n        std::lock_guard<std::mutex> lock(mtx);\n        return data[tail];\n    }\n\n    bool Push(const Type& x)\n    {\n        if (IsFull()) return false;\n        std::lock_guard<std::mutex> lock(mtx);\n        data[tail] = x;\n        cursize += 1;\n        tail = (tail + 1) % maxsize;   // 确保了取值范围在 0 ~ 7\n        return true;\n    }\n    bool Pop()\n    {\n        if (IsEmpty()) return false;\n        std::lock_guard<std::mutex> lock(mtx);\n        front = (front + 1) % maxsize; // 确保了取值范围在 0 ~ 7\n        cursize -= 1;\n        return true;\n    }\n\nprivate:\n    Type* data;\n    int maxsize;\n    // 队头\n    int front;\n    // 队尾\n    int tail;\n    int cursize;\n    mutable std::mutex mtx;\n};\nconstinit int product_num = 100;\nconstinit int n = 8;\nQueue<int> qu(n);\nstd::counting_semaphore produce_sema(8); // 生产者信号量\nstd::counting_semaphore consume_sema(0); // 消费者信号量\n// 下载器\nvoid produce()\n{\n    for (int i = 0; i < product_num; ++i)\n    {\n        produce_sema.acquire();\n        std::println(\"{} {}\", \"producer:\", i);\n        qu.Push(i);\n        consume_sema.release();\n    }\n}\n// 播放器\nvoid consume()\n{\n    for (int i = 0; i < product_num; ++i)\n    {\n        consume_sema.acquire();\n        std::println(\"{} {}\", \"consumer:\", qu.Front());\n        qu.Pop();\n        produce_sema.release();\n    }\n}\nint main()\n{\n    std::thread produce_th(produce);\n    std::thread consume_th(consume);\n\n    produce_th.join();\n    consume_th.join();\n}\n```\n结果：\n```\nproducer: 0\nproducer: 1\nproducer: 2\nproducer: 3\nproducer: 4\nconsumer: 0\nconsumer: 1\nconsumer: 2\nproducer: 5\nproducer: 6\nproducer: 7\nproducer: 8\nconsumer: 3\nproducer: 9\nproducer: 10\nproducer: 11\nconsumer: 4\nconsumer: 5\nconsumer: 6\nproducer: 12\nconsumer: 7\nconsumer: 8\nconsumer: 9\nconsumer: 10\nconsumer: 11\nproducer: 13\nproducer: 14\nconsumer: 12\nconsumer: 13\nproducer: 15\nconsumer: 14\nconsumer: 15\nproducer: 16\nproducer: 17\nproducer: 18\nproducer: 19\nconsumer: 16\nproducer: 20\nproducer: 21\nproducer: 22\nproducer: 23\nproducer: 24\nconsumer: 17\nconsumer: 18\nconsumer: 19\nproducer: 25\nproducer: 26\nproducer: 27\nconsumer: 20\nconsumer: 21\nproducer: 28\nconsumer: 22\nconsumer: 23\nproducer: 29\nproducer: 30\nconsumer: 24\nconsumer: 25\nconsumer: 26\nconsumer: 27\nproducer: 31\nproducer: 32\nconsumer: 28\nproducer: 33\nproducer: 34\nproducer: 35\nproducer: 36\nconsumer: 29\nconsumer: 30\nconsumer: 31\nproducer: 37\nproducer: 38\nconsumer: 32\nconsumer: 33\nconsumer: 34\nconsumer: 35\nconsumer: 36\nproducer: 39\nproducer: 40\nconsumer: 37\nconsumer: 38\nconsumer: 39\nconsumer: 40\nproducer: 41\nproducer: 42\nproducer: 43\nconsumer: 41\nconsumer: 42\nconsumer: 43\nproducer: 44\nproducer: 45\nproducer: 46\nproducer: 47\nconsumer: 44\nproducer: 48\nproducer: 49\nconsumer: 45\nconsumer: 46\nproducer: 50\nconsumer: 47\nconsumer: 48\nconsumer: 49\nconsumer: 50\nproducer: 51\nproducer: 52\nproducer: 53\nproducer: 54\nconsumer: 51\nconsumer: 52\nconsumer: 53\nconsumer: 54\nproducer: 55\nproducer: 56\nproducer: 57\nproducer: 58\nproducer: 59\nproducer: 60\nconsumer: 55\nproducer: 61\nconsumer: 56\nproducer: 62\nconsumer: 57\nconsumer: 58\nproducer: 63\nproducer: 64\nconsumer: 59\nconsumer: 60\nconsumer: 61\nconsumer: 62\nconsumer: 63\nproducer: 65\nconsumer: 64\nproducer: 66\nproducer: 67\nproducer: 68\nconsumer: 65\nconsumer: 66\nconsumer: 67\nconsumer: 68\nproducer: 69\nproducer: 70\nproducer: 71\nproducer: 72\nproducer: 73\nproducer: 74\nproducer: 75\nconsumer: 69\nconsumer: 70\nconsumer: 71\nconsumer: 72\nconsumer: 73\nproducer: 76\nproducer: 77\nconsumer: 74\nconsumer: 75\nconsumer: 76\nproducer: 78\nproducer: 79\nproducer: 80\nconsumer: 77\nconsumer: 78\nconsumer: 79\nconsumer: 80\nproducer: 81\nproducer: 82\nconsumer: 81\nconsumer: 82\nproducer: 83\nproducer: 84\nproducer: 85\nproducer: 86\nconsumer: 83\nproducer: 87\nproducer: 88\nconsumer: 84\nproducer: 89\nproducer: 90\nproducer: 91\nproducer: 92\nconsumer: 85\nconsumer: 86\nconsumer: 87\nproducer: 93\nproducer: 94\nproducer: 95\nconsumer: 88\nconsumer: 89\nconsumer: 90\nconsumer: 91\nproducer: 96\nproducer: 97\nproducer: 98\nconsumer: 92\nconsumer: 93\nproducer: 99\nconsumer: 94\nconsumer: 95\nconsumer: 96\nconsumer: 97\nconsumer: 98\nconsumer: 99\n\n```\n# 无锁队列\n\n共有三个线程：观察者线程（调度线程）、生产者线程、消费者线程。\n\n共有三个队列。\n\n生产者给第一个队列生产数据，若生产完毕或这个队列已满，生产者通知观察者。观察者则调度队列，把存放数据的队列移交到消费者端，把第二个队列（空队列）给生产者，再继续生产。若第二个队列也满了，也移交给消费者端，把第三个队列（空队列）给生产者。如此，消费者消费的过程中，生产者仍可以不断生产，直到没有空的队列。\n\n相应地，只要有空的队列或已使用过的队列，则移交给生产者端。（把队列入队，有点像二维队列的感觉）\n\n这个模型中，控制线程起关键桥梁作用，通知线程间信息交流。\n\n其次，这个模型的好处在于，相比简单的生产者消费者模型，不是单纯地对同一个缓冲区容器进行读写。可以进行分库、分表，还可把读写操作分开（根据模式进行轮换），粒度变细，提高并发性能。\n## 下去查资料\n\n1. 总线锁的汇编实现\n2. 缓冲锁的汇编实现","categories":["操作系统","多线程","Cpp","Modern","设计模式"]},{"title":"Linux_网络","url":"/Linux/Linux_网络/","content":"# 内容\n\n1. 基本概念\n2. 了解接口socket\n3. 了解协议tcp/udp\n4. io复用\n5. select\n6. poll/epoll\n\n# 分层模型\n\nOSI：七层\nTCP/IP协议族：四层\n## 问题\n\n1. 为什么要分层？\n    1. 解耦，分工。\n2. 网络：\n3. 互联网：网络和网络连接起来，就是互联网\n4. ipv4：是32位的，用“.”分成4个段，每个段是8位。每个段用1个10进制表示。\n5. ipv6：是128位的，用“:”分成8个段，每个段是16位。每个段用4个16进制表示。\n6. MAC地址：物理地址，又称硬件地址。\n7. 有了MAC地址，为什么还要有ip地址？寻址！\n8. 端口号：软件层次的概念。因为最终要达到进程的通信。\n9. 协议：\n    1. tcp\n    2. http\n    3. ip\n    4. udp\n# TCP编程流程\n\n面试唯一要写代码的。\n\n1. 服务器端：\n    1. 创建套接字socket()\n        1. 所需地址：ip+port\n    2. bind()\n    3. listen()\n    4. c = accept()\n    5. recv()\n    6. send()\n    7. close()\n2. 客户端：\n    1. socket()\n    2. connect()\n    3. send()\n    4. recv()\n    5. close()\n# TCP\n\n特点：\n1. 面向连接的\n    1. 三次握手--在客户端connect()时\n        1. 必须是三次\n    2. 四次挥手--在任一方close时\n        1. 有时可以三次\n2. 可靠的\n    1. 应答确认\n    2. 超时重传\n    3. 乱序重排\n    4. 去重\n    5. 滑动窗口进行流量控制\n3. 流式服务\n    1. 发送和接收的次数可能不一致。\n        1. 连续多次发送的数据可能会被对方一次性收到。\n            1. 起始末尾加标记\n            2. send之后recv隔开\n4. tcp是有状态的\n    1. 开始closed\n    2. listen--connecting(三次握手中)\n    3. established(已完成握手)\n    4. FIN_WAIT_1/2\n    5. TIME_WAIT\n        1. 可靠地终止TCP的连接\n        2. 让迟来的报文在这一段时间被识别，即收集后丢弃，以防止误传给下一个使用该端口的连接。\n\n问题：1、TCP/IP协议详解 卷一；2、UNIX网络编程 卷一\n\n1. 三次握手，四次挥手\n2. 应答确认、超时重传机制\n3. 乱序重排、去重、滑动窗口进行流量控制\n4. 什么是粘包？怎么解决？\n5. 中间转换状态的意义？TIME_WAIT状态的意义？\n# UDP\n\n特点：\n1. 无连接的\n    1. 没有严格意义上的服务端/客户端，只要知道ip:port就可以给对方sendto发消息。recvfrom谁的消息都可以收到，也可以收到不同终端的消息。\n2. 不可靠的\n    1. 没有应答确认机制，发出后是否成功看天意。\n3. 数据报服务\n    1. 如果send了很多信息，recv一次没收完，则剩下的数据丢包。\n    2. UDP的send和recv也有缓冲区，但是其与收发的动作是一个整体，对应着发送/接收的那一次。\n4. 无状态的\n# UDP编程流程\n\n在UDP场景中，其实没有严格意义上的服务端/客户端。因为编程流程很相似。\n\n## 服务端\n\nsocket()\nbind()\nrecvfrom()\nsendto()\nclose()\n## 客户端\n\nsocket()\n【bind()：可以绑定也可以不绑定】\nrecvfrom()\nsendto()\nclose()\n## 与tcp的区别\n\n1. 创建socket时的第二个参数TCP中是SOCK_STREAM，UDP中是SOCK_DGRAM(指datagrams)\n\n```c\nint sockfd = socket(AF_INET,SOCK_DGRAM,0);\n```\n2. recvfrom中多了两个参数，前四个参数与TCP一致，后面一个传入**要接收哪个主机的sockaddr类型的指针**，最后是传入这个**sockaddr对象的长度的指针**。为什么要传指针？因为UDP中某一端接收的数据可以来自不同主机，所以传入指针是要实时的记录谁在给接收端发数据。\n3. 同样的，sendto也多了两个参数，后面一个传入**要发送到哪个的主机的sockaddr类型的指针**（参数类型为`const struct sockaddr* dest_addr`），最后传入**这个`sockaddr`对象的长度大小，通常用`sizeof`计算**。相对于`recvfrom`，**为什么不传`非const指针`了**？因为：要么是服务端，`sendto`的目的主机已经在`recvfrom`收到客户端消息后明确；要么是客户端要`sendto`的目的主机已经很明确地指定。\n## 一个端口在开启TCP服务的同时，也可以开启UDP服务\n\n我们常说：一个端口标识一个进程，但是对于不同的协议，两个进程居然可以绑定到同一端口！但是，知道为什么能这样做，再去想，这句话还是没毛病的。\n\n只有一个端口，如何能够区分不同协议？这个区分工作通常是在应用层完成的。比如，一个进程是TCP服务端，另一个进程的UDP服务端。UDP报文过来了，该给谁；下一刻TCP数据过来了再给谁。端口虽然不能区分不同协议的数据报，但是我们最终都要把该数据包传到某个进程中去！**两个进程同时监听到了端口的数据传来，此时这个数据报头已经加了其协议头，进程在去解析协议头时就清楚了该不该继续接收这个数据报**，这样就自然的完成了对不同协议的区分。即：在应用层，每个连接就需要按照五元组来区分：{协议，源ip，源port，目的ip，目的port}。即使不区分，按照SOCK_STREAM或SOCK_DGRAM，报文类型不一样，根本就不适配，所以两者使用的端口在应用层来说是独立的。\n# http\n\n1. 浏览器解析到IP后，端口约定为80，connect三次握手建立TCP连接。\n2. 浏览器给服务器发送http请求报文。浏览器send\n3. 服务器给浏览器回复应答报文。浏览器recv\n4. 如果2、3步只发生一次，为短连接。发生了两次以上，则为长连接，之后不会很快断开。如此可以避免握手、挥手浪费的时间。\n# I/O复用\n\n1. select\n2. poll\n3. epoll\n## select\n\n先观察其API\n\n```c\n#include<sys/select.h>\nint select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);\n```\n\n1. 参数\n    1. nfds参数通常被设置为select监听的所有文件描述符中的最大值加1，表示在fd_set集合中，我们关心的描述符的总数。为什么加1呢？因为文件描述符是从0开始计数的。nfds与fd_set容量大小不一样，容量大小指的是FD_SETSIZE，即fd_set容量大小是fd_set可容纳描述符的最大大小。\n    2. readfds参数是select关心的读事件的集合；\n    3. writefds参数是select关心的写事件的集合；\n    4. exceptfds参数select关心的异常事件的集合；\n    5. timeout参数设置select的超时时间。\n2. 返回值\n    1. 集合中有事件就绪的描述符的个数\n    2. 但是并没有告诉你具体是哪一个描述符就绪\n### fd_set结构体\n\n```c\n#include<typesizes.h>\n#define __FD_SETSIZE 1024\n\n#include<sys/select.h>\n#define FD_SETSIZE __FD_SETSIZE\ntypedef long int __fd_mask;\n#undef __NFDBITS\n#define __NFDBITS (8*(int)sizeof(__fd_mask))\ntypedef struct\n{\n#ifdef __USE_XOPEN\n    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];\n#define __FDS_BITS(set) ((set)->fds_bits)\n#else\n    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];\n#define __FDS_BITS(set) ((set)->__fds_bits)\n#endif\n}fd_set;\n```\n\n其中，__FD_SETSIZE指出select可以关注的最大文件描述符个数，默认为1024。\n\n__fd_mask被定义为long int的类型别称，long int在32位机占8个字节。\n\n\\_\\_NFDBITS计算的是1个\\_\\_fd\\_mask元素所占用的位数，一个字节占8位，sizeof算出\\_\\_fd_mask的字节数，相乘得其占用的bit大小。\n\n接着，定义fds_bits，其是long int型的数组，数组大小为\\_\\_FD\\_SETSIZE除以\\_\\_NFDBITS。比如SETSIZE为1024位，NFDBITS是64位，则数组大小位1024/64=16。这里的计算主要是为了计算出数组的大小，以确定多大的数组可以正好容纳1024个位数，来记录文件描述符信息。\n### 用到的宏函数\n\nfd_set集合对于文件描述符的管理是按位进行的，而位只有0和1两种状态。\n\n假如SETSIZE=1024，则可管理1024个文件描述符，如果文件描述符7有效，我们需要对位操作，使其位变为1。\n\n由于位操作过于繁琐，select API中提供了一系列宏函数来方便我们访问、操作fd_set集合状态。\n\n```c\n#include<sys/select.h>\nFD_ZERO(fd_set *fdset);\t\t\t\t/*清除fdset的所有位*/\nFD_SET(int fd, fd_set *fdset);\t\t/*设置fdset的位fd*/\nFD_CLR(int fd, fd_set *fdset);\t\t/*清除fdset的位fd*/\nint FD_ISSET(int fd, fd_set *fdset);/*测试fdset的位fd是否被设置*/\n```\n### select编程思路\n\n最好另外定义一个整型数组，其大小为我们预测将要出现的描述符的最多数目。用作我们存放描述符的容器。初始化时将数组值一律设为-1，表示容器中该位置还没有存放描述符。如果在某一时刻有一个描述符有了消息，我们就将该描述符数值覆盖到这个容器中第一个为-1的地方。\n\n```c\n#define MAX 10\nvoid fds_init(int fds[])\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        fds[i] = -1;\n    }\n}\nvoid fds_add(int fd, int fds[])//向fds容器中添加描述符fd\n{\n    if(fd<0)\n    {\n        printf(\"无效的描述符\\n\");\n        return;\n    }\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i]==-1)\n        {\n            fds[i] = fd;\n            return;\n        }\n    }\n    printf(\"容器已满，无法添加该描述符\\n\");\n}\nvoid fds_del(int fd, int fds[])\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i]==fd)\n        {\n            fds[i] = -1;\n            return;\n        }\n    }\n    printf(\"没有找到该描述符\\n\");\n}\nint main()\n{\n    int fds[MAX];\n    fds_init(fds);\n}\n```\n#### 示例--TCP服务使用select处理多个套接字\n\n```c\nint main()\n{\n    int sockfd = socket_init();//socket_init封装了bind(ip:port)的操作，还封装了对sockfd进行listen的操作，并设置了监听队列大小。\n    assert(sockfd!=-1);\n    \n    int fds[MAX];\n    fds_init(fds);\n    \n    fds_add(sockfd, fds);\n    \n    fd_set fdset;//此处的fd_set即<sys/select.h>库中API提供的fd_set结构体\n    while(1)//将fds[MAX]中所有有效的(即>=0)描述符全部“加入”fdset中，即把fdset中与某有效描述符对应的[位]的状态设为1。\n    {\n        FD_ZERO(&fdset);\n        int maxfd = -1;//记录当前最大的描述符数值是多少，方便过后调用select传入第一个参数nfds。\n        for(int i = 0;i<MAX;++i)\n        {\n            if(fds[i]==-1)continue;\n            FD_SET(fds[i],fdset);\n            if(maxfd<fds[i])//寻找最大描述符数值\n            {\n                maxfd = fds[i];\n            }\n        }\n    \t//此时，我们已经把开始创建的sockfd添加到了fdset中。下面就可以用select来监测该套接字是否有消息了。比如，sockfd监听到了客户端的connect信息，则select就可以探测到fdset中对应的sockfd位处于消息就绪态，则select就可以不再阻塞，立马返回。\n        struct timeval tv = {5,0};\n        int n = select(maxfd+1,&fdset,NULL,NULL,&tv);//返回在fdset集合中有信息的描述符的个数。\n        if(n<0)printf(\"select err\\n\");\n        else if(n == 0)printf(\"time out\\n\");\n        else\n        {\n            for(int i = 0;i<MAX;++i)//依然需要根据fdset进行查询目前是哪个描述符有事件产生，fdset的过滤又需要根据fds的记录进行遍历。\n            {\n                if(fds[i]==-1)continue;\n                if(FD_ISSET(fds[i],&fdset))//此处判断ISSET即是判断我们关注的描述符是否有事件产生。为什么此时标志位为1一定有事件产生？--因为在这之前我们进行了select，select不仅说明有事件产生，它还做了更多的工作：将我们关心的描述符却在其上没有事件产生的标志位置0。因此目前所有标志位为1的描述符均有事件。\n                {\n                    //以下才是核心的业务代码，抓住了有事件产生的描述符，对这些描述符我们的处理流程，对于不同类型的描述符，需要不同的处理流程。比如sockfd用accept处理，accept返回一个新的描述符c，则先将其加入fds容器，下一轮再用recv处理描述符c的消息。\n                    if(fds[i] == sockfd)//处理监听套接字sockfd\n                    {\n                        struct sockaddr_in caddr;\n                        int len = sizeof(caddr);\n                        int c = accept(sockfd,(struct sockaddr*)&caddr,&len);\n                        if(c<0)continue;\n                        printf(\"accept c = %d\\n\",c);\n                        fds_add(c,fds);//只是先收集到fds容器中，下一次的while扫描才将c添加到fdset集合中。\n                    }\n                    else//处理收发套接字，在此程序，除了sockfd皆为收发套接字c\n                    {\n                        char buff[128] = {0};\n                        int num = recv(fds[i],buff,127,0);\n                        if(num <= 0)\n                        {\n                            printf(\"client close\\n\");\n                            close(fds[i]);\n                            fds_del(fds[i],fds);\n                        }\n                        else//num > 0，读到了数据\n                        {\n                            printf(\"recv(c = %d) = %s\\n\",fds[i],buff);\n                            send(fds[i],\"ok\",2,0);\n                        }\n                    }\n                }\n            }\n        }\n    }//while end\n}\n```\n\n场景情况：如果客户端与select服务端已建立连接，而客户端进程结束，select会一直阻塞、未感知吗？--不会。\n\n因为客户端的进程结束，也算是一种读事件，相当于通知服务端该套接字连接结束了。那么服务端recv会返回0，达到关闭该套接字的条件，关闭后，别忘了在fds容器中删除掉该描述符。\n\n如果忘记了close该套接字，且忘了fds_del该描述符，那么如果客户端结束进程，服务端就会一直打印\"client close\"，因为select一直在探测此描述符有无读事件，若该套接字连接关闭，那么此描述符一直有读事件，recv返回0，由于没有fds_del，每次都会关注，所以每次都会打印\"client close\"。\n## poll\n\n可以理解为加强版的select。\n\n先观察其API\n\n```c\n#include<poll.h>\nint poll(struct pollfd* fds, nfds_t nfds, int timeout);\n```\n\n1. fds参数是一个pollfd结构类型的指针，可指向一段连续空间（数组），因此很灵活，大小可按需声明。它可以指定我们感兴趣的文件描述符上发生的可读、可写和异常等事件。定义如下\n\n```c\nstruct pollfd\n{\n    int fd;\t\t\t//文件描述符\n    short events;\t//注册的事件类型，按位标志\n    short revents;\t//实际发生的事件，按位标志，由内核填充\n};\n```\n\n   1. 其中，fd成员指定文件描述符。\n   2. events成员告诉poll监听fd上的哪些事件类型，他可以是一系列事件类型的**按位或**。常见的事件类型有：POLLIN(数据可读)、POLLOUT(数据可写)。\n   3. revents成员由内核修改，以通知应用程序fd上实际发生了哪些事件。\n### poll编程\n\n```c\nvoid poll_fds_init(struct pollfd* fds)\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        fds[i].fd = -1;\n        fds[i].events = 0;\n        fds[i].revents = 0;\n    }\n}\nvoid poll_fds_add(int fd, struct pollfd* fds)\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i].fd == -1)\n        {\n            fds[i].fd = fd;\n            fds[i].events = POLLIN;//只关注读事件\n            fds[i].revents = 0;\n            break;\n        }\n    }\n}\nvoid poll_fds_del(int fd, struct pollfd* fds)\n{\n    for(int i = 0;i<MAX;++i)\n    {\n        if(fds[i].fd == fd)\n        {\n            fds[i].fd = -1;\n            fds[i].events = 0;\n            fds[i].revents = 0;\n            break;\n        }\n    }\n}\n#define MAX 10\nint main()\n{\n    int sockfd = socket_init();\n    assert(sockfd != -1);\n    struct pollfd poll_fds[MAX];\n    poll_fds_init(poll_fds);\n    poll_fds_add(sockfd,poll_fds);\n    while(1)\n    {\n        int n = poll(poll_fds,MAX,5000);//5000ms timeout \n        if(n < 0)printf(\"poll error\\n\");\n        else if(n == 0)printf(\"time out \\n\");\n        else\n        {\n            for(int i = 0;i<MAX;++i)\n            {\n                if(poll_fds[i].fd == -1)continue;\n                //short has 16bits,POLLIN is 10000000 ...,\n                //when revents is 10000000 ...,then the read event is going\n                if(poll_fds[i].revents & POLLIN)//revents & POLLIN 不为0 则代表有读事件产生\n                {\n                    if(poll_fds[i].fd == sockfd)\n                    {\n                        struct sockaddr_in caddr;\n                        int len = sizeof(caddr);\n                        int c = accept(sockfd,(struct sockaddr*)&caddr,&len);\n                        if(c<0)continue;\n                        printf(\"accept:%d\\n\",c);\n                        poll_fds_add(c,poll_fds);\n                    }\n                    else\n                    {\n                        char buff[128] = {0};\n                        int num = recv(poll_fds[i].fd,buff,127,0);\n                        if(num <=0)\n                        {\n                            close(poll_fds[i].fd);\n                            poll_fds_del(poll_fds[i].fd,poll_fds);\n                            printf(\"client close\\n\");\n                        }\n                        else\n                        {\n                            printf(\"recv(%d):%s\\n\",poll_fds[i].fd,buff);\n                            send(poll_fds[i].fd,\"ok\",2,0);\n                        }\n                    }\n\n                }\n                if(poll_fds[i].revents & POLLOUT)\n                {\n\t\t\t\t\t//...\n                }\n            }\n        }\n    }    \n}\n```\n\n与select的一处细节区别：\n\n每次select除了监测fd_set有效描述符上有无事件，其次还将没有事件的描述符从fd_set移除（其实是将该描述符对应在fd_set上的位进行置0操作）（**这样就得每次select之前都要重新注册一遍我们关注的描述符（即用户和内核共同操作FD_SET、FD_CLR等）。**），然后下面过滤有事件的描述符时，只要找到fd_set集合哪个位是1状态即就找到了有事件产生的描述符。\n\n而poll的用法是：用户只管注册events，实际上的有无事件**由内核来进行对revents的填充**，以此来更好地区别该描述符是否有事件产生。**这样，就不用在每次poll之前重新注册一遍我们关注的描述符的结构体里的events了**。我们只要把要关心的描述符的fd置成非-1，以及管理好要关心的哪些事件类型events即可。\n### 与select相比的优点\n\n1. 可以监听的描述符的最大数目可以超过1024个，大小按需自拟。\n2. 可以监听的事件类型数目变多、变细了，更强大了。\n3. **不用**在每次poll之前**重新注册**一遍我们关注的描述符的结构体里的events了\n## epoll\n\nepoll是Linux特有的I/O复用函数。\n\nepoll的使用实际上不是单独的API，而是有一组函数来完成。三个函数：\n\n```c\n#include<sys/epoll.h>\nint epoll_create(int size);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n```\n\n### 内核事件表\n\nepoll的最大优势在于处理描述符特别多的情况，相比轮询方式：\n\n1. 如果用传统的select、poll单纯的顺序轮询方法监测就绪的描述符，那么性能会很低下的。\n2. 而且虽然select、poll能顺利查出有几个描述符上有事件产生，但是是哪个描述符？并没有告诉我们，所以又得浪费一轮时间来查找产生时间是哪个描述符。","categories":["Linux","网络"]},{"title":"Cpp_智能指针","url":"/Cpp/Cpp_智能指针/","content":"`C++`中的智能指针定义于`<memory>`中。\n# 内容\n1. RAII\n2. auto_ptr\n3. unique_ptr\n4. shared_ptr\n5. weak_ptr\n# RAII\n\n堆上空间进行自动化管理，利用对象自动析构的机制。\n\n# auto_ptr\n这是旧版本的智能指针，在`C++11`之后被废弃。\n\n1. 不能使用同一个裸指针赋值/初始化多个`auto_ptr`。\n2. 拷贝构造和等号运算符，会将源智能指针置空。\n3. release(): 返回当前指向的地址（存到tmp中），并将当前智能指针置空\n4. reset(): 将当前智能指针指向的内存释放，指针置空。\n\n## 问题\n\n### 拷贝构造函数意义不明确\n1. 如果拷贝构造按浅拷贝形式进行，则会导致重复析构，崩溃。\n2. 如果拷贝构造按**转移资源**进行，则会导致意想不到的严重后果：如以下代码，在调用fun函数按值传入`my_auto_ptr`对象时，调用拷贝构造，拷贝构造释放自己的拥有权，给了apx。在fun函数外再找原指针时，原对象的指针信息已丢失。\n\n```c++\nclass my_auto_ptr\n{\npublic:\n    my_auto_ptr(const my_auto_ptr& op)\n        : _Owns(op._Owns), _Ptr(op.release())\n    {\n    }\n    \n    _Ty* release() const\n    {\n        _Ty* tmp = NULL;\n        if (_Owns)\n        {\n            _Owns = false;\n            tmp = _Ptr;\n            _Ptr = NULL;\n        }\n        return tmp;\n    }\n};\n    void fun(my_auto_ptr<Object> apx)\n    {\n        int x = apx->Value();\n        cout << x << endl;\n    }\nint main()\n{\n    my_auto_ptr<Object> pobja(new Object(10));\n    fun(pobja);\n    int a = pobja->Value();//error!\n    cout << a << endl;\n}\n```\n### 赋值重载意义不明确\n```c++\nclass my_auto_ptr\n{\npublic:\n    my_auto_ptr & operator=(const my_auto_ptr& _Y)\n    {\n        if(this == & _Y)return *this;\n        if(_Owns){delete _Ptr;}\n        _Owns = _Y._Owns;\n        _Ptr = _Y.release();\n    }\n    _Ty* release() const\n    {\n\t\t_Ty* tmp = NULL;\n\t\tif (_Owns)\n\t\t{\n\t\t\t_Owns = false;\n\t\t\ttmp = _Ptr;\n\t\t\t_Ptr = NULL;\n\t\t}\n\t\treturn tmp;\n    }\n};\nvoid fun(my_auto_ptr<Object> apx)\n{\n    int x = apx->Value();\n    cout << x << endl;\n}\nint main()\n{\n    my_auto_ptr<Object> pobja(new Object(10));\n    fun(pobja);\n    int a = pobja->Value();//error!\n    cout << a << endl;\n}\n```\n# unique_ptr\n以下是传统的不使用智能指针的写法。\n```cpp\n#include <iostream>\n#include <memory>\nclass Test\n{\npublic:\n    Test(void)\n    {\n        std::cout << \"Test()\" << std::endl;\n    }\n    ~Test()\n    {\n        std::cout << \"~Test()\" << std::endl;\n    }\n    void show(void) const\n    {\n        std::cout << \"show()\" << std::endl;\n    }\n};\nvoid foo()\n{\n    Test * test = new Test;\n    test->show();\n    delete test;\n    test = nullptr;\n}\nint main()\n{\n    foo();\n    return 0;\n}\n```\n如今不推荐这么写了，\n如何实现让test对象一出foo函数就自动析构呃呢？使用智能指针解决。\n```cpp\nvoid foo()\n{\n    std::unique_ptr<Test> test{ new Test };\n    test->show();\n    // 不用释放了，不用置空了。\n}\n```\n用智能指针管理时，就不用手动释放new出来的Test对象了，因为智能指针是在栈上建立的，函数调用结束后栈帧析构时，智能指针就会自动析构，从而把绑定的对象也析构。\n## 特性：unique\n\n1. 把拷贝构造函数禁用了。\n2. 如果想要迁移原智能指针，可以用move\n```cpp\nvoid foo()\n{\n    std::unique_ptr<Test> test{ new Test };\n    std::unique_ptr<Test> test2 = std::move(test);\n    if (test)\n        test->show();\n    if (test2)\n        test2->show();\n}\n```\n# 方法\n智能指针对象的`->`对应的是其持有对象的方法。\n`.`出来的方法才是其本身拥有的方法。\n## release（不析构旧对象）\n```cpp\npointer release() noexcept;\n```\n释放管理权，返回其持有对象的指针。\n智能指针不再管理该对象，程序员需要自己处理析构。\n```c++\nclass Test\n{\npublic:\n    Test(void)\n    {\n        std::cout << \"Test()\" << std::endl;\n    }\n    ~Test()\n    {\n        std::cout << \"~Test()\" << std::endl;\n    }\n    void show(void) const\n    {\n        std::cout << \"show()\" << std::endl;\n    }\nprivate:\n    int         _v{ 5 };\n};\nvoid foo()\n{\n    std::unique_ptr<Test> test{ new Test };\n    Test* raw_ptr = test.release();\n    if (test)\n        test->show();\n    delete raw_ptr;\n    raw_ptr = nullptr;\n}\nint main()\n{\n    foo();\n    return 0;\n}\n```\n## reset（会析构旧对象）\n\n接收一个同类对象的指针，或nullptr。\n\n原本的智能指针不再指向旧的对象地址，转而指向新的对象地址。\n\n1. 如果旧对象没有其他智能指针引用，则析构旧对象\n2. 指向新对象或nullptr\n```cpp\nvoid foo()\n{\n    std::unique_ptr<Test> test{ new Test };\n    test.reset(new Test);\n    if (test)\n        test->show();\n}\n```\n# 自实现\n```cpp\ntemplate <typename T>\nclass SmartPtr\n{\npublic:\n    SmartPtr(nullptr_t) : _t{ nullptr } {}\n    SmartPtr(void) : _t{ nullptr } {}\n    SmartPtr(T* t) : _t{ t } {}\n    ~SmartPtr()\n    {\n        if (_t)\n        {\n            delete _t;\n            _t = nullptr\n        }\n    }\n    \nprivate:\n    T*           _t;\n};\nint main()\n{\n    SmartPtr test{ new Test };\n}\n```\n## 处理对象数组\n用模板特化。\n```cpp\ntemplate <typename T>\nclass SmartPtr<T[]>\n{\npublic:\n    SmartPtr(T* t) : _t{ t } {}\n    ~SmartPtr()\n    {\n        if (_t)\n        {\n            delete [] _t;\n            _t = nullptr;\n        }\n    }\n    // ...\nprivate:\n    // ...\n};\nvoid foo()\n{\n    SmartPtr<Test[]> test{ new Test[5] };\n}\n```\n## `->`重载\n1. `->`的重载比较有意思，我们想要实现的效果是`smartPtr->objFunc()`，而`->`先返回的是`obj*`，本来应该还需要一个`->`才正确，但系统默认一个`->`就懂你的意思。\n```c++\ntemplate <typename T>\nclass SmartPtr\n{\npublic:\n    // ...\n    T* operator-> (void)\n    {\n        return _t;\n    }\nprivate:\n    // ...\n};\n```\n## `bool运算符`重载\n```cpp\ntemplate <typename T>\nclass SmartPtr\n{\npublic:\n    // ...\n    operator bool(void)\n    {\n        return _t;\n    }\nprivate:\n    // ...\n};\nvoid foo()\n{\n    SmartPtr<Test> test{ new Test };\n    if (test)\n        test->show();\n}\n```\n## unique的转移\n1. 禁用拷贝构造\n2. 提供右值引用拷贝构造\n3. 实现一个release方法，在右值引用拷贝构造中复用\n```cpp\ntemplate <typename T>\nclass SmartPtr\n{\npublic:\n    // ...\n    SmartPtr(SmartPtr const&) = delete;\n    SmartPtr(SmartPtr && other) noexcept\n    {\n        _t = other.release();\n    }\n    T* release()\n    {\n        auto t = _t;\n        _t = nullptr;\n        return t;\n    }\nprivate:\n    // ...\n};\nvoid foo()\n{\n    SmartPtr<Test> test{ new Test };\n    SmartPtr<Test> test2 = std::move(test);\n    \n    if (test)\n        test->show();\n    if (test2)\n        test2->show();\n}\n```\n\n# shared_ptr\n多个智能指针共享一个对象。\n\n支持拷贝构造。\n\n某个`shared_ptr`析构时，所持有的对象不会析构，直到此对象没有其他`shared_ptr`引用。这是用内部依赖的引用计数机制实现的。\n\n![](../../images/Cpp_智能指针/image-20240722042455549.png)\n## 两种构建方式\n\n```c++\nint main()\n{\n    std::shared_ptr<Object> op1(new Object(10));\n    std::shared_ptr<Object> op2(std::make_shared<Object>(10));\n}\n```\n\n## 方法\n没有release，只有reset。\n可以通过`reset(nullptr)`或`reset()`达到release的效果。\n### use_count\n```cpp\nvoid foo()\n{\n    std::shared_ptr<Test> test(new Test);\n    std::cout << test.use_count() << std::endl;\n}\n```\n### owner_before\n```cpp\nvoid foo()\n{\n    std::shared_ptr<Test> test(new Test);\n    std::shared_ptr<Test> test2 = test;\n    test.reset();\n    bool is_true = test.owner_before(test2); // true\n    is_true = test2.owner_before(test);      // false\n}\n```\n对被reset的对象test来说，判断是不是之前test2所持对象的拥有者。\n要想返回true需要满足：\n1. test已经被reset\n2. 指定的智能指针确实是test之前指向的对象\n```cpp\nvoid foo()\n{\n    std::shared_ptr<Test> test(new Test);\n    std::shared_ptr<Test> test2 = test;\n    // test.reset();\n    bool is_true = test.owner_before(test2); // false\n}\n```\n## 应用场景\n返回一个指针时。即，用于函数间传递指针。\n省去了程序员去判断何时需要析构的难题。\n```cpp\nstd::shared_ptr<Test> foo()\n{\n    std::shared_ptr<Test> test(new Test);\n    test->show();\n    return test;\n}\nint main()\n{\n    std::shared_ptr<Test> test = foo();\n    if (test)\n        test->show();\n    return 0;\n}\n```\n# weak_ptr\n```cpp\nclass B; // incomplete class\nclass A\n{\npublic:\n    A(void)\n    {\n        std::cout << \"A()\" << std::endl;\n    }\n    ~A()\n    {\n        std::cout << \"~A()\" << std::endl;\n    }\n    void set_b(std::shared_ptr<B> b)\n    {\n        _b = b;\n    }\nprivate:\n    std::shared_ptr<B> _b;\n};\nclass B\n{\npublic:\n    B(void)\n    {\n        std::cout << \"B()\" << std::endl;\n    }\n    ~B()\n    {\n        std::cout << \"~B()\" << std::endl;\n    }\n    void set_a(std::shared_ptr<A> a)\n    {\n        _a = a;\n    }\nprivate:\n    std::shared_ptr<A> _a;\n};\nvoid bar()\n{\n    std::shared_ptr<A> a(new A);\n    std::shared_ptr<B> b(new B);\n    a->set_b(b);\n    b->set_a(a);\n}\nint main()\n{\n    bar();\n    return 0;\n}\n```\n上面程序将输出：\n```\nA()\nB()\n```\n意味着A、B对象在最后没有被析构，造成内存泄漏。\n\n本身a、b是一个引用计数。\n又因为两个类内部都存在另一个类对象的`shared_ptr`指针，那么a、b的引用计数又会各自加1变成2。\nbar函数调用结束后智能指针a、b析构，但引用计数只减1，无法归零，都在等对方先析构，形成了僵局。\n因此当多方内部可能存在交叉、互相引用对方的`shared_ptr`时，需要改其为一种不会增加引用计数的特殊指针。则`weak_ptr`应运而生。\n```cpp\nvoid bar()\n{\n    // std::weak_ptr<A> a(new A); // error, weak_ptr不能直接管理对象。\n    std::shared_ptr<A> a(new A);\n    std::weak_ptr<A> w_a = a;\n    std::cout << a.use_count << std::endl; // 1\n    std::cout << w_a.count << std::endl; // 1\n}\n```\n`weak_ptr`不能直接管理对象。而是可以通过一个已经存在的`shared_ptr`赋值。\n\n此时`weak_ptr`作为一个观察者。不能直接引用对象。\n想调用的时候，通过以下方法：\n## 方法\n1. expired用于判断此`weak_ptr`是否过期了。\n2. lock用于把`weak_ptr`升级为一个`shared_ptr`。lock锁定是为了防止在提升等级的期间指针过期，但是取出来之后仍有可能过期，因此需要先if判断取出的指针是否为空。\n3. 也可以直接lock，但是expired比lock代价小，通过先判断是否过期从而可能省略代价大的lock。\n\n```cpp\nvoid bar()\n{\n    std::shared_ptr<A> a(new A);\n    std::weak_ptr<A> w_a = a;\n    if(!w_a.expired())\n    {\n        if(std::shared_ptr<A> a2 = w_a.lock())\n        {\n            a2->show();\n        }\n    }\n}\n```\n## A、B正确的定义\n只需要一方的内部的`shared_ptr`降级定义为`weak_ptr`即可解决僵局。\n以下，将B内部的引用A的智能指针成员变量改为弱指针。\n```cpp\nclass B; // incomplete class\nclass A\n{\npublic:\n    A(void)\n    {\n        std::cout << \"A()\" << std::endl;\n    }\n    ~A()\n    {\n        std::cout << \"~A()\" << std::endl;\n    }\n    void show() const\n    {\n        std::cout << \"A::show()\" << std::endl;\n    }\n    void set_b(std::shared_ptr<B> b)\n    {\n        _b = b;\n    }\n    // 由于B只在上面声明，因此不能在此定义有关B的函数，而是单独定义。\n    void show_b() const;\nprivate:\n    std::shared_ptr<B> _b;\n};\nclass B\n{\npublic:\n    B(void)\n    {\n        std::cout << \"B()\" << std::endl;\n    }\n    ~B()\n    {\n        std::cout << \"~B()\" << std::endl;\n    }\n    void show() const\n    {\n        std::cout << \"B::show()\" << std::endl;\n    }\n    void set_a(std::shared_ptr<A> a)\n    {\n        _a = a;\n    }\n    void show_a() const\n    {\n        if(!_a.expired())\n        {\n            if(auto a = _a.lock())\n            {\n                a->show();\n            }\n        }\n    }\nprivate:\n    std::weak_ptr<A> _a;\n};\n\nvoid A::show_b() const\n{\n    if (_b)\n    {\n        _b->show();\n    }\n}\n\nvoid bar()\n{\n    std::shared_ptr<A> a(new A);\n    std::shared_ptr<B> b(new B);\n    a->set_b(b);\n    b->set_a(a);\n\n    a->show_b();\n    b->show_a();\n}\nint main()\n{\n    bar();\n    return 0;\n}\n```\n正确的输出：\n```\nA()\nB()\nB::show()\nA::show()\n~A()\n~B()\n```","categories":["Cpp"]},{"title":"指导_学习计划_1127","url":"/计算机知识体系/指导_学习计划_1127/","content":"# 内容\n\n1. C++高质量编程\n2. 迭代器、类型的萃取、如何进行对象的构建和释放、对象空间的问题（内存池）如谷歌的Tmalloc（多线程）\n# 继承\n\n子赋给父。需要是公有继承。","categories":["计算机知识体系"]},{"title":"Cpp_泛型算法_函数对象","url":"/Cpp/Cpp_泛型算法_函数对象/","content":"# 内容\n\n1. 泛型算法\n    1. copy\n    2. find\n    3. sort\n    4. find_if\n2. 函数对象\n    1. less\n    2. greater\n    3. binder1st\n    4. binder2nd","categories":["Cpp"]},{"title":"Linux_线程","url":"/Linux/Linux_线程/","content":"# 与进程的区别\n\n1. 进程：一个正在运行的程序，是资源分配的最小单位。\n2. 线程：进程内部的一条执行路径，是执行任务的最小单位。\n\n# 为什么需要线程\n\n1. 程序需要同时做多个事情\n2. 充分利用多处理器（多核）\n\n# 示例\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\nint my_global;\nvoid * my_thread_handle(void * arg)\n{\n    int val;\n    val = *((int*)arg);\n    printf(\"new thread begin, got arg, val = %d\\n\", val);\n    my_global += val;\n    sleep(3);\n    pthread_exit(&my_global);\n    printf(\"new thread end\\n\");\n}\nint main()\n{\n    pthread_t mythread;\n    int arg;\n    void *thread_return_val;\n    arg = 100;\n    my_global = 1000;\n    printf(\"my_global = %d\\n\", my_global);\n    printf(\"ready create thread...\\n\");\n    int error = pthread_create(&mythread, NULL, my_thread_handle, &arg);\n    if (error)\n    {\n        printf(\"create thread failed!\\n\");\n        exit(1);\n    }\n    printf(\"wait thread finished...\\n\");\n    error = pthread_join(mythread, &thread_return_val);\n    if (error)\n    {\n        printf(\"pthread_join failed!\\n\");\n        exit(1);\n    }\n    printf(\"got return val, %d\\n\", *((int*)thread_return_val));\n    printf(\"my_global = %d\\n\", my_global);\n}\n```\n输出结果：\n```\nmy_global = 1000\nready create thread...\nwait thread finished...\nnew thread begin, got arg, val = 100\ngot return val, 1100\nmy_global = 1100\n```\n# API\n需包含头文件`<pthread.h>`\n编译链接时需带选项`-lpthread`\n## `pthread_create`\n\n\n```c\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);\n```\n\n\n参数：\n1. thread，指向新线程的标识符（需要传入已经定义好的`pthread_t`指针）\n2. attr，用来设置新线程的属性。一般用默认属性NULL\n3. `start_routine`，该线程的处理函数指针，返回类型、参数类型都是`void*`\n4. arg，传给处理函数的参数。\n\n返回值：\n如果成功，将返回 0；如果出错，将返回一个错误号，并且`*thread`的内容未定义。\n## `pthread_exit`\n\n```c\nvoid pthread_exit(void *retval);\n```\n\n在线程函数内部调用该函数，用于给外部写值。\n\n## `pthread_join`\n```c\nint pthread_join(pthread_t thread, void **retval);\n```\n等待指定的线程结束。\n\n参数：\n1. thread，指定等待的线程\n2. retval，指向该线程函数的返回值。线程函数的返回值类型是`void*`，所以该参数的类型为`void**`\n\n如果成功，将返回 0；如果出错，将返回一个错误号\n\n\n# 同步\n安装posix手册：\n```sh\nsudo apt install manpages-posix-dev\n```\n\nC语言中，关于同步提供的四个方法：\n1. 信号量\n2. 互斥锁\n3. 条件变量\n4. 读写锁\n\n信号量、互斥量用于解决多个线程对临界区的竞态问题。\n如果只允许一个线程进入临界区则用互斥量；\n如果要求多个线程的执行顺序满足某个约束，用信号量。\n## 信号量\n此时所指的“信号量”是指用于同一个进程内多个线程之间的信号量。\n即POSIX信号量，面不是System V信号量（用于进程之间的同步）\n\n用于线程的信号量的原理，与用于进程的信号量的原理相同。都有P、V操作。\n### API\n需要包含头文件`<semaphore.h>`\n\n信号量的表示\n```c\nsem_t\n```\n信号量的初始化\n```c\nint sem_init(sem_t *sem, int pshared, unsigned int value);\n```\n参数：\n1. sem，信号量的指针\n2. pshared，0 表示该信号量不被其他进程共享；1 表示可被其他进程共享。\n3. value，信号量的初值\n\n成功时返回 0；在错误时返回 -1，并设置 errno 来指示错误。\n\n---\n\n信号量的P操作。想要取得访问权，对信号量减1。\n```c\nint sem_wait(sem_t *sem);\n```\n信号量的V操作。想要让渡访问权，对信号量加1。\n```c\nint sem_post(sem_t *sem);\n```\n\n---\n信号量的析构\n```c\nint sem_destroy(sem_t *sem);\n```\n### 示例\n```c\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <semaphore.h>\n#include <string.h>\n#define BUFF_SIZE 80\nchar buff[BUFF_SIZE];\nsem_t sem;\nstatic void * str_thread_handle(void* arg)\n{\n    while(1)\n    {\n        if (sem_wait(&sem) != 0)\n        {\n            printf(\"sem wait failed!\\n\");\n            exit(1);\n        }\n        printf (\"string is: %s, len = %d\\n\", buff, strlen(buff));\n    }\n}\nint main()\n{\n    int error;\n    pthread_t str_thread;\n    void * thread_return_val;\n\n    error = sem_init(&sem, 0, 0);\n    if (error != 0)\n    {\n        printf(\"sem init failed!\\n\");\n        exit(1);\n    }\n    error = pthread_create(&str_thread, NULL, str_thread_handle, 0);\n    if (error != 0)\n    {\n        printf(\"pthread create failed!\\n\");\n        exit(1);\n    }\n    while (1)\n    {\n        fgets(buff, sizeof(buff), stdin);\n        error = sem_post(&sem);\n        if (error != 0)\n        {\n            printf(\"sem post failed!\\n\");\n            exit(1);\n        }\n        if (strncmp(buff, \"end\", 3) == 0)\n        {\n            break;\n        }\n    }\n    error = pthread_join(str_thread, &thread_return_val);\n    if (error != 0)\n    {\n        printf(\"pthread join failed!\\n\");\n        exit(1);\n    }\n    error = sem_destroy(&sem);\n    if (error != 0)\n    {\n        printf(\"sem_destroy failed!\\n\");\n        exit(1);\n    }\n}\n```\n结果\n```\n123（用户输入）\nstring is: 123\n, len = 4\n3（用户输入）\nstring is: 3\n, len = 2\n```\n\n## 互斥量\n效果上等同于初值为1的信号量。\n\n（UNIX环境高级编程 第3版 中文版）为了避免多个线程同时对某公共数据操作时产生冲突，可以使用pthread的互斥接口来保护数据，**确保同一时间只有一个线程访问数据**。\n\n互斥量(mutex)本质上来说是一把锁，利用互斥量，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量，即可达到线程同步。\n\n对互斥量加锁后，其他线程再次对mutex进行lock操作时会被**阻塞**，直到锁被释放。\n\n> 如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成**可运行状态**，只有第一个变为运行态的线程可以拿到锁进行加锁，其他线程会看到互斥量依然是锁着的，只能回去再次等待锁重新变为可用。在这种方式下，每次只有一个线程可以向前执行。\n\n### API\n```c\npthread_mutex_t\n```\n\n```c\n#include<pthread.h>\n/* 函数的返回值：若成功返回0；否则返回错误编号 */\nint pthread_mutex_init(pthread_mutex_t *restrict mutex,\n                       const pthread_mutexattr_t *restrict attr);\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n```\n\n关于restrict关键字，请移步C/C++语言分栏。\n\n要用默认的属性初始化互斥量，只需把attr设为NULL。\n\n---\n\n```c\n#include<pthread.h>\n/* 函数的返回值：若成功返回0；否则返回错误编号 */\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n\n如果线程不希望被阻塞，可以使用`pthread_mutex_trylock`尝试对互斥量进行加锁。\n如果调用`pthread_mutex_trylock`时互斥量处于未锁状态，那么将锁住互斥量，返回0；否则就不能锁住互斥量，返回`EBUSY`。\n\n### 避免死锁\n\n如果线程试图对同一个互斥量加锁两次（拿到锁之后再加锁），那么它自身就会陷入死锁状态。\n\n```c\npthread_mutex_t lock;\nvoid * fun(void *arg)\n{\n    pthread_mutex_lock(&lock);\n    pthread_mutex_lock(&lock);\t//死锁\n    //... \n}\nint main()\n{\n    int res = pthread_mutex_init(&lock, NULL);\n    if(res != 0)// 0 is success, or failed.\n    {\n        exit(1);\n    }\n    // ... initialization mutex\n    \n    pthread_t tid1;\n    res = pthread_create(&tid1, NULL, fun, NULL);\n    if(res != 0)exit(1);\n    \n    res = pthread_join(tid1, NULL);\t//第二个参数用于接收线程的返回值，不感兴趣可以设置为NULL\n    if(res != 0)exit(1);\n    \n    return 0;\n}\n```\n\n还有其他方式也能产生死锁，例如，程序中使用一个以上的互斥量时，如果线程1一直占有互斥量1，它要进行下一步的条件是占有互斥量2，而互斥量2一直被线程2占有，线程2下一步的条件是占用互斥量1。即**两个线程都在互相请求另一个线程拥有的资源**。\n\n可以通过仔细控制互斥量加锁的顺序来避免死锁的发生，例如，假设需要对两个互斥量A和B同时加锁。\n\n如果所有线程总是在对互斥量B加锁之前能够锁住互斥量A，那么使用这两个互斥量就不会产生死锁。类似地，如果所有的线程总是在锁住互斥量A之前能够锁住互斥量B，那么也不会发生死锁。\n\n可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的互斥量。\n\n有时候，应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构，可用的函数并不能把它转换成简单的层次，那么就需要采用另外的方法。在这种情况下，B可以先释放占有的锁（因为A可能需要B占有的锁），然后过一段时间再试。\n\n## 条件变量\n\n条件变量是线程可用的另一种同步机制。\n\n**条件变量给多个线程提供了一个回合的场所**。\n\n**条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生**。\n\n条件本身是由互斥量保护的。**线程在改变条件状态之前必须首先锁住互斥量**。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。\n\n\n---\n### API\n```c\npthread_cond_t\n```\n\n```c\n#include<pthread.h>\n/* 函数的返回值：若成功，返回0；否则，返回错误编号 */\nint pthread_cond_init(pthread_cond_t *restrict cond,\n                      const pthread_condattr_t *restrict attr);\nint pthread_cond_destroy(pthread_cond_t *cond);\n```\n\n在使用条件变量之前，必须先对它进行初始化。\n\n在释放条件变量底层的内存空间之前，可以使用`pthread_cond_destroy`函数对条件变量进行析构。\n\n---\n\n```c\n#include<pthread.h>\n/* 函数的返回值：若成功，返回0；否则，返回错误编号 */\nint pthread_cond_wait(pthread_cond_t *restrict cond,\n                      pthread_mutex_t *restrict mutex);\nint pthread_cond_timedwait(pthread_cond_t *restrict cond,\n                           pthread_mutex_t *restrict mutex,\n                           const struct timespec *restrict tsptr);\n```\n\n我们使用`pthread_cond_wait`等待条件变量变为真。如果在给定的时间内条件不能满足，那么会返回一个错误码。\n\n传递给`pthread_cond_wait`的**互斥量对条件进行保护**。调用者把锁住的互斥量传给函数，**函数然后自动把调用线程放到等待条件的线程列表**上，**对互斥量解锁**。这就**关闭了条件检查**和**线程进入休眠状态等待条件改变**这两个操作**之间的时间通道**，这样线程就不会错过条件的任何变化。`pthread_cond_wait`返回时，互斥量再次被锁住。\n\n> pthread_cond_timedwait函数多了一个超时参数`tsptr`。超时值指定了我们愿意等待多长时间，它是通过`timespec`结构指定的。需要指定愿意等待多长时间，这个时间值是一个**绝对数**而不是相对数。例如，假设愿意等待3分钟。那么，并不是把3分钟转换成`timespec`结构，而是需要把当前时间加上3分钟再转换成timespec结构。\n\n>如果超时到期时条件还是没有出现，`pthread_cond_timewait`将重新获取互斥量，然后返回错误`ETIMEDOUT`。\n\n>从`pthread_cond_wait`或者`pthread_cond_timedwait`调用成功返回时，线程需要重新计算条件，因为另一个线程可能已经在运行并改变了条件。\n\n> 可以使用`clock_gettime`函数获取timespec结构表示的当前时间。但是目前并不是所有的平台都支持这个函数，因此，也可以用另一个函数`gettimeofday`获取`timeval`结构表示的当前时间，然后把这个时间转换成`timespec`结构。\n\n---\n\n有两个函数可以用于通知线程条件已经满足。`pthread_cond_signal`函数至少能唤醒一个等待该条件的线程，而`pthread_cond_broadcast`函数则能唤醒等待该条件的所有线程。\n\n> POSIX规范为了简化`thread_cond_signal`的实现，允许他在实现的时候唤醒一个以上的线程。\n\n```c\n#include<pthread.h>\n/* 函数的返回值：若成功，返回0；否则，返回错误编号 */\nint pthread_cond_signal(pthread_cond_t * cond);\nint pthread_cond_broadcast(pthread_cond_t * cond);\n```\n\n在调用`pthread_cond_signal`或者`pthread_cond_broadcast`时，我们说这是在给线程或者条件发信号。必须注意，一定要在改变条件状态以后再给线程发信号。\n\n条件是工作队列的状态。我们用互斥量保护条件，在while循环中判断条件。把消息放到工作队列时，需要占有互斥量，但在给等待线程发信号时，不需要占有互斥量（但最好还是占有，详见[《Cpp_线程库》一篇中的《注意事项》一节](Cpp_线程库.md#注意事项)。只要线程在调用`pthread_cond_signal`之前把消息从队列中拖出了，就可以在释放互斥量以后完成这部分工作。因为我们是在while循环中检查条件，所以不存在这样的问题：线程醒来，发现队列仍为空，然后返回继续等待。如果代码不能容忍这种竞争，就需要在给线程发信号的时候占有互斥量。\n\n## 读写锁（共享互斥锁）\n\n读写锁和互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么是未锁状态，而且一次只有一个线程可以对其加锁。\n\n读写锁有3种状态：**读模式下加锁状态**，**写模式下加锁状态**，**不加锁状态**。**一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁**。写与写、读都会冲突，读与读不冲突。\n\n>1. 当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞；\n>2. 当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。\n>3. 虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。\n\n读写锁也叫做共享互斥锁(shared-exclusive lock)。**当读模式锁住时，相当于是以共享模式锁住的。当写模式锁住时，是以互斥模式锁住的**。\n\n### API\n\n```c\n#include<pthread.h>\n/* 函数的返回值：若成功，返回0；否则，返回错误编号 */\nint pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,\n                        pthread_rwlockattr_t *restrict attr);\nint pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n```\n\n在释放读写锁占用的内存之前，需要调用pthread\\_rwlock\\_destroy做清理工作。如果pthread\\_rwlock\\_init为读写锁分配了资源，pthread\\_rwlock\\_destroy将释放这些资源。\n\n**如果在调用pthread\\_rwlock\\_destroy之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失**。（分配给这个锁的资源指什么？“丢失”的具体含义？）\n\n>1. 如果你的pthread\\_rwlock\\_t资源是临时变量，就要保证在生存期之前destroy；\n>2. pthread_rwlock_t * 这个指针指向的内存区域是malloc动态分配的，那就是destroy后，再free释放空间；\n>3. 你的pthread_rwlock_t如果是个全局变量，那么生存期其实就不影响，程序退出前destroy。\n\n---\n\n```c\n#include<pthread.h>\n/* 函数的返回值：若成功，返回0；否则，返回错误编号 */\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n```\n\n要在读模式下锁定读写锁，需要调用pthread\\_rwlock\\_rdlock。要在写模式下锁定读写锁，需要调用pthread\\_rwlock\\_wrlock。不管以何种方式锁住读写锁，都可以调用pthread\\_rwlock\\_unlock进行解锁。\n\n# 生产者-消费者模型\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <time.h>\n\n#define BUFFER_MAX 10\n#define PRODUCER_NUM 2\n#define CONSUMER_NUM 3\n\nsem_t empty;\nsem_t full;\npthread_mutex_t mutex;\n\nint buff[BUFFER_MAX];\nint in_index = 0;\nint out_index = 0;\nvoid *produce(void *arg)\n{\n    int index = (int)arg;\n    for (int i = 0; i < 30; i++)\n    {\n        sem_wait(&empty);\n        pthread_mutex_lock(&mutex);\n        buff[in_index] = rand() % 100;\n        printf(\"the producer %d wrote data %d,where %d\\n\", index, buff[in_index], in_index);\n        in_index = (in_index + 1) % BUFFER_MAX;\n        pthread_mutex_unlock(&mutex);\n        sem_post(&full);\n\n        sleep(2);\n    }\n}\nvoid *consume(void *arg)\n{\n    int index = (int)arg;\n    for (int i = 0; i < 20; i++)\n    {\n        sem_wait(&full);\n        pthread_mutex_lock(&mutex);\n        printf(\"the consumer %d read the data %d,from %d\\n\", index, buff[out_index], out_index);\n        out_index = (out_index + 1) % BUFFER_MAX;\n        pthread_mutex_unlock(&mutex);\n        sem_post(&empty);\n        sleep(1);\n    }\n}\n\nint main()\n{\n    sem_init(&empty, 0, BUFFER_MAX);\n    sem_init(&full, 0, 0);\n    pthread_mutex_init(&mutex, NULL);\n\n    srand((int)time(NULL));\n\n    // create the producers\n    pthread_t producer_id[PRODUCER_NUM];\n    for (int i = 0; i < PRODUCER_NUM; i++)\n    {\n        pthread_create(&producer_id[i], NULL, produce, (void *)i);\n    }\n    pthread_t consumer_id[CONSUMER_NUM];\n    for (int i = 0; i < CONSUMER_NUM; i++)\n    {\n        pthread_create(&consumer_id[i], NULL, consume, (void *)i);\n    }\n    for (int i = 0; i < PRODUCER_NUM; i++)\n    {\n        pthread_join(producer_id[i], NULL);\n    }\n    for (int i = 0; i < CONSUMER_NUM; i++)\n    {\n        pthread_join(consumer_id[i], NULL);\n    }\n    sem_destroy(&empty);\n    sem_destroy(&full);\n    pthread_mutex_destroy(&mutex);\n}\n```\n\n结果：\n```\nthe producer 1 wrote data 96,where 0\nthe producer 0 wrote data 73,where 1\nthe consumer 1 read the data 96,from 0\nthe consumer 0 read the data 73,from 1\nthe producer 0 wrote data 54,where 2\nthe producer 1 wrote data 63,where 3\nthe consumer 0 read the data 54,from 2\nthe consumer 2 read the data 63,from 3\nthe producer 1 wrote data 22,where 4\nthe producer 0 wrote data 60,where 5\nthe consumer 1 read the data 22,from 4\nthe consumer 0 read the data 60,from 5\nthe producer 0 wrote data 20,where 6\nthe producer 1 wrote data 47,where 7\nthe consumer 1 read the data 20,from 6\nthe consumer 2 read the data 47,from 7\nthe producer 1 wrote data 7,where 8\nthe producer 0 wrote data 46,where 9\nthe consumer 1 read the data 7,from 8\nthe consumer 0 read the data 46,from 9\nthe producer 0 wrote data 32,where 0\nthe producer 1 wrote data 96,where 1\nthe consumer 0 read the data 32,from 0\nthe consumer 2 read the data 96,from 1\nthe producer 1 wrote data 61,where 2\nthe producer 0 wrote data 35,where 3\nthe consumer 0 read the data 61,from 2\nthe consumer 1 read the data 35,from 3\nthe producer 0 wrote data 29,where 4\nthe producer 1 wrote data 54,where 5\nthe consumer 0 read the data 29,from 4\nthe consumer 2 read the data 54,from 5\nthe producer 1 wrote data 85,where 6\nthe producer 0 wrote data 20,where 7\nthe consumer 0 read the data 85,from 6\nthe consumer 1 read the data 20,from 7\nthe producer 0 wrote data 13,where 8\nthe producer 1 wrote data 71,where 9\nthe consumer 0 read the data 13,from 8\nthe consumer 2 read the data 71,from 9\nthe producer 0 wrote data 4,where 0\nthe producer 1 wrote data 94,where 1\nthe consumer 0 read the data 4,from 0\nthe consumer 1 read the data 94,from 1\nthe producer 1 wrote data 70,where 2\nthe producer 0 wrote data 99,where 3\nthe consumer 0 read the data 70,from 2\nthe consumer 2 read the data 99,from 3\n...\n```\n\n# 实现线程的三种模式\n\n## 纯粹的用户级线程\n\n## 纯粹的内核级线程\n\n## 组合\n\n## 区别\n\n1. 用户级\n   1. 创建开销小，可以创建很多。\n   2. 无法使用多个处理器\n2. 内核级\n   1. 创建开销大。\n   2. 由内核直接管理\n   3. 可以使用多个处理器\n\n# 线程安全\n\n\n\n# 查看线程信息的方法\n\n```bash\nps -ef | grep main\nps -eLf | grep main #UID PID PPID LWP（线程ID） C NLWP（线程数目）\nps -L #显示线程id\n```\n\n# 多线程中的fork\n\n执行fork后，整个进程会被复制，但是规定只启用fork所在的那条执行路径。\n\n# Linux线程的优势\n\n1. 外部获得线程的返回值？\n2. \n\n","categories":["操作系统","多线程","Linux"]},{"title":"排序算法_总述","url":"/算法/排序算法_总述/","content":"# 八大排序算法，归于 5 类\n\n有八种典型的排序算法，可归于五大类：\n\n1. 插入排序\n    1. 直接插入排序\n    2. 希尔排序\n2. 选择排序\n    1. 简单选择排序\n    2. 堆排序\n3. 交换排序\n    1. 冒泡排序\n    2. 快速排序\n4. 归并排序\n5. 基数排序\n## 稳定性\n\n两要素：\n1. 两个元素相同\n2. 排序后这两个元素是否能保持原来的顺序\n\n以下讨论的默认都是从小到大的排序。\n# 插入排序（直接、希尔）\n## 直接插入排序\n依次从待排序序列中取值，向已排序序列中投放，保证再次完全有序，直到待排序列中所有值取完。\n\n插入排序大多数都是两层循环。\n\n直接插入排序的思想：将待排序数据分为两部分，左边为有序的，右边是无序的。\n从右边拿一个数据插入到左边（为了方便，每次拿右边的第一个数据），\n需保持左边继续有序，直到右边没有数据。\n\n过程可以参照扑克牌插入排序。\n### 《算法导论》写法\n思想：`j`指向的是左侧已排序的末尾。`i`指向的是未排序的开头。\n外部`for`是从左到右遍历`i`的。\n内部`for`是从右到左遍历`j`的。\n每次，`a[i]`存入到了`tmp`，让`a[j]`和`tmp`比较，若大于，说明还没找到tmp（`a[i]`）应该在的位置。则`--j`继续找，直到找到一个小于tmp的位置。那么，退出内部for，把tmp存入到它的右边一个位置`a[j + 1] = tmp`。开始下一个`a[i]`的排序。\n\n这个《算法导论》的写法可读性不如《算法》的写法，推荐看后者的。\n\n```c\nvoid straight_insert_sort(int a[], int n)\n{\n    for(int i = 1; i < n; ++i)\n    {\n        int tmp = a[i];\n        for(int j = i - 1; j > -1; --j)//j指示欲插入的位置的前一个\n        {\n            if(a[j] > tmp)//移动\n            {\n                a[j + 1] = a[j];\n            }\n            else break;//j不减1\n        }\n        a[j + 1] = tmp;\n    }\n}\n```\n\nfor循环体中的条件判断可以与for表达式合并\n\n```c\nvoid straight_insert_sort(int a[], int n)\n{\n    for(int i = 1; i < n; ++i)\n    {\n        int tmp = a[i];\n        for(int j = i - 1; tmp < a[j] && j > -1; --j)\n        {\n            a[j + 1] = a[j];\n        }\n        //j指示插入位置的前一个位置\n        a[j + 1] = tmp;\n    }\n}\n```\n\n### 《算法》写法\n在每遍历一个值时，直接把`i`和`j`同时指向了一个位置。第 0 个位置跳过（排序算法的常见套路，第 0 个位置略过，当作已排序数据）。\n\n同时，不用存tmp了，直接封装到了`swap`函数中。\n\n内部`for`循环条件，看`a[j - 1]`是否大于`a[j]`，大于则交换。\n内部for循环做的事情，就是让`a[i]`在左侧（`j`的区域），从右到左，找到合适的位置插入。\n\n```c\nvoid straight_insert_sort(int a[], int n)\n{\n    for(int i = 1; i < n; ++i)\n    {\n        for(int j = i; a[j - 1] > a[j] && j > 0; --j)\n        {\n            swap(&a[j], &a[j - 1]);\n        }\n    }\n}\n```\n\n| 情况   | 时间复杂度    |\n| ---- | -------- |\n| 最好情况 | $O(n)$   |\n| 平均情况 | $O(n^2)$ |\n| 最坏情况 | $O(n^2)$ |\n\n## 希尔排序 - 插入排序的优化\n### 《算法》的写法 - 3x+1 增量\n最大间隔为 n / 3。每次除以 3 取整，间隔序列长度是$O(\\log_3 n)$级别。1, 4, 13, 40, 121, 364, 1093, ...\n\n在插入排序中加入一个外循环，来将 h 按照递增序列递减，就能得到这个简洁的希尔排序。\n增幅 h 的初始值是数组长度乘以一个常数因子，最小为1。\n\n假设 n 是 10 ，n / 3 是 3。则 h 初值为 4。\n先按 下标间隔 4 进行排序。让数组a 每 4 个有序，即：0、4、8有序，1、5、9有序，2、6（没有10）有序，3、7有序。\n再让 h 递减，`h = h / 3`，得 h 为 1 。即按 下标间隔 1 进行排序。让数组a 每 1 个有序，即：0、1、2、3、4、5、6、7、8、9有序。\n```c\nvoid shell_sort(int a[], int n)\n{\n    int h = 1;\n    while (h < n / 3) h = 3 * h + 1; // h 可能是 1, 4, 13, 40, 121, 364, 1093, ...\n    while (h >= 1)\n    {\n        // 将数组变为 每 h 有序\n        for (int i = h; i < n; ++i)\n        {\n            // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中\n            for (int j = i; j - h > -1 && a[j] < a[j - h]; j -= h)\n            {\n                swap(&a[j], &a[j - h]);\n            }\n        }\n        h = h / 3;\n    }\n}\n```\n在最坏的情况下该算法的比较次数 和 $N^{3/2}$ 成正比。\n**经验平均复杂度**（大量随机输入）：$O(n^{3/2})$\n**最坏情况复杂度**：$O(n^{2})$。Shell 排序没有严格的最坏情况次方级优化保证，某些特殊序列会退化到平方级\n最好情况复杂度（数组已经有序）：$O(n \\log n)$。因为每个 h 排序只需一次线性扫描\n\n### Bubo的写法 - 折半增量\n这是折半增量序列，虽然在常数因子上比普通插入排序好，但在数据规模大时明显慢于用 3x+1 序列的排序。\n\n最大间隔为n / 2。增量依次为：n/2,n/4,n/8,…,1。序列长度 约等于 $\\log_2 n$。 1, 2, 4, 8, 16, 32, 64, ...\n\n```c\nvoid shell_sort(int a[], int n)\n{\n    for(int k = n / 2; k > 0; k /= 2) // k为组距或组数\n    {\n        // 组内进行\"直接插入排序\"\n        for(int i = k; i < n; i += k)\n        {\n            for(int j = i; j > k - 1 && a[j - k] > a[j]; j -= k)\n            {\n                swap(&a[j - k], &a[j]);\n            }\n        }\n    }\n}\n```\n由于最后一次 k=1 等同于直接插入排序，且前几轮效果不够显著，总体时间复杂度：$O(n^2)$\n平均情况：依然接近$O(n^2)$。比单纯的插入排序快常数倍，但数量级不变。\n最好情况：如果数组初始就是有序的，每轮只做一次扫描，复杂度：$O(n \\log n)$\n\n| 情况   | 时间复杂度         |\n| ---- | ------------- |\n| 最好情况 | $O(n \\log n)$ |\n| 平均情况 | $O(n^2)$      |\n| 最坏情况 | $O(n^2)$      |\n所以，这种（折半增量）如果不在序列增量（3x+1 增量）上进行优化，还不如直接用直接插入排序。\n### 3x+1 对比 折半 增量的优势\n**插入排序的一个核心特点** —— 它的效率高度依赖数据的**有序程度**，所以序列不同性能差异会很大。\n\n折半增量的早期问题：\n当 gap 很大时（比如 n/2）：\n- **子序列很短**：  \n    gap = n/2 → 每个子序列只有 2 个元素  \n    gap = n/4 → 每个子序列只有 4 个元素\n- **比较覆盖度低**：  \n    大 gap 排序时，只比较很稀疏的元素对，大部分元素间的相对顺序并没有直接调整\n- **逆序对消除效率低**：  \n    Shell 排序的性能提升依赖于尽早减少逆序对  \n    但大 gap 只能消除相隔很远的逆序对，很多局部逆序（相隔 < gap 的）还留着，等到 gap 变小时才会处理\n\n3x+1 增量 对比 折半增量的优势\n- **折半增量 n/2=8 第一轮**时，每个子序列长度只有 2，对局部逆序几乎没影响；\n- **3x+1 第一轮 h=13** 时，子序列长达 3 或 4，能一次调整更大范围的元素，迅速减少逆序对\n- 到 h=1 时，3x+1 版本剩下的乱序非常少，所以最后插入排序很快\n\n原始数组（逆序）：\n16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n\n折半增量第一轮：\n```\n原始：16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\ngap=8: (16,8), (15,7), (14,6), (13,5), (12,4), (11,3), (10,2), (9,1)\n结果： 8  7  6  5  4  3  2  1 16 15 14 13 12 11 10  9\n```\n虽然位置变化很大，但前 8 个和后 8 个依旧是逆序的；\n绝大多数局部逆序还在，下一轮 gap=4 时才开始打乱它们。\n\n3x+1 增量第一轮：\n- 子序列是按下标相差 13 分的分组：\n    - 组1: (16, 3)\n    - 组2: (15, 2)\n    - 组3: (14, 1)\n    - 其他元素只和自己比较\n- 对每个子序列进行插入排序：\n\n```\n3  2  1 13 12 11 10  9  8  7  6  5  4 16 15 14\n```\n\n3x+1 增量第二轮（h = 4）\n- 子序列（间隔 4）\n    - 组1: (3, 12, 8, 4)\n    - 组2: (2, 11, 7, 16)\n    - 组3: (1, 10, 6, 15)\n    - 组4: (13, 9, 5, 14)\n- 各组内部插入排序：\n\n结果：\n`3  2  1  5  8  7  6  9 12 11 10 13  4 16 15 14`\n（已经更接近有序）\n## 插入排序总结\n- **逆序对分析**：时间复杂度与数组中的逆序对数量成正比\n- **与希尔排序关系**：希尔排序是插入排序的推广（多间隔插入），解决了大规模数据移动代价高的问题\n- **实际案例**：C++ STL 的 `std::sort` 对小数组（一般 ≤ 32 元素）内部会用插入排序收尾（快速排序的尾递归部分），因为它在缓存命中率和分支预测上很高效。\n- 非常适合小规模或接近有序的数据\n- 不同的增量序列 → 决定了希尔排序每一轮能消除多少逆序对 → 决定了最后 gap=1 时的工作量 → 直接影响性能。\n\n增量序列的作用\n* 希尔排序的效率，取决于它能多快把逆序对减少到接近 0。\n* gap 很大时 → 只能消除长距离的逆序对（下标差 ≥ gap）\n* gap 变小时 → 才能处理更短距离的逆序对（下标差 < gap）\n\n最后一轮 gap=1（普通插入排序） → 必须处理剩余所有短距离逆序对\n1. 折半增量（n/2, n/4, …, 1）\n    - 前几轮 gap 很大时，每个子序列很短\n    - 只能消除少量长距离逆序对，很多短距离逆序对要留到最后一次 gap=1 时处理\n    - 导致最后一轮几乎是完整的 $O(n^2)$ 插入排序\n2. 优化过的增量（3x+1）\n    - gap 序列递减比例较小（约 2~3 倍），而不是直接减半\n    - 每一轮的子序列更长，能一次消除多种不同跨度的逆序对\n    - 到最后 gap=1 时，数组已经接近有序，逆序对很少 → 插入排序非常快\n\n逆序对是什么？\n```\n[3, 1, 2]\n逆序对：(3, 1)、(3, 2)\n总共 2 个逆序对。\n```\n# 选择排序（简单、堆排）\n每次找到剩余序列中最小的元素，放到已排序序列的尾部（或者看作剩余序列的头部）。\n**不断地选择剩余元素之中的最小者**。\n## 简单选择排序\n《算法》的写法：\n```c\nvoid selection_sort(int a[], int n)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        int min_idx = i;\n        for (int j = i + 1; j < n; ++j)\n        {\n            if (a[j] < a[min_idx])\n            {\n                min_idx = j;\n            }\n        }\n        // 注意，是 a[i]而不是a[j] 和 a[min_idx]交换\n        swap(&a[i], &a[min_idx]);\n    }\n}\n```\n\n```\ni min   0 1 2 3 4 5 6 7 8 9 10\n        S O R T E X A M P L E\n0  6    S O R T E X A M P L E\n1  4    A O R T E X S M P L E\n2  10   A E R T O X S M P L E\n3  9    A E E T O X S M P L R\n4  7    A E E L O X S M P T R\n5  7    A E E L M X S O P T R\n6  8    A E E L M O S X P T R\n7  10   A E E L M O P X S T R\n8  8    A E E L M O P R S T X\n9  9    A E E L M O P R S T X\n10 10   A E E L M O P R S T X\n```\n\n优化：第一层for中的`i`可以优化为`i < n - 1`，因为排最后一个时，剩余序列就1个数了，无需再找最小了。\n\n```c\nvoid selection_sort(int a[], int n)\n{\n    int min_idx;\n    for(int i = 0; i < n - 1; ++i)\n    {\n        min_idx = i;\n        for(int j = i + 1; j < n; ++j)\n        {\n            if(a[j] < a[min_idx])\n            {\n                min_idx = j;\n            }\n        }\n        swap(&a[i], &a[min_idx]);\n    }\n}\n```\n\n## 堆排序\n\n堆的作用是产生一个极值元素。\n\n堆是一种完全二叉树。（区分概念：二叉树、满二叉树、完全二叉树）\n\n总体的排序过程：首先要保证整个二叉树是一个大（小）根堆，即**每一个父节点都要比其子节点大（小）**，如此就能保证整个树的根节点就是最大（小）的节点，即产生了一个极值元素。\n我们把它和未排序的最后一个叶子节点互换值，而交换完之后，根节点打乱了大（小）根堆的结构，需要重新保证整个二叉树是一个大（小）根堆，才能产生极值元素与最后位置交换。\n如此，循环往复，每找到一个极值点，就换其到最后（归到已排序数列中），就可以达到排序的目的。\n\n**其中，找极值元素，即保证树为大（小）根堆的过程，是一个递归过程**：因为大（小）根堆的概念就是：**完全二叉树中，每一个父节点都要比其子节点大（小）**。由于涉及到树，并且涉及到层层相扣的大小关系，因此堆化的过程是一个递归过程。\n\n如果把数据抽象为堆结构去排序，那么首先我们需要建立堆。需要从最后一个非叶子节点进行逆向遍历，依次以节点为根进行堆化。\n\n### 堆化函数\n堆化函数，递归地让整颗完全二叉树每个节点都大于（小于）其子节点。根节点大于字节点则是大根堆，根节点小于子节点则是小根堆。\n\n注意！！！堆化函数只适用于：只有根节点不是大（小）根堆，而其他节点符合大（小）根堆 的情况。\n\n以下的堆化函数，是基于一个root为根到last节点的大根堆。（这段代码，事实上是：由于节点比子节点小，进行下沉操作）\n堆化函数，让它确保恢复到大根堆的状态。\n```c\nvoid heapify(int a[], int root_idx, int last_idx)\n{\n    int left = root_idx * 2 + 1; //root最小值可能为0\n    int right = left + 1;\n    // 判断该根节点是否有子节点，如果left超过了last_idx值则退出\n    if(left > last_idx) return;\n    int max = root_idx;\n    // 运行到这里时，left > last_idx，即last_idx <= left，由于是完全二叉树的逻辑结构，因此max一定有左子树，所以我们直接看[left]和[max]的大小关系\n    if(a[left] > a[max])\n    {\n        max = left;\n    }\n    // 但我们不能确定是否max有右子树，需要判断\n    if(right <= last_idx)\n    {\n        if(a[right] > a[max])\n        {\n            max = right;\n        }\n    }\n    if(max != root_idx)\n    {\n        exchange(a, &a[root_idx], &a[max]);\n        heapify(a, max, last_idx);\n    }\n}\n```\n### 堆化函数和优先级队列的关系 - 上浮、下沉函数\n优先级队列，可以看作是一个大根堆，根节点的优先级最大。\n\n大根堆中，上浮，swim，或FilterUp。即由于一个节点**大于其父节点**，上浮。\n大根堆中，下沉，sink，或FilterDown。即由于一个节点**小于其所有子节点**，下放。\n\n我们以下描述的均为数组下标。因此，假设某节点对应的下标为`i`，则左子节点的下标就为`2 * i + 1`\n```c\nvoid FilterDown(int a[], int start_idx, int end_idx)\n{\n    int i = start_idx;\n    int j = i * 2 + 1;\n    // 看有没有子节点。\n    while (j <= end_idx)\n    {\n        // 看 有没有 右子节点。如果有则 看 左子节点和右子节点哪个更大。\n        if (j < end_idx && a[j + 1] > a[j])\n        {\n            j = j + 1;\n        }\n        // 把更大的子节点a[j] 与 a[i]比较。如果a[i] 大于等于 a[j]，则 i 节点不用换位置了\n        if (a[i] >= a[j])\n        {\n            break;\n        }\n        swap(&a[i], &[j]);\n        // a[i] 和 a[j] 交换后，i 节点和 它的子节点有序了\n        // 但是，j 节点的值换成了 a[i]，有可能 j 节点和它的子节点乱序了。重新开始。\n        i = j;\n        j = i * 2 + 1;\n    }\n}\n```\n`(i - 1) / 2`是`i`节点的父节点。\n所谓上浮，是重点关注于该节点本身，与父节点比较大小。无需关注兄弟节点。\n```c\nvoid FilterUp(int a[], int start_idx)\n{\n    int i = start_idx;   // 子节点\n    int j = (i - 1) / 2; // 父节点\n    // 若 子节点 大于 父节点 则 上位\n    while (i > 0 && a[i] > a[j])\n    {\n        swap(&a[i], &a[j]);\n        // a[i] 和 a[j] 交换后，i 节点和 它的父节点 j 有序了（目前a[i] < a[j]，子节点小于父节点）\n        // 但是，有可能 j 节点 和 j 的父节点 乱序。重新开始。\n        i = j;\n    }\n}\n```\n### 建堆\n\n再次注意！！！堆化函数只适用于只有根节点不是大（小）根堆，而其他节点符合大（小）根堆 的情况。\n\n因此在堆化之前我们应该先建立一个大（小）根堆！\n\n怎么建立大（小）根堆呢？我们要利用上面这个堆化函数。而刚才一直在反复强调，堆化函数只能用于除了根节点没有堆化，其他节点已全部堆化的情况。所以：只能从非叶子节点逆着依次堆化！最后一个非叶子节点为：`(last_idx - 1) / 2`。（`last_idx`表示数组下标，从0开始）\n\n```c\nvoid create_heap(int a[], int root_idx, int last_idx)\n{\n    for(int i = (last_idx - 1) / 2; i > -1; --i)\n    {\n        heapify(a, i, last_idx);\n    }\n}\n```\n### 排序\n\n如上文，每次产生一个极值元素，和未排序的最后一个叶子节点互换值，就可以达到排序的目的。\n\n```c\nvoid heap_sort(int a[], int n)\n{\n    create_heap(a, 0, n - 1);\n    for(int i = n - 1; i > 0; )\n    {\n        exchange(a, &a[0], &a[i]);\n        --i;\n        heapify(a, 0, i);\n    }\n}\n```\n### 用下沉函数进行堆排序\n此处，sink，生成了一个大根堆。\n之后每次把大根（整棵树的最大值）放到后面，当作已排序序列。再对未排序进行大根化。以此往复。\n因此，基于大根堆的排序之后的序列是升序的（从小到大）\n同理，基于小根堆的排序之后的序列是降序的（从大到小）\n```c\nvoid heap_sort(int a[], int n)\n{\n    // i 初始化为 尾 节点的 父 节点\n    // 从 最后一个 有分支的 节点 开始，一直到 0 节点（整棵树的根）每个 二叉树 都 做一次 大根化 操作\n    for (int i = (n - 1) / 2; i >= 0; i--)\n    {\n        // sink 的 第三个参数传入的是 下标，n - 1指尾节点的下标\n        sink(a, i, n - 1);\n    }\n    int i = n - 1;\n    // i 等于 0 时，则 未排序的只剩一个数了，不用再排序。\n    while (i > 0)\n    {\n        // 目前 0 位置就是最大值，放到最后（就是 i 位置），然后最后的边界缩小 1（--i），让 0 到新边界大根化，生成下一个极值。\n        swap(&a[0], &a[i]);\n        --i;\n        sink(a, 0, i);\n    }\n}\n```\n# 冒泡排序\n\n```c\nvoid bubble_sort(int a[], int n)\n{\n    for(int i = 0; i < n - 1; ++i)\n    {\n        // 每完成一次 内部 for 循环，都会为 已排序序列 确定一个数。因此 已排序序列的边界 更新为 i\n        for(int j = n - 1; j > 0 + i; --j)\n        {\n            // 把 左边大的数 交换到了 右边，因此最后生成了 升序序列（从小到大）\n            if(a[j - 1] > a[j])\n            {\n                swap(&a[j - 1], &a[j]);\n            }\n        }\n    }\n}\n```\n第一层for循环退出的条件可以由`i < n`优化成`i < n - 1`。因为当`i == n - 1`时，最后的数一定是最大的数。\n\n优化：如果第一次for循环，从尾部到头部一路比较下来，发现，没有交换过，说明这是一个已经有升序的序列，直接return，不再进行往后无谓的排序了。\n最好情况（已排序数组）只需 $O(n)$\n```c\nvoid bubble_sort(int a[], int n)\n{\n    for(int i = 0; i < n - 1; ++i)\n    {\n        int is_exchanged = 0;\n        for(int j = n - 1; j > 0 + i; --j)\n        {\n            if(a[j - 1] > a[j])\n            {\n                swap(&a[j - 1], &a[j]);\n                is_exchanged = 1;\n            }\n        }\n        if(!is_exchanged)\n            return;\n    }\n}\n```\n\n# 快速排序\n## 划分基准\n在快速排序中，最重要的即为划分过程，每个数的位置将在每一次划分后确定。\n\n那么，基准值（pivot）其实可以从未定序列（除了确定位置的其他值）中随机选择。\n\n在不同教材中，讲解的快速排序往往有两大方案，一是每次选择左首为基准，二是每次选择右尾为基准进行划分。\n\n在《算法导论》中，选择的是右尾；\n在《算法》（普林斯顿大学）中选择的是左首。\n在Bubo的讲解中，选择的是右尾；\n在老杨派系的讲解中，选择的是左首。\n在网络上，大部分选择的是左首。\n## 划分方向 - 左右向 + 单双向\n除了基准位置的选取不同。迭代方向也有所不同：分为单向（单轴）法（需要分左右）、双轴法等。\n\n这些各式各样的方法，无所谓其细节，其实达到的效果都是一样的，\n\n即我们需要关注其核心本质，不要忘了快速排序中，划分函数的初心是什么。\n\n所以，我们可以想象，如果每次选择左首划分，那么其实给元素的位置交换多了一些麻烦，即出现不同的情况。\n\n而**如果选择右尾划分，我们可以发现，划分区域的扩张过程很简洁，那么元素的位置交换也不需要太多的分情况，所以思路相对简洁**。\n\n总的来说，划分的方式有三大要素：左首、右尾划分；单向、双向划分；左、右划分（如果是双向划分则是先左后右或先右后左）\n\n单向划分方法又称为：Lomuto 分区（Lomuto partition scheme）\n双向划分（向中间逼近）又称为：Hoare 分区（Hoare partition scheme）\n单向、双向都是把数组分成了两个区域加一个基准值。\n还有一种三路划分（Dutch National Flag partition），是分成了三个区域，小于的、等于的、大于的。\n三路划分单独处理了数组中和基准值重复过多的情况。\n\n总之，可分为：\n\n1. 左首、单向、左划分；\n2. 左首、单向、右划分；\n3. 左首、双向、先左后右划分；\n4. 左首、双向、先右后左划分；\n5. 右尾、单向、左划分；\n6. 右尾、单向、右划分；\n7. 右尾、双向、先左后右划分；\n8. 右尾、双向、先右后左划分；\n9. 三路划分\n## 0：左首、三路划分\n```c\nvoid quick_sort_3way(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int pivot = a[left];\n    int lt = left, i = left + 1, gt = right; // a[left..lt - 1] < p, a[lt ..gt] == p, a[gt+1..right] > p\n    while (i <= gt)\n    {\n        if (a[i] < pivot)\n        {\n            swap(&a[lt], &a[i]);\n            ++lt;\n            ++i;\n        }\n        else if (a[i] > pivot)\n        {\n            swap(&a[i], &a[gt]);\n            --gt;\n        }\n        else\n        {\n            ++i;\n        } // a[i] == pivot\n    }\n    quick_sort_3way(a, left, lt - 1);\n    quick_sort_3way(a, gt + 1, right);\n}\n\n```\n## 1：左首、单向、左划分（老杨）\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int pivot = a[left];\n    int i = left;\n    int j = i + 1;\n    // j 遍历向右\n    while (j <= right)\n    {\n        if (a[j] <= pivot)\n        {\n            swap(&a[i + 1], &a[j]);\n            ++i;\n        }\n        ++j;\n    }\n    // i 的位置是 左侧部分的末尾。\n    // left 属于 左侧部分。不应与i+1交换，而是与i交换\n    swap(&a[i], &a[left]);\n    // i 的位置是基准值，已固定。只需排除了i之后剩下的。\n    quick_sort(a, left, i - 1);\n    quick_sort(a, i + 1, right);\n}\n```\n优化：`if (a[j] <= pivot)`中最好把`<=`改为`<`。\n1. 优化前，如果数组中等值太多，则会进行多次无意义的交换。\n    - 设数组全是相同值，选左端为轴。\n    - 对每个 j，`a[j] <= pivot` 都成立，于是 i 每次自增，循环结束后 `i == right`，最后再把 pivot 和 `a[i]` 交换——**轴被放到最右端**。\n    - 递归变成：`[left, right-1]`（规模 n-1）和空区间。于是递归关系 `T(n)=T(n-1)+O(n)`，整体退化到 **O(n^2)**。\n2. 优化后，用 `<` 会好一点（少很多交换），但在“全等/大量重复”的数据上还是会退化到 $O(n^2)$。\n\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int pivot = a[left];\n    int i = left;\n    int j = i + 1;\n    // j 遍历向右\n    while (j <= right)\n    {\n        if (a[j] < pivot)\n        {\n            swap(&a[i + 1], &a[j]);\n            ++i;\n        }\n        ++j;\n    }\n    // i 的位置是 左侧部分的末尾。\n    // left 属于 左侧部分。不应与i+1交换，而是与i交换\n    swap(&a[i], &a[left]);\n    // i 的位置是基准值，已固定。只需排除了i之后剩下的。\n    quick_sort(a, left, i - 1);\n    quick_sort(a, i + 1, right);\n}\n```\n## 3：左首、双向、先左后右划分（《算法》 - 普林斯顿大学）\n以左首为基准的双向划分，不推荐先从左划分，代码可读性不太好，而且最后i、j边界不能乱用。\n以左首为基准的双向划分，推荐先右后左划分（老杨版本）\n```c\n//此方法是前置++，i和j的位置最后不一定重合，会错开1位！\n//由于是以左首划分，那么最后替换到左首的值则应该是一个小于（等于）左首的值。\n//以上两个条件决定了，必须选择a[j]（即j停下来的位置的值）与左首交换，则j就作为确定的划分界限。\n\n//另外，左右划分的顺序无所谓！先左先右都可以！\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int i = left, j = right + 1;//为了便于下面++i和--j的代码统一性，所以从left到right+1，实际上只考察到了left+1到right的部分\n    int pivot = a[left];\n    while(1)\n    {\n        while(a[++i] <= pivot)\n            if(i == right) break;\n        while(a[--j] > pivot)\n            if(j == left) break;\n        if(i >= j) break;\n        swap(&a[i], &a[j]);\n    }\n    swap(&a[left], &a[j]);// a[left]为左首元素，即基准值\n    quick_sort(a, left, j - 1);\n    quick_sort(a, j + 1, right);\n}\n```\n可读性更好的自用版：\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n\n    int pivot = a[left];\n    int i = left + 1, j = right;\n\n    while (1)\n    {\n        while (i <= j && a[i] <= pivot) ++i; // 停在 > pivot\n        while (i <= j && a[j] >  pivot) --j; // 停在 <= pivot\n        if (i > j) break;\n        swap(&a[i], &a[j]);\n        ++i; --j;\n    }\n    // 轴与 j 交换，保证 [left..j-1] <= pivot，pivot 在 j\n    swap(&a[left], &a[j]);\n\n    quick_sort(a, left, j - 1);\n    quick_sort(a, j + 1, right);\n}\n```\n指针交错（或相遇）后应把 **pivot 与 `a[j]` 交换**，而不是和 `a[i]`。用 `i` 会出错（如 `[1,3,2]` 会变成 `[3,1,2]`）。\n\n## 4：左首、双向、先右后左划分（仿照Bubo的“右尾、双向、先左后右划分”方法写的，见7）\n\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int l = left + 1, pivot = left, r = right;\n    while (l < r)\n    {\n        if (a[r] > a[pivot])\n            --r;\n        else if (a[l] <= a[pivot]) \n            ++l;\n        else\n            swap(&a[l], &a[r]);\n    }\n    if (a[r] > a[pivot])\n    {\n        swap(&a[r - 1], &a[pivot]);\n        pivot = r - 1;\n    }\n    else\n    {\n        swap(&a[r], &a[pivot]);\n        pivot = r;\n    }\n    quick_sort(a, left, pivot - 1);\n    quick_sort(a, pivot + 1, right);\n}\n```\n\n上面的代码是初版，最后的`if-else`想复杂了，以下是优化：\n\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int l = left + 1, pivot = left, r = right;\n    while (l < r)\n    {\n        if (a[r] > a[pivot])\n            --r;\n        else if (a[l] <= a[pivot])\n            ++l;\n        else\n            swap(&a[l], &a[r]);\n    }\n    if (a[l] < a[pivot])\n    {\n        swap(&a[l], &a[pivot]);\n        pivot = l;\n    }\n    quick_sort(a, left, pivot - 1);\n    quick_sort(a, pivot + 1, right);\n}\n```\n### ⭐老杨版（挖坑法）\n挖坑法（又叫“填坑法”）是快速排序的一种原地分区写法：先把轴值（pivot）暂存出来，把它原来的位置当成“坑”，然后从数组两端向中间扫，**用遇到的元素去“填”当前的坑**；被搬走的位置又形成新的坑，交替进行，直到左右指针相遇，最后把轴值放回这个最终的坑。\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int pivot = a[left];\n    int i = left;\n    int j = right;\n    while (i < j)\n    {\n        while (i < j && a[j] > pivot)\n        {\n            --j;\n        }\n        if (i < j) // a[right] <= pivot\n        {\n            a[i] = a[j];\n        }\n        while (i < j && a[i] <= pivot)\n        {\n            ++i;\n        }\n        if (i < j) // a[left] >= pivot\n        {\n            a[j] = a[i];\n        }\n    }\n    a[i] = pivot;\n    quick_sort(a, left, i - 1);\n    quick_sort(a, i + 1, right);\n}\n```\n\n## ⭐5：右尾、单向、左划分（北航算法）\n`left`到`i`的区域为**小于等于**基准值的区域。\n\n在划分结束前，`i + 1`到`right`的区域，均为**大于**基准值的区域。\n\n划分结束后，`i + 1`为基准值最后落到的位置。（需要单独进行`a[i+1]`和`a[right]`的交换）\n\n`left`和`right`均为数组下标。\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if(left >= right) return;\n    int i = left - 1, j = left;\n    int pivot = a[right];\n    while(j < right)\n    {\n        if(a[j] > pivot)\n        {\n            ++j;\n        }\n        else\n        {\n            swap(&a[i + 1], &a[j]);\n            ++i;\n            ++j; // 不管if是否成立，都++j\n        }\n    }\n    // i 的位置是 左侧部分的末尾。\n    // right 属于 右侧部分。不应与i交换，而是与i+1交换\n    swap(&a[i + 1], &a[right]);\n    quick_sort(a, left, i);\n    quick_sort(a, i + 2, right);\n}\n```\n\n`if-else`优化：\n\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if(left >= right) return;\n    int i = left - 1, j = left;\n    int pivot = a[right];\n    while(j < right)\n    {\n        if(a[j] <= pivot)\n        {\n            swap(&a[i + 1], &a[j]);\n            ++i;\n        }\n        ++j;  // 不管if是否成立，都++j\n    }\n    // i 的位置是 左侧部分的末尾。\n    // right 属于 右侧部分。不应与i交换，而是与i+1交换\n    swap(&a[i + 1], &a[right]);\n    quick_sort(a, left, i);\n    quick_sort(a, i + 2, right);\n}\n```\n### `i`的初始值应为`left - 1`\n以上程序，`i`的初始值不应是`left`，而是`left - 1`：\n\n怎么记住呢？我们可以想象一下，如果划分两个元素，那么`right = 1`，`left = 0`。如果`i`一开始和`j`都等于`left`，那么如果`a[j] <= pivot`，则`a[i + 1]`和`a[j]`交换，这时`i + 1`是`right`，造成小数在右，所以错误。\n\n实际上，`i`、`j`指示器分别代表左、右部分的末端。\n\n两个极端的情况就是：如果`i`超出数组左边界（值为`-1`）则说明左部分为空，即没有比基准值小于（等于）的值；\n如果`j`超出待排数组右边界（当以右尾划分时，`j`超出边界时值为`right`）则说明右部分为空，即没有比基准值大的值。\n\n遍历数组过程中，主要依托`j`的行进，如果遇到的值比基准值大，则`j`单独进步；如果遇到值比基准值小（等），则需要与`右部分`的首位置替换，如此，遇到的小的值去了`左部分`，原先首位置的值换到了`右部分`的最末端。最后，`i`和`j`同时进一步。\n\n## 7：右尾、双向、先左后右划分：（Bubo）\n\n```c\n//这个版本下，left和right必定相等\n//但是，存在一种情况，即只有两个元素进行划分，如2、3；\n//那么此时left和right一上来就相等，都指向2\n//如果我们不去做a[l]和a[pivot]的大小对比，那么最后就会划分为3、2（3为基准），此时发现，2比3小，却错误的排到后面了。\n//所以，必须在后面加上a[l]和右尾值的大小对比！才能进行替换\n\n//另外，此方法不能交换划分顺序！即必须先左划分，后右划分，否则错误！\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    //此时若只有两个元素，则出现l == r\n    int l = left, pivot = right, r = right - 1;\n    while (l < r)\n    {\n        if (a[l] <= a[pivot])\n            ++l;\n        else if (a[r] > a[pivot])\n            --r;\n        else\n            swap(&a[l], &a[r]);\n    }\n    if (a[l] > a[pivot])\n    {\n        swap(&a[l], &a[pivot]);\n        pivot = l;\n    }\n    quick_sort(a, left, pivot - 1);\n    quick_sort(a, pivot + 1, right);\n}\n```\n\n## 8：右尾、双向、先右后左划分；（仿照“左首、双向先左后右划分”《算法》写的）\n\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int i = left - 1, j = right;//为了便于下面++i和--j的代码统一性，所以从left-1到right，实际上只考察到了left到right-1的部分\n    int pivot = a[right];\n    while (1)\n    {\n        while (a[--j] > pivot)\n            if (j == left) break;\n        while (a[++i] <= pivot)\n            if (i == right) break;\n        if (i >= j) break;\n        swap(&a[i], &a[j]);\n    }\n    swap(&a[right], &a[i]);// a[right]为右尾元素，即基准值 //必须和a[i]交换，否则不对\n    quick_sort(a, left, i - 1); // 必须是i - 1，否则不对\n    quick_sort(a, i + 1, right);// 必须是i + 1，否则不对\n}\n```\n\n其实我们发现，先左后右划分也正确，但是后三句中的基准位置是`i`，不能是`j`\n\n```c\nvoid quick_sort(int a[], int left, int right)\n{\n    if (left >= right) return;\n    int i = left - 1, j = right;//为了便于下面++i和--j的代码统一性，所以从left-1到right，实际上只考察到了left到right-1的部分\n    int pivot = a[right];\n    while (1)\n    {\n        while (a[++i] <= pivot)\n            if (i == right) break;\n        while (a[--j] > pivot)\n            if (j == left) break;\n        if (i >= j) break;\n        swap(&a[i], &a[j]);\n    }\n    swap(&a[right], &a[i]);// a[right]为右尾元素，即基准值 //必须和a[i]交换，否则不对\n    quick_sort(a, left, i - 1); // 必须是i - 1，否则不对\n    quick_sort(a, i + 1, right);// 必须是i + 1，否则不对\n}\n```\n\n## 总结\n\n```\n若用前置++，i和j的位置最后不一定重合，可能会错开1位！\n由于是以左首划分，那么最后替换到左首的值则应该是一个小于（等于）左首的值。\n以上两个条件决定了，必须选择a[j]（即j停下来的位置的值）与左首交换，则j就作为确定的划分界限。\n相反，如果以右尾划分，那么替换到右尾的值则应该是一个大于（等于）右尾的值。则必须选择a[i]与右尾交换，则i就作为确定的划分界限。\n```\n\n综上所述，快排划分函数的细节需要注意：\n\n1. 如果你选择的是双向划分——最终的`i`、`j`指针是一定重合吗？有可能错开1位吗？\n    1. 如果错开1位，则先左先右无所谓！\n    2. 如果一定重合，则必须有个先左或先右的顺序！**（为什么呢？）**\n2. 你选择以左首或右尾划分，决定了你最后替换左首（右尾）的条件和具体位置！这个和`i`、`j`错不错开没关系！如果选择左首划分，则需要拿比左首小的值与之替换；如果选择右尾划分，则需要拿比右尾大的值与之替换；\n    1. 如果你的方法有可能使`i`、`j`错开，那么`i`停下的位置一定是比基准值大于（等于）的；`j`停下的位置一定是比基准值小于（等于）的\n    2. 如果你的方法使`i`、`j`最后一定重合，那么由于两个元素时`i`、`j`也恰巧重合，所以不能直接替换左首（右尾），需要比较`i`（或`j`，他俩一样，无所谓），如果你选择左首划分，则判断左首是否比`i`（或`j`）位置的值小（等）；如果你选择右尾划分，则判断右尾是否比`i`（或`j`）位置的值大（等）——若不是，则交换值，更新基准下标（pivot）；\n## 非递归形式\n```cpp\nint Partition(int * ar, int left, int right)\n{\n    int i = left;\n    int j = right;\n    int pivot = ar[left];\n    while (i < j)\n    {\n        while (i < j && ar[j] > pivot)\n        {\n            --j;\n        }\n        if (i < j) // ar[j] <= pivot\n        {\n            ar[i] = ar[j];\n        }\n        while (i < j && ar[i] <= pivot)\n        {\n            ++i;\n        }\n        if (i < j)\n        {\n            ar[j] = ar[i];\n        }\n    }\n    ar[i] = pivot;\n    return i;\n}\nvoid QuickSort(int * ar, int n)\n{\n    std::queue<int> qu;\n    qu.push(0);\n    qu.push(n - 1);\n    while (!qu.empty())\n    {\n        int left = qu.front(); qu.pop();\n        int right = qu.front(); qu.pop();\n        int mid = Partition(ar, left, right);\n        if (left < mid - 1)\n        {\n            qu.push(left);\n            qu.push(mid - 1);\n        }\n        if (mid + 1 < right)\n        {\n            qu.push(mid + 1);\n            qu.push(right);\n        }\n    }\n}\n```\n## 优化：随机基准或三位取中\n\n## 优化：尾递归消除\n```c\n// partition 返回轴最终下标 p；两侧为 [left, p-1] 与 [p+1, right]\nvoid quick_sort(int a[], int left, int right)\n{\n    while (left < right)\n    {\n        int p = partition(a, left, right);  // 任选 Lomuto/挖坑，保证返回轴位 p\n        // 递归较小一侧，较大一侧用循环“缩区间”\n        if (p - left < right - p)\n        {\n            quick_sort(a, left, p - 1);  // 小的那半递归\n            left = p + 1;                // 大的那半转为尾部迭代\n        }\n        else\n        {\n            quick_sort(a, p + 1, right);\n            right = p - 1;\n        }\n    }\n}\n```\n## 最终代码\n```c\n#define INSERTION_SORT_THRESHOLD 16\n\n// 三数取中：把 a[left], a[mid], a[right] 排成 a[left] <= a[mid] <= a[right]，然后把中位数放到 left 当轴\nstatic inline void median_of_three_to_left(int a[], int left, int right)\n{\n    int mid = left + ((right - left) >> 1);\n    if (a[mid]   < a[left])  swap_int(&a[mid]  , &a[left]);\n    if (a[right] < a[left])  swap_int(&a[right], &a[left]);\n    if (a[right] < a[mid])   swap_int(&a[right], &a[mid]);\n    // 此时 a[left] <= a[mid] <= a[right]，取中位数作为轴：交换到 left\n    swap_int(&a[left], &a[mid]);\n}\n// 快速排序（挖坑法 + 尾递归消除 + 小区间插排 + 三数取中选轴）\nvoid quick_sort(int a[], int left, int right)\n{\n    while (left < right)\n    {\n        // 小区间用插入排序更快\n        if (right - left + 1 <= INSERTION_SORT_THRESHOLD)\n        {\n            insertion_sort(a, left, right);\n            return;  // 当前区间完成，直接返回（外层 while 退出）\n        }\n\n        // 选轴优化：三数取中，并将中位数放到 left\n        median_of_three_to_left(a, left, right);\n\n        // 分区\n        int p = partition_pit(a, left, right);\n\n        // 尾递归消除：总是递归较小的一侧，较大的一侧改为迭代\n        if (p - left < right - p)\n        {\n            quick_sort(a, left, p - 1);  // 递归较小段\n            left = p + 1;                // 大段转为下一轮循环\n        }\n        else\n        {\n            quick_sort(a, p + 1, right);\n            right = p - 1;\n        }\n    }\n}\n```\n# 归并排序\n\n归并排序涉及到分治（Divide & Conquer）策略的思想。分治策略有很多例子，比如MapReduce用于大规模数据集（大于1TB）的并行运算。涉及\"Map（映射）\"和\"Reduce（归约）\"。\n\n需要注意，min和max是绝对下标，即要排序的整个数组的下标。\n\n```c\nvoid divide_conquer(int a[], int min, int max, int b[])\n{\n    if(min >= max) return;              //终止条件\n    int mid = (max - min) / 2 + min;    //找到中间位置(奇数时左边多1个)\n    divide_conquer(a, min, mid, b);     //处理完之后，此次递归时的min~max的左半侧已经有序\n    divide_conquer(a, mid + 1, max, b); //处理完之后，此次递归时的min~max的有半侧已经有序\n    conquer(a, min, max, b);            //conquer即合并两边数组的前提是左右双边均已有序\n}\n```\n\nconquer即合并两边数组的前提是左右双边均已有序。\n\n```c\nvoid conquer(int a[], int min, int max, int b[])\n{\n    int mid = (max - min) / 2 + min;\n    int i = min;      //左半边\n    int j = mid + 1;  //右半边\n    int k = min;      //合并的新空间的下标\n    while(k <= max)\n    {\n        if(i <= mid && j <= max)//i和j都没到结尾，则需要一一比对大小\n        {\n            if(a[i] < a[j])\n            {\n                b[k] = a[i++];\n            }\n            else b[k] = a[j++];\n        }\n        else if(i > mid)        //左半侧已结束，则右半侧(j)剩下的可直接全部放入b\n        {\n            b[k] = a[j++];\n        }\n        else b[k] = a[i++];     //右半侧已结束，右半侧(i)剩下的可直接全部放入b\n        ++k;\n    }\n    // 别忘了b数组中处理完成之后还要复制一份给a数组\n    for(int k = min; k <= max; ++k)\n    {\n        a[k] = b[k];\n    }\n}\n```\n\n```c\nvoid merging_sort(int a[], int n)\n{\n    int * b = (int *)malloc(n * sizeof(a[0]));\n    divide_conquer(a, 0, n - 1, b);\n    // 无须再把b数组复制给a数组，因为再conquer过程中b数组已经复制给了a数组\n    free(b);\n}\n```\n\n# 基数排序\n\n用的少，考的少，基本上已经退出历史舞台，暂不讨论。\n# 随机数-测试用\n\n```c\n#include<stdio.h>\n#include<time.h>\n#define SIZE 13\nvoid show(int * arr, int len)\n{\n    for(int i = 0; i < len; ++i)\n    {\n        printf(\"%i  \", arr[i]);\n    }\n    printf(\"\\n\");\n}\nbool isSort(int * arr, int len)\n{\n    for(int i = 0; i < len - 1; ++i)\n    {\n        if(arr[i] > arr[i + 1])\n            return false;\n    }\n    return true;\n}\nint main()\n{\n    int arr[SIZE] = { 0 };\n    // 设置一个随即因子\n    srand((unsigned)(time(NULL)));\n    for(int i = 0; i < SIZE; ++i)\n    {\n        arr[i] = rand() % 100;\n    }\n    show(arr, SIZE);  //展示原始数据\n    XXX(arr);         //调用排序算法\n    show(arr, SIZE);  //展示排后数据\n    if(isSort(arr, SIZE))\n        printf(\"数据已经完全有序\\n\");\n    else printf(\"数据无序\\n\");\n}\n```\n\n# 为何快速排序和归并排序很重要\n\n因为这两个算法可以把整个数据进行划分，所以可以使用多线程处理划分的任务，处理完后，最后再用一个主线程处理所有数据。这是可划分算法的优势。","categories":["算法","排序"]},{"title":"Cpp_继承和多态","url":"/Cpp/Cpp_继承和多态/","content":"\n# 内容\n\n# 引入\n\n类与类之间的关系：\n\n组合/嵌套：一个类中声明了另一个类，是属于的关系。一个类是另一个类的一部分。\n\n代理：一个类的接口是另一个类接口的子集\n\n继承：fish--goldFish\n\n# 隐藏\n\n子类会隐藏父类的同名成员。----同名隐藏\n\n访问被隐藏的成员需要加上（父类）作用域。\n\n# 动多态\n\n产生：使用指针或者引用调用虚函数，就会产生动多态调用\n\n动多态调用的过程：\n\n1. 使用指针或者引用调用虚函数\n2. 在对象中找到vfptr\n3. 根据vfptr找到vftable\n4. 在vftable中找到要调用的函数\n5. 调用\n\nvftable\n\n编译时期如果发现类中有虚函数，就会对这个类生成vftable（虚函数表）。将当前\n\n# 面试\n\n1. 父子类/组合类的构造顺序\n   1. 先构造父类，再构造子类。\n   2. 先构造内部类，再构造大类。\n2. 类的编译顺序：\n   1. 编译类名\n   2. 编译成员名=====编译嵌套类\n   3. 编译成员方法体\n3. 什么是多态\n   1. 面向对象方法学中，派生类继承基类后表现出来的形式叫多态。这个形式为在基类的行为基础上又派生出各自派生类的特性\n4. 动多态的产生条件\n   1. 父类有虚函数\n5. 动多态的过程\n   1. 子类继承父类时，拷贝父类虚函数表，覆盖虚函数表中的同名方法。\n   2. 在调用子类方法时，如果发现其是虚函数，则由虚函数表指针找到虚函数表，查出函数指针，调用继承或重写的方法。\n6. vftable什么时候产生？在哪里存储？\n   1. 在构造子类前，构造父类时产生。在内存的只读数据段中存储。\n7. 构造函数能不能写成虚函数\n   1. 不能，因为调用虚函数需要去构造好的对象中找虚函数表指针。但是他还没构造出来。\n8. 静态函数能不能写成虚函数\n   1. 静态函数属于类的函数，理论上可以被定义为虚函数并继承。\n9. 析构函数能不能写成虚函数\n   1. 可以，并且在运用多态时，常用。\n10. 虚函数能不能被处理为内联\n    1. 不能。内联是在编译期代码段展开，而动多态是在运行时。\n11. 什么情况下析构函数必须写成虚函数\n    1. 父类指针指向子类对象\n12. 父类指针能不能指向子类对象？子类指针能不能指向父类对象？\n    1. 前者可以，后者不可。\n13. 什么是RTTI？在什么时候产生？存储在哪里？\n14. 父类指针如何转化为子类指针？转化有什么条件？\n15. 什么是菱形继承？菱形继承有什么问题？如何解决？\n16. 纯虚函数有什么作用？\n17. 隐藏\n18. 覆盖\n\n## 答案\n\n1. \n   1. 静多态\n      1. 编译时期的多态，又被称为早绑定\n      2. 代表：函数重载、模板\n   2. 动多态\n      1. 运行时期的多态，又被称为晚绑定\n      2. 代表：继承中的多态\n\n2. \n   1. 编译类名\n   2. 编译成员名=====编译嵌套类\n   3. 编译成员方法体\n\n3. \n4. \n   1. 指针或引用调用虚函数 + 对象必须完整\n   2. 完整对象：构造函数执行完毕，虚构函数还没开始\n\n5. \n   1. 使用指针或者引用调用虚函数\n   2. 在对象中找到vfptr\n   3. 找到vftable\n   4. 在表中找到对应的函数\n\n6. \n   1. 编译期产生\n   2. 放在rodata区\n\n7. \n   1. 不能，构造函数无法通过指针或者引用调用，写成虚函数没有意义。\n   2. vfptr是在构造时才写入对象，而调用虚构造函数时没有对象构造出来。\n\n8. 不能，因为静态函数不依赖于对象。\n\n10. \n    1. 不能。已内联的函数在编译期代码段展开，在release版本没有地址。\n\n11. 父类指针指向堆上的子类对象时，必须把父类的虚构函数写为虚函数。\n\n13. \n    1. runtime type info，是一个指向类型信息的指针。\n    2. 编译期产生，RTTI指针放在vftable里面，类型信息放在rodata段。\n\n14. ```cpp\n    Derive* pd = dynamic_cast<Derive*>(p);\n    dynamic_cast : 父类指针转为子类指针专用的类型强转\n    要求：\n        1.必须有RTTI\n        2.父类指针指向的对象中的RTTI确实是子类类型。\n    ```\n\n15. \n\n17. 子类中的成员会隐藏父类中同名的成员。\n18. 子类中的成员方法会覆盖父类中相同（同返回值、参数列表（因为函数指针的类型要相同））的虚函数。\n\n# 菱形继承\n\n1. 菱形继承引入的问题\n   1. 造成公共父类在子对象中存在多个实例\n2. 菱形继承的解决\n   1. 虚继承\n3. PowerShell中命令查看类的构造\n   1. `cl /d1 report Single Class Layout D(要查看结构的类名) ./main.cpp > 1.txt`\n\n# 虚继承\n\n1. 虚继承的逻辑\n   1. 被虚继承的类会变成虚基类\n   2. 虚基类在子类对象中存放在vbtable中\n   3. 原本应该存储该父类对象的位置上替换为vbptr\n   4. vbptr指向vbtable中虚基类实例的位置，从而保证虚基类在子类中只会有一个实例的存在\n   5. 注意：虚基类在子类构造时候会被当做直接父类进行构造（子类的初始化列表需要加虚基类的初始化）\n\n# 抽象类\n\n1. 有纯虚函数的类叫抽象类\n2. \n\n# 隐藏和重写\n\n“隐藏”是比“重写”更重要的法则。“重写”虚函数需要函数同名，必定要遵守“隐藏”法则，这不意味着我们不能调用被隐藏的基类函数，“虚”的意义正是要通过另一种工具——虚表指针来找出隐藏的基类函数。\n\n```c++\n#include<iostream>\nusing namespace std;\nclass Object\n{\n\tint value;\npublic:\n\tObject(int x = 0) : value(x) {}\n\tvirtual void add() { cout << \"O:add\" << endl; }\n\tvirtual void fun() { cout << \"O:fun\" << endl; }\n};\nclass Base : public Object\n{\nprivate:\n\tint num;\npublic:\n\tBase(int x = 0) : num(x + 10) {}\n\tvirtual void add() { cout << \"B:add\" << endl; }\n\tvirtual void fun(int x) { cout << \"B:fun(int)\" << endl; }\n};\nint main()\n{\n\tBase base(10);\n/*\t'op', 'bp' actually point to a 'Base' instance. \n\tThere are 'B:add()', 'O:fun()', 'B:(int)' in this instance's vft*/\n\tObject* op = &base;\n\tBase* bp = &base;\n\top->add();\t\t//O:add()\n\top->fun();\t\t//O:fun()\n/*\top->fun(133);*/\t//complie error! 'op' is a 'Object' poniter, 'Object' class not has fun(int)\n\n\tbp->add();\t\t//B:add()\t->\toveride the O:add()\n/*\tbp->fun();*/\t//compile error! 'bp' is a 'Base' poniter, though it's vft has the O:fun(), but O:fun() is hidden by B:fun(int)\n\tbp->fun(233);\t//B:fun(int)->\thide\tthe O:fun()\n    \n\t//compile error! 'op' stated a 'Base' poniter, though it's vft has the O:fun(), but O:fun() is hidden by B:fun(int)\n/*\tdynamic_cast<Base*>(op)->fun();\t*/\n    \n    //ok! 'op' is a 'Object' poniter, it's vft not has the 'B:fun(int)'\n\tdynamic_cast<Base*>(op)->fun(1);\n    \n    \n    //ok! Here explicitly stated 'bp' a 'Object' pointer, now compiler feels 'O:fun()' instead of being hidden.\n\tdynamic_cast<Object*>(bp)->fun();\n    \n    //compile error! 'bp' stated a 'Object' pointer, now compiler think the 'bp' not has the 'fun(int)' function.\n/*\tdynamic_cast<Object*>(bp)->fun(2);*/\n\n}\n```\n\n","categories":["Cpp"]},{"title":"Cpp_返回值","url":"/Cpp/Cpp_返回值/","content":"# 内容\n![image-20211107095730498](../../images/返回值/image-20211107095730498.png)\nGetValue返回的是临时变量副本，由寄存器作为传递媒介。\n1. a1可以。因为调用的是public函数。但是得到的是经过寄存器赋值拿到的副本。\n2. 应该不可以，因为返回值是一个将亡值，不能对其进行普通引用。\n3. 猜测可以对将亡值进行常引用。\n## 2\n![image-20211107101017513](../../images/返回值/image-20211107101017513.png)\n## 3\n![image-20211107102226241](../../images/返回值/image-20211107102226241.png)\n## 4\n\n![image-20211107103310102](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211107103310102.png)\n## 5\n\n![image-20211107112403421](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211107112403421.png)\n## 6\n\n![image-20211107114851729](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211107114851729.png)\n## 7\n\n![image-20211114192200476](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211114192200476.png)\n\n`Test ta(10)`一个Int\n\n1. √--编译器优化，直接拷贝构造，一个Int\n2. √--没产生\n3. √--没产生\n4. ×\n5. ×\n6. √--没产生\n7. √--没产生\n8. √--没产生\n## 8\n\n![image-20211114195324558](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211114195324558.png)\n\n1. √\n2. ×\n3. √\n4. ×\n5. ×\n6. ×\n7. √\n8. ×\n9. √\n## 9\n\n![image-20211114201105648](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211114201105648.png)\n## 10\n\n![image-20211114203355621](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211114203355621.png)\n\n1. √\n2. √\n3. √\n4. b1：指针的临时量也算是一个将亡值\n5. p1：√\n6. p2：√\n7. p3：√\n8. p4：√\n## 11\n\n![image-20211114204142437](../../images/%E8%BF%94%E5%9B%9E%E5%80%BC/image-20211114204142437.png)\n\n1. a1：√\n2. a2：×\n3. a3：√\n4. b1：？，×，必须在b1的Int前加const\n5. p1：×\n6. p2：√\n7. p3：×\n8. p4：√","categories":["Cpp"]},{"title":"Linux_进程间通信(IPC)","url":"/Linux/Linux_进程间通信(IPC)/","content":"\n# 内容\n\n1. 管道\n2. 信号量\n3. 共享内存\n4. 消息队列\n5. 套接字\n\n2-4比较正式。如果填空只有三个空，填2-4。\n\n# 管道\n\n管道文件是在内存中分配空间。\n\n读端r，写端w。\n\n分两种，有名管道、无名管道。\n\n## 有名管道\n\n```bash\nmkfifo fifo#mkfifo [名字]\n#prw-rw-r-- 1 stu stu 0 fifo\nmkfifo()\n```\n\n```c\n//写端程序\n#include<stdlib.h>\n#include<unistd.h>\n#include<string.h>\n#include<assert.h>\n#include<fcntl.h>\nint main()\n{   \n    int fdw = open(\"fifo\",O_WRONLY);\n    assert(fdw!=-1);\n    printf(\"fdw=%d\\n\",fdw);\n    char buff[128] = {0};\n    fgets(buff,128,stdin);\n    write(fdw,buff,strlen(buff));\n    close(fdw);\n    exit(0);\n}\n```\n\n\n\n```c\nint main()\n{\n    int fdr = open(\"fifo\",O_RDONLY);\n    assert(fdr!=-1);\n    \n    printf(\"fdr=%d\\n\",fdr);\n    \n    char buff[128] = {0};\n    \n    read(fdr,buff,127);\n    printf(\"%s\",buff);\n    close(fdr);\n    exit(0);\n}\n```\n\n\n\n## 无名管道\n\n```bash\npipe()\n```\n\n\n\n## 总结\n\n1. 管道为空时，读会阻塞。\n\n2. 管道写满时，写会阻塞。\n\n3. 两个端口打开后，也写了一些数据，也读了一些数据，如果读完了，则管道内容变空，则读端进程阻塞。而如果写端关闭后，则读端不会再阻塞了，再接着read会返回一个零，可作为写端完毕的标志。\n\n   ```c\n   //写端\n   int main()\n   {   \n       int fdw = open(\"fifo\",O_WRONLY);\n       assert(fdw!=-1);\n       printf(\"fdw=%d\\n\",fdw);\n       while(1)\n       {\n           char buff[128] = {0};\n           printf(\"input util end:\"\\n);\n           fgets(buff,128,stdin);\n           if(strncmp(buff,\"end\",3)==0)\n           {\n               break;\n           }\n       }\n       write(fdw,buff,strlen(buff));\n       close(fdw);\n       exit(0);\n   }\n   //读端\n   int main()\n   {\n       int fdr = open(\"fifo\",O_RDONLY);\n       assert(fdr!=-1);\n       \n       printf(\"fdr=%d\\n\",fdr);\n       while(1)\n       {\n           char buff[128] = {0};\n       \tint n = read(fdr,buff,127);\n       \tif(n == 0)//n=0肯定是因为写端close了，因为没有在没写入时阻塞\n           {\n               break;\n           }\n       \tprintf(\"%s\",buff);\n       }\n       close(fdr);\n       exit(0);\n   }\n   ```\n\n4. 管道读端关闭后，写端再写入数据时，则会触发异常，则内核会给写端进程发信号。\n\n5. 面试：\n\n   1. 有名管道可以在任意两个进程间通信；无名管道只能在父子进程间使用。\n   2. 管道通信方式：半双工的。\n      1. 单工：电台从A发到B，收音机不可能给电台发数据。过程不可逆。\n      2. 半双工：跟对讲机类似。需要按下按键抢占信道。其余是听。同一时刻只能读或写。\n      3. 全双工：腾讯会议。\n   3. 写入管道的数据，在内存中。有名管道虽然能在磁盘上看到，但只是一个标识，大小是0。\n\n# 信号量\n\n目的是控制对某个临界资源的访问。\n\n## 临界资源\n\n临界资源：同一时刻只允许一个进程访问的资源\n\n临界区：访问临界资源的代码段\n\n## 取值\n\n比较特殊，只取0和正数。\n\n第一种是0，1二值信号量。\n\n第二种是计数信号量。\n\n## p,v操作\n\np，减一，代表获取资源。\n\nv，加一，代表释放资源。\n\n## 代码封装\n\n```c\n/*\n1.sem_init()\n2.sem_p()\n3.sem_v()\n4.sem_destroy()\n*/\n```\n\n# 共享内存\n\n1. 创建共享内存\n2. 将共享内存映射到进程中\n3. 断开映射\n4. 销毁共享内存\n\n# 消息队列\n\n1. 发送消息，发送两个信息，一是type，二是数据。\n2. 获取消息，获取type。\n","categories":["操作系统","多线程","Linux"]},{"title":"Linux_信号","url":"/Linux/Linux_信号/","content":"# 信号\n\n也叫软中断。\n\n通知进程发生了某个事件。\n\n# signal\n\n![image-20211030101557246](../../images/%E4%BF%A1%E5%8F%B7/image-20211030101557246.png)\n\nsignal第一个参数，信号代号。第二个参数，信号处理函数入口地址。\n\n默认：SIG_DFL；忽略：SIG_IGN。\n\n```c\n//默认：SIG_DFL；忽略：SIG_IGN。\n(void (*)0)\n```\n\n\n\n```c\n//以下程序把原有的SIGINT信号处理方式改为了我们自定义的函数。\nvoid sig_fun(int sig)\n{\n    printf(\"sig=%d\\n\",sig);\n}\nint main()\n{\n    signal(SIGINT, sig_fun);//只是做了一个约定。没有去调用sig_fun函数。等到信号出现才去调用。\n    while(1)\n    {\n        printf(\"hello\\n\");\n        sleep(1);\n    }\n}\n```\n\n","categories":["操作系统","多线程","Linux"]},{"title":"2021年10月面试","url":"/面试经验/2021年10月面试/","content":"\n# 1029\n\n第一道题，结构体对齐的规则。\n第二大题，实现一个宏，计算结构体成员的相对偏移量。\n第三道题，结构体和共用体的区别。\n第四道题，编写程序完成，int变量的小端存储转换成大端存储。\n第五道题，说一下用户存储空间都有哪几个区构成？回答一下，栈区和堆区的区别。\n第六道题，代码实现打印N行杨辉三角。不得使用二维数组，可以使用一维数组。\n第七道题，快排，堆排，归并排序，任选一道实现代码。\n第八道题，谈谈顺序表和链表的区别，以及适用的场景。\n第九道题，实现不带头节点单链表的逆置。\n\n# 1\n\n结构体对齐的规则。\n\n## 我答的\n\n1. ~~所有成员地址相对结构体~~首地址的偏移量要可以被成员的基本数据类型大小整除。计算sizeof时，首地址默认为0，所以都满足相对首地址可整除。\n2. 各个成员依次从上到下都要相对于前一个成员的首地址偏移量被下一个成员基本数据类型大小整除。\n3. 最后，结构体的大小要可以被该结构体内最大的成员基本数据类型大小整除。\n\n## 答案\n\n1. 结构体变量的首地址，必须是结构体变量中的“最大基本数据类型成员所占字节数”的整数倍。计算sizeof时，首地址默认为0，所以满足相对首地址可整除。\n2. 结构体变量中，相对于**结构体首地址**，**每个成员**的**偏移量**，都是**成员本身基本数据类型**所占字节数的整数倍。我们可以依次从上到下累计已计算的大小，再看下一某位置是否是其整数倍。\n3. 结构体变量的总大小，为结构体变量中 “最大**基本数据类型**成员所占字节数”的整数倍。\n\n## #pragma pack指定对齐值\n\n预处理指令#pragma pack(n) 可以改变默认对齐数。n 取值是 1, 2, 4, 8 , 16。\nvs 中默认值 = 8，gcc 中默认值 = 4；\n\n```c\n#pragma pack(1)\nstruct node\n{\n    char cha;\n    double dx;\n    char chb;\n};\n//若( )内为1->size:10;\n//\t\t为2->\t12;\n//\t\t为4->\t16;\n//\t\t为8->\t24;\n//\t\t为16->\t24;\n#pragma pack\n```\n\n## 加入指定对齐方式的终极总结\n\n1. 结构体变量的首地址，必须是MIN{“结构体**最大基本数据类型成员**所占字节数”, 指定对齐方式}的整数倍。\n2. 结构体中，相对于结构体首地址，每个成员的偏移量，都是MIN{该基本数据类型成员, 指定对齐方式}的整数倍。\n3. 结构体的总大小，为MIN{结构体最大基本数据类型成员所占字节数, 指定对齐方式}的整数倍。\n\n# 2\n\n实现一个宏，计算结构体成员的相对偏移量。\n\n```c\n#define offset(type,member) (int)&( ( (type*)0 ) ->member)\n```\n\n# 3\n\n结构体和共用体的区别。\n\n然后让你判断大小端或者对数据转换\n\n# 4\n\n编写程序完成，int变量的小端存储转换成大端存储。\n\n# 5\n\n说一下用户存储空间都有哪几个区构成？回答一下，栈区和堆区的区别。\n\n代码区、数据区、堆区、栈区\n\n1) 管理方式：栈由系统自动管理；堆由程序员控制，使用方便，但易产生内存泄露。\n2) 生长方向：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于堆区管理系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。\n3) 空间大小：栈顶地址和栈的最大容量由系统预先规定(通常默认1M 或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32 位Linux 系统中堆内存可达2.9G 空间。\n4) 存储内容：\n    1) 栈在函数调用时，首先压入是函数实参，然后主调函数中下条指令(函数调用语句的下条可执行语句)的地址压入，最后是被调函数的局部变量。本次调用结束后，局部变量先出栈，指令地址出栈，最后栈平衡，程序由该点继续运行下条可执行语句。\n    2) 堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。\n5) 分配方式：\n    1) 栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloc函数在栈上申请空间，用完后自动释放不需要调动free函数。\n    2) 堆只能动态分配且手工释放。\n6) 分配效率：\n    1) 栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。\n    2) 堆由函数库提供，机制复杂，效率比栈低得多。\n7) 分配后系统响应：\n    1) 只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。\n    2) 操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。\n    3) 此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。\n8) 碎片问题：\n    1) 栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。\n    2) 而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。\n    3) 可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，**仅在分配大量或大块内存空间时使用堆**。\n    4) 最后使用栈和堆时应避免越界发生，否则可能程序崩溃或破坏程序堆、栈结构，产生意想不到的后果。\n# 6\n\n代码实现打印N行杨辉三角。不得使用二维数组，可以使用一维数组。\n\n```c\nint ar[100] = { 0,1 };\t//初始化数组\nint n, i, j;\nint l, r;\t//存放上一层左边的数和右边的数\nn = 10;\t\t//层数\nfor (i = 1; i <= n; i++)\n{\n    l = 0;\n    for (j = 1; j <= i; j++)\n    {\n        r = ar[j];\t\t\t\t//面试题空白处\n        ar[j] = l + r;\t\t\t//面试题空白处\n        printf(\"%-4d\", ar[j]);\n        l = r;\n    }\n    printf(\"\\n\");\n}\n```\n\n\n\n# 7\n\n快排，堆排，归并排序，任选一道实现代码。\n\n# 8\n\n谈谈顺序表和链表的区别，以及适用的场景。\n\n# 9\n\n实现不带头节点单链表的逆置。\n\n","categories":["面试经验"]},{"title":"Cpp_Mstring_迭代器","url":"/Cpp/Cpp_Mstring_迭代器/","content":"# 迭代器\n\n可以理解为，指向容器内部数据的一个指针。本质是对象。\n\n```cpp\n#include<vector>\nint main()\n{\n    vector<int> v1;\n    for(int i = 0;i<10;i++)\n    {\n        v1.push_back(i);\n    }\n    vector<int>::iterator it1 = v1.begin();\n    for(;it1!=v1.end();it1++)\n    {\n        cout << \n    }\n}\n```\n\n# Mstring_iterator\n\n```cpp\n//mstring_iterator.h\n//begin end insert erase\n#ifndef MSTRING_ITERATOR_H\n#define MSTRING_ITERATOR_H\nclass Mstring;\n\nclass Mstring_iterator\n{\npublic:\n\tMstring_iterator(Mstring& mstr, int pos)\n        :_mstr(mstr), _pos(_pos)\n    {\n        \n    }\n    Mstring_iterator(const Mstring_iterator& src)\n        :_mstr(src._mstr), _pos(src._pos)\n    {\n        \n    }\n    Mstring_iterator& operator=(const Mstring_iterator& src)\n    {\n        if(&_mstr != &src._mstr)\n        {\n            return *this;\n        }\n        _pos = src._pos;\n        return *this;\n    }\n    \n    bool operator !=(const Mstring_iterator& src)\n    {\n        if(&_mstr != &src._mstr || _pos != src._pos)//不是一个字符串或没有指向同一位置\n        {\n            return true;\n        }\n        return false;\n    }\n    bool operator ==(const Mstring_iterator& src)\n    {\n        if(&_mstr == &src._mstr && _pos == src._pos)//不是一个字符串或没有指向同一位置\n        {\n            return true;\n        }\n        return false;\n    }\n    Mstring_iterator& operator++()\n    {\n        _pos++;\n        return *this;\n    }\n    Mstring_iterator operator++(int)\n    {\n        int pos = _pos;\n        _pos++;\n        return Mstring_iterator(_mstr,pos);\n    }\n\n    Mstring_iterator& operator--()\n    {\n        _pos--;\n        return *this;\n    }\n    Mstring_iterator operator--(int)\n    {\n        int pos = _pos;\n        _pos--;\n        return Mstring_iterator(_mstr,pos);\n    }\n\n    char& operator*();//由于[]重载在本文件不可见，则在这里实现不可编译，我们可以在mstring.cpp进行类外实现。\nprivate:\n    Mstring& _mstr;\n    int _pos;\n}\n```\n\n# Mstring\n\n```cpp\n//mstring.h\n#ifndef MSTRING_H\n#define MSTRING_H\n#include<iostream>\n#include\"mstring_iterator.h\"\n#include<mutex>\nusing namespace std;\n\n#define MSTRING_MORE_SIZE sizeof(int)\n#define DEFEALT_LEN (10+MSTRING_MORE_SIZE)\n\nclass Mstring\n{\npublic:\n\ttypedef Mstring_iterator iterator;\n\tMstring(const char* str = NULL);\n\tMstring(const Mstring& src);\n\tMstring& operator=(const Mstring& src);\n\t~Mstring();\n\n\tvoid push_back(char c);\n\tvoid pop_back();\n\tchar back()const;\n\tchar front()const;\n\tbool empty()const;\n\tint size()const;\n\n\tMstring operator+(const Mstring& str)const;\n\tchar& operator[](int pos);\n\tchar operator[](int pos)const;\n\n\titerator begin();\n\titerator end();\n\tvoid insert(iterator it, char val);\n\tvoid erase(iterator it);\n\n\tfriend ostream& operator<<(ostream& out, const Mstring& src);\n\tfriend istream& operator>>(istream& in, Mstring& src);\nprivate:\n\tbool full()const;\n\tvoid expand();\n\tvoid init_num();\n\tint& get_num();\n\tint get_num()const;\n\tconst char* get_str_begin()const;\n\tchar* get_str_begin();\n\tvoid write_copy();\n\tint down_num();//引用计数-1\n\tint up_num();//引用计数+1\n\n\tchar* _str;//能否直接使用浅拷贝------怎么加引用计数\n\tint _len;//当前空间总长度\n\tint _val_len;//已经占用的长度，实际数据数量\n\t//static mutex* _lock;\n};\n\n#endif\n```\n\n# mstring.cpp\n\n```cpp\n#include\"mstring.h\"\n\nmutex* Mstring::_lock = new mutex();\n\nMstring::Mstring(const char* str)\n{\n\tif (NULL == str)\n\t{\n\t\t_len = DEFEALT_LEN;\n\t\t_val_len = 0;\n\t\t_str = new char[_len];\n\t\tmemset(_str, 0, _len);\n\t\tinit_num();\n\t\treturn;\n\t}\n\n\t_val_len = strlen(str);\n\n\t//加上引用计数占的空间\n\t_len = _val_len + 1 + MSTRING_MORE_SIZE;\n\t_str = new char[_len];\n\tmemset(_str, 0, _len);\n\n\tfor (int i = 0; i < _val_len; i++)\n\t{\n\t\tget_str_begin()[i] = str[i];\n\t}\n\tinit_num();\n}\n\nMstring::Mstring(const Mstring& src)\n{\n\t_val_len = src._val_len;\n\t_len = src._len;\n\t_str = src._str;\n\t//让引用计数+1\n\tup_num();\n}\n\nMstring& Mstring::operator=(const Mstring& src)\n{\n\tif (&src == this)\n\t{\n\t\treturn *this;\n\t}\n\t_val_len = src._val_len;\n\t_len = src._len;\n\t_str = src._str;\n\tup_num();\n\n\treturn *this;\n}\n\nMstring::~Mstring()\n{\n\t//将引用计数-1\n\tdown_num();\n\n\t//查看当前是否还有人引用\n\tif (0 == get_num())\n\t{\n\t\tdelete[]_str;\n\t}\n}\n\nvoid Mstring::push_back(char c)\n{\n\t//判断是否一个人独有\n\tif (get_num() > 1)\n\t{\n\t\t//写时拷贝，给分配独有的空间\n\t\twrite_copy();\n\t}\n\n\tif (full())\n\t{\n\t\texpand();\n\t}\n\n\tget_str_begin()[_val_len] = c;\n\t_val_len++;\n}\n\nvoid Mstring::pop_back()\n{\n\tif (get_num() > 1)\n\t{\n\t\twrite_copy();\n\t}\n\n\tif (empty())\n\t{\n\t\treturn;\n\t}\n\n\t_val_len--;\n}\n\nchar Mstring::back()const\n{\n\tif (empty())\n\t{\n\t\treturn 0;\n\t}\n\n\treturn get_str_begin()[_val_len - 1];\n}\n\nchar Mstring::front()const\n{\n\tif (empty())\n\t{\n\t\treturn 0;\n\t}\n\n\treturn get_str_begin()[0];\n}\n\nbool Mstring::empty()const\n{\n\treturn _val_len == 0;\n}\n\nMstring Mstring::operator+(const Mstring& str)const\n{\n\tchar* p;\n\tint len = _val_len + str._val_len + 1;\n\tp = new char[len];\n\tmemset(p, 0, len);\n\n\t//进行数据拷贝-----将两个字符串的数据拼接起来\n\tint i = 0;\n\tfor (; i < _val_len; i++)\n\t{\n\t\tp[i] = get_str_begin()[i];\n\t}\n\n\tfor (int j = 0; j < str._val_len; j++, i++)\n\t{\n\t\tp[i] = str.get_str_begin()[j];\n\t}\n\n\treturn p;\n}\n\nchar& Mstring::operator[](int pos)\n{\n\tif (get_num() > 1)\n\t{\n\t\twrite_copy();\n\t}\n\treturn  get_str_begin()[pos];\n}\n\nchar Mstring::operator[](int pos)const\n{\n\treturn  get_str_begin()[pos];\n}\n\nbool Mstring::full()const\n{\n\treturn _val_len == _len - 1 - MSTRING_MORE_SIZE;\n}\n\nvoid Mstring::expand()\n{\n\tif (get_num() > 1)\n\t{\n\t\twrite_copy();\n\t}\n\n\t_len = _len << 1;\n\n\tchar* p = new char[_len];\n\tmemset(p, 0, _len);\n\n\tfor(int i = 0;i<_val_len+MSTRING_MORE_SIZE;i++)\n\t{\n\t\tp[i] = _str[i];\n\t}\n\n\tif (down_num() == 0)\n\t{\n\t\tdelete[]_str;\n\t}\n\n\t_str = p;\n}\n\nint Mstring::size()const\n{\n\treturn _val_len;\n}\n\n//初始化引用计数\nvoid Mstring::init_num()\n{\n\tget_num() = 1;\n}\n\n//获取引用计数\nint& Mstring::get_num()\n{\n\treturn *((int*)_str);\n}\n\n//引用计数-1\nint Mstring::down_num()\n{\n\t_lock->lock();\n\tint num = --get_num();\n\t_lock->unlock();\n\treturn num;\n}\n\n//引用计数+1\nint Mstring::up_num()\n{\n\t//get_lock()->lock();\n\t_lock->lock();\n\t/*\n\twhile(1)\n\t{\n\t\tif(_lock->a == 0)\n\t\t{\n\t\t\t_lock->a = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsleep(10);\n\t}\n\t\n\t*/\n\tint num = ++get_num();\n\t_lock->unlock();\n\t/*\n\t_lock->a = 0;\n\t*/\n\n\treturn num;\n}\n\n\n//获取引用计数\nint Mstring::get_num()const\n{\n\treturn *((int*)_str);\n}\n\n//获取字符串的开头指针\nchar* Mstring::get_str_begin()\n{\n\treturn _str + MSTRING_MORE_SIZE;\n}\n\n//获取字符串的开头指针\nconst char* Mstring::get_str_begin()const\n{\n\treturn _str + MSTRING_MORE_SIZE;\n}\n\n//写时拷贝\nvoid Mstring::write_copy()\n{\n\tchar* p = new char[_len];\n\n\t//将所有的数据全部拷贝过来\n\tfor (int i = 0; i < _len; i++)\n\t{\n\t\tp[i] = _str[i];\n\t}\n\n\t//改变原来指向的内存的引用计数\n\tif (0 == down_num())\n\t{\n\t\tdelete[]_str;\n\t}\n\n\t//将当前引用计数改为1\n\t_str = p;\n\tinit_num();\n}\n\nostream& operator<<(ostream& out, const Mstring& src)\n{\n\tfor (int i = 0; i < src.size(); i++)\n\t{\n\t\tout << src.get_str_begin()[i];\n\t}\n\tout << \"     :::::num:::\" << src.get_num();\n\tout << endl;\n\treturn out;\n}\n\nistream& operator>>(istream& in, Mstring& src)\n{\n\tif (src.get_num() > 1)\n\t{\n\t\tsrc.write_copy();\n\t}\n\n\tchar tmp[1024];\n\tin >> tmp;\n\t\n\tsrc = tmp;\n\treturn in;\n}\n\n////////////////////////////////迭代器\n\niterator Mstring::begin()\n{\n    return iterator(*this, 0);\n}\n\niterator Mstring::end()\n{\n    return iterator(*this, _val_len);\n}\niterator Mstring::insert(iterator it, char val) \n{\n    //判断是否独有\n    if (get_num() > 1)\n    {\n        write_copy();\n    }\n\n    //扩容\n    if (full())\n    {\n        expand();\n    }\n\n    iterator it1 = end();\n    iterator it2 = it1 - 1;\n\n    for (; it1 != it; it1--, it2--)\n    {\n        *it1 = *it2;\n    }\n    *it = val;\n    _val_len++;\n\n    return it;\n}\niterator Mstring::erase(iterator it)\n{\n    //判断是否独有\n    if (get_num() > 1)\n    {\n        write_copy();\n    }\n\n    //判空\n    if (empty())\n    {\n        return it;\n    }\n\n    iterator it1 = it;\n    iterator it2 = it + 1;\n    for (; it2 != end(); it1++, it2++)\n    {\n        *it1 = *it2;\n    }\n\n    _val_len--;\n    return it;\n}\n\n\nchar& Mstring_iterator::operator*()\n{\n\treturn _mstr[_pos];\n}\n```\n\n# test\n\n```cpp\nint main()\n{\n    Mstring s1 = \"123456\";\n    Mstring::iterator it = s1.begin();\n    for(; it != s1.end(); it++)\n    {\n        cout << *it << \" \";\n        \n    }\n    cout << endl;\n}\n```\n\n# vector\n\n通过迭代器进行增删改查。\n\n# 分类\n\n1. 顺序迭代器\n    1. `iterator`是正向迭代器\n    2. `reverse_iterator`是反向迭代器\n    3. `const_iterator`是常量正向迭代器\n    4. `const_reverse_iterator`是常量反向迭代器\n2. 插入型迭代器\n    1. `insert_iterator`是随机插入迭代器，内部调用的是`insert`\n    2. `back_insert_iterator`是尾插迭代器，调用的是`push_back`\n    3. `front_insert_iterator`是头插迭代器，调用的是`push_front`\n3. 流迭代器\n\n# 顺序迭代器\n\n```cpp\n//正向迭代打印\ntemplate<class T>\nvoid print(T & obj)\n{\n\ttypename T::iterator it = obj.begin();\n\tfor (; it != obj.end();it++)\n\t{\n\t\tcout << *it << \" \";\n\t}\n\tcout << endl;\n}\n//反向迭代打印\ntemplate<class T>\nvoid r_print(T& obj)\n{\n\ttypename T::reverse_iterator it = obj.rbegin();\n\tfor (;it != obj.rend();it++)\n\t{\n\t\tcout << *it << \" \";\n\t}\n\tcout << endl;\n}\n```\n\n","categories":["Cpp"]},{"title":"Cpp_new_delete重载","url":"/Cpp/Cpp_new_delete重载/","content":"# 内容\n\n# new的动作\n\nnew是关键字。其实是new operator，本身不可重载。\n\n1. 申请内存\n    1. new第一步的申请内存调用的是operator new(可看作一个运算符函数)，可以重载。\n2. 调用构造\n3. 返回地址\n# delete的动作\n\ndelete是关键字。其实是delete operator，本身不可重载。\n\n1. 调用析构\n2. 内存释放\n    1. delete内存释放调用的是operator delete(可看作一个运算符函数)，可以重载。\n# operator new重载\n```cpp\nvoid* operator new(size_t size)\n{\n    void* p = malloc(size);\n    cout << \"调用了自定义operator new\" << endl;\n    return p;\n}\n```\n\n有何作用？\n\n堆上内存：属于是外部资源。\n\n申请/释放外部资源，用户态没有权限访问，内核态才有权限。外部资源很多，比如我们的鼠标、键盘、屏幕。\n\n我们申请/释放资源的过程需要内核态完成，此时，需要从用户态切换到内核态，再做**系统调用**。\n\n平时接触的系统调用有很多，比如：cout、printf、cin、scanf\n\n应运而生，会出现内存池的概念。`C++`自带的内存池：`_Alloc`\n\n内存池是：用户态自己维护的**一大段**内存。\n\n重载new和delete相当于留下了一个可修改的端口，可以**自定义申请、释放内存的动作**。这就是重载new和delete的意义所在。\n比如，可以自己编写malloc把内存分配到显存中。除了在改变分配内存的不同设备，还可以在这里面进行内存分配动作的统计、标记等，常用于游戏开发、内存池。\n\n但是要知道，`C++`只允许把分配内存的任务交给程序员自定义，没有开放在重载new中调用构造函数的权限。\n# operator delete重载\n\n```cpp\nvoid operator delete(void* p)\n{\n    cout << \"调用了自定义operator delete\" << endl;\n    free(p);\n}\n```\n# \n```cpp\n#include<iostream>\nusing namespace std;\nclass Tmp\n{\npublic:\n\tTmp()\n\t{\n\t\tcout << \"Tmp()\" << endl;\n\t}\n\t~Tmp()\n\t{\n\t\tcout << \"~Tmp()\" << endl;\n\t}\n\tvoid* operator new(size_t size)\n\t{\n\t\tvoid* p = malloc(size);\n\t\tcout << \"调用了operator new\" << endl;\n\t\treturn p;\n\t}\n\tvoid operator delete(void* p)\n\t{\n\t\tcout << \"调用了operator delete\" << endl;\n\t\tfree(p);\n\t}\n};\nint main()\n{\n\tTmp* p = new Tmp();\n\n}\n```\n# 作业\n\n1. mstring三种：普通的、写时拷贝的、迭代器的\n2. 刷题\n# 区别\n\n1. new是关键字。malloc是函数；\n```c++\nint * p = new int(10);\nint * s = (int*)malloc(sizeof(int));\n```\n2. new不需要类型转换，malloc需要强转\n3. new自动计算类型大小，malloc需要sizeof\n4. new先malloc，再构造，再返回指针。malloc只申请内存\n5. 申请空间失败时\n    1. new抛出`std::bad_malloc`\n    2. malloc返回NULL\n6. new可以申请一组，需要`new[]`,`delete[]`。而malloc必须手动指明字节数，free不知道释放的是不是一组。\n7. 对于内置类型、POD类型，new/malloc可以混用；对于自定义类型能否混用？主要看类型中有没有析构函数，如果有，在`new[]`时会记录申请了多少对象，于是在`delete[]`时可以自动溯源。\n8. new是运算符，可以进行重载；malloc则不行\n9. new有三种调用方式；malloc没有\n10. new可以设置`nothrow`不抛异常，返回NULL\n11. `set_new_handler`","categories":["Cpp"]},{"title":"Cpp_封装BigNum实现大数加减","url":"/Cpp/Cpp_封装BigNum实现大数加减/","content":"\n# bignum.h\n\n```cpp\n//bignum.h\n#pragma once\n#include<iostream>\nusing namespace std;\nclass BigNum\n{\npublic:\n\tBigNum();\n\tBigNum(int);\n\tBigNum(const char*);\n\tBigNum(string);\n\tBigNum(const BigNum& src);\n\tBigNum operator=(const BigNum& src);\n\tBigNum operator+(const BigNum& src);\n\tBigNum operator-(const BigNum& src);\n\n\tBigNum& operator++();\n\tBigNum operator++(int);\n\tBigNum& operator--();\n\tBigNum operator--(int);\n\n\tfriend ostream& operator<<(ostream& out, const BigNum& src);\n\tfriend istream& operator>>(istream& in, BigNum& des);\n\tfriend void show_bignum(BigNum& src);\nprivate:\n\tstring _num;\n};\n\n```\n\n# bignum.cpp\n\n```cpp\n//bignum.cpp\n#include\"bignum.h\"\n#include<string>\nint num_digits(int n)\n{\n\tint i = 0;\n\twhile (n != 0)\n\t{\n\t\ti++;\n\t\tn /= 10;\n\t}\n\treturn i;\n}\nint num_string(const char* s)\n{\n\tint i = 0;\n\tconst char* p = s;\n\twhile (*p != 0)\n\t{\n\t\ti++;\n\t\tp++;\n\t}\n\treturn i;\n}\nvoid swap(char* a, char* b)\n{\n\tchar tmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\nvoid reverse(char* s, int front, int tail)\n{\n\tfor (int i = front; i < (tail - front+1) / 2;++i)\n\t{\n\t\tswap(&s[i], &s[tail - front - i]);\n\t}\n\treturn;\n}\nvoid show_bignum(BigNum& src)\n{\n\tconst char* p = src._num.data();\n\tint n = src._num.length();\n\tfor (int i = n - 1;i >= 0;i--)\n\t{\n\t\tprintf(\"%c\", p[i]);\n\t}\n\tprintf(\"\\n\");\n}\nBigNum::BigNum()\n\t:_num()\n{\n\n}\nBigNum::BigNum(int n)\n{\n\tint i = num_digits(n);\n\tchar* tmp = new char[i+1];\n\t_itoa_s(n,tmp,i+1,10);\n\treverse(tmp, 0, i - 1);\n\t_num.append(tmp);\n}\nBigNum::BigNum(const char* s)\n{\n\tint i = num_string(s);\n\tchar* tmp = new char[i + 1];\n\tconst char* p = s;\n\ti = 0;\n\twhile (*p != 0)\n\t{\n\t\ttmp[i++] = *p++;\n\t}\n\ttmp[i] = 0;\n\treverse(tmp, 0, i - 1);\n\t_num.append(tmp);\n}\nBigNum::BigNum(string s)\n{\n\tint i = s.length();\n\tchar* tmp = new char[i + 1];\n\tconst char* p = s.data();\n\ti = 0;\n\twhile (*p != 0)\n\t{\n\t\ttmp[i++] = *p++;\n\t}\n\ttmp[i] = 0;\n\treverse(tmp, 0, i - 1);\n\t_num.append(tmp);\n}\nBigNum::BigNum(const BigNum& src)\n{\n\tint i = src._num.length();\n\tchar* tmp = new char[i + 1];\n\tconst char* p = src._num.data();\n\ti = 0;\n\twhile (*p != 0)\n\t{\n\t\ttmp[i++] = *p++;\n\t}\n\ttmp[i] = 0;\n\t//reverse(tmp, 0, i - 1);\n\t_num.append(tmp);\n}\nBigNum BigNum::operator=(const BigNum& src)\n{\n\tif (this == &src)\n\t{\n\t\treturn *this;\n\t}\n\t_num.clear();\n\t_num.append(src._num);\n\treturn *this;\n}\nBigNum BigNum::operator+(const BigNum& src)\n{\n\tint i = 0;\n\tstring long_s, short_s;\n\tif (_num.length() >= src._num.length())\n\t{\n\t\tlong_s = _num, short_s = src._num;\n\t}\n\telse\n\t{\n\t\tlong_s = src._num, short_s = _num;\n\t}\n\tconst char* p1 = long_s.data();\n\tconst char* p2 = short_s.data();\n\tchar* new_s = new char[long_s.length() + 1 + 1]();\n\tchar* p = new_s;\n\tint tmp_10 = 0;\n\twhile (*p1 != 0 && *p2 != 0)\n\t{\n\t\ttmp_10 = (*p1 & 15) + (*p2 & 15) + (*p & 15);\n\t\t*p = (tmp_10 % 10) | (0b00110000);\n\t\t*(p + 1) = (tmp_10 / 10) | (0b00110000);\n\t\tif (i == long_s.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp2++;\n\t\tp++;\n\t\ti++;\n\t}\n\twhile (i != long_s.length())\n\t{\n\t\ttmp_10 = (*p & 15) + (*p1 & 15);//p1、p2为\\0或有效值，不影响结果。\n\t\t*p = (tmp_10 % 10)|(0b00110000);\n\t\t*(p + 1) = (tmp_10 / 10) | (0b00110000);\n\t\tif (i == long_s.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp++;\n\t\ti++;\n\t}\n\ti = new_s[long_s.length()] == '0' ? long_s.length() : long_s.length() + 1;\n\treverse(new_s, 0, i - 1);\n\treturn string(new_s);\n}\nBigNum BigNum::operator-(const BigNum& src)\n{\n\tint i = 0;\n\tstring long_s, short_s;\n\tif (_num.length() >= src._num.length())\n\t{\n\t\tlong_s = _num, short_s = src._num;\n\t}\n\telse\n\t{\n\t\tlong_s = src._num, short_s = _num;\n\t}\n\tconst char* p1 = long_s.data();\n\tconst char* p2 = short_s.data();\n\tchar* new_s = new char[long_s.length() + 1]();\n\tchar* p = new_s;\n\tint tmp_10 = 0;\n\tint tmp_2 = 0;\n\twhile (*p1 != 0 && *p2 != 0)\n\t{\n\t\ttmp_10 = (*p1 & 15) - (*p2 & 15) - (~(*p)+1);\n\t\t*p = ((tmp_10 + 10) % 10 ) | (0b00110000);\n\t\t*(p + 1) = ((tmp_10-9) / 10);\n\t\tif (i == long_s.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp2++;\n\t\tp++;\n\t\ti++;\n\t}\n\twhile (i != long_s.length())\n\t{\n\t\ttmp_10 = (*p1 & 15) - (~(*p) + 1);//p1、p2为\\0或有效值，不影响结果。\n\t\t*p = ((tmp_10 + 10) % 10) | (0b00110000);\n\t\t*(p + 1) = ((tmp_10 - 9) / 10);\n\t\tif (i == long_s.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp++;\n\t\ti++;\n\t}\n\ti = new_s[long_s.length()-1] == '0' ? long_s.length()-1 : long_s.length();\n\tnew_s[i] = 0;\n\treverse(new_s, 0, i - 1);\n\treturn string(new_s);\n}\n\nBigNum& BigNum::operator++()\n{\n\tint i = 0;\n\tconst char* p1 = _num.data();\n\tchar* p = new char[_num.length()+2]();\n\tchar* new_s = p;\n\tint tmp = 0;\n\n\ttmp = (*p1 & 15) + ('1' & 15) + (*p & 15);\n\t*p = (tmp % 10) | (0b00110000);\n\t*(p + 1) = (tmp / 10) | (0b00110000);\n\tif (i == _num.length() - 1)\n\t{\n\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t{\n\t\t\t*(p + 1) = '\\0';\n\t\t}\n\t}\n\tp1++;\n\tp++;\n\ti++;\n\n\twhile (i != _num.length())\n\t{\n\t\ttmp = (*p & 15) + (*p1 & 15);\n\t\t*p = (tmp % 10) | (0b00110000);\n\t\t*(p + 1) = (tmp / 10) | (0b00110000);\n\t\tif (i == _num.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp++;\n\t\ti++;\n\t}\n\ti = new_s[_num.length()] == '0' ? _num.length() : _num.length() + 1;\n\t_num.clear();\n\t_num.append(new_s);\n\treturn *this;\n}\nBigNum BigNum::operator++(int)\n{\n\tBigNum old = *this;\n\t\n\tint i = 0;\n\tconst char* p1 = _num.data();\n\tchar* p = new char[_num.length() + 2]();\n\tchar* new_s = p;\n\tint tmp = 0;\n\n\ttmp = (*p1 & 15) + ('1' & 15) + (*p & 15);\n\t*p = (tmp % 10) | (0b00110000);\n\t*(p + 1) = (tmp / 10) | (0b00110000);\n\tif (i == _num.length() - 1)\n\t{\n\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t{\n\t\t\t*(p + 1) = '\\0';\n\t\t}\n\t}\n\tp1++;\n\tp++;\n\ti++;\n\n\twhile (i != _num.length())\n\t{\n\t\ttmp = (*p & 15) + (*p1 & 15);\n\t\t*p = (tmp % 10) | (0b00110000);\n\t\t*(p + 1) = (tmp / 10) | (0b00110000);\n\t\tif (i == _num.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp++;\n\t\ti++;\n\t}\n\ti = new_s[_num.length()] == '0' ? _num.length() : _num.length() + 1;\n\t_num.clear();\n\t_num.append(new_s);\n\n\treturn old;\n}\nBigNum& BigNum::operator--()\n{\n\tint i = 0;\n\tconst char* p1 = _num.data();\n\tchar* new_s = new char[_num.length() + 1]();\n\tchar* p = new_s;\n\tint tmp_10 = 0;\n\tint tmp_2 = 0;\n\n\ttmp_10 = (*p1 & 15) - ('1' & 15) - (~(*p) + 1);\n\t*p = ((tmp_10 + 10) % 10) | (0b00110000);\n\t*(p + 1) = ((tmp_10 - 9) / 10);\n\tif (i == _num.length() - 1)\n\t{\n\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t{\n\t\t\t*(p + 1) = '\\0';\n\t\t}\n\t}\n\tp1++;\n\tp++;\n\ti++;\n\n\twhile (i != _num.length())\n\t{\n\t\ttmp_10 = (*p1 & 15) - (~(*p) + 1);//p1、p2为\\0或有效值，不影响结果。\n\t\t*p = ((tmp_10 + 10) % 10) | (0b00110000);\n\t\t*(p + 1) = ((tmp_10 - 9) / 10);\n\t\tif (i == _num.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp++;\n\t\ti++;\n\t}\n\ti = new_s[_num.length() - 1] == '0' ? _num.length() - 1 : _num.length();\n\tnew_s[i] = 0;\n\t_num.clear();\n\t_num.append(new_s);\n\n\treturn *this;\n}\nBigNum BigNum::operator--(int)\n{\n\tBigNum old = *this;\n\n\tint i = 0;\n\tconst char* p1 = _num.data();\n\tchar* new_s = new char[_num.length() + 1]();\n\tchar* p = new_s;\n\tint tmp_10 = 0;\n\tint tmp_2 = 0;\n\n\ttmp_10 = (*p1 & 15) - ('1' & 15) - (~(*p) + 1);\n\t*p = ((tmp_10 + 10) % 10) | (0b00110000);\n\t*(p + 1) = ((tmp_10 - 9) / 10);\n\tif (i == _num.length() - 1)\n\t{\n\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t{\n\t\t\t*(p + 1) = '\\0';\n\t\t}\n\t}\n\tp1++;\n\tp++;\n\ti++;\n\n\twhile (i != _num.length())\n\t{\n\t\ttmp_10 = (*p1 & 15) - (~(*p) + 1);//p1、p2为\\0或有效值，不影响结果。\n\t\t*p = ((tmp_10 + 10) % 10) | (0b00110000);\n\t\t*(p + 1) = ((tmp_10 - 9) / 10);\n\t\tif (i == _num.length() - 1)\n\t\t{\n\t\t\tif (*(p + 1) == (0 | (0b00110000)))\n\t\t\t{\n\t\t\t\t*(p + 1) = '\\0';\n\t\t\t}\n\t\t}\n\t\tp1++;\n\t\tp++;\n\t\ti++;\n\t}\n\ti = new_s[_num.length() - 1] == '0' ? _num.length() - 1 : _num.length();\n\tnew_s[i] = 0;\n\t_num.clear();\n\t_num.append(new_s);\n\n\treturn *this;\n\n\treturn old;\n}\nostream& operator<<(ostream& out, const BigNum& src)\n{\n\tout << src._num;\n\treturn out;\n}\nistream& operator>>(istream& in, BigNum& des)\n{\n\tdes._num.clear();\n\tstring s;\n\tin >> s;\n\tint i = s.length();\n\n\tchar* new_s = new char[i + 1]();\n\n\tconst char* p = s.data();\n\ti = 0;\n\twhile (*p != 0)\n\t{\n\t\tnew_s[i++] = *p++;\n\t}\n\n\treverse(new_s, 0, i-1);\n\tdes._num.append(new_s);\n\n\treturn in;\n}\n```\n\n# test\n\n```cpp\n//test.cpp\n#include\"bignum.h\"\n#include<math.h>\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tBigNum bn1(99999);\n\tshow_bignum(bn1);cout << \"real:\" << bn1 << endl;\n\tBigNum bn2(bn1);\n\tshow_bignum(bn2);cout << \"real:\" << bn2 << endl;\n\tBigNum bn3(string(\"999\"));\n\tshow_bignum(bn3);cout << \"real:\" << bn3 << endl;\n\tBigNum bn4(\"456\");\n\tshow_bignum(bn4);cout << \"real:\" << bn4 << endl;\n\tbn4 = bn3;\n\tshow_bignum(bn4);cout << \"real:\" << bn4 << endl;\n\tBigNum bn5 = bn1 + bn3;\n\tshow_bignum(bn5);\n\tBigNum bn6(100003);\n\tBigNum bn7(411);\n\tBigNum bn8 = bn6 - bn7;\n\tshow_bignum(bn8);\n\tBigNum bn9(999);\n\t++bn9;\n\tshow_bignum(bn9);\n\tbn9++;\n\tshow_bignum(bn9);\n\t--bn9;--bn9;\n\tshow_bignum(bn9);\n\t++bn9;++bn9;\n\tshow_bignum(bn9);\n\tbn9--;bn9--;\n\tshow_bignum(bn9);\n\tBigNum bn10;\n\tcin >> bn10;\n\tshow_bignum(bn10);\n\tcout << \"real:\" << bn10 << endl;\n}\n```\n\n# 截图\n\n![image-20211020232706800](../../images/Cpp%E5%B0%81%E8%A3%85BigNum%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E5%8A%A0%E5%87%8F/image-20211020232706800.png)\n\n","categories":["Cpp"]},{"title":"Cpp_封装队/栈+单例模式","url":"/Cpp/Cpp_封装队栈_单例模式/","content":"# node.h\n\n```cpp\n//node.h\n#ifndef NODE_H\n#define NODE_H\n#include<stdlib.h>\nusing namespace std;\nclass List;\nvoid show(List& list);\nclass Node\n{\npublic:\n\tNode(int val = int())//给函数形参默认值\n\t{\n\t\t_val = val;\n\t\t_next = NULL;\n\t\t_pre = NULL;\n\t}\n\tfriend class List;\n\tfriend void show(List& list);\nprivate:\n\tint _val;\n\tNode* _next;\n\tNode* _pre;\n};\n#endif\n```\n\n# list\n\n## list.h\n\n```cpp\n#include\"node.h\"\nusing namespace std;\nclass List\n{\npublic:\n\tList();\n\tList(const List& src);\n\t~List();\n\tList& operator=(const List& src);\n\tvoid push_back(int val);\n\tvoid pop_back();\n\tvoid push_front(int val);\n\tvoid pop_front(int *pval);\n\n\tbool get_back(int * pval);\n\tbool get_front(int* pval);\n\tbool is_empty();\n\tint size();\n\t//void show();\n\tfriend void show(List& list);\nprivate:\n\tclass Node\n\t{\n\tpublic:\n\t\tNode(int val = int())//给函数形参默认值\n\t\t{\n\t\t\t_val = val;\n\t\t\t_next = NULL;\n\t\t\t_pre = NULL;\n\t\t}\n\t\tfriend class List;\n\t\tfriend void show(List& list);\n\tprivate:\n\t\tint _val;\n\t\tNode* _next;\n\t\tNode* _pre;\n\t};\n\tNode* _head;\n\tNode* _tail;\n\n};\n```\n\n\n\n## list.cpp\n\n```cpp\n#include\"list.h\"\n#include<stdio.h>\n/*\n类内实现的成员方法默认会被建议为内联（默认加上\n对于大类更多时候在类外实现，为了人看代码的方便、清晰\n*/\nList::List()\n{\n\t_head = new Node();\n\t_tail = _head;\n}\nList::List(const List& src)\n{\n\t//申请新结点\n\t_head = new Node();\n\t_tail = _head;\n\t//遍历src链表，将每个数据push_back插入到新链表\n\tNode* tmp = src._head->_next;//next是私有的，只能加友元\n\twhile (NULL != tmp)\n\t{\n\t\tpush_back(tmp->_val);\n\t\ttmp = tmp->_next;\n\t}\n\t\n}\nList::~List()\n{\n\twhile (!is_empty())\n\t{\n\t\tpop_back();\n\t}\n\t//删除头结点\n\tdelete _head;\n}\nList& List::operator=(const List& src)\n{\n\tif (this == &src)\n\t{\n\t\treturn *this;\n\t}\n\t//1.清空目标链表。2.防止内存泄露\n\twhile (!is_empty())\n\t{\n\t\tpop_back();\n\t}\n\n\t//拷贝\n\tNode* tmp = src._head->_next;\n\twhile (NULL != tmp)\n\t{\n\t\tpush_back(tmp->_val);\n\t\ttmp = tmp->_next;\n\t}\n\treturn *this;\n}\nvoid List::push_back(int val)\n{\n\tNode* node = new Node(val);\n\t_tail->_next = node;\n\tnode->_pre = _tail;\n\t_tail = node;\n}\nvoid List::pop_back()\n{\n\tif (is_empty())\n\t{\n\t\treturn;\n\t}\n\t_tail = _tail->_pre;\n\tdelete _tail->_next;\n\t_tail->_next = NULL;\n}\nvoid List::push_front(int val)\n{\n\t\n\tNode* newnode = new Node(val);//构造好时的节点的next和pre已经为NULL了\n\tnewnode->_pre = _head;\n\t//空链表的情况，即_head->_next为NULL\n\tif (!is_empty())\n\t{\n\t\tnewnode->_next = _head->_next;//没必要，构造好时的节点的next和pre已经为NULL了\n\t\t_head->_next->_pre = newnode;//NULL就异常了\n\t}\n\telse\n\t{\n\t\t_tail = newnode;\n\t}\n\t_head->_next = newnode;\n\t\n}\nvoid List::pop_front(int *pval)\n{\n\tif (is_empty())\n\t{\n\t\treturn;\n\t}\n\tNode* tmp = _head->_next;\n\tif (NULL != tmp->_next)\n\t{\n\t\ttmp->_next->_pre = _head;\n\t}\n\telse\n\t{\n\t\t//如果删除的是当前链表的唯一实际节点\n\t\t_tail = _head;\n\t}\n\t_head->_next = tmp->_next;\n\t*pval = tmp->_val;\n\tdelete tmp;\n}\n\nbool List::get_back(int* pval)\n{\n\tif (is_empty())\n\t{\n\t\treturn false;\n\t}\n\t*pval = _tail->_val;\n\treturn true;\n}\nbool List::get_front(int* pval)\n{\n\tif (is_empty())\n\t{\n\t\treturn false;\n\t}\n\t*pval = _head->_next->_val;\n\treturn true;\n}\nbool List::is_empty()\n{\n\treturn _head->_next == NULL;\n}\nint List::size()\n{\n\tint i = 0;\n\tNode* p = _head->_next;\n\twhile (p != NULL)\n\t{\n\t\ti++;\n\t\tp = p->_next;\n\t}\n\treturn i;\n}\nvoid show(List& list)\n{\n\n\tList::Node* p = list._head->_next;\n\twhile (p != NULL)\n\t{\n\t\tprintf(\"%d \", p->_val);\n\t\tp = p->_next;\n\t}\n\tprintf(\"\\n\");\n}\n```\n\n# stack\n\n## stack.h\n\n```cpp\n#include\"list.h\"\n#include<mutex>\nclass Stack\n{\npublic:\n\tstatic Stack* get_stack();\n\t\n\t//~Stack();\n\t//Stack(const Stack& src);\n\t//Stack& operator=(const Stack& src);\n\tvoid push(int val);\n\tvoid pop(int* pval);\n\tint top();\n\tbool is_empty();\n\tfriend void show(Stack& stack);\nprivate:\n\tStack();\n\tList _list;\n\tstatic mutex* _lock;\n\tstatic Stack* _stack;\n};\n```\n\n## stack.cpp\n\n```cpp\n#include\"stack.h\"\n#include<stdio.h>\nStack* Stack::_stack = NULL;\nmutex* Stack::_lock = new mutex();\nStack* Stack::get_stack()\n{\n\tif (NULL == _stack)\n\t{\n\t\t_lock->lock();\n\t\tif (NULL == _stack)\n\t\t{\n\t\t\t_stack = new Stack();\n\t\t}\n\t\t_lock->unlock();\n\t}\n\treturn _stack;\n}\nStack::Stack()\n\t:_list()\n{\n\n}\n/*\nStack::~Stack()\n{\n\n}\nStack::Stack(const Stack& src)\n\t:_list(src._list)\n{\n\t\n}\nStack& Stack::operator=(const Stack& src)\n{\n\tif (this == &src)\n\t{\n\t\treturn *this;\n\t}\n\t_list.operator=(src._list);\n\treturn *this;\n}\n*/\nvoid Stack::push(int val)\n{\n\tStack::_list.push_front(val);\n}\nvoid Stack::pop(int* pval)\n{\n\tStack::_list.pop_front(pval);\n}\nint Stack::top()\n{\n\tint val;\n\t_list.get_back(&val);\n\treturn val;\n}\nbool Stack::is_empty()\n{\n\treturn _list.is_empty();\n}\nvoid show(Stack& stack)\n{\n\tshow(stack._list);\n}\n```\n\n# queue\n\n## queue.h\n\n```cpp\n#ifndef QUEUE_H\n#define QUEUE_H\n\n#include\"list.h\"\n#include<mutex>\nclass Queue\n{\npublic:\n\tstatic Queue* get_Queue();\n\t//~Queue();\n\t//Queue(const Queue& src);\n\t//Queue& operator=(const Queue& src);\n\tvoid push(int val);\n\tvoid pop(int* pval);\n\tint top();\n\tbool is_empty();\n\tfriend void show(Queue& queue);\nprivate:\n\tQueue();\n\tList _list;\n\tstatic mutex* _lock;\n\tstatic Queue* _queue;\n};\n\n#endif // !QUEUE_H\n```\n\n## queue.cpp\n\n```cpp\n#include\"queue.h\"\n#include<stdio.h>\nQueue* Queue::get_Queue()\n{\n\tif (NULL == _queue)\n\t{\n\t\t_lock->lock();\n\t\tif (NULL == _queue)\n\t\t{\n\t\t\t_queue = new Queue();\n\t\t}\n\t\t_lock->unlock();\n\t}\n\treturn _queue;\n}\nQueue::Queue()\n\t:_list()\n{\n}\n/*\nQueue::~Queue(){}\nQueue::Queue(const Queue& src)\n\t:_list(src._list)\n{\n\n}\n\nQueue& Queue::operator=(const Queue& src)\n{\n\tif (this == &src)\n\t{\n\t\treturn *this;\n\t}\n\t_list.operator=(src._list);\n\treturn *this;\n}\n*/\nQueue* Queue::_queue = NULL;\nmutex* Queue::_lock = new mutex();\nvoid Queue::push(int val)\n{\n\tQueue::_list.push_back(val);\n}\nvoid Queue::pop(int* pval)\n{\n\tQueue::_list.pop_front(pval);\n}\nint Queue::top()\n{\n\tint val;\n\t_list.get_front(&val);\n\treturn val;\n}\nbool Queue::is_empty()\n{\n\treturn _list.is_empty();\n}\nvoid show(Queue& queue)\n{\n\tshow(queue._list);\n}\n```\n\n# main\n\n```cpp\n//test\n#if 0\n#include\"queue.h\"\nint main()\n{\n\n\tQueue* queue1 = Queue::get_Queue();\n\n\tfor (int i = 0;i < 5;i++)\n\t{\n\t\tqueue1->push(i);\n\t}\n\tshow(*queue1);\n\n\tint val;\n\tqueue1->pop(&val);\n\tshow(*queue1);\n\treturn 0;\n}\n#endif\n\n\n#include\"stack.h\"\nint main()\n{\n\n\tStack * stack1 = Stack::get_stack();\n\tfor (int i = 0;i < 5;i++)\n\t{\n\t\tstack1->push(i);\n\t}\n\tshow(*stack1);\n\n\tint val;\n\tstack1->pop(&val);\n\tshow(*stack1);\n\treturn 0;\n}\n#if 0 \n#endif\n#if 0\n#include\"list.h\"\nint main()\n{\n\n\tList list1;\n\tfor (int i = 0;i < 5;i++)\n\t{\n\t\tlist1.push_back(i);\n\t}\n\tfor (int i = 0;i < 5;i++)\n\t{\n\t\tlist1.push_front(i);\n\t}\n\tshow(list1);\n\n\tList list2 = list1;\n\tshow(list2);\n\n\tlist1.pop_back();\n\tshow(list1);\n\tshow(list2);\n\treturn 0;\n}\n#endif\n```\n\n","categories":["Cpp"]},{"title":"Linux_系统调用_文件操作","url":"/Linux/Linux_系统调用_文件操作/","content":"# 文件操作\n\n打开，读或写，关闭\n\nopen\n\nread\n\nwrite\n\nclose\n\nC语言中的打开文件函数：`fopen`，库函数，返回值为`FILE *`，有`stdin`、`stdout`、`stderr`。\n## 文件描述符\nfd\n\n是一个`>=0`的整数。每打开一个文件，就按照**最小可用原则**占用一个文件描述符（假如现在已被占用的fd最大值为10，而0号是空缺的，则占用0号）。\n\n多次打开同一个文件，可得到多个不同的文件描述符。\n### 预定义的文件描述符\n* 0：标准输入，默认是键盘\n* 1：标准输出，默认是Shell对应的显示器\n* 2：标准错误，也是Shell对应的显示器\n## write\nwrite to a file descriptor。包含于`<unistd.h>`\n\n可通过`man 2 write`查询用法。`man 2`中大多都是系统调用的函数手册。\n而`man 1`也有一个和write同名的，和系统调用不同，它是命令程序，多用于shell。\n\n接口：\n```c\nssize_t write(int fd, const void *buf, size_t count);\n```\n返回值：有符号整数。\n成功则返回已写入的字节大小。失败则返回`-1`，设置errno值。\n\n## 文件指针\n文件刚打开时，文件的位置指针在头部。\n## read\nread from a file descriptor。包含于`<unistd.h>\n\n接口：\n```c\nssize_t read(int fd, void *buf, size_t count);\n```\n返回值：有符号整数\n成功：\n1. 返回已经读到的字节大小。并将文件指针向前移动该字节数。\n2. 返回 0 则表示已经读到了文件末尾。\n\n失败则返回`-1`，设置errno值。在这种情况下，文件指针是否发生变化是未定义的。\n\n需要注意的是，手册里提到，如果返回值小于我们请求的大小，**不能定义为失败：\n1. 可能是因为目前可读到的字节比较少：这种情况，可能是因为接近文件末尾，也可能是正在从一个管道或从一个终端读取。\n2. 也可能读操作正在被一个信号（signal）中断。\n\nERRORS：\n1. EAGAIN：文件描述符 fd 指向一个非套接字文件，且已被标记为非阻塞 (`O_NONBLOCK`)，读取操作将阻塞。有关 `O_NONBLOCK` 标志的更多详细信息，请参阅 `open(2)`。\n2. EAGAIN 或 EWOULDBLOCK：文件描述符 fd 指向一个套接字文件，且已被标记为非阻塞 (`O_NONBLOCK`)，读取操作将阻塞。POSIX.1-2001 允许在这种情况下返回任一错误，并且不要求这些常量具有相同的值，因此可移植应用程序应该检查这两种可能性。\n\n## open\n需要包含以下头文件：\n1. `<sys/types.h>`\n2. `<sys/stat.h>`\n3. `<fcntl.h>`\n\n接口\n```c\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n```\nflags，指示打开文件的方式。\n\n1. `O_CREAT`：如果文件不存在则创建该文件。并且使用第3个参数`mode`设置权限。\n    1. 如果搭配`O_EXCL`使用，可以防止多进程同时创建文件。如果文件存在，则返回错误EEXIST。\n2. `O_WRONLY`：只写\n3. `O_RDONLY`：只读\n4. `O_RDWR`：读写\n5. `O_APPEND`：尾部追加方式（打开后文件指针指向末尾）\n6. `O_TRUNC`：若文件存在，且在`O_WRONLY`或`O_RDWR`的前提下，则文件长度将被截断为 0（清空）。如果文件是 FIFO 或终端设备文件，则 `O_TRUNC` 标志将被忽略。\n7. `O_NONBLOCK` or `O_NDELAY`：以非阻塞模式打开文件，`open()` 以及对返回的文件描述符执行的任何后续 I/O 操作都不会导致调用进程等待。\n    1. 注意，此标志的设置对 `poll(2)`、`select(2)`、`epoll(7)` 及类似接口的操作没有影响，因为这些接口仅通知调用者文件描述符是否“就绪”，这意味着在 `O_NONBLOCK` 标志已清除的情况下对文件描述符执行的 I/O 操作不会阻塞。\n    2. 注意，此标志对常规文件和块设备没有影响；也就是说，无论是否设置了 `O_NONBLOCK`，当需要设备活动时，I/O 操作都会（短暂地）阻塞。由于 `O_NONBLOCK` 语义最终可能会实现，因此应用程序在为常规文件和块设备指定此标志时不应依赖于阻塞行为。\n\nmode，指示`O_CREAT`创建文件时，赋予的权限。\n有定义好的常量。\n命名是有规律的：\n`S_I`是固定开头\n`RWX`表示可读、可写、可执行。\n当前面是`RWX`3个权限都有时，后缀只有1个字符：`U`代表user，`G`代表group，`O`代表other。\n当前面只有1个权限（R、W、X）时，后缀是3个字符：`USR`代表user，`GRP`代表group，`OTH`代表other。\n![](../../images/Linux_系统调用_文件操作/image-20250719014341777.png)\n\n实际的值（比如00700）代表什么意思？\n1. 这是一个八进制数，所以要以0开头。\n2. 首先，前面两位都是0\n3. 后面三位：\n    1. 第1个数对应用户权限；第2个数对应组权限；第3个数对应其他人权限。\n    2. 每一位上，\n        1. 1代表可执行（二进制的001）、\n        2. 2代表可写（二进制的010）、\n        3. 4代表可读（二进制的100）、\n        4. 7代表可读可写可执行（二进制的111）。\n    3. 那么，我们可以推断出，\n        1. 可读可写是二进制的（110）即6。\n        2. 可读可执行是二进制的（101）即5。\n        3. 可写可执行是二进制的（011）即3。\n4. 因此，一般的文件，可以设置为`0666`，即所有人可读可写。也可以设置为`0600`，表示只有拥有者可读可写。\n## close\n需要包含头文件`<unistd.h>`\n接口\n```c\nint close(int fd);\n```\n返回值\n成功返回0；\n失败返回-1。\n## lseek\n重新定位文件偏移量\n需要包含头文件：\n1. `<sys/types.h>`\n2. `<unistd.h>`\n\n接口：\n```c\noff_t lseek(int fd, off_t offset, int whence);\n```\noffset，有符号。如果要往末尾方向偏移则需要正数，往头方向则需要负数。\nwhence，指示在哪个位置进行偏移。\n1. `SEEK_SET`，从0偏移offset。\n2. `SEEK_CUR`，从当前位置偏移offset。\n3. `SEEK_END`，从末尾偏移offset。如果offset被设置为0则返回文件大小。这是通过fd取文件大小的唯一方法。\n\n返回值：\n返回当前文件指针相对于文件头部的偏移量。\n发生错误则返回`-1`。\n# mybash\n\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<assert.h>\n#include<string.h>\n#include<sys/wait.h>\n#include<errno.h>\n#include<pwd.h>\nchar * get_cmd(char buff[], char* myargv[])\n{\n    if(NULL==buff || NULL==myargv)\n    {\n        return NULL;\n    }\n    char *s = strtok(buff,\" \");\n    int i = 0;\n    while(s != NULL)\n    {\n        myargv[i++] = s;\n        s = strtok(NULL,\" \");\n    }\n    return myargv[0];\n}\nvoid print_info()\n{\n    //getuid -->unistd.h\n    int id = getuid();\n    char *s = \"$\";\n    if(id == 0)//root is 0\n    {\n        s = \"#\";\n    }\n    //#inlcude<pwd.h>\n    //getpwuid\n    struct passwd* ptr = getpwuid(id);//get info of user through uid\n    if(ptr == NULL)\n    {\n        printf(\"$\");\n        fflush(stdout);\n        return;\n    }\n    //gethostname-->unistd.h\n    char hostname[64] = {0};\n    if(gethostname(hostname,64)==-1)\n    { \n        printf(\"$\");\n        fflush(stdout);\n        return;\n    }\n    //chdir & getcwd --> #include<unistd.h>\n    char pwd_buff[128] = {0};\n    if(getcwd(pwd_buff, 128)==NULL)\n    {    \n        printf(\"$\");\n        fflush(stdout);\n        return;\n    }\n    //ptr->pw_name:用户名字。（xcg）\t\t\t\t   -->getpwuid-->pwd.h\n    //hostname:主机名。（ubuntu）\t\t\t\t\t   -->gethostname-->unistd.h\n    //pwd_buff:当前目录完整信息（/home/xcg/c219/1024） -->getcwd-->unistd.h\n    //s:管理员或普通标识（#为管理员，$为普通）\t\t\t-->getuid-->unistd.h\n    //最后效果：xcg @ ubuntu : /home/xcg/c219/1024 $\n    printf(\"%s@%s:%s%s \", ptr->pw_name, hostname, pwd_buff,s);\n    fflush(stdout);\n    /*\n    char **p = engv;\n    while(*p != NULL)\n    {\n        if(strncmp(*p,\"PWD\",3)==0)\n        {\n            char *s = &((*p)[4]);\n            printf(\"%s\",s);\n            break;\n        }\n        p++;\n    }\n    printf(\"$ \");\n    */\n}\nint main(int argc, char* argv[], char* engv[])\n{\n    while(1)\n    {\n        print_info();//打印[用户名字@主机信息:当前目录$]\n        \n        //键盘获取[命令、命令参数]字符串\n        char buff[128] = {0};\n        fgets(buff,128,stdin);\n        buff[strlen(buff)-1] = 0;//remove the \\n\n        //存放解析的命令参数\n        char * myargv[10] = {0};\n        char * cmd = get_cmd(buff,myargv);\n        if(NULL == cmd)\n        {\n            continue;\n        }\n        else if(strcmp(cmd,\"exit\") == 0)\n        {\n            break;\n        }\n        else if(strcmp(cmd,\"cd\")==0)\n        {\n            //chdir()\n            if(myargv[1] == NULL)\n            {\n                continue;\n            }\n            if(chdir(myargv[1]) == -1)//chdir-->unistd.h\n            {\n                perror(\"cd err\"); //#include<errno.h>\n            }\n            continue;//redo the bash\n        }\n        else\n        {\n            //fork + exec\n            pid_t pid = fork();\n            if(pid == -1)\n            {\n                printf(\"error\\n\");\n                continue;\n            }\n            if(pid == 0)\n            {\n                execvp(cmd,myargv);\n                printf(\"execvp error\\n\");\n                exit(1);\n            }\n            wait(NULL);\n        }\n    }\n}\n\n```\n\n# pwd和ls\n\npwd可以输出当前目录的路径信息。\n\n用unistd.h下的getcwd函数获取到buff字符串中即可。\n\n```c\n#include<unistd.h>\nint main()\n{\n    char buff[128] = {0};\n    if(getcwd(buff,128)==NULL)\n    {\n        return;\n    }\n    printf(\"%s\\n\",buff);\n    exit(0);\n}\n```\n\nls是打印当前目录下的所有文件名。\n\n即需要扫描目录。\n\n## 目录流\n\n目录实际上是一个抽象的概念，因为实际上并没有实际的文件来存储目录，而是一个目录流。就类似于“219班”这个概念，实际上并没有219班这个人，只是抽象出来的一个可以代表一些文件的集合名词。\n\n与目录操作有关的函数在dirent.h头文件中声明，使用一个名为DIR的结构作为目录操作的基础。指向这个结构体的指针（DIR \\*）被称为目录流，用于完成各种目录的操作。与操作普通文件的文件流（FILE \\*）非常相似。\n\n涉及到的函数有：\n\n1. opendir\n   1. ![image-20211031173750225](../../images/Linux_%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20211031173750225.png)\n2. readdir\n   1. ![image-20211031173910841](../../images/Linux_%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20211031173910841.png)\n   2. 返回的指针的指向的结构体是dirent。包含的内容有：\n      ![image-20211031174007909](../../images/Linux_%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/image-20211031174007909.png)\n3. telldir\n4. seekdir\n5. closedir\n\n```c\n#include<unistd.h>\n#include<string.h>\n#include<dirent.h>\nint main()\n{\n    char buff[128] = {0};\n    if(getcwd(buff,128))==NULL)\n    {\n        return 0;\n    }\n    DIR * p = opendir(buff);//打开通过getcwd获取的当前目录字符串所指定的目录，获取一个目录流\n    if(p==NULL)\n    {\n        return 0;\n    }\n    struct dirent * p_dirent = NULL;\n    while((p_dirent = readdir(p))!=NULL)\n    {\n        printf(\"%s  \",p_dirent->d_name);\n    }\n    closedir(p);\n    return 0;\n}\n```\n\n```bash\n\n```\n\n","categories":["操作系统","Linux"]},{"title":"基础数据结构_队列和栈转换","url":"/基础数据结构/基础数据结构_队列和栈转换/","content":"# 链队\n\n头结点需要重新设计。\n\n如果头结点只有一个next节点。入队为O(1)但出队无法都同时为O(1)。我们需要另外设计一个尾指针。\n\n```c\ntypedef struct LinkQueue\n{\n    struct Node * front;\n    struct Node * tail;\n}LinkQueue,Head;\ntypedef struct QNode\n{\n    ElemType data;\n    struct Node * next;\n}QNode;\n```\n\n\n\n```c\n#pragma once\n//.h\ntypedef int ElemType;\ntypedef struct LinkQueue\n{\n    struct QNode* front;\n    struct QNode* tail;\n}LinkQueue, Head;\ntypedef struct QNode\n{\n    ElemType data;\n    struct QNode* next;\n}QNode;\nvoid Init_lqueue(LinkQueue* plq);\nbool Push_lqueue(LinkQueue* plq, ElemType val);\nbool Pop_lqueue(LinkQueue* plq, ElemType* pval);\nbool Front_lqueue(LinkQueue* plq, ElemType* pval);\nint Get_Length_lqueue(LinkQueue* plq);\nbool Is_Empty_lqueue(LinkQueue* plq);\nvoid Clear_lqueue(LinkQueue* plq);\nvoid Destroy_lqueue(LinkQueue* plq);\nvoid Show_lqueue(LinkQueue* plq);\n```\n\n```c\n//.c\n#include\"lqueue.h\"\n#include<assert.h>\n#include<stdlib.h>\n#include<stdio.h>\nQNode* Buy_node()\n{\n\tQNode* s = (QNode*)malloc(sizeof(QNode));\n\treturn s;\n}\nvoid Init_lqueue(LinkQueue* plq)\n{\n\tassert(plq != NULL);\n\tQNode* node = Buy_node();\n\tnode->next = NULL;\n\tplq->front = node;\n\tplq->tail = node;\n}\n//入队，尾插\nbool Push_lqueue(LinkQueue* plq, ElemType val)\n{\n\tassert(plq != NULL);\n\tQNode* newnode = Buy_node();\n\tif (NULL == newnode)return false;\n\tnewnode->next = NULL;\n\tplq->tail->next = newnode;\n\n\tplq->tail = newnode;\n\n\tnewnode->data = val;\n\treturn true;\n}\nbool Pop_lqueue(LinkQueue* plq, ElemType* pval)\n{\n\tassert(plq != NULL);\n\tif (Is_Empty_lqueue(plq))\n\t{\n\t\treturn false;\n\t}\n\tQNode* oldnode = plq->front->next;\n\t*pval = oldnode->data;\n\t//头删\n\tplq->front->next = oldnode->next;\n\tfree(oldnode);\n\toldnode = NULL;\n\treturn true;\n}\nbool Front_lqueue(LinkQueue* plq, ElemType* pval)\n{\n\tassert(plq != NULL);\n\tif (Is_Empty_lqueue(plq))\n\t{\n\t\treturn false;\n\t}\n\t*pval = plq->front->next->data;\n\treturn true;\n}\nbool Is_Empty_lqueue(LinkQueue* plq)\n{\n\tassert(plq != NULL);\n\treturn plq->front->next == NULL;\n}\nint Get_Length_lqueue(LinkQueue* plq)\n{\n\tassert(plq != NULL);\n\tint count = 0;\n\tQNode* p = plq->front->next;\n\twhile (p != NULL)\n\t{\n\t\tcount++;\n\t\tp = p->next;\n\t}\n\treturn count;\n}\nvoid Clear_lqueue(LinkQueue* plq)\n{\n\tassert(plq != NULL);\n\tint val;\n\twhile (!Is_Empty_lqueue(plq))\n\t{\n\t\tPop_lqueue(plq, &val);\n\t}\n}\nvoid Destroy_lqueue(LinkQueue* plq)\n{\n\tassert(plq != NULL);\n\tClear_lqueue(plq);\n\tfree(plq->front);\n\tplq->front = NULL;\n\tplq->tail = NULL;\n}\nvoid Show_lqueue(LinkQueue* plq)\n{\n\tassert(plq != NULL);\n\tQNode* p = plq->front->next;\n\twhile (p != NULL)\n\t{\n\t\tprintf(\"%d \", p->data);\n\t\tp = p->next;\n\t}\n\tprintf(\"\\n\");\n}\n\n```\n\n# 链栈\n\n```c\n//.h\n//LinkStack.h\n#ifndef LINKSTACK_H\n#define LINKSTACK_H\n\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define NULLPTR -3\n\ntypedef int Status;\n\ntypedef int SElemType;\ntypedef struct StackNode\n{\n    SElemType data;\n    struct StackNode* next;\n}StackNode, * PStackNode;\ntypedef struct\n{\n    StackNode* top;\n    int cursize;\n}LinkStack;\n\nStatus InitStack(LinkStack* ps);\nvoid DestroyStack(LinkStack* ps);\nvoid ClearStack(LinkStack* ps);\nint StackLength(const LinkStack* ps);\nbool StackEmpty(const LinkStack* ps);\nStatus Push_Stack(LinkStack* ps, SElemType val);\nStatus GetTop_Stack(LinkStack* ps, SElemType* pval);\nStatus Pop_Stack(LinkStack* ps, SElemType* pval);\nbool DelFront_Stack(LinkStack* ps);\nvoid Show_Stack(LinkStack* ps);\n#endif\n```\n\n```c\n//LinkStack.cpp\n#include<stdlib.h>\n#include<assert.h>\n#include<string.h>\n#include<stdio.h>\n#include\"LinkStack.h\"\nStackNode* Buynode()\n{\n    StackNode* newnode = (StackNode*)malloc(sizeof(StackNode));\n    if (NULL != newnode)\n    {\n        memset(newnode, 0, sizeof(StackNode));\n    }\n    return newnode;\n}\nStatus InitStack(LinkStack* ps)\n{\n    assert(ps != NULL);\n    ps->top = Buynode();//头结点\n    if (NULL == ps->top)return OVERFLOW;\n\n    ps->cursize = 0;\n    return OK;\n}\nvoid DestroyStack(LinkStack* ps)\n{\n    assert(ps != NULL);\n    ClearStack(ps);\n    free(ps->top);\n    ps->top = NULL;\n}\nvoid ClearStack(LinkStack* ps)\n{\n    assert(ps != NULL);\n    while (ps->cursize != 0)\n    {\n        DelFront_Stack(ps);\n    }\n}\nint StackLength(const LinkStack* ps)\n{\n    assert(ps != NULL);\n    return ps->cursize;\n}\nbool StackEmpty(const LinkStack* ps)\n{\n    assert(ps != NULL);\n    return ps->cursize == 0;\n}\nStatus Push_Stack(LinkStack* ps, SElemType val)\n{\n    assert(ps != NULL);\n    StackNode* newnode = Buynode();\n    if (NULL == newnode)return OVERFLOW;\n\n    newnode->next = ps->top->next;\n    ps->top->next = newnode;\n\n    newnode->data = val;\n\n    ps->cursize += 1;\n    return OK;\n}\nStatus GetTop_Stack(LinkStack* ps, SElemType* pval)\n{\n    assert(ps != NULL);\n    if (pval == NULL)return NULLPTR;\n    if (ps->cursize <= 0)return false;\n    *pval = ps->top->next->data;\n    return OK;\n}\nStatus Pop_Stack(LinkStack* ps, SElemType* pval)\n{\n    assert(ps != NULL);\n    if (pval == NULL)return NULLPTR;\n    if (ps->cursize <= 0)return ERROR;\n    GetTop_Stack(ps, pval);\n    DelFront_Stack(ps);\n    return OK;\n}\nbool DelFront_Stack(LinkStack* ps)\n{\n    assert(ps != NULL);\n    if (ps->cursize <= 0)return false;\n    StackNode* p = ps->top->next;\n    ps->top->next = p->next;\n    free(p);\n    ps->cursize -= 1;\n    return true;\n}\nvoid Show_Stack(LinkStack* ps)\n{\n    StackNode* p = ps->top->next;\n    while (p != NULL)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    //printf(\"\\n\");\n}\n```\n\n# 栈转队列\n\n```c\n//.h\n#ifndef MYQUEUE_H\n#define MYQUEUE_H\n#include\"../../Stack/Stack/LinkStack.h\"\n#include\"../../QueueTest/QueueTest/lqueue.h\"\ntypedef int ElemType;\ntypedef struct MyQueue\n{\n\tLinkStack s1;\n\tLinkStack s2;\n}MyQueue;\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define NULLPTR -3\n\ntypedef int Status;\nvoid Init_MyQueue(MyQueue* pmyq);\nStatus Push_MyQueue(MyQueue* pmyq, ElemType val);\nStatus Pop_MyQueue(MyQueue* pmyq, ElemType* pval);\nStatus Front_MyQueue(MyQueue* pmyq, ElemType* pval);\nint Get_Length_MyQueue(MyQueue* pmyq);\nbool Is_Empty_MyQueue(MyQueue* pmyq);\nvoid Clear_MyQueue(MyQueue* pmyq);\nvoid Destroy_MyQueue(MyQueue* pmyq);\nvoid Show_MyQueue(MyQueue* pmyq);\n#endif\n\n```\n\n```c\n//.c\n#include\"MyQueue.h\"\n#include<assert.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid Init_MyQueue(MyQueue* pmyq)\n{\n\tInitStack(&pmyq->s1);\n\tInitStack(&pmyq->s2);\n}\nStatus Push_MyQueue(MyQueue* pmyq, ElemType val)\n{\n\treturn Push_Stack(&pmyq->s1, val);\n}\nStatus Pop_MyQueue(MyQueue* pmyq, ElemType* pval)\n{\n\tif (!StackEmpty(&pmyq->s2))\n\t{\n\t\treturn Pop_Stack(&pmyq->s2, pval);\n\t}\n\telse\n\t{\n\t\tint val;\n\t\twhile(!StackEmpty(&pmyq->s1))\n\t\t{\n\t\t\tPop_Stack(&pmyq->s1, &val);\n\t\t\tPush_Stack(&pmyq->s2, val);\n\t\t}\n\t\tif (StackEmpty(&pmyq->s2))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn Pop_Stack(&pmyq->s2, pval);\n\t\t}\n\t}\n}\nStatus Front_MyQueue(MyQueue* pmyq, ElemType* pval)\n{\n\tif (!StackEmpty(&pmyq->s2))\n\t{\n\t\treturn GetTop_Stack(&pmyq->s2, pval);\n\t}\n\telse\n\t{\n\t\tint val;\n\t\twhile (!StackEmpty(&pmyq->s1))\n\t\t{\n\t\t\tPop_Stack(&pmyq->s1, &val);\n\t\t\tPush_Stack(&pmyq->s2, val);\n\t\t}\n\t\tif (StackEmpty(&pmyq->s2))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn GetTop_Stack(&pmyq->s2, pval);\n\t\t}\n\t}\n}\nint Get_Length_MyQueue(MyQueue* pmyq)\n{\n\treturn StackLength(&pmyq->s1) + StackLength(&pmyq->s2);\n}\nbool Is_Empty_MyQueue(MyQueue* pmyq)\n{\n\treturn Get_Length_MyQueue(pmyq) == 0;\n}\nvoid Clear_MyQueue(MyQueue* pmyq)\n{\n\tClearStack(&pmyq->s1);\n\tClearStack(&pmyq->s2);\n}\nvoid Destroy_MyQueue(MyQueue* pmyq)\n{\n\tDestroyStack(&pmyq->s1);\n\tDestroyStack(&pmyq->s2);\n}\nvoid Show_MyQueue(MyQueue* pmyq)\n{\n\tStackNode* p = pmyq->s1.top->next;\n\tp = pmyq->s1.top->next;\n\twhile (p != NULL)\n\t{\n\t\tprintf(\"%d \", p->data);\n\t\tp = p->next;\n\t}\n\n\tLinkStack s3;\n\tInitStack(&s3);\n\tp = pmyq->s2.top->next;\n\twhile (p != NULL)\n\t{\n\t\tPush_Stack(&s3, p->data);\n\t\tp = p->next;\n\t}\n\n\tp = s3.top->next;\n\twhile (p != NULL)\n\t{\n\t\tprintf(\"%d \", p->data);\n\t\tp = p->next;\n\t}\n\tprintf(\"\\n\");\n}\n```\n\n# 队列转栈\n\n```c\n//.h\n//MyStack.h\n#ifndef MYSTACK_H\n#define MYSTACK_H\n\n#include\"../../Stack/Stack/LinkStack.h\"\n#include\"../../QueueTest/QueueTest/lqueue.h\"\n\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define NULLPTR -3\n\ntypedef int Status;\n\ntypedef int ElemType;\n\ntypedef struct MyStack\n{\n    LinkQueue q1;\n    LinkQueue q2;\n}MyStack;\n\nStatus InitMyStack(MyStack* pmys);\nvoid DestroyMyStack(MyStack* pmys);\nvoid ClearMyStack(MyStack* pmys);\nint MyStackLength(const MyStack* pmys);\nbool EmptyMyStack(const MyStack* pmys);\nStatus Push_MyStack(MyStack* pmys, ElemType val);\nStatus GetTop_MyStack(MyStack* pmys, ElemType* pval,int *flag);\nStatus Pop_MyStack(MyStack* pmys, ElemType* pval);\nbool DelFront_LQueue(LinkQueue* plq);\nvoid Show_MyStack(MyStack* pmys);\n#endif\n```\n\n```c\n//.c\n#include\"MyStack.h\"\n#include<stdlib.h>\n#include<stdio.h>\nStatus InitMyStack(MyStack* pmys)\n{\n\tInit_lqueue(&pmys->q1);\n\tInit_lqueue(&pmys->q2);\n\treturn OK;\n}\nvoid DestroyMyStack(MyStack* pmys)\n{\n\tDestroy_lqueue(&pmys->q1);\n\tDestroy_lqueue(&pmys->q2);\n\n}\nvoid ClearMyStack(MyStack* pmys)\n{\n\tClear_lqueue(&pmys->q1);\n\tClear_lqueue(&pmys->q2);\n\n}\nint MyStackLength(MyStack* pmys)\n{\n\treturn Get_Length_lqueue(&pmys->q1) + Get_Length_lqueue(&pmys->q2);\n}\nbool EmptyMyStack(MyStack* pmys)\n{\n\treturn MyStackLength(pmys) == 0;\n}\nStatus Push_MyStack(MyStack* pmys, ElemType val)\n{\n\treturn Push_lqueue(&pmys->q2, val);\n}\nbool MostHaveOneNode_LQueue(LinkQueue* plq)\n{\n\treturn Get_Length_lqueue(plq)<=1;\n}\nStatus GetTop_MyStack(MyStack* pmys, ElemType* pval, int *flag)\n{\n\tint val;\n\tbool goodPop = false;\n\tif (Get_Length_lqueue(&pmys->q1) == 1)\n\t{\n\t\t*pval = pmys->q1.front->next->data;\n\t\t*flag = 1;\n\t\treturn OK;\n\t}\n\tif (!Is_Empty_lqueue(&pmys->q2))\n\t{\n\t\twhile (!MostHaveOneNode_LQueue(&pmys->q2))\n\t\t{\n\t\t\tgoodPop = Pop_lqueue(&pmys->q2, &val);\n\t\t\tif(goodPop)Push_lqueue(&pmys->q1, val);\n\t\t}\n\t\t*flag = 2;\n\t\treturn Front_lqueue(&pmys->q2, pval);\n\t}\n\telse\n\t{\n\t\twhile (!MostHaveOneNode_LQueue(&pmys->q1))\n\t\t{\n\t\t\tgoodPop = Pop_lqueue(&pmys->q1, &val);\n\t\t\tif (goodPop)Push_lqueue(&pmys->q2, val);\n\t\t}\n\t\t*flag = 1;\n\t\treturn Front_lqueue(&pmys->q1, pval);\n\t}\n\t*flag = 0;\n\treturn FALSE;\n}\nStatus Pop_MyStack(MyStack* pmys, ElemType* pval)\n{\n\tif (EmptyMyStack(pmys))return FALSE;\n\tint flag = 0;\n\tGetTop_MyStack(pmys,pval,&flag);\n\tif (flag != 0)\n\t{\n\t\tif (flag == 1)\n\t\t{\n\t\t\tDelFront_LQueue(&pmys->q1);\n\t\t}\n\t\telse if (flag == 2)\n\t\t{\n\t\t\tDelFront_LQueue(&pmys->q2);\n\t\t}\n\t}\n\treturn TRUE;\n\t/*\n\tint val;\n\tif (!Is_Empty_lqueue(&pmys->q2))\n\t{\n\t\twhile (!MostHaveOneNode_LQueue(&pmys->q2))\n\t\t{\n\t\t\tPop_lqueue(&pmys->q2, &val);\n\t\t\tPush_lqueue(&pmys->q1, val);\n\t\t}\n\t\treturn Pop_lqueue(&pmys->q2, pval);\n\t}\n\telse if (!Is_Empty_lqueue(&pmys->q1))\n\t{\n\t\twhile (!MostHaveOneNode_LQueue(&pmys->q1))\n\t\t{\n\t\t\tPop_lqueue(&pmys->q1, &val);\n\t\t\tPush_lqueue(&pmys->q2, val);\n\t\t}\n\t\treturn Pop_lqueue(&pmys->q1, pval);\n\t}\n\treturn FALSE;\n\t*/\n}\nbool DelFront_LQueue(LinkQueue *plq)\n{\n\tif (plq->front->next == NULL)return false;\n\tQNode* s = plq->front->next;\n\tplq->front->next = s->next;\n\tplq->tail = plq->front;\n\tfree(s);\n\treturn true;\n}\nvoid Print_Queue_Reverse(LinkQueue* plq)\n{\n\tLinkStack ls;\n\tInitStack(&ls);\n\tQNode* p = plq->front->next;\n\twhile (p != NULL)\n\t{\n\t\tPush_Stack(&ls, p->data);\n\t\tp = p->next;\n\t}\n\tShow_Stack(&ls);\n\tDestroyStack(&ls);\n}\nvoid Show_MyStack(MyStack* pmys)\n{\n\tPrint_Queue_Reverse(&pmys->q2);\n\tPrint_Queue_Reverse(&pmys->q1);\n\tprintf(\"\\n\");\n}\n```\n\n# 测试\n\n```c\n//TestMyQueue.cpp\n#if 0\n#include\"MyQueue.h\"\nint main()\n{\n\tMyQueue myq;\n\tInit_MyQueue(&myq);\n\tint n = 10;\n\tfor (int i = 0; i < n;i++)\n\t{\n\n\t\tPush_MyQueue(&myq, i);\n\t\tShow_MyQueue(&myq);\n\t}\n\tint val;\n\tfor (int i = 0; i < n;i++)\n\t{\n\n\t\tPop_MyQueue(&myq, &val);\n\t\tShow_MyQueue(&myq);\n\t}\n\tDestroy_MyQueue(&myq);\n\t//Show(&lq);\n\treturn 0;\n}\n#endif\n```\n\n```c\n//TestMyStack.cpp\n\n#include\"MyStack.h\"\nint main()\n{\n\tMyStack myq;\n\tInitMyStack(&myq);\n\tint n = 10;\n\tfor (int i = 0; i < n;i++)\n\t{\n\t\tPush_MyStack(&myq, i);\n\t\tShow_MyStack(&myq);\n\t}\n\tint val;\n\tfor (int i = 0; i < n;i++)\n\t{\n\t\tPop_MyStack(&myq, &val);\n\t\tShow_MyStack(&myq);\n\t}\n\tDestroyMyStack(&myq);\n\t//Show(&lq);\n\treturn 0;\n}\n```\n\n","categories":["基础数据结构"]},{"title":"Redis_跳跃表","url":"/Redis/Redis_跳跃表/","content":"\n# 内容\n\n# 平衡树\n\n平衡树(Balance Tree，BT) 指的是，**任意节点的子树的高度差都小于等于1**。常见的符合平衡树的有，B树（多路平衡搜索树）、AVL树（二叉平衡搜索树）等。平衡树可以完成集合的一系列操作, 时间复杂度和空间复杂度相对于“2-3树”要低，在完成集合的一系列操作中始终保持平衡，为大型数据库的组织、索引提供了一条新的途径。\n\n","categories":["高级数据结构","Redis"]},{"title":"计算机知识体系2021_1009","url":"/计算机知识体系/计算机知识体系2021_1009/","content":"# 内容\n\n今天总结的内容是一个发散性和系统性都有的。\n\n先要把整个操作系统的体系建立起来，存储体系、进程和线程体系。下去之后看操作系统哲学、程序员自我修养、深入理解计算机系统\n\n从应用层穿到底层。\n\n内存方面：通过new和malloc区别穿到：内存开辟底层的实现、内存的管理、页面的调换。\n\n谷歌的tmalloc源码下载下来分析，不会问老师。\n\n# C语言的整个基础\n\n1. 结构体的使用--设计结构体--数据结构\n2. 函数指针\n\n# `C++`的核心\n\n学习`C++`：先练（还是念？没听清），就是先理解面向对象的思想，然后用。`C++`中最主要的是灵活使用STL。STL有几个重要的点：（Vector、List比较简单，刨除了）Map、HashMap、HashSet，不要剖析VS2019的源码，因为太难了，剖析VC6.0或版本比较低的。**Hash类的STL中，HashMap是最重要的一个点**，其底层是红黑树实现的，但红黑树问的不多，撑死问一个树的左旋右旋。**主要是让你实现HashMap（无序）代码**。\n\n`C++`更重要的是：\n\n`C++11`新特性很重要，可以看一本书`C++11`新特性。**最重要的是即智能指针**。智能指针问的问题太多太多了。**STL、智能指针会用，`C++`就到头了**。\n\n`C++`结束后，更重要的是修炼内功。\n\n操作系统的两个点：进程、内存。I/O、多核可以了解一下，其他的不重要。\n\n## 内存\n\n页面置换算法：九个或八个，老师实现LRU算法，时钟算法自己实现，并且要讲清楚，才可以下达`C++`代码。\n\n**任务1（一周完成）**：面试可能会问到：如果你定义了一个变量，你能否**打印出其真实的物理地址**？则我们必须对整个LINUX的内存管理原理非常熟悉才可以。\n\n如果能分析出真实的物理地址，则报文原理、写时拷贝原理（fork的原理）就会立马明白。\n\n**任务2**：父进程建立链表，子进程也要使用链表，子进程和父进程不改变数据值。\n首先在父进程建立链表，创建子进程，打印每个地址和值，父进程也如是。当子进程或父进程改变某个节点数据值后，在子进程和父进程再次打印链表的地址。对照链表有何变化。\n本质问题就是：原来我们讲过，局部变量和全局变量产生写时拷贝，那么我们**在堆区如何产生写时拷贝**？\n\n## 进程\n\n1. 父进程构造了个对象5，**fork后子进程会不会还要调用构造函数**？当对象的局部发生改变后，打印对象地址。这问题会牵扯到后续的继承内容，有多态，存在虚表问题。\n2. 进程间的通信有哪几种？管道、共享内存、消息队列。如果内存知识不懂，则不会理解。一旦要共享内存，就会有互斥、同步问题。互斥量、互斥锁、信号量、原子操作、条件变量。**任务3**：原子操作的底层实现是？搞清原子操作，就可以搞清信号量、互斥量。\n\n# `C/C++`面试\n\nC和`C++`的面试，重点不在语法上，而是透过问题C和`C++`穿入到操作系统。\n\n## new和malloc区别\n\n1. new是关键字，malloc是函数，new调用malloc。\n2. new和malloc都是在堆区申请空间\n3. new有三个步骤\n    1. 开辟空间\n    2. 构造函数，初始化对象。\n    3. 返回地址\n如果考虑CPU的串行、并行，则2、3步可能会顺序不一致。有可能还没构建对象就拿到了地址，会导致错误。我们需要强制其按照2、3顺序来。\n4. new不会强转返回值类型，malloc需要程序员强转。\n5. new封装计算sizeof，而malloc需要程序员清楚要开辟的空间。\n6. 空间不足时，new会抛异常（`bad_alloc`），不会执行返回操作。`malloc`会返回空指针。（`int *p = new(nothrow) int(20);//我们可以加nothrow禁止抛出异常，则返回空指针`）\n7. 释放时，如果对象是内置类型，delete和free可以混用。自己设计的类型，如果没有析构函数、继承关系，也没有虚函数，则也可以混用；如果你设计的new是一个完全的面向对象的写法，则不可以混用。\n8. new是个关键字，可以重载；malloc是函数，不可以重载。重载new，在类中重载的new和delete的最大特点是其具有静态特性，没有this指针。为什么类中重载的new没有this指针？this指向当前对象，new需要给当前对象开辟地址，调动new的时候，还不存在对象，那么无法传递this指针。\n\n透过这个问题，我们可以联想到：\n\n**C++的核心思想**：地址和空间分离。就比如，局部对象的定义时分配的空间是系统管理的，构造函数是无能力开辟空间的，只是在空间中构建出来。所以，有空间不一定有对象，有对象一定有空间。\n\n针对这个思想，有一个例子：类中没有任何指令、成员的sizeof是1，对象占空间大小也是1字节。因为它至少要体现它存在着，起占位符作用。\n\n## new的三种调用形式\n\n1. 关键字\n```c++\nint *p = new int(10);\n```\n2. 函数\n```c++\nint *p = ::operator new(sizeof(int));  //malloc\n```\n类似于调用malloc，但是还是有区别，这个形式的new内存不足时还是会抛出异常。\n3. 定位new\n定位new就是对已有的空间，在空间中拿定位new来构建你认为的对象。为什么呢？因为ar传递进去之后，传递进的是个无类型指针，无类型指针在地址范围内构建对象就可以了，不管原来是什么货，我现在认为：有地址即可构建对象。对系统内部来说，认为有空间我就能把地址构建到，而回到用户空间下做的话，整型数组里就不能有对象了。但对系统来说，不管类型，我就是可以构建。\n```c++\nint ar[10];\nnew(ar) Test(10);//把对象构建到数组中了。跨越了类型的障碍。\n```\n## malloc\n\n1. new和malloc都是调用malloc来分配空间\n2. malloc的底层实现是调用tmalloc和pmalloc，大块内存、小块内存组织方案不一样。这个问题就牵扯到了内存池。理解内存池后，malloc底层效率低，我们需要写自己的内存池来增加效率，比如谷歌的tmalloc，那么与STL中的内存池有何区别？\n3. 谷歌的tmalloc如果考虑在多线程环境下，有可能你调的是1号线程给你分配，有可能是2号，线程多了之后，可以加速分配速度。线程有自己的线程池，并不冲突。但是如果要的空间比较大时，要在底层对大空间进行一个统一的开辟，并且会产生竞争，则会出现同步问题。则会出现以下现象：原来是1号线程分配的空间，释放时用的2号线程。原来是2号线程分配的空间，释放时用的1号线程。那么空间如何有一个统一的方法还回去？线程池从某地方拿了一块给另一方，还回的时候是第二个线程还，那么就会把这一块放到线程空间里。所以有可能从1号的还给2号，有可能从2号来的，还给1号。\n## 什么是内存泄漏？\n\n1. 内存泄露的本质原因是什么？\n    1. 内存泄漏绝不是简单的malloc后没有free。进程结束后，malloc的内存都会释放。**因为我们进程使用的是虚拟地址，我们会在进程执行完毕后，撤销虚拟地址在物理地址的映射关系。**\n2. 内存不足时，我们采取的政策是什么？\n## 进程同步经典问题\n\n1. 生产者-消费者：面试中经久不衰的问题，因为用到的场景太多了。与播放有关的都是这种问题。\n    1. 短视频软件就是一个生产者-消费者模型。有环形的缓冲池，有倒水者（服务器）、接水者（用户）。\n    2. 如果只有一个池子：使用过程中，队头和队尾需要一直迭代，我们可能需要计算队列中的个数，需要队尾、队头相减，则需要锁住队头和队尾指针，则不能灌水、取水。\n    3. 三个池子来回倒：先把一个池子注满，注满后把池子拉给播放器。接着给另一个池子注，这样来说，两个池子是独立的。并行能力提升了。代价是要有两个池子的资源。\n2. 哲学家进餐，避免死锁\n3. 读者-写者问题：实际上是生产者-消费者的变种问题\n    1. 读者不可改内容，写者可改。读者可以并发，读者和写者互斥，读者和读者并发，写者和写者互斥。代码比较小，但是要你设计框架。\n4. 实现信号量：给上三个线程，第一个线程打印A，第二个线程打印B，第三个线程打印C。总共打印10个，要求先A后B再C。不给信号量，能不能拿原子操作和条件变量完成？能不能拿条件变量和互斥量完成？能不能把原子操作、条件变量、互斥量三者合起来组成一个新的信号量？看你是不是学通了。这就面试到了很根本的难点了。年薪40-50W都会面到。\n\n## 进程池、线程池\n\n如何实现进程池、线程池？\n\n学了TCP/IP就能体会到线程池了。\n\n# 书\n\n1. 操作系统哲学\n2. 程序员的自我修养\n    1. 看Linux就够了，Windows不看\n两本看完后，可以弄一个4G文件，内存中取500M空间，玩地址映射。\n3. csapp\n    1. 存储器\n    2. 内存管理\n        1. 页面置换算法\n        2. 进程、线程\n4. effective C++\n    1. 可当作对C++的扩充\n    2. 最有价值的是第六章，应该反复去看，即继承关系。\n5. 陈硕-LINUX C++网络库\n    1. 智能指针\n6. 深入理解C++11\n","categories":["计算机知识体系"]},{"title":"基础数据结构_队列","url":"/基础数据结构/基础数据结构_队列/","content":"# 内容\n\n# 特点\n\n1. 先进先出（FIFO）。\n2. 一端进行插入，另一端进行删除的线性表。\n3. 没有有效数据节点的队列称作空队。\n## 难点\n\n1. 如何让入队和出队的时间复杂度都为O(1)：将顺序队列臆想成一个环形。\n2. 判空和判满条件冲突，都是队头==队尾\n   1. 方案一：加个标志，保存有效值个数。\n   2. 方案二：在队尾浪费一个空间，不再保存有效值，而是作为一个标记。\n\n# 实现\n\n```c\n//queue.h\n#pragma once\n\ntypedef int ElemType;\ntypedef struct Queue\n{\n    ELEM_TYPE *base;\n    int front;\n    int tail;\n    //int cursize;\n}Queue, *PQueue;\n//增删改查\n//初始化\nvoid Init_queue(Queue *pq);\n//入队\nbool Push(Queue *pq, ElemType val);\n//出队\nbool Pop(Queue *pq, ElemType *pval);\n//获取队头元素值\nbool Head(Queue *pq, ElemType *pval);\n//获取有效值个数\nint GetLength(Queue *pq);\n//判空\nbool IsEmpty(Queue *pq);\n//判满\nbool IsFull(Queue *pq);\n//清空\nvoid Clear(Queue *pq);\n//销毁\nvoid Destroy(Queue *pq);\n//show\nvoid Show(Queue *pq);\n```\n\n```c\n//初始化\nvoid Init_queue(Queue *pq)\n{\n    assert(pq!=NULL);\n    pq->base = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE);\n    assert(pq->base !=NULL);\n    pq->front = pq->tail = 0;\n}\n//入队\nbool Push(Queue *pq, ElemType val)\n{\n    assert(pq!=NULL);\n    if(IsFull(pq))\n    {\n        return false;\n    }\n    pq->base[pa->tail] = val;\n    pq->tail = (pq->tail + 1) % MAXSIZE;\n    return true;\n}\n//出队\nbool Pop(Queue *pq, ElemType *pval)\n{\n    if(IsEmpty(pq))\n    {\n        return false;\n    }\n    *pval = pq->base[pq->front];\n    pq->front = (pq->front + 1) % MAXSIZE;\n    return true;\n}\n//获取队头元素值\nbool Head(Queue *pq, ElemType *pval)\n{\n    if(IsEmpty(pq))\n    {\n        return false;\n    }\n    *pval = pq->base[pq->front];\n    return true;\n}\n//获取有效值个数\nint GetLength(Queue *pq)\n{\n\treturn (pq->tail - pq-> front + MAXSIZE) % MAXSIZE;\n}\n//判空\nbool IsEmpty(Queue *pq)\n{\n    return pq->front == pq->tail;\n}\n//判满\nbool IsFull(Queue *pq)\n{\n    return (pq->tail+1)%MAXSIZE == pq->front;\n}\n//清空\nvoid Clear(Queue *pq)\n{\n    pq->tail = pq->front = 0;\n}\n//销毁\nvoid Destroy(Queue *pq)\n{\n    free(pq->base);\n    pq->base = NULL;\n}\n//show\nvoid Show(Queue *pq)\n{\n    int p = pq->front;\n    while(p != pq->tail)\n    {\n        printf(\"%d \",pq->base[p]);\n        p = (p+1) % MAXSIZE;\n    }\n    printf(\"\\n\");\n}\n```\n\n```c\n//test\n#include\"queue.h\"\nint main()\n{\n    Queue q;\n    Init_queue(&q);\n    for(int i = 0;i<20;i++)\n    {\n        Push(&q,i+1);\n    }\n    \n    Show(&q);\n    \n    for(int i = 0;i<5;i++)\n    {\n        int tmp;\n        Pop(&q,&tmp);\n        printf(\"%d\\n\",tmp);\n    }\n    Show(&q);\n    \n    printf(\"%d \\n\",GetLength(&q));\n    \n    Clear(&q);\n    Show(&q);\n    Destroy(&q);\n    return 0;\n}\n```\n\n# 链队列\n\n```c\n//lqueue.h\ntypedef L\n```\n\n\n\n```c\n//lqueue.cpp\n\n```\n\n\n\n```c\n//test.cpp\n```\n\n","categories":["基础数据结构"]},{"title":"Cpp_面向对象_初探","url":"/Cpp/Cpp_面向对象_初探/","content":"# 内容\n\n四大特性：抽象、封装、继承、多态\n# 概述\n\n1. 编程语言：是为了模拟现实而产生的\n    1. 就比如要模拟person类：我们要描述人，就要抽象为数据\n2. 面向对象就是一个模拟现实很好的思想\n    1. 属性----成员属性：sex, age\n    2. 行为----成员方法：work, eat\n## this指针\n\nthis指针是指向本对象的指针。\n\n`C++`和C的区别，很明显的是，`C++`会在编译时期暗中做很多事情，其次的区别就是`C++`封装。\n\n就比如定义成员方法时，`C++`就在编译时期为我们加上了：\n1. 在函数普通成员方法的第一个参数默认是指向本类型的this指针。（`Class_Name* const this`）\n2. 在普通成员方法内，使用到普通成员的地方，加上\"`this->`\"。\n3. 在调用普通成员方法的时候加上实参数this指针，方便方法内使用。\n```c++\nclass Person\n{\npublic:\n    int _age;\n    int _sex;\n    char *_name;\n    void work()\n    {\n        cout << _name << \": work\" << endl;\n    }\n    void eat()\n    {\n        cout << _name << \": eat\" << endl;\n    }\n};//分号不要丢\n```\n每一个成员方法，第一个参数一般默认在编译期时，传入一个(`Class_name * this`)。\n\n在使用到成员方法、成员变量时，会默认加上`解引用`。\n```c++\nvoid work(Person *this)\n{\n    cout << this->_name << \": work\" << endl;\n    this->eat();\n}\n```\n## 构造函数\n\n构造函数就是：在对象进行构造的时候（其实就是定义，`Person p;`），默认调用的成员方法。\n1. 如果没有实现构造函数，会自动生成默认构造函数\n    1. 自己实现了之后，就不会自动生成。\n    2. 默认构造函数就是：除了this指针以外，没有参数的构造函数。 \n3. 构造函数名字与类名一致，无返回值。\n4. 构造函数可以重载，参数列表不限制。\n```c++\nPerson(int age, int sex, const char *name)\n{\n    _age = age;\n    _sex = sex;\n    // _name = name; // 这是浅拷贝：指针给指针赋值；\n    \n    // 以下是深拷贝，申请新的空间填充相同内容。\n    _name = new char[strlen(name) + 1];\n    memset(_name, 0, strlen(name) + 1);\n    for(int i = 0; i < strlen(name); ++i)\n    {\n        _name[i] = name[i];\n    }\n    _name[i] = 0; \n}\n```\n## 析构函数\n\n是对象生存周期满了之后（死亡），自动调用的函数。\n```c++\n~Person()\n{\n    delete[]_name;\n}\n```\n\n1. 在栈桢上，先构造的后析构。\n2. 如果没有实现析构函数，系统会默认生成一个默认的析构函数。函数体是空的。\n3. 自己实现了之后，就不会自动生成。\n## 拷贝构造函数\n\n1. 用一个已存在的对象给另一个正在生成的对象初始化的时候自动调用的成员方法。\n2. 如果没有自己实现，会自动生成一个浅拷贝的拷贝构造函数。\n3. 如果自己实现，不会生成。\n\n```c++\nPerson(const Person& src)\n{\n\t_age = src._age;\n    _sex = src._sex;\n    //预防浅拷贝\n    _name = new char[strlen(src._name) + 1];\n    memset(_name, 0, strlen(_name) + 1);\n    for(int i = 0;i < strlen(_name); ++i)\n    {\n        _name[i] = src._name[i];\n    }\n}\nint main()\n{\n    char name1[] = {\"zhangsan\"};\n    Person p1(32, 1, name1);\n    Person p2(p1);//拷贝构造函数\n}\n```\n\n注意：\n1. 拷贝构造函数--传递引用的目的是防止死递归。因为传参（传已存在的对象）的时候，也会调用拷贝构造函数，就会一直递归下去。\n2. 要防止浅拷贝。\n## 运算符重载\n\n### 等号运算符（赋值运算）\n\n当使用一个已存在的对象，给另一个已存在的对象赋值的时候，自动调用的成员方法。\n\n如果自己不实现，会自动生成一个浅拷贝的等号运算符重载函数。自己实现了则不会。\n\n```c++\nvoid operator=(const Person& src)\n{\n    // 如果是自赋值，可以直接返回\n    if(this == &src)\n    {\n        return;\n    }\n    // 删掉原有的堆中成员属性，因为马上就要覆盖，地址会丢失，防止内存泄露\n    delete[]_name;\n    //防止浅拷贝\n    _name = new char[strlen(src._name) + 1];\n    memset(_name, 0, strlen(src.name) + 1);\n    for(int i = 0; i < strlen(src._name); ++i)\n    {\n        _name[i] = src._name[i];\n    }\n}\n\n//为了可以连等，可以加一个返回值类型。\nPerson& operator=(const Person& src)//使用引用节省内存，防止多余的重复构造\n{\n    //防止自赋值\n    if(this == &src)\n    {\n        return *this;\n    }\n    //防止内存泄露\n    delete[]_name;\n    //防止浅拷贝\n    _name = new char[strlen(src._name) + 1];\n    memset(_name, 0, strlen(src._name) + 1);\n    for(int i = 0; i < strlen(src._name); ++i)\n    {\n        _name[i] = src._name[i];\n    }\n    return *this;\n}\n```\n\n注意：\n1. 跳过自赋值\n2. 防止内存泄漏\n3. 防止浅拷贝\n### 等号重载和拷贝构造区别\n```c++\nint d(a); // 拷贝构造是用一个已存在的对象对正在定义的对象进行初始化\nint e = a;\n```\n\n```c++\nint c = int();\nc = a; // 等号重载，两个对象都已经存在\n```\n## 对象的生存周期\n\n```c++\nPerson()\n{\n    _name = NULL;\n}\nPerson fun(Person p)\n{\n    int a = 10;\n}\nint main()\n{\n    Person p1(31, 1, \"zhangsan\");\n}\n```\n\n```c++\nPerson p5 = p3;\nPerson p6(p3);\n//一样\n```\n\n```c++\nPerson p4 = 20;\n/*\n使用20生成临时对象-->看有没有对应的构造函数\n使用临时对象拷贝构造p4\n析构临时对象\n\n如果出现上述步骤，会被直接优化成构造p4\n\n--临时对象的生存周期只在当下语句。\n--在当下栈帧上（如main中的，而不是子函数中的栈帧），临时对象如果被引用，临时对象的生存周期就会被提升为和引用一致。\n--栈帧没有了，一切都失效了。\n*/\n```\n\n```c++\nPerson fun(Person& p)\n{\n    int a = 10;\n    Person tmp(10);\n    return tmp;\n}\nint main()\n{\n    Person p3;\n    p3 = fun(p3);\n    return 0;\n}\n```\n\n# 练习\n\n## 使用class封装一个数组\n\n```c++\nclass Arr\n{\npublic:\n    int *_arr;//指向堆空间\n    int _cap;//容量\n    int _cur_len;//实际\n    Arr();\n    Arr(int len);\n    Arr(const Arr& src);\n    Arr& operator=(const Arr& src);\n    ~Arr();\n    \n    void push_back();\n    void pop_back();\n    int front();\n    int back();\n    void show();\n    bool is_full();\n    bool is_empty();\n}\n```\n## 封装List\n\n```c++\nclass List\n{\n\tis_empty();\n    push_back();\n    pop_back();\n    push_front();\n    pop_front();\n    \n    ElemType front();\n    ElemType back();\n    \n    int size();\n    \n}\n```\n## 单例模式实现stack/queue\n\n```cpp\n//再依赖链表实现stack、queue——单例模式\nclass Stack\n{\n    pop()\n    {\n        _list.pop_front();\n    }\n    top()\n    {\n        return _list.front();\n    }\n    List _list;\n}\n```\n# class\n\n```c++\nclass Person\n{\npublic:\n    int _age;\n    int _sex;\n    char *_name;\n    void work()\n    {\n        cout << _name << \": work\" << endl;\n    }\n    void eat()\n    {\n        cout << _name << \": eat\" << endl;\n    }\n};//分号不要丢\n```\n## private\n\nclass中默认权限是private。\n\n```c++\nint last_name;\n\nclass Person\n{\nprivate:\n    int _age;\n    const int _sex;//常量必须初始化。\n    char *_name;\n    int& _last_name;//引用也必须初始化。\npublic:\n    Person()\n        :_sex(1),_last_name(last_name)\n    {\n        \n    }\n    Person(int age)\n    {\n        \n    }\n    Person(int age, int sex, const char *name)\n    {\n        _age = age;\n        _sex = sex;\n        _name = new char[strlen(name)+1];\n        memset(name,0,strlen(name)+1);\n        for(int i = 0;i<strlen(name);++i)\n        {\n            _name[i] = name[i];\n        }\n    }\n    Person(const Person& src)\n    {\n        \n    }\n    void operator=(const Person& src)\n    {\n        //防止自赋值\n        if(this==src)\n        {\n            return;\n        }\n        //防止内存泄露\n        delete[]_name;\n        _name = new char[strlen(src._name)+1];\n        memset(_name,0,strlen(src.name)+1);\n        for(int i = 0;i<strlen(src._name);++i)\n        {\n            _name[i] = src._name[i];\n        }\n    }\n    const char* get_name()\n    {\n\t\treturn this.name;   \n    }\n    int get_age()\n    {\n        return this.age;\n    }\n    void set_age(int age)\n    {\n        _age = age;\n    }\n    void work()\n    {\n        cout << _name << \": work\" << endl;\n    }\n    void eat()\n    {\n        cout << _name << \": eat\" << endl;\n    }\n};//分号不要丢\n```\n### 与struct区别\n\nstruct成员的默认权限是public，class成员的默认权限是private；\n## 权限选择\n\n1. 必须要为外界提供的，放在public。其他的都放在private。\n2. 一般成员属性都放在private，如果外界需要使用就提供公有接口。\n## 名词区别\n\n定义--划分内存\n\n```c++\nint a;\nPerson p;\n```\n\n初始化--定义的同时给值\n\n```c++\n\n```\n\n赋值--定义之后给值--内存划分之后给值\n\n```c++\n_sex = 1;\n```\n## 初始化列表\n\n```c++\npublic:\n    Person()\n        : _sex(1)//初始化列表。\n    {\n        \n    }\n```\n\n1. 只有构造函数有初始化列表。\n2. 必须初始化的成员需要放在初始化列表。如const修饰的成员属性。\n3. 在本对象构造之前必须要完成的动作，必须放在初始化列表。\n## 常对象\n\n```c++\nconst char* get_name() const\n{\n    return this.name;   \n}\nint get_age()\n{\n    return this.age;\n}\nint main()\n{\n    const Person p1(18, 0, \"xiaohua\");\n}\n```\n\n1. 常对象只能调用常方法——构造函数，析构函数，静态函数不影响。\n2. 常方法中只能调用常方法——静态函数不影响。\n\n为什么呢？因为，非const方法里默认的第一的参数是`Class_Name * const this`。所以不能把`Class_Name const * const this`赋给它。（常量不能赋给非常量）。\n### 哪些成员方法需要写成常方法\n\n1. 如果成员方法内不需要改动成员，并且没有对外暴露成员引用或指针，就可以直接写成常方法。\n2. 如果成员内部不需要改动成员，但是会对外暴露成员引用或指针，就写两个成员方法，奇淫巧计，效果是形成重载。\n```c++\nint& get_age()\n{\n    return _age;\n}\nint get_age()const\n{\n    return _age;\n}\n```\n3. 如果成员方法内部需要改动成员，就写成普通方法。\n## 静态成员\n\n### 变量\n\n1. 类中每个静态成员在一个类中只有一份，这个类的对象公用。\n2. 存储在数据段。\n3. 必须在类外的.cpp文件中进行初始化，只能初始化一次。\n\n```c++\n//静态成员变量的类外初始化\nint Person::_num = 0;//必须指明作用域\n```\n4. 静态成员变量的访问可以不依赖于对象--不依赖于this指针，使用类的作用域可以直接访问。\n### 方法\n```c++\nint get_num()\n{\n    return _num;\n}\nint main()\n{\n    cout << p1.get_num() << endl;//报错，因为p1是常量对象，不可调用非常方法\n    cout << p2.get_num() << endl;//可以\n    cout << Person::get_num() << endl;//报错，因为\n}\n```\n\n1. 静态成员方法没有this指针。\n2. 静态成员方法的访问可以不依赖于对象--不依赖于this指针，可以使用类的作用域直接访问。\n3. 静态成员方法内只能使用静态成员变量或方法，因为没有this指针可以拿来指向自己的成员。\n## 应用\n单例模式\n1. 把构造方法写在private里\n```c++\nclass Only\n{\n    //要求\n    //限制只能产生一个对象\n    //在项目中任意地方都可以获取到这个惟一的对象\nprivate:\n    static Only* _only;\n    Only();\n    static mutex _lock;//#include<mutex>\npublic:\n    static Only* get_Only()\n    {\n        if(NULL == _only)\n        {\n            _lock.lock;\n            if(NULL==_only)\n            {\n                _only = new Only();\n                return _only;\n            }\n            _lock.unlock;\n        }\n\n        \n    }\n    \n}\n```\n## 嵌套类\n\n1. 按类与类之间的关系来说，组合关系：一个类是另一个类的一部分。\n2. 一个类在另一个类的内部实现。\n3. 权限属性依然生效。\n4. 外界访问嵌套类需要用到外层类的作用域。\n\n1. 成员对象：先构造内部类对象，再构造自己。\n2. 析构时，先析构自己，再析构内部类对象。\n3. 如果成员对象没有默认的构造函数，必须手动写在初始化列表。\n## 代理关系\n\n一个类的接口功能完全依赖于另一个类的接口功能。\n## 类的编译顺序\n\n成员变量必须放在成员方法的前面，否则成员方法编译的时候无法知道成员变量的存在。\n\n1. 编译类名\n2. 编译成员名 = 编译嵌套类\n3. 编译成员方法体\n# 缺省函数\n\n```cpp\nclass Int\n{\n    int value;\n    int sum;\npublic:\n    Int(int x)\n        :\n    {\n        \n    }\n    void Print()const\n    {\n        printf(\"value = %d, sum = %d\\n\",value,sum);\n    }\n}\n```\n\n```cpp\n// 缺省的拷贝构造函数\n{\n    const& Int(const& Int src)\n    {\n        if(this != &src)\n        {\n            value = src.value;\n            sum = src.value;\n        }\n        return *this;\n    }\n    const& Int operator=(const& Int src)\n    {\n        \n    }\n}\n```\n\n# 对象\n\n```cpp\nclass CGoods\n{\nprivate:\n    char Name[20];\n\tint Amount;\n    float Price;\n    float Total;\npublic:\n    void RegisterGoods(const char *name, int amount, float price);\n    int GetAmount()\n    {\n        return Amount;\n    }\n    float GetTotal()\n    {\n        return Total;\n    }\n};\nvoid CGoods::RegisterGoods(const char *name, int amount, float price)\n{\n    strcpy_s(Name, 20, name);\n    Amount = amount;\n    Price = price;\n    Total = Amount * Price;\n}\nint main()\n{\n    CGoods tea;\n    CGoods book;\n    tea.RegisterGoods(\"black_tea\",12,560);\n    book.RegisterGoods(\"Thinking in C++\",100,98.9f);\n    \n    int x = tea.GetAmount();\n    x = book.GetAmount();\n}\n```\n\n1. 类是一种数据类型，定义时系统不为类分配存储空间，所以不能对类的数据成员初始化。\n2. 类中的任何数据成员也不能使用关键字extern、auto或register限定其存储类型。\n3. 函数在类中声明后，在类中定义则默认为内联函数，在类外定义则默认不为内联函数，需要主动加上。\n## 对象的创建与使用\n\n对象是类的实例。声明一种数据类型只是告诉编译系统该数据类型的构造，并没有预定内存。类只是一个样板（图纸），以此样板可以在内存中开辟出同样结构的实例--对象。\n\n创建类的对象有两种常用方法。\n第一种是直接定义类的实例--对象：\n```cpp\nint a;\nCGoods Car;\n```\n\n这个定义创建了CGoods类的一个对象Car，同时为它分配了属于它自己的存储块，用来存放数据和对这些数据实施操作的成员函数（代码）。对象只在定义它的域中有效。\n\n第二种是用new来创建。\n```cpp\nCGoods s1;//对象构建在数据区，还没进入主函数就构建好了。\nint main()\n{\n    int a = 10;\n    CGoods c1;//整个对象构建在栈区，首地址为&c1\n    CGoods *cp = new CGoods();//对象用new构建在堆区，在栈区用一个指针保存其首地址cp。\n    delete cp;\n}\n```\n\n# 运算符重载\n\n1. 一元运算符：`*`、`++`、`--`\n2. 二元运算符：`+`、`-`、`=`、`&&`、`||`\n3. 三元运算符：` : ? `\n\n```cpp\nint main()\n{\n    string s1 = \"aaaa\";\n    string s2 = \"bbbbb\";\n    string s3 = s1 + s2;\n    cout << s3 << endl;\n}\n```\n\n```cpp\nclass Complex\n{\npublic:\n    Complex();\n    Complex(int a, int b);\n    \n    Complex(const Complex& src);\n    Complex& operator=(const Complex& src);\n    Complex  operator+(const Complex& src) const;\n    Complex  operator-(const Complex& src) const;\n    ~Complex();\n    friend ostream& operator <<(ostream& out, const Complex& src);\nprivate:\n    int _a;//实部\n    int _b;//虚部\n};\n```\n\n```cpp\nComplex()\n{\n    \n}\nComplex(int a, int b)\n{\n    _a = a;\n    _b = b;\n}\nComplex operator+(const Complex& src)const\n{\n    int a = _a + src._a;\n    int b = _b + src._b;\n    return Compare(a,b);\n}\nComplex operator-(const Complex& src)const\n{\n    int a = _a - src._a;\n    int b = _b - src._b;\n    return Compare(a,b);\n}\nbool operator&&(const Complex& src)const\n{\n    return _a && src._a;\n}\nvoid operator <<(ostream& out)\n{\n    out << _a << \"+\" << _b << \"i\" << endl;\n}\nvoid operator <<(ostream& out, const Complex& src)\n{\n    out << src._a << \"+\" << src._b << \"i\" << endl;\n}\n\nComplex& operator++()//前置++\n{\n    ++_a;\n    return *this;//退出函数时，this指针还有效。\n}\nComplex operator ++(int)//后置++，int没用，只作为标志是后置\n{\n    int tmp = _a;\n    _a++;\n    return Complex(tmp, _b);//临时对象，不能返回引用\n}\n\nostream& operator <<(ostream& out, const Complex& src)\n{\n\tout << src._a << \"+\" << src._b << \"i\" << endl;\n\treturn out;\n}\n\n//- -- || >>\nint main()\n{\n    string s1 = \"aaaa\";\n\tstring s2 = \"bbbbb\";\n\n\tstring s3 = s1 + s2;\n\tcout << s3 << endl;\n\n\n\tComplex c1(1, 2);\n\tComplex c2(2, 3);\n\n\tComplex c3 = c1 + c2;\n\n\tif (c1 && c2)\n\t{\n\t\tcout << \"all 0\" << endl;\n\t}\n\n\tostream& oo = cout;\n\too << s1 << endl;\n\n\t//c1.operator<<(cout);\n\n\tcout << c1 << c2 <<endl;\n\n\n\tc1++;\n\t//++c1;\n\tcout << c1 << endl;\n\t//c1--;\n\t//--c1;\n\n\treturn 0;\n}\n```\n## 输入输出重载\n\n### `<<`重载\n\nostream是iostream的一个类。cout就是这个类的对象，在屏幕上输出东西。\n\n```cpp\nostream oo = cout;//不允许，只能有一个ostream对象，默认已创建好，为cout。\n//我们可以利用引用，起个别名。\nostream& oo = cout;\noo << \"abc\" << endl;\n```\n### `>>`重载\n\nistream也是iostream中的一个类。cin就是这个类的对象，从键盘获取数据给其他对象。\n\n```cpp\nvoid operator <<(ostream& out)\n{\n    out << _a << \"+\" << _b << \"i\" << endl;\n}\nint main()\n{\n    cout << c1 << endl;//报错\n    //只能写成如下形式：\n    c1 << cout;\n}\n\n```\n\n改进：\n\n```cpp\nvoid operator <<(ostream& out)\n{\n    \n}\n```\n\n## 练习\n\nBigNum\n\n```cpp\nclass BigNum\n{\n    BigNum(int);\n    BigNum(const char*);\n    BigNum& operator++();\n    BigNum  operator++(int);\n    BigNum& operator--();\n    BigNum  operator--(int);\nprivate:\n    string _num;\n};\n```","tags":["tulun"],"categories":["Cpp"]},{"title":"基础数据结构_栈","url":"/基础数据结构/基础数据结构_栈/","content":"# 顺序栈\n\n## 头文件\n\n```c\n#ifndef MY_SEQSTACK_H\n#define MY_SEQSTACK_H\n\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define NULLPTR -3\n\ntypedef int Status;\n\n#define STACK_INIT_SIZE 100\n#define STACKINC 1.5\ntypedef int SElemType;\ntypedef struct\n{\n    SElemType *base;//栈底指针\n    SElemType *top;//栈顶指针\n    int stacksize;//栈的容量\n}SeqStack;\n\nStatus InitStack(SeqStack *ps);\nvoid DestroyStack(SeqStack *ps);\nvoid ClearStack(SeqStack *ps);\nint StackLength(const SeqStack *ps);\nbool StackEmpty(const SeqStack *ps);\nbool StackFull(const SeqStack *ps);\nStatus Push(SeqStack *ps, SElemType val);\nStatus GetTop(SeqStack *ps, SElemType *pval);\nStatus Pop(SeqStack *ps, SElemType *pval);\n\n\n#endif\n```\n\n## 实现\n\n```c\n//My_SeqStack.cpp\n#include<stdlib.h>//malloc free\n#include<assert.h>\n\n#include\"My_SeqStack.h\"\nStatus InitStack(SeqStack *ps)\n{\n    assert(ps!=NULL);\n    ps->base = (SElemType *)malloc(sizeof(SElemType)*STACK_INIT_SIZE);\n    if(NULL==ps->base)\n    {\n        return OVERFLOW;\n    }\n    ps->top = ps->base;\n    ps->stacksize = STACK_INIT_SIZE;\n    return OK;\n}\nvoid DestroyStack(SeqStack *ps)\n{\n\tassert(ps!=NULL);\n    free(ps->base);\n    ps->base = NULL;\n    ps->top = NULL;\n    ps->stacksize = 0;\n}\nvoid ClearStack(SeqStack *ps)\n{\n    assert(ps!=NULL);\n    ps->top = ps->base;\n}\nint StackLength(const SeqStack *ps)\n{\n    assert(ps!=NULL);\n    return ps->top - ps->base;\n}\nbool StackEmpty(const SeqStack *ps)\n{\n    assert(ps!=NULL);\n    return ps->top == ps->base;\n    //return StackLength(ps)==0;\n}\nbool StackFull(const SeqStack *ps)\n{\n    assert(ps!=NULL);\n    return StackLength(ps)==ps->stacksize;\n}\nbool IncSize(SeqStack *ps)\n{\n    assert(ps!=NULL);\n    int newsize = ps->stacksize * STACKINC;\n    SElemType *newdata = (SElemType*)realloc(ps->base,sizeof(SElemType)*newsize);\n    \n    if(NULL==newdata)return false;\n    ps->base = newdata;\n    \n    ps->top = ps->base + ps->stacksize;\n    \n    ps->stacksize = newsize;\n    return true;\n}\nStatus Push(SeqStack *ps, SElemType val)\n{\n    assert(ps!=NULL);\n    if(StackFull(ps) && !IncSize(ps))\n    {\n        return OVERFLOW;\n    }\n    *(ps->top) = val;\n    ps->top += 1;\n    return OK;\n}\nStatus GetTop(const SeqStack *ps, SElemType *pval)\n{\n    assert(ps!=NULL);\n    if(StackEmpty(ps))\n    {\n        return ERROR;\n    }\n    if(NULL == pval)return NULLPTR;\n    *pval = *(ps->top-1);\n    return OK;\n}\nStatus Pop(SeqStack *ps, SElemType *pval)\n{\n    assert(ps !=NULL);\n    if(StackEmpty(ps))\n    {\n        return ERROR;\n    }\n    if(NULL==pval)return NULLPTR;\n    \n    ps->top -= 1;\n    *pval = *(ps->top);\n    return OK;\n}\n```\n\n## 测试\n\n```c\n//TestStack.cpp\n#include<stdio.h>\n#include\"My_SeqStack.h\"\nint main()\n{\n    SeqStack mys;\n    InitStack(&mys);\n    for (int i = 0;i < 10;++i)\n    {\n        Push(&mys, i);\n    }\n    int val;\n    while (!StackEmpty(&mys))\n    {\n        Pop(&mys, &val);\n        printf(\"%d \", val);\n    }\n    DestroyStack(&mys);\n}\n```\n\n# 链栈\n\n## 头文件\n\n```c\n//LinkStack.h\n#ifndef LINKSTACK_H\n#define LINKSTACK_H\n\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define OVERFLOW -2\n#define NULLPTR -3\n\ntypedef int Status;\n\ntypedef int SElemType;\ntypedef struct StackNode\n{\n    SElemType data;\n    struct StackNode *next;\n}StackNode,*PStackNode;\ntypedef struct\n{\n    StackNode *top;\n    int cursize;\n}LinkStack;\n\nStatus InitStack(LinkStack *ps);\nvoid DestroyStack(LinkStack *ps);\nvoid ClearStack(LinkStack *ps);\nint StackLength(const LinkStack *ps);\nbool StackEmpty(const LinkStack *ps);\nbool StackFull(const LinkStack *ps);\nStatus Push(LinkStack *ps, SElemType val);\nStatus GetTop(LinkStack *ps, SElemType *pval);\nStatus Pop(LinkStack *ps, SElemType *pval);\n#endif\n```\n\n## 实现\n\n```c\n//LinkStack.cpp\n#include<stdlib.h>\n#include<assert.h>\n#include<string.h>\n#include\"LinkStack.h\"\nStackNode* Buynode()\n{\n    StackNode *newnode = (StackNode*)malloc(sizeof(StackNode));\n    if(NULL!=newnode)\n    {\n        memset(newnode,0,sizeof(StackNode));\n    }\n    return newnode;\n}\nStatus InitStack(LinkStack *ps)\n{\n    assert(ps!=NULL);\n    ps->top = Buynode();//头结点\n    if(NULL == ps->top)return OVERFLOW;\n    \n    ps->cursize = 0;\n    return OK;\n}\nvoid DestroyStack(LinkStack *ps)\n{\n    assert(ps!=NULL);\n    ClearStack(ps);\n    free(ps->top);\n    ps->top = NULL;\n    return OK;\n}\nvoid ClearStack(LinkStack *ps)\n{\n    assert(ps!=NULL);\n    while(ps->cursize!=0)\n    {\n        DelFront(ps);\n    }\n    return OK;\n}\nint StackLength(const LinkStack *ps)\n{\n    assert(ps!=NULL);\n    return ps->cursize;\n}\nbool StackEmpty(const LinkStack *ps)\n{\n    assert(ps!=NULL);\n    return ps->cursize == 0;\n}\nStatus Push(LinkStack *ps, SElemType val)\n{\n    assert(ps!=NULL);\n    StackNode *newnode = Buynode();\n    if(NULL==newnode)return OVERFLOW;\n    \n    newnode->next = ps->top->next;\n    ps->top->next = newnode;\n    \n    newnode->data = val;\n    \n    ps->cursize +=1;\n    return OK;\n}\nStatus GetTop(LinkStack *ps, SElemType *pval)\n{\n    assert(ps!=NULL);\n    if(pval==NULL)return NULLPTR;\n    if(ps->cursize<=0)return false;\n    *pval = ps->top->next->data;\n    return OK;\n}\nStatus Pop(LinkStack *ps, SElemType *pval)\n{\n    assert(ps!=NULL);\n    if(pval==NULL)return NULLPTR;\n    if(ps->cursize<=0)return ERROR;\n    GetTop(ps,pval);\n    DelNext(ps);\n    return OK;\n}\nbool DelFront(LinkStack *ps)\n{\n    assert(ps!=NULL);\n    if(ps->cursize<=0)return false;\n    StackNode *p = ps->top->next;\n    ps->top->next = p->next;\n    free(p);\n    ps->cursize-=1;\n    return true;\n}\n```\n\n\n\n## 测试\n\n```c\n```\n\n","categories":["基础数据结构"]},{"title":"Cpp_函数调用过程","url":"/Cpp/Cpp_函数调用过程/","content":"\n# 函数调用过程\n\n1. 参数入栈\n2. 函数栈帧开辟\n3. 返回值返回\n4. 函数栈退出\n\n# 代码\n\n```c\n//4字节入栈\n#include<stdio.h>\nvoid fun(int a, int b)\n{\n    int c;\n    c = a + b;\n    return c;\n}\nint main()\n{\n    int a = 10;\n    int b = 20;\n    fun(a,b);\n    return 0;\n}\n```\n\n```c\n//8字节入栈\nstruct Node\n{\n    int _1;\n    int _2;\n};\nint fun(struct Node a, struct Node b)\n{\n    int c = 30;\n    return c;\n}\nint main()\n{\n    struct Node a = {10, 20};\n    struct Node b = {30, 40};\n    fun(a, b);\n    return 0;\n}\n```\n\n```c\n//12字节入栈\nstruct Node\n{\n    int _1;\n    int _2;\n    int _3;\n};\nint fun(struct Node a, struct Node b)\n{\n    int c = 30;\n    return c;\n}\nint main()\n{\n    struct Node a = {10, 20, 30};\n    struct Node b = {40, 50, 60};\n    fun(a, b);\n    return 0;\n}\n```\n\n![image-20211001184239521](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211001184239521.png)\n\n# 寄存器\n\n可以理解为CPU中的变量\n\n如何去标志一个栈？——栈底和栈顶指针。\n\nesp：栈顶寄存器。\n\nebp：栈底寄存器。\n\n# 函数调用过程\n\n1. 参数入栈（C语言）\n\n   1. 4字节参数（dword）入栈\n\n      1. 顺序：从右向左\n      2. 方式：使用寄存器push带入\n\n   2. 8字节参数入栈\n\n      1. 顺序：从右向左\n      2. 方式：使用寄存器分两次push带入\n\n   3. （>8字节）12字节参数入栈\n\n      ![image-20211001184251000](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211001184251000.png)\n\n      1. 顺序：从右向左\n      2. 方式：变了，**栈顶先上移，即开辟足够的空间**，之后利用寄存器将数据分批次复制进去。\n\n   4. C++中，只要是自定义类型，无论多大字节，都采用先esp上移开辟空间，之后分次赋值的方式（即方式3），即>8字节的情况。\n\n2. 函数栈帧开辟\n   其中，1、2步是为了保存现场。3、4步是开辟新的栈帧。\n\n   1. 函数入参的动作完成后，汇编代码执行call(_fun)语句，esp向上移4位，将**调用方函数原来的下一行指令地址**存入栈。因为main中调用完成外部函数后，还要回到以前的位置。\n      ![image-20211018205543731](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018205543731.png)\n      ![image-20211018205624299](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018205624299.png)\n   2. 将**调用方函数的栈底寄存器**（ebp）入栈\n      ![image-20211018205322518](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018205322518.png)\n   3. **让`ebp=esp`**（让ebp上移到esp的位置）\n   4. **让`esp=esp-0**h`**（上移若干空间，开辟此函数的空间）\n   5. 将某些寄存器（线程保护）入栈\n   6. 将新开辟的栈帧空间中全部赋为`0xcccccccc`\n\n3. 函数返回值\n\n   1. 4字节返回值：将返回值先存到eax再赋给接收变量\n      ![image-20211018210146635](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018210146635.png)\n      ![image-20211018210420665](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018210420665.png)\n\n   2. 8字节返回值：将返回值分开放到两个寄存器，再赋给接收变量\n      ![image-20211018210458734](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018210458734.png)\n\n      ![image-20211018210558730](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018210558730.png)\n      ![image-20211018210607525](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018210607525.png)\n      ![image-20211018210900593](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018210900593.png)\n\n   3. （>8字节）12字节返回值：\n\n      1. 在函数参数入栈之后，入栈一个调用方（如main）栈帧上的地址（靠近栈顶位置）\n      2. 在返回值返回的时候，将返回数据分次写入到之前入栈的调用方地址上。\n      3. 返回之后，将从该地址（调用方（如main）栈帧上的地址）将数据分次取出（一次4字节）到接收变量中。\n\n      ![image-20211001213921252](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211001213921252.png)\n\n   4. C++中，自定义类型都按照入栈一个调用方地址的方式\n\n4. 函数栈退出\n\n   1. 进行当前函数栈帧的校验\n   2. 将线程保护的寄存器出栈\n   3. 让`esp=ebp`（回缩栈帧）\n   4. `pop`操作（即将pop的位置是esp指向的位置）。\n      `pop ebp`，意为：`ebp=pop`，`esp`指向的是原来`main`的`ebp`地址，赋给`ebp`，同时`esp`下移4字节。则`ebp`回指到原来的位置。形成现场恢复。\n      ![image-20211018233157527](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018233157527.png)\n   5. 将下一行指令的地址还原（`ret`），实际上，也是一个`pop`，返回保留的地址值，`esp`下移4字节。\n   6. esp再次下移若干，清除参数和之前入栈的调用方地址。下移之后，则esp和ebp回到了main函数调用外部函数之前的原始位置。函数调用结束。\n      ![image-20211018233852672](../../images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/image-20211018233852672.png)\n\n# 说明\n\n当前演示的函数调用规则是依赖于C语言默认的调用约定`__cdecl`，其他的还有`__stdcall`/`__fastcall`。三种差异并不大，只是负责的事情不同，清除参数是调用方执行的，`stdcall`是被调用方执行的。\n\n```c\nstruct Node __cdecl fun(int a, int b)\n{\n    struct Node c = {10, 20, 30};\n    return c;\n}\n```\n\n","categories":["Cpp"]},{"title":"基础数据结构_循环单链表","url":"/基础数据结构/基础数据结构_循环单链表/","content":"# 声明\n\n```c\n#ifndef CLIST_H\n#define CLIST_H\ntypedef int ElemType;\ntypedef struct CNode\n{\n    ElemType data;\n    struct CNode* next;//指针域\n}CNode, * PCNode;\n//可执行操作\n//初始化\nvoid Init_clist(struct CNode* plist);\n//头插\nbool Push_Front(PCNode plist, int val);\n//尾插\nbool Push_Back(PCNode plist, int val);\n//按位置插\nbool Insert_Pos(PCNode plist, int pos, int val);\n//头删\nbool Pop_Front(PCNode plist);\n//尾删\nbool Pop_Back(PCNode plist);\n//按位置删\nbool Del_Pos(PCNode plist, int pos);\n//按值删除\nbool Del_Val(PCNode plist, int val);\n//查找\nstruct CNode* Search(PCNode plist, int val);\n//找值为val的节点前驱\nstruct CNode* Get_Prev(PCNode plist, int val);\n//找值为val的节点后继\nstruct CNode* Get_Next(PCNode plist, int val);\n//获取其有效节点的个数\nint Get_Length(PCNode plist);\n//清空\nvoid Clear(PCNode plist);\n//销毁1\nvoid Destroy1(PCNode plist);\n//销毁2\nvoid Destroy2(PCNode plist);\n//判空\nbool IsEmpty(PCNode plist);\n//打印\nvoid Show(PCNode plist);\n#endif\n\n\n```\n\n# 实现\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\n#include\"clist.h\"\n\nstruct CNode* Buynode()\n{\n    CNode* newnode = (CNode*)malloc(sizeof(CNode));\n    if (NULL == newnode)\n    {\n        printf(\"memory error\");\n        exit(1);\n    }\n    return newnode;\n}\n//可执行操作\n//初始化\nvoid Init_clist(struct CNode* head)\n{\n    assert(head != NULL);\n    head->next = head;\n}\n//查到ptr下一个\nbool Insert_Next(CNode* ptr, int val)\n{\n    assert(ptr);\n    CNode* pnewnode = Buynode();\n    pnewnode->next = ptr->next;\n    ptr -> next = pnewnode;\n    pnewnode->data = val;\n    return true;\n}\n//头插\nbool Push_Front(PCNode head, int val)\n{\n    assert(head);\n    return Insert_Next(head, val);\n}\n//尾插\nbool Push_Back(PCNode head, int val)\n{\n    assert(head);\n    CNode* p = head;\n    while (p->next != head)\n    {\n        p = p->next;\n    }\n    return Insert_Next(p, val);\n}\n//按位置插\nbool Insert_Pos(PCNode head, int pos, int val)\n{\n    assert(head);\n    if (pos < 0)return false;\n    CNode* pnode = head;\n    while (pnode->next != head && pos--)\n    {\n        pnode = pnode->next;\n    }\n    if (pos != 0)\n    {\n        return false;\n    }\n    return Insert_Next(pnode, val);\n}\n//删除下一个\nbool Del_Next(CNode* ptr)\n{\n    assert(ptr);\n    CNode* p = ptr->next;\n    ptr->next = p->next;\n    free(p);\n    return true;\n}\n//头删\nbool Pop_Front(PCNode head)\n{\n    assert(head);\n    if (head == head->next)//只有头结点不行\n    {\n        return false;\n    }\n    return Del_Next(head);\n}\n//尾删\nbool Pop_Back(PCNode head)\n{\n    assert(head);\n    CNode* p = head;\n    if (head == p->next)//只有头结点不行\n    {\n        return false;\n    }\n    while (p->next->next != head)\n    {\n        p = p->next;\n    }\n    return Del_Next(p);\n}\n//按位置删\nbool Del_Pos(PCNode head, int pos)\n{\n    assert(head);\n    if (pos < 0)return false;\n    CNode* p = head;\n    if (NULL == p->next)return false;\n    int count = pos - 1;\n    while (p->next != head && count--)\n    {\n        p = p->next;\n    }\n    if (count != -1)\n    {\n        return false;\n    }\n    return Del_Next(p);\n}\n//按值删除\nbool Del_Val(PCNode head, int val)\n{\n    assert(head);\n    CNode* p = head;\n    if (NULL == p->next)return false;\n    while (p->next != head && val != p->next->data)\n    {\n        p = p->next;\n    }\n    if (p->next == head)\n    {\n        return false;\n    }\n    return Del_Next(p);\n}\n//查找\nstruct CNode* Search(PCNode plist, int val);\n//找值为val的节点前驱\nstruct CNode* Get_Prev(PCNode plist, int val);\n//找值为val的节点后继\nstruct CNode* Get_Next(PCNode plist, int val);\n//获取其有效节点的个数\nint Get_Length(PCNode head)\n{\n    assert(head);\n    CNode* p = head;\n    int count = 0;\n    while (p->next != head)\n    {\n        count++;\n    }\n    return count;\n}\n//判空\nbool IsEmpty(PCNode head)\n{\n    assert(head);\n    if (head->next == head)return true;\n    return false;\n}\n//清空\nvoid Clear(PCNode head)\n{\n    assert(head);\n    while (!IsEmpty(head))\n    {\n        Pop_Front(head);\n    }\n}\n//销毁1\nvoid Destroy1(PCNode head)\n{\n    assert(head);\n    Clear(head);\n}\n//销毁2\nvoid Destroy2(PCNode plist);\n//打印\nvoid Show(PCNode head)\n{\n    assert(head);\n    CNode* p = head->next;\n    while (p != head)\n    {\n        printf(\"%3d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\nint main()\n{\n    CNode cn;\n    Init_clist(&cn);\n    for (int i = 0;i < 10;i++)\n    {\n        Insert_Pos(&cn, i,i+1);\n\n    }\n    Show(&cn);\n    Push_Front(&cn, 100);\n    Push_Back(&cn, 200);\n    Show(&cn);\n\n    Pop_Front(&cn);\n    Pop_Back(&cn);\n    Show(&cn);\n\n    Del_Val(&cn, 6);\n    Show(&cn);\n    Del_Pos(&cn, 6);\n    Show(&cn);\n    Destroy1(&cn);\n    Show(&cn);\n}\n\n```\n\n","categories":["基础数据结构"]},{"title":"Cpp_C和C++区别","url":"/Cpp/Cpp_体系内容_C和C++区别/","content":"# C++体系内容\n要掌握C++，需要建立以下知识体系：\n* 编译链接过程\n* 函数调用过程\n* C和C++区别\n    * 基础部分和C++基本一样，只需区分\n    * 数组、循环、判断、宏不再讲，一样\n* 面向对象\n* 运算符重载\n* 模板\n* 继承与多态\n* STL：容器、泛型算法、函数对象\n* 智能指针\n* C++项目\n\n本篇文章通过介绍C和C++的区别，一窥C++的体系形态。\n# 输入输出\n\n```cpp\n#include<stdio.h>\nint main()\n{\n    int a = 0;\n    char ch = '\\0';\n    scanf(\"%d %c\", &a, &ch);\n    printf(\"a = %d , ch = %c \\n\", a, ch);\n    return 0;\n}\n```\n\n```cpp\n#include<iostream>\nusing namespace std;\nint main()\n{\n    int a = 0;\n    char ch = '\\0';\n    cin >> a >> ch;//不可写作cin >> a, ch;\n    cout << \"a = \" << a << \"\\t\" << \"ch = \" << ch << endl;\n    return 0;\n}\n```\n\n# 函数的区别\n\n## 函数参数默认值\n\n```c++\nint fun(int a, int b, int c)\n{\n    cout << a << endl;\n    cout << b << endl;\n    cout << c << endl;\n    return 0;\n}\n```\n\n\n```c++\nint fun(int a, int b, int c = 10)\n{\n    cout << a << endl;//<<为输出运算符。\n    cout << b << endl;\n    cout << c << endl;\n    return 0;\n}\nint main()\n{\n    int a = 1;\n    int b = 2;\n    fun(a,b);\n    //知识点：函数的默认值参数：如果不传c，则填充默认值，push 0Ah，其他的参数push eax。\n    //在函数声明或者定义的时候给定参数默认值；如果实参传递的时候不给该形参传值，则会按照默认值传参。\n    //函数的默认值参数 是在编译期，生成指令的时候，直接生成入参指令。\n    //函数参数默认值不能传递变量，必须是常量。因为变量在编译期时无法取值。\n    return 0;\n}\n```\n\n```c++\n//以下情况不可以，在调用此函数时，会出现歧义。因此编译器不能通过。\n//函数的参数只能从右向左依次连续赋值，不能跳过\nint fun(int a, int b = 10, int c)\n{\n    cout << a << endl;\n    cout << b << endl;\n    cout << c << endl;\n    return 0;\n}\n```\n\n```c++\n//但是如下代码可以运行，结果为1, 10, 20.\n//相当于fun函数在定义时定义c的默认值为20，在声明时定义b的默认值为10。\nint fun(int a, int b, int c = 20)\n{\n    cout << a << endl;//<<为输出运算符。\n    cout << b << endl;\n    cout << c << endl;\n    return 0;\n}\nint fun(int a, int b = 10, int c);\nint main()\n{\n    int a1=1;\n    fun(a1);\n}\n```\n\n\n\n```c++\n//错误，函数的默认值参数在同一作用域只能赋值一次，不能重复给相同的一个参数赋值。\nint fun(int a, int b, int c = 20)\n{\n    cout << a << endl;//<<为输出运算符。\n    cout << b << endl;\n    cout << c << endl;\n    return 0;\n}\nint fun(int a, int b, int c = 30);\n//无法运行，提示参数默认值重定义赋值。\n```\n\n```c++\n//不可行。编译是针对单文件的，所以不能知道在其他文件函数中定义的函数参数默认值\n#fun.cpp\nint fun(int a, int b, int c = 20)\n{\n    cout << a << endl;\n    cout << b << endl;\n    cout << c << endl;\n    return 0;\n}\n#main.cpp\nint fun(int a, int b, int c);\nint main()\n{\n    int a1 = 1;\n    int b1 = 2;\n    fun(a1,b1);\n    return 0;\n}\n```\n\n### 总结\n\n因为函数参数的默认值是在编译器带入的，所以函数的参数的默认值只能在本单文件（不包括头文件，头文件的信息是在预编译期就展开了。）生效。\n\n## inline和内联\n\n在调用内联函数时，该函数会在调用点将代码展开（复制）。\n\n```c++\ninline int fun1(int a, int b)\n{\n    int c = a + b;\n    cout << c << endl;\n    return c;\n}\nint main()\n{\n    int a1 = 1;\n    int b1 = 2;\n    fun1(a1,b1);\n    return 0;\n}\n```\n\n### 与一般函数的对比\n\n* 一般函数调用是一个消耗很大的过程\n    1. 传参\n    2. call调用函数\n    3. 开辟栈帧\n    4. 如果有返回值则返回结果\n    5. 栈帧回退\n    6. 参数清除\n\n\n* 内联函数\n    1. 在函数的调用点展开（函数体中的指令复制过去）\n    2. 不用传参\n    3. 不用call\n    4. 不用...\n\n\n### debug和release对比\n\n* 在debug版本，内联函数失效，和正常函数调用方式一致；\n* 在release版本，在调用内联函数时候，该函数会在调用点展开。\n\n### 哪些函数不能被展开\n\n内联函数是在编译时期，生成指令时展开的。\n\n* 递归函数无法展开。因为递归函数的终止条件一定需要由变量决定，递归层数不定。而编译期是无法得知变量的具体值。所以递归函数不能被处理为内联函数。\n\n### inline和内联的关系\n\n```c++\ninline int fun1(int a, int b)\n{\n    fun1(a,b);\n    //不报错，只警告\n}\n```\n\n为何不会报错？\n\n**inline只是对编译器、CPU的建议**，声明建议将该函数处理为内联。实际情况由编译器视情况决定。意思就是：虽然有的函数加了inline修饰，但是结果不一定被内联处理。\n\n## 宏函数、static函数、内联函数的对比\n\n### 宏函数\n\n```cpp\n#define SUM(a,b) {a+b;}\n```\n\n1. 预编译时期在调用点展开\n2. 无法调试\n3. 没有参数类型安全校验，因为它连类型都无法指出\n4. 作用域：单文件可见\n5. 预编译期就展开了，不生成符号\n\n### static函数\n\n1. 不展开\n2. 可以调试\n3. 有参数类型安全校验\n4. 作用域：单文件可见\n5. 生成local型符号\n\n### 内联函数\n\n1. debug版本不展开；release版本在调用点展开\n2. debug版本可以调试；release版本不可调试\n3. 有参数类型安全校验\n4. 作用域：单文件可见\n5. debug生成local符号；release版本不生产符号。\n    * 为何在release版本不生成符号？：编译期间已经展开了，相当于函数签名是透明的，不能生成符号\n    * 为何在debug版本生成符号？：debug要求能够调试函数，既然要调试函数，就要知道函数的详细信息，不能内联处理，所以要生成符号以标识。\n    * 为何debug版本生成的是local符号？：编译期只处理、生成单文件，内联函数本意是只展开在本单文件中，不能用于其他文件，所以只能是local符号。\n\n### 普通函数\n\n不展开，可以调试，有参数类型校验，多文件可见，生成global符号。\n\n## 函数的重载-静多态\n\n函数的重载--静多态--编译时期的多态--早绑定\n\n### 函数的原型\n\n函数的重载就要看准函数的原型：包括函数返回类型、函数名、形参列表（其中形参名可省略），且不需要函数体。\n\n但是我们不能拿函数返回类型作为重载的标志，因为会产生**二义性**。\n\n```cpp\nchar Max(char a, char b)\n{\n    return a>b?a:b;\n}\nint Max(char a, char b)\n{\n    return a>b?a:b;\n}\n//如此如果能编译通过的话，你说你是返回char还是返回int？char本质上也是一个整型！所以不能这样编写。\n```\n\n所以Cpp中的重载就是：函数名相同，参数列表不同。\n\n### 按函数生成的符号区分函数\n\n符号不能同名，否则被认为是重定义。因此生成的符号不能一样。\n\nCpp中的函数可以重载，C语言不可以。因为C语言和Cpp生成函数符号的效果不同。\n\n* C语言生成函数符号**仅依赖函数名**。\n\n```c++\n//c语言的写法\nbool compare1(int a, int b)\n{\n    return a > b;\n}\nbool compare2(char a, char b)\n{\n    return a > b;\n}\nint main()\n{\n    int a1 = 1;\n    int b1 = 2;\n    \n    char a2 = 'c';\n    char b2 = 'b';\n    \n    compare1(a1,b1);\n    compare2(a2,b2);\n}\n```\n\n* C++生成函数符号依赖**函数名和参数列表**（返回值不影响）。\n\n```c++\nbool compare(int a, int b)\n{\n    cout << \"bool compare(int a, int b)\" << endl;\n}\nbool compare(char a, char b)\n{\n    cout << \"bool compare(char a, char b)\" << endl;\n}\n```\n\n### 静多态\n\n函数重载后，究竟调用哪个函数？是在编译时期决定的，因为编译生成指令和符号，才能确定call哪个具体的函数——静多态的一种\n\n```c++\n//可以运行，因为虽然main中只是声明，但是会生成UND符号，会寻找链接。\n#fun.cpp\nbool compare(int a, int b)\n{\n    cout << \"bool compare(int a, int b)\" << endl;\n}\nbool compare(char a, char b)\n{\n    cout << \"bool compare(char a, char b)\" << endl;\n}\n#main.cpp\nbool compare(int a, int b);//*UND*\nbool compare(char a, char b);\nint main()\n{\n    int a1 = 1;\n    int b1 = 2;\n    \n    char a2 = 'c';\n    char b2 = 'b';\n    \n    compare1(a1,b1);\n    compare2(a2,b2);\n}\n```\n\n### 名字修饰约定（名字粉碎）\n\n![image-20220104201210066](../../images/Cpp第一课_C和C++区别/image-20220104201210066.png)\n\n#### 修饰名(Decoration name)\n\n“C”或者“C++”函数在内部（编译和链接）通过修饰名识别。修饰名是编译器在编译函数定义或者原型时生成的字符串。有些情况下使用函数的修饰名是必要的，如在模块定义文件里头指定输出“C++”重载函数、构造函数、析构函数，又如在汇编代码里调用“C”或“C++”函数等。\n\n修饰名由函数名、类名、调用约定、返回类型、参数等共同决定。\n\n#### 名字修饰约定\n\n名字修饰约定随调用约定和编译种类(C或C++文件)的不同而变化。下面分别说明。 \n\n* C编译时函数名修饰约定规则：\n    1. `__stdcall`调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为`_functionname@number`。\n    2. `__cdecl`调用约定仅在输出函数名前加上一个下划线前缀，格式为`_functionname`。\n    3. `__fastcall`调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，格式为`@functionname@number`。\n\n它们均不改变输出函数名中的字符大小写，这和PASCAL调用约定不同，PASCAL约定输出的函数名无任何修饰且全部大写。\n\n* C++编译时函数名修饰约定规则：\n    1. `__stdcall`调用约定：\n        1. 以“`?`”标识函数名的开始，后跟函数名；\n        2. 函数名后面以“`@@YG`”标识参数表的开始，后跟参数表；\n        3. 参数表以代号表示\n            1. `X--void ， D--char， E--unsigned char， F--short， H--int，I--unsigned int， J--long， K--unsigned long， M--float，N--double， _N--bool，.... `\n            2. `PA`表示指针，后面的代号表明指针类型，如果相同类型的指针连续出现，以“`0`”代替，一个“`0`”代表一次重复；\n        4. 参数表的**第一项为该函数的返回值类型**，**其后依次为参数**的**数据类型**，**指针标识在其所指数据类型前**；\n        5. 参数表后以“`@Z`”标识整个名字的结束，如果该函数无参数，则以“`Z`”标识结束。\n            1. 其格式为“`?functionname@@YA*****@Z`”或“`?functionname@@YG*XZ`”。例如`int Test1(char *var1,unsigned long)`：“`?Test1@@YGHPADK@Z`”\n    2. `__cdecl`调用约定：规则同上面的`_stdcall`调用约定，只是参数表的开始标识由上面的“`@@YG`”变为“`@@YA`”。\n    3. `__fastcall`调用约定：规则同上面的`_stdcall`调用约定，只是参数表的开始标识由上面的“`@@YG`”变为“`@@YI`”\n    4. VC++对函数的缺省声明是\"`__cedcl`\"，将只能被C/C++调用。\n\n# 符号\n\n符号=数据+指令\n\n## 符号的来源\n\n所有的数据都会生成符号。\n\n指令中（比如函数声明）只有函数名会生成符号。\n\n## 符号又可分为两种\n\n* 全局符号-global符号\n    * 所有的文件都可以引入。\n\n* 局部符号-local符号\n    * 只有本文件可见。\n\n## 具体表现\n\n* 普通的函数生成的是global符号。\n* 被inline修饰的函数，语义为只在本文件可见，所以生成的是local符号。\n* 如果函数只是声明而未在本文件定义，生成的符号是UND。\n* inline函数在debug版本生成的是local型符号；如果处理为内联之后，在release版本下不生成符号，因为它已在调用点处展开了。\n\n# extern关键字\n\n两种用法：\n\n1. C++中，干预编译器，extern \"C\"是以C方式编译，extern \"C++\"是以C++方式编译；\n2. C语言中，告诉编译器，函数是外部函数，既可以用在本文件，也可用在其他文件。\n\n## 在cpp文件中调用c文件\n\n矛盾点：\n\n1. C++调用C--C++产生函数符号-（函数名+参数类型列表），C语言产生函数符号-（函数名）\n2. C语言调用C++--如果将C++的函数符号改为C语言的函数符号--需要改动C++源文件--不现实。正确解决办法是添加自己实现的C++文件，写**C++函数作为中间层去调用需要的C++函数，然后让自实现的C++函数产生C语言符号（extern C）**。\n\n```c\n#func.c\n\n#include<stdio.h>\nvoid fun_C()\n{\n    printf(\"void fun_C()\");\n}\n#main.cpp\nvoid fun_C();\n//cpp生成的符号的方式是取决于函数名和参数列表。\n//而c生成的符号只是函数名\n//c和cpp生成符号的规则不一样，所以导致符号找不到。\nint main()\n{\n    fun_C();\n    return 0;\n}\n```\n\n所以，如何在cpp文件中调用c函数？\n\n```cpp\n//如何解决——使用C语言的方式编译和生成符号。\nextern \"C\"\n{\n    void fun_C();//声明\n}\nint main()\n{\n    fun_C();\n    return 0;\n}\n```\n\n如果想反过来呢？在c文件中怎么调用cpp的代码？如何解决？\n\n```c++\n#fun.cpp\nvoid fun_CPP()//生成的符号：fun_CPP_void\n{\n    printf(\"void fun_CPP()\");\n}\n\n#func.c\nvoid fun_CPP();//生成的符号：fun_CPP\nint main()\n{\n    fun_CPP();\n    return 0;\n}\n\n```\n\n解决方案：中间加一层\n\n```c++\n//C调用C++的代码方法\n------------------------------------------\n#fun.cpp\nint fun_CPP(int a)//生成Cpp符号：fun_CPP_int\n{\n    printf(\"int fun_CPP(int a)\");\n    return a;\n}\n------------------------------------------\n#tmp.cpp\nvoid fun_CPP();\t\t\t//声明\nextern \"C\"\n{\n    int fun_CPP_tmp(int a)\t//要与fun_CPP形式一致\n    {\n        return fun_CPP(a);\n    }\n}\n-----------------------------------------\n#func.c\nint fun_CPP_tmp(int a);//生成C符号：fun_CPP\nint main()\n{\n    int n = 100;\n    int res = fun_CPP_tmp(100);\n    return 0;\n}\n```\n\n# namespace\n\n实际上是个头文件。\n\n```c++\n//tmp.h\nnamespace AA\n{\n    typedef int INT;\n    typename char CHAR;\n}\n```\n\n\n\n```c++\n#include<iostream>\nusing namespace AA;\nint main()\n{\n    INT a = 10;//需要使用命名空间AA才能编译通过。\n    return 0;\n}\n```\n\n另外一种使用方式\n\n```c++\nusing AA::INT;//拿出命名空间中特定的某一个使用。\n```\n\nnamespace主要作用是封装，防止命名冲突问题。\n\n# 指针和数组\n\n```c++\n//fun.cpp\nint arr[]={0,1,2,3,4,5,6,7,8,9};\n```\n\n```c++\nusing AA::INT;\nextern int* arr;\n/*\n指针和数组名的区别——什么是指针\n*/\nint main()\n{\n    cout << arr << endl;\t\t//\n    cout << *arr << endl;\t//\n    cout << arr[0] << endl;\n}\n//输出00000000\\n 崩溃\nint main()\n{\n    int a = 10;\n    int *p = &a;\n    int arr1[]={0,1,2,3,4};\n    \n    cout << arr1 <<endl;\n    cout << p <<endl;\n    //输出的都是数组的地址，正常\n    //汇编代码：\n    //1. lea eax,[arr1];  push eax。直接传值给eax\n    //2. mov eax,dword ptr [p];  push eax。有dword ptr，去地址中取值\n    ///////\n    //数组名就是个地址。本质是常量，是个数字\n    //指针是变量。\n    \n    \n    \n    \n    //在编译时，直接把常量的值替换了常量名字。\n    \n}\n//变量和常量有何区别？\nint main()\n{\n    int a = 20;\n    int *p = &a;\n    int b;\n    b = 20;\n    b = a;\n    //用常量给变量赋值时，直接拿值替换。\n    //用变量给变量赋值时，有一次解引用\n    \n    b = *p;//去p的内存中将存储的地址拿出来。再去拿出来的地址中取出存储的数据。\n    //汇编：\n    // mov eax,dword ptr [p]\n    // mov ecx,dword ptr [eax]\n    // mov dword ptr [b],ecx\n}\n/*\n回到最初的问题，我们把arr当作了指针，把常量当作了变量来用。\n常量不用下地址，变量需要下地址。\n如果把常量当作了变量来用，编译器会将解引用，把解引用到的数据（数组首元素）当作结果来输出了。即00000000\ncout << arr << endl;\nmov eax,dword [arr]\nmov out,eax\n*/\n```\n\n# const\n\n```c++\n//c_main.c\n#include<stdio.h>\nint main()\n{\n    const int a = 10;\n    a = 20;//报错，必须是可修改的左值。\n    \n    int *p = &a;\n    *p = 20;\n    \n    \n    printf(\"%d\\n\",a);\n    \n    return 0;\n}\n```\n\n## C：常-变量\n\n不能作为左值。\n\n## C++：常量\n\n```c++\nint main()\n{\n    const int a = 10;\n    //a = 20;\n    //int *p = &a;\n    cout << a <<endl;\n    cout << *p <<endl;\n    // 10 10\n    \n    *p = 20;\n    cout << a <<endl;\n    cout << *p <<endl;\n    //10 20\n    //C++中，const常量就是纯常量，而不像C语言中可以轻易通过指针间接修改的。\n    //mov out, 0Ah ; cout << a\n    //常量：在编译期，将常量的值直接传入到目标中。\n}\n```\n\n## 面试\n\n为什么常量必须初始化？\n\n因为如果要使用常量又不初始化的话，后期没有机会改。使用一个随机值对于程序没有意义。\n\n如果使用变量给const修饰的量初始化，则该量会退化为常变量。\n\n## 指针和const\n\n```c++\nint main()\n{\n    int *p1 = &a;\n    const int *p2 = &a;\n    int const* p3 = &a;\n    int* const p4 = &a;\n    \n    int *q1 = &a;\n    const int* q2 = &a;\n    int const* q3 = &a;\n    int* const q4 = &a;\n}\n```\n\n要点1：const修饰的内容不能作为左值\n\n要点2：不能泄露常量的地址给非常量的指针\n\nconst修饰的类型是离它最近的第一个成型的类型。其余的是它修饰的内容。\n\n```c++\nint fun(int a)\n{\n    cout << typeid(a).name() << endl;\n    return 0;\n}\nint fun(const int a)\n{\n    cout << typeid(a).name() << endl;\n    return 0;\n}\n```\n\n如果const修饰的内容不包含指针，则无法参与类型。\n\n# 动态内存\n\n## C语言\n\nmalloc-free\n\n```c\n//使用malloc和free申请、释放一维数组、二位数组\nint main()\n{\n    const int n = 10;\n    //一维数组\n    int *ar = (int*)malloc(sizeof(int)*n);\n    //二维数组\n    int **ar = (int**)malloc(sizeof(int*)*n);\n    if(NULL==ar)\n    {\n        exit(1);\n    }\n    for(int i=0;i<n;i++)\n    {\n        ar[i] = (int*)malloc(sizeof(int)*n);\n        if(NULL==ar[i])\n        {\n            exit(1);\n        }\n        \n    }\n    for(int i = 0;i<n;i++)\n    {\n        free(ar[i]);\n    }\n}\n\n```\n\n## C++\n\nnew-delete\n\n```c++\nint main()\n{\n    int *p = new int;\n    *p = 10;\n    delete p;\n    \n    int *arr = new int[10];\n    arr[0] = 10;\n    delete[]arr;//释放数组\n}\n```\n\n```c++\nint main()\n{\n    int **arr1 = new int* [4];\n    for(int i = 0;i<4;i++)\n    {\n        arr1[i] = new int[5];\n    }\n    for(int i =0;i<4;i++)\n    {\n        delete[]arr1[i];\n    }\n}\n```\n\n## new和malloc区别\n\n1. new是关键字，malloc是函数，new调用malloc。\n2. new和malloc都是在堆区申请空间\n3. new有三个步骤\n    1. 开辟空间\n    2. 构造函数。---初始化，这是与malloc的区别。\n    3. 返回地址\n4. new不会强转返回值类型\n5. 封装计算sizeof\n6. 空间不足时，new会抛异常（bad_alloc）。malloc会返回空指针。（`int *p = new(nothrow) int(20);`）\n\n## new三种调用形式\n\n1. 关键字\n    1. `int *p = new int(10);\n2. 函数\n    1. `int *p = ::operator new(sizeof(int));` 把new当函数调用，类似于malloc，没有初始化！仍需强转和传入sizeof字节数。但是还是会抛异常。\n    2. `operator delete(p);`相当于free，需要用函数形式delete释放，即`operator delete(p)`\n    3. 与正常new区别就是没有初始化；\n    4. 需要用函数形式delete释放，即operator delete(p)\n3. 定位new\n\n```c++\nint *pa = (int*)::operator new(sizeof(int));\nnew(pa) int(10);//不开辟空间，而是用int(10)去初始化pa指向的空间。\n```\n# 引用\n\n## 是什么\n\n张三——有个小名，二狗子。二狗子和张三是同一个人。\n\n```c++\nint main()\n{\n    int a = 10;\n    int& b = a;\n    \n    \n    b = 20;//  mov eax,dword ptr [b]\n    cout << a <<endl;\n    cout << b <<endl;\n\t// 20 20\n\n\tint *p = &a;\n    *p = 20;\n}\n```\n\n引用的底层是一个指针，\n\n在使用到引用的地方，编译期会自动替换成指针的解引用。\n\n```cpp\n//c\nvoid Swap_C(int *ap, int *bp)\n{\n    assert(ap!=NULL&&bp!=NULL);\n    int tmp = *ap;\n    *ap = *bp;\n    *bp = tmp;\n}\n//cpp\nvoid Swap_Cpp(int& a, int& b)\n{\n    //无需断言判空，因为不可能有空引用。\n    int tmp = a;\n    a = b;\n    b = tmp;\n}\nint main()\n{\n    int x = 10, y = 20;\n    Swap_C(&x, &y);\n    Swap_Cpp(x, y);\n    return 0;\n}\n```\n\n引用为什么必须初始化？\n\n引用为什么一旦初始化就无法改变引用的方向？\n\n```c++\nint main()\n{\n    const int c = 20;\n    int& d = c;//报错\n    const int& d = c;\n}\n```\n\n笔试常见\n\n```c++\nint fun1()\n{\n    return 10;\n}\n\nint main()\n{\n    int& e = fun1();//报错，不能引用寄存器\n    const int& e = fun1();\n    \n    const int& f = 10;\n    \n    //当引用一个不可取地址的量的时候，使用常引用\n    //会生成一个临时量，实际引用的是这个临时量。\n    //为什么必须要const来修饰临时量？因为临时量都有常属性。（关于临时量，面向对象还会涉及。\n}\n```\n\n## 注意点\n\n1. 定义时必须初始化；\n2. 没有空引用\n3. 没有二级引用\n\n## 常引用\n\n```c++\nint a=10;\nint &b=a;\nconst int& c = b;\n```\n\n# 两个概念\n\n## 面向过程\n\n```c++\nint flag = 0;\nvoid echo()\n{\n    if(0 == flag)\n    {\n    \tprintf(\"%s\\n\",\"printf screen\");\n    }\n    else\n    {\n        printf(\"%s\\n\",\"printf file\");\n    }\n}\nvoid set_flag_file()\n{\n    flag = 1;\n}\nvoid set_flag_screen()\n{\n    flag = 0;\n}\n```\n\n\n\n## 面向对象\n\n```c++\nclass Note\n{\npublic:\n    Note()\n    {\n        _flag = 0;\n    }\n    void echo()\n    {\n        if(0 == _flag)\n        {\n            printf(\"%s\\n\",\"printf screen\");\n        }\n        else\n        {\n            printf(\"%s\\n\",\"printf file\");\n        }\n    }\n    void set_flag_file()\n    {\n        _flag = 1;\n    }\n    void set_flag_screen()\n    {\n        _flag = 0;\n    }\nprivate:\n    int _flag;\n}\nint main()\n{\n    Note n;\n    n.echo();\n    n.set_flag_file();\n    n.echo();\n    \n    \n    return 0;\n}\n```\n\n","categories":["Cpp"]},{"title":"C语言_const与volatile和mutable","url":"/C/C语言_const与volatile和mutable/","content":"# 一句话结论\nvolatile是要求读值时，必须每次从内存中读取。不能优化缓存到寄存器中，因为这个变量实际的值可能被修改，从寄存器中读取缓存可能出现脏值。\n\n**典型用途​**​：硬件寄存器和多线程共享的只读状态。\n\n在嵌入式编程中，硬件寄存器可能被映射到固定地址。这个寄存器可能是只读的（比如状态寄存器），**但它的值会随着硬件状态改变**。所以我们既需要`const`（因为程序不能写它）又需要`volatile`（因为值会变，编译器不能优化读取）。\n\nvolatile 与程序所做的更改完全无关。这意味着**内存可能会因为编译器无法控制的原因而改变**，因此编译器每次都必须读取或写入内存地址，并且不能将内容缓存在寄存器中。\n\n而const只是给程序员的指导性建议，实际可以强制修改const变量。而且const只限制了程序内部行为，它修饰的变量仍然可能被外部修改。\n# const和volatile结合的汇编区别\n\n```c\nint main()\n{\n\tvolatile const int a = 0;\n\tint b = a;\n\tint* p = (int*)&a;\n\t*p = 10;\n}\n```\n\n![image-20210926094934967](../../images/C%E8%AF%AD%E8%A8%80_volatile&const/image-20210926094934967.png)\n区别在于：`int b = a;`：去取了内存中 a 的地址中实际的值到寄存器，寄存器给 b 赋值。\n\n```c\nint main()\n{\n\tconst int a = 0;\n\tint b = a;\n\tint* p = (int*)&a;\n\t*p = 10;\n}\n```\n\n![image-20210926095031711](../../images/C%E8%AF%AD%E8%A8%80_volatile&const/image-20210926095031711.png)\n区别在于：`int b = a;`：没有去取内存中 a 的地址中实际的值，而是经过了优化，直接给 b 填了 0 。\n\n如果变量被volatile修饰，则是在给编译器说明：该变量可能随时被改写。\n所以编译器就不会轻易地去优化代码结构。\n\nconst：本程序段中不能对此变量作修改，任何修改都是不通过的，或者至少是粗心，编译器应该报错，防止这种粗心。\n但const修饰了的变量不允许被修改，**不代表不允许通过别名的方式修改**，比如：\n```c\nint i = 5;\nconst int* p = &i;\n*p = 6; // 不可以；\ni = 7;  // 完全可以，而且那个“const”的“*p”也跟着变成了7。\n```\n# const和volatile放在一起的意义\nconst和volatile放在一起的意义在于：\n（1）本程序段中不能对a作修改，任何修改都是不通过的，或者至少是粗心，编译器应该报错，防止这种粗心；\n（2）另一个程序段则完全有可能修改，因此编译器最好不要做太激进的优化。\n\n“const”含义是“请作为常量使用”，**但不是**：“放心吧，那肯定是个常量”。\n“volatile”的含义是“请不要做没谱的优化，这个值可能变掉的”，**但不是**“你可以修改这个值”。\n因此，它们不是矛盾的。\n## 例子\n```c\nconst volatile int i = 10;\n```\n这行代码有没有问题？如果没有，那 `i` 到底是什么属性?\n\n回答一：\n1. 没有问题。\n2. 例如只读的状态寄存器。它是volatile，因为它可能被意想不到地改变。\n3. 它是const，因为程序不应该试图去修改它。\n4. volatile和const并不矛盾，只是控制的范围不一样，一个在程序本身之外，另一个是程序本身。\n\n回答二：\n1. 没问题，const和volatile这两个类型限定符不矛盾。\n2. const表示（运行时）常量语义：被const修饰的对象在所在的作用域无法进行修改操作，编译器对于试图直接修改const对象的表达式会产生编译错误。\n3. volatile表示“易变的”，即在运行期对象可能在当前程序上下文的控制流以外被修改（例如多线程中被其它线程修改；对象所在的存储器可能被多个硬件设备随机修改等情况）：被volatile修饰的对象，编译器不会对这个对象的操作进行优化。\n4. 一个对象可以同时被const和volatile修饰，表明这个对象体现常量语义，但同时可能被当前对象所在程序上下文意外的情况修改。\n# mutable和const的关系\n- **规则​**​：`mutable`​**​不能​**​直接与`const`或`volatile`组合修饰变量（如`mutable const`非法）。\n- ​**​语义​**​：\n    - `mutable`：专门用于类的成员变量，允许其在`const`成员函数中被修改。\n    - `const`：在成员函数中禁止修改对象状态。\n- ​**​用途​**​：突破`const`限制，修改与逻辑无关的内部状态（如缓存、互斥锁）。\n\n```cpp\nclass Cache\n{\n    mutable int cached_value; // 允许const函数修改\n    int expensive_calculation() const;\npublic:\n    int get_value() const\n    {\n        if (!cache_valid)\n        {\n            cached_value = expensive_calculation(); // mutable突破const限制\n        }\n        return cached_value;\n    }\n};\n```\n\n- ​**​关键限制​**​：\n    - `mutable`​**​仅用于类的非静态数据成员​**​。\n    - 不可修饰类外的局部变量、函数参数或类中静态成员。\n    - 不允许组合`mutable const int x;`❌（语法错误）。\n\n# volatile 和 mutable可以组合吗？\n`C++`标准人为规定了：`volatile`和`mutable`​**​不能组合​**​（如`mutable volatile`非法）。\nvolatile的语义：告诉编译器，这个变量可能被外部修改，不能优化访问的方式\nmutable的语义：告诉编译器，即使对象是const，也可以修改这个成员变量\n\n组合起来的语义是：我希望这个成员变量，即使const对象也可以修改其成员变量，而且每次访问都要从内存中读取，不能缓存。\n\n虽然语义是不冲突的，逻辑是通顺的，但是`C++`标准明确禁止了这种组合。\n可能是碍于编译器实现的复杂度、实际需求太少。\n\n可以有替代方案：用`const_cast`突破。\n```cpp\nclass Device\n{\n    volatile int status_register;\npublic:\n    void reset() const \n    {\n        const_cast<volatile int&>(status_register) = 0;\n    }\n};\n```\n# 总结\n\n| 关键字组合              | 是否允许 | 用途场景                                   | 关键限制                                         |\n| ------------------ | ---- | -------------------------------------- | -------------------------------------------- |\n| `const volatile`   | ✅    | 只读但可能被外部修改的变量                          | 程序自身不可写                                      |\n| `mutable`          | ✅    | 类的成员（在const函数中可修改）                     | 仅限类的非静态成员                                    |\n| `const mutable`    | ❌    | 无！                                     | 语义冲突                                         |\n| `volatile mutable` | ❌    | const对象也可以修改其成员变量，而且每次访问都要从内存中读取，不能缓存。 | 语义上不冲突，但是人为规定禁止。可以用`const_cast`代替mutable的功能。 |\n核心区别\n- `const volatile`→ ​**​全局性限制​**​（硬件/多线程只读数据）\n- `mutable`→ ​**​局部性突破​**​（针对类的const成员函数，修改特定状态）\n","categories":["C","Cpp"]},{"title":"Linux_进程","url":"/Linux/Linux_进程/","content":"\n# 内容\n\n1. 进程的概念\n2. 进程控制块、pid\n3. 进程状态\n4. 进程的并发、并行\n5. 相关命令\n6. 进程的复制\n7. printf引出的思考\n8. 孤儿进程\n9. 僵死进程\n10. 写时拷贝技术\n11. 进程的替换\n\n# 进程\n\n进程：一个正在执行（运行）的程序。\n\n程序：由一条条的指令构成。\n\n# 进程控制块\n\n进程控制块，即pcb，process control block，对应于Linux上的数据结构是`struct task_struct`。\n\n里面包含了关于进程的详细的信息，如**进程标识符(pid)**、**进程名字(name)**、**用户标识符(uid, 用于区分进程属于哪个用户)**、组标识符(gid)、**进程退出码(`exit_code`)**等等。但最为重要的，只需要记住——`pid`，即进程标识符，它是唯一标识一个进程的id号。\n\n## 相关api\n\n* 获取pid\n\n```c\n#include<unistd.h>\npid_t getpid(void);\t\t//获得当前进程pid\npit_t getppid(void);\t//获得当前进程父进程的pid\n```\n\n\n\n# 进程状态\n\n就绪、运行、阻塞\n![image-20220512212116321](../../images/Linux_进程/image-20220512212116321.png)\n\n# 并发与并行\n\n![image-20220512212251186](../../images/Linux_进程/image-20220512212251186.png)\n\n并发不一定可以并行。但可以模拟并行，实际不是并行。\n\n并行一定并发。并行是一种特殊的并发情况。只有在多处理器或多核环境中才能并行。\n\n# 相关命令\n\n## ps\n\n可以查看终端中当前运行的进程\n\n```bash\nps -f #查看更详细的信息\nps -e #显示系统所有的进程（不加e的话默认只是该用户的进程）\nps -ef #是e和f的复合命令\n```\n\n## kill\n\n结束进程\n\n```bash\nCtrl + C只可以结束在前台的进程。\nCtrl + Z停止一个前台的进程\nkill pid #\nkill -9 pid #强制\npkill 进程名 #把所有叫某名的进程都结束\nps -ef | grep sleep\n```\n\n## &\n\n后台运行符\n\n```bash\nsleep 100 &\n\n```\n\n## jobs\n\n显示当前终端的任务\n\n```bash\n#把前台运行的程序转到后台运行\nsleep 200\n^Z\njobs #显示当前终端（后台）的任务\n[1] 已停止\t\tsleep 200\nbg %1 \t\n\t\t#bg %任务号 将后台运行或挂起的进程挪到前台执行\n\t\t#fg %任务号 将挂起的进程唤醒到后台执行\n```\n\n## bg/fg\n\n`bg %任务号`将后台运行或挂起的进程挪到前台执行\n\n`fg %任务号`将挂起的进程唤醒到后台执行\n\n## top\n\n查看系统资源使用情况以及进程信息（按q退出）\n\n# 编译链接过程\n\nwin可执行文件的标识是PE，linux的标识是ELF。\n\n* gcc分步编译链接过程\n\n1. 预编译 - `gcc -E main.c -o main.i`\n   1. 展开头文件，扫描`/usr/include`中引用到的头文件\n2. 编译 - `gcc -S main.i -o main.s`\n   1. 检查语法错误，生成汇编代码。\n3. 汇编 - `gcc -c main.s -o main.o`\n   1. 转换为二进制代码（ELF文件格式）。还不可执行。只是把自己写的代码翻译成了二进制代码，还有其他的main函数之前的引入的库函数，除了自己的代码，还要链接别人的代码。\n4. 链接\n\n* 一步编译链接：`gcc -o main main.o`\n\n## 多文件编译\n\n```bash\n#两步编译链接\n\n#先全部编译为机器指令--.o文件\ngcc -c main.c add.c max.c\n#再链接成一个文件\ngcc -o main add.o max.o main.o\t#文件顺序可以不一样\n```\n\n```bash\n#一步编译链接\ngcc -o main main.c add.c max.c\t\n```\n\n更多的编译链接内容请查看“Linux_库”。\n\n# 进程的复制 - fork\n\n`pid_t fork(void);`\n\n对于返回值`pid_t`，Linux内核`2.4.0`版本的定义为：\n\n```c\ntypedef int\t\t__kernel_pid_t;\ntypedef __kernel_pid_t\t pid_t;\n//\t相当于pid_t 就是 int类型。\n```\n\n调用fork函数会生成一个进程，调用者的进程身份成为父进程，生成的新进程为子进程。在父进程中fork函数返回值：成功则返回子进程的pid，失败则返回-1；在子进程中fork函数返回值为0。\n\n## 一个代码说明要点\n\n```c\n#include<stdio.h>\t//printf\n#include<unistd.h>\t//sleep\tfork\n#include<assert.h>\t//assert\n#include<stdlib.h>\t//exit\nint main()\n{\n    int n = 0;\n    char * s = NULL;\n    pid_t pid = fork();\n    assert(pid != -1);\n    if(pid == 0)\n    {\n        s = \"child\";\n        n = 3;\n    }\n    else\n    {\n        s = \"parent\";\n        n = 7;\n    }\n    for(int i = 0; i < n; ++i)\n    {\n        printf(\"s = %s\\n\", s);\n        sleep(1);\n    }\n    exit(0);\n}\n```\n\n运行结果\n\n![image-20220513144726751](../../images/Linux_进程/image-20220513144726751.png)\n\n分析\n\n![image-20220513151002364](../../images/Linux_进程/image-20220513151002364.png)\n\n## 要点\n\n1. fork后子进程复制父进程的地址空间作为副本，包括数据段、栈段、堆段等等，但子进程和父进程共享代码段。（没有使用写时拷贝技术时）\n2. 父进程复制生成子进程后，**由于进程会记录目前代码运行的过程信息，则子进程就会从fork处开始执行代码，前面的代码不再执行**。父进程和子进程从fork处开始分支。\n   * 虽然子进程前面的代码不再执行，但是不意味着前面的变量是个随机值。而是利用了父进程执行过前面的指令，子进程复制过来可以读取、使用。\n3. fork之后父子进程各自独立，并发运行。所以程序运行结果可能呈现出不确定性。因此打印的先后顺序无所谓，没有正确不正确之分。\n\n## fork函数的变体\n\nLinux 3.2.0提供了另一种新进程创建函数`clone(2)`系统调用。这是一种fork的推广形式，它允许调用者控制哪些部分由父进程和子进程共享。\n\nFreeBSD 8.0提供了`rfork(2)`系统调用，它类似于Linux的`clone`系统调用。`rfork`调用是从Plan 9操作系统派生出来的。\n\nSolaris 10提供了两个线程库：一个用于POSIX线程(pthreads)，另一个用于Solaris线程。在这两个线程库中，fork的行为有所不同。对于POSIX线程，fork创建一个进程，它仅包含调用该fork的线程；但对于Solaris线程，fork创建的进程包含了调用线程所在进程的所有线程的副本。在Solaris 10中，这种行为改变了。不管使用哪种线程库，fork创建的子进程只保留调用线程的副本。Solaris也提供了`fork1`函数，它创建的进程只复制调用线程。还有`forkall`函数，它创建的进程复制了进程中所有的线程。\n\n# 写时拷贝技术\n\n没有改变页面内容，暂时共享。要改变页面，再复制。\n\n由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为替代，使用了写时复制(Copy-On-Write, COW)技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。**如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本**，通常是虚拟存储系统中的一“页”。\n\n## 细节\n\n进程复制的具体过程：\n\n1. 向系统申请一个pcb进程控制块，生成新的pid。\n2. 若申请成功，则复制父进程的pcb进程控制块结构体信息到子进程的pcb中。\n3. 把进程体内存空间浅拷贝给子进程。即映射各种资源。\n4. 子进程试图改写进程体空间信息时，再实际深拷贝一份空间，最终改的是自己的空间。\n\n# printf引出的思考\n\n## 前期铺垫\n\n```c\n#include<stdio.h>\t//printf\n#include<unistd.h>\t//exit\n#include<stdlib.h>\t//sleep\nint main()\n{\n    printf(\"hello\");\n    sleep(3);\n    exit(0);\n}\n//睡眠3秒后，退出前才打印。\n```\n\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\nint main()\n{\n    printf(\"hello\");\n    sleep(3);\n    _exit(0);\n}\n//睡眠3秒后，不打印，直接退出。\n```\n\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\nint main()\n{\n    printf(\"hello\");\n    fflush(stdout);\n    sleep(3);\n    _exit(0);\n}\n//先打印，再睡眠3秒，退出。\n```\n\n> `exit`和`_exit`的区别：\n>\n> `_exit`啥也不干，直接鲁莽退出程序。\n>\n> `exit`会先帮你刷新缓冲区，才退出程序，以面错过遗留信息。相当于`fflush(stdout)`+`_exit(0)`。`return`和`exit`相似。\n\nprintf函数并不会直接将数据输出到屏幕，而是先放到缓冲区中，待某时把缓冲区数据再发送给内核，内核处理后写入到IO设备中。只有以下三种情况满足，才会输出到屏幕。 \n\n1. 缓冲区满\n2. 强制刷新缓冲区，即调用`fflush(stdout)`。\n3. 调用`exit(0)`程序结束时，注意，必须是`exit(0)`，不能直接`_exit(0)`。\n\n## 开始试探\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\nint main()\n{\n    for(int i = 0; i<2; ++i)\n    {\n        fork();\n        printf(\"A\\n\");\n    }\n    exit(0);\n}\n```\n\n运行结果\n\n```\nA\nA\nA\nA\nA\nA\n\n```\n\n分析\n![image-20220513171739655](../../images/Linux_进程/image-20220513171739655.png)\n\n每换行一次即清空**行缓冲区**，会立即输出，不会遗留给子进程。\n\n## 再来一个\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\nint main()\n{\n    for(int i = 0; i<2; ++i)\n    {\n        fork();\n        printf(\"A\");\n    }\n    exit(0);\n}\n```\n\n运行结果\n\n```\nAAAAAAAA\n```\n\n分析\n![image-20220513171823048](../../images/Linux_进程/image-20220513171823048.png)\n\n每次的`printf`函数不会立即输出，内容放到了缓冲区，而且会遗留给子进程。直到进程结束才会输出。本质：两个父进程分别输出两个A，两个子进程也分别输出两个A。\n\n## 试试这个\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\nint main()\n{\n    fork() || fork();\n    printf(\"A\\n\");\n    exit(0);\n}\n```\n\n运行结果\n\n```\nA\nA\nA\n\n```\n\n分析\n\n![image-20220513174543556](../../images/Linux_进程/image-20220513174543556.png)\n做完了题，别急着走！你还没收拾摊子。\n\n# 孤儿进程\n\n子进程未结束，父进程先结束时，子进程就变成了孤儿进程，其父进程会改变，通常变为1。详见\"Linux_exit\"。\n\n# 僵死进程\n\n子进程先结束，父进程没有调用wait获取子进程的退出码，那么子进程就成为僵死进程。wait函数的参数是用于接收退出码的指针变量。详见\"Linux_exit\"。\n\n# 进程替换 - exec\n\n用fork函数创建新的子进程后，子进程往往要调用一种`exec`函数以执行另个程序。当进程调用一种`exec`函数时，该进程执行的程序完全替换为新程序，而新程序则从其`main`函数开始执行。因为调用`exec`并不创建新进程，所以前后的进程ID并未改变。**exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。**\n\nexec函数不是一个具体的函数，而是一系列函数。有7种不同的exec函数可供使用，它们常常被统称为`exec`函数，我们可以使用这7个函数中的任一个。这些exec函数使得UNIX系统进程控制原语更加完善。用`fork`可以创建新进程，用`exec`可以初始执行新的程序。`exit`函数和`wait`函数处理终止和等待终止。这些是我们需要的基本的进程控制原语。可以使用这些原语构造另外一些如`popen`和`system`之类的函数。\n\n> 控制UNIX进程的四大原语：`fork`、`exec`、`exit`、`wait`\n\n## API\n\n```c\n#include<unistd.h>\nint execl(const char *pathname, const char *arg0, .../* (char*)0 */);\nint execv(const char *pathname, char * const argv[]);\nint execle(const char *pathname, const char *arg0, ... /* (char*)0, char * const envp[] */);\nint execve(const char *pathname, char * const argv[], char * const envp[]);\n\nint execlp(const char *filename, const char * arg0, ... /* (char*)0 */);\nint execvp(const char * filename, char * const argv[]);\nint fexecve(int fd, char * const argv[], char * const envp[]);\n//7个函数返回值：若出错，返回-1；若成功，不返回。\n```\n\n## 区别\n\n这些函数之间的第一个区别是前4个函数取**路径名**作为参数，后2个函数则取**文件名**作为参数，最后一个取**文件描述符**作为参数。\n\n当指定`filename`作为参数时（即`execlp, execvp`）：\n\n1. 如果filename中包含`/`，则就将其视为路径名；\n2. 否则就按`PATH`环境变量，在它所指定的各目录中搜寻可执行文件。\n\n> `PATH`变量包含了一张目录表（称为路径前缀），目录之间用冒号（`:`）分隔。例如，下列`name=value`环境字符串指定在4个目录中进行搜索。\n>\n> `PATH=/bin:/usr/bin:/usr/local/bin:.`\n>\n> 最后的路径前缀`.`表示当前目录。（零长前缀也表示当前目录。在value的开始处可用`:`表示，在行中间则要用`::`表示，在行尾以`:`表示。）\n\n> 出于安全性方面的考虑，有些人要求在搜索路径中决不要包括当前目录。参见`Garfinkel等[2003]`。\n\n> 如果`execlp`或`execvp`使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的机器可执行文件，则就认为该文件是一个shell脚本，于是试着调用`/bin/sh`，并以该`filename`作为shell的输入。\n\n`fexecve`函数避免了**寻找**正确的可执行文件，而是**依赖调用进程(rely on the caller)**来完成这项工作。通过使用一个文件描述符，**调用进程(the caller)**可以使用文件描述符验证所需要的文件并且无竞争地执行该文件。否则，拥有特权的恶意用户就可以在**找到文件位置并且验证之后**，但**在调用进程(the caller)执行该文件之前**，**替换可执行文件（或可执行文件的部分路径）**，具体可参考TOCTTOU错误(time-of-check-to-time-of-use)。\n\n>TOCTTOU错误的基本思想是：\n>\n>如果有两个基于文件的函数调用，其中二个调用依赖于第一个调用的结果，则程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。\n>\n>文件系统命名空间中的TOCTTOU错误通常处理的就是那些颠覆文件系统权限的小把戏，这些小把戏通过骗取特权程序降低特权文件的权限控制或者让特权文件打开一个安全漏洞等方式进行。\n>\n>`Wei和Pu[2005]`在UNIX文件系统接口中讨论了`TOCTTOU`的缺陷。\n\n---\n\n第二个区别与参数表的传递有关(`l`表示列表`list`，`v`表示矢量`vector`)。函数`execl`、`execlp`和`execle`要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数(`execv`、`execvp`、`execve`和`fexecve`)，则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数。\n\n在使用`ISO C`原型之前，对`execl`、`execle`和`execlp`三个函数表示命令行参数的一般方法是：\n`char *arg0, char *arg1, ..., char *argn, (char *)0`\n这种语法显式地说明了最后一个命令行参数之后跟了一个空指针。如果用常量0来表示一个空指针，则必须将它强制转换为一个指针；否则它将被解释为整型参数。如果一个整型数的长度与`char *`的长度不同，那么exec函数的实际参数将出错。\n\n---\n\n最后一个区别与向新程序传递环境表相关。以`e`结尾的3个函数(`execle`，`execve`和`fexecve`)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的`environ`变量为新程序复制现有的环境(如果系统支持`setenv`和`putenv`这样的函数，则可更改当前环境和后面生成的子进程的环境，但不能影响父进程的环境)。\n\n通常，一个进程允许将其环境传播给其子进程，但有时也有这种情况：进程想要为子进程指定某一个确定的环境。例如，在初始化一个新登录的shell时，login程序通常创建一个只定义少数几个变量的特殊环境，而在我们登录时，可以通过shell启动文件，将其他变量加到环境中。\n\n在使用`ISO C`原型之前，`execle`的参数是：\n\n`char *pathname, char *arg0, ..., char *argn, (char *)O, char *envp[]`\n\n从中可见，最后一个参数是指向环境字符串的各字符指针构成的数组的指针。而在`ISO C`原型中，所有命令行参数、空指针和envp指针都用省略号(`...`)表示。\n\n这7个exec函数的参数很难记忆。函数名中的字符会给我们一些帮助。字母p表示该函数取`filename`作为参数，并且用`PATH`环境变量寻找可执行文件。字母`l`表示该函数取一个参数表，它与字母`v`互斥。`v`表示该函数取一个`argv[]`矢量。最后，字母`e`表示该函数取`envp[]`数组，而不使用当前环境。\n\n![image-20220515195300517](../../images/Linux_进程/image-20220515195300517.png)\n\nexecl：路径加名称（指定的是哪个程序），加可变参（第一个参数是当前程序的**名字**），直到空指针。默认是当前环境变量。\n\nexeclp：和execl一样。p指的是当前环境命令。可以直接写“ps”，不用写绝对路径。\n\nexecle：比execl的NULL后多了一个参数，需要传入自定义的环境变量。\n\n**execv**：路径加名称（指定的是哪个程序），中间的可变参换为了一个字符串数组。我们传入的数组可以多余开辟空间，填充0。则NULL参数可以省略。**较灵活，常用**。\n\nexecvp：p指的是当前环境下，即**默认使用的是系统/usr/bin下的相关命令**。比如可以直接写“ps”，不用写绝对路径。中间的可变参换为了一个字符串数组。我们传入的数组可以多余开辟空间，填充0。则NULL参数可以省略。**较灵活，常用**。\n\n在很多UNIX实现中，这7个函数中只有`execve`是内核的系统调用。另外6个只是库函数它们最终都要调用该系统调用。这7个函数之间的关系如图。\n\n![image-20220515202315518](../../images/Linux_进程/image-20220515202315518.png)\n\n在这种安排中，库函数`execlp`和`execvp`使用`PATH`环境变量，查找第一个包含名为`filename`的可执行文件的路径名前缀。`fexecve`库函数使用`/proc`把文件描述符参数转换成路径名，`execve`用该路径名去执行程序。\n\n这描述了在`FreeBSD 8.0`和`Linux 3.2.0`中是如何实现`fexecve`的。其他系统采用的方法可能不同。例如，没有`/proc`和`/dev/fd`的系统可能把`fexecve`实现为系统调用，把文件描述符参数转换成`i节点指针`，把`execve`实现为系统调用，把路径名参数转换成`i节点指针`，然后把`execve`和`fexecve`中剩余的`exec`公共代码放到单独的函数中，调用该函数时传入执行文件的`i节点指针`。\n\n## 属性迭代\n\n在执行exec后，进程ID没有改变。且新程序从调用进程继承了下列属性：\n\n| 继承的属性                                               |\n| -------------------------------------------------------- |\n| 进程ID和父进程ID                                         |\n| 实际用户ID和实际组ID                                     |\n| 附属组ID                                                 |\n| 进程组ID                                                 |\n| 会话ID                                                   |\n| 控制终端                                                 |\n| 闹钟尚余留的时间                                         |\n| 当前工作目录                                             |\n| 根目录                                                   |\n| 文件模式创建屏蔽字                                       |\n| 文件锁                                                   |\n| 进程信号屏蔽                                             |\n| 未处理信号                                               |\n| 资源限制                                                 |\n| nice值（遵循XSI的系统）                                  |\n| `tms_utime`、`tms_stime`、`tms_cutime`以及`tms_cstime`值 |\n\n> 对打开文件的处理与每个描述符的**执行时关闭(close-on-exec)标志值**有关。这个与`FD_CLOEXEC`标志有关，进程中每个打开描述符都有一个执行时关闭标志。若设置了此标志，则在执行exec时关闭该描述符；否则该描述符仍打开。所以，除非特地用`fcntl`设置了该执行时关闭标志，否则系统的默认操作是在exec后仍保持这种描述符打开。\n>\n> `POSIX.1`明确要求在`exec`时关闭**打开目录流(open directory streams)**。这通常是由opendir函数实现的，它调用`fcntl`函数为对应于打开目录流的描述符设置执行时关闭标志。\n\n注意，在exec前后实际用户ID和实际组ID保持不变，而有效ID是否改变则取决于所执行程序文件的设置用户ID位和设置组ID位是否设置。**如果新程序的设置用户ID位已设置，则有效用户ID变成程序文件所有者的ID；否则有效用户ID不变**。对组ID的处理方式与此相同。\n","categories":["操作系统","多线程","Linux"]},{"title":"基础数据结构_链表","url":"/基础数据结构/基础数据结构_链表/","content":"# 内容\n\n1. 单链表的操作\n2. 单链表的经典题目\n\n# 单链表经典题目\n\n## Remove\n\n![image-20220321090309971](../../images/基础数据结构_链表/image-20220321090309971.png)\n\n* 删除单个元素--按值\n\n比如删除34。\n\n第1种做法，双指针\n\n```c\nvoid Remove(LinkList head, ElemType val)\n{\n    assert(head != NULL);\n    ListNode* back = head;\n    ListNode* front = head->next; \n    while(front != NULL && front->data != val)\n    {\n        back = front;\n        front = front->next;\n    }\n    if(front == NULL)return;\n    back->next = front->next;\n    free(front);\n    front = NULL;\n    return;\n}\n```\n\n第2种做法，结合API。按值找到该值节点的前驱(调用FindValue_Prev)，然后调用删除Erase_Next。\n\n```c\nbool Erase_Next(LinkList head, ListNode *ptr);\nbool Remove(LinkList head, ElemType val)\n{\n    assert(head != NULL);\n    return Erase_Next(head, FindValue_Prev(head, val));\n}\n```\n\n* 删除所有val值节点\n\n![image-20220321095517379](../../images/基础数据结构_链表/image-20220321095517379.png)\n\n第1种做法，每次从头开始找val，重复若干次，直到找不到为止。时间复杂度为$O(n^2)$\n\n```c\nbool Erase_Next(LinkList head, ListNode *ptr);\nListNode * FindValue_Prev(LinkList head, ElemType val);\nvoid Remove_All(LinkList head, ElemType val)\n{\n    assert(head != NULL);\n    ListNode * p = NULL;\n    while((p = FindValue_Prev(head, val)) != NULL)\n    {\n        Erase_Next(head, p);\n    }\n}\n```\n\n第2种做法，思想：back指针在后面守护，front在前面探测：**front遇到非val值时back前移，然后交换此时back和front的数据域**。每轮front都前移一次，直到遍历完毕。\n\n![image-20220321103213898](../../images/基础数据结构_链表/image-20220321103213898.png)\n\n![image-20220321103233830](../../images/基础数据结构_链表/image-20220321103233830.png)\n\n![image-20220321103315038](../../images/基础数据结构_链表/image-20220321103315038.png)\n\n![image-20220321103356110](../../images/基础数据结构_链表/image-20220321103356110.png)\n\n```c\nvoid Remove_All(LinkList head, ElemType val)\n{\n    assert(head != NULL);\n    ListNode * back = head;\n    ListNode * front = head->next;\n    while(front != NULL)\n    {\n        if(front->data != val)\n        {\n            back = back->next;\n            Swap(&back->data, &front->data);\n        }\n        front = front->next;\n    }\n    // 此时，所有val节点都集中在back指向的节点之后，while直到删完\n    while(back->next != NULL)\n    {\n        Erase_Next(head, pre);\n    }\n}\n```\n\n## Reverse\n\n### 三指针\n\n时间复杂度$O(n)$，空间复杂度$O(1)$\n\n```c\nvoid ReverseList(LinkList head)\n{\n    assert(head != NULL);\n    ListNode *back = NULL;\n    ListNode *temp = NULL;\n    ListNode *front = head->next;\n    while(front != NULL)\n    {\n        temp = front;\n        front = front->next;\n        temp->next = back;\n        back = temp;\n    }\n    head->next = back;\n}\n```\n\n\n\n### 二指针（头插）\n\n![image-20220321110049606](../../images/基础数据结构_链表/image-20220321110049606.png)\n\n时间复杂度$O(n)$，空间复杂度$O(1)$\n\n```c\nvoid ReverseList(LinkList head)\n{\n    ListNode *front = head->next;\n    ListNode *temp = NULL;\n    head->next = NULL;\t// ready to push_front\n    while(front != NULL)\n    {\n        // front will move, avoid front->next change, temp log. \n        temp = front;\n        front = front->next;\n        // the next 2 steps : push front\n        temp->next = head->next;\n        head->next = temp;\n    }\n}\n```\n\n头插法逆置还有一种单指针的做法，遍历把每个节点的值取出，调用Push_Front按值购买节点头插。这种做法的空间复杂度是$O(n)$，同时还会涉及到内存泄漏的问题，因为旧有遍历过的节点没有释放。如果要在代码中主动释放，则又需要加个temp指针来记录了。一边申请，一边释放，这种做法是及其耗费资源的，不推荐。\n\n```c\nvoid ReverseList(LinkList head)\n{\n    ListNode *front = head->next;\n    head->next = NULL;\n    while(front != NULL)\n    {\n        ElemType val = front->val;\n        Push_Front(head, val);\n        \n    /*  ListNode *temp = front;\t*/\n        front = front->next;\n    /*\tfree(temp);\t\t\t\t*/\n    }\n}\n```\n\n\n\n### 栈\n\n栈的特性：后进先出\n\n用一个连续空间和push_back/pop_back/get_back模拟一个栈。\n\n时间复杂度$O(n)$，空间复杂度$O(n)$\n\n```c\nvoid ReverseList(LinkList head)\n{\n    assert(head != NULL);\n    int len = 0;\n    ListNode *front = head->next;\n    while(p != NULL)\n    {\n        ++len;\n        front = front->next;\n    }\n    ElemType *stack = (ElemType*)malloc(sizeof(ElemType)*len);\n    int top = -1;\n    front = head->next;\n    while(p != NULL)\n    {\n        top += 1;\n        stack[top] = p->data;\n        front = front->next;\n    }\n    front = head->next;\n    while(front != NULL)\n    {\n        p->data = stack[top];\n        top -= 1;\n        front = front->next;\n    }\n    free(stack);\n    stack = NULL;\n}\n```\n\n\n\n### 递归\n\n分析最小的递归单元：两个节点的逆置。\n\n![image-20220321133942696](../../images/基础数据结构_链表/image-20220321133942696.png)\n\n两个节点的逆置动作：**首先first指针指向23**，然后分析：要逆置23和34，需要先把23之后的逆置，而34只是一个节点，不做动作直接return自身，**则last指针指向34**。然后first->next->next指向first，即34指向自己，先画一个环；然后first->next = NULL，23与34切断连接。如此即完成两个节点的逆置。以此类推即是链表逆置的递归过程。\n\n时间复杂度$O(n)$，空间复杂度$O(n)$\n\n```c\nListNode * Reverse(ListNode *first)\t//此函数也可以处理不带头节点的单链表逆置\n{\n    if(pnode==NULL || pnode->next==NULL)return first;\n    ListNode * last = Reverse(first->next);\n    first->next->next = first;\n    first->next = NULL;\n    return last;\n}\nvoid ReverseList(LinkList head)\n{\n    assert(head != NULL);\n    ListNode *front = head->next;\n    head->next = Reverse(front);\n}\n```\n\n举例：\n\n![image-20220321142459489](../../images/基础数据结构_链表/image-20220321142459489.png)\n\n![image-20220321142555889](../../images/基础数据结构_链表/image-20220321142555889.png)\n\n![image-20220321142645452](../../images/基础数据结构_链表/image-20220321142645452.png)\n\n![image-20220321142707390](../../images/基础数据结构_链表/image-20220321142707390.png)\n\n### 不带头结点单链表的非递归逆置--三指针法\n\n```c\nListNode * NiceReverseList(LinkList head)\n{\n    if(head == NULL || head->next == NULL)return head;\n    ListNode *front = head;\n    ListNode *back = NULL;\n    ListNode *temp = NULL;\n    while(front != NULL)\n    {\n        temp = front;\n        front = front->next;\n        temp->next = back;\n        back = temp;\n    }\n    return back;\n}\n```\n\n## 倒数第k\n\n打印不带头节点的单链表中倒数第k个节点的数据。\n\n![image-20220321144102473](../../images/基础数据结构_链表/image-20220321144102473.png)\n\n### len减k法\n\n打印第n-k+1个节点。\n\n比如，我们有5个节点，要求打印倒数第2个节点。则等效于打印正数第5-2+1个节点。\n\n```c\nvoid PrintKth_List(LinkList head, int k)\n{\n    if(head == NULL || k < 1)return;\n    int count = 0;\n    ListNode *front = head;\n    while(front != NULL)\n    {\n        ++count;\n        front = front->next;\n    }\n    if(k > n)return;\n    \n    front = head;\n    while(count-- > k)\n    {\n        front = front->next;\n    }\n    printf(\"%dth data of LinkList : %d. \\n\", front->data);\n    return;\n}\n```\n\n### 递归\n\n时间复杂度$O(n)$，空间复杂度$O(n)$\n\n```c\nint PrintKth(ListNode * head, int k)\n{\n    if(head == NULL)return 0;\n    int count = PrintKth(head->next, k) + 1;\n    if(count == k)\n    {\n        printf(\"%dth data of LinkList : %d. \\n\", front->data);\n    }\n    return count;\n}\nvoid PrintKth_List(LinkList head, int k)\n{\n    if(head == NULL || k < 1)return;\n    PrintKth(head, k);\n}\n```\n\n### 栈\n\n### 双指针\n\n即快慢指针法，使快慢指针相差k距离，同时步进，当快指针空时，则慢指针指向倒数第k值。\n\n```c\nvoid PrintKth_List(LinkList head, int k)\n{\n    if(head == NULL || k < 1)return;\n    ListNode *front = head;\n    ListNode *back = head;\n    int count = k;\n    while(front!=NULL && count>0)\t//front==NULL 或 k==0退出，front==NULL退出是因为k>=n；front!=NULL&&k==0退出 则k<n，正常。\n    {\n        front = front->next;\n        --count;\n    }\n    if(count != 0)\n    {\n        if(front == NULL)return;//k超出节点数量范围\n        while(front != NULL)\n        {\n            front = front->next;\n            back = back->next;\n        }\n    }\n    printf(\"%dth data of LinkList : %d. \\n\", back->data);\n    return;\n}\n```\n\n## 返回中间节点\n\n快慢指针法，快指针一次走两个，慢指针一次走一个。\n\n```c\nListNode * GetMidNode(LinkList head)\n{\n    if(head==NULL || head->next==NULL)return head;\n    ListNode * front = head;\n    ListNode * back = head;\n    while(front->next!=NULL && front->next->next!=NULL)\n    {\n        front = front->next->next;\n        back = back->next;\n    }\n    return back;\n}\n```\n\n## 环路\n\n### 数组中的重复数字\n\n\n\n# 刷题\n\n![image-20210921182935780](../../images/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E9%93%BE%E8%A1%A8/image-20210921182935780.png)\n\n```c\nvoid deleteNode(struct ListNode* node) \n{\n    struct ListNode *p = node->next;\n    *node=*p;\n    free(p);\n}\n```\n\n如果考虑最后节点，就没办法用这种方法了，因为最多只能给最后的节点的信息全赋零值，并且前继节点的next指向的地址是无法改变的。\n\n\n\n","categories":["基础数据结构"]},{"title":"存疑记录","url":"/课堂笔记/存疑记录/","content":"\n# 刷题碰到的\n\n## 解决哈希冲突-公共溢出区法\n\n![image-20210921020227197](../../images/%E5%AD%98%E7%96%91%E8%AE%B0%E5%BD%95/image-20210921020227197.png)\n\n![image-20210921020240377](../../images/%E5%AD%98%E7%96%91%E8%AE%B0%E5%BD%95/image-20210921020240377.png)\n\nhttps://blog.csdn.net/ycwasdfasdf/article/details/52232502\n\n![image-20210921020448550](../../images/%E5%AD%98%E7%96%91%E8%AE%B0%E5%BD%95/image-20210921020448550.png)\n\n```c++\n//https://blog.csdn.net/HLW0522/article/details/52086598\n#include<iostream>\nusing namespace std;\n#define HASHSIZE 10\n#define NULLKEY -32768\ntypedef struct hash\n{\n\tint *element;\n\tint *extraElement;//溢出区表\n\tint count; // 溢出区的元素个数\n}HashTable;\n// 由于 通过哈希函数 计算后的地址重复几率很小，所以把重复部分用顺序表来存放，查找时遍历这个公共溢出区的顺序表，效率会更高。\nvoid Init(HashTable *p)\n{\n\tp->element = (int*)malloc(sizeof(int)*HASHSIZE);\n\tp->extraElement = (int*)malloc(sizeof(int)*HASHSIZE);\n\tfor (int i = 0; i < HASHSIZE; ++i)\n\t{\n\t\tp->element[i] = NULLKEY;\n\t\tp->extraElement[i] = NULLKEY; \n\t}\n\tp->count = 0; \n}\n// 除留余数法\nint HASH(int key)\n{\n\treturn key%HASHSIZE;\n}\n//插入元素\nvoid InsertHash(HashTable *p, int key)\n{\n\tint addr = HASH(key);\n\t//处理冲突, 使用公共溢出法\n\tif (p->element[addr] == NULLKEY)\n\t\tp->element[addr] = key;\n\telse //如果元素内已经有值了，就放到溢出部分的表中，且把count加 1\n\t\tp->extraElement[p->count++] = key;\n}\nint Search(HashTable *p, int key)\n{\n\tint addr = HASH(key);\n\tif (key == p->element[addr])\n\t\treturn addr;\n\telse\n\t{\n\t\tfor (int i = 0; i < p->count; ++i)\n\t\t\tif (p->extraElement[i] == key)\n\t\t\t{\n\t\t\t\tcout << \"溢出表\" << endl;\n\t\t\t\treturn i;\n\t\t\t}\n\t}\n\treturn -1;\n}\nint main(void)\n{\n\tint a[10] = { 12,45,2,6,78,9,0,1,15 };\n\tHashTable table;\n\tInit(&table);\n\tfor (int i = 0; i < 10; i++)\n\t\tInsertHash(&table, a[i]);\n \n\tint res = Search(&table, 2);\n\tif (res != -1)\n\t\tcout << \"查找成功！地址为： \" << res << endl;\n\telse\n\t\tcout << \"查找失败！ \" << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n","categories":["课堂笔记"]},{"title":"基础数据结构_线性表概括&顺序表","url":"/基础数据结构/基础数据结构_线性表概括&顺序表/","content":"# 线性表\n\n线性表(linear_list)是最常用且最简单的一种数据结构。简言之，**一个线性表是n个数据元素的有限序列**。至于每个数据元素的具体含义，在不同的情况下各不相同，它可以是一个整数或一个字符，也可以是一页书，甚至其他更复杂的信息。\n\n## 线性结构的特点\n\n1. 存在惟一的一个被称作“第一个”的数据元素；\n2. 存在惟一的一个被称作“最后一个”的数据元素；\n3. 除第一个之外，集合中的每个数据元素均只有一个前驱；\n4. 除最后一个之外，集合中每个数据元素均只有一个后继；\n\n![image-20210914180221393](../../images/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A6%82%E6%8B%AC&%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20210914180221393.png)\n\n概括来讲，最大的特点就是“**元素之间一对一**”的特点，即特点3和4；另外的一个标志就是，**它是连续不间断的**。\n\n最后还要说明的是，虽然我们对线性表的定义中没有要求n个数据元素是相同类型的，但是**我们在编程的实际应用中只研究数据元素具有相同类型的线性表**。因为无类型的泛型线性表没有研究价值和意义。\n\n```c\nint main()\n{\n    int ar[10] = {12,23,34,45,56,67};\n    double dx[10] = {12.23, 23.34, 34.45};\n    \n    //以下泛型线性表我们不做研究\n    {12, 45.56, 'a', {\"09001\",\"yhping\",\"man\"}, \"hmin\"};\n}\n```\n\n数据元素类型相同的线性表的相邻数据元素之间存在序偶关系。若将含有n个元素的线性表记为：\n$$\n(a_0,a_1,...,a_{i-1},a_i,a_{i+1},...,a_{n-1})\n$$\n则表中$a_{i-1}$领先于$a_{i}$，$a_{i}$领先于$a_{i+1}$。称$a_{i-1}$是$a_{i}$的直接前驱元素，$a_{i+1}$是$a_{i}$的直接后继元素。当$i=0,2,...,n-2$时，$a_{i}$有且仅有一个直接后继，当$i=1,2,...,n-1$时，$a_{i}$有且仅有一个直接前驱。\n\n## 总结\n\n线性表的决定性特征：\n\n1. 一对一\n2. 连续不间断\n\n# 顺序表\n\n顺序表是线性表的一种表示和实现方式。指的是用一组地址连续的存储单元依次存储线性表的数据元素。\n\n示例：\n\n```c\nint main()\n{\n    int ar[10]={12,23,34,45,56,67,78,89,90,100};\n  //位序、数组下标:0  1  2  3  4  5  6  7  8  9\n    return 0;\n}\n```\n![image-20210914212736157](../../images/基础数据结构_线性表概括&顺序表/image-20210914212736157.png)\n\n## 容量固定的顺序表\n\n有缺陷。容量固定的顺序表的数据元素一般都是直接以数组的形式在栈空间中存放，顺序表一旦定义在内存中，则存储空间就定死了。而栈的空间资源是很宝贵的，默认情况下栈的大小只有1M，导致固定的顺序表最大容量受到限制。\n\n```c\n#define SEQ_INIT_SIZE 1024*1024\t//1M，将会栈溢出\ntypedef char ElemType;\ntypedef struct\n{\n    ElemType data[SEQ_INIT_SIZE];\n    int cursize;\n}SeqList;\n```\n## 容量可变顺序表\n\n当顺序表需要扩容时，我们需要重新给顺序表分配存储空间，即调用动态内存管理函数realloc。我们在这里默认一个新的顺序表的初始容量是10，扩容后的容量是原容量的2倍。\n\n```c\n#define SEQ_INIT_SIZE 10\n#define SEQ_INC_SIZE 2\n```\n\n### 结构体设计\n\n```c\ntypedef struct\n{\n    ElemType *data;\t//专门定义一个指针，指向动态空间的首地址\n    int capacity;\t//容量\n    int cursize;\t//现存元素个数\n}SeqList;\n```\n\n\n\n```c\nint main()\n{\n    SeqList myseq;\n    InitSeqList(&myseq);\n    return 0;\n}\n```\n\n以下即是声明了SeqList myseq;后，myseq在内存中的情况。\n\n![image-20210914223828585](../../images/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A6%82%E6%8B%AC&%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20210914223828585.png)\n\n### 初始化\n\n即如何编写InitSeqList(&myseq);函数\n\n```c\n//最原始的写法\n#define SEQ_INIT_SIZE 10\n#define SEQ_INC_SIZE 2\ntypedef int ElemType;\nvoid InitSeqList(SeqList seq)\n{\n    seq.capacity = SEQ_INIT_SIZE;\n    seq.cursize = 0;\n    seq.data = (ElemType*)malloc(seq.capacity);\n}\nint main()\n{\n    SeqList myseq = {};\t//把成员都初始化为0，否则在VS2012环境下的代码运行过程中会报错。即运行时值传递不会进行。就比如int a;printf(\"%d\\n\",a);主要是因为没有进行初始化的值是随机值，某些运行环境会认为此时进行值传递是毫无意义的。\n    InitSeqList(myseq);\n    return 0;\n}\n```\n\n以上写法是不可使myseq正确初始化的，因为**函数只对子函数域的形参myseq初始化**，函数执行完毕后，子函数域的myseq就被收回资源，而**主函数域中的myseq的实际内容丝毫无影响**。因为InitSeqList(myseq)只是相当于复制了一个myseq，即把自身的成员值传递给了一个其他域的myseq。\n\n这是第一个问题。\n\n除了这个问题，因为：子函数执行完毕后，子函数域的myseq就被收回资源，而此时data指针所指向的动态空间未被释放，导致内存泄漏。\n\n所以这个初始化函数的写法是错上加错的。\n\n正确的做法应该是传递主函数域中myseq的自身地址，从而实现对主函数域的myseq进行初始化。\n\n下一个问题，(ElemType\\*)malloc(seq.capacity);，malloc的参数是存储单元数，即字节数。此处的元素类型是ElemType即int型，int型每一个元素占4个字节，所以应该在参数中再乘以4。即seq.capacity\\*4\n\n第一次改进后的代码\n\n```c\n//第一次改进\n#define SEQ_INIT_SIZE 10\n#define SEQ_INC_SIZE 2\ntypedef int ElemType;\nvoid InitSeqList(SeqList *plist)\n{\n    plist->capacity = SEQ_INIT_SIZE;\n    plist->cursize = 0;\n    plist->data = (ElemType*)malloc(plist->capacity*sizeof(ElemType));\n}\nint main()\n{\n    SeqList myseq = {};\n    InitSeqList(&myseq);\n    return 0;\n}\n```\n\n还有一些细节上的问题，函数在执行前，**要进行判空处理**，即传入的plist不要是NULL指针。第二，malloc是向堆区申请空间，堆区大小也是有限的，所以有可能申请不到，我们**要对失败情况进行处理**。\n\n第二次改进后的代码\n\n```c\nvoid InitSeqList(SeqList *plist)\n{\n    assert(plist!=NULL);\n    plist->capacity = SEQ_INIT_SIZE;\n    plist->cursize = 0;\n    plist->data = (ElemType*)malloc(plist->capacity*sizeof(ElemType));\n\tif(NULL == plist->data)\n    {\n        printf(\"error \\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n```\n\n### 整表打印\n\n```c\nvoid PrintSeqList(SeqList *plist)\n{\n    assert(plist!=NULL);\n    printf(\"Capacity: %d\\n\",plist->capacity);\n    printf(\"Cursize: %d\\n\",plist->cursize);\n    for(int i = 0; i < plist->cursize; ++i)\n    {\n        printf(\"%3d\",plist->data[i]);\n    }\n    printf(\"\\n\");\n}\n```\n\n### 查询某值的下标位置\n\n```c\n//第一次写\nint FindValue(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    int pos = -1;\n    for(int i = 0; i < plist->cursize; ++i)\n    {\n        if(val == plist->data[i])\n        {\n            pos = i;\n            break;\n        }\n    }\n    return pos;\n}\n```\n\n\n\n```c\n//改进，巧妙地运用“找到”情况下的返回值和“未找到”情况下返回值的关联。使代码的逻辑如行云流水一般顺畅。\nint FindValue(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    int pos = plist->cursize - 1;\n    while(pos>=0 && plist->data[pos]!=val)//有两个出口：一是pos<0即为-1，表示整个表中未找到val；另一个出口是data[pos]==val，此时的pos即为val值的下标。\n    {\n        --pos;\n    }\n    return pos;\n}\n```\n\n### 未考虑容量问题\n\n在指定位置插入数据元素\n\n```c\nbool InsertItem(SeqList *plist, int pos, ElemType val)\n{\n    assert(plist!=NULL);\n    if(pos<0 || pos > plist->cursize)\n    {\n        return false;\n\t}\n    //该位置之后的元素全都向后移一位。\n    for(int i = plist->cursize; i>pos; --i)\n    {\n        plist->data[i]=plist->data[i-1];//存在漏洞，如果表满，i越界\n    }\n    plist->data[pos] = val;\n    plist->cursize += 1;\n    return true;\n}\n//尾插\nvoid Push_Back(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    InsertItem(plist, plist->cursize, val);\n}\n//头插\nvoid Push_Front(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    InsertItem(plist, 0, val);\n}\n```\n\n### 考虑容量问题\n\n#### 获取大小、容量\n\n```c\nint GetSize(SeqList *plist)\n{\n    assert(plist!=NULL);\n    return plist->cursize;\n}\nint GetCapacity(SeqList *plist)\n{\n    assert(plist!=NULL);\n    return plist->capacity;\n}\n```\n\n\n\n#### 判空、判满\n\n```c\nbool IsEmpty(SeqList *plist)\n{\n    assert(plist!=NULL);\n    return GetSize(plist) == 0;\n}\nbool IsFull(SeqList *plist)\n{\n    assert(plist!=NULL);\n    return GetSize(plist) == GetCapacity(plist);\n}\n```\n\n\n\n#### 增容\n\n##### 用malloc实现的增容\n\n完成的动作：\n\n1. malloc\n2. myseq.data所有数据移动到新空间\n3. free原空间\n4. data指针指向新空间的首地址\n5. 更新capacity\n\n```c\nbool Inc_Capacity(SeqList *plist)\n{\n    assert(plist!=NULL);\n    ElemType *newdata = NULL;\n    int newcap = GetCapacity(plist)*SEQ_INC_SIZE;\n    newdata = (ElemType*)malloc(newcap*sizeof(ElemType));\n    if(NULL == newdata)\n    {\n        return false;\n    }\n    \n    for(int i = 0;i < plist->GetCapacity(plist);++i)\n    {\n        newdata[i] = plist->data[i];\n    }\n    \n    free(plist->data);\n    \n    plist->data = newdata;\n    \n    plist->capacity = newcap;\n    return true;\n}\n```\n\n优化-移动数据\n\n```c\n\t/*for(int i = 0;i < plist->GetCapacity(plist);++i)\n    {\n        newdata[i] = plist->data[i];\n    }*/\n\t//可以换为\n\tmemmove(newdata, plist->data, plist->cursize*sizeof(ElemType));\n```\n\n##### 用realloc实现的增容\n\n```c\nbool Inc_Capacity(SeqList *plist)\n{\n    assert(plist!=NULL);\n    int newcap = GetCapacity(plist)*SEQ_INC_SIZE;\n    \n    //不要直接把realloc的返回值赋给plist->data，因为可能返回NULL，导致数据空间丢失。\n    ElemType *newdata = (ElemType*)realloc(plist->data, newcap*sizeof(ElemType));\n    if(NULL == newdata)\n    {\n        return false;\n    }\n    \n    plist->data = newdata;\n    \n    plist->capacity = newcap;\n    return true;\n}\n```\n\n\n\n#### 在指定位置插入数据元素\n\n\n\n```c\nbool InsertItem(SeqList *plist, int pos, ElemType val)\n{\n    assert(plist!=NULL);\n    if(pos<0 || pos > plist->cursize)\n    {\n        return false;\n\t}\n    if(IsFull(plist) && !Inc_Capacity(plist))//表满且扩容失败\n    {\n        return false;\n    }\n    //该位置之后的元素全都向后移一位。\n    for(int i = plist->cursize; i>pos; --i)\n    {\n        plist->data[i]=plist->data[i-1];//永远不会越界，因为移动前已经确保空间充足\n    }\n    plist->data[pos] = val;\n    plist->cursize += 1;\n    return true;\n}\n```\n\n优化-返回状态值\n\n```c\n//infeasible:不可行\n//overflow:空间不足，内存溢出\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n\n#define INFEASIBLE -1\n#define OVERFLOW -2\n\ntypedef int Status;\n\nStatus InsertItem(SeqList *plist, int pos, ElemType val)\n{\n    assert(plist!=NULL);\n    if(pos<0 || pos > plist->cursize)\n    {\n        return INFEASIBLE;\n\t}\n    if(IsFull(plist) && !Inc_Capacity(plist))//表满且扩容失败\n    {\n        return OVERFLOW;\n    }\n    //该位置之后的元素全都向后移一位。\n    for(int i = plist->cursize; i>pos; --i)\n    {\n        plist->data[i]=plist->data[i-1];//永远不会越界，因为移动前已经确保空间充足\n    }\n    plist->data[pos] = val;\n    plist->cursize += 1;\n    return OK;\n}\n\nint main()\n{\n    Status tag = InsertItem(&myseq,12,23);\n    if(tag == INFEASIBLE)\n    {\n        printf(\"位置不可行\");\n    }\n    else if(tag == OVERFLOW)\n    {\n        printf(\"内存溢出\");\n    }\n    else if(tag == OK)\n    {\n        printf(\"成功\");\n    }\n}\n```\n\n\n\n#### 尾插、头插\n\n```c\nvoid Push_Back(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    InsertItem(plist, plist->cursize, val);\n}\n```\n\n```c\nvoid Push_Front(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    InsertItem(plist, 0, val);\n}\n```\n\n#### 插数据测试\n\n```c\nint main()\n{\n    SeqList myseq = {};\n    InitSeqList(&myseq);\n    for(int i = 0; i<20; ++i)\n    {\n        Push_Back(&myseq,i);\n        PrintSeqList(&myseq);\n\t}\n    return 0;\n}\n```\n\n#### 删\n\n```c\nStatus EraseItem(SeqList *plist, int pos)\n{\n    assert(plist!=NULL);\n    if(pos < 0 || pos > plist->cursize - 1)\n    {\n        return INFEASIBLE;\n    }\n    for(int i = pos; i < plist->cursize - 1; i++)\n    {\n        plist->data[i] = plist->data[i+1];\n    }\n    plist->cursize -= 1;\n    return OK;\n}\n```\n\n#### 头删、尾删\n\n```c\nvoid Pop_Front(SeqList *plist)\n{\n    assert(plist!=NULL);\n    EraseItem(plist, 0);\n}\nvoid Pop_Back(SeqList *plist)\n{\n    assert(plist!=NULL);\n    EraseItem(plist, plist->cursize-1);\n}\n```\n\n#### 判断数据元素是否在表中\n\n```c\nbool LocateElem(const SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    return FindValue(plist,val) != -1;\n}\n```\n\n#### 删除最后一个数据元素val\n\n因为Find函数是从后向前找的。\n\n```c\nStatus Remove(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    return EraseItem(plist, FindValue(plist, val));\n}\n```\n\n#### 置空、摧毁\n\n```c\nvoid ClearSeqList(SeqList *plist)\n{\n    assert(plist!=NULL);\n    plist->cursize = 0;\n}\nvoid Destroy(SeqList *plist)\n{\n    assert(plist!=NULL);\n    plist->cursize = 0;\n    plist->capacity = 0;\n    free(plist->data); \n}\n```\n\n\n\n#### 删除所有val元素\n\n```c\nvoid Remove_All(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    int j = 0;\n    for(int i = 0;i<plist->cursize; ++i)\n    {\n        if(val != plist->data[i])\n        {\n            plist->data[j]=plist->data[i];\n            j++;\n        }\n    }\n    plist->cursize = j;\n}\n```\n\n### 整理代码+const\n\n#### 头文件\n\n```c\n//My_SeqList.h\n#ifndef MY_SEQLIST_H\n#define MY_SEQLIST_H\n\n//infeasible:不可行\n//overflow:空间不足，内存溢出\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n\n#define INFEASIBLE -1\n#define OVERFLOW -2\n\ntypedef int Status;\n#define SEQ_INIT_SIZE 4\n#define SEQ_INC_SIZE 2\ntypedef int ElemType;\ntypedef struct\n{\n    ElemType *data;\n    int capacity;\n    int cursize;\n}SeqList;\n\nvoid InitSeqList(SeqList *plist);\nvoid DestroySeqList(SeqList *plist);\n\nvoid ClearSeqList(SeqList *plist);\n\nint GetSize(const SeqList *plist);\nint GetCapacity(const SeqList *plist);\nbool IsEmpty(const SeqList *plist);\nbool IsFull(const SeqList *plist);\n\nint FindValue(const SeqList *plist, ElemType val);\n\nbool Inc_Capacity(SeqList *plist);\nStatus InsertItem(SeqList *plist, int pos, ElemType val);\nvoid Push_Back(SeqList *plist, ElemType val);\nvoid Push_Front(SeqList *plist, ElemType val);\n\nStatus EraseItem(SeqList *plist, int pos);\nvoid Pop_Back(SeqList *plist);\nvoid Pop_Front(SeqList *plist);\nbool LocateElem(const SeqList *plist, ElemType val);\nStatus Remove(SeqList *plist, ElemType val);\n\nvoid PrintSeqList(const SeqList *plist);\n#endif\n```\n\n#### cpp文件\n\n```c\n//My_SeqList.cpp\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#include\"My_SeqList.h\"\n\nvoid InitSeqList(SeqList seq)\n{\n    seq.capacity = SEQ_INIT_SIZE;\n    seq.cursize = 0;\n    seq.data = (ElemType*)malloc(seq.capacity);\n}\nvoid ClearSeqList(SeqList *plist)\n{\n    assert(plist!=NULL);\n    plist->cursize = 0;\n}\nvoid DestroySeqList(SeqList *plist)\n{\n    assert(plist!=NULL);\n    plist->cursize = 0;\n    plist->capacity = 0;\n    free(plist->data); \n}\n\nint GetSize(const SeqList *plist)\n{\n    assert(plist!=NULL);\n    return plist->cursize;\n}\nint GetCapacity(const SeqList *plist)\n{\n    assert(plist!=NULL);\n    return plist->capacity;\n}\nbool IsEmpty(const SeqList *plist)\n{\n    assert(plist!=NULL);\n    return GetSize(plist) == 0;\n}\nbool IsFull(const SeqList *plist)\n{\n    assert(plist!=NULL);\n    return GetSize(plist) == GetCapacity(plist);\n}\n\nint FindValue(const SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    int pos = plist->cursize - 1;\n    while(pos>=0 && plist->data[pos]!=val)\n    {\n        --pos;\n    }\n    return pos;\n}\nbool Inc_Capacity(SeqList *plist)\n{\n    assert(plist!=NULL);\n    int newcap = GetCapacity(plist)*SEQ_INC_SIZE;\n    \n    ElemType *newdata = (ElemType*)realloc(plist->data, newcap*sizeof(ElemType));\n    if(NULL == newdata)\n    {\n        return false;\n    }\n    \n    plist->data = newdata;\n    \n    plist->capacity = newcap;\n    return true;\n}\n\nStatus InsertItem(SeqList *plist, int pos, ElemType val)\n{\n    assert(plist!=NULL);\n    if(pos<0 || pos > plist->cursize)\n    {\n        return INFEASIBLE;\n\t}\n    if(IsFull(plist) && !Inc_Capacity(plist))//表满且扩容失败\n    {\n        return OVERFLOW;\n    }\n    //该位置之后的元素全都向后移一位。\n    for(int i = plist->cursize; i>pos; --i)\n    {\n        plist->data[i]=plist->data[i-1];//永远不会越界，因为移动前已经确保空间充足\n    }\n    plist->data[pos] = val;\n    plist->cursize += 1;\n    return OK;\n}\n\nvoid Push_Back(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    InsertItem(plist, plist->cursize, val);\n}\n\nvoid Push_Front(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    InsertItem(plist, 0, val);\n}\n\n\nStatus EraseItem(SeqList *plist, int pos)\n{\n    assert(plist!=NULL);\n    if(pos < 0 || pos > plist->cursize - 1)\n    {\n        return INFEASIBLE;\n    }\n    for(int i = pos; i < plist->cursize - 1; i++)\n    {\n        plist->data[i] = plist->data[i+1];\n    }\n    plist->cursize -= 1;\n    return OK;\n}\n\nvoid Pop_Front(SeqList *plist)\n{\n    assert(plist!=NULL);\n    EraseItem(plist, 0);\n}\nvoid Pop_Back(SeqList *plist)\n{\n    assert(plist!=NULL);\n    EraseItem(plist, plist->cursize-1);\n}\n\nbool LocateElem(const SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    return FindValue(plist,val) != -1;\n}\n\nStatus Remove(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    return EraseItem(plist, FindValue(plist, val));\n}\n\nvoid Remove_All(SeqList *plist, ElemType val)\n{\n    assert(plist!=NULL);\n    int j = 0;\n    for(int i = 0;i<plist->cursize; ++i)\n    {\n        if(val != plist->data[i])\n        {\n            plist->data[j]=plist->data[i];\n            j++;\n        }\n    }\n    plist->cursize = j;\n}\nvoid PrintSeqList(const SeqList *plist)\n{\n    assert(plist!=NULL);\n    printf(\"Capacity: %d\\n\",plist->capacity);\n    printf(\"Cursize: %d\\n\",plist->cursize);\n    for(int i = 0; i < plist->cursize; ++i)\n    {\n        printf(\"%3d\",plist->data[i]);\n    }\n    printf(\"\\n\");\n}\n```\n\n```c\nint main()\n{\n    SeqList myseq;\n    InitSeqList(&myseq);\n    \n    \n    \n    DestroySeqList(&myseq);\n}\n```\n\n# 面试题\n\n## 查表法找数组中重复的值\n\n```c\n//\nint FindDuplicate(int *nums, int size)\n{\n    assert(nums!=NULL);\n    int res = 0;\n    int *ar = (int*)calloc(size,sizeof(int));\n    if(NULL == ar)\n    {\n        exit(1);\n    }\n    for(int i = 0;i<size;++i)\n    {\n        if(ar[nums[i]]++!=0)\n        {\n         \tres = nums[i];\n            break;\n        }\n    }\n    free(ar);\n    ar = NULL;\n    return res;\n}\n```\n\n","categories":["基础数据结构"]},{"title":"MIT-6.S081","url":"/操作系统/MIT-6.S081/","content":"# 内容\n\nSchedule: [6.S081 / 2020年秋季 --- 6.S081 / Fall 2020 (mit.edu)](https://pdos.csail.mit.edu/6.828/2020/schedule.html)\n1. Basic ideas of OS\n2. Study of the code in xv6 (a small teaching OS)\n    1. talk about how it works\n    2. look at the code and show the code executing\n    3. reading assignments, a book that describes how xv6 operates and why it's designed that way.\n    4. xv6 is a simplified unix-like operating system, which runs on the RISC-V microprocessor that is the same microprocessor and the focus of 6.004, but in this course we will run xv6 under the QEMU machine emulator which runs on Linux.\n3. Background to help do the labs, like about C works, how the RISC-V which is the microprocessor that will be used.\n# Labs\n\nEither implementing basic operating system features or adding a kernel extensions to the xv6 operating system.\n\n2023 Guidance: [6.1810 / 2023 年秋季 --- 6.1810 / Fall 2023 (mit.edu)](https://pdos.csail.mit.edu/6.828/2023/tools.html)\n## 安装中遇到的棘手问题（Apple M芯片、macOS 14）\n\n1. 不需要安装xcode IDE，只需要安装`$ xcode-select --install`即可，是xcode的命令行工具\n2. 安装Homebrew，按照官网给的一句话命令安装\n3. https://github.com/riscv/homebrew-riscv 这是homebrew下安装risc-v，旧系统、旧芯片可能会装到`/usr/local/opt/riscv-gnu-toolchain/bin`，但新系统、新芯片则装到了`/opt/homebrew/Cellar/riscv-gnu-toolchain/main.reinstall/bin`。\n4. The brew formula may not link into /usr/local. You will need to update your shell's rc file (e.g. [~/.bashrc](https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html)) to add the appropriate directory to [$PATH](http://www.linfo.org/path_env_var.html).\n    1. 此处需要手动添加PATH，例子中说的是bashrc，M2、macOS14系统下默认终端是zsh，因此需要在家目录下的`.zshrc`中添加：`PATH=$PATH:/opt/homebrew/Cellar/riscv-gnu-toolchain/main.reinstall/bin`。意味着将此目录添加到当前用户的环境变量 `PATH` 中。这个操作的作用是将该目录下的可执行文件路径包含进系统的执行路径中，使得系统可以直接在命令行中找到并执行这些命令。\n    2. 修改 `.zshrc` 后，需要执行 `source ~/.zshrc` 命令使其生效，或者关闭当前终端窗口重新打开一个新窗口。\n5. 用brew安装qemu，默认装到了`/opt/homebrew/Cellar/qemu/9.0.1`\n6. 然后，以上这些和xv6没关系，第一节课演示的xv6系统需要git源码：`git clone git://g.csail.mit.edu/xv6-labs-2023`然后进入make qemu。\n7. 如何退出xv6：先按`Ctrl+A`后单击`X`。\n## Lab1\n\nWriting applications that make the system calls\n## The Last Lab\n\nAdd a network stack and a network driver, to be able to connect in over the network to the operating system that you run.\n# 零碎\n\n## Xv6 I/O 与文件描述符\n\nhttps://blog.csdn.net/u012419550/article/details/113850465\n\n# OS设计原则\n\nOS should be defensive.\n- app cannot crash the OS\n- app cannot break out of its isolation\n\nStrong isolation between app and OS\n- typical : Hardware Support\n    - user / kernel mode\n    - virtual memory system\n# E01 - open & fork\n\nOperating Systems provide a lot of features and a lot of services, but they actually tend to interact, and sometimes in odd ways that require a lot of thought, even the simple examples given with **open** and **fork**.\nif a program allocates a file descriptor with the **open** system call, and then that same program forks.\nThe semantics of fork turned out to be that you create a new process that's a copy of the current process, this file descriptor you opened is truly to be a copy, this file descriptor still has to be present and usable in the child. So that is the files, the opened file descriptors, interact with fork in this interesting way. \nfork的语义是：创建一个进程，是当前进程的副本。\n刚才打开的文件描述符在子进程中仍然存在并可用。\n# Page Faults\nPlan：\n1. Implement Virtual Memory features using page faults\n    1. lazy allocation\n    2. copy on write fork\n    3. demand paging\n    4. memory mapped files","categories":["操作系统"]},{"title":"C语言_动态内存分配","url":"/C/C语言_动态内存分配/","content":"# malloc\n\n1. 返回类型为void *\n2. 参数为(unsigned int size)，表示总共要开辟的字节数\n\n```c\nint* p = nullptr;\nint n = 0;\nscanf_s(\"%d\", &n);\n//p = (int*)malloc(n);//这是错误的参数，因为malloc的参数要写要开辟的字节数，而不是以变量数为单位。\np = (int*)malloc(sizeof(int) * n);\n```\n\n\n\n# calloc\n\n1. 返回类型为*void\n2. 参数为(unsigned int count, unsigned int size)，count表示变量数，size表示单个变量(类型)的字节数。\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>//包含memset函数\ntypedef unsigned int size_t;\nvoid* My_Calloc(size_t count, size_t size)\n{\n    void* p = malloc(count * size);\n    if(nullptr != p)\n    {\n        memset(p, 0, count * size);//把p指向的内存空间中的数据赋值为0x00\n    }\n    return p;\n}\n```\n\n# free\n\n1. 不管是malloc还是calloc开辟的空间都是用free(p)来释放的。\n\n2. free并不是把p释放掉了，而是把p指向堆区的空间从引用状态转换成未引用状态。\n\n3. 空间的释放只能释放一次，不能释放多次\n\n4. free(p)释放后，要给p赋值nullptr，防止指针失效带来的麻烦。\n\n   ```c\n   int* p = (int*)My_Calloc(10, sizeof(int));\n   free(p);\n   p = nullptr;\n   return 0;\n   ```\n\n   \n\n# realloc\n\nrealloc扩充或收缩之前分配的内存块（重新分配内存块）\n\n```c\nvoid *realloc(void *ptr, size_t new_size);\n```\n1. 参数中的ptr指向需要重新分配的内存区域的地址，new_size为新的字节数\n2. 返回值：成功时，返回指向新分配内存的指针，返回的指针必须用free或realloc归还。；失败时，返回空指针。原指针ptr保持有效，并需要通过free或realloc归还。\n\n重新分配给定的内存区域。它必须是之前为malloc/calloc/realloc分配的，并且仍未被free或realloc的调用所释放。否则，结果未定义。\n\n```c\nint size=5;//分配空间的变量数为5\nint new_size=10;//最终要分配空间的变量数为10\nint* p = (int*)malloc(sizeof(int)*size);//开辟size个int空间\nfor(int i=0;i<size;++i)\n{\n    p[i]=1;\n}\np = (int*)realloc(p, sizeof(int) * new_size);//增加到new_size个int空间，即由原来5个扩充到10个\np = (int*)realloc(p, sizeof(int) * 2);//减少到2个int空间，即由原来5个收缩到2个\n```\n\n","categories":["C"]},{"title":"基础数据结构_C语言实现","url":"/基础数据结构/基础数据结构_C语言实现/","content":"# 内容\n\n1. 数据结构的基础概念和时间空间复杂度\n2. 线性表：顺序表、链表\n   1. 顺序表（定长的、扩容的）\n   2. 单链表（带头结点的、不带头结点的）\n      1. 需要动手实践，大量的面试题\n3. 栈（顺序栈、链栈）\n   1. 用两个栈实现一个队列\n4. 队列（顺序队、链队）\n   1. 用两个队实现一个栈\n5. 串（字符数组）\n   1. API实现（strcpy strcat srtcmp strlen）\n   2. 字符串的查找（BF、KMP算法）\n6. 双向链表、循环链表、双向循环链表\n7. 八大排序算法\n   1. 冒泡排序\n   2. 二路归并排序\n   3. 插入排序\n   4. 希尔排序\n   5. 堆排序\n   6. 基数排序（桶排序）\n   7. 快速排序\n   8. 选择排序\n\n# 概念\n\n## 数据结构\n\n1. 集合\n2. 线性（现实生活中的排队）\n3. 树型（部门架构、族谱）\n4. 图型（交通网络、六度分割理论、网络拓扑）\n\n## 时间复杂度\n\n执行语句与问题规模之间的函数\n\n1. O(1): 没有循环，或者有循环但是循环的退出条件和问题规模之间没有关系；\n2. O(n): 有循环，循环的退出条件与问题规模之间存在关系，并且控制循环的变量以++或者--的方式执行\n3. O(n^2): 有循环，嵌套一层。\n4. O(logn): 有循环，循环的退出条件与问题规模之间存在关系，并且控制循环的变量每次\\*2或/2的方式执行。\n\n## 空间复杂度\n\n算法所需的额外存储空间（除了函数本身计算申请的内存外）与问题规模之间的关系。\n\n```c\nvoid Show(int arr[], int len)\n{\n    for(int i = 0;i<len;++i)\n    {\n        printf(\"%d \",arr[i]);\n    }\n}\n```\n\n此处，函数参数中的int arr[]和int len不是额外存储空间。而是for循环。\n\n# 线性表\n\n* 唯一的头（此处的头指的是第一个有效节点），唯一的尾。\n* 除了头，剩余的节点都有前驱。除了尾，剩余的节点都有后继。\n\n## 定长顺序表\n\n相当于一个特殊使用的数组。\n\n但存放数据是按顺序来存的，不能随意位置存放。\n\n```c\n//sqlist.h\n#pragma once\t//防止头文件重复\ntypedef int ElemType;\ntypedef struct Sqlist\n{\n    ElemType arr[10];//节点\n    int length;//当前有效数据节点的个数\n}Sqlist,*PSqlist;\n//初始化\nvoid Init_sqlist(PSqlist plist);\n//增删改查\n//按位置插入（头插、尾插）\nbool Insert_Pos(PSqlist plist, int pos, int val);\n//删除：按值删、按位置删（删除这个值第一次出现的位置）\nbool Del_val(PSqlist plist, int val);\nbool Del_pos(PSqlist plist, int pos);\n//查找值为val的节点\nSqlist* FindNode(PSqlist plist, int val);\n//判空 判满\nbool IsEmpty(PSqlist plist);\nbool IsFull(PSqlist plist);\n//清空\nvoid Clear(PSqlist plist);\n//销毁\nvoid Destory(PSplist plist);\n```\n\n```c\n#include<stdio.h>\n#include<assert.h>\n#include<stdlib.h>\n#include\"sqlist.h\"\n#include<string.h>\n//初始化\nvoid Init_sqlist(PSqlist plist)\n{\n    assert(plist!=NULL);\n    memset(plist->arr,0,sizeof(arr));\n    plist->length = 0;\n}\n//增删改查\n//按位置插入（头插、尾插）\nbool Insert_Pos(PSqlist plist, int pos, int val)\n{\n    assert(plist!=NULL);\n    if( pos<0 || pos > plist->length || IsFull(plist) )return false;\n    \n    //移动数据\n    for(int i = plist->length-1; i>=pos ;i--)\n    {\n        //不会越界，因为如果length为10时，不能进入此循环\n        plist->arr[i+1] = plist->arr[i];\n    }\n    //插空\n    plist->arr[pos] = val;\n    //长度加1\n    plist->length++;\n    return true;\n}\n//头插\nbool Push_Front(PSqlist plist, int val)\n{\n    assert(plist!=NULL);\n    return Insert_Pos(plist, 0, val);\n}\n//尾插\nbool Push_Back(PSqlist plist, int val)\n{\n    assert(plist!=NULL);\n    return Insert_Pos(plist, plist->length, val);\n}\n//删除：（删除这个值第一次出现的位置）\n//按值删\nbool Del_val(PSqlist plist, int val)\n{\n    assert(plist!=NULL);\n    return Del_pos(plist, FindPos_withVal(plist, val) );\n}\n//按位置删\nbool Del_pos(PSqlist plist, int pos)\n{\n    assert(plist!=NULL);\n    if( pos<0 || pos > plist->length || IsEmpty(plist) )return false;\n    //长度减1\n    plist->length--;\n    //移动数据（相当于清除了arr[pos]）\n    for(int i = pos; i < plist->length-1 ;++i)//i < plist->length-1  容易出错\n    {\n        plist->arr[i] = plist->arr[i+1];\n    }\n    return true;\n}\n//头删\nbool Pop_Front(PSqlist plist)\n{\n    assert(plist!=NULL);\n    Del_pos(plist, 0);\n}\n//尾删\nbool Pop_Back(PSqlist plist)\n{\n    assert(plist!=NULL);\n    Del_pos(plist, plist->length);\n}\n//查找值为val的节点\nint FindPos_withVal(PSqlist plist, int val)\n{\n    assert(plist!=NULL);\n    int pos = -1;\n    int i = 0;\n    while(i< plist->length && val!=plist->arr[i])\n    {\n        ++i;\n    }\n    if(i!=length)//则while是因为val==plist->arr[i]跳出的。\n    {\n        pos = i;\n    }\n    return pos;\n}\n//判空 判满\nbool IsEmpty(PSqlist plist)\n{\n    return plist->length == 0;\n}\nbool IsFull(PSqlist plist)\n{\n    return plist->length == sizeof(plist->arr)/sizeof(plist->arr[0]);\n}\n//清空\nvoid Clear(PSqlist plist)\n{\n    assert(plist!=NULL);\n    plist->length = 0;\n}\n//销毁\nvoid Destory(PSplist plist)\n{\n    assert(plist!=NULL);\n    Clear(plist);\n}\n```\n\n## 不定长顺序表\n\n```c\n//sqlist.h\n#pragma once\t//防止头文件重复\ntypedef int ElemType;\n#define INIT_SIZE 10\ntypedef struct DSqlist\n{\n    ElemType* ar;//基地址\n    int cursize;//当前有效数据节点的个数\n    int capacity;//当前最长容量\n}DSqlist,*PDSqlist;\n//初始化\nvoid Init_sqlist(PDSqlist plist);\n//增删改查\n//按位置插入（头插、尾插）\nbool Insert_Pos(PDSqlist plist, int pos, int val);\n//头插\nbool Push_Front(PDSqlist plist, int val);\n//尾插\nbool Push_Back(PDSqlist plist, int val);\n//删除：按值删、按位置删（删除这个值第一次出现的位置）\nbool Del_val(PDSqlist plist, int val);\nbool Del_pos(PDSqlist plist, int pos);\n//头删\nbool Pop_Front(PDSqlist plist);\n//尾删\nbool Pop_Back(PDSqlist plist);\n//查找值为val的节点\nint FindPos_withVal(PDSqlist plist, int val);\n//判空 判满\nbool IsEmpty(PDSqlist plist);\nbool IsFull(PDSqlist plist);\n//清空\nvoid Clear(PDSqlist plist);\n//销毁\nvoid Destory(PDSplist plist);\nvoid Inc(PDsqlist plist);\n```\n\n```c\nvoid Inc(PDsqlist plist)\n{\n    \n}\n```\n\n# 单链表\n\n![image-20210902180653639](../../images/C%E8%AF%AD%E8%A8%80_%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210902180653639.png)\n\n\n\n![image-20210902181055988](../../images/C%E8%AF%AD%E8%A8%80_%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210902181055988.png)\n\n1. 第一种大厂笔试/面试中常用，主要考察对边界条件检测的掌握力；\n   * 不带头结点的逆置和带头结点的逆置难度不一样。\n2. 第二种实际编程中常用，方便好用；\n3. 第三种的循环无意义，因为功能和头指针差不多。\n4. 第四种是加了一个尾指针，使尾插也变O(1)，但代价是需要对尾指针进行密切维护。\n\n\n\n# 面试\n\n![image-20210904191948363](../../images/C%E8%AF%AD%E8%A8%80_%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20210904191948363.png)\n","categories":["C","基础数据结构"]},{"title":"C语言_编译和预处理","url":"/C/C语言_编译和预处理/","content":"# 内容\n\n本章主要讲解了预处理的三种方式：宏定义、文件包含、条件编译\n\n# 学习目标\n\n1. 掌握无参数宏定义和带参数宏定义的使用方法\n2. 学会使用文件包含\n3. 熟悉条件编译指令的使用方法\n\n预处理命令的作用不是实现程序的功能，而是给C语言编译系统提供信息，通知C编译器在对源程序进行编译之前应该做哪些预处理工作。预处理是指在进行编译之前所作的处理，由预处理程序负责完成。接下来还要经过编译、链接，才能变成可执行程序。本章节将结合案例对编译和预处理的相关知识进行详细讲解。\n\n# 最简单的预处理-不带参宏定义\n\n## 案例描述\n\n为了引入“预处理”这个概念，本案例要求将矩形的长和宽设置为宏，然后再求出矩形的面积。这事最简单的预处理。\n\n## 案例分析\n\n宏定义是预处理最常用的功能之一，它用于将一个标识符定义为一个字符串。这样，在源程序被编译器处理之前，预处理器会将标识符替换成定义的字符串。根据是否带参数，可以将宏定义分为无参数宏定义和带参数宏定义。本案例要学习的是不带参数的宏定义。\n\n## 必备知识\n\n### 不带参数的宏定义\n\n在程序中，经常会定义一些常量，例如，3.14、\"ABC\"。如果这些常量在程序中被频繁使用，难免会出现书写错误的情况。为了避免程序书写错误，可以使用不带参数的宏定义来定义这些常量，其语法格式如下：\n\n```c\n#define 标识符 字符串\n```\n\n在上述语法格式中，\"#define\"用于标识一个宏定义，\"标识符\"指的是所定义的宏名，\"字符串\"指的是宏体，它可以是常量、表达式等。一般情况下，宏定义需要放在源程序的开头，函数定义之外。它的有效范围是从宏定义语句开始到源文件结束。一般宏名都是大写字母，以便于与其他的操作符区别。\n\n```c\n#define PI 3.141592\n```\n\n### `#undef`指令取消宏定义\n\n与#define相对，还有#undef指令用于取消宏定义，当使用#define定义了一个宏之后，如果预处理器在接下来的源代码中看到了#undef指令，那么#undef后面的代码中这个宏将会失效，如下代码所示。\n\n```c\n#include<stdio.h>\n#define PI 3.14\nint main()\n{\n    printf(\"%f\\n\",PI);\n#undef PI\n    printf(\"%f\\n\",PI);\n    return 0;\n}\n```\n\n运行这段程序，会报错\n\n```c\nIntelliSense: 未定义标识符 \"PI\"\t\t//7行17列\nerror C2065: \"PI\": 未声明的标识符\t   //7行1列\n```\n\n# 第二简单的预处理-带参宏定义\n\n## 案例描述\n\n在之前的章节中，我们已经学过简单的数据交换。本案例要求使用宏定义，依次交换两个一维数组中的元素。\n\n## 案例分析\n\n本案例要实现两个一维数组中元素的依次交换，整个交换过程包含多次数组元素的交换。结合之前学习的知识，可以使用函数实现简单的数据交换功能，在使用循环遍历数组的同时，调用交换函数，实现数组元素的交换。本案例要求使用宏定义实现此功能。\n\n因为数组遍历的过程中，数据在不断改变，而不带参宏定义中只能定义固定的内容。这里我们需要使用第二简单的预处理方法——带参宏定义来完成本案例。\n\n## 必备知识\n\n### 带参数的宏定义\n\n语法格式如下所示：\n\n```c\n#define 标识符(形参表) 字符串\n```\n\n上述语法格式和不带参数的宏定义有些类似，不同的是多了一个括号，括号中的“形参表”由一个或多个形参组成，当多于一个形参时，形参之间要用逗号进行分隔。\n\n对于带参数的宏定义来说，同样需要使用字符串替换宏名，使用实参替换形参。\n\n### 与带参函数的区别\n\n带参宏定义和带参函数有时可以实现同样的功能，但两者有本质的不同，具体如表所示。\n\n| 基本操作     | 带参数的宏定义             | 带参数的函数                                                 |\n| ------------ | -------------------------- | ------------------------------------------------------------ |\n| 处理时间节点 | 预处理时                   | 程序运行时                                                   |\n| 参数类型     | 无                         | 需定义参数类型                                               |\n| 参数传递     | 不分配内存，无值传递的问题 | 分配内存，将实参值代入形参                                   |\n| 运行速度     | 快                         | 相对较慢，因为函数的调用会涉及到参数的传递、压栈、出栈等操作 |\n\n## 务必要注意的问题\n\n来看一个例子\n\n```c\n#define ABS(x) ((x)>=0 ? (x): -(x))\n```\n\n这是一个求绝对值的带参宏定义，调用这个宏定义，代码如下所示：\n\n```c\ndouble x = 12;\nprintf(\"%d \\n\",ABS(++x));\n```\n\n输出的结果是14，显然与我们的初意中的12不相符。这是因为在预处理时，表达式\"ABS(++x)\"会被替换为\"( (++x)>=0 ? (++x): -(++x) ) \"，因此结果是14。\n\n那么，这就是带参宏定义时要注意的问题，**宏定义中的参数替换是“整体”替换**，不像是函数中只是参数之间的值传递。\n\n## 案例实现\n\n```c\n#include<stdio.h>\n#define SWAP(a,b) {int temp = a; a=b; b=temp;}\nint main()\n{\n    int i,j;\n    int a[5]={3,4,5,6,7};\n    int b[5]={5,6,7,8,9};\n    for(int i = 0;i<5;i++)\n    {\n        SWAP(a[i],b[i]);\n    }\n    printf(\"After swaping:\\n\");\n    for(int i = 0;i<5;i++)\n    {\n        printf(\"%d \",a[i]);\n    }\n    printf(\"\\n\");\n    for(int i = 0;i<5;i++)\n    {\n        printf(\"%d \",b[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n//运行结果：\nAfter swaping\n5 6 7 8 9\n3 4 5 6 7\n```\n\n## 关于宏定义中参数的替换-要注意的问题\n\n### 表达式字符串中出现运算符\n\n若宏定义中的字符串出现运算符，需要在合适的位置上加上括号，如果不添加括号可能会出现错误。例如\n\n```c\n#define S 3+4\nint c = 100;\nint a = S*c\t\t//3+4*c == 403 而非 7*c ==700\n```\n\n### 宏定义的末尾不要加分号\n\n如果加了分号，将被视为被替换字符串的一部分。\n\n宏定义不会进行严格的语法检查，因此宏替换的错误要等到系统编译时才能被发现，例如：\n\n```c\n#define Max=20;\n....\nif(result == Max)\t//if(result==20;)\n{\n    printf(\"equal\");\n}\n//显然if语句会出错\n```\n\n### 宏定义允许嵌套\n\n在宏定义的字符串中可以使用已经定义的宏名。\n\n```c\n#define PI 3.141592\n#define P PI*x\nprintf(\"%f\",P);\t\t//替换后的语句为printf(\"%f\",3.141592*x);\n```\n\n但宏定义不支持递归，因此下面的宏定义是错误的：\n\n```c\n#define Max Max+5\n```\n\n# 预处理的第二种方式-文件包含\n\n## 案例描述\n\n要求设计一个头文件，将经常使用的输出模式都写进头文件中，方便编写代码。\n\n## 案例分析\n\n除宏定义外，文件包含也是一种预处理语句，它的作用就是将一个源程序文件包含到另外一个源程序文件中。\n\n## 必备知识\n\n### 文件包含命令的形式\n\n同引入头文件一样，文件包含也是使用#include指令实现的，它的语法格式有两种，具体如下\n\n#### 格式一\n\n```c\n#include <文件名>\n```\n\n#### 格式二\n\n```c\n#include \"文件名“\n```\n\n#### 区别\n\n上述两种格式都可以实现文件包含，不同的是，**格式一是标准形式，当使用这种格式时，C编译系统在系统指定的路径下搜索尖括号(<>)中的文件**；当使用**第二种格式时，系统首先会在用户当前工作的目录中搜索双引号(\"\")中的文件，如果找不到，再按系统指定的路径进行搜索。**\n\n## 案例实现\n\nfoo.h代码如下：\n\n```c\n#define INT(x) printf(\"%d\\n\",x)\n```\n\nmain.c代码如下：\n\n```c\n#include <stdio.h>\n#include \"foo.h\"\nint main()\n{\n    int a;\n    printf(\"Please input an integer:\\n\");\n    scanf(\"%d\",&a);\n    INT(a);\t\t//替换为\"printf(\"%d\\n\",a)\" + \";\"\n    return 0;\n}\n```\n\n# 32还是64-条件编译\n\n## 案例描述\n\n要求使用条件编译，根据条件输出对应的判定结果：如果系统是32位的，就输出“系统是32位的”；如果系统是64位的，就输出“系统是64位的”。\n\n## 案例分析\n\n上文提到的“条件编译”也是预处理的一种方式。\n\n一般情况下，C语言程序中的所有代码都要参与编译，但有时出于程序代码优化的考虑，希望源代码中一部分内容只在指定条件下进行编译。这种根据指定条件，只对程序一部分内容编译的情况，称为条件编译。\n\n在C语言中条件编译指令的形式有很多种，接下来将详细讲解一种最常见的条件编译指令：#if/#else/#endif，该指令根据常数表达式来决定某段代码是否执行。\n\n## 必备知识\n\n### #if/#else/#endif指令\n\n通常情况下，#if指令、#else指令和#endif指令是结合在一起使用的，其语法格式如下所示：\n\n```c\n#if 判断表达式\n\t程序段\n#else\n    程序段2\n#endif\n```\n\n在上述语法格式中，编译器只会编译程序段1和程序段2中的一段。当条件为真时，编译器会编译程序段1，否则编译程序段2。\n\n## 案例实现\n\n### 案例设计\n\n1. 定义两个宏，分别表示Windows32位和64位平台；\n2. 定义宏SYSTEM表示其中某个平台；\n3. 使用条件编译指令判断SYSTEM值，并输出结果到屏幕上。\n\n### 完整代码\n\n```c\n#include <stdio.h>\n#define Win32 0\n#define x64 1\n#define SYSTEM Win32\t\t//定义宏SYSTEM是32位的\nint main()\n{\n#if SYSTEM == Win32\t\t\t//此处条件成立\n    printf(\"Win32\\n\");\n#else\n    printf(\"x64\");\n#endif\n    return 0;\n}\n//执行printf(\"Win32\\n\");\n运行结果为 Win32\n```\n\n# #ifdef-神奇的#include<stdio.h>\n\n## 案例描述\n\n在同一文件中写两遍\"#include\\<stdio.h\\>\"，编译器进行编译时为什么没有报错呢？按常理而言，文件\"stdio.h\"中的函数和数据类型等必然被定义了两次，此时编译器应该报出\"重定义\"的错误，但实际上编译十分顺利。\n\n## 案例分析\n\n在上一个案例中我们提到C语言中条件编译指令的形式有很多种，如果现在的你百思不得其解，那是因为你没有学过另一种条件编译指令：#ifdef和#ifndef。下面来讲解。\n\n## 必备知识\n\n### #ifdef指令\n\n如果想判断某个宏是否被定义，可以使用#ifdef指令，通常情况下，该指令需要和#endif一起使用，#ifdef指令的语法格式如下所示：\n\n```c\n#ifdef 宏名\n\t程序段1\n#else\n    程序段2\n#endif\n```\n\n在上述语法格式中，#ifdef指令用于控制单独的一段源码是否需要编译，它的功能类似于一个单独的#if/#endif\n\n### #ifndef指令\n\n和#ifdef相反，#ifdef用来确定某一个宏是否没有被定义，如果宏没有被定义，那么就编译#ifndef和#endif中间的内容，否则就跳过。其语法格式如下所示：\n\n```c\n#ifndef 宏名\n    程序段1\n#else\n    程序段2\n#endif\n```\n\n## 案例实现\n\n如果我们打开\"stdio.h\"这个文件，便会发现其开头是这样的两行代码。\n\n```c\n#ifndef _STDIO_H_\n#define _STDIO_H_\n```\n\n在其结尾有这样一行代码：\n\n```c\n#endif /* _STDIO_H_ */\n```\n\n这三行代码是三条预处理指令，也就是为什么写两遍\"#include<stdio.h>\"也不会报错。当然，写更多遍也不会报错。\n\n这三行代码的含义是：如果\"\\_STDIO\\_H\\_\"没有定义过，那么就定义\"\\_STDIO\\_H\\_\"。仔细观察后我们会发现**\"#define \\_STDIO\\_H\\_\"后面什么都没写，其实这也是宏定义的一种写法——并不关注\"\\_STDIO\\_H\\_\"被定义成了什么，只关注他是否被定义过。**\n\n综上分析可知，初次遇到\"\\_STDIO\\_H\\_\"的时候，由于宏\"\\_STDIO\\_H\\_\"尚未定义，因此，#ifndef条件成立，定义\"\\_STDIO\\_H\\_\"。当再次遇到\"\\_STDIO\\_H\\_\"的时候，#ifndef的条件不成立，因此它与\"#endif\"之间的内容就不会被编译了。\n\n## 利用预定义宏得知程序允许到了何处\n\n下面是\\<stdio.h\\>头文件中的五个预定义宏，利用这些宏可以轻松得知程序运行到了何处，有助于编程人员进行程序调试，具体如下表。\n\n| 预定义宏     | 说明                   |\n| ------------ | ---------------------- |\n| \\_DATE\\_     | 定义源文件编译日期的宏 |\n| \\_FILE\\_     | 定义源代码文件名的宏   |\n| \\_LINE\\_     | 定义源代码中行号的宏   |\n| \\_TIME\\_     | 定义源代码编译时间的宏 |\n| \\_FUNCTION\\_ | 定义当前所在函数名的宏 |\n\n","categories":["C"]},{"title":"C语言_链表","url":"/C/C语言_链表入门/","content":"# 单链表\n\n## 不带头\n\n```c\ntypedef int ElemType;\ntypedef struct ListNode\n{\n    ElemType data;\n    struct ListNode* next;\n}ListNode;\ntypedef struct\n{\n\tListNode* first;\n\tint cursize;\n}LinkList;\n//1.初始化\nvoid InitList(LinkList* plist);\n//2.清空链表\nvoid ClearList(LinkList* plist);\n//3.销毁链表\nvoid DestroyList(LinkList* plist);\n//4.获取链表的数据元素的个数\nint GetSize(const LinkList* plist);\n//5.链表判空\nbool IsEmpty(const LinkList* plist);\n//6.在ptr指针之后插入数据元素\nbool Insert_Next(LinkList* plist, ListNode* ptr, ElemType val);\n//7.头插数据元素\nvoid Push_Front(LinkList* plist, ElemType val);\n//8.尾插数据元素\nvoid Push_Back(LinkList* plist, ElemType val);\n//9.删除ptr所指向的后续结点（数据元素）\nbool Erase_Next(LinkList* plist, ListNode* ptr);\n//10.删除第一个数据结点\nvoid Pop_Front(LinkList* plist);\n//11.删除尾部数据节点\nvoid Pop_Back(LinkList* plist);\n//12.删除与val值相等的数据节点\nvoid Remove(LinkList* plist, ElemType val);\n//13.删除与val值相等的所有数据节点\nvoid Remove_All(LinkList* plist, ElemType val);\n//14.打印链表中的数据元素\nvoid PrintList(const LinkList* plist);\n//15.返回与val值相等节点的前驱节点指针\nListNode* FindValue_pre(const LinkList* plist, ElemType val);\n//16.返回与val值相等节点指针\nListNode* FindValue(const LinkList* plist, ElemType val);\n//17.返回pos位置的前驱节点指针\nListNode* FindPos_pre(const LinkList* plist, int pos);\n//18.返回pos位置的节点指针\nListNode* FindPos(const LinkList* plist, int pos);\n```\n\n```c\n//1.初始化\nvoid InitList(LinkList* plist);\n//2.清空链表\nvoid ClearList(LinkList* plist);\n//3.销毁链表\nvoid DestroyList(LinkList* plist);\n//4.获取链表的数据元素的个数\nint GetSize(const LinkList* plist);\n//5.链表判空\nbool IsEmpty(const LinkList* plist);\n//6.在ptr指针之后插入数据元素\nbool Insert_Next(LinkList* plist, ListNode* ptr, ElemType val);\n//7.头插数据元素\nvoid Push_Front(LinkList* plist, ElemType val);\n//8.尾插数据元素\nvoid Push_Back(LinkList* plist, ElemType val);\n//9.删除ptr所指向的后续结点（数据元素）\nbool Erase_Next(LinkList* plist, ListNode* ptr);\n//10.删除第一个数据结点\nvoid Pop_Front(LinkList* plist);\n//11.删除尾部数据节点\nvoid Pop_Back(LinkList* plist);\n//12.删除与val值相等的数据节点\nvoid Remove(LinkList* plist, ElemType val);\n//13.删除与val值相等的所有数据节点\nvoid Remove_All(LinkList* plist, ElemType val);\n//14.打印链表中的数据元素\nvoid PrintList(const LinkList* plist);\n//15.返回与val值相等节点的前驱节点指针\nListNode* FindValue_pre(const LinkList* plist, ElemType val);\n//16.返回与val值相等节点指针\nListNode* FindValue(const LinkList* plist, ElemType val);\n//17.返回pos位置的前驱节点指针\nListNode* FindPos_pre(const LinkList* plist, int pos);\n//18.返回pos位置的节点指针\nListNode* FindPos(const LinkList* plist, int pos);\n```\n\n","tags":["tulun"],"categories":["C","基础数据结构"]},{"title":"C语言_文件入门","url":"/C/C语言_文件入门/","content":"# 本章内容\n\n1. C 语言中的文件是什么？\n2. 流的概念及分类\n3. 文本文件和二进制文件到底有什么区别\n4. C 语言与文件读写\n5. 缓冲和非缓冲文件系统\n6. 文件的顺序读写\n7. 文件的随机读写\n\n重点掌握：第一，FILE，即文件结构体。第二，文件位置指针。\n\n# C 语言中的文件是什么？\n\n　　所谓文件（file）一般指存储在外部介质上数据的集合，比如我们经常使用的txt、bmp、jpg、exe、rmvb 等等。这些文件各有各的用途，我们通常将它们存放在磁盘或者可移动盘等介质中。\n　　文件无非就是一段数据的集合，这些数据可以是有规则的集合，也可以是无序的集合。操作系统也就是以文件为单位对数据进行管理的。也就是说，要访问外部介质上的数据，必须先按照文件名进行查找，然后从该文件中读取数据。要想写数据到外部介质，必须得建立一个文件，然后再写入。因此，你眼前的文件只是数据的集合。\n\n## 三要素：文件路径、文件名、后缀\n\n　　由于在 C 语言中'\\\\'一般是转义字符的起始标志，故在路径中需要用两个'\\\\'表示路径中目录层次的间隔，也可以使用 '/' 作为路径中的分隔符。\n\n　　例如: \"D:\\\\\\\\tulun\\\\\\\\test.c\"或者\"D:/tulun/test.c\"，表示文件 test.c 保存在 D 盘tulun 目录下；\"tu.txt\" 表示当前目录下的文件 tu.txt。\n\n### 文件路径\n\n* **以盘符开头的**，可以显式指出其绝对路径，如上面的”D:\\\\\\\\”或者”D:/”等。\n* 如果没有显式指出其路径，默认为当前路径。也就是相对路径。\n\n　　**数据的输入和输出几乎伴随着每个 C 语言程序，所谓输入就是从“源端”获取数据，所谓输出可以理解为向“终端”写入数据。**这里的源端可以是键盘、鼠标、硬盘、光盘、扫描仪等输入设备，终端可以是显示器、硬盘、打印机等输出设备。在 C 语言中，把这些输入和输出设备也看作“文件”。**要注意，我们所站的角度是执行程序的角度，以执行程序为主讨论输入输出**。\n\n## C 语言文件系统中的类型\n\n* FILE：对象类型，足以保有控制 C I/O 流所需的全部信息\n* fpos_t：非数组完整对象类型，足以唯一指定文件的位置和多字节剖析状态\n\n每个 FILE 对象直接或间接保有下列信息：\n\n1. (C95)字符宽度：未设置、窄或宽。\n2. (C95)多字节与宽字符间转换的分析状态（ mbstate_t 类型对象）\n3. 缓冲状态：无缓冲、行缓冲、全缓冲。\n4. 缓冲区，可为外部的用户提供缓冲区所替换。\n5. I/O 模式：输入、输出或更新（兼具输入与输出）。\n6. 二进制/文本模式指示器。\n7. 文件尾指示器。\n8. 错误状态指示器。\n9. 文件位置指示器，可作为 fpos_t 类型对象访问，对于宽流包含剖析状态。\n10. (C11)在多个线程读、写、寻位或查询流时避免数据竞争的再入锁。\n\n## 预定义标准流\n\n1. stdin 与标准输入流关联的 FILE\\* 类型表达式\n2. stdout 与标准输出流关联的 FILE\\* 类型表达式（有缓冲区）\n3. stderr 与标准错误输出流关联的 FILE\\* 类型表达式（实际上和stdout一样，只不过无缓冲区）\n\n## 宏常量\n\n| 名称         | 描述                                      | 举例                    |\n| ------------ | ----------------------------------------- | ----------------------- |\n| EOF          | int 类型的负值整数常量表达式              | #define EOF (-1)        |\n| FOPEN_MAX    | 能同时打开的文件数                        | #define FOPEN_MAX 20    |\n| FILENAME_MAX | 保有最长受支持文件名所需的 char 数组大小  | define FILENAME_MAX 260 |\n| BUFSIZ       | setbuf() 所用的缓冲区大小                 | #define BUFSIZ 512      |\n| _IOFBF       | 指示全缓冲 I/O 的 setvbuf() 参数          | #define _IOFBF 0x0000   |\n| _IOLBF       | 指示行缓冲 I/O 的 setvbuf() 参数          | #define _IOLBF 0x0040   |\n| _IONBF       | 指示无缓冲 I/O 的 setvbuf() 参数          | #define _IONBF 0x0004   |\n| SEEK_SET     | 指示从文件首开始寻位的 fseek() 参数       | #define SEEK_SET 0      |\n| SEEK_CUR     | 指示从文件当前位置开始寻位的 fseek() 参数 | #define SEEK_CUR 1      |\n| SEEK_END     | 指示从文件尾开始寻位的 fseek() 参数       | #define SEEK_END 2      |\n| TMP_MAX      | tmpnam 所能生成的最大独有文件数           | #define TMP_MAX 32767   |\n| TMP_MAX_S    | tmpnam_s 所能生成的最大独有文件数         |                         |\n| L_tmpnam     | 保有 tmpnam 结果所需的 char 数组大小      |                         |\n| L_tmpnam_s   | 保有 tmpnam_s 结果所需的 char 数组大小    |                         |\n\n# 流的概念及分类\n\n　　I/O 设备的多样性及复杂性，给程序设计者访问这些设备带来了很大的难度和不便。为此，ANSIC 的 I/O 系统即标准 I/O 系统（即“流”），把任意输入的源端或任意输出的终端，都抽象转换成了概念上的“标准 I/O 设备”或称“标准逻辑设备”。\n\n　　流是一种抽象的概念，负责在数据的产生者和数据的使用者之间建立联系，并管理数据的流动。\n\n　　**为什么如此设计：因为程序写出到的外部设备的种类很多，只需要一个统一的接口，使程序绕过具体设备，直接与该“标准逻辑设备”进行交互。**这样就为程序设计者提供了一个不依赖于任何具体 I/O 设备的统一的操作接口，通常把抽象出来的“标准逻辑设备”或“标准文件”称作“流”。**思想：适配器设计方案。**\n　　把任意 I/O 设备，转换成逻辑意义上的标准 I/O 设备或标准文件的过程，并不需要程序设计者感知和处理，是由标准 I/O 系统自动转换完成的。故从这个意义上，可以认为任意输入的源端和任意输出的终端均对应一个“流”。\n\n* 流按**方向**分为：输入流和输出流。从文件获取数据的流称为输入流，向文件输出数据称为输出流。\n* 流按**数据形式**分为：文本流和二进制流。文本流是 ASCII 码字符（0 000 0000\\~0  111 1111即0\\~127）序列，而二进制流是字节序列。从某种意义上来说，文本流是一种特殊的二进制流。\n\n图示：\n\n![image-20210819010628605](../../images/C_%E6%96%87%E4%BB%B6/image-20210819010628605.png)\n\n# 文本文件和二进制文件到底有什么区别\n\nhttps://www.zhihu.com/question/19971994/answer/17256634\n\nhttps://www.zhihu.com/question/24662572/answer/28541822\n\nhttps://zhuanlan.zhihu.com/p/51828216\n\n根据文件中数据的组织形式的不同，可以把文件分为：文本文件和二进制文件。\n\n* 文本文件：把要存储的数据当成一系列字符组成，把每个字符的 ASCII 码值存入文件中。每个 ASCII 码值占一个字节，每个字节表示一个字符。故文本文件也称作字符文件或 ASCII 文件，是字符序列文件。\n* 二进制文件：把数据对应的二进制形式存储到文件中，是字节序列文件。\n\n![image-20210819010658360](../../images/C_%E6%96%87%E4%BB%B6/image-20210819010658360.png)\n\n## 关于字符集的个人总结\n\n理论上，文本文件可以看作特殊的二进制文件。\n\n你比如说，图片和视频都是二进制文件，他们的区别就在于编码与解码的格式不同，比如某种图片以jpg格式打开，某种视频以mp4格式打开。\n\n而文本文件同样可以类比，文本文件实际上就是二进制文件，只不过有好几种文本文件，有不同的编码和解码方式。比如汉字“我”在ASCII码中没有规定，而在GBK字符集的编码为：(CE D2)16，Unicode字符集的UTF-8方式编码为：(62 11)16。所以，不同格式的文本文件用不同的解码方式转换出来的文本就不一样。很容易就导致乱码现象的产生。而Unicode字符集规范了世界上所有地区的语言。\n\nUTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与[ASCII](https://baike.baidu.com/item/ASCII/309296)相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。\n\n# C 语言与文件读写，文件库函数stdio.h\n\n链接： http://www.cplusplus.com/reference/cstdio/\n\nC 语言操作文件分为三步\n\n1. 打开文件\n2. 读写文件\n3. 关闭文件\n\n## 打开文件fopen\n\nFILE \\* fopen ( const char \\* filename, const char \\* mode );\n\n### 函数参数\n\n| 参数名   | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| filename | 文件名，包括路径，如果不显式含有路径，则表示当前路径。例如，“D:\\\\text.txt”表示 D 盘根目录下的文件 text.txt 文件。“tulun.txt”表示当前目录下的文件 tulun.txt |\n| mode     | 文件打开模式，指出对该文件可进行的操作。常见的打开模式如 \"r\" 表示只读，\"w\" 表示只写，\"rw\" 表示读写，\"a\" 表示追加写入。**注意，\" \"代表一个字符串，不是字符。** |\n\n![image-20210819010757148](../../images/C_%E6%96%87%E4%BB%B6/image-20210819010757148.png)\n\n虽然fopen以写方式打开文件时，若文件不存在可以创建新文件后写入，但只是针对存在的目录而言的，如果前面的目录位置不存在，是不会给你创建文件夹的。比如fopen(\"D:/yhp.txt\",\"w\");是可以的。而fopen(\"D:/yhp/yhp.txt\",\"w\");在D:/yhp目录不存在时将无法创建yhp.txt，并且返回空指针。\n\n![image-20210824212604457](../../images/C_%E6%96%87%E4%BB%B6/image-20210824212604457.png)\n\n### 返回值\n\n| 状态     | 返回值                           |\n| -------- | -------------------------------- |\n| 打开成功 | 返回该文件对应的 FILE 类型的指针 |\n| 打开失败 | 返回 NULL                        |\n\n根据返回值表，需定义 FILE 类型的指针变量，保存该函数的返回值。可根据该函数的返回值判断文件打开是否成功。\n\n### 写入文件-代码案例\n\n```c\n#include<stdio.h>\nint main()\n{\n    //第一部分代码-打开文件\n    FILE* fp = NULL;\n    fp = fopen(\"yhping\",\"w\"); //与malloc类似，要从系统里申请文件资源。如果没有申请到，则返回空。\n    if(NULL==fp)\n    {\n        printf(\"file open error\\n\");\n        return 1;\n    }\n    \n    //第二部分代码-定义数据\n    int ar[10]={12,23,34,45,56,67,78,89,90,100};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    \n    //第三部分代码-写数据到文件\n    for(int i= 0;i<n;++i)\n    {\n        //printf(\"%d \",ar[i]);\t\t//默认写到stdout，等效于fprintf(stdout, \"%d \", ar[i]);\n        fprintf(fp, \"%d \", ar[i]);\t//写到fp中，但是只是写到了缓冲区，还没写到磁盘中。内部还要调用itoa函数，把整型转换为字符串（ASCII码串）\n    }\n    \n    //第四部分代码-善后处理\n    fclose(fp);//不仅把文件流对象资源归还系统，还把缓冲区的数据输出到文件中。之后，fp指针就失效了，记得free\n    free(fp);\n    \n    return 0;\n}\n```\n\n注意观察FILE结构体的cnt信息，写了第一个数加一个空格后，cnt由4096减去了3。\n\n![image-20210824203452627](../../images/C_%E6%96%87%E4%BB%B6/image-20210824203452627.png)\n\n两种缓冲区：\n\n1. 全缓冲区——缓冲区满后写到磁盘。\n2. 行缓冲区——遇到\\\\n写到磁盘。\n3. 无缓冲区——不经过缓冲区，直接把文件流写入到磁盘中。\n\n### 读出文件-代码案例\n\n```c\nint main()\n{\n    //1.\n    FILE* fp = fopen(\"yhp.txt\",\"r\");\n    if(NULL==fp)\n    {\n        return 1;\n    }\n    //2.\n    int ar[10]={};\n    \n    //3.\n    for(int i = 0;i<10;++i)\n    {\n        fscanf(fp,\"%d\",&ar[i]);//内部调用atoi(),把字符串转换为整型数据\n    }\n    //4.\n    fclose(fp);\n    fp = nullptr;\n}\n```\n\n注意观察FILE结构体cnt的信息，原本\"12 23 34 45 56 67 78 89 90 100 \"十个数据加上十个空格，不包括'\\\\0'的长度为9\\*2+3+10=31。当我们读出了1个数据后，（没读空格），31减去了2变为了29。\n\n![image-20210824213744839](../../images/C_%E6%96%87%E4%BB%B6/image-20210824213744839.png)\n\n![image-20210824214430960](../../images/C_%E6%96%87%E4%BB%B6/image-20210824214430960.png)\n\n#### 回忆知识\n\n三种scanf：\n\n1. scanf是从标准输入设备读出\n2. sscanf是从输入缓冲区（buff字符串）中读出\n3. fscanf是从指定文件中读出\n\n## 关闭函数fclose\n\nint fclose (FILE \\* stream);\n\n### 函数参数\n\n| 名称  | 描述                   |\n| ----- | ---------------------- |\n| strem | 指向要关闭流对象的指针 |\n\n### 返回值\n\n| 状态         | 返回值      |\n| ------------ | ----------- |\n| 流被成功关闭 | 返回0 值    |\n| 失败         | 返回EOF(-1) |\n\n即使调用失败，作为参数传递的流将不再与文件或其缓冲区关联。\n\n## 字符串格式化函数sprintf\n\nint sprintf (char \\* str, const char \\* format, ... );\n\n### 函数参数\n\n| 参数名 | 描述                                                         |\n| ------ | ------------------------------------------------------------ |\n| str    | 指向缓冲区指针，缓冲区足够大                                 |\n| format | 格式化字符串，该字符串遵循与printf 中的格式相同的规范        |\n| ...    | 附加可变参数。 根据格式化字符串的不同，函数可能需要一系列附加参数，每个参数都包含一个值，用于替换格式字符串中的格式说明符。 |\n\n### 返回值\n\n如果成功，将返回写入的字符总数。此计数不包括自动附加在字符串末尾的额外空字符。失败返回负数。\n\n![image-20210819010851930](../../images/C_%E6%96%87%E4%BB%B6/image-20210819010851930.png)\n\n注意： Windows OS 上的 C 流在输出时将 '\\\\n' 转换为 '\\\\r\\\\n' ，输入时将 '\\\\r\\\\n' 转换为 '\\\\n' 。\n\n## 格式化写入函数\n\nint fprintf ( FILE \\* stream, const char \\* format, ... )；\n\n![image-20210819010921972](../../images/C_%E6%96%87%E4%BB%B6/image-20210819010921972.png)\n\n![image-20210819010941058](../../images/C_%E6%96%87%E4%BB%B6/image-20210819010941058.png)\n\n## 从流中读取格式化数据函数\n\nint fscanf ( FILE \\* stream, const char \\* format, ... );\n\n### 函数参数\n\n| 参数名 | 参数描述                                               |\n| ------ | ------------------------------------------------------ |\n| stream | 指向文件对象的指针，该对象标识要从中读取数据的输入流。 |\n| format | 格式化字符串，该字符串遵循与scanf 中的格式相同的规范。 |\n\n### 返回值\n\n| 状态                                                         | 值                                                           |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| receiving arguments successfully assigned. 传入的参数输入成功，匹配成功。 | Number of receiving arguments successfully assigned. 成功赋值的接收参数的数量 |\n| in case a matching failure occurred before the first receiving argument was assigned. 输入成功，但传入的参数第一次就匹配失败了 | 0                                                            |\n| if input failure occurs before the first receiving argument was assigned | EOF（-1）                                                    |\n![image-20210819011017608](../../images/C_文件/image-20210819011017608.png)\n## 二进制文件的读写\n\n### （字节）块数据写入函数\n\n`size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );`\n\n将内存中数组的内容写到文件中。功能类似于`fprintf`\n\n#### 函数参数\n\n| 参数名 | 参数描述                                                     |\n| ------ | ------------------------------------------------------------ |\n| buffer | 指向将要**被写出**到文件里的元素数组的指针                   |\n| size   | 这是要**被写出到文件里**的每个元素的大小，以字节为单位。     |\n| count  | 这是**要写的**总共的元素个数，每个元素的大小为 size 字节。   |\n| stream | 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流（相对内存而言，输出到文件的流）。 |\n\n#### 返回值\n\n返回成功地被写出的元素的个数，如果出现错误，可能比count小。\n如果传入的参数size 或count 为零，fwrite返回0且不做任何动作。\n\n### 块数据读出函数\n\n`size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );`\n\n#### 函数参数\n\n| 参数名 | 参数描述                                                     |\n| ------ | ------------------------------------------------------------ |\n| buffer | 指向大小至少为（size\\*count）字节的内存块的指针，从流中读出的数据存储到buffer指向的内存。 |\n| size   | 读取元素的大小，unsigned int。                               |\n| count  | 被读取元素的个数                                             |\n| stream | 是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流（相对内存而言的，从外部的文件输入到内存中）。 |\n\n#### 返回值\n\n返回成功被读取的元素个数count，若出现错误或到达文件末尾，则可能小于count。\n如果传入的参数size 或count 为零，fread返回0且不做任何动作。\nfread 不区分文件尾和错误，因此调用者必须用feof 和ferror 才能判断发生了什么。\n\n### 二进制方式-代码案例\n\n注意，不仅要打开时按照wb打开，还要把读写函数改为fwrite和fread\n\n```c\n#include<stdio.h>\nint main()\n{\n    int ar[10]={12,23,34,45,56,67,78,89,90,100};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    FILE* fp = NULL;\n    fp = fopen(\"yhpBin.txt\",\"wb\"); //与malloc类似，要从系统里申请文件资源。如果没有申请到，则返回空。\n    if(NULL==fp)\n    {\n        printf(\"file open error\\n\");\n        return 1;\n    }\n    \n    fwrite(ar,sizeof(int),n,fp);\t//专门写入二进制文件\n    \n    fclose(fp);//不仅把文件流对象资源归还系统，还把缓冲区的数据输出到文件中。之后，fp指针就失效了，记得free\n    free(fp);\n    \n    return 0;\n}\n//通过记事本打开文件，发现显示的是：□ □ - 8 C N Y Z d 。通过观察，发现正好对应于各自的ASCII码值\"\\12 \\23 \\34 \\45 \\56 \\67 \\78 \\89 \\90 \\100 \"\n```\n\n因为我们是用记事本打开的（系统自动解析为UTF-8编码），**系统对这些数据的处理是按照ASCII码处理的**。所以出现了以下的情况！\n\n![image-20210824221223042](../../images/C_%E6%96%87%E4%BB%B6/image-20210824221223042.png)\n\n![image-20210824221905601](../../images/C_%E6%96%87%E4%BB%B6/image-20210824221905601.png)\n\n每个int型数据占据了4字节。我们输入的数据都没有用到第二个字节，则正好限制在了0~127这个ASCII码区间内，12和23表示控制符，显示不出来，故显示为□。剩下的00通过文本格式解码变成了空格。\n\n![image-20210824221601975](../../images/C_%E6%96%87%E4%BB%B6/image-20210824221601975.png)\n\n```c\nint main()\n{\n    int ar[10]={};\n    FILE* fp = fopen(\"yhpBin.txt\",\"rb\");\n    if(NULL==fp)\n    {\n        return 1;\n    }\n    \n    fread(ar,sizeof(int),n,fp);//从fp读出数据到ar数组中\n    \n    fclose(fp);\n    fp = nullptr;\n}\n```\n\n### 总结\n\n二进制读写（fwrite和fread）是按着把数据“本该在内存中的样子”原封不动地存入到文件中。\n\n# 缓冲和非缓冲文件系统\n\n在ANSI C 标准中，使用的是“缓冲文件系统”。\n\n所谓缓冲文件系统指系统自动地在内存为每一个正在使用的文件名开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存中的缓冲区，装满后再一起送到磁盘去。反向也是如此。\n\n## vs2012中的FILE 结构体\n\n![image-20210819011136329](../../images/C_%E6%96%87%E4%BB%B6/image-20210819011136329.png)\n\n## 写数据\n\n![image-20210819011222800](../../images/C_%E6%96%87%E4%BB%B6/image-20210819011222800.png)\n\n## 读数据\n\n![image-20210819011232955](../../images/C_%E6%96%87%E4%BB%B6/image-20210819011232955.png)\n## fflush\n```cpp\nint fflush( FILE *stream);\n```\n### 功能\n\n清除读写缓冲区，在需要立即把输出缓冲区的数据进行物理写入时。\n### 函数说明\n\n如果指针指向一个输出流或者是一个最近的一次操作不是输入的更新流，输出刷新将会创造任意未写入的数据给将要被写入文件的流和最近的数据被修改流，并且最后的文件状态改变应该被标记为更新的基础文件的时间戳。\n对于打开以使用基础文件描述进行读取的流，如果文件尚未处于EOF，并且该文件是能够搜索的文件，则基础打开文件描述的文件偏移量应设置为流的文件位置，并且任何未被从流中读取的`ungetc（）`或`ungetwc（）`推回到流上的字符都将被丢弃（不再进一步改变文件偏移量）。\n如果stream 是空指针，则fflush()将对上面定义了行为的所有流执行此刷新操作。\n\n### 返回值\n\n如果成功刷新，fflush 返回0。指定的流没有缓冲区或者只读打开时也返回0 值。返回EOF 指出一个错误。\n\n### 注意\n\n如果fflush 返回EOF,数据可能由于写错误已经丢失。当设置一个重要错误处理器时,最安全的是用setvbuf函数关闭缓冲或者使用低级IO例程,如open、close 和write 来代替流I/O 函数。\n\n### 其他用法\n\n`fflush(stdin)`刷新标准输入缓冲区，把输入缓冲区里的东西丢弃[非标准]\n`fflush(stdout)`刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上\n\n### 注意事项\n\nC 和`C++`的标准里从来没有定义过`fflush(stdin)`。也许有人会说：“可是我用`flush(stdin)`解决了这个问题，你怎么能说是错的呢？”的确，某些编译器（如VC6）支持用 `fflush(stdin)`来清空输入缓冲，但是并非所有编译器都支持这个功能（linux 下的gcc 就不支持），因为标准中根本没有定义`fflush(stdin)`。MSDN 文档里也清楚地写着：fflush on input stream is an extension to the C standard （fflush 操作输入流是对C 标准的扩充）。\n以下是 C99 对 fflush 函数的定义：\n`int fflush(FILE *stream);`\n如果stream 指向输出流或者更新流（update stream），并且这个更新流最近执行的操作不是输入，那么fflush函数将把任何未被写入的数据写入stream 指向的文件（如标准输出文件stdout）。否则，fflush 函数的行为是不确定的。`fflush（NULL）`清空所有输出流和上面提到的更新流。如果发生写错误，flush 函数会给那些流打上错误标记，并且返回EOF，否则返回0。\n由此可知，如果 stream 指向输入流（如 stdin），那么 fflush 函数的行为是不确定的。故而使用`fflush(stdin)`是不正确的。\n\n## setbuf\n```cpp\nvoid setbuf( FILE *stream, char *buffer );\n```\n### 功能\n\n设置用于流操作的内部缓冲区。其长度至少应该为 BUFSIZ 个字符。\n若 buffer 非空，则等价于`setvbuf(stream, buffer, _IOFBF, BUFSIZ)`\n若 buffer 为空，则等价于`setvbuf(stream, NULL, _IONBF, 0)`，这会关闭缓冲。\n\n### 参数\n\nstream :要设置缓冲区的文件流\nbuffer:指向文件流所用的缓冲区的指针。若提供空指针，则关闭缓冲。\n\n### 返回值\n\n无\n\n### 注解\n\n若 BUFSIZ 不是适合的缓冲区大小，则能用 setvbuf 更改它。\nsetvbuf 亦应当用于检测错误，因为 setbuf 不指示成功或失败。\n此函数仅可在已将 stream 关联到打开的文件后，但要在任何其他操作（除了对 setbuf/setvbuf 的失败调用）前使用。\n\n一个常见错误是设置 stdin 或 stdout 的缓冲区为生存期在程序终止前结束的数组：\n\n```c\nint main(void) {\nchar buf[BUFSIZ];\nsetbuf(stdin, buf);\n} // buf 的生存期结束，未定义行为\n```\n\n示例\n\n```c\nint main()\n{\n\tchar buff[256];\n\tint a = 10, b = 20;\n\tFILE *pf = fopen(\"yhp.txt\",\"w\");\n\tsetbuf(pf,buff);\n\tfprintf(pf,\"a = %d b = %d \\n\",a,b);\n\tfclose(pf);\n\tpf = NULL;\n\treturn 0;\n}\n```\n\n## setvbuf\n```cpp\nint setvbuf( FILE * stream, char * buffer, int mode, size_t size );\n```\n以 mode 所指示值更改给定文件流 stream 的缓冲模式。另外，\n▪ 若 buffer 为空指针，则重设内部缓冲区大小为 size 。\n▪ 若 buffer 不是空指针，则指示流使用始于 buffer 而大小为 size 的用户提供缓冲区。必须在 buffer 所指向的数组的生存期结束前（用 fclose ）关闭流。成功调用 setvbuf 后，数组内容不确定，而任何使用它的尝试是未定义行为。\n### 参数\n\nstream：要设置缓冲的文件流\nbuffer：指向要使用的流缓冲区的指针，或若仅更改大小和模式则为空指针\nmode：使用的缓冲模式。它能是下列值之一：\n\n1. \\_IOFBF: 全缓冲，当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数据。\n2. \\_IOLBF: 行缓冲，每次从流中读入一行数据或向流中写入一行数据。\n3. \\_IONBF: 无缓冲，直接从流中读入数据或直接向流中写入数据，缓冲设置无效。\n\nsize：缓冲区的大小\n\n### 返回值\n\n成功时为0，失败时为非零。\n\n### 注意\n\n此函数仅可在已将 stream 关联到打开的文件后，但要在任何其他操作（除了对 setbuf/setvbuf 的失败调用）前使用。不是所有 size 字节都需要用于缓冲：实际缓冲区大小通常向下取整到 2 的倍数、页面大小的倍数等。\n多数实现上，行缓冲仅对终端输入流可用。\n一个常见错误是设置 stdin 或 stdout 的缓冲区为生存期在程序终止前结束的数组：\n\n```c\nint main(void) {\nchar buf[BUFSIZ];\nsetbuf(stdin, buf);\n} // buf 的生存期结束，未定义行为\n```\n\n期待默认缓冲区大小 BUFSIZ 为实现上文件 I/O 的最高效缓冲区大小，但 POSIX fstat 经常提供更好的估计。\n\n# 文件位置\n\n| 函数名  | 描述                                   |\n| ------- | -------------------------------------- |\n| ftell   | 返回当前的文件位置指示值               |\n| fgetpos | 获取文件位置指示器                     |\n| fseek   | 将文件位置指示符移动到文件中的指定位置 |\n| fsetpos | 将文件位置指示器移动到文件中的指定位置 |\n| rewind  | 将文件位置指示器移动到文件首           |\n\n## 当前的文件位置\n```cpp\nlong ftell(FILE *stream);\n```\n\n注：long占四个字节，范围为`-2^31~2^31-1`。实际上和int一样。因为int当年有时是占两个字节，所以出现了long。而后来int也变为4了，long没变。\n\n返回stream的**文件位置指示值**。\n若流以二进制模式打开，则由此函数获得的值是从文件开始的字节数。\n若流以文本模式打开，则由此函数返回的值未指定，且仅作为 `fseek()` 的输入才有意义。\n\n### 参数\n\nstream：要检验的文件流\n\n### 返回值\n\n成功时为文件位置指示器，若失败发生则为 `-1L` 。失败时，设 errno 对象为实现定义的正值。\n\n```c\nint main()\n{\n    int ar[]={12,23,34,45,56,67,78,89,90,100};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    FILE* pf = NULL;\n    //pfa = fopen(\"yhp.txt\",\"w\");//VS2019中不能运行\n    erron_t tag = fopen_s(&pf,\"yhp.txt\",\"w\");//此时pfa指针就指向了系统产生的一个文件流对象。那么对文件流对象的操作就可以间接操作磁盘中的数据。文件流对象内部包含缓冲区。//\"a\"代表追加写入，并且找不到文件时主动创建。\n    if(NULL==pfa)\n    {\n        printf(\"open file error: %d\\n\",tag);\n        exit(EXIT_FAILURE);\n    }\n    \n    long pos;\n    for(int i=0;i<n;++i)\n    {\n        pos = ftell(pf);\n        printf(\"%d \",pos);\n        fprintf(pf,\"%5d\",ar[i]);\n        //pos从0开始，每次调用一次fprintf后pos都会加5\n        //即屏幕输出0 5 10 15 20 ...\n    }\n    fclose(pf);\n    pfa = NULL;\n    return 0;\n}\n```\n\n## fgetpos\n```cpp\nint fgetpos(FILE * stream, fpos_t * pos );\n```\n\n注：`fpos_t`是`__int`类型，即64位整型。在32位机中，用这种表示64位整型数据，而在C99后新增了long long类型，实际上和`__int`一样。只是不同编译器环境下效果不同。\n关于C语言中long long与`__int64`的区别：http://c.biancheng.net/cpp/html/2975.html\n\n获得文件流 stream 的文件位置指示器和当前分析状态（若存在），并将它们存储于 pos 所指向的对象。存储的值仅在作为 fsetpos 的输入的情况有意义。\n\n### 参数\n\nstream 要检验的文件流\npos 指向要存储文件位置指示器到的 fpos_t 对象的指针\n\n### 返回值\n\n成功时为0，否则非零值。\n\n```c\nint main()\n{\n    int ar[]={12,23,34,45,56,67,78,89,90,100};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    FILE* pf = NULL;\n    //pfa = fopen(\"yhp.txt\",\"w\");//VS2019中不能运行\n    erron_t tag = fopen_s(&pf,\"yhp.txt\",\"a\");//此时pfa指针就指向了系统产生的一个文件流对象。那么对文件流对象的操作就可以间接操作磁盘中的数据。文件流对象内部包含缓冲区。//\"a\"代表追加写入，并且找不到文件时主动创建。\n    if(NULL==pf)\n    {\n        printf(\"open file error: %d\\n\",tag);\n        exit(EXIT_FAILURE);\n    }\n    \n    fpos_t pos; //64位整型\n    \n    for(int i=0;i<n;++i)\n    {\n        pos = ftell(pf);\n        fgetpos(pf,&pos)\n        printf(\"%d \",pos);\n        fprintf(pf,\"%d \",ar[i]);\n        //pos从0开始，每次pos都会加若干值\n        //即屏幕输出0 5 10 15 20 ...\n    }\n    fclose(pf);\n    pfa = NULL;\n    return 0;\n}\n```\n\n## ⭐文件位置指针移动fseek\n```cpp\nint fseek(FILE *stream, long offset, int origin);\n```\n\n设置文件流 stream 的文件位置指示器为 offset 所指向的值。\n\n1. 若 stream 以二进制模式打开，则新位置准确地是文件起始后（若 origin 为 `SEEK_SET` ）或当前文件位置后（若 origin 为 `SEEK_CUR` ），或文件结尾后（若 origin 为 `SEEK_END` ）的 offset 字节。不要求二进制流支持 `SEEK_END` ，尤其是是否输出附加的空字节。\n2. 若 stream 以文本模式打开，则仅有的受支持 offset 值为零（可用于任何 origin ）和先前在关联到同一个文件的流上对 ftell 的调用的返回值（仅可用于 SEEK_SET 的 origin ）。\n3. 若 stream 为宽面向，则一同应用对文本和二进制流的限制（允许 ftell 的结果与 `SEEK_SET` 一同使用，并允许零 offset 以 `SEEK_SET` 和 `SEEK_CUR` 但非 `SEEK_END` 为基准）。除了更改文件位置指示器， fseek 还撤销 ungetc 的效果并清除文件尾状态，若可应用。\n若发生读或写错误，则设置流的错误指示器（ ferror ）而不影响文件位置。\n\n### 参数\n\nstream：要修改的文件流\noffset：相对 origin 迁移的字符数\norigin：offset 所加上的位置。它能拥有下列值之一： `SEEK_SET`（从起始位置开始移动）、 `SEEK_CUR`（当前位置）、 `SEEK_END`（末尾位置）\n\n### 返回值\n\n成功时为 0 ，否则为非零。\n\n### 举例\n\n比如我们调用了`fseek(pf, 2, SEEK_CUR);`那么，文件位置指针将会从当前位置（`SEEK_CUR`）向后偏移2字节。假如调用前文件位置指针指向4位置，那么调用后文件位置指针将指向6。\n\n相应地，`SEEK_SET`是从0位置开始移动的。`SEEK_END`是从文件末尾开始移动的。如果我们调用`fseek(pf, 0, SEEK_END);`，那么我们将使文件位置指针指向文件末尾。\n\n![image-20210825205704520](../../images/C_%E6%96%87%E4%BB%B6/image-20210825205704520.png)\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    FILE* pf = NULL;\n    errno_t tag = fopen_s(&pf, \"Test8_25.cpp\", \"rb\");\n    if (NULL == pf)\n    {\n        printf(\"file open error: %d\\n\", tag);\n        exit(1);\n    }\n\n    fseek(pf, 0, SEEK_END);//为了可以获取文件的长度，我们要调用fseek实现了文件位置指针指向文件末尾\n    //fseek(pfs, 1, SET_END);//文件位置指针指向了文件末尾前一个，不是后一个\n    int len = ftell(pf);\n    printf(\"%d \\n\", len);\n\n    fseek(pf, 0, SEEK_SET);//现在为了要从头输出文件内容，我们需要将文件位置指针指向文件开头。\n    //也可以使用rewind(pf);\n    char ch;\n    for (int i = 0;i < len;++i)\n    {\n        fscanf_s(pf,\"%c\", &ch,1);\n        printf(\"%c\", ch);\n    }\n    fclose(pf);\n    pf = NULL;\n    return 0;\n}\n```\n### 棘手的问题\n\n如果我们执行上述程序。会发现，打印出来的最后一个字符会重复多次打印。\n\n![image-20210825213347468](../../images/C_%E6%96%87%E4%BB%B6/image-20210825213347468.png)\n\n我们在scanf语句执行一次后进行对变量的监视，发现文件结构体中的成员的信息有所端倪：\n\n![image-20210825214922278](../../images/C_%E6%96%87%E4%BB%B6/image-20210825214922278.png)\n\n我们计算求得的len值是760。此处的`_cnt`表示还未读入的剩余字节数，为731个左右。也就是说，他实际最多可读的有效数据是731左右个字节，但我们却输出了760个字节。这显然会出错的。\n\n那么，`_cnt`和`len`为何有差异？\n\n此时就要谈论到二进制打开和文本格式打开的差异了！\n\n我们这里的文件在VS2019中的编辑器编写的，右下角的编辑方式默认为“CRLF”，即我们按下键盘的“enter”键时，相当于在文件中存放了0D 0A两个控制符，即回车+换行。\n\n![image-20210825222544799](../../images/C_%E6%96%87%E4%BB%B6/image-20210825222544799.png)\n\n分析了实际保存的内容后。再分析：我们上面的程序是r方式打开的，即文本方式打开。文本方式打开，对于fscanf函数来说，“0D 0A”只识别“0A”即换行符，忽略“0D”即回车符。这是文本文件的特殊之处。但！虽然是文本格式打开的，而对于fseek函数和ftell而言一视同仁，都看作是二进制文件，把0D也算了进去。所以，len比`_cnt`多了29个字节（刚刚好和程序代码的行数一样，所以这不是巧合）。\n\n**所以，文本文件是一种特殊的二进制文件，在有些环境下，如果以文本方式打开文件，解码器将会自动处理其中的某些数据，比如把0D0A中的0D去掉！**\n\n经过调试，fscanf读取了731个字节之后，fscanf就不会再读入有效数据给ch了，因此ch的值不会改变，将会定格在文件的最后一个字符。操蛋的地方就在于`fscanf_s`函数也没给我们报错，偷偷地将其结构体中成员`_ptr`指向了文件的开头，即`_base`的值。\n\n![image-20210825222217114](../../images/C_%E6%96%87%E4%BB%B6/image-20210825222217114.png)\n\n分析至此，因为ch的值没有变化，依旧是`}`，而循环仍在继续，所以打印了文本文件的行数的个数的`}`！\n\n因此，经过上述分析后，我们解决方案有两个。\n\n一是以“rb”方式打开文本文件。\n\n二是用pf结构体中的实际剩余读入数目值来代替len。\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    FILE* pf = NULL;\n    errno_t tag = fopen_s(&pf, \"Test8_25.cpp\", \"rb\");\n    if (NULL == pf)\n    {\n        printf(\"file open error: %d\\n\", tag);\n        exit(1);\n    }\n\n    fseek(pf, 0, SEEK_END);//为了可以获取文件的长度，我们要调用fseek实现了文件位置指针指向文件末尾\n    //fseek(pfs, 1, SET_END);//文件位置指针指向了文件末尾前一个，不是后一个\n    fseek(pf, 0, SEEK_SET);//现在为了要从头输出文件内容，我们需要将文件位置指针指向文件开头。\n    \n    \n    char ch;\n    fscanf_s(pf,\"%c\",&ch);\n    int len = pf->_cnt;\t//改为实际的剩余要读的数目\n    for (int i = 0;i < len;++i)\n    {\n        fscanf_s(pf,\"%c\", &ch,1);\n        printf(\"%c\", ch);\n    }\n    fclose(pf);\n    pf = NULL;\n    return 0;\n}\n```\n\n### 二进制文件的案例\n\n```c\nint main()\n{\n    const int n = 10;\n    int ar[n] = {0,1,2,3,4,5,6,7,8,9};\n    FILE* pf = NULL;\n    errno_t tag = fopen_s(&pf,\"TestBin.txt\",\"wb\");\n    if(NULL==pf)\n    {\n        exit(1);\n    }\n    fwrite(ar,sizeof(int),n,pf);\n    fclose(pf);\n    pf=nullptr;\n    ////////////////\n    tag = fopen_s(&pf,\"TestBin.txt\".\"rb\");\n    if(NULL=pf)\n    {\n        exit(1);\n    }\n    int val;\n    int pos;\n    while(1)\n    {\n        scanf_s(\"%d\",&pos);\n        if(pos<0)break;\n        fseek(pf,pos,SEEK_SET);//偏移pos个字节\n        fread(&val,sizeof(int),1,pf);//参数意义：读出到哪个变量，一次读多少字节，一次读几个，从哪个文件读\n        printf(\"%d \\n\",val);\n    }\n    fclose(pf);\n    pf=nullptr;\n    return 0;\n}\n```\n\n**故意留坑**：这个程序原本的意思想要达到“文件中存储了数据`‘0 1 2 3 4 5 6 7 8 9’`，我们输入`0`，就输出文件中偏移0位置的整型值0；输入1，本应该输出文件中偏移1位置的整型值1”。但是，运行测试发现输入1程序输出的是16777216。\n\n![image-20210825225705167](../../images/C_%E6%96%87%E4%BB%B6/image-20210825225705167.png)\n\n通过对这个数的观察，转为16进制我们发现他是“0100 0000”。\n\n已经有些端倪了，那就是“`fseek(pf,pos,SEEK_SET);//偏移pos个字节`”这里出错了。正确的写法应该是`fseek(pf,pos*(sizeof(int) )  ),SEEK_SET);//偏移4*pos个字节`，因为int型占4字节。\n\n那么我们分析一下，为何只偏移1个字节时会打印16777216?\n\n因为前四个字节存的是“00 00 00 00”，之后是“01 00 00 00”。我们只偏移了一个字节，读取的是“00 00 00 01”！然而！我们还要清醒的是！我们在内存中默认下的状态是小端存放数据，因此01是高位！人类的读数据顺序应该是“01 00 00 00”，因此算下来是16777216！到此，我只有一句感慨，那就是计算机中处处都是坑啊！都是基础知识点的体现！\n\n![image-20210825230416632](../../images/C_%E6%96%87%E4%BB%B6/image-20210825230416632.png)\n\n因此，改正以下语句。程序才能达到预期的效果。\n\n```c\nfseek(pf,pos*sizeof(int),SEEK_SET);//偏移(pos*int大小)个字节\n```\n\n### 总结\n\n文件定位指针函数如fseek、ftell对二进制文件是最合适的。\n\nscanf对文本文件操作更合适。\n\n因此，不要拿scanf去读取fseek、ftell操作过的文件。\n\n## fsetpos\n```cpp\nint fsetpos( FILE *stream, const fpos_t *pos );\n```\n按照 pos 所指向的值，设置文件流 stream 的文件位置指示器和多字节分析状态（若存在）。\n除了建立新的分析状态和位置，调用此函数还会撤销 ungetc 的效果，并若设置了文件尾状态则清除之。\n若读或写出现错误，则设置流的错误指示器（ ferror ）。\n参数\nstream 要修改的文件流\npos 指向 fpos_t 对象的指针，用作文件位置指示器的新值\n返回值\n成功时为 0 ，否则为非零值。\n## rewind\n```cpp\nvoid rewind( FILE *stream );\n```\n移动文件位置指示器到给定文件流的起始。函数等价于 fseek(stream, 0, SEEK_SET); ，除了它清除文件尾和错误\n指示器。\n此函数丢弃任何来自先前对 ungetc 调用的效果。\n参数\nstream 要修改的文件流\n返回值（无）\n\n# 错误处理\n\n| 函数名   | 函数功能                         |\n| -------- | -------------------------------- |\n| clearerr | 清楚错误                         |\n| feof     | 检查文件结尾                     |\n| ferror   | 检查文件错误                     |\n| perror   | 显示对应当前错误的字符串到stderr |\n\n## clearerr\n```cpp\nvoid clearerr( FILE *stream );\n```\n重置给定文件流的错误标志和 EOF 指示器。\n\n### 参数\n\nstream： 要重置错误标志的文件流\n\n### 返回值\n\n无\n\n## ⭐feof\n```cpp\nint feof( FILE *stream );\n\n```\n检查是否已抵达给定文件流的结尾。\n\n### 参数\n\nstream 要检验的文件流\n\n### 返回值\n\n若已抵达流尾则为非零值，否则（未抵达）为 0\n\n### 注意\n\n此函数仅报告最近一次 I/O 操作所报告的流状态，而不检验关联的数据源。例如，若最近一次 I/O 是抵达文件最\n后字节的 fgetc ，则 feof 返回零。下个 fgetc 失败并更改流状态为文件尾。然后 feof 才返回非零。\n典型用法中，输入流处理在任何错误时停止；而 feof 和 ferror 用于区别不同错误条件。\n\n```c\n//本文件名为FileTest.cpp\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    char ch;\n    FILE* pf = nullptr;\n    errno_t tag = fopen_s(&pf,\"FileTest.cpp\",\"r\");\n    if(nullptr==pf)\n    {\n        exit(1);\n    }\n    while(!feof(pf))//未抵达末尾\n    {\n        ch = fgetc(pf);\n        printf(\"%c\",ch);\n    }\n    fclose(pf);\n    pf = nullptr;\n    return 0;\n}\n```\n\n怎么达到模拟缓慢打字的效果\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<Windows.h>\nint main()\n{\n    char ch;\n    FILE* pf = nullptr;\n    errno_t tag = fopen_s(&pf, \"Test8_25.cpp\", \"rb\");\n    if (nullptr == pf)\n    {\n        exit(1);\n    }\n    while (!feof(pf))//未抵达末尾\n    {\n        ch = fgetc(pf);\n        printf(\"%c\", ch);\n        Sleep(50);\n    }\n    fclose(pf);\n    pf = nullptr;\n    return 0;\n}\n```\n\n如果想让这个速度更快一些，我们可以采取“缓存区”思想，每次存20个，打印20个。 可以提高打印效率\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<Windows.h>\nint main()\n{\n    //char ch;\n    char str[20];\n    FILE* pf = nullptr;\n    errno_t tag = fopen_s(&pf, \"Test8_25.cpp\", \"rb\");\n    if (nullptr == pf)\n    {\n        exit(1);\n    }\n    while (!feof(pf))//未抵达末尾\n    {\n        fgets(str,20,pf);\n        //puts(str);//printf(\"%s\\n\",str);\n        printf(\"%s\", str);\n        Sleep(1);\n    }\n    fclose(pf);\n    pf = nullptr;\n    return 0;\n}\n```\n\n## ferror\n```cpp\nint ferror( FILE *stream );\n\n```\n检查给定文件流的错误。\n\n### 参数\n\nstream 要检查的文件流\n\n### 返回值\n\n若文件流已出现错误则为非零值，否则为 0\n\n## perror\n```cpp\nvoid perror( const char *s );\n\n```\n打印当前存储于系统变量 errno 的错误码到 stderr 。\n\n通过连接下列组分构成描述：\n* s 所指向的空终止字节字符串的内容后随 \": \" （除非 s 为空指针或 s 所指向字符为空字符）实现定义的，描述存储于 errno 的错误码的错误消息字符串后随`'\\n'`。\n* 错误消息字符串等同于 `strerror(errno)` 的结果。\n### 参数\n\ns 指向带解释消息的空终止字符串的指针\n### 返回值\n\n无\n\n# 文件操作\n\n| 函数名    | 描述                   |\n| --------- | ---------------------- |\n| remove    | 删除文件               |\n| rename    | 重命名文件             |\n| tmpfile   | 返回指向临时文件的指针 |\n| tmpfile_s | （c11）                |\n\n## remove\n```cpp\nint remove( const char *fname );\n\n```\n删除 fname 所指向的字符串所标识的文件。若文件为当前进程或另一进程打开，则此函数行为是实现定义的。具体而言， POSIX 系统解链接文件名，到最后一个运行的进程关闭该文件为止，即使这是最后一个到文件的硬链接也不回收文件系统空间。 Windows 不允许删除该文件。\n\n### 参数\n\nfname 指向空终止字符串的指针，字符串含标识待删除文件的路径\n\n### 返回值\n\n成功时为0，错误时为非零值。\n\n### 注意\n\nPOSIX 指定此函数行为的许多额外细节。\n\n## rename\n```cpp\nint rename( const char *old_filename, const char *new_filename );\n```\n更改文件的文件名。该文件以 old_filename 所指向的字符串标识。新文件名以 `new_filename` 所指向的字符串标识。若 `new_filename` 存在，则行为是实现定义的。\n\n### 参数\n\n`old_filename` 指向包含标识要重命名的文件的路径的空终止字符串的指针\n`new_filename` 指向包含文件新路径的空终止字符串的指针\n\n### 返回值\n\n成功时为0，失败时为非零值。\n\n# 无格式输入/输出\n\n这里的无格式的意思是，对二进制文件和文本文件都通用。无论是什么文件，都会一个字节一个字节地读出。\n\n就比如putchar函数，当我们输入了一个“烫”时，getchar却被调用了两次。而且在第一个putchar断点时，输不出烫，运行完第二个putchar时，才出现“烫”。证明此类`get/put`读写函数是针对字节而言的，而不是官方文档中针对“字符”操作。\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    char* pch = (char*)calloc(1,3);\n    for(int i = 0;i<2;++i)\n    {\n        pch[i] = getchar();\n    }\n    getchar();//消除回车\n\tputchar(pch[0]);\n\tputchar(pch[1]);\n    return 0;\n}\n```\n\n比如`getchar()`，通过调试，我们发现：\n\n```c\nint main()\n{\n    char test = getchar();\n    printf(\"%d\\n\",test);\n    test = getchar();\n    printf(\"%d\\n\",test);\n}\n```\n\n程序让你输入时，你按住Alt键+小键盘的10，意思是将10转换为一个ASCII码字符，10表示换行，这时控制台的输入指示标志挪到了下一行，但是屏幕上没有输出“10”。说明getchar对ASCII码为10对应的换行符不敏感。\n\n重新进入程序，第一次输入，按住Alt键+小键盘的13（仅仅进行此操作，没有另外按enter键），意思是将13转换为一个ASCII码字符，13表示回车，这时控制台立马在下一行显示了“10”字样。这说明，我们在控制台输入一个“ASCII码为13对应的回车符”时，getchar对回车符敏感，仿佛是把回车符变成了换行符。这时，我们可以猜测，系统对标准输入设备的回车操作视为某一阶段的输入完成，可以开始推流，并且最后加了一个换行符。**以前我们以为换行符才是控制输入结束的标志，现在看来，回车符才是！**\n\n![image-20210826175900462](../../images/C_%E6%96%87%E4%BB%B6/image-20210826175900462.png)\n\n接着测试，重新进入程序。我们第一次输入，按住ALT键+10，控制台的输入标志切到了下一行，没有输出数据。第二次输入，按住ALT键+13，按完后，没有其他操作，控制台输出了两行10。进一步证明了换行符10不是控制输入结束的标志，而是回车符13。\n\n![image-20210826180447679](../../images/C_%E6%96%87%E4%BB%B6/image-20210826180447679.png)\n\n然后，我们在VS2019编辑器中创建了一个txt文件，以文本格式编辑时，右下角有`CRLF/LF/CR`三种模式可以切换，当你选择了其中的一种模式，那么你键盘上的enter键就对应着什么意思。比如，若我们选择了LF模式（enter为换行），那么按一下enter键就意味着给文件输入了一个“0A”；若我们选择了CR模式（enter为回车），那么按一下enter键就意味着给文件输入了一个“0D”；若我们选择了CRLF模式（enter为回车+换行），那么按一下enter键就意味着给文件输入了一个“0D 0A”；\n\n那么，我们可以推断，为什么我们在输入时，打一个回车会结束输入呢？关键在于控制台收到了“阶段结束标志”，这个标志很有可能是回车符0D，因为我们的程序经验表明，按下enter键时，不但结束了输入，而且缓冲区中多了换行符，因此给很多输入的控制带来了干扰，比如菜单选择的程序中，如果不注意消除缓冲区的换行符，那么用户在没有输入下一个字符时，缓冲区中的换行符就偷偷地替代了用户的输入工作，造成输入干扰。这意味着我们的控制台把换行符0A看作是一个可以实际输入的字符，而不是当作一个结束输入的标志。由此可以推断，我们在Windows控制台的enter键实际上默认是CRLF模式。即：既告诉控制台我们结束了输入，又给你打了个换行符。\n\n最后，对于以下程序，我们再归纳一下0D0A的坑：\n\n```c\n//本文件名为Test8_25.cpp\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    FILE* pf = NULL;\n    errno_t tag = fopen_s(&pf, \"Test8_25.cpp\", \"rb\");\n    if (NULL == pf)\n    {\n        printf(\"file open error: %d\\n\", tag);\n        exit(1);\n    }\n\n    fseek(pf, 0, SEEK_END);//为了可以获取文件的长度，我们要调用fseek实现了文件位置指针指向文件末尾\n    //fseek(pfs, 1, SET_END);//文件位置指针指向了文件末尾前一个，不是后一个\n    int len = ftell(pf);\n    printf(\"%d \\n\", len);\n\n    fseek(pf, 0, SEEK_SET);//现在为了要从头输出文件内容，我们需要将文件位置指针指向文件开头。\n    //也可以使用rewind(pf);\n    char ch;\n    for (int i = 0;i < len;++i)\n    {\n        fscanf_s(pf,\"%c\", &ch,1);\n        printf(\"%c\", ch);\n    }\n    fclose(pf);\n    pf = NULL;\n    return 0;\n}\n```\n\n* rb打开文本文件时，对于0D0A的处理等同于用户原先在编辑此文本文件选择的enter模式。\n* fread读取rb打开的文本文件时，对于0D0A的处理等同于用户原先在编辑此文本文件选择的enter模式。\n* scanf读取r模式打开的文本文件时，对于0D0A的处理只读取了0A，把0D去除了。这说明r模式下的enter模式很有可能是LF模式；scanf读取rb模式打开的文本文件时，对于0D0A的处理等同于用户原先在编辑此文本文件选择的enter模式，也就是说，如果用户是CRLF编辑的，那么读入的数据0D0A都包含。\n* **综上三个现象，说明：对于0D0A的处理方式，取决于你打开文件的方式。最好以rb方式打开，原样呈现。不建议以r打开（即文本模式），因为会使源文件的真实数据丢失，比如原本的0D0A，抛弃了0D。**\n\n| 函数名     | 描述                    |\n| ---------- | ----------------------- |\n| fgetc/getc | 从文件流获取一个字节    |\n| fgets      | 从文件流获取一个字节串  |\n| fputc/putc | 将一个字节写入文件流    |\n| fputs      | 将一个字节串写入文件流  |\n| getchar    | 从 stdin 读取一个字节   |\n| gets       | (C11 中移除)            |\n| gets_s     | 从 stdin 读取一个字节串 |\n| putchar    | 将一个字节写入 stdout   |\n| puts       | 将一个字节串写入 stdout |\n| ungetc     | 将一个字节送回文件流    |\n\n\n```c\nint main()\n{\n    char buff[128];\n    scanf_s(\"%s\",buff,128);\n    printf(\"%s \\n\",buff);\n    gets_s(\"%s\",buff,128);\n    printf(\"%s \\n\",buff);\n    return 0;\n}//如果我们只输入一次\"123 345 567 789\"并回车，那么我们的屏幕上将会打印：\n123\n 345 567 789\n/*原因：\nscanf(\"%s\",...);我们是给了格式控制的，遇到空格就结束了。\ngets();是遇到回车就结束。注意，上面已经讨论过了，是遇到“回车符”结束，遇到“换行符”不会控制输入结束。\n*/\n```\n\n\n```c\nint main()\n{\n    char ch;\n    int select;\n    do\n    {\n        printf(\"**********\\n\");\n        printf(\" 1.       \\n\");\n        printf(\" 2.       \\n\");\n        printf(\" 3.       \\n\");\n        printf(\" 4.       \\n\");\n        printf(\"select:\\n\");\n        scanf_s(\"%d\",&select);\n        switch(select)\n    \t{\n            case 1:\n                break;\n            case 2:\n                break;\n            default:\n                break;\n    \t}\n        printf(\"是否继续(y/n):\");\n        getchar();//消除回车的影响。\n        ch = getchar();\n    }while(ch=='y'||ch=='Y');\n    \n    printf(\"main end \\n\");\n    return 0;\n}\n```\n\n## getc/fgetc\n```cpp\nint fgetc( FILE * stream );\nint getc( FILE * stream );\n```\n\n从给定的输入流读取下一个字符。 `getc()` 可以实现为宏。\n### 参数\n\nstream 读取字符的来源\n\n### 返回值\n\n成功时为获得的字符，失败时为 EOF 。\n若文件尾条件导致失败，则另外设置 stream 上的文件尾指示器（见 `feof()` ）。若某些其他错误导致失败，则设\n置 stream 上的错误指示器（见 `ferror()` ）。\n\n## fgets\n```cpp\nchar * fgets(char * str, int count, FILE * stream );\n\n```\n从给定文件流读取最多 `count - 1` 个字符并将它们存储于 str 所指向的字符数组。若文件尾出现或发现换行符则终\n止分析，后一情况下 str 将包含一个换行符。若读入字节且无错误发生，则紧随写入到 str 的最后一个字符后写入空字\n符。\n\n### 参数\n\nstr 指向 char 数组元素的指针\ncount 写入的最大字符数（典型的为 str 的长度）\nstream 读取数据来源的文件流\n\n### 返回值\n\n成功时为 str ，失败时为空指针。\n若遇到文件尾条件导致了失败，则设置 stream 上的文件尾指示器（见 feof() ）。这仅若它导致未读取字符才是失\n败，该情况下返回空指针且不改变 str 所指向数组的内容（即不以空字符覆写首字节）。\n若某些其他错误导致了失败，则设置 stream 上的错误指示器（见 ferror() ）。 str 所指向的数组内容是不确定的\n（甚至可以不是空终止）。\n\n### 注解\n\nPOSIX 额外要求若 fgets 遇到异于文件尾条件的失败则设置 errno 。\n尽管标准规范在 count<=1 的情况下不明，常见的实现\n* 若 count < 1 则不做任何事并报告错误\n* 若 count == 1 ，则某些实现不做任何事并报告错误，其他实现不读内容，存储零于 str[0] 并报告成功\n## putc/fputc\n```cpp\nint fputc( int ch, FILE *stream );\nint putc( int ch, FILE *stream );\n```\n\n写入字符 ch 到给定输出流 stream 。 putc() 可以实现为宏并对 stream 求值超过一次，故对应的参数决不应是有副\n效应的表达式。在内部，在写入前将字符转换为 unsigned char 。\n\n### 参数\n\nch 要被写入的字符\nstream 输出流\n\n### 返回值\n\n成功时，返回被写入字符。\n失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror() ）。\n\n## fputs\n```cpp\nint fputs( const char \\* str, FILE \\* stream );\nint fputs( const char \\* restrict str, FILE \\* restrict stream );\n```\n\n将以NULL 结尾的字符串 str 的每个字符写入到输出流 stream ，如同通过重复执行 fputc 。\n不将 str 的空字符写入。\n\n### 参数\n\nstr 要写入的空终止字符串\nstream 输出流\n\n### 返回值\n\n成功时，返回非负值。\n失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror ）。\n\n### 注意\n\n相关函数 puts 后附新换行符到输出，而 fputs 写入不修改的字符串。不同的实现返回不同的非负数：一些返回最后写入的字符，一些返回写入的字符数（或若字符串长于 INT_MAX 则为该值），一些简单地非负常量，例如零。\n\n## getchar\n```cpp\nint getchar(void);\n```\n从 stdin 读取下一个字符。等价于 `getc(stdin)`。\n\n### 参数\n\n无\n\n### 返回值\n\n成功时为获得的字符，失败时为 EOF 。\n若失败由文件尾条件产生，则另外设置 stdin 上的文件尾指示器（见 feof() ）。若失败由某些其他错误产生，则设\n置 stdin 上的错误指示器（见 ferror() ）。\n\n## gets/gets_s\n```cpp\nchar * gets(char * str); //C11 中移除\nchar * gets_s(char * str, rsize_t n); //C11 起\n```\n\n1. 从 stdin 读入 str 所指向的字符数组，直到发现换行符或出现文件尾。在读入数组的最后一个字符后立即写入空字符。换行符被舍弃，但不会存储于缓冲区中。\n2. 从 stdin 读取字符直到发现换行符或出现文件尾。至多写入 n-1 个字符到 str 所指向的数组，并始终写入空终止字符（除非 str 是空指针）。若发现换行符，则忽略它并且不将它计入写入缓冲区的字符数。\n\n在运行时检测下列错误并调用当前安装的制约处理函数：\n* n 为零\n* n 大于 RSIZE_MAX\n* str 是空指针\n* 在存储 n-1 个字符到缓冲区后没有遇到换行符或文件尾。\n\n任何情况下，`gets_s` 首先结束读取并忽略来自 stdin 的字符，直到换行符、文件尾条件，或在调用制约处理前的\n读取错误。\n同所有边界检查函数， `gets_s` 仅若实现定义 `__STDC_LIB_EXT1__`且用户在包含 `stdio.h` 前定\n义`__STDC_WANT_LIB_EXT1__`为整数常量 1 才保证可用。\n\n### 参数\n\nstr 要被写入的字符串\nn char 数组的最大长度\n\n### 返回值\n\n成功时为 str ，失败时为空指针。\n若文件尾条件导致了失败，则附加设置 stdin 的文件尾指示器（见 feof() ）。若其他某些原因导致了失败，则设\n置 stdin 的错误指示器（见 ferror() ）。\n\n### 注解\n\ngets() 函数不进行边界检查，从而此函数对缓冲区溢出攻击极度脆弱。无法安全使用它（除非程序运行的环境限定\n能出现在 stdin 上的内容）。因此，此函数在 C99 的第三次勘误中被弃用，而在 C11 标准发布时被移除。推荐的替代\n品是 fgets() 和 `gets_s()` 。绝对不要用 gets() 。\n\n## putchar\n```cpp\nint putchar( int ch );\n\n```\n写字符 ch 到 stdout 。在内部，字符于写入前被转换到 unsigned char 。\n等价于 `putc(ch, stdout)`。\n\n### 参数\n\nch 要被写入的字符\n\n### 返回值\n\n成功时返回写入的字符。\n失败时返回 EOF 并设置 stdout 上的错误指示器（见 ferror() ）\n\n示例：putchar 带错误检查\n\n## puts\n```cpp\nint puts( const char *str );\n```\n写入每个来自空终止字符串 str 的字符及附加换行符`'\\n'`到输出流 stdout ，如同以重复执行 putc 写入。\n不写入来自 str 的空终止字符。\n\n### 参数\n\nstr 要写入的字符串\n\n### 返回值\n\n成功时返回非负值\n失败时，返回 EOF 并设置 stdout 的错误指示器（见 ferror() ）。\n\n### 注意\n\nputs 函数后附一个换行字符到输出，而 fputs 不这么做。\n不同的实现返回不同的非负数：一些返回最后写入的字符，一些返回写入的字符数（或若字符串长于`INT_MAX`则返回\n它），一些简单地返回非负常量。\n在重定向 stdout 到文件时，导致 puts 失败的典型原因是用尽了文件系统的空间。\n\n## ungetc\n```cpp\nint ungetc( int ch, FILE *stream );\n\n```\n若 ch 不等于 EOF ，则推入字符 ch （转译为 unsigned char ）到与流 stream 关联的输入缓冲区，方式满足从 stream 的后继读取操作将取得该字符。不修改与流关联的外部设备。\n流重寻位操作 fseek 、 fsetpos 和 rewind 弃去 ungetc 的效果。\n若调用 ungetc 多于一次，而无中间读取或重寻位，则可能失败（换言之，保证大小为 1 的回放缓冲区，但任何更大的缓冲区是实现定义的）。若成功进行多次 ungetc ，则读取操作以 ungetc 的逆序取得回放的字符。\n若 ch 等于 EOF ，则操作失败而不影响流。\n对 ungetc 的成功调用清除文件尾状态标志 feof 。\n在二进制流上对 ungetc 的成功调用将流位置指示器减少一（若流位置指示器为零，则行为不确定）。\n在文本流上对 ungetc 的成功调用以未指定方式修改流位置指示器，但保证在以读取操作取得所有回放字符后，流位置指示器等于其在 ungetc 之前的值。\n\n### 参数\n\nch 要推入输入流缓冲区的字符\nstream 要回放字符到的文件流\n\n### 返回值\n\n成功时返回 ch 。\n失败时返回 EOF ，而给定的流保持不变。\n\n### 注意\n\n实践中，回放缓冲区的大小会在 4k （ Linux 、 MacOS ）和 4 （ Solaris ）或保证的最小值 1 （ HPUX 、AIX ）间变化。\n若回放的字符等于存在于外部字符序列中该位置的字符，则回放缓冲区的表观大小可以更大（实现可以简单地自减读取的文件位置指示器，并避免维护回放缓冲区）。\n\n# 附录：C11 标准\n\nfopen变换了，要用`fopen_s`。里面的pf指针要取其地址写成`&pf`。要返回一个`errno_t`值。可以返回错误标识值。\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n    float ar[]={1.2,2.3,3.4,4.5,5.6,6.7,7.8,8.9,9.0,1.00};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    FILE* pf = NULL;\n    //pfa = fopen(\"yhp.txt\",\"w\");//VS2019中不能运行\n    errno_t tag = fopen_s(&pf,\"yhp.txt\",\"a\");//此时pf指针就指向了系统产生的一个文件流对象。那么对文件流对象的操作就可以间接对磁盘中的文件进行操作。文件流对象内部包含缓冲区。//\"a\"代表追加写入，并且找不到文件时主动创建。\n    if(NULL==pf)\n    {\n        printf(\"open file error: %d\\n\",tag);\n        exit(EXIT_FAILURE);\n    }\n    for(int i=0;i<n;++i)\n    {\n        fprintf(pf,\"%f \",ar[i]);\n    }\n    fclose(pf);\n    pf = NULL;\n    return 0;\n}\n```\n\n![image-20210824211918339](../../images/C_%E6%96%87%E4%BB%B6/image-20210824211918339.png)\n\n# 关于回车和换行在文件中的表现方式\n\n# 主函数带参\n\n## 这是不带参的\n\n```c\nint main()\n{\n    \n}\n```\n\n## 这是两个参数的\n\n以下程序可以输出目前argv数组的元素个数和内容，但是直接运行的话只会输出1。\n我们在cmd.exe中运行此程序时，可以在后面加字符串，比如`tulun219.exe yhp hello newdata print`\n会输出5（字符串个数），以及各字符串的内容。\n\n```c\nint main(int argc, char* argv[])\n{\n    printf(\"%d \\n\",argc);\n    for(int i = 0;i<argc;++i)\n    {\n        printf(\"%s \\n\",argv[i]);\n    }\n    return 0;\n}\n```\n\n![image-20210826214859920](../../images/C_%E6%96%87%E4%BB%B6/image-20210826214859920.png)\n\n![image-20210826215126981](../../images/C_%E6%96%87%E4%BB%B6/image-20210826215126981.png)\n\n此处的应用价值有很多，比如我们操作控制台的时候，dir表示查看目录信息的**命令程序**，后面跟的/D就是其参数。很好地类比了“程序名 str1 str2”的命令控制格式。\n\n![image-20210826215343314](../../images/C_%E6%96%87%E4%BB%B6/image-20210826215343314.png)\n\n### 实现cmd下依靠程序进行文件的复制\n\n`tulun219.exe Test.cpp yhp.cpp`\n\n输入以上信息可以达到一个传参的效果。通过fopen把Test.cpp打开，通过fopen，创建yhp.cpp。然后读取数据写入到yhp.cpp中。就可以实现文件的复制。\n\n```c\nint main(int argc, char* argv[])//tulun219.exe Test.cpp yhp.cpp\n{\n    char ch;\n    if(argc<3)return 1;\n    FILE* fpr = nullptr;FILE* fpw = nullptr;\n    errno_t tag = fopen_s(&fpr,argv[1],\"rb\");\n    if(nullptr==fpr)\n    {\n        printf(\"src file open error:%d\\n\",tag);\n        return 1;\n    }\n    tag = fopen_s(&fpw,argv[2],\"wb\");\n    if(nullptr==fpw)\n    {\n        printf(\"des file open error:%d\\n\",tag);\n        return 1;\n    }\n    fseek(pfr,0,SEEK_END);\n    int len = ftell(pf);\n    printf(\"len:%d \\n\",len);\n    rewind(pfr);\n    \n    char* str = (char*)malloc(sizeof(char)*len);\n    fread(str,sizeof(char),len,fpr);\n    fwrite(str,sizeof(char),len,fpw);\n    fclose(fpr);\n    fclose(fpw);\n    fpr = fpw = nullptr;\n    return 0;\n}\n```\n\n#### 问题：argv里的字符串存放在哪个区域？\n\n```c\n#include<stdio.h>\nint main(int argc, char* argv[])\n{\n    printf(\"%s \\n\",argv[0]);\n    return 0;\n}\n```\n\n上面这个程序会打印：\n\n![image-20210826222047730](../../images/C_%E6%96%87%E4%BB%B6/image-20210826222047730.png)\n\n那么就像这样的字符串是在哪呢？代码区不可能，因为传参的时候代码早已经加载完了。堆区也不可能，因为堆区的数据都是malloc产生的。目前剩下数据区和栈区。我们仔细观察，思考，既然我们给的参数字符串可以修改，而且char \\* argv[]前面没有const修饰，所以肯定不是在数据区的。那么，结论就是字符串指针数组和字符串均在主函数的栈帧之下。\n\n![image-20210826223218635](../../images/C_%E6%96%87%E4%BB%B6/image-20210826223218635.png)\n\n## 这是三个参数的\n\n三个参数的main函数，前两个参数是配合使用的。第三个参数engv可以读取系统的环境变量。\n\n```c\nint main(int argc, char* argv[], char* engv[])\n{\n    for(int i = 0;engv[i]!=NULL;++i)\n    {\n        printf(\"%s\\n\",engv[i]);\n    }\n    return 0;\n}\n```\n\n![image-20210826223348266](../../images/C_%E6%96%87%E4%BB%B6/image-20210826223348266.png)\n\n# 序列化-反序列化\n\n把链表变成一组数据。\n\n要求可以根据这组数据在另一个机子上构建出来链表。\n\n```c\n//本文件名为MyLinkList.h\n#ifndef MYLINKLIST_H\n#define MYLINKLIST_H\ntypedef int ElemType;\ntypedef struct ListNode\n{\n\tElemType data;\n\tstruct ListNode* next;\n}ListNode;\ntypedef struct\n{\n\tListNode* head;\n\tint cursize;\n}LinkList;\nvoid InitLink(LinkList* plist);\nvoid ClearLink(LinkList* plist);\nvoid DestroyLink(LinkList* plist);\nint GetSize(const LinkList* plist);\nbool IsEmpty(const LinkList* plist);\nvoid Insert_Next(LinkList* plist, ListNode* ptr, ElemType val);\nvoid Push_Front(LinkList* plist, ElemType val);\nvoid Push_Back(LinkList* plist, ElemType val);\nbool Erase_Next(LinkList* plist, ListNode* ptr);\nvoid Pop_Front(LinkList* plist);\nvoid Pop_Back(LinkList* plist);\nvoid Remove(LinkList* plist, ElemType val);\nvoid Remove_All(LinkList* plist, ElemType val);\nvoid PrintLink(const LinkList* plist);\nListNode* FindValue_pre(const LinkList* plist, ElemType val);\nListNode* FindValue(const LinkList* plist, ElemType val);\nListNode* FindPos_pre(const LinkList* plist, int pos);\nListNode* FindPos(const LinkList* plist, int pos);\n#endif\n```\n\n现要求写两个函数：\n1. `void ListSave(LinkList* plist);`把链表的数据保存到本计算机的磁盘中。通过写入到文件实现。序列化。\n2. `void ListLoad(LinkList* plist);`加载收到的文件中的数据，在内存中构建一个链表，重载数据。反序列化。\n\n```c\n//MyLinkList.cpp\n#include<stdio.h>\n#include\"MyLinkList.h\"\nvoid ListSave(LinkList* plist)\n{\n    assert(plist!=NULL);\n    if(IsEmpty(plist))return;\n    FILE* pf = NULL;\n    errno_t tag = fopen_s(&pf,\"List.dat\",\"wb\");\n    if(fp == NULL)\n    {\n\t\tprintf(\"file open error:%d\\n\",tag);\n        exit(1);\n    }\n    fprintf(pf,\"%d\\n\",plist->cursize);\n    ListNode* pnode = plist->head->next;\n    while(pnode!=NULL)\n    {\n        fprintf(pf,\"%d\\n\",pnode->data);\n        pnode=pnode->next;\n    }\n    fclose(pf);\n    pf=NULL;\n}\nvoid ListLoad(LinkList* plist)\n{\n    assert(plist!=NULL);\n    FILE* pf = NULL;\n    errno_t tag = fopen_s(&pf,\"List.dat\",\"rb\");\n    if(pf==NULL)\n    {\n        printf(\"file open error:%d\\n\");\n        exit(1);\n    }\n    int n = 0;\n    fscanf_s(pf,\"%d\",&n);\n    for(int i = 0;i<n;++i)\n    {\n        int val=0;\n        fscanf_s(pf,\"%d\",&val);\n        Push_Back(plist,val);\n    }\n    fclose(pf);\n    pf=NULL;\n}\nint main()\n{\n    LinkList mylist;\n    InitLink(&mylist);\n    \n    int val;\n    while(scanf_s(\"%d\",&val),val!=-1)\n    {\n        Push_Front(&mylist,val);\n    }\n    PrintLink(&mylist);\n    //以上程序运行时，输入12 23 34 45 56 67 78 89 90 100 -1\n    //输入100 90 89 78 67 56 45 34 23 12 （因为是头插）\n    ListSave(&mylist);\n    \n    LinkList newlist;\n    InitLink(&newlist);\n    ListLoad(&newlist);\n    PrintLink(&newlist);\n    \n    \n    DestoryLink(&mylist);\n    DestoryLink(&newlist);\n    return 0;\n}\n```\n\n# json专题\n\n```c\n//json对象结构：\n/* The cJSON structure: */\ntypedef struct cJSON {\n\tstruct cJSON *next,*prev;\n\tstruct cJSON *child;\n\tint type;\n\tchar *valuestring;\n\tint valueint;\n\tdouble valuedouble;\n\tchar *string;\n}cJSON;\n```\n\n```json\n//yhp.json文件\n{\n    \"name\":\"杨和平\",\n    \"age\":17,\n    \"LOVE\":[\"Study\",\"Programming\",\"Go shopping\"],\n    \"score\":145,\n    \"address\":\"shanxi\"\n}\n```\n\n![image-20210827202745517](../../images/C_%E6%96%87%E4%BB%B6/image-20210827202745517.png)\n\n## 有价值的问题\n\n如何把数据通过json把数据写到文件，\n\n如何通过文件写到程序中。\n\n## `cJSON_InitHooks`\n\n`extern void cJSON_InitHooks(cJSON_Hooks* hooks);`\n\n向cJSON 提供malloc 和free 函数：挂接内存池\n\n## `cJSON_Parse`\n\n`extern cJSON* cJSON_Parse(const char *value);`\n\n提供一个JSON 块，然后返回一个可以查询的cJSON 对象。完成后不要忘了调用`cJSON_Delete`。\n\n## `cJSON_Print`\n\n`extern char* cJSON_Print(cJSON\\* item);`\n\n将cJSON 实体呈现为用于传输/存储的文本。完成后释放char\\*。\n\n\n```c\n#include<stdio.h>\n#include<stdlib.h>  // malloc free  exit\n#include<assert.h>\n#include<string.h>\n#include\"cJSON.h\"\nstruct Student\n{\n    char s_id[20];\n    char s_name[20];\n    char s_sex[8];\n    int s_age;\n};\nint main()\n{\n    struct Student *pstud;\n    int n = 0;\n    char *buff = NULL;\n    int len = 0;\n    FILE *fp = fopen(\"Student.json\",\"rb\");\n    if(fp == NULL) exit(1);\n    fseek(fp,0,SEEK_END);\n    len = ftell(fp);  // file size \n    rewind(fp);\n    \n    buff = (char*)calloc(sizeof(char),len+1);\n    //fgets(buff,len+1,fp); // \n    fread(buff,sizeof(char),len+1,fp);\n    fclose(fp); \n    fp = NULL;\n    printf(\"%s\\n\",buff);\n    cJSON *json = cJSON_Parse(buff);\n    free(buff); buff = NULL;\n    cJSON *array = cJSON_GetObjectItem(json,\"Student\");\n    \n    n = cJSON_GetArraySize(array);\n    \n    printf(\"n : %d \\n\",n);\n    \n    pstud = (struct Student*)calloc(sizeof(struct Student),n);\n    for(int i = 0;i<n;++i)\n    {\n        cJSON *obj = cJSON_GetArrayItem(array,i);\n        cJSON *id = cJSON_GetObjectItem(obj,\"id\");\n        cJSON *name = cJSON_GetObjectItem(obj,\"name\");\n        cJSON *sex = cJSON_GetObjectItem(obj,\"sex\");\n        cJSON *age = cJSON_GetObjectItem(obj,\"age\");\n        strcpy(pstud[i].s_id,id->valuestring);\n        strcpy(pstud[i].s_name,name->valuestring);\n        strcpy(pstud[i].s_sex,sex->valuestring);\n        pstud[i].s_age=age->valueint;\n        char *s = cJSON_Print(obj);\n        printf(\"%s \\n\",s);\n        free(s);\n        printf(\"id: %s,name: %s,sex: %s,age: %d\\n\",pstud[i].s_id,pstud[i].s_name,pstud[i].s_sex,pstud[i].s_age);\n    }\n\n    return 0;\n}\n\n#if 0\nint main()\n{\n    struct Student stud[]=\n    {\n        {\"09001\",\"yhping\",\"man\",23},\n        {\"09002\",\"lijianli\",\"man\",90},\n        {\"09003\",\"tianjia\",\"man\",12},\n        {\"09004\",\"liulu\",\"woman\",18},\n        {\"09005\",\"baihen\",\"man\",17}\n    };\n    int n = sizeof(stud)/sizeof(stud[0]); \n    cJSON *json = cJSON_CreateObject();\n    cJSON *array = cJSON_CreateArray();\n    cJSON_AddItemToObject(json,\"Student\",array);\n    for(int i = 0;i<n;++i)\n    { // 11:53\n        cJSON *obj = cJSON_CreateObject();\n        cJSON_AddItemToArray(array,obj);\n        //cJSON_AddItemToObject(obj,\"id\",cJSON_CreateString(stud[i].s_id));\n        cJSON_AddStringToObject(obj,\"id\",stud[i].s_id);\n        cJSON_AddStringToObject(obj,\"name\",stud[i].s_name);\n        cJSON_AddStringToObject(obj,\"sex\",stud[i].s_sex);\n        cJSON_AddNumberToObject(obj,\"age\",stud[i].s_age);\n    }\n    char *s = cJSON_Print(json);\n    printf(\"%s \\n\",s);\n    FILE *fp = fopen(\"Student.json\",\"wb\");\n    if(fp == NULL) exit(1);\n    fwrite(s,sizeof(char),strlen(s),fp);\n    fclose(fp);\n    fp = NULL;\n    free(s);\n    s = NULL;\n    cJSON_Delete(json);\n    json = NULL;\n    return 0;\n}\nint main()\n{\n    cJSON *json = cJSON_CreateObject();\n    // \"{}\"\n    cJSON_AddItemToObject(json,\"name\",cJSON_CreateString(\"yhping\"));\n    //\" {\\\"name\\\":\\\"yhping\\\"} \"\n    cJSON_AddItemToObject(json,\"sex\",cJSON_CreateString(\"man\"));// object =>key:value\n    //cJSON *sex = cJSON_CreateString(\"man\");\n    //cJSON_AddItemToObject(json,\"sex\",sex);\n    //\"  {\\\"name\\\":\\\"yhping\\\" , \\\"sex\\\":\\\"man\\\"} \"\n    cJSON_AddItemToObject(json,\"age\",cJSON_CreateNumber(23));\n    //\"  {\\\"name\\\":\\\"yhping\\\" , \\\"sex\\\":\\\"man\\\", \\\"age\\\":23} \"\n    \n    cJSON *array = NULL;\n    cJSON_AddItemToObject(json,\"LOVE\",array = cJSON_CreateArray());\n    // \"  {\\\"name\\\":\\\"yhping\\\" , \\\"sex\\\":\\\"man\\\", \\\"age\\\":23,\"LOVE\":[]} \"\n    cJSON_AddItemToArray(array,cJSON_CreateString(\"Study\"));\n    // \"  {\\\"name\\\":\\\"yhping\\\" , \\\"sex\\\":\\\"man\\\", \\\"age\\\":23,\"LOVE\":[\"Study\"]} \"\n    cJSON_AddItemToArray(array,cJSON_CreateString(\"Programming\"));\n    cJSON_AddItemToArray(array,cJSON_CreateString(\"Go shopping\"));\n    \n    cJSON_AddItemToObject(json,\"score\",cJSON_CreateNumber(145));\n    //cJSON_AddNumberToObject(json,\"score\",145);\n    \n    cJSON_AddItemToObject(json,\"address\",cJSON_CreateString(\"shanxi\"));\n    //cJSON_AddStringToObject(json,\"addree\",\"shanxi\");\n    \n    char *str = cJSON_Print(json);\n    printf(\"%s \\n\",str);\n    \n    free(str);\n    str = NULL;\n    cJSON_Delete(json);\n    json = NULL;\n    \n    return 0;\n}\n\nint main()\n{\n    char *buff = NULL;\n    int len = 0;\n    FILE *fp = fopen(\"Testcjson.json\",\"rb\");\n    if(fp == NULL) exit(1);\n    fseek(fp,0,SEEK_END);\n    len = ftell(fp);  // file size \n    rewind(fp);\n    \n    buff = (char*)calloc(sizeof(char),len+1);\n    //fgets(buff,len+1,fp); // \n    fread(buff,sizeof(char),len+1,fp);\n    \n    cJSON *json = cJSON_Parse(buff);\n    \n    int n = cJSON_GetArraySize(json);\n    \n    fclose(fp);\n    fp = NULL;\n    free(buff);\n    buff = NULL;\n    return 0;\n}\nint main()\n{\n    char str[]=\"{ \\\"name\\\":\\\"yhping\\\" ,\\\"sex\\\":\\\"man\\\",\\\"age\\\":23 }\";\n    \n    char stra[]=\"{name: yhping,sex:man,age:23}\";\n    cJSON *json = cJSON_Parse(str);\n    \n    char *s = cJSON_Print(json);\n    char *p = cJSON_PrintUnformatted(json);\n    FILE *fp = fopen(\"Testcjson.json\",\"w\");\n    \n    printf(\"%s \\n\",s);\n    printf(\"%s \\n\",p);\n    fprintf(fp,\"%s\",s);\n    fclose(fp);\n    \n    free(s);\n    s = NULL;\n    \n    return 0;\n}\n#endif\n```\n\n改进\n\n```c\ntypedef struct cJSON\n{\n    struct cJSON* next,*prev;\n    struct cJSON* child;\n    int type;\n    union\n    {\n        char* valuestring;\n        int valueint;\n        double valuedouble;\n    }\n    char* string;\n}\n```\n# 总结\n\nw/a可以主动创建文件，r不能创建文件。","tags":["tulun"],"categories":["C"]},{"title":"C语言_动态内存管理","url":"/C/C语言_动态内存管理/","content":"\n# 本章内容\n\n1. 什么是动态内存\n2. 动态内存管理函数\n3. 动态内存的使用\n4. 动态内存与结构体\n\n# 什么是动态内存\n\n先看一段程序：\n\n```c\n#include<stdio.h>\nint main()\n{\n    char str[1024 * 1024];\t// 需要1MB存储空间\n    print(\"hehe \\n\");\n    return 0;\n}\n```\n\n![image-20210819005329023](../../images/C_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20210819005329023.png)\n\n运行时程序崩溃（在Windows系统下）。这是为什么呢？\n\n> 注意报错信息：\n>\n> `0xC00000FD`: Stackoverflow\n\n再次分析编译链接过程：\n\n![image-20220604082515963](../../images/C_动态内存管理/image-20220604082515963.png)\n\n先来谈栈区，我们知道栈区的空间在函数被调时会分配，用于存放函数的参数值，局部变量等值。在Windows中栈的默认大小是`1MB`，在vs中可以设置栈区的大小；在Linux中栈的默认大小是`10MB`，在gcc编译时可以设置栈区的大小。\n\n再看堆区，程序运行时可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。在Liunx系统中用户可用的堆区的大小接近`3GB`。Windows下的用户堆区大小是接近`2G`。可参考此文章：[栈和堆的大小，申请一个整形数组最大可以达到多少（Linux和Windows）](https://www.its203.com/article/qq_37200329/97949658)\n\n**如果我们需要大块内存，或者程序在运行的过程中才知道所需内存大小，我们就从堆区分配空间**。\n\n## 动态内存分配函数\n\nC语言中动态内存管理的有四个函数：`malloc`，`calloc`，`realloc`，`free`，都需要引用`stdlib.h`或`malloc.h`文件。\n\n# malloc\n\n向堆区申请一块指定大小的连续内存空间。\n```c\nusing size_t = unsigned int;\nvoid* malloc(size_t size);\n参数：\n\tsize\t- 要分配的字节数\n返回值：\n\t成功时, 返回指向新分配内存的指针;\n\t失败时, 返回空指针。\n```\n\n1. 分配`size`字节的未初始化内存。\n2. 若分配成功，则返回为任何拥有**基础对齐**的对象类型对齐的指针。\n3. 若`size`为零，则`malloc`的行为是实现定义的。例如可返回空指针，亦可返回非空指针，但不应当**解引用**这种非空指针，而且应将它传递给以避免内存泄漏。\n\n# free\n\n用来释放且仅能释放从`malloc`，`realloc`，`calloc`成功获取到的动态内存分配的空间。释放的不是指针本身，而是指针所指的堆区空间。\n\n```cpp\nvoid free(void * ptr);\n```\n\n释放之前由`malloc()`、`calloc()`、`aligned_alloc() (C11起)`或`realloc()`分配的空间。\n\n1. 若`ptr`为空指针，则函数不进行操作。\n2. 若`ptr`的值不是之前从`malloc()`、`calloc()`、`realloc()`或`aligned_alloc() (C11起)`返回的值，则行为未定义。\n3. 若`ptr`所指代的内存区域已经被解分配，则行为未定义。\n4. 若在`free()`返回后通过指针`ptr`访问内存，则行为未定义（除非另一个分配函数恰好返回等于`ptr`的值）。\n\n**参数**\nptr 指向要解分配的内存的指针\n**返回值（无）**\n注解\n此函数接收空指针（并对其不处理）以减少特例的数量。不管分配成功与否，分配函数返回的指针都能传递给 free() 。\n\n## 示例\n\n\n\n## 面试重点\n\n\n\n\n\n# calloc\n\n分配并使用零初始化连续内存空间\n\n```c\nvoid * calloc(size_t num, size_t size);\n参数:\n\tnum\t\t- 对象（元素）数目\n\tsize\t- 每个对象（元素）的大小\n返回值:\n\t成功时，返回指向新分配内存的指针。\n\t失败时，返回空指针。\n```\n\n为`num`个对象（元素）的数组分配内存，并初始化所有分配存储中的字节为零。\n\n1. 若分配成功，会返回指向分配内存块最低位（首位）字节的指针，它为任何类型适当地对齐。\n2. 若`size`为零，则行为是实现定义的（可返回空指针，或返回不可用于访问存储的非空指针）。\n\n## 模拟实现\n\n实际上，calloc是基于malloc实现的。\n\n```c\nvoid* my_calloc(size_t count, size_t size)\n{\n    void* s = malloc(count * size);\n    if(s != NULL)\n    {\n        memset(s, 0, count * size);\n    }\n    return s;\n}\n```\n\n# realloc\n\n扩充之前分配的内存块(重新分配内存块)。\n\n```c\nvoid * realloc(void * ptr, size_t new_size);\n参数:\n\tptr\t\t\t- 指向需要重新分配的内存区域的指针\n\tnew_size\t- 数组的新大小（字节数）\n返回值:\n\t成功时，返回指向新分配内存的指针。原指针ptr失效，而且任何通过它的访问是未定义行为（即使重分配是就地的）。\n\t失败时，返回空指针。原指针ptr保持有效。\n```\n\n重新分配给定的内存区域。它必须是之前为`malloc()`、`calloc()`或`realloc()`所分配，并且仍未被`free`或`realloc`的调用所释放。否则，结果未定义。\n\n重新分配按以下二者之一执行：\n\n1. 可能的话，扩张或收缩`ptr`所指向的已存在内存。内容在新旧大小中的较小者范围内保持不变。若扩张范围，则数组新增部分的内容是未定义的。\n2. 分配一个大小为`new_size`字节的新内存块，并复制大小等于新旧大小中较小者的内存区域，然后释放旧内存块。\n\n1. 若无足够内存，则不释放旧内存块，并返回空指针。\n2. 若`ptr`是`NULL`，则行为与调用`malloc(new_size)`相同。\n3. 若`new_size`为零，则行为是实现定义的（可返回空指针，此情况下可能或可能不释放旧内存，或返回不会用于访问存储的非空指针）。\n\n## 示例\n\n```c\n#include<stdlib.h>\n#include<stdio.h>\nint main()\n{\n    int n = 10;\n    int m = 5;\n    int dm = 3;\n    //现在申请 m 个int空间。\n    int* p = (int*)malloc(sizeof(int) * m);\n    if (p == NULL)\n    {\n        exit(1);\n    }\n    for (int i = 0; i < m; ++i)\n    {\n        p[i] = i;\n    }\n\t//现在扩展到 n 个int空间。\n    int* newdata = (int*)realloc(p, sizeof(int) * n);//扩展到n个，不是扩展n个\n    if (NULL == newdata)\n    {\n        printf(\"堆无更多空间，增容失败\\n\");\n        exit(1);\n    }\n    p = newdata;\n}\n```\n\n## 扩容\n\nrealloc扩容有3种情况。\n\n### 1 - 后面足够, 就地\n\n后续有足够的可分配空间。图示如下：\n\n![image-20220604184349335](../../images/C_动态内存管理/image-20220604184349335.png)\n\n1. 下越界标记后移。\n2. 修改上越界标记之上的信息为最新大小值。\n\n### 2 - 后面不足, 搬到更大的空地\n\n后续未分配内存空间不足够大，不能分配空间。图示如下：\n\n![image-20220604184421960](../../images/C_动态内存管理/image-20220604184421960.png)\n\n1. 在堆内存其他区域开辟要扩展的大小。\n2. 原本的内存内容拷贝到新空间。\n3. 原本的内存释放。\n4. 原来的指针失效，需要重新接收新指针（返回值）。\n\n### 3 - 堆空间不足, 会产生内存泄漏\n\n```c\nint main()\n{\n    int m = 100;\n    int n = 1000;\n    int * p = (int*)malloc(sizeof(int) * m);\n    for(int i = 0; i<m; ++i)\n    {\n        p[i] = i;\n    }\n    // 由 100个空间扩展到1000个空间\n    p = (int*)realloc(p, sizeof(int) * n);\n    //如果返回了一个NULL呢？把p给冲掉了！\n}\n```\n\n堆内存不足，扩展空间失败，`realloc`函数返回NULL。\n\n此时会产生一个**巨大的坑**。\n\n如果你没有事先保存指针p的值，那么p的值将会丢失。就产生了内存泄漏。\n\n> 内存泄漏指的不是p所指的空间被释放了，而是p指针所指的地址无从查找了，从而无法管理原有的内存空间了。\n\n#### 安全的方案\n\n```c\nint main()\n{\n    int m = 100;\n    int n = 1000;\n    int * p = (int*)malloc(sizeof(int) * m);\n    for(int i = 0; i<m; ++i)\n    {\n        p[i] = i;\n    }\n    // 由 100个空间扩展到1000个空间\n    int * newdata = (int*)realloc(p, sizeof(int)*n);\n    if(newdata == NULL)\n    {\n        printf(\"内存不足, realloc失败\\n\");\n    }\n    else\n    {\n        free(p);\t\t//内存足够, free掉原有空间\n        p = newdata;\n    }\n}\n```\n\n## 模拟实现 - 扩容\n\n```c\nvoid my_realloc(void* p, size_t old_sz, size_t new_sz)\n{\n    void* newdata = malloc(size);\n    if(newdata!=NULL)\n    {\n        memmove(newdata, p, old_sz);\n    }\n    return newdata;\n}//只能模拟第二种情况，第一种情况需要知道内存后面是否有足够空间，需要系统调用。\n```\n\n# 单链表\n\n```c\n#pragma once\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\ntypedef int ElemType;\ntypedef struct ListNode\n{\n    ElemType data;\n    struct ListNode* next;\n}ListNode;\ntypedef struct\n{\n    ListNode* head;\n    int cursize;\n}LinkList;//链表\nListNode* Buynode()\n{\n    ListNode* s = (ListNode*)malloc(sizeof(ListNode));\n    if (NULL == s)\n    {\n        exit(1);\n    }\n    memset(s, 0, sizeof(ListNode));\n    return s;\n}\nvoid Freenode(ListNode* p)\n{\n    free(p);\n}\nvoid InitList(LinkList* plist)\n{\n    assert(plist != nullptr);\n    plist->head = Buynode();\n    plist->cursize = 0;\n}\nint GetSize(const LinkList* plist)\n{\n    assert(plist != nullptr);\n    return plist->cursize;\n}\nbool isEmpty(const LinkList* plist)\n{\n    return GetSize(plist) == 0;\n}\nvoid PrintList(LinkList* plist)\n{\n    assert(plist != nullptr);\n    ListNode* p = plist->head->next;\n    while (p != NULL)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\nListNode* FindValue(LinkList* plist, ElemType val)\n{\n    assert(plist != nullptr);\n    ListNode* p = plist->head->next;\n    while (p != NULL && p->data != val)\n    {\n        p = p->next;\n    }\n    return p;\n}\nListNode* FindValue_Prev(LinkList* plist, ElemType val)\n{\n    assert(plist != nullptr);\n    ListNode* pre = plist->head;\n    ListNode* pnode = pre->next;\n    while (pnode != NULL && pnode->data != val)\n    {\n        pre = pnode;\n        pnode = pnode->next;\n    }\n    if (pnode == NULL)\n    {\n        pre = NULL;\n    }\n    return pre;\n}\nbool Insert_Next(LinkList* plist, ListNode* ptr, ElemType val)//向plist链表中的ptr结点（假设已经找到）之后插入新结点。为其他插入函数服务\n{\n    assert(plist != nullptr);\n    if (ptr == NULL)return false;\n    ListNode* pnode = Buynode();\n    pnode->data = val;\n    pnode->next = ptr->next;\n    ptr->next = pnode;\n    plist->cursize += 1;\n    return true;\n}\nvoid Push_Front(LinkList* plist, ElemType val)\n{\n    Insert_Next(plist, plist->head, val);\n}\nvoid Push_Back(LinkList* plist, ElemType val)\n{\n    ListNode* pnode = plist->head;\n    while (pnode->next != nullptr)\n    {\n        pnode = pnode->next;\n    }\n    Insert_Next(plist, pnode, val);\n}\nbool Remove(LinkList* plist, ElemType val)\n{\n    assert(plist != NULL);\n    ListNode* p = FindValue_Prev(plist, val);\n    return Erase_Next(plist, p);\n}\n//最垃圾的219版\nvoid Remove_All(LinkList* plist, ElemType val)\n{\n    assert(plist != NULL);\n    ListNode* p = NULL;\n    while ((p = FindValue_Prev(plist, val)) != NULL)\n    {\n        Erase_Next(plist, p);\n    }\n}\n//技能提升班版本\nvoid Remove_All(LinkList* plist, ElemType val)\n{\n    assert(plist != NULL);\n    ListNode* p = plist->head;\n    while (p->next != NULL)//说明p有后继\n    {\n        if (p->next->data == val)\n        {\n            ListNode* q = p->next;\n            p->next = q->next;\n            Freenode(q);\n            plist->cursize--;\n        }\n        else\n        {\n            p = p->next;\n        }\n    }\n}\n//技能提升班版本改进，215版本\nvoid Remove_All(LinkList* plist, ElemType val)\n{\n    assert(plist != NULL);\n    ListNode* p = plist->head;\n    while (p->next != NULL)//说明p有后继\n    {\n        if (p->next->data == val)\n        {\n            Erase_Next(plist, p);\n        }\n        else\n        {\n            p = p->next;\n        }\n    }\n}\n//B站版本\nvoid Remove_All(LinkList *plist, ElemType val)\n{\n    assert(plist != NULL);\n    ListNode *pre = plist->head;\n    ListNode *p = plist->head->next;\n    while(p!=NULL)\n    {\n        if(val!=p->data)\n        {\n            pre = pre->next;\n            Swap(&pre->data,&p->data);\n        }\n        p = p->next;\n    }\n    while(pre->next!=NULL)\n    {\n        Erase_Next(plist,pre);\n    }\n}\nbool IsEmpty(const LinkList* plist)\n{\n    assert(plist != NULL);\n    return plist->cursize == 0;\n}\nvoid ClearList(LinkList* plist)\n{\n    assert(plist);\n    while (!IsEmpty(plist))\n    {\n        Pop_Front(plist);\n    }\n}\nvoid DestroyList(LinkList* plist)\n{\n    assert(plist);\n    ClearList(plist);\n    Freenode(plist->head);\n    plist->head = NULL;\n}\nListNode* FindPrevNode_Pos(const LinkList* plist, int pos)\n{\n    assert(plist != nullptr);\n    if (pos<1 || pos > plist->cursize + 1)return NULL;\n    ListNode* pnode = plist->head;  //0\n    for (int i = 0; i < pos - 1;++i)\t//pos: pos=5->1 2 3 4;pos=1 -> 0\n    {\n        pnode = pnode->next;\n    }\n    return pnode;\n}\nListNode* FindNode_Pos(const LinkList* plist, int pos)\n{\n    assert(plist != nullptr);\n    if (pos<1 || pos > plist->cursize)return NULL;\n    ListNode* pnode = FindPrevNode_Pos(plist, pos);\n    return pnode->next;\n}\nvoid Insert_Item(LinkList* plist, ElemType x, ElemType val)\n{\n\n}\nbool Erase_Next(LinkList* plist, ListNode* ptr)//删除ptr的后续节点\n{\n    assert(plist != nullptr);\n    ListNode* pnode = ptr->next;\n    if (NULL == ptr || pnode == nullptr)return false;\n    ptr->next = pnode->next;\n    free(pnode);\n    plist->cursize -= 1;\n    return true;\n}\nvoid Pop_Front(LinkList* plist)//头删法\n{\n    Erase_Next(plist, plist->head);\n}\nvoid Pop_Back(LinkList* plist)//尾删法\n{\n    ListNode* pnode = FindPrevNode_Pos(plist, plist->cursize);\n    Erase_Next(plist, pnode);\n}\n```\n\n# 双链表\n\n```c\n//My_DuLinkList.h\n#ifndef MY_DULINKLIST_H\n#define MY_DULINKLIST_H\ntypedef int ElemType;\ntypedef struct DuLNode\n{\n    struct DuLNode* prev;\n    struct DuLNode* next;\n    ElemType data;\n}DuLNode,*PDuLNode;\ntypedef struct\n{\n    PDuLNode head;\n    int cursize;\n}DuLinkList;\nDuLNode* Buynode();\nvoid Freenode(DuLNode* p);\nvoid InitDuList(DuLinkList* plist);\nvoid ClearDuList(DuLinkList* plist);\nvoid DestroyDuList(DuLinkList* plist);\nint GetSize(const DuLinkList* plist);\nbool IsEmpty(const DuLinkList* plist);\nbool Insert_Prev(DuLinkList* plist, DuLNode* ptr, ElemType val);\nvoid Push_Front(DuLinkList* plist, ElemType val);\nvoid Push_Back(DuLinnkList* plist, ElemType val);\nbool Erase(DuLinkList* plist, DuLNode* ptr);\nvoid Pop_Front(DuLinkList* plist);\nvoid Pop_Back(DuLinkList* plist);\nvoid Remove(DuLinkList* plist, ElemType val);\nvoid RemoveAll(DuLinkList* plist, ElemType val);\nvoid PrintDuList(const DuLinkList* plist);\nDuLNode* FindValue(const DuLinkList* plist, ElemType val);\nDuLNode* FindPos(const DuLinkList* plist, int pos);\n#endif\n```\n\n```c\n//My_DuLinkList.cpp\n#include<stdlib.h>//malloc free\n#include<string.h>//memset\n#include<stdio.h>//printf scanf\n#include\"My_DuLinkList.h\"\n#include<assert.h>\nDuLNode* Buynode()\n{\n    DuLNode* s = (DuLNode*)malloc(sizeof(DuLNode));\n    if(NULL==s)exit(1);\n    memset(s,0,sizeof(DuLNode));\n    return s;\n}\nvoid Freenode(DuLNode* p)\n{\n    free(p);\n}\nvoid InitDuList(DuLinkList* plist)\n{\n    assert(plist !=NULL);\n    plist->cursize = 0;\n    plist->head = Buynode();\n    plist->head->prev = plist->head;\n    plist->head->next = plist->head;\n}\nvoid PrintDuList(const DuLinkList* plist)\n{\n    assert(plist!=NULL);\n    DuLNode* pnode = plist->head->next;\n    while(pnode!=plist->head)\n    {\n        printf(\"%d \",pnode->data);\n        pnode = pnode->next;\n    }\n    printf(\"\\n\");\n}\nint GetSize(const DuLinkList* plist)\n{\n    assert(plist!=NULL);\n    return plist->cursize;\n}\nbool IsEmpty(const DuLinkList* plist)\n{\n    assert(plist != NULL);\n    return Getsize(plist)==0;\n}\nDuLNode* FindValue(const DuLinkList* plist, ElemType val)\n{\n    assert(plist!=NULL);\n    DuLNode* pnode = plist->head->next;\n    while(pnode!=plist->head&&pnode->data!=val)\n    {\n        pnode = pnode->next;\n    }\n    if(plist->head == p)pnode = NULL;\n    return pnode;\n}\n//插到节点ptr的前驱\nbool Insert_Prev(DuLinkList* plist, DuLNode* ptr, ElemType val)\n{\n    assert(plist!=NULL);\n    if(ptr==NULL)return false;\n    DuLNode* s = Buynode();\n    \n    s->prev = ptr->prev;\n    s->next = ptr;\n    ptr->prev->next = s;\n    ptr->prev = s;\n    /*第二种写法\n    s->prev = ptr->prev;\n    s->next = ptr;\n    ptr->prev = s;\n    s->prev->next = s;\n    */\n    /*第三种写法\n    \t//先处理next\n    s->next = ptr;\n    s->prev->next = s;\n    \t//后处理prev\n    s->prev = ptr->prev;\n    ptr->prev = s;\n    */\n    \n    s->data = val;\n    plist->cursize++;\n    return true;\n}\nvoid Push_Front(DuLinkList* plist, ElemType val)\n{\n    assert(plist!=NULL);\n    Insert_Prev(plist, plist->head->next, val);\n}\nvoid Push_Back(DuLinnkList* plist, ElemType val)\n{\n    assert(plist!=NULL);\n    Insert_Prev(plist, plist->head, val);\n}\nbool Erase(DuLinkList* plist, DuLNode* ptr)\n{\n    assert(plist!=NULL);\n    if(ptr==NULL)return false;\n    ptr->prev->next = ptr->next;\n    ptr->next->prev = ptr->prev;\n    Freenode(ptr);\n    plist->cursize--;\n    return true;\n}\nvoid Pop_Front(DuLinkList* plist)\n{\n    assert(plist!=NULL);\n    if(!IsEmpty(plist))\n    {\n        Erase(plist,plist->head->next);\n    }\n}\nvoid Pop_Back(DuLinkList* plist)\n{\n    assert(plist!=NULL);\n    if(!IsEmpty(plist))\n    {\n        Erase(plist,plist->head->prev);\n    }\n}\nvoid Remove(DuLinKList* plist, ElemType val)\n{\n    assert(plist!=NULL);\n    Erase(plist, FindValue(plist, val));\n}\nvoid RemoveAll(DuLinkList* plist, ElemType val)\n{\n    \n}\nvoid ClearDuList(DuLinkList* plist)\n{\n    assert(plist != NULL);\n    while(!Empty(plist))\n    {\n        Pop_Front(plist);\n    }\n}\nvoid DestroyDuList(DuLinkList* plist)\n{\n    assert(plist!=NULL);\n    ClearDuList(plist);\n    Freenode(plist->head);\n}\nDuLNode* FindPos(const DuLinkList* plist, int pos)\n{\n    assert(plist!=NULL);\n    \n}\n```\n\n\n\n```c\n//test.cpp\n#include<assert.h>\n#include<string.h>\n#include\"My_DuLinkList.h\"\nint main()\n{\n    int ar[] = {12,23,34,45,56,67,78,89,90,100};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    DuLinkList mylist;\n    InitDuList(&mylist);\n    for(int i = 0;i<n;++i)\n    {\n        Push_Back(&mylist);\n        PrintDuList(&mylist);\n    }\n}\n```\n\n","categories":["C"]},{"title":"C语言_数据类型_浮点型","url":"/C/C语言_数据类型_浮点型/","content":"# 课件\n\n![image-20210818232054410](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818232054410.png)\n\n![image-20210818232259910](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818232259910.png)\n![image-20210818232907404](../../images/C数据类型/image-20210818232907404.png)\n\n![image-20210818231225754](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231225754.png)\n\n![image-20210818231301755](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231301755.png)\n![image-20210818231320838](../../images/C数据类型/image-20210818231320838.png)\n![image-20210818231341094](../../images/C数据类型/image-20210818231341094.png)\n![image-20210818231554889](../../images/C数据类型/image-20210818231554889.png)\n![image-20210818231457059](../../images/C数据类型/image-20210818231457059.png)\n\n![image-20210818231917144](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231917144.png)\n\n# 二进制\n\n二进制怎么转换为十进制？`0101  ->  5`\n\n```\n次数：  3  2  1  0\n权值：  0  1  0  1\n  0 + 1 * 2^2 + 0 + 1 * 2^0\n= 0 +   4     + 0 +    1\n= 5\n```\n\n十进制怎么转换为二进制？`5   ->  101`\n\n```\n    2  | 5                     \n       ---------               _\n      2  | 2   ......     1   /|\\    后3位\n         ---------             |\n        2  | 1   .....    0    |     后2位\n            -------            |\n              0   ......  1    |     后1位\n```\n\n## 负数怎么表示\n\n以下均是在4位机下讨论\n\n负5？\n\n`5 + x = 0 -> 0101 + x = 0 -> 0101 + 1010 = 1111, 1111 + 1 = 0, x = 1010 + 1 = 1011`\n\n负数用补码表示，是原码的反码加1。\n\n负8？\n\n先求8的原码的反码，再加1：`8: 1000 -> 0111 + 1 -> 1000`\n\n负8的补码居然是它自己？\n\n搞了半天发现，我们一开始就说明了，在4位机下讨论，那么有符号数的范围只有`-8 ~ 7`，根本就不存在8一说。所以，无法求得8的原码，也因此无法求8的补码。（为什么1000不能代表8的原码？因为有符号数中第一位代表符号位！）\n\n## 16进制\n\n```\n    0101 1100\n     5    C\n   => 0x5C\n```\n\n数字字面常量的规则：只要第一位是数字，那么代表这是个数字。而0开头的数字，不带x的是8进制（`0___`），带x的是16进制（`0x___`），带b的是2进制（`0b___`）。\n\n16进制的格式化输出的描述符为`%x`，代表`unsigned hexadecimal integer`，是无符号十六进制整型。\n\n```c\nint main()\n{\n    unsigned char ucVal = 0x5cu;//0x5c是数字，u是无符号指示\n    printf(\"%hhu\\n\", ucVal);    //92\n    printf(\"%hhx\\n\", ucVal);    //5c\n}\n```\n\n### 8进制\n\n8进制的格式化输出的描述符为`%o`，代表`unsigned octal`，是无符号8进制数。\n\n```\n    01 011 100\n     1   3   4\n   => 0134\n```\n\n```c\nint main()\n{\n    unsigned char ucVal = 0134u;//0134是数字，u是无符号指示\n    printf(\"%hhu\\n\", ucVal);    //92\n    printf(\"%hho\\n\", ucVal);    //134\n}\n```\n\n### 2进制\n\n输出2进制：需要把C语言设置为17标准。\n\n2进制没有格式化输出的描述符。\n\n```\n       0101 1100\n => 0b 0101 1100\n```\n\n```c\nint main()\n{\n    unsigned char ucVal = 0b0101'1100u; // '为分割符号，便于人性化输入，可有可无\n    printf(\"%hhu\\n\", ucVal);    //92\n    printf(\"%hho\\n\", ucVal);    //134\n}\n```\n# integer\n\n32 bits, 4 Bytes\n\n1. 区分有符号、无符号，其中有符号的`signed`可以省略；无符号带int的整型的int可以省略，其他无符号整型不能省；long int中的int可以省略\n2. 字面常量（8、8u）也是有类型的，不带后缀默认是有符号数，带u是无符号数。\n\n## long int\n\nISO标准中提到，long int的大小不得小于int。目前微软long int的大小为32bits、4字节；而在Linux下为64bits、8字节。\n\nlong指示类型的长度，涉及到长度，格式化输出时，需要注意加上length specifiers，即长度描述符。\n\n## long long int\n\n64bits、8字节\n\n## short int\n\n16bits、2字节\n\n针对于整型字面常量的长度描述符没有专门用于short的，因为C语言字面常量最小为32位。如果比32位小的，一律向下兼容。归根结底是因为数据总线最少一次传32位。\n\n但是，针对于printf中的格式化输出，还是要区分长度的，对应short的长度描述符为h。\n\n## char\n\n如果要打印十进制整数，那么对应char的长度描述符为`hh`。格式描述符为`i`或`u`。\n\n而如果要打印字符，那么对应的格式描述符为`c`。\n\nASCII码：形式上是字符图形，但本质上是整数，如`'a'`是97。\n\n## 整型类测试\n\n```c\nint main()\n{\n    /* integer: 32bits */\n    /*signed*/ int iVal = 8;\n    unsigned /*int*/ uVal = 8u;\n    printf(\"%i\\n\", iVal);\n    printf(\"%u\\n\", uVal);\n    /* long int: 32bits */\n    /*signed*/ long /*int*/ lVal = 9l;\n    unsigned long /*int*/ ulVal = 9ul;\n    printf(\"%li\\n\", lVal);\n    printf(\"%lu\\n\", ulVal);\n    /* long long int: 64bits */\n    /*signed*/ long long /*int*/ llVal = 9ll;\n    unsigned long long /*int*/ ullVal = 9ull;\n    printf(\"%lli\\n\", llVal);\n    printf(\"%llu\\n\", ullVal);\n    /* short int: 16bits */\n    /*signed*/ short /*int*/ sVal = 9; //9后面没有专门用于short的长度指示符\n    /*unsigned*/ short /*int*/ usVal = 9u;\n    printf(\"%hi\\n\", sVal);             //但是格式化输出有，要加上h\n    printf(\"%hu\\n\", usVal);\n    /* char: 8bits */\n    /*signed*/ char cVal = 9;\n    unsigned char ucVal = 9u;\n    printf(\"%hhi\\n\", cVal);\n    printf(\"%hhu\\n\", ucVal);\n    unsigned char ucVal2 = 'a';\n    printf(\"%c\\n\", ucVal2);\n}\n```\n\n# 浮点型\n\n计算机中整型和浮点型的计算是在不同的处理器下完成的。整型处理器是由x86部分完成的，浮点型处理器是由x87部分完成的。因为整型和浮点型的格式是不一样的。\n\n> 小数默认都是有符号数。\n\n1010.1101二进制小数化为十进制小数。依然按照每一位的权重展开计算：\n$$\n\\begin{align}\n& 1\\times2^3+0\\times2^2+1\\times2^1+0\\times2^0+1\\times2^{-1}+1\\times2^{-2}+0\\times2^{-3}+1\\times2^{-4}\\\\\n& =8+2+\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{16}\\\\\n& =10.8125\n\\end{align}\n$$\n10.8125十进制小数如何化为二进制小数？整数部分是一直进行余2运算，而小数部分如何化？即0.1101。\n$$\n\\begin{align}\n0.8125\\times2&=1.625\\cdots1\\\\\n0.625\\times2&=1.250\\cdots1\\\\\n0.25\\times2&=0.500\\cdots0\\\\\n0.5\\times2&=1.000\\cdots1\\\\\n&end\n\\end{align}\n$$\n与求整数的二进制不同，求余之后，整数二进制的结果从下往上顺位。而小数二进制是从上往下顺位。\n\n0.13化为二进制小数时会遇到无限循环的现象：\n$$\n\\begin{align}\n0.13\\times2&=0.26\\cdots0\\\\\n0.26\\times2&=0.52\\cdots0\\\\\n0.52\\times2&=1.04\\cdots1\\\\\n0.04\\times2&=0.08\\cdots0 -- cycle\\\\\n0.08\\times2&=0.16\\cdots0\\\\\n0.16\\times2&=0.32\\cdots0\\\\\n0.32\\times2&=0.64\\cdots0\\\\\n0.64\\times2&=1.28\\cdots1\\\\\n0.28\\times2&=0.56\\cdots0\\\\\n0.56\\times2&=1.02\\cdots1\\\\\n0.02\\times2&=0.04\\cdots0\\\\\n0.04\\times2&=0.08\\cdots0 -- cycle\\\\\n&\\cdots\n\\end{align}\n$$\n\n## float（单精度）\n\n全称：single point float，单精度浮点数。32 bits, 4 Bytes\n\n格式描述符用`f`。代表十进制浮点数（Decimal floating point）\n\n```c\nint main()\n{\n    float fVal = 5.0f;   //加f后缀指示其为float类型字面常量\n    printf(\"%f\\n\", fVal);\n}\n```\n\n## double（双精度）\n\n全称：double point float，双精度浮点数。64 bits, 8 Bytes\n\n格式描述符也是用`f`。代表十进制浮点数（Decimal floating point）\n\n```c\nint main()\n{\n    double dVal = 5.0;  //字面小数常量不加后缀，默认为double类型\n    printf(\"%f\\n\", dVal);\n}\n```\n\n## long double\n\nModern Cpp和新的C标准才有的。标准指出long double长度不得小于double。在微软编译器下等于double长度，有些编译器是大于double长度的。为什么微软如此保守呢？因为CPU的字长一般还是64位。如果大小设计超过64位的话，就需要两个时钟周期来完成数据的传输。\n\n需要注意，long double的格式描述符依旧为`f`，`%`后面的长度描述符不再是`l`而是大写的`L`。而字面常量的后缀还是小写的`l`。\n\n```c\nint main()\n{\n    long double ldVal = 5.0l; // 加l后缀\n    printf(\"%Lf\\n\", ldVal);   // 加L前缀，格式描述符\n}\n```\n\n## 科学计数法\n\n651.32怎么表示（字面常量）？\n\n1. `651.32`\n2. `6.52132e+2`，其中`+`可以省略\n\n科学计数法的格式描述符为`e`或`E`。表示：Scientific notation (mantissa/exponent), lowercase/uppercase\n\n0.065132呢？`6.5132e-2`\n\n```c\nint main()\n{\n    double dVal = 6.52132e+2;\n    printf(\"%f\\n\", dVal); // 652.132000\n    printf(\"%e\\n\", dVal); // 6.521320e+02\n    printf(\"%E\\n\", dVal); // 6.521320E+02\n}\n```\n\n## float内存结构（IEEE754标准）\n\nIEEE754标准。所有处理器，无论手机上的ARM架构还是服务器处理器都是遵循这个标准。\n\n三部分：sign（符号位）、exponent（指数）、mantissa（底数）\n### sign（符号位）\nsign（符号位） - 1 bit - 1代表负，0代表正\n### exponent（指数）\n\n首先，指数是一个有符号数。\n负数，是补码表达的。八位二进制来说，0000 0000表示0，则 1111 1111表示-1，1000 0000表示-128，0111 1111表示127，这是有符号正数的最大值，再加1就溢出了。本来的范围是：`-128 ~ 127`\n但是，浮点数中指数位置存储的是偏移值，如果是float，存储的值是加了127的。因此，指数为1时，应该存储`1 + 127 = 128`，存储`1000 0000`；指数为2时，应该存储`2 + 127 = 129`，存储`1000 0001`。因此，加127后，范围就变成了：`-1 ~ 254`。\n而指数全0、全1，在浮点数中有特殊含义。所以，范围就变成了：`1 ~ 254`。减去127之后，实际的范围就变成了：`-126 ~ 127`。\n\n举一个例子：`7.25`怎么表示？先转化为二进制：`0111.01`，带权的形式则是：`1.1101 * 2^2`，即右移2位，指数为2。\n实际存储的二进制形式：\n```\n0     1000 0001            (1)110 1000 0000 0000 0000 0000`\n符   指数位（2+127=129）    底数位（23位）前面有个隐藏的1，不在这23位中\n```\n\nexponent（指数） - 8 bits - 标准里规定：\n\n在exp位模式（the bit pattern of exp）既不全为0，也不全为1时，浮点数值为**规格化的值**。\n阶码字段在这种情况下，被解释为以偏置（biased）形式表示的**有符号整数**（原文：the exponent field is interpreted as representing a signed integer in *biased* form）。\n那么，阶码字段的值为：$E = e - Bias$。\n其中$e$是无符号数，即直接通过exp位模式计算得出。\n$Bias$是一个固定值$2^{k-1}-1, k = exp的位数, 单精度下是8位, 双精度下是11位$。比如，float，指数二进制位数为8位时，Bias就是128-1=127。\n单精度下$Bias=2^7-1=127$。\n因此$E$范围：$(1-127)\\sim(254-127)=-126\\sim127$，表示在2进制下可以右移127位、左移126位。\ne和最终的移位值之间的对应关系：`1 = -126`、`2 = -125`，...，`253 = 126`、`254 = 127`。\n\n> 由此，看出，不能简单地把exp位模式看做有符号数直接计算得到移位数值，如果直接当做有符号数计算的话，范围变成了：`1000'0000 ~ 0111'1111 = -128 ~ 127`。和标准规定的对应不上！\n\n为什么要预留出来exp位模式全0或全1的情况？\n1. **全0是为了能让浮点数可以表示0或者表示非常接近于0.0的数**。此情况在标准中称为：“**非规格化**的值”。这种情况下，阶码值（移位值）规定为$E=1-Bias$。并且要特别注意：底数的值是位模式直接计算出来的，也就是小数字段的值，不包含隐含的开头的1。即：`0.XXXX`，不再是`1.XXXX`！\n\n>使阶码值为$1-Bias$而不是简单的$-Bias$​似乎是违反直觉的。但是这种方式提供了一种从非规格化值平滑转换到规格化值的方法。\n\n2. 非规格化数有两个用途。首先，它们提供了一种表示数值0的方法，因为使用规格化数，我们必须总是使$M\\geq1$，因此就不能表示0。实际上，$+0.0$的浮点表示的位模式为全0：符号位是0，阶码字段全为0（表明是一个非规格化值），而小数域也全为0，这就得到$M=f=0$。令人奇怪的是，当符号位为1，而其他域全为0时，我们得到值$-0.0$。根据IEE的浮点格式，值$+0.0$和$-0.0$在某些方面被认为是不同的，而在其他方面是相同的。\n3. 非规格化数的另外一个功能是表示那些非常接近于$0.0$的数。这提供了一种属性，称为逐渐溢出（gradual underflow），其中，可能的数值分布均匀地接近于$0.0$。而刚才提到的使阶码值为$1-Bias$而不是简单的$-Bias$，就是为这个做铺垫的！**详看CSAPP-3rd P80**。\n4. 全1是为了能让浮点数表示\n     1. 无穷大 - 底数全0时\n     2. NaN - 底数非0时\n### mantissa（底数）\n4. mantissa（底数） - 23 bits - 范围、**精度**：$\\lg 2^{24} \\approx 7.2247$，即可以表示7位十进制数。\n    1. 因为要用科学计数法，底数第一位必须是1，因此可以省略第一位。因此此处的23位可以表达24位二进制数。\n\n7.25的IEEE754表示：\n\n`0 1000'0001 110'1000'0000'0000'0000'0000`\n\n## 浮点数的好处\n\n1. 虽然精度小，但是可表示的范围大（指数的作用）。\n2. 能表达实数（除了小数，也能表示整数、0）\n3. 能表达NaN（Not A Number），0除以0的结果就是NaN。\n    1. `0 1111'1111 100'0000'0000'0000'0000'0000`\n4. 能表达正负inf（无穷大），比如1除以0。\n    1. 正无穷：`0 1111'1111 000'0000'0000'0000'0000'0000`\n    2. 负无穷：`1 1111'1111 000'0000'0000'0000'0000'0000`\n## 怎么比较浮点数\n### 首先是不带等号的大小判断（<、>）\n- 对于 `a < b`、`a > b` 这种​**​大小关系比较​**​，通常可以​**​安全地直接使用运算符​**​。\n- 因为即使存在微小的舍入误差，只要这个误差不足以改变大小关系的本质（即误差远小于 `a` 和 `b` 本身的差值），结果就是正确的。\n- 判断 `a` 是否严格大于 `b` 时，应该使用 `a > b`，而不是 `!(a <= b)`（后者涉及相等判断，不精确）。\n### 特殊值的比较\n- 特殊值如 `NaN` (Not a Number) 与任何值（包括自己）比较，`==` 都返回 `false`，`!=` 都返回 `true`。必须用专门的函数检查：\n    - Python: `math.isnan(x)`\n    - C/C++: `isnan(x)` (来自 `math.h` 或 `cmath`)\n    - Java: `Double.isNaN(x)` / `Float.isNaN(x)`\n- 检查无穷大：\n    - Python: `math.isinf(x)`\n    - C/C++: `isinf(x)`\n    - Java: `Double.isInfinite(x)` / `Float.isInfinite(x)`\n### 涉及到两个浮点数是否相等时\n**绝对不能直接用 `==` 或 `!=` 来判断两个浮点数是否“相等”！​**​ \n因为浮点数在计算机内部使用 IEEE 754 标准以二进制存储小数，很多十进制小数无法精确表示（例如 `0.1`），计算过程中也会积累微小的舍入误差。\n正确的比较方法是​**​允许一定的误差范围（容差 epsilon）​**​：\n1. ​**​检查近似相等 (Approximate Equality)：​**​\n    - 计算两个浮点数 `a` 和 `b` 的绝对差值：`diff = abs(a - b)`\n    - 定义一个非常小的正数作为容忍度 `epsilon`（例如 `1e-9`, `1e-12`, 具体值取决于你的精度要求）。\n    - 如果 `diff <= epsilon`，则认为 `a` 和 `b` 在 `epsilon` 的误差范围内是“相等”的。\n    - 但是这个容差是绝对容差，有缺陷，见下：\n- **检查相对相等 (Relative Equality - 更稳健)：​**​\n    - 当数值大小差异巨大时，固定绝对容差可能不合适（比如比较 1e9 和 1e9+1e-9 时差值很小，但比较 1e-9 和 2e-9 时用绝对容差 1e-9 会认为相等）。相对容差考虑数值的大小。\n    - `rel_tol`: 相对容差（如 1e-5, 1e-9）\n    - `abs_tol`: 绝对容差下限（保证接近零的数也能比较，例如设为 `1e-12`）\n\n下面主要论述，为什么需要相对相等（使用相对容差）\n\n直接使用绝对相等的容差（比如 `abs(a - b) <= 1e-9`）在大多数情况下是有效的。但是，它有一个显著的缺点：当比较的数值本身非常大或者非常小（靠近零）时，这个固定大小的绝对容差就显得不合理了。\n\n1. ​**​问题场景一：数值巨大​**​\n    \n    - 例子：比较 `a = 1, 000, 000, 000 (1e9)` 和 `b = 1, 000, 000, 001 (1e9 + 1)`\n    - 它们的绝对差是 `|a - b| = 1`。\n    - 如果你设定的绝对容差 `epsilon = 1e-9`（即 0.000000001），那么 `1 > 1e-9`，程序会判断它们​**​不相等​**​。\n    - 但直觉上，10亿和10亿零1之间的_相对误差_非常小（大约是 `1 / 1e9 = 1e-9`）。在很多科学计算或工程领域，这个精度已经足够了，我们可能希望认为它们_相对相等_。\n    - ​**​结论：​**​ 当数值本身很大时，一个固定的小绝对容差过于严格，忽略了数值的量级。\n2. ​**​问题场景二：数值极小（接近零）​**​\n    \n    - 例子：比较 `a = 0.000001 (1e-6)` 和 `b = 0.000002 (2e-6)`\n    - 它们的绝对差是 `|a - b| = 0.000001 (1e-6)`。\n    - 如果你设定的绝对容差 `epsilon = 1e-9`（即 0.000000001），那么 `1e-6 > 1e-9`，程序会判断它们​**​不相等​**​。\n    - 但是，它们的相对差非常大（一个是另一个的两倍，相对误差高达 `1e-6 / 1e-6 = 1` 或 100%）。实际上，它们_不应_被看作是近似相等的。\n    - ​**​结论：​**​ 当数值本身很小时，一个固定的小绝对容差又过于宽松，可能把差别很大的两个数判断为相等。\n    - ​**​更麻烦的问题：比较接近零的数​**​\n        - 例子：比较 `a = 0.000000001 (1e-9)` 和 `b = 0.000000002 (2e-9)`\n        - 绝对差 `|a - b| = 1e-9`，如果我们设定的绝对容差也是 `1e-9`，那么程序会认为它们相等。\n        - 例子：比较 `a = 1e-20` 和 `b = 2e-20`\n        - 绝对差 `|a - b| = 1e-20`。一个合理的绝对容差（比如 `1e-9`）远远大于这个差值（`1e-9 > 1e-20`），所以程序也会认为它们相等。但从相对角度看，`b` 是 `a` 的两倍！\n        - ​**​总结：​**​ 对于非常接近零的数，即使设置了一个看似很小的绝对容差，也可能过于宽松，无法反映数值之间的真实相对误差。这时甚至需要一个更小的、不切实际的绝对容差才能区分它们，而相对相等可以自然地处理这种情况（此时相对误差会很大）。\n\n​**​相对相等的解决方案：引入相对容差​**​\n\n相对相等的核心思想是：​**​判断两个数是否近似相等的标准，应该与它们自身的_大小_有关。​**​\n\n1. ​**​核心公式：​**​\n    \n    `abs(a - b) <= max(rel_tol * max(|a|, |b|), abs_tol)`\n    \n    - `rel_tol`: ​**​相对容差（relative tolerance）​**​。这是一个很小的正数，表示你能接受的_最大相对误差_（例如 `0.01` 表示 1% 的相对误差，`1e-5` 表示 0.001% 的相对误差，`1e-9` 表示极小的相对误差）。这个值需要根据你的具体应用场景（你对精度的要求）来设定。\n    - `abs_tol`: ​**​绝对容差下限（absolute tolerance）​**​。这也是一个很小的正数（例如 `1e-12`）。它的作用是确保当 `a` 和 `b` 都_非常非常接近零_时，公式仍然有效。\n2. ​**​公式解读：​**​\n    \n    - `max(|a|, |b|)`: 取 `a` 和 `b` 的绝对值中较大的那个。这代表了参与比较的两个数在数值上的大致_量级（Scale）_。\n    - `rel_tol * max(|a|, |b|)`: ​**​动态计算的相对容差​**​。这个容差会根据 `a` 和 `b` 的当前量级自动调整：\n        - 当 `a` 和 `b` 很大时，这个值会变大，可以容忍较大的绝对差值（只要相对误差小）。\n        - 当 `a` 和 `b` 很小时（但还没有小到必须依赖 `abs_tol`），这个值会变小，要求更小的绝对差值才能被视为相等。\n    - `max( ..., abs_tol)`: 取 `动态计算的相对容差` 和 `abs_tol` 中​**​较大的那个​**​作为最终的容差阈值。\n        - 当 `a` 和 `b` 远离零时，`动态计算的相对容差` 通常会远大于 `abs_tol`，所以`max` 的结果就是相对容差。\n        - 当 `a` 和 `b` 非常接近零（或者其中一个为零）时，`动态计算的相对容差` (`rel_tol * max(|a|, |b|)`) 会变得非常小（接近于零）。如果此时没有 `abs_tol`，即使两个非常接近零但彼此不同的数（比如 `1e-20` 和 `2e-20`，差值 `1e-20`），也会因为 `1e-20` > `某个几乎为零的动态相对容差` (比如 `1e-9 * 2e-20 = 2e-29`) 而被错误地认为_不相等_（而实际上根据相对误差，它们差异很大）。更极端的是比较 `0` 和一个很小的数（比如 `1e-30`），`动态计算的相对容差` 会变成 `0`，没有 `abs_tol` 就无法进行有效比较。加入 `abs_tol` 提供了这个绝对下限。\n        - `abs_tol` 就是为了确保在这种情况下，公式不会因为 `动态计算的相对容差` 太小而失效。它会提供一个最低限度的绝对容差保证（比如 `1e-12`）。如果 `|a - b| <= abs_tol`，即使 `a` 和 `b` 本身很小（导致 `rel_tol * max(|a|, |b|)` 更小），也能认为它们在绝对意义上足够接近零。\n3. ​**​举例说明：​**​\n    \n    - ​**​情况一：大数值（相对容差主导）​**​\n        - `a = 1e9`, `b = 1e9 + 1000` (`|a-b|=1000`)\n        - 设 `rel_tol=1e-6`, `abs_tol=1e-9`\n        - `max(|a|,|b|) ≈ 1e9`\n        - `动态相对容差 = 1e-6 * 1e9 = 1000`\n        - `max(1000, 1e-9) = 1000`\n        - `1000 (|a-b|) <= 1000 (阈值)` → ​**​相对相等（成立）​**​\n    - ​**​情况二：中等数值（相对容差主导）​**​\n        - `a = 3.141592`, `b = 3.141593` (`|a-b|=0.000001`)\n        - 设 `rel_tol=1e-6`, `abs_tol=1e-9`\n        - `max(|a|,|b|) ≈ 3.1416`\n        - `动态相对容差 ≈ 1e-6 * 3.1416 ≈ 3.1416e-6`\n        - `max(3.1416e-6, 1e-9) ≈ 3.1416e-6`\n        - `0.000001 (1e-6) ≈ 1e-6 < 3.1416e-6 (阈值)` → ​**​相对相等（成立）​**​\n        - 注意：如果只用 `abs_tol=1e-9`，`1e-6 > 1e-9`，会被判为不相等。相对容差（`≈ 3e-6`）更合理。\n    - ​**​情况三：小数值（绝对容差主导）​**​\n        - `a = 1e-10`, `b = 2e-10` (`|a-b|=1e-10`)\n        - 设 `rel_tol=1e-6`, `abs_tol=1e-12`\n        - `max(|a|,|b|) = 2e-10`\n        - `动态相对容差 = 1e-6 * 2e-10 = 2e-16` (非常小！)\n        - `max(2e-16, 1e-12) = 1e-12` (因为 `1e-12` 远大于 `2e-16`)\n        - `1e-10 (|a-b|) <= 1e-12`? ​**​1e-10 > 1e-12​**​ → ​**​不相等（成立）​**​\n            - _解释：_ 虽然它们很小（都在 `1e-10` 量级），但`b`是`a`的2倍！相对误差极大。绝对容差 `1e-12` 无法容忍 `1e-10` 这么大的差，所以正确判定不相等。动态相对容差 `2e-16` 在这里太小而没起作用，`abs_tol` `1e-12` 提供了合适的判断依据。\n    - ​**​情况四：非常接近零（绝对容差主导）​**​\n        - `a = 0`, `b = 1.5e-12`\n        - 设 `rel_tol=1e-6`, `abs_tol=1e-12`\n        - `max(|a|,|b|) = 1.5e-12`\n        - `动态相对容差 = 1e-6 * 1.5e-12 = 1.5e-18` (极其小！)\n        - `max(1.5e-18, 1e-12) = 1e-12`\n        - `1.5e-12 (|a-b|) <= 1e-12`? ​**​1.5e-12 > 1e-12​**​ → ​**​不相等（成立）​**​\n        - _想让它被判定为接近零（相等）：_\n            - 可以设置更大的 `abs_tol`，比如 `abs_tol=1.6e-12`\n            - `1.5e-12 <= 1.6e-12` → ​**​相对相等（成立）​**​\n    - ​**​情况五：相对容差和绝对容差都参与（通常发生在中等或较小数值）​**​\n        - 公式选取两者中较大的作为最终容差，确保在两种标准中满足其一即可视为相等。\n\n**在代码中使用：​**​\n\n在 Python 中，推荐使用标准库 `math.isclose`：\n```python\nimport math\n\nif math.isclose(a, b, rel_tol=1e-9, abs_tol=1e-12):\n    print(\"a and b are considered close\")\n```\n- `rel_tol`：相对容差，通常 `1e-9` 是一个较高的精度要求，`1e-6` 或 `1e-3` 可能用于精度要求较低的领域。根据你的需求设定。\n- `abs_tol`：绝对容差下限，通常设置为一个非常小的数（如 `0.0`， `1e-12`, `1e-15`），或者当你知道要处理接近零的数时，设置成一个合适的、比“显著差异”要小的值（例如，如果你的数据精度极限是 `1e-10`，`abs_tol=1e-12` 可能就太小了，需要设成 `1e-9` 或更大，但这时最好通过相对容差来覆盖非零区域）。 `abs_tol` 最主要的作用是确保 `a` 和 `b` 都接近零时比较逻辑仍然工作。\n\n​**​总结：​**​\n\n相对相等 (`abs(a - b) <= max(rel_tol * max(|a|, |b|), abs_tol)`) 是一种更​**​稳健（Robust）​**​的浮点数近似相等判断方法。它通过结合​**​相对容差​**​（`rel_tol`）来解决大数值比较的问题，以及​**​绝对容差下限​**​（`abs_tol`）来解决非常接近零的数值比较的问题，从而在各种不同的数值量级上提供更合理、更一致的比较结果。在复杂应用中，优先考虑使用相对相等而不是简单的绝对容差相等。\n## 练习题\n\n### CSAPP-3rd P93 2.84\n\n```c\n填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数f2u返回一个无符号32位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是NaN。两种0，+0和一0被认为是相等的。\nint float_1e(float x, float y){\nunsigned ux=f2u(x);\nunsigned uy=f2u(y);\n/*Get the sign bits*/\nunsigned sx=ux >>31;\nunsigned sy=uy >>31;\n/*Give an expression using only ux，uy，sx，and sy*/\nreturn;\n}\n如果使用判断就比较简单，下面是不使用判断.\n第一个参数是否小于等于第二个参数，将可能满足的情况（即会返回1的情况）进行分类处理。\n情况一：两个参数相等且为0， 根据IEEE规则，0用Denormalized表示，且有+0(0x0)和-0(0x80000000)两种表示 所以通过左移一位来比较\n==>ux << 1 == 0 && uy << 1 == 0\n情况二：第一个参数为负(此时ux>>31为sx=0x1得到!sx=0) ，第二个参数为0或者正数(此时uy>>31为sy=0x0 !sy=1)\n==>(sx && !sy)\n反之，若第一个参数为正或者0， 第二个参数为负，这种情况肯定返回0，就不需要特殊处理。\n情况三：两个参数都为正\n==>(!sx && !sy && ux <= uy)\n情况四：两个参数都为负，此时根据IEEE的定义 正数可以用无符号整数的升序进行排列（正数越大 无符号数越大） 负数可以用无符号整数的升序进行排列（负数越小，无符号数越大）\n==>(sx && sy && ux >= uy)\n四种情况或运算,满足一种就返回1。\n```\n### 讨论题\n下列哪些浮点数是符合标准的？`1.e0`、`1.2e0`、`.2e0`、`123`、`1e0`、`2e4.2`、`1.2`、`.e5`\n​​`2e4.2`：不符合​。指数部分 (`e4.2`) 包含了小数点 `.`。指数必须是一个​**​整数​**​（可正可负，如 `4`, `-2`, `+10`）。\n`.e5`：​​不符合​。尾数部分 `.e5` 缺少有效的数字。前面只有小数点 `.` 而没有跟随任何数字。必须在小数点前后至少有一方包含数字（如 `.1`, `1.`, `1.2`, `1e5`）。\n# 两道诡异的题目\n\n```c\nint main()\n{\n    char a = 100;\n    char b = 200;\n    char c = a + b;\n    printf(\"%d %d\\n\", c, a+b);\n}\n//输出结果为44 44\n```\n\na和b同为8位有符号整型类数据。直接加和，a+b等于300。a和b都是char型，最后得出的结果也是char型：因为溢出了8位的最大范围（0~255），所以需要模256，最终300转换后的结果等效于44。\n\n44是存储在内存中的数据，最终显示给人类的还是44，因为44没有超过127，也就不用涉及到补码来表示负数。（反之的情况，如果模后的结果是128，则表示人类所看到的负数-128；如果模后的结果是255，则表示-1）\n\n既然a和b都是char型，最后得出的结果也是char型，所以\"c\"和\"a+b\"两者代表的意义是一样的，最终都是char型下的44。于是输出结果为44。\n\n上面的题目只是乐呵一下，下面的题目才诡异莫测，如果对计算机的底层运算法则、流程不详，那么是无法领会的。\n\n```c\nint main()\n{\n    unsigned char a = 100;\n    unsigned char b = 200;\n    char c = a + b;\n    printf(\"%d %d\\n\", c, a+b);\n}\n//输出结果为44 300\n```\n\n我们默认我们在x86体系架构下的、字长为32位的环境下运行。根据微机原理x86的描述，我们的通用寄存器有`eax/ebx/ecx/edx`。其中低16位叫做`ax/bx/cx/dx`。再分，低16位中的高8位叫做`ah/bh/ch/dh`、低8位叫做`al/bl/cl/dl`。\n\n经过测试，在VS2019编译器下，反汇编代码得出：`a+b`这个语句的运算首先要把a和b的值分别存放到寄存器`eax/ecx`中。注意：eax和ecx都是32位寄存器，**如果把a和b的值分别存放到寄存器eax/ecx中，意味着存放了原来的8位有效数据外，前面的24位都需要补位**，而无符号整型数据补前位时用0补位。\n存数据之后，对两数的加操作是：`add eax,ecx`。**即加操作是在寄存器内累加的**。那么即使300超过了255，本应溢出的数据仍然能有效保存在寄存器eax中（即关键的第9位——\"1\"）。\n\n接下来：\n\n**对于`char c = a + b`;**，对c的赋值是通过eax赋值的，因为声明了c是有符号char型，赋值时存在隐形类型转换，即要进行隐式的切片操作，将切除前24位，留下后8位。所以：这里编译器只把低八位即AL赋给了c。因此，上述的eax寄存器中关键的第9位——\"1\"失效了，只保留了后八位，最终打印c的结果是44。\n\n![image-20210818214251517](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818214251517.png)\n\n**对于`a + b`;**，a和b在eax寄存器中直接加和的结果是300，即使超过了255，本应溢出的数据仍然能有效保存在寄存器eax中（即关键的第9位——\"1\"）。而我们格式化控制的输出是`%d`，即我们要拿4个字节即**32位有符号整型**来识别内存的数据，**并在最后转为十进制数**，所以打印出来是300。（其实如果拿`%u`来打印更合适，即**32位无符号整型**来识别内存的数据，**并在最后转为十进制数**，最后打印出来也是300）\n\n## 习题\n\n```c\nint main()\n{\n    char c = 128;\n    unsigned char uc = 128;\n    unsigned short us = 0;\n    us = c + uc;\n    printf(\"%x \\n\",us);//0\n    \n    us = (unsigned char)c+uc;\n    printf(\"%x \\n\",us);//16:100->10:256\n    \n    us = c+(char)uc;\n    printf(\"%x \\n\",us);//2:1111 1111 1000 0000+1111 1111 1000 0000=>(1) 1111 1111 0000 0000 -> 16:ff00\n    \n    //同us = c + uc;原理一样，都是相当于把c存放到16位ax寄存器中，自然需要补位，而c原本是有符号数，则补符号位\"1\"。\n\t//强转为(unsigned short)就表示存放到16位ax寄存器中。其实我们不用人为地显式写出\"(unsigned short)\"，因为c+uc肯定需要达到统一类型，自然要把char c隐式转为unsigned short，即无符号16位数据。\n    us = (unsigned short)c+uc;\n    printf(\"%x \\n\",us);//1111 1111 1000 0000+0000 0000 1000 0000=>(1) 0000 0000 0000 0000 =>0 -> 16:0\n    \n    return 0;\n}//0 100 ff00 0\n```\n\n![image-20210818224646093](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224646093.png)\n\n![image-20210818224658042](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224658042.png)\n\n![image-20210818224711482](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224711482.png)\n\n![image-20210818224728892](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224728892.png)\n\n![image-20210818224743542](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224743542.png)\n\n# 高超的技艺\n\n```c\n//最拉跨的\nint Get1Bit(int x)\n{\n    int sum = 0;\n    while(x)\n    {\n        if(x & 0x01)\n        {\n            sum += 1;\n        }\n        x = x >> 1;\n    }\n    return sum;\n}\n//面试宝典中\n//老师不讲，学生永远不知道\nint Get1Bit(int x)\n{\n    int sum = 0;\n    while(x)\n    {\n        x = x &(x-1);\n        sum+=1;\n    }\n    return sum;\n}\n//查表方案\nint Get1Bit(int x)\n{\n    int ar[] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4};\n    int sum = 0;\n    for(int i = 0;i<sizeof(x)*2;++i)\n    {\n        sum = sum + ar[x & 0x0f];\n        x = x >> 4;\n    }\n    return sum;\n}\n```\n\n这个减1就与原数按位与，每次都会少个1。\n\n![image-20210823024356781](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823024356781.png)\n\n计算一个4字节整型的二进制格式中1的个数。\n\n有一位图论的学生，面试时通过此题进入了腾讯。\n\n![image-20210823021837556](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823021837556.png)\n\n![image-20210823021900711](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823021900711.png)\n\n![image-20210823021915500](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823021915500.png)\n\n# 断位\n\n```c\nstruct Node\n{\n    char a:4;\n    unsigned char b:3;\n    \n    unsigned char c:5;\n};\nint main()\n{\n    struct Node x={};\n    x.a = 4;\n    x.b = 2;\n    x.c = 5;\n}\n```\n\n# 刷题\n\n![image-20210921200013444](../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210921200013444.png)\n\n```c\nint getDecimalValue(struct ListNode* head)\n{\n    int res = 0;\n    struct ListNode* p = head;\n    while (p != NULL)\n    {\n        res = res << 1 | p->val;\n        p = p->next;\n    }\n    return res;\n}\n```\n\n","categories":["C"]},{"title":"C语言_结构体","url":"/C/C语言_结构体/","content":"# 本章内容\n\n1. 结构体类型的设计\n2. 结构体变量初始化\n3. 结构体成员访问\n4. 结构体与数组\n# 结构体类型的设计\n\nC 语言提供了基本数据类型，如 `char`, `short`, `int`, `float` 等类型，我们称之为内置类型。\n程序开发人员可以使用结构体来封装一些属性，设计出新的类型，在 C 语言中称为结构体类型。\n在 C 语言中，结构体是一种数据类型。（由程序开发者自己设计的类型）\n可以使用结构体（struct）来存放一组不同类型的数据。结构体的定义形式为：\n```c\nstruct 结构体名\n{\n    成员列表（可以是基本数据类型，指针，数组或其它结构类型）\n};\n```\n## 我们自己设计一个学生类型\n\n客观事物（实体）是复杂的，要描述它必须从多方面进行，也就是用不同的数据类型来描述不同的方面。如学生实体可以这样来描述：\n1. 学生学号（用字符串描述）\n2. 学生姓名（用字符串描述）\n3. 性别（用字符串描述）\n4. 年龄（用整型数描述）。\n这里用了2种不同数据类型，以及四个**数据成员**（data member）来描述学生实体。\n（数据成员，也可称之为属性，不能称之为函数中的变量概念）\n\n![image-20210815101308997](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210815101308997.png)\n# 结构体变量的定义和初始化\n\n既然结构体是一种数据类型，那么就可以用它来定义变量。结构体就像一个“模板”，定义出来的变量都具有相同的性质。\n也可以将**结构体比作“图纸”，将结构体变量比作“零件”**，根据同一张图纸生产出来的零件的特性都是一样的。\n**结构体是一种数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要存储空间**。\n## 结构体变量在内存中表示\n\n思考下述代码结构体在内存中的分配是A情况还是B情况？\n\n```c\nstruct Student\n{\n    char s_id[8];\n    char s_name[8];\n    char s_sex[4];\n    int s_age;\n};\nint main()\n{\n    int a = 10,b = 20;\n    struct Student s1 = {\"09001\",\"yhping\",\"man\",23};\n    return 0;\n}\n```\n\n![image-20210816155806100](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210816155806100.png)\n\n答案是A，即结构体成员的内存分布顺序是从上到下依次排列。为什么不是像a,b那样的顺序？\n\n我自己的解释：结构体的类型结构声明不像函数中变量的声明定义。我们要区分类型内部的成员和函数内部的变量，两者是截然不同的！结构体类型的抽象是一种类型，是由若干其他类型组成的一种新类型，那么类型内部的成员必然要按照我们在定义时的顺序从上到下分布内存空间，才符合程序设计的逻辑思路。按照如此规则如此分布，才能方便我们进行后续的给结构体变量初始化赋值，大括号内的值的顺序是按照成员顺序来的，而不是随意颠倒顺序，编译器是不会同意的。\n\n示例\n\n![image-20210815102046756](../../images/C语言_结构体/image-20210815102046756.png)\n如果把`char`数组改为指针：\n![image-20210815104639636](../../images/C语言_结构体/image-20210815104639636.png)\n## 结构变量初始化\n\n![image-20210815102137170](../../images/C语言_结构体/image-20210815102137170.png)\n\n大括号内的值的顺序是按照成员顺序来的，而不是随意颠倒顺序，编译器是不会同意的。\n\n![image-20210816162135598](../../images/C语言_结构体/image-20210816162135598.png)\n\n如果把char数组改为指针：\n\n这时按照上图的赋值方式，在VS2019中是不能通过的，因为，`\"09001\"`这种双引号引起来的字符串的类型是常量字符串型即`const char*`（要给`s_id`赋的值本质是字符串首字符`'0'`的指针，此指针只能读数据不能改数据，因此类型是`const char*`），与我们在结构体中声明的`char*`不匹配。\n\n## 结构体嵌套结构体\n\n![image-20210815104658804](../../images/C语言_结构体/image-20210815104658804.png)\n\n思考以下结构是否可行？\n\n```c\nstruct Student\n{\n    char s_name[8];\n    int s_age;\n    float score;\n    struct Student studx;\n};\t\t//sizeof(Student)是计算不出来的，因为如此定义会导致无穷的递归下去。不能被sizeof计算的类型因此也叫做不完整的类型。\n```\n\n![image-20210816181150361](../../images/C语言_结构体/image-20210816181150361.png)\n## 结构体链接结构体\n\n```c\nstruct Student\n{\n    char s_name[8];\n    int s_age;\n    float score;\n    struct Student* next;//如此定义才可行。\n};\t\t//sizeof(Student)==16\nint main()\n{\n    struct Node a,b,c;\n    struct Node* head = &a;\n    a.data = 10;\n    a.next = &b;\n    b.data = 20;\n    b.next = &c;\n    c.data = 30;\n    c.next = NULL;\n    \n    return 0;\n}\n```\n\n![image-20210816181426848](../../images/C语言_结构体/image-20210816181426848.png)\n如何使用循环打印？\n\n```c\nvoid Print_List(const struct Node* head)\n{\n    const struct Node* p = head;\n    while(p!=nullptr)\n    {\n        printf(\"%d \",p->data);\n        p = p->next;\n    }\n}\n```\n\n# 结构体成员的访问\n\n结构体变量的成员使用`.`访问。\n获取和赋值结构体变量成员的一般格式为：`结构体变量.成员名`；\n## 结构体变量成员的访问\n\n```c\n#include<stdio.h>\n#include<string.h>\nstruct Date\n{\n\tint year;\n\tint month;\n\tint day;\n};\nstruct Student stud1\n{\n\tchar s_name[20]; //姓名\n\tstruct Date birthday; //生日\n\tfloat score; //成绩\n};\nint main()\n{\n\tstruct Student stud1={\"Yhp\",2007,10,1,145.5};\n\tstruct Student stud2={\"Liuwuyang\",{2007,2,2},135.0};\n    \n\tint y = stud1.birthday.year;//用.访问结构体变量的成员\n    struct Student* sp = &stud1;\n    sp->s_name;//用->访问结构体变量指针对应的结构体变量的成员\n    (*sp).s_name;//用.访问结构体变量的成员\n    sp->birthday.year;//前sp是指针，后birthday是结构体，所以前用->后用.\n    \n\treturn 0;\n}\n```\n\n## 结构体变量（的成员）的赋值\n\n对结构变量整体赋值有三种情况：\n1. 定义结构体变量（用{ }花括号初始化）；\n2. 用已定义的结构变量初始化；\n3. **结构体类型相同的变量可以作为整体相互赋值**。\n\n在其他情况的使用过程中只能对成员逐一赋值。\n在 C 语言中不存在对结构体类型的强制转换（和内置类型的区别）。\n\n```c\nstruct Student\n{\n\tchar s_id[8];\n    char s_name[8];\n    char s_sex[4];\n    int s_age;\n}Student;\nint main\n{\n    Student stda={\"09001\",\"xcg\",\"M\",23};\n    Student stdb=stda;//调用了memcpy(&stdb,&stda,sizeof(stda));\n    Student stdc;\n    Student stdx;\n    stdc = stda;\n    stdx.s_name = stda.s_name;//此语句是错误的。\n    strcpy_s(stdx.s_name,stda.s_name);//正确的做法！\n}\n```\n\n### 关于两结构体变量整体赋值如何实现\n\n首先，抓住两个结构体变量各自的地址，再依次同步迭代拷贝，调用的函数是`memcpy();`如`memcpy(&stdb,&stda,sizeof(stda));`\n### 关于上面提到的错误赋值\n\n`stdx.s_name = stda.s_name;`此语句是错误的。`\n\n为什么？\n\n`s_name`是一个数组，数组是不可能给另一个数组直接赋值的。因为：`s_name`代表首元素指针，根据我们数组那一节的知识储备，这个指针是常量（即数组名所代表的指针），`stdx.s_name = stda.s_name`这个语句的意思是把`stda.s_name`这个指针赋给`stdx.s_name`这个指针，这显然是不可行的，数组首元素指针不可能改变！\n\n同理，数组名不可以`++`，如已知`int ar[100]={};`的`ar`数组，`ar++`这个语句是错误的。\n\n应该对数组进行全部迭代拷贝，如调用`strcpy_s(stdx.s_name,stda.s_name);`\n\n### 与数组`{}`花括号赋值的异同\n\n不同点是：数组的花括号内的值类型必须一致，而结构体花括号内的值可能不一致。\n\n共同点：如果`{}`花括号内的内容缺省，默认赋值为0。\n\n## 结构体变量和函数\n\n拿打印函数举例\n\n![image-20210816183332238](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210816183332238.png)\n\n二个打印函数那个好 ？ 原因是什么？\n\n![image-20210816183348520](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210816183348520.png)\n\n二个打印函数那个好 ？ 原因是什么？和指针比较的优势？ 限制条件是什么？\n\n肯定是`Print_c`好。优势在于如果不是用指针来传值，那么还要再次开辟空间且给形参复制源变量的信息，导致空间和时间的效率都大大降低。而用指针来传值，直接能操作源变量。而用`const`来读取信息更为谨慎，因为`const`能保证该指针只能读取变量信息而不能改变变量信息。\n\n# 结构体的大小\n\n```c\nstruct Node_a\n{\n    char ca;\n    int sum;\n    char cb;\n}\nint main()\n{\n    struct Node_a ax;\n    printf(\"%d %d \\n\",sizeof(struct Node_a),sizeof(ax));//12 12\n}\n```\n\n## 为什么要理解字节对齐问题\n\n1. 内存大小的基本单位是字节，理论上来讲，可以从任意地址访问变量，但是实际上，cpu并非逐字节读写内存，而是以 2, 4 或 8 的倍数的字节块来读写内存，因此就会对基本数据类型的地址作出一些限制，即它的地址必须是 2，4 或 8 的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。\n2. 有些平台每次读都是从偶地址开始，如果一个 int 型（假设为 32 位系统）如果存放在**偶地址**开始的地方，那么一个读周期就可以读出这 32 bit，而如果存放在**奇地址**开始的地方，就需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 32 bit 数据。显然在读取效率上下降很多。\n3. **由于不同平台对齐方式可能不同，如此一来，同样的结构在不同的平台其大小可能不同，在无意识的情况下，互相发送的数据可能出现错乱，甚至引发严重的问题**。\n## 计算规则\n\n由于存储变量地址对齐的问题，计算结构体大小的 3 条规则：\n1. 结构体变量的首地址，必须是结构体变量中的“最大基本数据类型成员所占字节数”的整数倍。\n2. 结构体变量中，相对于**结构体首地址**，**每个成员**的**偏移量**，都是**成员本身基本数据类型**所占字节数的整数倍。\n\n   ```c\n   struct Node\n   {\n       char ca;//偏移地址为0，占1字节。偏移地址1-7起地址对齐占位作用，内容无实际意义。\n       double dx;//偏移地址为8，占8字节。因为要满足原则2即double的偏移量要相对于结构体首地址（视为0），是成员本身基本数据类型所占字节数的整数倍。只有在偏移地址8时，才满足(8-0)/8==1。\n       char cb;\n   };//24\n   ```\n3. 结构体变量的总大小，为结构体变量中 “最大**基本数据类型**成员所占字节数”的整数倍。\n![image-20210817015222060](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210817015222060.png)\n### 实例/测验\n\n```c\nstruct node\n{\n    char cha;\n    double da;\n    char chb;\n};//24,因为da是从0x08开始的。cha和chb都占了8个\n```\n\n```c\nstruct sdate\n{\n    int year;\n    int ia;\n    int day;\n};\nstruct Student\n{\n    char s_id[10];//1-10\n    char s_name[8];//11-18\n    struct sdate birthday;//21-32\n    double grade;//33-40\n};//40\n```\n\n```c\nstruct Inventory\n{\n    char description[15];//货物名称\n    char no[10];//货号\n    int quantity;//库存数量\n    double cost;//成本\n    double retail;//零售价格\n};//48\n```\n\n```c\nstruct Employee\n{\n    char name[27];//1-27\n    char address[30];//28-57\n    long int zip;//61-64\n    long int telenum;//65-68\n    double salary;//72-80\n};//80\n```\n\n### 如何巧妙计算偏移量\n\n有`Employee`类型的结构体，成员有`name`, `address`, `zip`, `telenum`, `salary`等，现要求：不要定义任何结构体变量计算`zip`相对结构体自身首地址的偏移量。\n利用`宏`+`无中生有`法。\n\n```c\n#define my_offset(type,exp) ( (int) & (( (type*)0 )->exp ))\nstruct Employee\n{\n    char name[27];//1-27\n    char address[30];//28-57\n    long int zip;//61-64\n    long int telenum;//65-68\n    double salary;//72-80\n};//80\nint main()\n{\n    int offset = 0;\n    //struct Employee x;\n    //offset = (char*)&x.salary - (char*)&x;  //72-0==72\n    offset = (int) & ( (struct Employee*)0 )->salary;//无中生有  0x00->0x72\n    offset = my_offer(struct Employee,zip);//利用宏定义\n    printf(\"%d \\n\",offset);\n}\n```\n### `#pragma pack`指定对齐值\n\n预处理指令`#pragma pack(n)`可以改变默认对齐数。`n`取值是 `1, 2, 4, 8, 16`。\nVS 中默认值` = 8`，gcc 中默认值` = 4`\n\n```c\n#pragma pack(1)\nstruct node\n{\n    char cha;\n    double dx;\n    char chb;\n};\n//若( )内为1->size:10;\n//\t\t为2->\t12;\n//\t\t为4->\t16;\n//\t\t为8->\t24;\n//\t\t为16->\t24;\n#pragma pack\n```\n### 终极总结\n\n1. 结构体变量的首地址，必须是`MIN{\"结构体 最大基本数据类型成员 所占字节数\", 指定对齐方式}`的整数倍。\n2. 结构体中，相对于结构体首地址，每个成员的偏移量，都是`MIN{该基本数据类型成员, 指定对齐方式}`的整数倍。\n3. 结构体的总大小，为`MIN{结构体最大基本数据类型成员所占字节数, 指定对齐方式}`的整数倍。\n# 比较结构体变量\n\n不要轻易地使用`memcmp`函数来对比两个结构体变量。因为结构体内存结构层面中，成员间的空隙填充的内容是不可控的，即结构体是一种非连续型内存空间。\n\n```c\nstruct Node\n{\n    char cha;\n    int ix;\n    char chb;\n};\n//当调用主函数时，将对分配得到的栈帧的每个字节进行刷新，全部赋为'0xcc'\nint main()\n{\n    int ar[10]={};\n    int br[10]={};\n    int x = memcmp(ar,br,sizeof(ar));\n    printf(\"%d\\n\",x);\n    \n    struct Node x = {'a',12,'b'};\n    struct Node y = {'a',12,'b'};\n    int tag1 = memcmp(&x,&y,sizeof(x));//不要轻易地使用memcmp比较结构体。因为结构体是一种非连续型内存空间。\n    struct Node z = {};//{}代表:把12个字节全赋成了0\n    z.cha = 'a';\n    z.chb = 'b';\n    z.ix = 12;\n    int tag2 = memcmp(&x,&z,sizeof(x));//返回值0代表相等，1代表大于，-1代表小于\n    printf(\"%d %d\\n\",tag1,tag2);//0 1\n    return 0;\n}\n```\n\n![image-20210817153745134](../../images/C语言_结构体/image-20210817153745134.png)\n# 结构体与数组\n\n所谓结构体数组，是指数组中的每个元素都是一个结构体类型。在实际应用中，C 语言结构体数组常被用来表示一个拥有相同数据结构的群体，比如一个班的学生、一个公司的员工等。\n# 联合体\n\n联合体(union)与结构体(struct)有一些相似之处。但两者有本质上的不同。在结构体中,各成员有各自的内存空间。而**在联合体中,各成员共享同一段内存空间**, **一个联合体变量的长度等于成员中最长的长度**。\n应该说明的是, 这里所谓的共享不是指把多个成员同时装入一个联合变量内, 而是指该联合变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值。\n一个联合体类型必须经过定义之后, 才能使用它，才能把一个变量声明定义为该联合体类型。\n联合体不仅可以节省内存空间，最本质、重要的用法是对同一段空间采取不同的类型格式去识别、读取数据。\n\n![image-20210817164050152](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210817164050152.png)\n\n```c\nunion Node\n{\n    short sx;\n    char cx[2];\n};\nint main()\n{\n    union Node x;\n    x.sx = 0x6162;//0x62,0x61\n    printf(\"%c %c \\n\",x.cx[0],x.cx[1]);//b a 而非a b \n    \n    x.cx[0]=1;\n    x.cx[1]=2;\n    printf(\"%d \\n\",x.sx); //0x01,0x02=>0x0201\n    return 0;\n}\n```\n\n![image-20210817162154866](../../images/C语言_结构体/image-20210817162154866.png)\n## 声明和定义时的注意\n\n设计有名的联合体，同时没有定义变量。\n\n```c\nunion UnData\n{\n    short st;\n    char cs[2];\n};\nunion UnData x;\n```\n\n设计有名的联合体，同时定义变量。与上述代码等效，节省了一行代码。\n\n```c\nunion UnData\n{\n    short st;\n    char cs[2];\n}x;\n```\n\n设计无名的联合体，同时定义变量。这样是可行的。\n\n```c\nunion\n{\n    short st;\n    char cs[2];\n}x;\n```\n\n但要注意的是，如下做法编译器是不认为x,y属于同一种类型的联合体的。\n\n```c\nunion\n{\n    short st;\n    char cs[2];\n}x;\nunion\n{\n    short st;\n    char cs[2];\n}y;\nint main()\n{\n    x = y;//不可编译通过。编译器不认为x,y属于同一种类型的联合体。\n}\n```\n\n当然，我们可以用`typedef`关键字把无名的联合体定义出的变量名赋予其类型的性质。\n\n```c\ntypedef union\n{\n    short sx;\n    char cx[2];\n}x;\n```\n\n## 重要的面试笔试题目\n\nIP地址本质上是一串32位二进制代码（对于ipv4是32位，ipv6是128位），可看作无符号int数。题目要求把32位二进制代码的每八位转换为一个无符号十进制数，并用“点”隔开，最终转为字符串。同时也要求把该格式的字符串能逆转换为32位二进制代码构成的无符号int数。\n\n![image-20210817114120334](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210817114120334.png)\n\n### 要运用到的输入/输出函数\n\n```c\nchar buff[20];\nint a = 10,b = 20;\n\nprintf();//打印到屏幕上\nint len = printf(\"a = %d b = %d \\n\",a,b);//将格式化字符串写入到标准输出设备中\n\nsprintf(buff,\"%d.%d.%d.%d\",x.s4,x.s3,x.s2,x.s1);//将格式化字符串写入到buff中\nint sprintf(char* buff,const char* fmt, ...);//返回的值：格式化字符串探测到'\\0'时，返回有效字符的长度\nint len = sprintf(buff,\"a = %d b = %d \\n\",a,b);\n\nfprintf(stdout,\"a = %d b = %d \\n\",a,b);//将格式化字符串写入到文件指针对应的位置。如果该文件是标准输出设备则是打印到屏幕上。\n\n//由此可知，printf()实际上内部调用了fprintf()，文件指针为stdout；而fprintf()实际上内部调用了sprintf()，buff指针指向文件指针。即sprintf才是根本所在。\n```\n\n```c\nscanf();//从标准输入设备stdin中输入的数据读取值。\n\nsscanf(char* buff,\"%...\", &...);//从buff（字符串）中读值。按格式化控制将%...对应的值写到&...中\n\n\nint main()\n{\n    int a,b;\n    int sum = scanf(\"%d %d\",&a,&b);//scanf返回正确读取到的值的个数，此处若正确输入则返回2。若输入\"12,23\"则只能正确读取一个值\n    //如果输入时两数中间分开的不是空格，则无法正常输入。因此此处就体现了scanf的“格式控制”，那么同样的，我们若想要用户用.来隔开数据，则可以通过限制格式来达到控制效果。\n    \n    char buff[]={\"12,23,34,45\"};\n    unsigned int s[4];\n    //sum = sscanf(buff,\"%d.%d.%d.%d\",&s[0],&s[1],&s[2],&s[3]);\n    //为了能检测到用户多输入了字符，则我们在格式化控制中多加一个哨兵位检测是否多输入了值。\n\tchar ch;\n    sum = sscanf(buff,\"%d.%d.%d.%d%c\",&s[0],&s[1],&s[2],&s[3],&ch);\n    //一旦用户多输入了字符如'.'，则sum将大于4，则可以条件判断意外情况。\n    printf(\"%d \\n\",num);//4为正常，5为多输入了字符-意外情况\n}\n```\n\n### 代码编写\n\n```c\nunion IPNode\n{\n    unsigned int addr;\n    struct //没有名字，称为哑元结构（dummy），对应于实元。\n    {\n        unsigned char s1,s2,s3,s4;//或者声明一个数组也可以。unsigned char s[4];\n    };\n    //unsigned char s1,s2,s3,s4;不能简单地写成这样，因为这样写的结果是：四个变量都只共享第一个字节。\n};\nvoid int_to_str(unsigned int ip,char* buff)\n{\n    assert(buff!=nullptr);\n    union IPNode x;\n    x.addr = ip;\n    sprintf_s(buff,20,\"%d.%d.%d.%d\",x.s4,x.s3,x.s2,x.s1);\n}\nint main()\n{\n    unsigned int ip = 2394117684;\n    char buff[20]={};\n    int_to_str(ip,buff);\n    return 0;\n}\n```\n\n```c\nunsigned int str_to_int(const char* buff)\n{\n    unsigned int ip=0;\n    if(buff==NULL)return ip;\n    \n    union IPNode x;\n    \n    unsigned int s[4]={};\n    char ch=0;\n    int sum=sscanf_s(buff,\"%d.%d.%d.%d%c\",&s[3],&s[2],&s[1],&s[0],&ch);\n    if(num>4)return ip;\n    for(int i=3;i>=0;--i)\n    {\n        if(s[i]>255)return ip;\n        x.s[i]=s[i];\n    }\n    ip=x.addr;\n    return ip;\n}\nint main()\n{\n    unsigned int ip = 2394117684;\n    char buff[20];\n    printf(\"%u \\n\",ip);\n    \n    int_to_str(ip,buff);\n    printf(\"%s \\n\",buff);\n    \n    unsigned ipx = str_to_int(buff);\n    printf(\"%u \\n\",ipx);\n}\n```\n\n# 作业\n\n1. 给结构体变量赋值和输出结构体变量的值。想尽办法做初始化。\n\n   ![image-20210815114633078](../../images/C%E8%AF%AD%E8%A8%80_%E7%BB%93%E6%9E%84%E4%BD%93/image-20210815114633078.png)\n\n","categories":["C"]},{"title":"C语言_递归","url":"/C/C语言_递归/","content":"# 递归内容\n\n1. 栈帧的理解\n2. 分治策略和递归\n\n# 复习函数\n\n## 编译链接和内存布局\n\n![image-20210814025249988](../../images/C%E8%AF%AD%E8%A8%80_%E9%80%92%E5%BD%92/image-20210814025249988.png)\n\n　　根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分为以下4个部分：\n1) 代码区：这个区域存储着被装入执行的二进制机器代码，处理器(CPU)会到这个区域取指并执行。\n2) 数据区：用于存储全局变量, 静态全局变量，静态局部变量，字符串常量等。\n3) 堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。\n4) 栈区：函数被调时分配栈区，用于存放函数的参数值，局部变量等值；还要动态地存储函数之间的关系，以保证被调用函数在返回时恢复到被调用函数中继续执行。\n\n## 函数调用机制\n\n局部变量占用的内存是在程序执行过程中“动态”地建立和释放的。这种“动态”是通过栈由系统自动管理进行的。当任何一个函数调用发生时，系统都要作以下工作：\n1) 建立栈帧空间；\n2) 保护现场：主调函数运行状态和返回地址入栈；\n3) 为被调函数传递数据（进行实参和形参的结合），同时形参获得存储空间；接着给局部变量分配空间；\n4) 执行被调函数函数体；\n5) 当被调函数执行完成，释放被调函数中局部变量占用的栈空间；\n6) 恢复现场：取主调函数运行状态及返回地址，释放栈帧空间；\n7) 继续主调函数后续语句。\n\n![image-20210814025448484](../../images/C%E8%AF%AD%E8%A8%80_%E9%80%92%E5%BD%92/image-20210814025448484.png)\n\n在进入main函数时，只创建了main函数的栈帧，在调用Add函数时才会建立Add函数的栈帧，当Add函数return时，栈帧收回。\n\n### 有启发的代码\n\n```c\nint* fun()\n{\n    int ar[10]={12,23,34,45,56,67,78,89,90,100};\n    return ar;\n}\nint main()\n{\n    int* p = fun();\n    for(int i = 0;i<10;++i)\n    {\n        printf(\"%d \",p[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\nar大小为10时，fun函数调用时还正常存在着ar数组的信息，而fun函数调用完后，再循环调用printf函数，致使冲掉了以前栈帧的信息，导致输出错误。\n\n![image-20210814032349532](../../images/C%E8%AF%AD%E8%A8%80_%E9%80%92%E5%BD%92/image-20210814032349532.png)\n\n而把fun函数中的ar大小改为1000时，运行结果就不一样了，输出的是正常的。\n\n![image-20210814032439500](../../images/C%E8%AF%AD%E8%A8%80_%E9%80%92%E5%BD%92/image-20210814032439500.png)\n\n因为，ar占用的栈帧很多，printf函数未能冲刷到之前ar的原有数据。但是本质上ar的信息还是失效了的。懂了这个例子，会对函数调用与栈帧分配的关系深入理解。\n\n# 分治策略与递归\n\n　　分治策略：是将规模比较大的问题可分割成规模较小的相同问题。**问题不变，规模变小**。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。\n\n## 分治法步骤\n\n在分治策略中递归地求解一个问题，在每层递归中应用如下三个步骤：\n\n1. 分解：将问题划分成一些子问题，**子问题的形式与原问题一样，只是规模更小**。\n2. 解决：递归地求解子问题。**如果子问题的规模足够小，则停止递归，直接求解**。\n3. 合并：将小规模的解组合成原规模问题的解。\n\n　　递归函数的执行分为“递推”和“回归”两个过程，这两个过程由递归终止条件控制，即逐层递推，直至递归终止条件满足，终止递归，然后逐层回归。\n　　递归调用同普通的函数调用一样，每当调用发生时，就要分配新的栈帧（形参数据，现场保护，局部变量）；而与普通的函数调用不同的是，由于递推的过程是一个逐层调用的过程，因此存在一个逐层连续的分配栈帧过程，直至遇到递归终止条件时，才开始回归，这时才逐层释放栈帧空间，返回到上一层，直至最后返回到主调函数。\n\n## 经典题目\n\n我们对于递归要达到的初级水平是：可以把循环程序改为递归程序。\n\n最终的目标是：在递归的活动中，直接能捕获到某一步的运行情况。\n\n### 求解阶乘\n![image-20210814032743926](../../images/C语言_递归/image-20210814032743926.png)\n```\nn! = (n-1)!\\*n\n(n-1)! = (n-2)!\\*n-1\n(n-2)! = (n-3)!\\*n-1\n...\n2! = 1! \\* 2\n1! = 1\n```\n阶乘可递归的定义为：\n![image-20210814033732211](../../images/C语言_递归/image-20210814033732211.png)\n\n可以看出是用阶乘定义阶乘，这种拿自己定义自己的方法称为递归定义。\n\n在写出递归程序前，我们先拿循环程序解决一下。\n\n```c\n//不考虑整型溢出\nint factorial(int n)\n{\n    int sum=1;\n    for(int i=1;i<=n;++i)\n    {\n        sum=sum*i;\n    }\n    return sum;\n}\n```\n\n递归的写法：\n\n```c\nint factorial_recursion(int n)//factorial:阶乘 recursion:递归\n{\n    if(n<=1)\n    {\n        return 1;\n    }\n    else//n>1\n    {\n        return factorial_recursion(n-1)*n;\n    }\n}\n```\n\n可以把一切的循环改为递归，也可把一切的递归改为循环，两者本质上可以相通。\n\n### 整数倒序输出\n\n输入一个整数（无符号整型），用递归算法将整数倒序输出。\n\n循环法\n\n```c\nvoid reverse_print(unsigned int n)\n{\n    while(n!=0)\n    {\n        printf(\"%d \",n%10);//1234%10=4 ...\n        n=n/10;\n    }\n}\n```\n\n递归法\n\n```c\nvoid reverse_print(unsigned int n)\n{\n    if(n!=0)\n    {\n        printf(\"%d \",n%10);\n        reverse_print(n/10);\n    }\n}\n```\n\n上述递归代码是正确的，即输出了\"4 3 2 1 \"。而如果调用函数和打印顺序颠倒，则结果会完全不一样。分析代码结构，打印函数是在调用reverse_print之前的，就是说我们是在递推的同时打印模10结果的，而回归时reverse_print函数后面没有语句，因此没有其他的操作。\n\n```c\nvoid fun(unsigned int n)\n{\n    if(n!=0)\n    {\n        fun(n/10);\n        printf(\"%d \",n%10);\n    }\n}\n```\n\n上述代码为先递归切割（每次都除10），最后则从1%10开始打印到1234%10，即\"1 2 3 4 \"。分析递归时，一定要明确各层函数在栈区中的结构和意义。那么我们分析，由于打印函数在fun函数之后，所以这个程序在从1234递推到1的过程中没有打印，而是在递推完毕回归时才打印（即执行fun函数之后的语句）。\n\n### 打印无序数组\n\n有一个整型数组，数值无序，使用循环和递归完成打印和查询。\n\n循环方法：\n\n```c\nvoid Print_Ar(const int* ar, int n)\n{\n    assert(ar!=NULL);\n    for(int i=0;i<n;++i)\n    {\n        printf(\"%d \",ar[i]);\n    }\n    printf(\"\\n\");\n}\nint main()\n{\n    int ar[]={12,23,34};\n    int n = sizeof(ar)/size(ar[0]);\n    Print_Ar(ar,n);\n}\n```\n\n递归方法：\n\n```c\nvoid Print_recursion(const int* ar, int n)\n{\n    if(n>0)\n    {\n        Print_recursion(ar,n-1);//n-1代表打印前n-1个元素\n    \tprintf(\"%d \",ar[n-1]);//n-1代表此时的第n下标值\n    }\n}\nvoid Print_Ar(const int* ar, int n)\n{\n    assert(ar!=NULL);\n    Print_recursion(ar, n)；\n    printf(\"\\n\");\n}\nint main()\n{\n    int ar[]={12,23,34};\n    int n = sizeof(ar)/size(ar[0]);\n    Print_Ar(ar,n);\n}\n```\n\n#### 思考1\n\n如果把递归函数体中的`Print_recursion(ar,n-1);`中的`\"n-1\"`改为`\"n--\"`会发生什么现象？\n\n```c\nvoid Print_recursion(const int* ar, int n)\n{\n    if(n>0)\n    {\n        Print_recursion(ar,n--);//n-1代表打印前n-1个元素\n    \tprintf(\"%d \",ar[n-1]);//n-1代表此时的第n下标值\n    }\n}\nvoid Print_Ar(const int* ar, int n)\n{\n    assert(ar!=NULL);\n    Print_recursion(ar, n);\n    printf(\"\\n\");\n}\nint main()\n{\n    int ar[]={12,23,34};\n    int n = sizeof(ar)/size(ar[0]);\n    Print_Ar(ar,n);\n}\n```\n\n答案是运行时内存溢出了。因为`n--`是后置`--`，先取值运行函数，函数调用完才回写减一后的结果。开始时n是3，函数调用时传的值永远都是2。\n#### 思考2\n\n如果把递归函数体中的`Print_recursion(ar,n--);`中的`\"n--\"`改为`\"--n\"`会发生什么现象？\n\n答案是`\"随机值 12 23 \"`。因为`--n`是前置`--`，在运行函数前就把`n-1`并回写了，这导致一个问题，函数调用时，n已经减了1，那么打印`ar[n-1]`又会减1，则会导致`n=1`时调用`Print_recursion(ar, n);`时满足条件执行语句`--n`，此时n变0，接下来打印`ar[n-1]`即`ar[-1]`，就产生了越界。\n### 查询无序数组某值的下标\n\n```c\nint FindValueIndex(const int* ar, int n, int val)\n{\n\tint pos = -1;\n\tif (n > 0)\n\t{\n\t\tif (ar[n - 1] == val)\n\t\t{\n\t\t\tpos = n - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos = FindValueIndex(ar, n - 1, val);\n\t\t}\n\t}\n\treturn pos;\n}\nint findValue(const int*ar, int n,int val)\n{\n    if(ar==NULL) return -1;\n    return FindValueIndex(ar, n, val);\n}\n```\n\n老师的写法：\n\n```c\nint FindValueIndex(const int* ar, int n, int val)\n{\n\tif (n < 1 || ar[n-1] == val)\n\t{\n\t\treturn n-1;\n\t}\n    else\n    {\n        return FindValueIndex(ar, n-1, val);\n    }\n}\nint findValue(const int*ar, int n,int val)\n{\n    if(ar==NULL) return -1;\n    return FindValueIndex(ar, n, val);\n}\n```\n\n### 全排列/子集问题：树形结构(组合树/子集树)\n\n现要求输出集合`{1,2,3}`的全部子集。\n\n![image-20210815021627089](../../images/C%E8%AF%AD%E8%A8%80_%E9%80%92%E5%BD%92/image-20210815021627089.png)\n![image-20210816014510751](../../images/C语言_递归/image-20210816014510751.png)\n\n```c\nvoid fun(int* ar,int* br,int i,int n)\n{\n    if(i==n)\n    {\n        for(int k=0;i<n;++k)\n        {\n            if(br[k]==1)\n            {\n                printf(\"%d \",ar[k]);\n            }\n        }\n        printf(\"\\n\");\n        \n    }\n    else\n    {\n        br[i]=1;\n        fun(i+1,n);\n        br[i]=0;\n        fun(i+1,n);\n    }\n}\nint main()\n{\n    const int n = 3;\n    int ar[]={1,2,3};\n    int br[]={0,0,0};\n    fun(ar,br,0,n);\n    return 0;\n}\n```\n\n此类递归程序的时间复杂度为$O(2^n)$，空间复杂度为树的高度$S(n)$。\n\n## 图解递归过程\n\n### 代码的调动过程\n\n![image-20210814220256021](../../images/C%E8%AF%AD%E8%A8%80_%E9%80%92%E5%BD%92/image-20210814220256021.png)\n\n### 栈帧的动态调动过程\n\n![image-20210814220321049](../../images/C%E8%AF%AD%E8%A8%80_%E9%80%92%E5%BD%92/image-20210814220321049.png)\n\n# 总结\n\n## 关于分配栈帧\n\n函数被调用，不管是自己调用自己，还是被其它函数调用，都将会给被调用函数分配栈帧。\n\n## 关于死循环\n\n存在死循环，但不存在无穷递归。即递归函数必须要有一个是递归结束的出口（要有递归中止的条件语句）。\n\n```c\nint factorial(int n)\n{\n    int sum=1;\n    for(int i=1; ;++i)//中间语句缺省，意味着死循环。\n    {\n        sum=sum*i;\n    }\n    return sum;\n}\n```\n\n```c\nint factorial_recursion(int n)//factorial:阶乘 recursion:递归\n{\n    if(false)//达不到原来的函数出口了\n    {\n        return 1;\n    }\n    else\n    {\n        return factorial_recursion(n-1)*n;\n    }\n}\n```\n\n死循环只是重复的在开辟的某一个空间里反复计算赋值，过程都是在一个内存空间完成的。即时间复杂度是$O(n)$，空间复杂度是$S(1)$。死循环只是全负荷的使用CPU的运算资源，但不会影响内存结构。\n\n而无穷递归是反复开辟新的栈帧，时间复杂度是$O(n)$，空间复杂度是$S(n)$，因为栈区的大小是有限的，默认为1M，如果一直递归下去，则会溢出栈区破坏内存结构，则不可能一直递归下去。所以问题的规模不要过大，递归过深，引起栈溢出。\n\n# 找数组某一值\n\n```c\nint Find(const int* ar,int n,int val)\n{\n    if(n<1 || ar[n-1]==val)\n    {\n        return n-1;\n    }\n    else\n    {\n        return Find(ar,n-1,val);\n    }\n}\n```\n\n\n\n```c\nint Find(const int* ar,int n,int val)\n{\n\tint pos = -1;\n\tif (n > 0)\n\t{\n\t\tif (ar[n - 1] == val)\n\t\t{\n\t\t\tpos=n-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos = FindValueIndex(ar, n - 1, val);\n\t\t}\n\t}\n\treturn pos;\n}\n```\n\n# 体会递归的分析\n\n```c\nvoid Print(const int* ar,int n)\n{\n    if(n>0)\n    {\n        Print(ar,n-1);//括号内的n-1改成n--和--n,结果都会不一样。\n        printf(\"%d \",ar[n-1]);\n    }\n}\nvoid Print_Ar(const int* ar,int n)\n{\n    assert(ar!=nullptr);\n    Print(ar,n);\n    printf(\"\\n\");\n}\nint main()\n{\n    int ar[] = { 12,23,34 };\n\tint n = sizeof(ar) / sizeof(ar[0]);\n\tPrint_Ar(ar, n);\n}\n```\n\n# 作业\n\n1. 斐波那契数列\n   循环法\n```c\nint fun(int n)\n{\n   int a=1,b=1,c=1;\n   for(int i=3;i<=n;++i)\n   {\n       c=a+b;\n       b=a;\n       a=c;\n   }\n   return c;\n}\n```\n\n   递归法（目标要达到时间复杂度$O(n)$）\n   https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/fei-bo-na-qi-shu-lie-wen-ti-de-si-chong-jie-fa-by-/\n\n```c\nint Fibonacci(int n)\n{\n    if (n == 1 || n == 2)return 1;\n    else if (n > 0)\n    {\n        return Fibonacci(n - 1) + Fibonacci(n - 2);\n    }\n    else\n    {\n        return 0;\n    }\n}\nint Fibonacci_Ar(int* ar,int n)\n{\n    int i = 2;\n    for (i; i <= n;++i)\n    {\n        ar[i] = ar[i - 2] + ar[i - 1];\n    }\n    return ar[n];\n}\nint main()\n{\n    int ar[101] = { 0,1,1 };\n    int fibo = Fibonacci_Ar(ar,30);\n    printf(\"%d \", fibo);\n}\n```\n\n```java\n/*记忆化递归解法\n解题思路:\n既然普通的递归解法产生大量的重复计算，如果已经计算过的f(x) 把结果保存不就减少了计算么？ 用一个数组记忆计算结果，如果f(x)已经计算过了，直接返回a[x]\n时间复杂度:\nO(n)， 由于计算过的记忆下了，只要n次\n空间复杂度:\nO(n)， 递归调用栈消耗了线性数量级，记忆数组使用了n的空间\n*/\n#define N 100 + 1\nclass Solution {\nprivate:\n   int arr[N] = {0, 1, 1, } ;\npublic:\n   int fib(int n) {\n       if (arr[n] || !n)\n           return arr[n] ;\n       return arr[n] = (fib(n-1) + fib(n-2))%1000000007 ;\n   }\n};\n``` \n2. 二分查找递归法\n```c\nint binary_search(const int* ar, int n, int val, int left, int right)\n{\n    int pos = -1;\n    int mid = (right+left)/2;\n    if (n < 1 || ar[mid] == val)\n    {\n        pos = mid;\n    }\n    else if(ar[mid]>val)\n    {\n        return binary_search(ar, n/2, val, left, right-1);\n    }\n    else\n    {\n        return binary_search(ar, n/2, val, left+1, right);\n    }\n    return pos;\n}\n/*\nint FindValueIndex(const int* ar, int n, int val)\n{\nif (n < 1 || ar[n-1] == val)\n{\n    return n-1;\n}\n   else\n   {\n       return FindValueIndex(ar, n-1, val);\n   }\n}\n*/\nint findValue(const int*ar, int n,int val)\n{\n    if(ar==NULL) return -1;\n    return binary_search(ar, n, val, 0, n-1);\n}\n```\n3. 思考以下代码`'#'`会输出几次？\n```c\nvoid fun(int i,int n)\n{\n    if(i==n)\n    {\n        printf(\"# \");\n    }\n    else\n    {\n        fun(i+1,n);\n        fun(i+1,n);\n    }\n}\nint main()\n{\n    int n = 3;\n    fun(0,n);\n    return 0;\n}\n```\n\n答案是输出8次。如果只写了一行`fun(i+1,n);`则只打印1次。思考为什么。\n大体上分析用层次分析，具体调动是深度优先搜索分析。\n![image-20210816010631178](../../images/C语言_递归/image-20210816010631178.png)\n只调用一次的情况：\n![image-20210816010852815](../../images/C语言_递归/image-20210816010852815.png)\n只有一条路径，即只打印一次。\n\n调用两次的情况：\n![image-20210816012051272](../../images/C语言_递归/image-20210816012051272.png)\n规律：调用两次时，此类递归程序的时间复杂度为O(2^n)，空间复杂度为树的高度S(n)。\n\n层次分析：（一层一层看，而不是具体的实现步骤）\n![image-20210816012904753](../../images/C语言_递归/image-20210816012904753.png)\n由此题可以延伸出全排列/子集树(组合树)问题！\n","categories":["C"]},{"title":"C语言_二级指针","url":"/C/C语言_二级指针/","content":"# 理解各级指针+1的含义\n\ntypename\\* p;\np = p + 1; 被编译器解释成： p = p + sizeof(typename)*1；\n\n## int型为例\n\n![image-20210731140231534](../../images/C%E8%AF%AD%E8%A8%80_%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/image-20210731140231534.png)\n\n```c\nint a3,a2,a1,a0;\nint *p3,*p2,*p1,*p0;\nint **s;\ns+1;\n*s+1;\n**s+1;\n//以上三句：1、加1的意义是什么？2、加后的类型是什么\n```\n\n### s+1\n\ns是一个二级指针，类型为int\\*\\*，只要是x86架构下的指针，不管几级，都是占用4字节。\n\n而指针+1我们要理解其含义，指针+1等效于(指针+sizeof(\\*指针))。\n\n如果是二级指针+1，则加的大小是一级指针的大小。则不管typename\\*\\* p; p的类型无论如何，p+1都是加4。 \n\n如果是一级指针+1，则加的大小是指向的数据类型的大小，不同数据类型的大小不一样，int型正好和指针的大小一样都是4字节，所以容易造成混淆；char型占1字节。所以int\\* ip; ip+1为+4；所以char\\* cp; cp+1为+1。\n\n则s+1的意义就是，实际是s+4字节，使二级指针指向了下一个元素，即二级指针指向了下一个一级指针。加后的类型依旧是二级指针。\n\n![image-20210731140336842](../../images/C%E8%AF%AD%E8%A8%80_%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/image-20210731140336842.png)\n\n### \\*s+1\n\n\\*s+1实际上是\\*s+4字节，因为int型占4字节。意义就是使一级指针指向了下一个元素，即一级指针指向了下一个int型数据。加后的类型依旧是一级指针。\n\n### \\*\\*s+1\n\n\\*\\*s+1实际上就是表面意思\\*\\*s+1，因为\\*\\*s为int型数据，而不是二级指针也不是一级指针，是实实在在的数据本身。则意义就是int型数据的加法运算。加后的类型为int型。\n\n## char型为例\n\n![image-20210731140429617](../../images/C%E8%AF%AD%E8%A8%80_%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/image-20210731140429617.png)\n\n### s+1\n\ns是一个二级指针，类型为char\\*\\*，只要是x86架构下的指针，不管几级，都是占用4字节。\n\n则根据上文，s+1的意义就是，实际是s+4字节，使二级指针指向了下一个元素，即二级指针指向了下一个一级指针。加后的类型依旧是二级指针。\n\n![image-20210731140336842](../../images/C%E8%AF%AD%E8%A8%80_%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/image-20210731140336842.png)\n\n### \\*s+1\n\n\\*s+1实际上是\\*s+4字节，因为char型占1字节。意义就是使一级指针指向了下一个元素，即一级指针指向了下一个char型数据。加后的类型依旧是一级指针。\n\n### \\*\\*s+1\n\n\\*\\*s+1实际上就是表面意思\\*\\*s+1，因为\\*\\*s为char型数据，而不是二级指针也不是一级指针，是实实在在的数据本身。则意义就是char型数据（本质上是ASCII码整型值）的加法运算。加后的类型为char型。\n\n## double型为例\n\n![image-20210731140641462](../../images/C%E8%AF%AD%E8%A8%80_%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/image-20210731140641462.png)\n\n### s+1\n\ns是一个二级指针，类型为double\\*\\*，只要是x86架构下的指针，不管几级，都是占用4字节。\n\n则根据上文，s+1的意义就是，实际是s+4字节，使二级指针指向了下一个元素，即二级指针指向了下一个一级指针。加后的类型依旧是二级指针。\n\n![image-20210731140336842](../../images/C%E8%AF%AD%E8%A8%80_%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/image-20210731140336842.png)\n\n### \\*s+1\n\n\\*s+1实际上是\\*s+8字节，因为double型占8字节。意义就是使一级指针指向了下一个元素，即一级指针指向了下一个double型数据。加后的类型依旧是一级指针。\n\n### \\*\\*s+1\n\n\\*\\*s+1实际上就是表面意思\\*\\*s+1.0，因为\\*\\*s为double型数据，而不是二级指针也不是一级指针，是实实在在的数据本身。则意义就是double型数据的加法运算。加后的类型为double型。\n\n# 反观数组指针\n\n首先区分一个概念，即int\\* s[4];的意义是s是存放int型指针的数组。而int(\\*s)[4];的意义是s是存放int[4]数组的指针，类似于int[4]\\* s.\n\n```c\nint(*s)[4];//意义是s是存放int[4]数组的指针，类似于int[4]* s，则s是指向一个int[4]数组。\n```\n\n\n\n","categories":["C"]},{"title":"Linux_初识Linux","url":"/Linux/Linux_初识Linux/","content":"# Linux学习内容\n1. 基本操作\n2. `gcc/g++`（程序如何编译）\n3. 工程文件管理makefile\n4. 调试gdb\n5. 库文件\n6. 进程：复制进程fork、替换进程\n7. 进程间通信（比如QQ互发信息）：管道、共享内存、信号量\n8. 线程：同步、并发\n9. 网络编程：跨主机发送数据（最好有计算机网络基础），TCP、HTTP、I/O复用方法\n## 初识内容\n1. 目录结构：Linux中的文件夹称为目录\n2. 文件类型\n3. 权限\n4. 命令\n## 总结\n1. 与Windows相比：Linux多用命令行，我们要掌握基本的命令。\n2. 了解系统的目录结构，是个倒状树，记住常见的四五个目录的作用。\n3. 用户存放文件，要放到自己的家目录。\n# Linux目录结构\n\n| 目录   | 描述                                                                                                                                          | 全拼                                      |\n| ---- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |\n| /    | 根目录                                                                                                                                         |                                         |\n| bin  | 二进制可执行程序，常用的命令就存放到这了。                                                                                                                       | binary, 表示二进制可执行文件                      |\n| dev  | 硬件设备文件，把硬件设备抽象成为了文件                                                                                                                         | device, 设备                              |\n| lib  | 这个目录里存放着系统最基本的动态库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。                                                                                 | library, 库                              |\n| mnt  | 临时挂载移动设备                                                                                                                                    | mount                                   |\n| proc | 将内存中进程的信息映射到了文件中                                                                                                                            | process, 进程                             |\n| home | 普通用户的家目录，以用户名为准，如`/home/xcg`                                                                                                                |                                         |\n| root | 管理员的家目录                                                                                                                                     |                                         |\n| boot | 存放系统启动相关的内核文件                                                                                                                               |                                         |\n| etc  | 系统的配置文件                                                                                                                                     | et cetera, \"等等\"                         |\n| usr  | 系统用户工具和程序。在系统运行过程中，不经常改变的内容，比如说安装的软件。存放所有命令、库、手册等共享资源。子目录有`bin`（用户命令）、`sbin`（超级用户使用的高级管理程序和系统守护程序）、`include`、`lib`（用户后来安装的库文件）、`src`（内核源代码） | 据说是user的缩写，也据说是Unix Shared Resources的缩写 |\n| var  | usr目录下的软件产生的数据，会存放于此；除此之外还有邮件、系统日志等。因此**经常改变**。                                                                                             |                                         |\n| proc | 每一个进程启动后，都会在里面创建一个名为进程ID号的目录，保存进程相关的信息。其中包含fd，即进程打开的文件、socket。                                                                              |                                         |\n## etc\n\netc不是什么缩写，是\"and so on\"的意思，来源于法语的\"et cetera\"，翻译成中文就是\"等等\"的意思。至于为什么在`/etc`下面存放配置文件，按照原始的UNIX的说法这下面放的都是一堆零零碎碎的东西，就叫etc，这其实是个历史遗留。\n\n这个目录一般用来存放程序所需的整个文件系统的配置文件。\n\n`/etc`目录包含很多文件，许多网络配置文件在其中：\n1. `/etc/rc`or`/etc/rc.d`or`/etc/rc*.d`：启动、或改变运行级时运行的scripts或scripts的目录。\n2. `/etc/passwd`：用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息。\n3. `/etc/fstab`：启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表。Linux下也包括用swapon -a启用的swap区的信息。\n4. `/etc/group`：类似`/etc/passwd`，但说明的不是用户而是组\n5. `/etc/issue`：getty在登录提示符前的输出信息，通常包括系统的一段短说明或欢迎信息，内容由系统管理员确定。\n6. `/etc/magic`：file的配置文件，包含不同文件格式的说明，file基于它猜测文件类型。\n7. `/etc/mtab`：当前安装的文件系统列表，由scripts初始化，并由mount命令自动更新。需要一个当前安装的文件系统的列表时使用，例如df命令。\n8. `/etc/shadow`：在安装了影子口令软件的系统上的影子口令文件，影子口令文件将`/etc/passwd`文件中的加密口令移动到`/etc/shadow`中，而后者只对`root`可读，这使破译口令更困难。\n9. `/etc/login.defs`：login命令的配置文件。\n10. `/etc/profile, /etc/csh.login, /etc/csh.cshrc`：登录或启动时Bourne或Cshells执行的文件，这允许系统管理员为所有用户建立全局缺省环境。\n11. `/etc/shells`：列出可信任的shell.chsh命令允许用户在本文件指定范围内改变登录shell。提供一台机器FTP服务的服务进程ftpd检查用户shell是否列在 `/etc/shells`文件中，如果不是将不允许该用户登录\n## usr\n之前一直没有怎么关注过它，反正程序都是安装在里边的，也没有什么值得追根溯源的东西。那么usr到底是什么的缩写呢，它又是怎么来的呢？讨论中，大部分观点认为：\n1. usr是user的缩写；\n2. usr是unix system resources的缩写；\n3. usr是unix software resources的缩写。\n4. usr是unix shared resources\n\n根据常识判断，是user缩写的可能性不大，因为和`/home`冲突了。不过是system resources还是software resources的缩写还真不好说。特此查了好多东西，却发现竟然连wikipedia也模棱两可。`/usr`是linux系统核心所在，包含了所有的共享文件。\n它是unix系统中最重要的目录之一，涵盖了二进位制文件，各种文件，各种标头文件，还有各种库文件，还有诸多程序，例如ftp，telnet等等。\n\n曾经的`/usr`还是使用者的家目录，存放着各种使用者文件，但现在已经被`/home`取代了（例如`/usr/someone`已经改为`/home/someone`）。\n现代的`/usr`只专门存放各种程序和资料，使用者目录已经转移。虽然`/usr`名称未改，不过其含义已经从“使用者目录” 变成了“unix系统资源” 目录。值得注意的是，在一些unix系统上，仍然把`/usr/someone`当做使用者家目录，如Minix。\n\n`/usr`文件系统经常很大，因为所有程序安装在这里。`/usr`里的所有文件一般来自Linux distribution；本地安装的程序和其他东西在`/usr/local`下。这样可能在升级新版系统或新distribution时无须重新安装全部程序。\n\n由于`/usr`中的文件不和特定的计算机相关，也不会在通常使用中修改，因此可以通过互联网共享这个目录（文件系统），这样，当管理员安装了新的站群软件之后，所有共享这一文件系统的计算机均可以使用新的站群软件。\n\n至此，真相大白。看来就像前一阵子的`/var/run`移到`/run`一样。\n\n真的是不看不知道，一看吓一跳呀。原来linux几经进化，好多目录的诞生和用途已经产生了根本的变化。\n\n* `/usr/bin`: 所有可执行文件，如gcc等（指不包含在 `/sbin` 和 `/bin` 内的）；\n* `/usr/include`: 各种标头文件，编译文件等时需要使用；\n    * `/usr/include/’package-name’` : 程序特定的标头文件；\n* `/usr/lib`: 所有可执行文件所需要的库文件；\n* `/usr/local`: 这里主要存放那些手动安装的站群软件，即不是通过“新立得” 或 `apt-get` 安装的站群软件。 它和`/usr`目录具有相类似的目录结构 。让站群软件包管理器来管理`/usr`目录，而把自定义的指令码（scripts）放到`/usr/local`目录下面，应该是个不错的主意。\n* `/usr/games`: 曾经包含游戏等文件，现在很少用到；\n* `/usr/man`: man 手册，已经移至 `/usr/share/man`；\n* `/usr/sbin`: 类似 `/sbin`，root 可以执行。但此目录不包含在环境变数 `$PATH` 中，它包含的程序类似于 `chroot`, `useradd`, `in.tftpd` and `pppconfig`；\n* `/usr/share`: 它包含了各种程序间的共享文件，如字型，图示，文件等。（`/usr/local` 对应的目录是 `/usr/loca/share`）;\n    * `/usr/share/doc` : 类似应用程序的 man 手册。它包含程序的说明文件，预设配置文件等；\n    * `/usr/share/info` : 不常用，已经被 man 代替；\n    * `/usr/share/man` : app 的 manual；\n    * `/usr/share/icons` : 应用程序的图示等文件，分为png，svg等多种格式；\n* `/usr/src` : linux 核心的原始码和说明文件等；\n    * `/usr/src/linux` : linux 原始码；\n# 文件属性\n\n![image-20220512112348998](../../images/Linux_初识Linux/image-20220512112348998.png)\n\n## 文件类型\n\n| 文件类型           | 符号表示 |\n| ------------------ | -------- |\n| 普通文件（文档）   | `-`      |\n| 目录文件（文件夹） | d        |\n| 管道文件           | p        |\n| 设备文件           | `c`、`b` |\n| 链接文件           | `l`      |\n| 套接字文件         | s        |\n\n## 文件权限\n\n| 文件权限 | 符号表示 | 二进制表示 | 十进制数 |\n| -------- | -------- | ---------- | -------- |\n| 无权限   | `-`      | 0000       | 0        |\n| 可读     | r        | 0100       | 4        |\n| 可写     | w        | 0010       | 2        |\n| 可执行   | x        | 0001       | 1        |\n\n### chmod改权限\n\n| 所有权范围   | 符号表示 |\n| ------------ | -------- |\n| 自己（属主） | u        |\n| 同组人       | g        |\n| 其他人       | o        |\n\n```bash\n#chmod 改权限\nchmod u-w main #属主 去除 写权限\nchmod o+w main #其他人 增加 写权限\n```\n\n# 基础命令\n\n## 基本文件操作\n\n```bash\n# 文件操作基本命令\ncd \t#切换目录\npwd #显示当前位置\nls \t#显示当前目录下有哪些文件\nls -l #显示详细信息\nls -a #显示隐藏文件\ntouch #创建普通文件\ntouch a.c\nmkdir tmp #创建tmp目录（文件夹）\ncp\nrm\nmv\ncat\nmore/less/head/tail\t# 优先学习more、tail\nvi/vim\t#编辑文件\n```\n\n### ls\n\n```bash\nls \t#显示当前目录下有哪些文件\nls -l #显示详细信息\nls -a #显示隐藏文件\n```\n\n### cd\n\n```bash\n#cd \t#切换目录\n\ncd \\\t#切换位置到根目录下\t#也可写作cd /\ncd tmp \t#进入tmp这个目录（文件夹）\ncd ~ \t#回到家目录\ncd .. \t#返回上一层\n#绝对路径\n#相对路径\n```\n\n### cp/mv\n\n```bash\ncp\t#拷贝\ncp a.c b.c #拷贝普通文件\ncp -r tmp tmp1 #拷贝文件夹，包括文件夹的内容，参数要加-r\ncp file.txt tmp\ncp file.txt tmp/file.txt\n\nmv\t#1.移动 2.重命名\n#mv对文件夹的操作不需要加-r\nmv a.c b.c #将a.c重命名为b.c\nmv dir1 dir2#将目录1重命名为目录2\nmv b.c dir#如果已经有dir这个目录，那么我们将会把b.c移动到dir里；如果不存在dir文件，则会重命名b.c为dir\nmv b.c dir/a.c #如果已经有dir这个目录，那么我们将会把b.c移动到dir里并重命名为a.c\n```\n\n### rm\n\n```bash\nrm\t#删除\nrm -f \t#不给提示报错的删除\nrm -d \t#删除文件夹（只能删除空的）\nrm -r \t#递归删除文件夹（包含里面所有内容）\nrm -rf\t#-r和-f的组合用法，强有力，一定要谨慎使用\nrmdir \t#删除空文件夹\n```\n\n## 高级文件操作\n\n### cat/more/less/head/tail\n\n```bash\ncat #1.打印文件内容 2.向文件输入内容 3.合并文件\ncat a.c #打印文件内容\ncat > a.txt#键盘输入内容，重定向到文件里。Ctrl+D结束输入。如果a.txt不存在，自动创建。\ncat a.c b.c > d.txt#把a.c和b.c的内容按顺序写到d.txt中。合并到另一文件中。\nmore #分屏幕显示，适于输出超过一个屏幕的文件内容，但只能看一次，空格是翻页，回车是下一行\nless #在more的基础上，可以回滚。退出按q\nhead #默认打印文件前10行\nhead -3 passwd #打印前三行\ntail #默认打印文件后10行\ntail -3 passwd #打印后三行 \n```\n\n### tar\n\n```bash\ntar zxf name.tar.gz #解包\n```\n\n### find\n\n```bash\nfind /home/xcg -name a.c #找某个目录下有无a.c\n```\n\n### grep\n\n## vi/vim\n\n### 关于vi的配置\n\n[vi默认的tab缩进是制表符，怎么改为空格？](https://www.cnblogs.com/hydah/archive/2012/04/10/2440225.html)\n\n对于使用vim的程序员来说，shiftwidth，tabstop，softtabstop绝对是经常接触的三个缩进因素。能否有方便美观的，整体化的缩进，主要是由他们相互间的配合决定。在经过一段时间试用后，总结一下我的设置经验。\n\n**shiftwidth**：\n\n这个是**用于程序中自动缩进所使用的空白长度**指示的。一般来说为了保持程序的美观，和下面的参数最好一致。同时它也是符号移位长度的制定者。\n\n**tabstop**：\n\n**定义tab所等同的空格长度**，一般来说最好设置成8，因为如果是其它值的话，可能引起文件在打印之类的场合中看起来很别扭。除非你设置了 **expandtab模式，也就是把tabs转换成空格**，这样的话就不会一起混淆，不过毕竟制表符为8是最常用最普遍的设置，所以一般还是不要改。\n\n**softtabstop**：\n\n如果我们希望改变程序中的缩进怎么办？shiftwidth和tabstop不一样的话，你会发现程序比较难看的。这时候，softtabstop就起作用了。可以从vim的说明中看到，**一旦设置了softtabstop的值时，你按下tab键，插入的是空格和tab制表符的混合**，具体如何混合取决于你设定的softtabstop，举个例子，如果设定softtabstop=8,那么按下tab键，插入的就是正常的一个制表符;如果设定 softtabstop=16,那么插入的就是两个制表符；如果softtabstop=12,那么插入的就是一个制表符加上4个空格；如果 softtabstop=4呢？那么一开始，插入的就是4个空格，此时一旦你再按下一次tab，这次的四个空格就会和上次的四个空格组合起来变成一个制表符。换句话说，softtabstop是“逢8空格进1制表符”,前提是你tabstop=8。\n\n关于**expandtab**\n\n举个例子，在多人一起开发项目时，为了使代码风格尽量保持一致，一般**不允许在代码使用TAB符，而以4个空格代之**。我们可以编辑一个文件，包含下面的内容：\nset shiftwidth=4\nset expandtab\n\n然后把下面的命令加入到.vimrc中：\nautocmd FileType c,cpp set shiftwidth=4 | set expandtab\n\n就可以只在编辑c和cpp文件时实行这种设置了\n\n \n\n删除掉每一行末尾的空格：\n\n行末：`$`\n行首：`^`\n空格：`\\s`\n行末空格：`\\s\\+$`\n行首空格：`^\\+\\s`\n有些人认为行末的空格是无用，浪费而难看的。要删除这些每行后面多余的空格，可以执行如下命令：\n`:%s/\\s\\+$//`\n命令前面指明范围是\"%\"，所以这会作用于整个文件。\"substitute\" 命令的匹配模式是\n`\"\\s\\+$\"`。这表示行末（$）前的一个或者多个（\\+）空格（\\s）。后面我们会介绍怎样\n写这样的模式。\n替换命令的 \"to\" 部分是空的：\"//\"。这样就会删除那些匹配的空白字符。\n另一种没有用的空格是 Tab 前面的字符。通常这可以删除而不影响格式。但并不是总这样！所以，你最好手工删除它。执行如下命令：\n/\n你什么都看不见，其实这是一个空格加一个 TAB 键。相当于 \"/\"。现在，\n你可以用 \"x\" 删除多余的空格，并保证格式没有改变。接着你可以用 \"n\" 找到下一个\n位置并重复这个操作。\n\n### 插入模式(编辑模式)\n\n`命令模式--i/a/o/s-->插入模式--ESC-->命令模式`\n\n- i:在光标所在字符前开始插入\n- a:在光标所在字符后开始插入\n- o:在光标所在行的下面另起一新行插入\n- s:删除光标所在的字符并开始插入\n- I:在光标所在行的行首开始插入 如果行首有空格则在空格之后插入\n- A:在光标所在行的行尾开始插入\n- O:在光标所在行的上面另起一行开始插入\n- S:删除光标所在行并开始插入\n\n### 命令模式\n\n`底行命令模式/插入模式--ESC-->命令模式`\n\n```bash\nr #只替换一个\nR #一直替换 按esc结束\nx #删除一个字符，但是不能删除空行\ncc #清除整行并进入插入模式\nshift+c或C #清楚本行光标及以后的内容，并进入插入模式\n/ #对文本进行全文向下搜索字符串string\t如：/text\n? #对文本进行全文向上搜索字符串string 如：?text\nG #切换到末尾行\n```\n\nvi打开文件，以搜索\"port\"为例：\n\n从开头处开始搜索：/port\n\n从结尾处开始搜索：?port\n\n向下搜索：n\n\n向上搜索：N，或者shift+n，或者shift+#\n\n### 底行命令模式\n\n`命令模式--:-->末行模式-->`\n\n1:**wq**保存并退出 2:**q!**强制不保存退出 3:**w**只保存 4:**q**仅退出\n\n```bash\n:n #切换到第n行\n```\n\n### 练习\n\n1. 复制51到60行，并且粘贴到最后一行后面\n\n   ```bash\n   50G\t\t#先跳转到50行\n   10yy\t#复制光标下10行\n   G\t\t#跳转到文件最末\n   p\t\t#粘贴复制内容\n   ```\n\n2. 删除11到30行之间的20行\n\n   ```bash\n   10G\t\t#先跳转到10行\n   20dd\t#删除光标下20行\n   ```\n\n3. 移动到第29行，并且删除15个字符。\n\n   ```bash\n   29G\t\t#先跳转到29行\n   15x\t\t#x表示删除光标所在位置的一个字符，X表示删除光标所在位置的前面一个字符，前面加数字可以删除指定个。\n   ```\n\n## gcc\n\n关于编译链接更多内容请查看文章“Linux_库”。\n\n```bash\ngcc -o main main.c\n```\n\n## 进程操作\n\n```bash\n# 进程操作基本命令\nps\t\t#查看当前终端中运行的进程\nkill\t#结束进程\njobs \t#查看后台运行的进程\n&\t\t#放到后台运行\n```\n\n## 帮助手册命令-man\n\n```bash\nman #帮助文档 1.命令 2.系统调用 3.库函数\n#printf 既有命令也有库函数，而man默认输出命令相关文档，所以要输出库函数时，我们要加 3\nman 3 printf\n```\n\n# 快捷键\n\n| 功能     | 快捷键     |\n| -------- | ---------- |\n| 打开终端 | Ctrl+Alt+T |\n\n# 一些需要搜索才知道的操作\n\n1. 网上下载的deb安装包双击后提示”软件无法安装:不支持“。\n\n   ```bash\n   sudo dpkg -i google-chrome-stable_current_amd64.deb\n   ```\n\n2. 关闭没有必要的动画特效\n\n   ```bash\n   gsettings set org.gnome.desktop.interface enable-animations false\n   ```\n\n3. 找不到环境文件夹——链接\n\n   https://stackoverflow.com/questions/3655306/ubuntu-usr-bin-env-python-no-such-file-or-directory\n\n   ```bash\n   whereis python3\n   sudo ln -s /usr/bin/python3 /usr/bin/python\n   ```\n\n","categories":["Linux"]},{"title":"Redis_dict","url":"/Redis/Redis_dict/","content":"\n# 引例\n\n图书馆借书问题，图书馆有成千上万本图书，最初，需要有一个本子记录哪一天学生记录的情况。最初以日期为编号记录某一天来借书的情况。当有人来还书时，需要先问清借书者是几号来借的，然后还要在这天的记录里依次找到具体信息。如果借书者清楚自己是几号借的还好说，但是如果不记得了呢？比如说他只记得好像是上上个月来借的，那么就需要一天一天的从头到尾查找记录，显然效率是低下的。\n![image-20210807233939705](../../images/Redis_dict/image-20210807233939705.png)\n那么我们可以如此改进：我们搞一个`000 0000 0000 ~ 199 9999 9999`页的本子，某同学借书时让他提供电话号码，以电话号码为基准记录信息。待还书时，只需要报电话号则可以直接找到记录。但此方法不现实，因为本子太厚，要花费的空间太大。\n![image-20210807234740133](../../images/Redis_dict/image-20210807234740133.png)\n再改进：做一个1000页的本子，因为电话号码的范围远远大于页数，我们要想办法使电话号码映射到页数，则这个映射方案则称为“哈希函数”。如A同学电话号码为137 3456 9090，可取后三位090，存到90页。B同学电话号码为186 7890 1234，取后三位234，存到234页。\n![image-20210807235252067](../../images/Redis_dict/image-20210807235252067.png)\n此时又来了一个C同学，电话号码为156 9090 1234，虽然关键码与B同学不一样，但位置信息一样，则称之为“哈希冲突”。\n# 哈希表\n\n## 什么是哈希表\n\n严蔚敏版本的数据结构教材中指出，在诸如线性表、树结构中，“记录”中结构中的相对位置是随机的，和“记录”的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。比如，数组存放的从小到大的10个数据，要用二分查找法找出某value的下标值就需要一直探测。这一类查找方法建立在“比较”的基础上。在顺序查找时，比较的结果为“=”与“≠”两种可能；在折半查找、二叉排序树查找和B树查找时，比较的结果为“<”、“=”和“>”3种可能。查找的效率依赖于查找过程中所进行的比较次数。\n\n我们所向往的理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的**存储位置**和它的**关键字**之间建立一个确定的对应关系f，使每个关键字和结构中一个惟一的存储位置相对应。因而在查找时只要根据这个对应关系f找到给定值K的“像”f(K)便能找到其存储位置。若结构中存在关键字和K相等的记录，则必定在f(K)这个存储位置上，由此不需要比较便可直接取得所查记录。在此我们称这个对应关系f为**哈希（Hash）函数**，由此思想建立的表称为**哈希表**。\n\n```c\n#include<stdio.h>\n#include<assert.h>\n#define NIL -1\n#define m 13\ntypedef int KeyType;\nstruct ElemType\n{\n  \tKeyType key;\n    void* ptr;\t//value\n};\ntypedef struct\n{\n    ElemType data[m];\n    int cursize;\n}HashTable;\n```\n\n![image-20210808011308669](../../images/Redis_dict/image-20210808011308669.png)\n\n```c\nvoid Init_HashTable(HashTable* pt)\n{\n    assert(pt != nullptr);\n    pt->cursize = 0;\n    for(int i=0;i<m;++i)\n    {\n        pt->data[i].key = NIL;\n        pt->data[i].ptr = nullptr;\n    }\n}\nint Hash(KeyType kx)\n{\n    return kx%m;\n}\nbool Insert_Item(HashTable* pt, ElemType item)\n{\n    assert(pt != nullptr);\n    int index = Hash(item.key);\n    pt->data[index] = item;\n    pt->cursize += 1;\n}\nint main()\n{\n    HashTable ht;\n    Init_HashTable(&ht);\n    int ar[]={12,23,25,8,19,29};\n    int n=sizeof(ar)/sizeof(ar[0]);\n    for(int i=0;i<n;++i)\n    {\n        struct ElemType item = {ar[i],nullptr};\n        bool tag = Insert_Item(&ht,item);\n    }\n}\n```\n\n但是这种Insert_Item函数是有问题的，没有解决**哈希冲突**问题，比如在插入key为25的元素时会替换掉前期已经插入的key为12的元素。\n\n![image-20210808013500159](../../images/Redis_dict/image-20210808013500159.png)\n\n以下来通过 **（增量）线性探测法**来解决哈希冲突。\n\n```c\nint Inc(int i)\n{\n    return i;\n}\nint Hash_Inc(KeyType kx, int i)\n{\n    return (Hash(kx) + Inc(i))%m;\n}\nbool Insert_Item(HashTable* pt, ElemType item)\n{\n    assert(pt != nullptr);\n    for(int i = 0;i<m;++i)\n    {\n        int index = Hash_Inc(item.key, i);\n        if(pt->data[i].key == NIL)//随着Inc更迭，找到一个空位置\n        {\n            pt->data[index] = item;\n            pt->cursize += 1;\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n```c\nint main()\n{\n    HashTable ht;\n    Init_HashTable(&ht);\n    int ar[]={12,15,28,23,25,38,36,49,14};\n    int n=sizeof(ar)/sizeof(ar[0]);\n    for(int i=0;i<n;++i)\n    {\n        struct ElemType item = {ar[i],nullptr};\n        bool tag = Insert_Item(&ht,item);\n    }\n}\n```\n\n![image-20210808015044675](../../images/Redis_dict/image-20210808015044675.png)\n\n这种**线性探测法**虽然解决了哈希冲突，但最终的数据分布太堆积化。可以通过**平方探测法**改善此问题。\n\n```c\nint Inc(int i)\n{\n    return i*i;\n}\n```\n\n但无论是**线性探测法**存储还是**平方探测法**存储，在这种纯顺序表（数组）中实现哈希表会遇到一个严重的问题！即插入数据后，不能轻易删除某一个数据，因为删除了某一数据后，查找另外的数据就会出现数据断层导致不能正常探测。比如下图：如果把3下标的28删除，则查找key为49的元素时，第一次探测49%13=10，23不等于49，第二次探测（线性探测，下标+1），36不等于49，第三次探测，12不等于49，……，直到探测到下标3，发现key值为-1。如果我们停止探测返回，则是错误的；所以我们只能遇到-1不停止继续探测，那么就失去了哈希表的意义，这相当于在查某个key对应的value时有可能把整个表都遍历了一遍。\n\n```c\nvoid* FindValue(HashTable* pt, KeyType kx)\n{\n    assert(pt != nullptr);\n    for(int i = 0;i<m;++i)\n    {\n        int pos = Hash_Inc(kx,i);\n        if(pt->data[pos].key==kx)\n        {\n            return pt->data[pos].ptr;\n        }\n        if(pt->data[pos].key==NIL)\n        {\n            return nullptr;\n        }\n    }\n}\n```\n\n![image-20210808020035825](../../images/Redis_dict/image-20210808020035825.png)\n\n## 链地址法\n\n所以我们要改变这种存储哈希表的方式，改用**链地址法**存储。（视频01:27:42）\n\n![image-20210808191518194](../../images/Redis_dict/image-20210808191518194.png)\n\n看图设计结构\n\n```c\n#include<stdio.h>\n#include<assert.h>\n#define m 13\ntypedef int KeyType;\ntypedef struct ElemType\n{\n    KeyType key;\n    void* ptr;\n}ElemType;\ntypedef struct HashNode\n{\n    ElemType data;\n    struct HashNode* next;\n}HashNode;\ntypedef struct HashTable\n{\n    HashNode* table[m];\n    int cursize;\n}HashTable;\n```\n\n### 测试代码\n\n```c\nint Hash(KeyType kx)\n{\n    return kx % m;\n}\nvoid Init_Hash(HashTable* pt)\n{\n    assert(pt!=nullptr);\n    for(int i = 0;i<m;++i)\n    {\n        pt->table[i] = nullptr;\n    }\n    pt->cursize = 0;\n}\nvoid Insert_Item(HashTable* pt, ElemType item)//但是此函数没有解决存在相同key时的情况\n{\n    assert(pt!=nullptr);\n    int index = Hash(item.key);\n    HashNode* s = (HashNode*)malloc(sizeof(HashNode));\n    if(nullptr == s) exit(1);\n    s->data = item;\n    s->next = pt->table[index];\n    pt->table[index] = s;\n    pt->cursize += 1;\n}\nint main()\n{\n    int ar[]={1,55,19,20,10,11,14,68,84,23,27,79};\n    int n = sizeof(ar)/sizeof(ar[0]);\n    HashTable ht;\n    Init_Hash(&ht);\n    for(int i = 0;i<n;++i)\n    {\n        ElemType elem = {ar[i],nullptr};\n        Insert_Item(&ht,elem);\n    }\n}\n```\n\n## API\n\n### Init\n\n```c\nvoid Init_Hash(HashTable* pt)\n{\n    assert(pt != nullptr);\n    for(int i = 0;i<m;++i)\n    {\n        pt->table[i]=nullptr;\n    }\n    pt->cursize=0;\n}\n```\n\n### Insert\n\n```c\nvoid Insert_Item(HashTable* pt, ElemType item)\n{\n    assert(pt != nullptr);\n    int index = Hash(item.key);\n    HashNode* pnode = (HashNode*)malloc(sizeof(*pnode));\n    if (nullptr == pnode) exit(1);\n    pnode->data = item;//讲外部elem封装到新建结点的数据域\n    //以下两步为入表操作，采用头插法，时间复杂度为O(1)，不用判头结点是否为空\n    pnode->next = pt->table[index];\n    pt->table[index] = pnode;\n    \n    pt->cursize++;//现有大小+1\n}\n```\n\n### FindNode\n\n查看字典中是否已存在某key值对应的节点并返回。\n\n```c\nHashNode* FindNode(HashTable* pt, KeyType kx)\n{\n\tint index = Hash(kx);\n\tHashNode* p = pt->data[index];\n\twhile (p != nullptr && p->item.key != kx)\n\t{\n\t\tp = p->next;\n\t}\n\treturn p;\n}\n```\n\n### Clear\n\n自己写的\n\n```c\n//free掉所有节点，HashTable的指针数组数据全赋空\nvoid ClearTable(HashTable* pt)\n{\n\tfor (int i = 0;i < m;++i)\n\t{\n\t\tHashNode* p = pt->data[i];\n\t\tHashNode* q = nullptr;\n\t\twhile (p)\n\t\t{\n\t\t\tq = p->next;\n\t\t\tfree(p);\n\t\t\tpt->cursize--;\n\t\t\tp = q;\n\t\t}\n\t\tpt->data[i] = nullptr;\n\t}\n}\n```\n\n老师写的\n\n```c\nvoid ClearHash(HashTable* pt)\n{\n    for(int i = 0;i<m;++i)\n    {\n        while(pt->data[i]!=nullptr)\n        {\n            HashNode* q = pt->data[i];\n            pt->data[i]=q->next;\n            free(q);\n        }\n    }\n    pt->cursize=0;\n}\n```\n\n### Remove\n\n```c\n//删除某一节点，需用到两个指针变量，一前一后。\nvoid RemoveNode(HashTable* pt, KeyType kx)\n{\n\n\tint index = Hash(kx);\n\tHashNode* p = pt->data[index];\n\tif (p == nullptr) exit(1);//不存在要删除的key的对应节点，因为Table数组此下标的值既然为空则肯定不会有key值相应的节点存在\n\tHashNode* q = p->next;\n\t//若删除的节点为头结点，则特殊处理\n\tif (p->item.key == kx)\n\t{\n\t\tpt->data[index] = q;\n\t\tfree(p);\n\t}\n\telse//\n\t{\n\t\twhile (q != nullptr && q->item.key != kx)\n\t\t{\n\t\t\tp = p->next;\n\t\t\tq = q->next;\n\t\t}\n\t\tif (q == nullptr) exit(1);//不存在要删除的key的对应节点，因为遍历这一条链后不存在相同的key值对应的节点。\n\t\telse//q->item.key == kx\n\t\t{\n\t\t\tp->next = q->next;\n\t\t\tfree(q);\n\t\t}\n\t}\n\tpt->cursize--;\n\treturn;\n}\n```\n\n老师写法\n\n```c\n//Remove节点更老套的写法：\nbool Remove(HashTable* pt,KeyType kx)\n{\n    assert(pt!=nullptr);\n    int index=Hash(kx);\n    HashNode* pr=nullptr;//前驱指针\n    HashNode* p=pt->table[index];\n    while(p!=nullptr)\n    {\n        if(p->item.key==kx)\n        {\n            if(pr!=nullptr)\n            {\n                pr->next=p->next;\n            }\n            else\n            {\n                pt->table[index]=p->next;\n            }\n            free(p);\n            pt->total-=1;\n            return true;\n        }\n        pr=p;\n        p=p->next;\n    }\n    return false;\n}\n```\n\n## 习题\n\n定义大小为100 的整型数组，使用随机函数给数组元素赋值。数值的范围是1 .. 100 ，并且不容许重复。\n\n```c\nint* My_NonRepeating_RandArr(int* ar, int n)\n{\n    assert(ar != nullptr);\n    int br[101];\n    for (int i = 0;i < n + 1;++i)\n    {\n        br[i]=0;\n    }\n    int temp;\n    srand(time(NULL));\n    int i = 0;\n    do\n    {\n        temp = rand() % 100 + 1;\n        if (br[temp] != 1)\n        {\n            br[temp] = 1;\n            ar[i] = temp;\n            ++i;\n        }\n    } while (i<n);\n    return ar;\n}\n```\n\n如果题中数组大小改为1000000，那么数组开辟空间就很大，如果仍然按照旧的方式去做肯定是对程序不利的。考虑用哈希算法解决！\n\n```c\n#include<stdio.h>\n#include<assert.h>\n#define m 100\ntypedef int KeyType;\ntypedef struct ElemType\n{\n    KeyType key;\n    void* ptr;\n}ElemType;\ntypedef struct HashNode\n{\n    ElemType data;\n    struct HashNode* next;\n}HashNode;\ntypedef struct HashTable\n{\n    HashNode* table[m];\n    int cursize;\n}HashTable;\nvoid Init_Hash(HashTable* pt)\n{\n    assert(pt != nullptr);\n    for(int i = 0;i<m;++i)\n    {\n        pt->table[i]=nullptr;\n    }\n    pt->cursize=0;\n}\nvoid Insert_Item(HashTable* pt, ElemType item)\n{\n    assert(pt != nullptr);\n    int index = Hash(item.key);\n    HashNode* pnode = (HashNode*)malloc(sizeof(*pnode));\n    if (nullptr == pnode) exit(1);\n    pnode->data = item;//讲外部elem封装到新建结点的数据域\n    //以下两步为入表操作，采用头插法，时间复杂度为O(1)，不用判头结点是否为空\n    pnode->next = pt->table[index];\n    pt->table[index] = pnode;\n    \n    pt->cursize++;//现有大小+1\n}\nint Hash(KeyType kx)\n{\n    return kx%m;\n}\nHashNode* FindValue(HashTable* pt, KeyType kx)\n{\n    int index = Hash(kx);\n    HashNode* p = pt->table[index];\n    while(p != nullptr && p->data.key != kx)\n    {\n        p=p->next;\n    }\n    return p;\n}\nint* My_NonRepeating_Hash(int* ar, int n)\n{\n    assert(ar != nullptr);\n    HashTable ht;\n    Init_Hash(&ht);\n    int temp;\n    srand(time(NULL));\n    int i = 0;\n    do\n    {\n        temp = rand()* rand() % 1000000 + 1;\n        if (FindValue(&ht, temp) == nullptr || *(int*)(FindValue(&ht, temp)->data.ptr) != 1)\n        {\n            ElemType item = { temp,new int(1) };\n            Insert_Item(&ht, item);\n            ar[i] = temp;\n            ++i;\n        }\n    } while (i < n);\n    return ar;\n}\nint main()\n{\n    \n}\n```\n\n老师写的\n\n```c\n#include<assert.h>\n#define m 13\n#define INC\t2\ntypedef int KeyType;\ntypedef struct\n{\n    KeyType key;\n    void* ptr;\n}ElemType;\ntypedef struct HashNode\n{\n    ElemType data;\n    struct HashNode* next;\n}HashNode;\ntypedef struct HashTable\n{\n    HashNode** table;\n    int capacity;\n    int total;\n}HashTable;\nint Hash(HashTable* pt, KeyType kx)\n{\n    //return kx % m; //原始不考虑增容的情况下默认%m\n    return kx % pt->capacity;\n}\nvoid Init_Hash(HashTable* pt)\n{\n    assert(pt!=nullptr);\n    pt->table = (HashNode**)malloc(sizeof(HashNode*)*m);\n    if(pt->table == nullptr)exit(EXIT_FAILURE);\n    pt->capacity = m;\n    for(int i = 0;i<pt->capacity;++i)\n    {\n        pt->table[i] = nullptr;\n    }\n    pt->total = 0;\n}\nHashNode* FindNode(HashTable* pt, KeyType kx)\n{\n    int index = Hash(pt,kx);\n    HashNode* p = pt->table[index];\n    while(p != nullptr && p->data.key != kx)\n    {\n        p=p->next;\n    }\n    return p;\n}\nbool Inc(HashTable* pt)//对哈希表的增容操作\n{\n    int incsize = pt->capacity * INC;//INC为增容系数，默认为2，incsize表示增容后的新大小，为此前哈希表容量的2倍。\n    HashNode** newtable = (HashNode**)malloc(sizeof(HashNode*)*incsize);\n    if(newtable == nullptr)return false;\n    for(int i = 0;i<incsize;++i)\n    {\n        newtable[i] = nullptr;\n    }\n    pt->captacity = incsize;\n    //以上，开辟新的哈希表完毕，下面要把旧表复制到新表\n    int oldsize = pt->capacity;\n    for(int i = 0;i<oldsize;++i)\n    {\n        if(pt->table[i]!=nullptr)\n        {\n            \n        }\n    }\n}\nbool Insert_Item(HashTable* pt, ElemType item)\n{\n    assert(pt!=nullptr);\n    HashNode* p = FindNode(pt,item.key);\n    if(p!=nullptr)return false;//哈希表中已存在相同key值的节点\n    if(pt->total > pt->capacity && !Inc(pt))//需要增容但没有增容成功\n    {\n        return false;\n    }\n    int index \n}\n```\n\nC++就一个东西引用返回，B站的老师永远搞不清楚\n\n# Redis字典\n\n字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。\n在字典中，一个键(key)可以和一个值(value)进行关联（或者说将键映射为值），这些关联的键和值就称为键值对。\n字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对，等等。\n字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此 Redis构建了自己的字典实现。\n字典在Redis中的应用相当广泛，比如 Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。\n\n## 与相似结构对比\n\nHashTable是无序的；\nMap是有序的；HashMap是无序的，底层有红黑树实现。因此Map效率较低。\n\n## 字典的实现\n\nRedis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。\n\n### 哈希表\n\nRedis字典所使用的哈希表由dict.h/dictht结构定义：\n\n```c\ntypedef struct dictht\n{\n    dictEntry** table;//哈希表数组\n    unsigned long size;//哈希表大小\n    unsigned long sizemark;//哈希表大小掩码，用于计算索引值。总是等于size-1\n    unsigned long used;//表中已有节点的数量\n}dictht;\n```\n\n成员table的功能是一个数组（指向首元素的指针），数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。\n\n![image-20210818030916272](../../images/Redis_dict/image-20210818030916272.png)\n\n### 哈希表节点\n\n即dictEntry结构。\n\n```c\ntypedef struct dictEntry\n{\n    void* key;\n    union\n    {\n        void* val;\n        uint64_tu64;\n        int64_ts64;\n    }v;\n    struct dictEntry* next;\n}dictEntry;\n```\n\n![image-20210818031224095](../../images/Redis_dict/image-20210818031224095.png)\n\n### 字典\n\nRedis中的字典由dict.h/dict结构表示\n\n```c\ntypedef struct dictType \n{\n    // 计算哈希值的函数\n    unsigned int (*hashFunction)(const void *key);\n    // 复制键的函数\n    void *(*keyDup)(void *privdata, const void *key);\n    // 复制值的函数\n    void *(*valDup)(void *privdata, const void *obj);\n    // 对比键的函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2);\n    // 销毁键的函数\n    void (*keyDestructor)(void *privdata, void *key);\n    // 销毁值的函数\n    void (*valDestructor)(void *privdata, void *obj);\n} dictType;\ntypedef struct dict\n{\n    dictType* type;//结构体指针，用于存放特定类型的操作函数\n    void* privdata;//私有数据\n    dictht ht[2];//内部定义了两个哈希表\n    int rehashidx;//当没有在rehash时值为-1\n}dict;\n```\n\n![image-20210818032212233](../../images/Redis_dict/image-20210818032212233.png)\n\n# 面试\n\n1. 渐进式增容/缩容\n2. 一致性哈希--解决负载均衡的问题。比如登陆项目。一千万个用户同时登陆。\n3. 操作系统一定要开始看了，内存管理、进程管理、线程管理。\n\n# dictDelete\n\n1. 删除第一节点\n2. 删除后个数会少，要处理\n\n# time\n\n```c\n/*\n * 返回以毫秒为单位的 UNIX 时间戳\n *\n * T = O(1)\n */\nlong long timeInMilliseconds(void) \n{\n    struct timeval tv;\n\n    gettimeofday(&tv,NULL);\n    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);\n}\n/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */\n/*\n * 在给定毫秒数内，以 100 步为单位，对字典进行 rehash 。\n *\n * T = O(N)\n */\nint dictRehashMilliseconds(dict *d, int ms) \n{\n    // 记录开始时间\n    long long start = timeInMilliseconds();\n    int rehashes = 0;\n\n    while(dictRehash(d,100)) {\n        rehashes += 100;\n        // 如果时间已过，跳出\n        if (timeInMilliseconds()-start > ms) break;\n    }\n\n    return rehashes;\n}\n```\n\n","categories":["高级数据结构","Redis"]},{"title":"微机原理","url":"/微机原理/微机原理/","content":"# 二进制转化为十进制\n\nhttps://blog.csdn.net/weixin_42857472/article/details/103966229\n\n## 除10取余法\n\n设计程序时候的二进制转化为十进制的算法\n二进制转化为十进制（除10取余法）\n\n除10取余法中，对于二进制转化为10进制来讲要除于1010，就是把10转化为二进制数，再用二进制数除于1010\n\n例如：二进制11101除于1010，余数1001，转化为十进制数为9，这个是相当于十进制数的个位，再用中间商0010再除于1010，余数为0010，转化为十进制数为2，相当于十进制数的十位。\n\n![image-20210725001626129](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210725001626129.png)\n\n## 比较法\n\n假如一个数393\n最高位为百位，所以让393和100比较\n如果393>=100\n则393减去100，然后统计百位的数＋1，然后用结果差继续和100比较，也就是293和100比较，仍然大于，所以293再减去100，统计一百的数再+1，直到不大于一百了，说明这个数没有百位只有十位和个位了，所以和10比较，类似的减去10，然后统计十位的数+1，再继续比较，知道不大于十，那么剩下的就是个位的数了。\n\n二进制转化为十进制的话比较的对象100就要化成二进制，即1100100\n十的二进制就是1010。\n\n比如(11101)2-->(29)10：11101>1010，十位+1；11101-1010=10011>1010，十位+1；10011-1010=1001<1010，十位结束，(1001)2=(9)10。则结果为(29)10。\n\n# 8位寄存器\n\n以8086为例，虽然8086是16位处理器，但也可以以8位方式存储数据到寄存器中。\n\n8位寄存器有：AH、AL。H代表高八位，L代表低八位，AH与AL一起组成AX寄存器即16位寄存器。相应地，BH、BL；CH、CL；DH、DL，也是8位寄存器。BX、CX、DX是16位寄存器。\n\n# 二进制数的运算\n\n## 算术运算+、-、*、/\n\n比如97+89\n\n```x86asm\nmov AL,97\t;汇编后:B0 61\t;B0h就表示“把一个字节数传送给AL寄存器中”的机器源代码，61h代表97的十六进制。\nadd AL,89\t;(AL)=BAh\t;带括号就表示括号中地址的内容，此处表示AL寄存器的内容\n```\n\n\n\nmov AL,97 <---> B0 61    ;B0h就表示“把一个字节数传送给AL寄存器中”的机器源代码，61h代表97的十六进制。\n\n\n\n# 处理器状态字寄存器PSW\n\n也称为标志寄存器，主要用于CPU运算后根据结果设置各个标志，一个标志一个状态，一个状态用一个bit位表示。\n\n# 补码\n\n补码的范围有一个疑惑点。假如一个8位补码，可以表示的范围是-128~+127，如果只是按照老师上课讲的“取反加一法”来看，就会不清楚-128这个数是怎么来的。因为带符号位（带符号位这种说法是有误的，下面会提到）的8位二进制码的绝对值最大是127。\n\n这时，我们要深刻地纠正我们对补码概念的误区。\n\n补码的范围https://www.zhihu.com/question/20458542/answer/40759880\n补码的定义https://blog.csdn.net/xiang_shao344/article/details/118490004\n\n第一步，就像练北冥神功要先散功一样，先把你心中对原码，反码，补码的一套认识全部忘掉。\n\n第二步，正式开讲\t\n\n首先灌输一个新的概念叫，**模**\n什么是“模”，想象日常使用的钟表，它可以显示0～12点的时间，假设现在是2点钟，请用手动拨动时针的方式将时间减4小时，你会怎么做？\n有两种方式：\n\n1. 逆时针将时针拨4小时\n2. 顺时针将时针拨8（12-4）小时\n\n这里要讲的是第二种方式，为什么顺时针拨12-4也可以达到和正常思维的第一种方式一样的位置。\n12就是模。\n同样的，如果是十进制的两位数，80-10 和 80＋90在不考虑百位数的基础上都是70。这里的90就是100-10得来的，这种情况下100就是模\n模就好比是一个极限，在它的范围内，两个相加等于模的数互为补数，还是举100的例子\n90和10， 55和45，68和32，互为补数\n在模的范围内做减法，可以将“X－Y”的减法变更为“X＋Y的补数“的加法，当然前提是不考虑百位数。\n\n**思考题**，*上面举的例子是大数减小数，那么如果是小数减大数会怎么样呢？*\n\n如果是10-80，结果应该是－70，但如果按照10+（100-80），结果是30。\n而很明显－70和30不是一回事，这里也没有百位数的问题，这种情况应该怎么破？\n当初的那些先贤们想出来的办法很简单，就是把这两个数直接划上等号，正好顺便解决了负数的表达方式。再来仔细看看这两个数的关系：－70绝对值的补数就正好是30\n所以在计算机中，**负数的表达方式就是它绝对值的补数**\n但是问题又来了，看起来这个解决方式很完美了，但别忘了，30他已经代表了正数的30了，现在又要用来代表负数的－70，谁知道它出现的时候到底是代表哪个数？\n为了解决这个问题，需要给这套规则划定一个范围，原来是0～99的正数，现在既然要用部分正数来代替负数了，那就要规定一个范围来使得一个数只代表一个含义，正好一人一半，0～49这个区间就代表正数，50～99的区间就用来代表各自补数的负值，例：98就代表－2\n\n第三步，现在回到二进制的计算机世界\n\n8位二进制数一共可以表示2的8次方，256个数，即0～255 （别忘了0也要占一位的），他们的极限就是256，即256是8位二进制数的模 ，应该不难理解吧，同上十进制的两位数0～99的模是100。\n还是用二进制来说明清楚，8位二进制能表示的数的极限是\n1 1 1 1 1 1 1 1， 就是255，在这基础上加0 0 0 0 0 0 0 1，出现了进一位 即 1 0 0 0 0 0 0 0 0\n这个1 0 0 0 0 0 0 0 0就是8位二进制数的模，256\n\n同样按照第二步讲的逻辑，一半的数0～127，代表其正数本身，另一半的数 128～255，代表其补数的负值，即“－1～－128”的区间。\n而 “X－Y”的减法 就用 “X＋Y的补数” 的加法来表示，完美！ 唯一需要注意的事情是任何计算的输入值和输出结果值都需要严格遵守－128～127的范围，一旦溢出就会报错。\n这也就是我们在编程里强调的为什么 byte＋byte还得是byte，int＋int还得是int，数据溢出问题也是每一个程序员都需要注意的问题。\n\n这样一说是不是可以理解－128的补码是怎么来的了吧？ 他就是256 - |-128|＝128\n二进制的128是不是就是1 0 0 0 0 0 0 0 ？\n\n最终问题，那书和老师为什么要用原码，反码来讲补码 ？\n\n空穴来风，未必无因\n那是因为计算机就是这样求负数的补码的，我们在键盘上敲一个负数的时候，计算机要把它用补码的形式存储下来，还记得上面我们讲的补码是怎么来的吗？\n模－绝对值，这是不是个减法公式？但计算机没有减法逻辑，我们费了那么大的劲搞了一套补码的规则就是为了用加法来替代减法，但为了实现这么套规则，却跨不过一个坎，就是把负数计算成补码仍然是需要减法逻辑的。怎么办呢，那些伟大的先贤们 （膜拜）就想出了这么个办法：\n首位不变，其余位取反后，再加一\n\n问题：上面说到了，负数计算成补码需要取反加1，但-128在8位数中，没有其原码表示形式，如果要人工手工计算，将-128先看做是9位带符号数，再转换为补码：1 1000 0000首位不变，其余取反加1会变成1 1000 0000，进位溢出舍去，即为1000 0000。\n\n下面是吐槽\n\n不知道是哪个书呆子教书，照搬了机器的逻辑，把取反加一的方法当做补码的计算逻辑就这么教下来了。搞笑的是，还保留了补码这个名字，照理说这种教法应该叫 取反加一码 更合理，你还补什么啊？\n不仅如此，还搞出了个首位符号位的说法，弄出了个正0负0，还用负0来充当－128，真是不把人弄疯不罢休啊！！\n\n# 寄存器\n\n## 通用寄存器\n\n### 数据寄存器\n\n#### AX\n\n累加\n\n#### BX\n\n基址寄存器\n\n#### CX\n\n计数器\n\n#### DX\n\n数据寄存器。在I/O端口的IN/OUT操作中充当I/O地址寄存器。\n\n### 地址指针与变址寄存器\n\n#### 地址指针寄存器\n\n##### SP\n\n堆栈指针寄存器--用来指示PUSH/POP堆栈操作时所操作单元的段内16位地址的寄存器。\n\n##### BP\n\n地址指针寄存器--作用和BX基址寄存器是一样的，都可以存放16位段内偏移地址，但是是有区别的，存放16位段内偏移地址不在同一个逻辑段，CPU默认BX在DS数据段，BP在SS堆栈段。CPU默认BP指向的是SS段的地址。\n当然，想要BP指向数据段也可以，必须在汇编语句中写明前缀，称之为**段超越前缀**，如：\n\n```X86ASM\nMOV AL,56H\nMOV BP,0003H\nMOV DS:[BP],AL\n```\n\n#### 变址寄存器\n\n##### SI\n\n源变址寄存器\n\n##### DI\n\n目的变址寄存器\n\n\n\n#### 总结\n\n用BX/SI/DI外加中括号即间接找到的地址都默认在DS段内。只用BP中括号间接找到的地址默认在SS段内。\n\n![image-20210726185205000](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726185205000.png)\n\n## 段寄存器\n\n分别放的是各自逻辑段的段地址\n\n### CS\n\n代码段寄存器。CS的值指明的是，程序代码所在的那个逻辑段的段地址。\n\nCS初始化的值用户不可设置，由操作系统决定。\n\n### DS\n\n数据段寄存器\n\n### ES\n\n附加数据段寄存器\n\n### SS\n\n堆栈段寄存器\n\n## 控制寄存器\n\n### IP\n\n指令指针寄存器。等效于一般处理器中程序计数器PC的作用。即用于CPU取指令时需要用到的偏移地址寄存器。与CS（代码段）不可分家，CS:IP。\n\n### PSW\n\n处理器状态字寄存器。16位寄存器，但有用的只有9位。\n\n![image-20210726144858440](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726144858440.png)\n\n9位分为两类标志。\n\n#### 状态标志（6个）\n\nZF、CF、PF、OF、SF、AF。反映的是ALU运算后结果的状态。\n\n只有运算指令执行后才会影响这些状态值的改变。\n\n#### 控制标志（3个）\n\nIF、PF、TF。用来控制CPU的运行状态的。\n\n##### DF\n\n方向控制标志。用于控制字符串操作中SI和DI变址的方向。\n\n```X86ASM\nCLD\t;DF=0;控制SI/DI加1或2\nSTD\t;DF=1;控制SI/DI减1或2\n```\n\n![image-20210726150833012](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726150833012.png)\n\n##### IF\n\n中断允许标志。\n\n执行用户程序期间，某个特殊事件发生，让CPU暂时停止正在执行的程序，转去为该事件服务，即去执行中断服务子程序。服务完成后，CPU尚可返回到刚才中止的位置继续执行。\n\nCLI会置0，STL会置1。\n\n如果IF为0，则会屏蔽外部中断请求（8086的18脚INTR输入）。但CPU芯片内部中断不可屏蔽。\n\n##### TF\n\n陷阱（单步）标志。Debug专用。\n\n没有清零置一的指令。那该如何设计程序使TF置1？\n\n![image-20210726151453188](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210726151453188.png)\n\n以上程序：先PUSHF（F即PSW），再POP给AX赋值；再OR把AX中第九位置1；将AX压栈，在POPF给PSW赋值。\n\nTF在PSW寄存器的第九位（如果从0开始，是第8位），我们知道，OR语句可以让数据置1，则让PSW或上0000 0001 0000 0000即可使TF置1。\n\n如果TF标志为1，则程序将进行单步操作。常用于Debug调试。\n\n# 8086存储器和I/O组织\n\n## 存储器地址空间与数据存放格式\n\n### 地址空间\n\nA_19\\~A_16/A_15\\~A_10/A_9\\~A_0：均为外部存储器编址。所以能寻址的空间为2^20字节即1MB。\n\n低16位给外部I/O端口编址。I/O地址空间为2^16字节=64KB。\n\n在IBM PC机中只用了低10位给I/O分配地址，地址空间为1KB。前512个I/O地址即000H\\~1FFH给主板上的I/O分配地址；后512个I/O地址即200H\\~3FFH给插件版上的I/O分配地址。\n\n### 数据存放格式\n\n字节型、字型、双字型。\n\n#### 字节型数据\n\n字节型数据定义伪指令：DB（Data Byte）\n\n字型数据定义伪指令：DW（Data Word）\n\n双字型数据定义伪指令：DD（Data Double）\n\n## 存储器的分段与物理地址的形成\n\n### 分段\n\n#### 1、为什么分段？\n\n地址线有20根，而寄存器只有16位，无法直接管理2^20位空间。我们可以通过给内存分段使16位寄存器有效管理若干段（最少2^4=16段）的每个逻辑段的2^16位信息。\n\n#### 2、怎么分？\n\n根据需求进行分段，每段最大2^16=64KB。每个逻辑段的起始地址必须能被16整除。\n\n### 已知某存储器单元的逻辑地址，求物理地址\n\n PA（Physical Address）=段地址\\*10H + 段内偏移地址（也称段内有效地址EA(Effective Address)）\n\n段地址\\*10H 就相当于左移一位。\n\n例：逻辑地址0001H: 0010H，PA=0001H*10H + 0010H=00010H+0010H=00020H\n\n# 8086CPU的指令系统\n\n## 名词解释\n\n指令：\n\n指令系统：CPU能识别的所有指令的集合\n\n机器语言：指令代码语言\n\n机器语言程序：用户用机器语言编写的程序\n\n汇编语言：一种符号化语言，用一组符号和数字替代CPU能认识的指令。如MOV AL,12H替换了B0 12。\n\n汇编语言（源）程序：用户用汇编语言编写的程序，但CPU不能直接执行，必须要翻译为机器语言程序\n\n汇编：将汇编语言（源）程序翻译为机器语言程序的过程。\n\n反汇编：将机器语言程序翻译为汇编语言（源）程序的过程。\n\n# 8086汇编语言程序\n\n## 语句的种类\n\n### 指令语句\n\nCPU能执行的语句称为指令语句；\n\n能汇编/翻译成二进制指令代码的语句，称为指令语句。\n\n### 伪指令语句\n\nCPU不能执行的语句称为指令语句；\n\n汇编时不能汇编/翻译成二进制指令代码的语句，称为伪指令语句。如\"DB\"，只是告诉汇编程序（masm.exe）开始定义字节型数据，开始分配空间。这条语句是汇编时完成的，并不是执行时完成的。\n\n### 宏指令语句\n\n本身是8086指令系统没有的指令，是用户用**宏定义伪指令**定义的一条新的语句。\n\n## 汇编语言中语句的组成\n\n名称+助记符+操作数+注释\n\n变量名称、标号名必须以字母打头，操作数必须以0~9打头。\n\n```x86asm\nDAT1 DB 12H,-12,12\t;注释\t;DAT1为变量名\nDAT2 DW ?\t;定义时若不赋值，则需标问号;可以MOV DAT2,AX写入数据\n...\nNEXT: MOV AX,BX\t\t;NEXT为标号名，将此处语句的地址符号化\n...\nADD AX,DAT2\t\t\t;\nJZ NEXT\t\t\t\t;判ZF标志是否为1，若为1则说明AX加和为0，则跳转的条件满足，则跳至NEXT\n```\n\n## 汇编语言中的常数及表达式\n\n### 常数\n\n十六进制常数，以H结尾；二进制常数，以B结尾；十进制常数，以D结尾，可以缺省\n\n字符常数'A'；字符串常数'THIS IS A ...'\n\n### 表达式\n\n#### 算术表达式\n\n#### 逻辑表达式\n\nAND/OR/NOT\n\n#### 关系表达式\n\nLT: 小于\n\n\n#### 属性表达式\n\n##### 标号\n\n标号一旦定义了，就具有3个属性。\n\n1. 16位段地址。获取属性操作符：SEG\n\n2. 16位段内偏移地址。获取属性操作符：**OFFSET（常用）**\n\n   ```x86asm\n   MOV BX,OFFSET NEXT\t;NEXT是标号名称\n   ```\n\n   \n\n3. 类型。获取标号对应的类型：TYPE\n\n   有两种类型，一种是跳转目的地和跳转语句在同一个代码段，则为段内NEAR近程型，值为-1；一种是跳转目的地和跳转语句不在同一个代码段，则是段间FAR远程型，值为-2。\n\n##### 变量及变量定义伪指令\n\n| 变量定义伪指令 | 用途                 |\n| -------------- | -------------------- |\n| DB             | 定义字节型变量，8位  |\n| DW             | 定义字型变量，16位   |\n| DD             | 定义双字型变量，32位 |\n\n变量一旦定义了，就具有5个属性。\n\n1. 16位段地址。获取属性操作符：SEG\n\n2. 16位段内偏移地址。获取属性操作符：**OFFSET（常用）**\n\n3. 类型。获取标号对应的类型：TYPE\n\n   | 变量定义伪 | 类型       | 类型值（字节数） |\n   | ---------- | ---------- | ---------------- |\n   | DB         | 字节型变量 | 1                |\n   | DW         | 字型变量   | 2                |\n   | DD         | 双字型变量 | 4                |\n\n   ```x86asm\n   MOV AL,TYPE DAT1\t;等效于MOV AL,1\n   ```\n\n4. 长度。获取属性操作符：LENGTH\n\n   变量的长度指在变量名定义语句中，所定义的**变量的个数**。比如在变量定义的语句中出现了DUP重复操作符，那么重复操作符前的数值便是定义的**变量的个数**；如果没有出现DUP重复操作符，则认为只定义了一个变量。\n\n5. 大小。获取属性操作符：SIZE\n\n   变量的长度指在变量名定义语句中，所定义的**所有变量占用的总的字节数**。那么，SIZE=TYPE\\*LENGTH\n\n##### 总结\n\nOFFSET获取的段内偏移地址属性最好赋给地址寄存器，BX/BP为基址寄存器，SI/DI为变址寄存器。如果赋给AX没有意义。\n\n##### 例\n\n在DS段有以下变量定义\n\n```x86asm\nDAT1 DB 12,12H,-12,'1'\n```\n\n![image-20210728155350067](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728155350067.png)\n\n在masm.exe编译过程中，有一个\"\\$\"符号——位置计数器，记录偏移地址。每定义一个变量，$则会指向下一个将要被使用的存储单元地址。是16位变量。本身的值也是一个常数，既然是常数，那么在程序中也可以引用。\n\n```x86asm\nDAT1 DB 12,12H,-12,'1'\n;DAT2 DB $\t;DB定义不对，因为$是16位数据。\nDAT2 DW $\t;当执行到这一句时，$已经指向了下一个将要被使用的存储单元地址，即$中的值是0004H，则这条语句的意思是将0004H存入0004H存储单元，其中，低地址存放低位数据04H，高地址存放高位数据00H。\n```\n\n![image-20210728160206056](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728160206056.png)\n\n```x86asm\n;假设DAT3的段地址是1500H，偏移地址是000AH；DAT6的偏移地址是0016H\nDAT6 DW DAT3\t;此语句的意思不是取DAT3的值给DAT6，而是把DAT3的偏移地址赋给DAT6。即把000AH赋给DAT6存储空间。\nDAT7 DD DAT3\t;此时DAT7对应的偏移地址是0018H，DD变量将占用4个字节存储单元，由于4个字节可以分为2个双字空间，则汇编时会将DAT3的偏移地址和段地址都存放到DAT7中。\n```\n\n![image-20210728161510404](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728161510404.png)\n\n###### 重复操作符(DUP)\n\n```x86asm\nDAT8 DB 4 DUP(?)\t;DUB为重复操作符，左边的4是指要重复的次数，括号内是要重复定义的值，这里的?代表随机值。\n```\n\n![image-20210728161729544](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728161729544.png)\n\n```x86asm\nDAT9 DW 3 DUP(?)\n```\n\n![image-20210728162021258](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210728162021258.png)\n\n##### 注意区分\n\n要区分变量定义和赋值时的区别。\n\n```x86asm\nMOV AL,DAT1+2\t;指的是把(DAT1+2)存储单元中的“内容”赋给AL寄存器。(DAT1+2)存储单元中的内容目前是“F4H”，则把“F4H”传给了AL。采用的寻址方式是直接寻址。\nDAT123 DW DAT1\t;指的是把DAT1的偏移地址存到DAT123的存储单元中去。 \n```\n\n##### 属性临时修改操作符(PTR)\n\n```x86asm\nMOV AX,DAT1\t;此句语法错误，因为AX是16位寄存器，而DAT1是DB类型的变量，占8位。类型不匹配，无法完成赋值。\n```\n\n类型不一致无法赋值时，可以使用PTR\n\n```x86asm\nMOV AX,WORD PTR DAT1\t;将DAT1在这条语句中临时转换为字型数据。脱离这条语句后仍然是字节型变量。\n```\n\n###### 应用\n\nBYTE PTR [BX]\n\n```x86asm\nMOV [BX],10H\t;语法错误，因为不知道[BX]找到的地址的那个存储单元是什么类型的，就不知道那个存储单元占几字节，那么就不知道10H该如何处理（是处理为10H还是0010H）。\nMOV BYTE PTR [BX],10H\t;运用PTR操作符正确处理\n```\n\n# 数据与转移地址的寻址方式\n\n寻址方式就是求操作数的**所在地**或者**所在存储器单元地址**的方式。求得的操作数一是可以用来作为数据用，二是可以用来作为转移地址用。那么寻址方式就分为了两大类，第一大类是取数据的寻址方式，第二大类是关于转移到目的地地址的操作数在哪放着的寻址方式。如果是段内转移，则要求得16位偏移地址给IP，如果是段间转移，还要求得16位段地址给CS。\n![image-20210728172308349](../../images/微机原理/image-20210728172308349.png)\n## 关于寻找数据的寻址方式（8种）\n\n### 立即数寻址\n\n立即数只能做源操作数，不能做目的操作数。\n\nMOV AX,1234H\n\n#### 注意\n\n立即数只能传送给通用寄存器和存储器单元。\n\n当段寄存器DS/ES/SS作为DST操作数时，SRC操作数不能是立即数寻址。\n\n### 寄存器寻址\n\n要寻找的操作数在寄存器当中。则是寄存器寻址。\n\n```x86asm\nMOV AX,BX\n```\n\n#### 注意\n\n##### MOV两个操作数时类型要一致\n\n```X86ASM\nMOV AX,CL\t;ERROR\n```\n\n##### 类型要明确\n\n```x86asm\nMOV [0200H],56H\t\t\t\t;ERROR\nMOV WORD PTR [0200H],56H\t;指明了该单元是一个字单元\n```\n\n##### 当段寄存器DS/ES/SS作为DST操作数时，SRC操作数不能是立即数寻址。\n\n但可以采用寄存器寻址作为中介。\n\n```x86asm\nMOV DS,1500H\t;ERROR\nMOV AX,1500H\nMOV DS,AX\n```\n\n##### CS/IP只能作源操作数\n\nCS代码段寄存器，IP指令指针寄存器，都不可作DST操作数。往往只读不写。用户无权主观更改CS/IP的值，CS/IP的值一是在初始值是程序中的内存启动时由操作系统赋予的。二是执行期间由转移指令CPU执行后改变而赋予的。\n\n### 存储器寻址（5种）\n\n要寻找的OPR（操作数）在存储器某单元中，存储操作数单元的EA（段内偏移地址）可以由以下5种寻址方式求得。\n\n#### 直接寻址\n\n操作数所在单元的EA指令中直接给出。\n\n```x86asm\nMOV AL,[2000H]\t;实际编程中，2000H将会符号化为变量\n;在ds段：\n\t\tdat1 DB 12H\n\t\tdat2 DB 34H\n\t\t...\n;在CS段：\n\t\t...\n\t\tMOV AL,dat1\t\t;AL是寄存器寻址，dat1是直接寻址。语句执行完成后，AL中的内容则为(AL)=12H\n```\n\n##### 注意\n\n两个存储器单元之间不能直接传送数据\n\n```x86asm\nMOV DAT2,DAT1\t;错误，两存储器单元之间不能直接进行一切的操作\nMOV AL,DAT1\nMOV DAT2,AL\n```\n\n#### 寄存器间接寻址\n\n[BX/SI/DI]\n\n三个寄存器都是默认存放的DS中的地址。\n\n![image-20210729135603135](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729135603135.png)\n\n```x86asm\nMOV BX,OFFSET DAT1\t;将dat1的16位偏移地址给了BX\nMOV AL,[BX]\t\t\t;(DS:(BX))-->AL\t;AL默认是字节型数据，则把12H给AL\n```\n\n```x86asm\nMOV [BX],56H\t;ERROR,因为源操作数是立即数寻址而[BX]没有说明类型。\n```\n\n```x86asm\nMOV BX,OFFSET DAT1\nMOV SI,OFFSET DAT2\nMOV [BX],[SI]\t;ERROR,两存储器单元之间不能直接传送数据。\nMOV AL,[SI]\nMOV [BX],AL\n```\n\n\n\n#### 寄存器相对寻址\n\nEA=[BX/BP/SI/DI] + 8/16位disp(相对位移量)\n\n例：MOV **[BX]+3**,AL\t;也可等效为**[BX+3]或3+[BX]**,**如果相对位移量写在左边，则+号可以缺省。**\n\n如果相对位移量为常数：如果寄存器是BX,SI,DI则段地址默认在DS段；如果寄存器是BP则段地址在SS段。\n\n```x86asm\nMOV BX,OFFSET DAT1\nMOV [BX]+3,AL\t;也可等效为[BX+3]或3+[BX],如果相对位移量写在左边，则+号可以缺省。\n```\n\n![image-20210729142813193](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729142813193.png)\n\n**如果相对位移量是变量：段地址由变量的段地址决定。**\n\n```x86asm\nMOV BX,0\nMOV AL,0\nMOV DAT1[BX],AL\t;完成的功能是：先计算16位偏移地址，即OFFSET DAT1+(BX)作为偏移地址，段地址由DAT1决定，再把AL的内容赋给SEG DAT1:BX+OFFSET DAT1这个存储单元中。\n```\n\n\n\n##### 通过一个例子体现为何要设计一个默认在SS段的BP\n\n![image-20210729143703028](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729143703028.png)\n\n```x86asm\nMOV BP,SP\nMOV DX,[BP]+4\n```\n\n![image-20210729144042088](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729144042088.png)\n\n该例说明了，如果不想破坏SP栈顶指针，则可以方便的用BP来替代其指向栈顶，而且默认的段地址在堆栈段，所以操作栈比较方便。\n\n#### 基址、变址寻址\n\n基址：[BX/BP]，变址：[SI/DI]。EA=[BX/BP]+[SI/DI]\n\n段地址的确认以基址寄存器来决定。BX默认为DS，BP默认为SS。\n\n```x86asm\n\tDAT1 DB 12H\n\tDAT2 DB 34H\n\t...\n\tMOV CX,10\n\tMOV BX,OFFSET DAT1\n\tMOV SI,0\n\tMOV AL,0\nNEXT: MOV [BX][SI],AL\n\tINC SI\t\t\t;SI的值增1\n\tLOOP NEXT\t\t;CX的值循环减1，若不为0则跳转到NEXT\n```\n\n![image-20210729145047000](../../images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20210729145047000.png)\n\n#### 基址、变址且相对寻址\n\n基址：[BX/BP]，变址：[SI/DI]。EA=[BX/BP]+[SI/DI]+8/16disp\n\n如果相对位移量是变量，则段地址以变量的段地址为准。\n\n### 隐含寻址\n\n指令中并未写出操作数，但CPU执行指令时知道操作数在哪里。\n\n```x86asm\n...\nPUSH AX\n...\n;1.        SP <-- (SP)-2\n;2. (SS:(SP)) <-- (AX)\n```\n\n## 关于转移地址的寻址方式\n\n","categories":["微机原理"]},{"title":"关于x86和x64","url":"/微机原理/微信原理_关于x86和x64/","content":"\nhttps://www.cnblogs.com/netserver/p/11106130.html\n\nhttps://www.zhihu.com/question/47389187/answer/106229744\n\n![image-20210724144729788](../../images/%E5%85%B3%E4%BA%8Ex86%E5%92%8Cx64/image-20210724144729788.png)\n\nhttps://www.zhihu.com/question/47389187/answer/656682145\n\n![image-20210724144752256](../../images/%E5%85%B3%E4%BA%8Ex86%E5%92%8Cx64/image-20210724144752256.png)\n\n","categories":["操作系统","微机原理"]},{"title":"C语言_关于指针的解引用与++","url":"/C/C语言_关于指针的解引用与++/","content":"# 运算符及其优先级\n\n![image-20210723180215871](../../images/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8E++/image-20210723180215871.png)\n\n# int x=++*p++;\n\n![image-20210723175726868](../../images/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8E++/image-20210723175726868.png)\n\n++与\\*的运算优先级是平级关系，都是单目运算符，运算顺序是从右向左进行，什么是运算顺序呢？就比如加减法两个运算符是平级关系，但运算顺序是左到右进行，就比如1+2-3是先计算左边的'+'再计算右边的'-'。那么根据优先级表，++与\\*是从右向左顺序进行的，则此处的++\\*p++，先计算第二个++，再计算\\*，再计算第一个++。\n\n可以如此理解：后置++的特点是：将要运算时，待前面全部的表达式运算完毕后才会进行，我们可以把++\\*p++看作是：(++\\*)p++，待++\\*p全部计算完成后，再单独给p++。那么：下一步就变成了计算++\\*p，此处*在++运算符的右边，则先\\*p取值，再说++。前置++的特点是先+1并回写，此处操作的对象是\\*p。整个前置++\\*p操作完后，(++\\*)p++的前半部分就结束了。这时我们再单独给p进行后置++，操作的对象是指针p而不是\\*p，因为\\*已经做过了运算。\n\n最后结果：x=1, a=1.","categories":["C"]},{"title":"Redis_链表","url":"/Redis/Redis_链表/","content":"# 链表\n\n```c\nlist list={&node1,&node2,}\n```\n\n","categories":["高级数据结构","Redis"]},{"title":"C语言_指针_入门","url":"/C/C语言_指针_入门/","content":"本章内容：\n1. 什么是指针\n2. 指针的定义\n3. 指针的应用\n4. 指针的运算\n5. 指针与数组的关系\n6. 指针和数组，函数示例\n7. 二级指针\n# 什么是指针\n\n计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如`int`占用 4 个字节，char 占用 1 个字节。为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。 我们将内存中字节的编号称为地址（Address）或指针（Pointer）。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB。\n最小的地址为`0x0000 0000`，最大的地址为`0XFFFF FFFF`。\n![image-20210720094948057](../../images/C语言_指针/image-20210720094948057.png)\n## 对星号`*`的总结\n1. 表示乘法。\n2. 表示定义一个指针变量，以和普通变量区分开\n3. 表示解引用。获取指针指向的数据，是一种间接操作。\n\n`*`号运算符所在的环境不一样，`*`号的含意也不一样。\n```c\nint main()\n{\n\tint a = 10, b = 20;\n\tint c = a * b;//表示乘号\n    \n    int * p;//声明指针\n    p = &a;\n    * p = 100;//解引用\n    \n    return 0;\n}\n```\n# 定义指针变量\n## 一定要在定义时初始化\n要么初始化为空，要么指向已有变量的地址。否则指针指向的位置不可控，可能在操作指针时会改变其他正在运转的值。\n```c\nint main()\n{\n    int *p , s; // p 是整型指针变量，s 是整型变量。\n    char *cpa , *cpb; // cpa 和 cpb 都是char 类型指针变量。\n    int a = 10;\n    // 以下两句与 int *p = &a; 等价\n    int * ip; // 未初始化的指针，不良的定义习惯\n    ip = &a; \n    return 0;\n}\n```\n## 图解\n![image-20210720101404483](../../images/C语言_指针/image-20210720101404483.png)\n定义指针变量时，类型对指针变量起到2个作用：\n1. 解析存储单元的大小;\n2. 指针变量加1的能力。\n\n如：\n1. `double da = *dp;`\n2. `int ib = *ip;`\n3. `char cc = *cp;`\n## 综合实例\n```c\nvoid fun(int *p)\n{\n    int a = 200;\n    *p = 100;\n    p = &a;\n}\nint main()\n{\n    int x = 0;\n    int *s = &x;\n    fun(s);\n    printf(\"%d %d\\n\",x,*s);//x=100, *s=200或失效，因为int a在fun函数调用后释放了。错！*s是100。\n    return 0;\n}\n```\n![image-20210720105039607](../../images/C语言_指针/image-20210720105039607.png)\n# 指针的运算\n## 指针+1\n`typename * p;`\n`p = p + 1;`被编译器解释成：`p = p + sizeof(typename) * 1;`\n### 示例1：int指针变量加1\n```c\n#include<stdio.h>\nint main()\n{\n    const int n = 5;\n    int ar[n]={12,23,34,45,56};\n    int *ip = &ar[0]; // int *ip = ar;\n    for(int i = 0;i<n;++i)\n    {\n        printf(\"0x%08X => %d \\n\",ip,*ip);\n        ip = ip + 1;\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n![image-20210720110054100](../../images/C语言_指针/image-20210720110054100.png)\n### 示例2：char类型指针变量+1\n```c\n#include<stdio.h>\nint main()\n{\n    const int n = 5;\n    char ar[n]={'t','u','l','u','n'};\n    char *cp = &ar[0]; // char *cp = ar;\n    for(int i = 0;i<n;++i)\n    {\n        printf(\"0x%08X => %c \\n\",cp,*cp);\n        // printf(\"%#p => %c \\n\",cp,*cp);\n        cp = cp + 1;\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n![image-20210720110059739](../../images/C语言_指针/image-20210720110059739.png)\n### 示例3：double类型指针变量+1\n```c\n#include<stdio.h>\nint main()\n{\n    const int n = 5;\n    double ar[n]={1.2, 2.3, 3.4, 4.5, 5.6};\n    double *dp = &ar[0]; // char *cp = ar;\n    for(int i = 0;i<n;++i)\n    {\n        printf(\"0x%08X => %f \\n\",dp,*dp);\n        // printf(\"%#p => %f \\n\",dp,*dp);\n        dp = dp + 1;\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n### 指针+1详解\n\n![image-20210720110426346](../../images/C语言_指针/image-20210720110426346.png)\n## 思考下面代码运行结果\n```c\nint main()\n{\n    int ar[5]={12, 23, 34, 45, 56 };\n    int *p = ar; // int *p = &ar[0];\n    int x = 0;\n    int y = 0;\n    x = *p++; //int x = *p; p++;\n    y = *p;\n    printf(\"%d %d \\n\",x,y);\n    x = ++*p;\n    y = *p;\n    printf(\"%d %d \\n\",x,y);\n    x = *++p;\n    y = *p;\n    printf(\"%d %d \\n\",x,y);\n    return 0;\n}\n```\n\n![image-20210722152558428](../../images/C%E8%AF%AD%E8%A8%80_%E6%8C%87%E9%92%88/image-20210722152558428.png)\n\n![image-20210722152657523](../../images/C%E8%AF%AD%E8%A8%80_%E6%8C%87%E9%92%88/image-20210722152657523.png)\n## 总结\n### 指针的类型决定了两个能力\n1. +1的能力，偏移量。\n2. 对内存的解析能力。\n\n![image-20210722154957018](../../images/C%E8%AF%AD%E8%A8%80_%E6%8C%87%E9%92%88/image-20210722154957018.png)\n\n```c\nix=0x12345678  sx=0x5678 cx=0x78\n```\n### 指针有两个要素\n1. 地址值\n2. 指针指向的数据类型\n# 指针与数组的关系\n1. 数组名被看作该数组的第一个元素在内存中的首地址（仅在`sizeof`操作中例外，该操作给出数组所占内存大小）。\n2. 数组名在表达式中被自动转换为一个指向数组第一个元素的指针常量。\n3. 数组名是指针，非常方便，但是却丢失了数组另一个要素：数组的大小，即数组元素的数量。编译器按数组定义时的大小分配内存，但运行时（run time）对数组的边界不加检测。这会带来无法预知的严重错误。\n\n![image-20210720111145131](../../images/C语言_指针/image-20210720111145131.png)\n\nC提供根据数组的存储地址访问数组元素的方法。上图中`ar`是数组第一个元素的地址，所以`*ar`是数组的第一个元素`ar[0]`，而`ar+1`是数组第二个元素的地址，`*(ar+1)`是第二个元素`ar[1]`本身。指针加1，则地址移动一个数组元素所占字节数。\n\nC语言的下标运算符`[]`是以指针作为操作数的，`ar[i]`被编译系统解释为`*(ar+i)`，即表示为`ar`所指（固定不可变）元素向后第`i`个元素。无论以下标方式或指针方式存取数组元素时，系统都是转换为指针方法实现。逻辑上有两种方式，物理上只有一种方式。\n## 数组名访问\n```c\nint main()\n{\n    const int n = 5;\n    int ar[n] = {1, 2, 3, 4, 5};\n    for(int i = 0;i < n;++i)\n    {\n        printf(\"0x%08x %d %d \\n\",ar+i, ar[i], *(ar+i));\n    }\n    return 0;\n}\n```\n![image-20210720111509965](../../images/C语言_指针/image-20210720111509965.png)\n## 指针访问\n\n```c\nint main()\n{\n    const int n = 5;\n    int ar[n] = {1,2,3,4,5};\n    int *p = ar;\n    for(int i = 0;i<n;++i)\n    {\n        printf(\"0x%08x %d %d\\n\",p+i,p[i],*(p+i));\n    }\n    return 0;\n}\n```\n![image-20210720111538163](../../images/C语言_指针/image-20210720111538163.png)\n## 数组的退化\n\n用数组作为函数的形参，数组将退化为指针类型。\n\n如果想要在函数中传递一个一维数组作为参数，必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会转成指针。\n\n```c\nvoid Print_Array(int br[],int n); //形式参数是一个未定义大小的数组：\nvoid Print_Array(int br[5],int n); //形式参数是一个已定义大小的数组\nvoid Print_Array(int *br,int n)； //形式参数是一个指针\n```\n\n要点：为什么数组作为函数的形参会退化为指针呢？我们将从时间效率和空间效率上分析。\n\n我们先假设数组作为函数的形参，我们分析一下调用过程；\n\n```c\nvoid Print_Array(int br[5],int n)\n{\n\tint ar_len = sizeof(br);\n\tprintf(\"ar_len : %d \\n\",ar_len);\n}\nint main()\n{\n\tconst int n = 5;\n\tint ar[n] = {1,2,3,4,5};\n\tPrint_Array(ar,n);\n\treturn 0;\n}\n```\n\n```c\n#include<stdio.h>\nvoid Print_Ar(int br[10])//如果如此定义，传参数前，主函数开辟了数组空间，传参数时，栈区又会开辟10个空间！而且又要浪费时间把数组中的数据依次传入。既浪费空间又浪费空间。\n{\n    int size=sizeof(br);//只会是4，因为(int br[10]退化成了(int *br)\n    printf(\"size: %d \\n\",size);\n}\n```\n### 二维数组的退化\n```c\n//打印二维数组\nvoid Print_Ar(int(*br)[4],int row,int col)\n{\n    //int n = sizeof(**br);//虽然可以通过sizeof(**br);算出column即列数。但为了使程序更加方便化，定义形参col\n    printf(\"%d %d\\n\", row, n);\n    for (int i = 0;i < row;++i)\n    {\n        for (int j = 0;j < col;++j)\n        {\n            printf(\"%d \", br[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n```\n\n如果二维数组的形参定义为：`int [4][5]`，同一维数组的道理一样，将会退化为`int(*br)[4]`。\n## 数组名表示数组首元素的地址\n\n数组名表示数组首元素的地址，而不是数组的地址。\n## 数组的地址\n```c\nint main()\n{\n    const int n =5;\n    int ar[n] = {12,23,34,45,56};\n    \n    int* ip = ar;//&a[0]\n    int (*s)[5] = &ar;//\n    int* pa[5];\n    return 0;\n}\n```\n\n```c\nint main()\n{\n    int a = 10;\n    int* p = &a;\n    //p: int*, *p: int\n    int a[5];\n    int(*p)[5] = &a;\n    //p: int [5]*, *p: int [5]\n}\n```\n## 指针与字符串\n\n```c\nchar c = \"xcgong\"[2];//此句话编译后等效于：字符串数组的首元素地址即'y'的地址p，+2取值后*(p+2)赋值给c，即'g'。\n```\n## 总结\n访问数组时，编译器会把`x[y]`转换为：`*(x+y)`，对应机器码的基变址寻址。`x`是基地址。\n# const\n不带const修饰的指针是自由的，一是自身的值可以改变，二是指向的值可以改变。\n```c\nint a = 10, b = 20;\nint *p = &a;\n*p = 100;\np = &b;\n```\n## 带const\n```c\nint a=10,b=20;\n//以下的const在*的左边，修饰的是指向能力（修饰“修改指向的值”的能力），两句话等价\nconst int *p = &a;\nint const *p = &a;\n*p = 100;//error\np = &b;  //OK\n//以下的const在*的右边，修饰指针自身，可读不可改变自身的值\nint * const p = &a;\nint x = *p;\n*p = 100;//OK\np = &b;  //error\n//有两个const，第一个修饰的是指向能力（修饰“修改指向的值”的能力），第二个修饰的是指针自身\nconst int * const p = &a;\nint const * const p = &a;\n*p = 100;//error\np = &b;  //error\n```\n\n```c\nint a=10;\nconst int b=20;\nint *pa=&a;//*pa=100;//ok\nconst int* pa1=&a;//*pa1=100;//error\n\nint* pb=&b;//error\nconst int* pb=&b; //ok\n```\n\n```c\n//.cpp下编译\nint main()\n{\n    const int a=10;\n    int b=0;\n    int* p=(int*)&a;\n    *p=100;\n    b=a;//编译时自动把a替换成了10\n    printf(\"a=%d\\n\",a);//打印10\n    printf(\"b=%d\\n\",b);//打印10\n    printf(\"*p=%d\\n\",*p);//打印100\n}\n```\n# str相关函数\n## strlen\n### 第一次编的\n```c\n#include<stdio.h>\nint my_strlen(char* string)\n{\n    int count = 0;\n    while (*string++ != '\\0')\n    {\n        ++count;\n    }\n    return count;\n}\n```\n### 老师的改进\n```c\n#include<stdio.h>\n#include<assert.h>\nint my_strlen(const int* string)\n{\n    assert(string != NULL);\n    int i=0;\n    while(string[i]!='\\0')\n    {\n        ++i;\n    }\n    return i;\n}\n```\n### 另有方法：利用指针地址计算\n指针地址的计算——算头不算尾\n```c\n#include<stdio.h>\n#include<assert.h>\nint my_strlen(const int* str)\n{\n    assert(str!=nullptr);\n    const char* cp = str;\n    while(*cp!='\\0')\n    {\n        cp++;\n    }\n    return (cp-str);\n}\n```\n#### 变种问题\n不让用计数变量计算字符串长度--指针地址计算\n\n不让用任何变量计算字符串长度--递归函数\n```c\nint my_strlen2(const char* string)\n{\n    assert(string != nullptr);\n    if (*string++)\n    {\n        return my_strlen2(string)+1;\n    }\n    else return 0;\n}\n```\n## cpy\n```c\nchar* my_strcpy(char* dest,const char* src)\n{\n    assert(dest != NULL && src != NULL);\n    char* cp = dest;\n    while (*src != '\\0')\n    {\n        *dest = *src;\n        dest++;\n        src++;\n        //也可以一句话解决，while(*dest++ = *src++);//因为赋值语句有返回值是赋值的值，但可读性不好\n    }\n    *dest = '\\0';\n    return dest;//返回dest即目的拷贝字符串，便于函数嵌套达到可以实现连续拷贝\n}\n```\n对于`*dest++ = *src++`可以看一下汇编代码，就清楚了\n![image-20210723160515838](../../images/C%E8%AF%AD%E8%A8%80_%E6%8C%87%E9%92%88/image-20210723160515838.png)\n\n![image-20210723160525560](../../images/C%E8%AF%AD%E8%A8%80_%E6%8C%87%E9%92%88/image-20210723160525560.png)\n## strcat\n### 定义一个指针变量\n```c\n#include<stdio.h>\n#include<assert.h>\nchar* my_strcat(char* dest, const char* src)\n{\n    assert(dest != nullptr && src != nullptr);\n    char* cp = dest;\n    while (*cp != '\\0') ++cp;\n    while (*cp++ = *src++);\n    return dest;\n}\n```\n### 不用定义指针变量，利用len获取下标\n```c\n#include<stdio.h>\n#include<assert.h>\nchar* my_strcat(char* dest, const char* src)\n{\n    assert(dest != nullptr && src != nullptr);\n    int index = my_strlen(dest);\n    my_strcpy(dest+len, src);\n    return dest;\n}\n```\n## strcmp\n```c\nint main()\n{\n    char* stra = \"yhp\";\n    char* strb = \"yhp\";\n    \n    char strc[]=\"yhp\";\n    char strd[]=\"yhp\";\n    \n    bool x = (stra==strb);//1\n    bool y = (strc==strd);//0\n    printf(\"x = %d y = %d\\n\",x,y);\n}\n```\n\n```c\n#include<stdio.h>\n#include<assert.h>\nint my_strcmp(const char* ap, const char* bp)\n{\n    //ap=\"yhping\" bp=\"yhping\" 0\n    //ap=\"yhxing\" bp=\"yhping\" >0\n    //ap=\"yhping\" bp=\"yhxing\" <0\n    assert(ap!=nullptr&&bp!=nullptr);\n    while((ap||bp)&&(*ap==*bp))\n    {\n        ap++;\n        bp++;\n        if(*ap=='\\0'||*bp=='\\0')break;\n    }\n    return *ap-*bp;\n}\nint main()\n{\n    char stra[10] = \"yhping\";\n    char strb[10] = \"yhxing\";\n    int ans = my_strcmp(stra,strb);\n    printf(\"%d\\n\", ans);\n}\n```\n# 练习\n## 判断当前系统是小端地址还是大端地址（可通过指针强转来探测）\n```c\nint main()\n{\n    short st = 0x0001;\n    char* cp = (char*)&st;\n    if(*cp==0x01)\n    {\n        printf(\"小端\\n\");\n    }\n    else\n    {\n        printf(\"大端\\n\");\n    }\n}\n```\n## 不让用任何变量计算字符串长度--递归函数\n```c\nint my_strlen2(const char* string)//不定义变量，递归求解\n{\n    assert(string != nullptr);\n    if (*string++)\n    {\n        return my_strlen2(string)+1;\n    }\n    else return 0;\n}\n```\n## 给出以下的代码输出结果\n```c\nint main()\n{\n    char* stra = \"yhp\";\n    char* strb = \"yhp\";\n    \n    char strc[]=\"yhp\";\n    char strd[]=\"yhp\";\n    \n    bool x = (stra==strb);//1\n    bool y = (strc==strd);//0\n    printf(\"x = %d y = %d\\n\",x,y);\n}\n```\n## strcmp函数\n```c\n//ap=\"yhping\" bp=\"yhping\" 0\n//ap=\"yhxing\" bp=\"yhping\" >0\n//ap=\"yhping\" bp=\"yhxing\" <0\nint my_strcmp(const char* ap, const char* bp)\n{\n    assert(ap != nullptr && bp != nullptr);\n    while (ap&&bp&&*ap == *bp)//有一个不为空且依次相等\n    {\n        ap++;\n        bp++;\n    }\n    return *ap - *bp;\n}\n```\n## 冒泡排序\n```c\n\n```\n## 二分查找\n```c\nint FindValue(int* ar,int n,int val)\n{\n    assert(ar != nullptr);\n    int pos = -1;\n    int left = 0, right = n - 1;\n    //为什么left还要等于right呢？left和right表示数据的规模，如果left=right说明还要再寻找一次。当right和right错位，说明没有数据了。\n    while (left<=right)\n    {\n        int mid = (left + right) >>2;\n        if (val < ar[mid])\n        {\n            right = mid-1;//val值在mid下标前，mid下标已经没必要比较，而且必须-1，因为如果这个值在数组中没有，而在mid下标值和mid-1下标值之间的话\n        }\n        else if (val > ar[mid])\n        {\n            left = mid+1;\n        }\n        else\n        {\t//如果有重复的值，则向前探测相同值。\n            //但也要注意越界问题。mid-1不要<0\n            while (mid > left && ar[mid - 1] == ar[mid])\n            {\n                --mid;\n            }\n            pos = mid;\n            break;\n        }\n    }\n    return pos;\n}\n```\n1. 如果数据量非常大，`left+right`可能会溢出，怎么解决——`left + (right - left) / 2`\n2. 线性探测如何优化，以加速探测速度。\n3. [二分查找及其变种](https://www.cnblogs.com/yumingxing/p/9583154.html)：斐波那契查找的时间复杂度还是$O(\\log_2 n)$，但是 与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间。\n## 循环移动数组\n示例：`int ar[10]={1, 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10};`\n右移一个数据元素：输出`{ 10,1,2,3,4,5,6,7,8,9};`\n右移`k`个数据元素：如`k = 3;`输出`{8，9，10，1，2，3，4，5，6，7}`\n\n实现函数：\n`Right_Move_Array; // 右移一个数据元素`\n`Right_Move_Array_K; // 右移k 个数据元素`\n`Left_Move_Array;`\n`Left_Move_Array_K;`\n\nhttps://blog.csdn.net/weixin_45007066/article/details/116057402\nhttps://blog.csdn.net/weixin_45332776/article/details/116333199\n## 改进冒泡排序\n```c\n\n```\n## `my_memset()`\n```c\nvoid my_memset(void* src, int val, int size)\n{\n    assert(src != nullptr);\n    char* cp = (char*)src;\n    for (int i = 0;i < size;++i,++cp)\n    {\n        *cp = 0;\n    }\n}\n```\n## `my_memmove()`\n```c\n\n```\n## `my_atoi()`\n字符串数字转换为整型数字\n1. `\"123\"=>123`\n2. `\"-123\"=>-123`\n3. `\"0123\"(8进制)=>`\n4. `\"0x123Df\"=>`\n5. `\"75894235702389573478903242334537\" =>`\n6. \"505\"错写为了\"5o5\"，要有纠错能力转为505\n\n```c\n\n```","tags":["tulun"],"categories":["C"]},{"title":"Redis_SDS","url":"/Redis/Redis_SDS/","content":"\nSDS指simple dynamic string，即简单动态字符串。\n\n# Memcached与Redis的区别和选择\n\nMemcached与Redis的区别和选择https://blog.csdn.net/qq_18671415/article/details/104540628\n\nhttps://zhuanlan.zhihu.com/p/183993817\n\nRedis 这几年的大热，现在已经替代 Memcached 成为缓存技术的首要中间件，作为大厂的带头兵，在 BAT 里面，Redis 也已经逐渐取代了 Memcached，广泛使用 Redis 作为缓存应用方案。\n\n**1）速度更快**\n\nMemcached 使用的是多线程模型，既然是多线程，就会因为全局加锁而带来性能损耗。而 Redis 使用的是单线程模型，没有锁竞争，速度非常快。\n\n**2）数据类型更丰富**\n\nMemcached 数据类型非常单一，只支持 String 数据类型，在业务实现上就非常有瓶颈。\n\n而 Redis 支持 string(字符串)、hash(哈希)、list(列表)、set(集合)、zset(sorted set:有序集合) 等……丰富的数据类型可以让 Redis 在业务上大展拳脚。\n\n这也是 Redis 能代替 Memcached 最重要的原因之一。\n\n并且，Memcached 值最大上限为：1M，而 Redis 最大可以到：1GB。\n\n**3）数据持久化**\n\nMemcached 不支持持久化，Redis 支持。\n\n缓存服务器断电后，Memcached 的数据是不能恢复的，而 Redis 可以将数据保久化在磁盘中，服务器重启的后可以加载再次使用，不会造成数据断电丢失。\n\n比如，有些数据是直接放在缓存数据库中的，其他地方可能没有备份，如果丢失了，那可能会造成业务影响，这也是 Redis 非常有用的一个保障特性。\n\n# 柔性数组\n\n先看一个结构体的设计\n\n```c\n#define MAXLEN 1024 //1K  //对于操作系统层面来讲，分配、管理内存是以一页为单位的，占4K即1024*4=4096字节\ntypedef struct kd_node\n{\n    struct kd_node* left;\n    struct kd_node* right;\n    int dim;\n    unsigned long long data[MAXLEN];//数据  //占用了1024*sizeof(unsigned long long)=8k字节\n}kd_node;\n```\n\n在上面这段代码中，为了存储数据，申请了长度为1024的unsigned long long型数组。若是数据的长度远远小于MAXLEN，这样的设计是很浪费空间的。\n\n对于数组，我们的原则是大开小用（尽可能开辟足够的空间，但使用时不能全都用上）。而对于动态内存分配，我们就可以更加的灵活运用，但代价是使用完后要释放掉。\n\nC99标准中给出了新的设计方法，通过柔性数组可以解决这个问题。\n\n```c\nstruct sd_node\n{\n    int num;//数据的长度，即已填入的数据占用的长度\n    int size;//总长度\n    char data[];//或char data[0];\n    //数组的大小声明为0或不给出大小，称之为柔性数组。必须在最后位置声明，且一旦声明后面不能再声明其他结构。全局数组和局部数组不可如此定义。\n};\nint main()\n{\n    sizeof(struct sd_node);//8\n}\n```\n\n在struct sd_node结构体中data仅仅是一个待使用的标识符，不占用存储空间。\n\n用途：柔性数组的主要用途是为了满足长度可变的结构体。\n\n用法：在一个结构体的最后，声明一个长度为0的数组，就可以使得这个结构体是可变长的。**对于编译器来说**，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量。数组名这个符号本身代表了一个**不可修改的地址常量**。但对于这个数组的大小，我们可以进行动态分配。\n\n注意：如果结构体是通过calloc/malloc/realloc等动态分配方式生成的，在不使用时需要释放相应的空间。\n\n优点：比起在结构体中声明一个指针变量再进行动态分配的做法，柔性数组方法效率要高，因为简单。\n\n缺点：在结构体中，数组为0的数组必须在最后声明，在设计结构体类型时有一定限制。\n\n![image-20210810021047383](../../images/Redis_SDS/image-20210810021047383.png)\n\n```c\nint main()\n{\n    struct kd_node* sp1 = (struct kd_node*)malloc(sizeof(struct kd_node)+20);\n    if(sp1==nullptr)\n    {\n        exit(EXIT_FAILURE);\n    }\n    strcpy_s(sp1->data,20,\"yhping\");//20指sp1->data的最大空间，使其安全拷贝\n    sp1->num = strlen(\"yhping\");\n    sp1->size = 20;\n    \n    printf(\"size: %d \\n\",sp1->size);\n    printf(\"num: %d \\n\",sp1->num);\n    printf(\"data: %s \\n\",sp1->data);\n    \n    free(sp1);\n    sp1 = nullptr;\n    return 0;\n}\n```\n\n![image-20210810022209189](../../images/Redis_SDS/image-20210810022209189.png)\n\n![image-20210810022351037](../../images/Redis_SDS/image-20210810022351037.png)\n\n## 易错\n\n![image-20210810023944795](../../images/Redis_SDS/image-20210810023944795.png)\n\n![image-20210810024031901](../../images/Redis_SDS/image-20210810024031901.png)\n\n运行结果\n\n![image-20210810024054322](../../images/Redis_SDS/image-20210810024054322.png)\n\nsizeof的运算只发生在编译时期，因此只计算变量的类型的大小，经典的例子就是sizeof(++a)，再次输出a时发现没有+1，是因为sizeof(++a)根本没有执行。\n\n## 与另一种实现方法的对比\n\n```c\nstruct kd_buff\n{\n    int num;\n    int size;\n    char* buff;\n};\nint main()\n{\n    kd_buff* p = (kd_buff*)malloc(sizeof(kd_buff));\n    \n    p->buff = (char*)malloc(sizeof(char)*strlen(\"yhping\"));\n    strcpy(p->buff,strlen(\"yhping\"),\"yhping\");\n    \n    p->num = strlen(\"yhping\")-1;\n    p->size = strlen(\"yhping\");\n}\n```\n\n显然，指向字符串指针的方法的操作起来比柔性数组操作起来要繁杂一些。\n![image-20210810025606081](../../images/Redis_SDS/image-20210810025606081.png)\n\n而且，这种结构需要分两次申请空间，导致到最后必须释放两次。而柔性数组只申请一次空间，最后释放时直接释放一次即可。因此，综合考虑，柔性数组明显是优于上述结构的。\n\n# 退出方案\n\n`exit()`, `_exit()`, `return`, `abort()`函数的区别\nhttps://blog.csdn.net/lyf47/article/details/44203499\n\n在Redis中我们采用的是`abort();`\n\n```c\nstatic void adsOomAbort()\n{\n    fprintf(stderr,\"SDS: out of memory \\n\");\n    abort();\n}\n```\n\n## `abort()`\n\n## `exit(EXIT_FAILURE)`\n\n## `_exit()`\n\n# 代码\n\n```c\ntypedef sds char*;\nvoid sdsclear(sds s)\n{\n    struct sdshdr* sh=(struct sdshdr*)s-sizeof(struct*(sdshdr));\n    sh->free+=sh->len;\n    sh->len=0;\n    sh->buf[0]='\\0';\n}\nsds sdscat(sds stra,sds strb)\n{\n    struct sdshar* sh_a=(struct sdshdr*)stra-sizeof(struct*(sdshdr));\n    struct sdshar* sh_b=(struct sdshdr*)strb-sizeof(struct*(sdshdr));\n    if(sh_a->free>=str->free)\n    {\n        memcpy_s(\"\")\n    }\n    stra[6]\n}\n```\n# string.h\n\n## memcpy\n\n函数原型为`void *memcpy(void *destin, void *source, unsigned n)`。函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中，即从源source中拷贝n个字节到目标destin中。\n\n# C语言传统的字符串\n\n即以空字符结尾的字符数组。\n\n1. 在.rdata数据区里\n\n```c\nchar* sp = \"yhping\";\n```\n\n2. 数组存放\n\n```c\nchar stra[] = \"yhping\";\n```\n\n3. 堆区开辟，并用strcpy_s(cp,10,\"yhping\");复制\n\n```c\nint main()\n{\n    char* cp = (char*)malloc(sizeof(char)*10);\n    strcpy_s(cp,10,\"yhping\");\n}\n```\n# redis的字符串\n\n```c\ntypedef char* sds;\nstruct sdshdr\n{\n    int len; //已输入的字符串不包括\\0的长度\n    int free;//还未使用的字节数，同样不包括\\0\n    char buf[];\n}\n//传入一个init指针（多为字符串）和其长度，长度不计算\\0，memcpy写入内存时不包括\\0的写入，\\0是单独用memset处理的\nsds sdsnewlen(const void *init, size_t initlen) {\n    struct sdshdr *sh;//声明定义一个sdshdr结构体指针 \n\n    sh = zmalloc(sizeof(struct sdshdr)+initlen+1);//开辟sdshdr结构体类型大小（8字节）+initlen+1（存放\\0）字节。 头部赋给指针sh \n#ifdef SDS_ABORT_ON_OOM\n    if (sh == NULL) sdsOomAbort();\n#else\n    if (sh == NULL) return NULL;\n#endif\n    sh->len = initlen;//把initlen数值赋给sh->len \n    sh->free = 0;//sh->free暂时初始化为0 \n    if (initlen) {\n        if (init) memcpy(sh->buf, init, initlen);//如果init不为空 则 将init指针开始的initlen长度内存空间中的内容复制给sh->buf同样长度 \n        else memset(sh->buf,0,initlen);//如果init为空 则 将sh->开始的initlen长度的空间的内容赋为0 \n    }\n    sh->buf[initlen] = '\\0';  //无论如何，buf的initlen下标处（也就是不包含\\0的字符串的尾部的后一位）赋值为\\0 \n    return (char*)sh->buf;//返回一个指向buf的sds指针 \n}\n//将字符串传入，生成对应的sds，适用于直接传一个常规的字符串，只写一个参数即可 \nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init); //字符串为空则initlen=0，不为空则initlen等于不包含\\0的字符串长度 \n    return sdsnewlen(init, initlen);//调用sdsnewlen创建sds结构体 \n}\nint main()\n{\n\tsds sdsp = sdsnew(\"yhping\");\n}\n```\n\n# sds函数\n\n## 创建\n\n### `sdsnew`/`sdsnewlen`\n\n其中`sdsnew`调用了`sdsnewlen`\n### `sdsempty`\n\n创建柔性数组内只含有`'\\0'`的`sdshdr`\n### sdsdup\n\n创建sdshdr的副本\n## 属性\n\nsdslen返回已使用空间字节数即len；sdsavail返回未使用空间字节数即free。\n## 释放\n\n### sdsfree\n\n对应于创建sdshdr的sdsnew，即释放sdshdr\n### sdsclear\n\n惰性释放，只删除字符串内容，更新len属性和free属性，结构保留。\n\n```c\nvoid sdsclear(sds s)\n{\n    struct sdshdr* sh = (struct sdshdr*)(s-sizeof(struct sdshdr));\n    sh->free += sh->len;\n    sh->len=0;\n    sh->buf[0]='\\0';//不显式清零字符串内存空间内容，而是在逻辑上使字符串buf[0]=\\0标志，使之无法访问。\n}\n```\n\n## 扩展\n\n### sdsgrowzero\n\n将柔性数组长度扩展到指定长度，多余空间用'\\\\0'填充。\n### sdscatlen\n\n# 可变参数\n\n```c\nint a=10,b=20;\nchar buff[20];\n\nprintf(\"a=%d b=%d\\n\",a,b);//stdout a=10 b=20\nsprintf(buff,\"a=%d b=%d \\n\",a,b);\n//把数据放到了buff中\nsprintf_s(buff,20,\"a=%d b=%d \\n\",a,b);\n```\n\n```c\nint a = 10,b = 20;\nchar buff[20];\nint len = sprintf(buff,\"a = %d b = %d \\n\",a,b);//返回字符串的长度15，格式化转化后存放的是\"a = 10 b = 20 \\n\\0\"，但算长度时不包含\\0长度\nsprintf(buff,20,\"a = %d b = %d \\n\",a,b);//相比于不带_s的sprintf更安全，因为限制了长度\n```\n\n```c\nvoid funa(int a,char cx,int b,char cy)\n{\n    printf(\"%p => %d \\n\",&a,a);\n    printf(\"%p => %c \\n\",&cx,cx);\n    printf(\"%p => %d \\n\",&b,b);\n    printf(\"%p => %d \\n\",&cy,cy);\n}\nvoid funb(int a,float ft,double dx,char c)\n{\n    printf(\"%p => %d \\n\",&a,a);\n    printf(\"%p => %f \\n\",&ft,ft);\n    printf(\"%p => %f \\n\",&dx,dx);\n    printf(\"%p => %c \\n\",&c,c);\n}\nvoid fun(int num, ...)//fun(3,'a',12,'b');\n{\n    int* p = &num;\n    int* p1 = p+1;\n    printf(\"%d\\n\",*p1);\n    int* p2 = p1+1;\n    printf(\"%c\\n\",*p2);\n    int* p3 = p2+1;\n    printf(\"%d\\n\",*p3);\n    int* p4 = p3+1;\n    printf(\"%c\\n\",*p4);\n}\nint main()\n{\n    funa(12,'a',23,'b');\n    funb(12,12.25,25.50,'b');//80-84-88-差了8个字节-90\n    //fun(0);\n    //fun(1,23);\n    //fun(2,23,34);\n    fun(3,'a',12,'b');\n    return 0;\n}\n```\n\n\n\n```c\nvoid fun(const char* fmt, ...)\n{\n    \n}\nint main()\n{\n    fun(\"%c %d %c \\n\",'a',12,'b');\n}\n```\n\n![image-20210721204739876](../../images/Redis_SDS/image-20210721204739876.png)\n\n```c\n#include<stdarg.h>\nvoid fun(const char* fmt, ...)\n{\n    va_list ap = nullptr;\n    va_start(ap,fmt);\n    va_start(ap,char);\n    va_start(ap,int);\n    va_start(ap,char);\n    \n    va_end(ap);\n}\n```\n\n\n\n```c\n#include<stdarg.h>\nvoid fun(const char* fmt, ...)\n{\n    va_list ap = nullptr;//typedef char* va_list\n    char* p = nullptr, * sval = nullptr;\n    int ival = 0;\n    double dval = 0;\n    va_start(ap,fmt);\n    for(p=fmt;*p!='\\0';++p)\n    {\n        if(*p!='%')\n        {\n            switch(*++p)\n            {\n                case 'd':\n                    ival = va_arg(ap,int);\n                    printf(\"%d\",ival);\n                    break;\n                case 'f':\n                    fval = va_arg(ap,float);\n                    printf(\"%f\",dval);\n                    break;\n                case 's':\n                    sval = va_arg(ap,char*);\n                    printf(\"%s\",sval);\n                    break;\n                default:\n                    putchar(*p);\n                    break;\n            }\n        }\n    }\n    va_end(ap);\n}\nint main()\n{\n    fun(\"a = %d\\nft = %f\\nstr = %s\\n\",12,12.25f,\"hello tulun\");\n}\n//#define va_start __crt_va_start\n//#define va_arg   __crt_va_arg\n//#define va_end   __crt_va_end\n//#define va_copy(destination, source) ((destination) = (source))\n//#define __crt_va_start(ap, x) __crt_va_start_a(ap, x)\n//#define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))\n//#define __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))\n//#define __crt_va_end(ap)        ((void)(ap = (va_list)0))\n```\n\n","categories":["高级数据结构","Redis"]},{"title":"C语言_数组入门及练习","url":"/C/C语言_数组入门及练习/","content":"本章内容：\n1. 一维数组的定义和初始化\n2. 一维数组在内存中的存储\n3. 一维数组的使用\n4. 一维数组的应用实例\n5. 二维数组的定义和初始化\n6. 二维数组在内存中的存储\n7. 二维数组的使用\n8. 二维数组的应用实例\n# 数组的定义和初始化\n\n数组是包含给定类型的一组数据，并将这些数据依次存储在连续的内存空间中。每个独立的数据被称为数组的元素（element）。元素的类型可以是任意类型。 数组本身也是一个结构，其类型由它的元素类型延伸而来。更具体地说，数组的类型由**元素的类型和数量**所决定。如果一个数组的元素是 T 类型，那么该数组就称为“T 数组”。例如，如果元素类型为 int，那么该数组的类型就是“int 数组”。然而，int 数组类型是不完整的类型，除非指定了数组元素的数量。如果一个 int 数组有 16 个元素，那么它就是一个完整的对象类型，即“16 个 int 元素数组”。\n\n## 一维数组的定义和初始化\n\n数组的定义决定了数组名、元素类型以及元素个数。\n其语法如下：`<类型> 数组名 [ <元素数量> ];`\n元素数量在方括号`[ ]`之间，它必须是大于`0`的整型常量表达式。\n\n```c\n#include<stdio.h>\nint main()\n{\n    int ar[10]; //elem num;elem type;\n    int br[10] = {};//对数组的10个元素都初始化为0。\n    int cr[10] = { 12,23,34 };//后面的值为0\n    int a = 10;\n    sizeof(a);//4\n    sizeof(ar);//4*10=40\n    int dr[] = { 12,23,34,45,56,67,78 };//方括号内可以不写，但花括号中的数据必须得写。则元素数为sizeof(dr)/sezeof(dr[0])。sizeof是在编译时期计算的，则dr数组的大小是编译时期就确定了。\n}\n```\n\n### 总结\n\n数组的类型有数组元素的类型、数组元素的个数。数组的元素个数可以通过sizeof 计算得到。\n\n### 不同C标准\n\nC99可以拿将要用键盘输入的变量作为方括号内的常量，但VS这样的C11不可以。\n\n```c\nint n=0;\nscanf(\"%d\",&n);\nint ar[n];\nreturn 0;\n```\n\n# 数值在内存的表\n\n```c\nint main()\n{\n    int ar[10]={12,23,34,45,56,67,78,89,100};//0x0c~0x64\n}\n```\n\n![image-20210717150102235](../../images/C%E8%AF%AD%E8%A8%80_%E6%95%B0%E7%BB%84/image-20210717150102235.png)\n\n# 一维数组\n\n## 一维数组的使用\n\n数组在存储单元中是顺序连续存放的，任何一个元素都可以单独访问，其标识方法是用数组名和下标;\n`数组名[整型表达式];`\n\n整型表达式**可以是变量，也可是常量，但必须是整型类型**。\n\n数组的访问（读取，写入）与数组的定义不一样。\n\n```c\nint main()\n{\n    int ar[10];\n    for(int i=0;i<10;++i)\n    {\n        ar[i]=i+10;\n    }\n    for(int i=0;i<10;++i)\n    {\n        printf(\"%d \",ar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n```c\n//为了便于代码的维护\nint main()\n{\n    const int n=5;\n    int ar[n];\n    for(int i=0;i<n;++i)\n    {\n        ar[i]=i+10;\n    }\n    for(int i=0;i<n;++i)\n    {\n        printf(\"%d \",ar[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\nconst关键字在编译时期的替换是对于cpp文件而言的。对于`.c`文件，const就不适用了！\n```c\nconst int m;//无意义\nconst int br[10];//也不可以。但是const int br[10]={};可以\n//说明const修饰的变量必须要在定义时初始化值。\n```\n### 其他类型的数组\n\n#### 常性数组\n```c\nconst int ar[5]={1,2,3,4,5};//常性数组，数组元素的值只可读，不可写。\n```\n#### 存放字符（串）的数组\n```c\n#include<stdio.h>\nint main()\n{\n    //以下两个数组效果一样，未存放的位置都是'\\0'\n    char str1[10]={\"tulun\"};\n    char str2[10]={'t','u','l','u','n'};\n    //而以下两个数组就不一样了，尤其是在被表示为字符串格式化输出时：\n    char stra[]={\"tulun\"};//定界符\"\"表示存入的数据是字符串，隐形在尾部有'\\0'，数组元素个数被开辟6个\n    char strb[]={'t','u','l','u','n'};//是一个个存的，数组元素个数被开辟5个，后面没有'\\0'\n    sizeof(stra);//6\n    sizeof(strb);//5\n    \n    printf(\"%s \\n\",stra);//将输出\"tulun\"\n    printf(\"%s \\n\",strb);//将输出：tulun????????...因为程序将从strb这个首地址开始一个一个输出，直到找到内存中存的数值为0才结束\n}\n```\n#### 存放指针的数组\n```c\nint main()\n{\n    //每个元素是某一指针类型//是存放指针的数组\n    int* par[10]={NULL};\n    char* pstr[10]={NULL};\n}\n```\n## 一维数组的应用实例\n### 查表法\n查表法是将一些事先计算好的结果，存储在常量数组中，用到是直接按下标取数据，以节省运行时的计算时间。是以空间换时间。\n```c\n//斐波那契数列\n#include<stdio.h>\nint main()\n{\n    const int n=30;\n    int ar[n]={1,1};\n    ar[0]=ar[1]=1;\n    for(int i=2;i<n;++i)\n    {\n        ar[i]=ar[i-1]+ar[i];\n    }\n    for(int i;i<n;++i)\n    {\n        printf(\"%d \",ar[i]);\n    }\n}\n```\n# 二维数组\n## 二维数组的定义\n## 二维数组的逻辑和物理（内存）表示\n## 二维数组的使用\n# 数组与函数\n## 一维数组作为函数的实参\n## 二维数组作为函数的实参\n# 有关指针\n## `int *p[n]`\n## `int (*p)[n]`\n## 对比\n# 不同C标准\n1. C99可以拿将要用键盘输入的变量作为方括号内的常量，但VS这样的C11不可以。\n```c\nint n=0;\nscanf(\"%d\",&n);\nint ar[n];\nreturn 0;\n```\n\n2. const关键字在编译时期的替换是对于cpp文件而言的。对于.c文件，const就不适用了！\n# 练习\n## 把ar数组中的数据赋值给br数组\n```c\nint main()\n{\n    const int n = 5;\n    int ar[5] = {1,2,3,4,5};\n    int br[5];\n    br = ar;//能不能把ar数组中的数据赋值给br数组。你如何实现？\n    return 0;\n}\n```\n\n```c\n//头文件是#include <string.h>,如果要从数组a复制k个元素到数组b，可以这样做\n//memcpy(b,a,sizeof(int)*k);\n#include <stdio.h>  \n#include <string.h> \nint main()  \n{\n    int a[5]={0,1,2,3,4};\n    int b[5];\n    memcpy(b,a,sizeof(int)*3);\n    for(int i = 0; i < 3; i++)\n    {\n        printf(\"%d \",b[i]);\n    }\n    return 0;\n}\n//如此，b数组变为：0,1,2,??,??\n```\n## 为什么数组的下标从0 开始而不是从1 开始\nhttps://blog.csdn.net/every__day/article/details/83114080\n\n从数组中存储的数据模型来看，下标最精确的意思是”偏移量“，`a[0]`的偏移量是0，即为首地址。`a[i]`的偏移量是`i`，寻址公式就是`a[i]_address = base_address + i*data_type_size`\n\n如果下标从`1`开始，那对应的寻址公式`a[i]_address = base_address + (i-1) * data_type_size`\n对CPU来说，每次随机访问，就多了一次运算，多发一条指令。\n## 如果希望数组的下标从1 到10 而不是从0 到9，该怎么做\n![image-20210718004201328](../../images/C%E8%AF%AD%E8%A8%80_%E6%95%B0%E7%BB%84/image-20210718004201328.png)\n## 用查表法实现日历的一些功能\n## 随机函数给数组元素赋值并且排序\n定义大小为100 的整型数组，使用随机函数给数组元素赋值。数值范围`1..100`，并且排序，使用冒泡排序实现。\n\n随机函数：链接地址： http://www.cplusplus.com/reference/cstdlib/rand/\n```c\nvoid Bubble_Sort(int* br,int n)\n{\n    for(int i=1;i<n;++i)\n    {\n        bool tag=true;\n        for(int j=0;j<n-i;++j)\n        {\n            if(br[j]>b[j+1])\n            {\n                Swap_Int(&br[j],&br[j+1]);\n                tag=false;\n            }\n        }\n        if(tag) break;\n    }\n}\n```\n## 随机函数给数组元素赋值，不能重复\n定义大小为100 的整型数组，使用随机函数给数组元素赋值。数值的范围是`1 .. 100`，并且不能重复。\n```c\nint* My_NonRepeating_RandArr(int* ar, int n)\n{\n    assert(ar != nullptr);\n    int br[101];\n    for (int i = 0;i < n + 1;++i)\n    {\n        br[i]=0;\n    }\n    int temp;\n    srand(time(NULL));\n    int i = 0;\n    do\n    {\n        temp = rand() % 100 + 1;\n        if (br[temp] != 1)\n        {\n            br[temp] = 1;\n            ar[i] = temp;\n            ++i;\n        }\n    } while (i<n);\n    return ar;\n}\n```\n## 统计字符串中每个英文字符出现的次数，不区分大小写\n统计字符串中每个英文字符出现的次数，不区分大小写，只统计英文字符。\n## 统计字符串中每个英文字符出现的次数，区分大小写\n统计字符串中每个英文字符出现的次数，区分大小写，只统计英文字符。\n## FindValue\n`FindValue`，Value如果没在数组中则返回`-1`，如果在则返回下标。\n```c\nint FindValue(int* br, int n, int val)\n{\n    int i=0;\n    while(i<n)\n    {\n        if(br[i]==val)\n        {\n            return i;\n        }\n        ++i;\n        }\n        return -1;\n    }\nint main()\n{\n    int br[8]={23,12,67,34,90,100,45,78};\n    FindValue(br,8,34);\n}\n\n//改进后的代码\nint FindValue(int* br, int n, int val)\n{\n    assert(br != nullptr);\n    int pos=-1;\n    int i=0;\n    while(i<n)\n    {\n        if(br[i]==val)\n        {\n            pos = i;\n        }\n        ++i;\n    }\n    return pos;\n}\n//终极改进\nint FindValue(int* br, int n, int val)\n{\n    assert(br != nullptr);\n    int pos=n-1;\n    while(pos>=0 && br[pos]!=val)\n    {\n        --pos;\n    }\n    return pos;\n}\n```\n## 给超大数组随机赋值，不能重复，用哈希算法\n如果第六题中数组大小改为1000000，那么数组开辟空间就很大，如果仍然按照旧的方式去做肯定是对程序不利的。考虑用哈希算法解决！\n## 有序数组中FindValue，用二分查找\n接第9题FindValue，如果我们的数组中的数据是按照大小顺序排列的，那么我们就不需要按顺序遍历查找，可以采取二分查找，何为二分查找，效率如何，如何二分查找？\n## 二分查找的变种——斐波那契查找\n[二分查找及其变种](https://www.cnblogs.com/yumingxing/p/9583154.html)：斐波那契查找的时间复杂度还是$O(\\log_2 n)$，但是与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间。\n","tags":["tulun"],"categories":["C"]},{"title":"C语言_分支语句、循环语句、函数初步","url":"/C/C语言_分支语句、循环语句、函数初步/","content":"# bool类型\n\nbool只有true 和false；在C语言中0是false，其他情况(非0)都为true。\n在.c文件中需要引入头文件<stdbool.h>；在.cpp文件中直接使用。\n注意：VS2012不完全支持C99标准，不能引入头文件stdbool.h 。但文件后缀为.cpp可以直接使用bool类型。\n\n也可以自己构造bool 类型（但没必要，因为cpp文件下可以直接用）。\n## 构造bool类型代码示例\n```c\n// test.c 文件 注意文件后缀是 C 文件。\n#include<stdio.h>\ntypedef int bool;\n#define true 1\n#define false 0\nint main()\n{\n\tbool xtag = true;\n\treturn 0;\n}\n```\n\n\n\n```c\n#include<stdio.h>\nint main()\n{\n    bool x = false;\n    printf(\"%d \\n\",x);//0\n    ++x;\n    printf(\"%d \\n\",x);//1\n    ++x;\n    printf(\"%d \\n\",x);//1\n    ++x;\n    printf(\"%d \\n\",x);//1\n    return 0;\n}\n```\n\n```c\n#include<stdio.h>\nint main()\n{\n    bool x = false;\n    printf(\"%d \\n\",x);//0\n    --x;//0 --> -1 转为1\n    printf(\"%d \\n\",x);//1\n    --x;//1 --> 0\n    printf(\"%d \\n\",x);//0\n    --x;//0 --> -1 转为1\n    printf(\"%d \\n\",x);//1\n    return 0;\n}\n```\n\n# 关系表达式\n\n关系表达式运算结果是bool值。关系运算符都是双目运算符，其结合性均为左结合。关系运算符的优先级低于算术运算符，高于赋值运算符。在六个关系运算符中，`<`、`<=`、`>`、`>=`的优先级相同，高于`==`和`!=`，`==`和`!=`的优先级相同。\n需要特别注意：`==` 才表示等于比较，而 `=` 表示赋值，大家要注意区分，切勿混淆。\n\n![image-20210715132315085](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210715132315085.png)\n\n## 该死的`=`号\n\n```c\n#include<stdio.h>\nint main()\n{\n    int age = 0;\n\tscanf(\"%d\",&age);\n\tif(age = 3)  //if(age==3) //if(3==age)\n\t{\n\t\tprintf(\"该上幼儿园了 \\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"hehe \\n\");\n\t}\n\treturn 0;\n}\n```\n\n此例中if圆括号内的表达式为`\"age=3\"`，是一个常量赋值给变量的操作，一定会通过导致表达式结果值为1，所以无论在外输入什么此处判断都会为true。这是因为少打了一个=号造成等值判断误成为了赋值语句。为了规避这个错误，我们应该在使用等值判断语句时尽量把常量放在左边，把待比较的变量放在右边。这样的话，如果写成`\"3=age\"`后，编译时期即会报错，而不是把错误延续给运行时期！\n# 逻辑表达式\n\n逻辑表达式运算结果是bool值。\n\n![image-20210715132551231](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210715132551231.png)\n## 与运算(`&&`)\n又称截断与、简洁与。参与运算的两个表达式都为真时，结果才为真，否则为假。\n## 或运算(`||`)\n又称截断或、简洁或。参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假。\n## 非运算(`!`)\n参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真。\n## 优先级\n逻辑运算符和其它运算符优先级从低到高依次为：\n赋值运算符(`=`)　`<`　`&&`和`||`　`<`　`关系运算符`　`<`　`算术运算符`　`<`　非(`!`)\n`&&`和`||`低于`关系运算符`，`!`高于`算术运算符`。\n# 分支语句\n\n## 双分支语句加几行代码变单分支\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a=0,b=0;\n    int max=0;\n    scanf(\"%d %d\",&a,&b);\n    if(a>b)\n    {\n        max = a;\n    }else\n    {\n        max = b;\n    }\n    return 0;\n}\n```\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a=0,b=0;\n    int max=0;\n    scanf(\"%d %d\",&a,&b);\n    max = a;\n    if(max<b)\n    {\n        max = b;\n    }\n    return 0;\n}\n```\n\n## 三目运算符替代简单的if语句\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a=0,b=0;\n    int max=0;\n    scanf(\"%d %d\",&a,&b);\n    max = (a>b)?a:b;\n    return 0;\n}\n```\n\n　　if 语句在某些情况下可以用条件运算符“?:”来简化表达。“ ? :”是一个三元运算符，其构成的表达式格式为：<表达式1> ? <表达式2> : <表达式3>；执行逻辑：先计算表达式1，若其值为真（或非0），则计算表达式2（不计算表达式3），并将该值作为整个表达式的值；反之，即表达式1 的值为假或为0，则计算表达式3（不计算表达式2），并将该值作为整个表达式的值。\n\n## if-else多分支语句\n\n### 判断字符类别\n\n判别键盘输入字符的类别，是否是数字字符，是否是小写字符，是否是大写字符，还有其它字符。\n\n```c\n//输入字符给变量有两种写法。\nchar ch;\nscanf_s(\"%c\",&ch);//a\nch=getchar();\n//以上两种写法是等效的。\n```\n\n#### 相应的头文件`<ctype.h>`\n\n##### 函数\n\n###### 字符分类\n\n1. `isalnum(char)`;判断一个字符是否是字母或数字\n2. `isalpha(char)`;判断一个字符是否是字母\n3. `islower(char);`判断一个字符是否是小写字母\n4. `isupper(char);`判断一个字符是否是大写字母\n5. `isdigit(char);`判断一个字符是否是数字\n6. `isxdigit(char);`判断一个字符是否是十六进制数字字符（`0123456789abcdefABCDEF`）\n7. `iscntrl(char);`判断一个字符是否是控制字符\n8. `isspace(char);`判断一个字符是否是空白字符\n9. `isblank(char);`判断一个字符是否是空格字符（`C99`）\n10. `ispunct(char);`判断一个字符是否是一个标点符号\n###### 字符操作\n1. `tolower(char);`将字符转换成小写\n2. `toupper(char);`将字符转换成大写\n### 良好的代码风格\n\n![image-20210716113008168](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716113008168.png)\n## switch多分支结构\n\n# 函数初步\n\n在结构化程序设计中，函数是将任务进行模块划分的基本单位。通过函数，可以把一个复杂任务分解成为若干个易于解决的小任务。充分体现结构化程序设计由粗到精，逐步细化的设计思想。一个大的程序一般应分为若干个程序模块，每个模块实现一个特定的功能，这些模块称为子程序，在C语言中子程序用函数实现。\n\n什么时候我们认为模块是足够小的：功能是单一的。\n\n![image-20210714181921261](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210714181921261.png)\n\n## 按是否系统预定义分两类\n\n### 编译系统预定义\n\n一类是编译系统预定义的，称为库函数或标准函数，如一些常用的数学计算函数、字符串处理函数、图形处理函数、标准输入输出函数等。这些库函数都按功能分类，集中说明在不同的头文件中。用户只需在自己的程序中包含某个头文件，就可直接使用该文件中定义的函数。\n1. `<asserst.h>`\n2. `<ctype.h>`\n3. `<math.h>`\n4. `<stdio.h>`\n把函数名字、函数功能记下来。\n### 用户自定义\n另一类是用户自定义函数，用户可以根据需要将某个具有相对独立功能的程序定义为函数。\n自定义函数有：`函数返回类型` + `函数名` + `形参列表` + `函数体构成` ；\n#### 函数的命名要求\n1. 拿英文命名函数\n2. 第二个要求：见名知义，不要用汉语拼音，有歧义。\n#### 函数的声明、定义注意事项\n##### 原则\n1. 需要外部输入的（比如scanf）写到形参中；\n2. 需要打印、输出的，return返回。\n##### 该死的形参\n\n###### 形参变量类型名后的标识符要不要省\n\n1. 函数的声明中形参列表可以省去形参名（标识符），但不能省去类型名。因为虽然函数不识别名称，但必须识别类型；\n2. 而函数定义就要把形参名写全，因为函数体中要操作之；\n3. 函数的调用中，参数前不能加类型名。\n###### 形参变量的定义必须每个参数都有一个类型和一个名称\n\n形参变量的定义与局部变量定义是有区别的。局部变量是可以`int x,y;`这样定义的，但形参定义不可以，必须是一个类型匹配一个名称！\n##### 函数声明、定义后的分号\n\n函数声明是一个语句，所以要加分号。但是定义函数完成后花括号后加分号也没影响，因为那是个空语句，但也没必要！\n\n##### 一定要在函数被调用前声明或定义\n\n被调用函数要在调用者调用它之前的区域声明或定义，不然编译是不会通过的！\n##### 不允许函数的嵌套定义\n\nC语言中不允许函数的嵌套定义，即在一个函数中定义另一个函数。\n##### 函数的调用是允许嵌套的\n![image-20210716124810268](../../images/C语言_分支语句、循环语句、函数初步/image-20210716124810268.png)\n![image-20210716124758735](../../images/C语言_分支语句、循环语句、函数初步/image-20210716124758735.png)\n### 示例\n\n![image-20210714182226592](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210714182226592.png)\n\n定义函数时可能会涉及若干个变量，究竟哪些变量应当作为函数的参数？哪些应当定义在函数体内？这有一个原则：\n作为一个相对独立的模块，函数在使用时完全可以被看成 “黑匣子”，除了输入输出外，其他部分可不必关心。从函数的定义看出，函数头正是用来反映函数的功能和使用接口，它所定义的是“做什么”，在这部分必须明确“黑匣子”的输入输出部分，输出就是函数的返回值，输入就是参数。因此，只有那些功能上起自变量作用的变量才必须作为参数定义在参数表中；函数体中具体描述“如何做”，因此除参数之外的为实现算法所需用的变量应当定义在函数体内。\n## 形参和实参\n\n### 形式参数（形参）\n\n只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。\n\n形式参数是指函数名后括号中定义的变量，形式参数只有在函数被调用的过程中给于赋值（分配存储空间）。函数执行完后形式参数变量就自动释放了，所以形式参数只在函数中可见（作用域）。\n### 实参（实际参数）\n\n调用函数时给出的参数包含了实实在在的数据，所以称为实际参数，简称实参。\n\n实参可以是：常量、变量、表达式或函数等。无论实参是何种类型的量，在进行函数调用时，它们都**必须有确定的值**，以便把这些值传送给形参。\n### 功能\n\n形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。\n### 形参实参的区别与联系\n\n1. 形参变量只有在函数被调用时才会分配内存（在stack 中），调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。\n2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。\n3. 实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。\n4. 函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有关系，所以，在函数调用过程中，形参的值发生改变并不会影响实参的值。\n\n## 函数调用中的内存分配\n\n![image-20210716123311156](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716123311156.png)\n\n假如内存共有1M空间。我们会把它分解成若干个栈帧（**下去查询VS如何设置栈的大小和栈帧的大小**），主函数调用时，会把底层的栈帧分配给主函数，如果将要占用很多的空间，我们就得继续往上占用上层的栈帧。每当有一个函数调用，即分配一个栈帧。\n\n```c\nint a = 10;\nint b = 20;\nint* p = &a;//星号在类型和标识符之间时是声明。//p=>&a;  //*p（星号在指针变量前是解引用）=>*&a=>a;\n```\n\n## 传地址交换值--间接改变值\n\n![image-20210715152049764](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210715152049764.png)\n\n### 问题1\n`int tmp = *ap;`通过指针指向取x的值并修改tmp值的底层实现是如何的？\n`mov eax,10;`\n`mov ebx,0x00b3f9f0;`\n`mov [ebx],100h;`\n直接访问、间接访问。任何一本讲微机原理的书都有讲解。\n### 问题2\n![image-20210716122234042](../../images/C语言_分支语句、循环语句、函数初步/image-20210716122234042.png)\n仔细观察，发现未曾开辟定义的存储空间中都是随机值\"`cccccccc`\"，而有两个地址很特殊，就是`Swap_p`的函数域中`ap`指针变量的地址之上的两个地址`\"0X00B3F9F8\"`和`\"01351459\"`。这两个值是什么值呢？\nC语言的面试：指针、编译链接过程、函数调用过程中**线程的保护、恢复**是怎么实现的。调用函数、现场保护，调用完后要实现现场的恢复。这是区分学的好不好、自学能力强不强的标准。C语言全部讲完后，分模块讲时再说。\n## 函数调用机制\n\n![image-20210714182226592](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210714182226592.png)\n\nC语言中，先把y入栈，再把x入栈，函数参数入栈的顺序是从右向左的！有些编程语言是从左向右的。\n\n函数调用首先要进行参数传递，参数传递的方向是由实参传递给形参。传递过程是，先计算实参表达式的值，再将该值传递给对应的形参变量。一般情况下，实参和形参的个数和排列顺序应一一对应，并且对应参数应类型匹配（赋值兼容）,即实参的类型可以转化为形参类型。而对应参数的参数名则不要求相同。\n在示例中`int MaxInt(int a,int b)`，a和b是形参，在main中 x, y 是实参。\n\n查：被调用函数MaxInt return c给主函数中的max变量时，肯定不能直接赋值，而是用临时空间先存放，再取出送给这个max。这个临时空间谁来担当？\n\n## 多文件结构\n\n# 循环语句\n\n## while语句\n\n### 示例--打印平方表\n\n```c\n#include<stdio.h>\nint main()\n{\n\tint i = 0, n = 0;\n\tprintf(\"Enter number of entries in table: \");\n\tscanf(\"%d\",&n);\n\ti = 1;\n\twhile(i <= n)\n\t{\n\t\tprintf(\"%10d%10d\\n\",i,i*i);\n\t\t++i;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n```\n\n## do-while循环\n\n特点是先执行，后判断。要有一个条件使之退出while才行。\n\n```c\n//计算一个正整数的位数\n#include<stdio.h>\nint main()\n{\n    int digits = 0,n;\n    printf(\"Enter a nonnegative integer: \");\n    scanf(\"%d\",&n);\n    do\n    {\n        n/=10;\n        digits++;\n    }while(n>0);\n    printf(\"The Number has %d digit \\n\",digits);\n    return 0;\n}\n```\n\n但是do-while有一个漏洞，就是如果上例代码输入了一个\"0\"值的话，还是会执行一次，最后输出1位。但是实际上0是不占位数的。\n\n## for循环\n\n1. 表达式1只执行一次\n2. 表达式2判断为真才执行循环体\n3. 循环体执行完后才执行表达式3\n特点是：编程的执行顺序和我们编写他的顺序不符合，所以有些人不习惯for语句。\n### VS和VC++编译器对于for语句中表达式1的区别\n\nVS2012/2019中的`for(int i=0;i<10;++i)`中i的作用域只在for块内\n\nVC++中i的作用域在块外也有，因此不能重新声明i\n\nVC++中`.c`文件中的for语句中表达式1不能同时定义、初始化。只能在for外先定义i。\n\n### for循环的惯用法\n\n对于向上加（变量自增）或向下减（变量自减）的循环来说，for语句通常是最好的选择。\n\n```c\n// 从0 向上加到n-1\nfor(i = 0; i < n; ++i) ...\n// 从1 向上加到n\nfor(i = 1; i <= n; ++i) ...\n// 从n-1 向下减到0\nfor(i = n-1; i >= 0; --i) ...\n//从n 向下减到1\nfor(i = n; i > 0; --i) ...\n//编写的控制表达式中把 i < n 写成 i <= n , 会犯\"循环次数差一次\" 错误\n```\n\n```c\n#include<stdio.h>\nint main\n{\n    int i = 0;\n    int n = 5;\n    for(i = n; i > 0;--i)\n    {\n        printf(\"%d \",i);//执行n次\n    }\n    printf(\"for end: \\n\");//输出for循环退出后i的值\n    printf(\"%d \\n\", i);\n    return 0;\n}\n```\n\n### 循环语句圆括号中省略表达式\n\n```c\nint n=10;\nint i=1;\nfor(;;)//for(int i=0;i<n;++i)\n{\n    if(i>=n)\n    {\n        break;\n    }\n    ++i;\n}\n```\n\n对于for省略：如果省略了表达式2，那么是死循环的效果\n\n对于while，省略圆括号内表达式，不可行。\n### 三种死循环\n#### for\n\n```c\nfor(;;)\n{\n    ;\n}\n```\n\n```c\n//如何把死循环写法改为之前for(int i=0;i<n;++i)的效果\nint n=10;\nint i=1;\nfor(;;)//for(int i=0;i<n;++i)\n{\n    if(i>=n)\n    {\n        break;\n    }\n    ++i;\n}\n```\n\n#### while\n\n```c\nwhile(1)\n{\n    ;\n}\n```\n\n#### do-while\n\n```c\ndo\n{\n    ;\n}while(1);\n```\n\n### 0716重点：跳转语句\n\n实际上，`break/continue/return`都是`goto`的变种。\n#### break\n语句只能用在switch语句和循环语句中，用来跳出switch语句或提前终止循环，**转去执行switch语句或循环语句之后的语句**。\n\n![image-20210716141723230](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716141723230.png)\n\n需要注意的是：**break语句只能跳出一层循环**。\n#### continue\n\n语句只能用在循环语句中，用来终止本次循环。当程序执行到continue语句时，将**跳过其后尚未执行的循环体语句，开始下一次循环**。**下一次循环是否执行仍然取决于循环条件的判断**。continue语句与break语句的区别在于，continue语句结束的只是本次循环，而break结束的是整个循环。\n\n但上面这段话没说明本质。\n\n![image-20210716143039440](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716143039440.png)\n\n##### continue对于for语句\n\ncontinue对于for语句跳到的是表达式3。如果处理不当就会出问题：\n\n```c\n//打印：1 3 5 7 9\nint main()\n{\n    int n=10;\n    for(int i=0;i<n;++i)\n    {\n        if(i&2==0)\n        {\n            continue;\n        }\n        printf(\"%d \",i);\n        //++i;//如果把for圆括号中的表达式3挪下来写到循环块内的最后一句，则此循环将成为死循环。因为continue针对for循环是跳到表达式3的，如果表达式3是空语句则不执行任何语句，徒劳。\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n##### continue对于while和do-while语句\n\ncontinue对于while和do-while语句，continue跳到的是圆括号内的判断。如果处理不当，更会出问题。\n\n如何将上述for的代码由for改为while循环？\n\n```c\n#include<stdio.h>\n//错误示范\nint main()\n{\n    int n=10;\n    int i=0;\n    while(i<n)\n    {\n        if(i%2==0)\n        {\n            continue;\n        }\n        printf(\"%d \",i);\n        ++i;\n    }\n    printf(\"\\n\");\n}\n```\n\n```c\n#include<stdio.h>\nint main()\n{\n    int n=10;\n    int i=0;\n    while(i<n)\n    {\n        ++i;\n        if(i%2==0)\n        {\n            continue;\n        }\n        printf(\"%d \",i);\n    }\n    printf(\"\\n\");\n}\n```\n\n#### goto\n\n**语句**和**标号语句**一起使用，所谓标号语句是**用标识符标识的语句**，它控制程序从goto语句所在的地方转移到标号语句处。\n\ngoto语句会导致程序结构混乱，可读性降低，而且它所完成的功能完全可以用算法的三种基本结构实现，因此一般不提倡使用goto语句。\n\n```c\n#include<stdio.h>\nint main()\n{\n\tint i = 0,j = 0,k = 0;\n\tfor(i = 0;i<10;++i)\n\t{\n\t\tfor(j = 0;j<10;++j)\n\t\t{\n\t\t\tfor(k = 0;k<10;++k)\n\t\t\t{\n\t\t\t\tif(i+j+k == 10)\n\t\t\t\t{\n\t\t\t\t\tgoto input;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinput:\n\tprintf(\" main end \\n\");\n\treturn 0;\n}\n```\n##### 适用场合\n\n在某些特定场合下goto语句可能会显出价值，比如在多层循环嵌套中，要从深层地方跳出所有循环，如果用break语句，不仅要使用多次，而且可读性较差，这时goto语句可以发挥作用。\n\n```c\n#include<stdio.h>\nint main()\n{\n    \n}\n```\n\n##### 注意\n\n1. goto最好只用它来从上到下跳。不要从下到上跳，因为可能会产生程序的二义性。\n2. 不能在函数间跳转，不能跨越两个函数。只能在本函数的作用域、可见性中跳转。\n##### VS2019\n#### return\n\n语句用于结束函数的执行，返回调用者，如果是主函数，则返回至操作系统（终止程序的执行）。\n利用一个return语句可以将一个数据返回给调用者。\n\nreturn本质上就是goto连带一个数据返回。与goto的区别就是goto不能带一个数据，return可以。\n\n##### 主函数中的return与子函数中的return\n\n1. 主函数return后，程序结束。子函数return只是本函数结束。\n2. 主函数的return是返回给操作系统。\n\n##### return与exit函数的区别\n\n在主函数中，`exit(1);`与`return 0;`的效果是一样的。都是结束程序的执行；但在子函数中就和return语句不一样了，子函数中调用`exit()`也会直接终止整个程序的执行。\n\n调用exit()函数会直接终止程序的进行，需要引入头文件`<stdlib.h>`。\n\n传递给exit函数的实际参数和main函数的返回值具有相同的含义：两者都说明程序终止时的状态，为了表示正常\n终止，传递0，即 exit(0)；因为0 有点模糊，所以C语言允许用`EXIT_SUCCESS`来替代（效果相同）。exit(0);等同于`exit(EXIT_SUCCESS)`;，表示程序正常退出；exit(1);等同于exit(EXIT_FAILURE);，表示程序异常退出。\n\n```c\nexit(EXIT_SUCCESS); /* normal termination */\nexit(EXIT_FAILURE); /* abnormal termination */  //传递EXIT_FAILURE表示异常终止：\nEXIT_SUCCESS和EXIT_FAILURE都是定义在<stdlib.h>中的宏。\nEXIT_SUCCESS和EXIT_FAILURE的值都分别是0和1.\n```\n##### 返回类型为void\n\n通常，当函数的返回类型为void时， return语句可以省略，如果使用也仅作为函数或程序结束的标志。有些编译器可以写成`return void;`，但在VS2019中不可以。\n#### 总结\n\n都是goto的变种。\n\n# 空语句\n\n语句可以为空，也就是除了末尾处的**分号**以外什么符号也没有。\n\n## 所带来的问题\n\n### 圆括号后放置空语句\n\n不小心在if、while 或 for 语句的圆括号后放置分号会创建空语句，从而造成if、 while 或 for 语句提前结束。if 语句中，如果在圆括号后放置分号，无论条件表达的值是什么，if 语句执行的动作都一样，都会执行if块内的代码：\n\n#### if语句\n\n```c\nif(d == 0)  ;\n{\n    printf(\"Error: Division by zero \\n\");\n}\n```\n\n#### while语句\n\nwhile 语句中，如果在圆括号后放置分号，会产生无限循环：\n\n```c\ni = 10;\nwhile(i>0) ;\n{\n\tprintf(\"%d \",i);\n\t--i;\n}\n```\n\n另一种可能是循环终止，但是在循环终止后只执行一次循环体语句：\n\n```c\ni = 10;\nwhile(--i>0) ;\n{\n\tprintf(\"%d \",i);\n}\n```\n\n#### for语句\n\nfor 语句中，如果在圆括号后放置分号，会导致只执行一次循环体语句：\n\n```c\nfor(i = 10; i > 0 ; --i) ;\n{\n    printf(\"value: %d \",i);\n}\n```\n\n## 要注意的地方\n\n### 该死的分号;\n\n#### 函数后的分号\n\n##### 函数声明语句\n\n函数声明时加分号。\n\n##### 函数定义语句\n\n在大括号后加了分号也没事，因为这是空语句，无大碍。\n![image-20210716114054328](../../images/C语言_分支语句、循环语句、函数初步/image-20210716114054328.png)\n##### 结构体定义语句\n\n结构体定义结束时，在大括号后必须加分号。表示结束。\n![image-20210716114227011](../../images/C语言_分支语句、循环语句、函数初步/image-20210716114227011.png)\n# 逗号表达式\n\n逗号表达式只能写类型一致的声明，`int i = 0, float = 2.0`是不对的。\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a=10,b=20,c-30;\n    int x=0;\n    //下面两句看似说明逗号运算符和分号没什么区别\n    x=a,a=b,c+=10;\n    x=a;a=b;c+=10;\n    //但是，如下两句就能体现出了逗号运算符的方便\n    x = (a+10, a=b, c += 10);//编译通过\n    x = (a+10; a=b; c += 10);//程序编译不通过，因为分号不可被包在括号里。\n}\n```\n\n上例中，`x = (a+10, a=b, c += 10);`这句表达式如何运算呢？首先执行`a+10`，但a的值不变；再执行`a=b`，将b的值赋给，a的值变成20；再让`c+=10`，c的值变为40。那么x的值会被赋为多少呢？答案是40，因为逗号表达式的值是取最后一条表达式的值。\n\n按照逗号表达式的运行机制，我们可以优化一个事情，就是下面讲到的scanf的代码位置。\n## `scanf_s`函数的机制\n\n```c\n#include<stdio.h>\nint main()\n{\n    int n=0,m=0;\n    printf(\"Enter integers (0 to erminate)\\n\");\n    scanf_s(\"%d\",&n);\n    while(n!=0)\n    {\n        sum = sum + n;\n        scanf_s(\"%d\",&n);\n    }\n    printf(\"sum %d \\n\",sum);\n    return 0;\n}\n```\n\nstdin标准输入文件流\nstdout标准输出文件流\nstderr错误流\n\n标准输入/输入文件流他们都带有缓冲区。stdin从键盘上输入数据的时候，就先把数据放到标准输入文件流的缓冲区中了。stdin还有一个能力，会把缓冲区中的内容回显在屏幕上。如果没有回车，我们就认为这个输入没有结束。如果打了回车，就相当于通知scanf从缓冲区中取值。可以每输入一个数据回车一次后scanf读取此数，接下来输入后面的数据并回车时，就会把前面的缓冲区覆盖掉；也可以使多个数据空格隔开全输入完，再一次性回车，交给scanf依次读取。两种方式最大的不同就在于缓冲区存储的数据不一样多。\n\n这种输入的形式，有个不好的地方，就是while外一个scanf，while内有个scanf。怎么样使之更为简洁呢？就用到了逗号表达式。\n\n```c\n#include<stdio.h>\nint main()\n{\n    int n=0,sum=0;\n    printf(\"Enter integers (0 to terminate)\\n\");\n    while(scanf_s(\"%d\",&n),n!=0)\n    {\n        sum = sum + n;\n    }\n    printf(\"sum %d \\n\",sum);\n    return 0;\n}\n```\n\nwhile最终要判断的是逗号表达式最后的一个表达式即`n!=0`。所以这样做不但不影响while的正确判断还简化了代码编写。\n# 0715作业\n\n1. 两个for循环（二维数组）打印一个乘法口诀表。\n```c\n#include<stdio.h>\nvoid MultiTable(int n)\n{\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=1;j<=i;++j)\n        {\n            printf(\"%d*%d=%d \",j,i,i*j);\n        }\n        printf(\"\\n\");\n    }\n}\nint main()\n{\n    int n = 0;\n    scanf_s(\"%d\",&n);\n    MultiTable(n);\n}\n```\n2. 仔细观察如何把一维数组转化输出为一个二维平面？-->为N后做准备\n![image-20210715163945136](../../images/C语言_分支语句、循环语句、函数初步/image-20210715163945136.png)\n3. 选做题：仔细观察，n=5，从输出的角度如何打印成这样的效果：\n![image-20210716012622369](../../images/C语言_分支语句、循环语句、函数初步/image-20210716012622369.png)\n   （提示：第一行每个数只有1位，每一行都比上一行少一个数）\n   如果是整型数\n   如果是字符数组：滑动动态窗口方式。\n4. 输入任意顺序的三位数，都能正确找到其中间大小的数。\n\n```c\n#include<stdio.h>\nint MaxInt(int x,int y)\n{\n    return x > y ? x : y;\n}\n//错误写法\nint MidInt(int a,int b,int c)\n{\n    a = a > b ? a : b;\n    return a < c ? a : c;\n}\n//逻辑法\nint MidInt(int a, int b, int c)\n{\n    if(a>=b&&a<=c)\n    {\n        return a;\n    }\n    else if(b>=a&&b<=c)\n    {\n        return b;\n    }\n    else\n    {\n        return c;\n    }\n}\n//先冒泡排序，后输出b\nint MidInt(int a, int b, int c)\n{\n    if(a>b){Swap_Int(&a,&b);}\n    if(b>c){Swap_Int(&b,&c);}\n    if(a>b){Swap_Int(&a,&b);}\n    return b;\n}\n//1 2 3=>2\n//1 3 2=>2\n//2 3 1=>2\n//2 1 3=>2\n//3 1 2=>2\n//3 2 1=>2\nint main()\n{\n    int a,b,c;\n    int max=0,mid=0;\n    scanf_s(\"%d %d %d\",&a,&b,&c);\n    max = MaxInt(a,MaxInt(b,c));\n    mid = MidInt(a,b,c);\n    printf(\"max=%d,mid=%d\",max,mid);\n    return 0;\n}\n```\n5. 下去查询VS如何设置栈的大小和栈帧的大小\n![image-20210716013306466](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716013306466.png)\n\n![image-20210716013335862](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716013335862.png)\n6. 下去查：每一个工程的入口函数默认是主函数，怎么设置其他函数为入口？\n![image-20210716013306466](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716013306466.png)\n![image-20210716015329536](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716015329536.png)\n7. 查：直接访问、间接访问。讲微机原理的书都有讲解。\n   `mov eax,10;`\n   `mov ebx,0x00b3f9f0;`\n   `mov [ebx],100h;`\n8. 被调用函数return一个数给主函数中的一个变量时，肯定不能直接赋值，而是用临时空间先存放，再取出送给这个变量。这个临时空间谁来担当？\n9. EAX惯用于“累加器”(accumulator)，它是很多加法乘法指令的缺省寄存器；还用来存放函数返回值；占用32个2进制位，4个字节。eax的后16位为ax，后16位中，前8位为ah，后8位为al，前16位的访问需要右移。有时EAX也用于程序数据的返回值。\n    1. EBX惯用于“基地址”(base)寄存器，在内存寻址时存放基地址。多与指针相关。\n    2. ECX惯用于“计数器”(counter)，是重复(REP)前缀指令和LOOP指令的内定计数器。用于循环的计数。\n    3. EDX：I/O设备的地址编号大于255时，存放设备的端口号。\n    4. 在进行乘除法运算时，EAX用来存商，EDX用来存余数。\n    5. 临时量具有常性，只读不可写，Add(x,y)=100;是不可行的，是不能给函数的返回值赋值的。\n# 0716作业\n\n1. 查：如何产生随机值\n   https://blog.csdn.net/w_y_x_y/article/details/80199694\n```c\n这里对程序中用到的产生随机数的函数进行解释。\n1、srand（）函数：随机数发生器的初始化函数，需要提供一个种子，这个种子会对应一个随机数。如果使用相同的种子,rand() 函数会出现一样的随机数。默认种子数是1，即srand(1)。\n2、rand（）函数：伪随机数发生器，需要先调用srand初始化，一般用当前日历时间初始化随机数种子，这样每行代码都可以产生不同的随机数。\n3、随机数产生的原理：随机数中的变量种子rand初始会赋值给holdrand，然后holdrand和一个公式计算出新的随机数并赋值给holdrand再返回，循环产生随机数，每次得到的结果只与上次随机数的值有关，如果想要每次生成的新随机数和上次随机数没有关联，可以通过每次利用(srand((unsigned)time(0)))改变种子进而初始化holdrand得到随机数。\n```\n2. 做一个简单的计算器，弄一个.h和.cpp文件\n![image-20210716150924442](../../images/C%E8%AF%AD%E8%A8%80_%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E5%87%BD%E6%95%B0%E5%88%9D%E6%AD%A5/image-20210716150924442.png)\n\n```c\n#ifndef\n#表明是预处理命令\nifndef意为if not defined sth.\n它与ifdef都可用于条件编译\n即\n#ifdef 标识符A\n程序段1\n#else\n程序段2\n#endif\n意为若所指定的标识符A已经被#define命令定义过则编译程序段1，否则编译程序段2\n\n同理\n#ifndef 标识符B\n程序段1\n#else\n程序段2\n#endif\n意为若所指定的标识符B未被#define命令定义过则编译程序段1，否则编译程序段2\n```\n","categories":["C"]},{"title":"C语言_概览","url":"/C/C语言_概览/","content":"# 前言及语录\n\n1. C语言的最根本的一个特点：一定要会上机编程。这是宗旨。不管学的怎么样，程序要会编。程序不会编的话，记那么多规则也是没有用的。即C语言的编程是第一位的要求。\n2. [C语言官网](http://www.cplusplus.com) ；[C++参考手册](https://zh.cppreference.com/w)：不会了就可以在这里面查！\n3. 注册博客，要求是：把学习内容按照我们的理解写出来，总结自己学到的内容。博客的好处就是避免遗忘。可以翻出来清楚自己学到了哪些，同时能随时补充。\n4. 刷题网站：牛客网、力扣网。学完数组、指针、结构体后即可上此平台刷题。绝大部分的题都是要我们自己去刷的。\n5. 看的第一本C语言书籍：《高质量程序设计指南——`C++/C`语言》。先看到56页，等学到`C++`再往后看。\n\nC语言概述部分内容简单地把基础知识、基本的语法、指针、结构体介绍。有的详尽，有的不太详尽。后期分专题分析重要的内容。\n# 计算机基础知识\n## 软件的概念\n\n一系列按照特的那个顺序组织的计算机**数据**和**指令**的集合。简单地说，软件就是程序加文档的集合。\n软件一般被划分为系统软件（如安卓操作系统）、应用软件（如Word、编译器）和介于这两者之间的中间件（如Redis）。\n## 文件\n\n文件由两部分构成：文件名和文件主体。\n文件的一种分类是：可执行文件和不可执行文件。\n### 可执行文件\n1. 在Windows操作系统中，扩展名为：`*.exe`, `*.bat`, `*.com`等的文件是可执行文件；\n2. 可执行文件由指令和数据构成。\n3. Linux是靠文件属性来判断是否可执行。\n### 不可执行文件\n其内容是由数据构成。\n### 举例\n\n在`C/C++`语言中，`*.c`/`*.cpp`源文件（文本--`ASCII`码字符构成的），`*.h`头文件（文本），`*.i`预编译文件（文本），`*.s`汇编文件，`*.o/*.obj`二进制目标文件，`*.exe`可执行文件。\n\n![image-20210712155031576](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712155031576.png)\n\n在IDE中编译链接后，工程目录下的`Debug`中形成了`obj`文件和`exe`文件。\n达到可执行的底层步骤：预编译、编译、链接。\n>实际上在编译和链接之间还有汇编这个步骤\n## 进制及其转换\n\n![image-20210712180942700](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712180942700.png)\n我们学习计算机时，如在调试的时候我们看到的底层是以16进制表达的。我们要理解进制。\n进制也就是进位计数制，是人为定义的带进位的计数方法。 对于任何一种进制--`X进制`，就表示每一位置上的数运算时都是逢`X`进一位。 如：十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，`x`进制就是逢`x`进位。我们日常生活中的进制都哪些？\n计算机中的进制分为二进制，八进制，十进制，十六进制。\n二进制数、八进制数、十六进制数转换为十进制数的规律是相同的。把二进制数（八进制或十六进制数）按位权形式展开多项式和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”。如：\n`(10100)2`➔`(1 * 2^4 + 0*2^3 + 1 * 2^2 + 0*2^1 + 0*2^0)10`➔`(20)10`\n\n`(245)8`➔`(2 * 8^2 + 4 * 8^1 + 5 * 8^0)10`➔`(165)10`\n\n`(1F2)16`➔`(1 * 16^2 + 15 * 16^1 + 2 * 16^0)10`➔`(498)10`\n\n> 练习：`(103)10`➔`(    )2➔(    )8`➔`(    )16`\n\n# C语言简介\n\nC语言是一种结构化语言，它有着清晰的层次，可按照模块的方式对程序进行编写，十分有利于程序的调试，且C语言的处理和表现能力都非常的强大，依靠非常全面的运算符和多样的数据类型，可以轻易完成各种数据结构的构建，通过指针类型更可对内存直接寻址以及对硬件进行直接操作，因此既能够用于开发系统程序，也可用于开发应用软件。\n1982年成立C标准委员会，建立C语言的标准。\n1989年，ANSI发布了第一个完整的C语言标准——`ANSIX3.159—1989`，简称“C89”。\n1999年，在做了一些必要的修正和完善后，ISO (International Standards Organization)，发布了新的C语言标准，命名为`ISO/IEC 9899: 1999`，简称“C99”。\n在2011年12月8日，ISO又正式发布了新的标准，称为`ISO/IEC9899: 2011`，简称为“C11”。 \n## 第一个C语言程序\n\n```c\n// hello.c  \t\t //注释\t// /* 不容许嵌套 */\n#include<stdio.h> \t //预编译处理\nint main() \t\t\t //主函数\n{\n\tprintf(\"hello word !\\n\"); //语句\n\treturn 0;\n}\n```\n## C源程序的结构特点\n1. 一个Ｃ语言源程序可以由一个或多个源文件组成。\n2. 每个源文件可由一个或多个函数组成。\n3. 一个源程序不论由多少个文件组成，都有一个且**只能有一个main函数**，即主函数。\n4. 源程序中可以有预处理命令(include 命令仅为其中的一种)，预处理命令通常应放在源文件或源程序的最前面。\n5. 每一个说明，每一个语句都必须以分号结尾。\n6. 标识符，关键字之间必须至少加一个空格以示间隔。若已有明显的间隔符，也可不再加空格来间隔。\n## C语言的特点\n1. 与Java和C++一样，C语言是一种**强类型**语言。即**类型不可变**性。在C语言中，变量、函数一旦定义了类型，它的类型就不变。\n2. C语言是函数式编译的。即小函数来套函数，一个一个套接。\n### 一段有启发的代码\n![image-20210712190620491](../../images/C语言_210617/image-20210712190620491.png)\n此段代码的运行结果是：`“-10 > 10”`\n# 数据类型\n## 基本数据类型\n必须记住（包括占用字节数），融于血液中。\n### 整型\n1. `char`; 存放字符的ASCII码值。占用1字节\n2. `short`; 短整型，占用2字节\n3. `int`; 占用4字节\n4. `long int`; 占用4字节\n5. `long long`; 占用8字节\n### 浮点\n1. `float`; 单精度，占用4字节\n2. `double`; 双精度，占用8字节\n3. `long double`; 双双精度，当前VS编译器占用8字节，dev编译器占用12字节，将来可能占用16字节\n### 新类型\n`bool`; 占用1字节\n### 无类型 - 也属于基本数据类型\n`void`; 不能定义变量，所以不占用字节\n## 各数据类型的区别\n\n最大的区别在于在定义变量时，它们开辟的空间的字节个数不一样。\n## 关键字sizeof\n\n1. 计算**变量占用的存储空间**或**一种类型在定义变量时所占的存储空间**。**不是函数**！\n2. 计算出来的数值类型为：`unsigned int`\n3. 在编译时进行计算，而不是运行时进行计算。\n\n示例：`int n = sizeof(char);`\n\n```c\nconst int n = 5;\nint ar[n] = {12,23,34,45,56};\nsizeof(n);//4\nsizeof(ar);//等于sizeof(int)*n 即4*5=20\n```\n\n# 变量、常量、标识符\n\n## 变量\n\n以某标识符为名字，其数值可以改变，可读可写。共有三个层次。\n### 全局变量\n\n定义在函数（包括主函数）之外的变量。\n\n#### 作用域解析符——`::`\n\n两个冒号，代表我要用全局变量。常用于全局、局部变量名冲突时区别出全局变量。\n\n### 局部变量\n\n定义在函数内部的变量。\n\n### 块内变量\n\n块内可见。块外不可见。\n\n### 代码示例\n![image-20210712233203207](../../images/C语言_210617/image-20210712233203207.png)\n这段代码的输出结果为：“b = 0 ”。\n#### 全局与局部冲突时的向上就近原则\n\n说明一个规律、道理：当遇到的变量名字出现全局、局部的冲突时，按**向上就近原则**为主。\n![image-20210712233841613](../../images/C语言_210617/image-20210712233841613.png)\n这段代码的输出结果为：`b = 10`。说明了`::`符的作用。\n## 常量\n\n其值不可改变，只读不写。\n### 字面常量\n\n要注意的是常量不只是有数值，常量也带有类型的意义。比如`7/2=3`。\n\n编程与数学的区别：一个有穷一个无穷；一个有类型一个无类型。\n### 宏常量\n\n用#define定义的常量，叫做宏常量。\n\n```C\n#define PI 3.14\n```\n\n宏的根本概念是一种替换原则。\n\n1. 无类型，只是暂时用字符串来表示\n2. 不开辟存储空间\n3. 结尾一般不加分号，如果加上分号则把分号也一起看作是替换的值。\n4. 在预编译时遇到宏常量字符串时起作用，替换。可以在预编译后Debug文件夹下生成的\\*.i文件中看到。\n   ![image-20210713003504549](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003504549.png)\n\n   ![image-20210713003530909](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713003530909.png)\n![image-20210713003601640](../../images/C语言_210617/image-20210713003601640.png)\n### 常变量\n\n用const关键字修饰的变量，称为常变量。只可读取，不可改变。要开辟空间。\n### 枚举常量（enum）\n\n```c\nenum week{\n    Mon=1,\n    Tues=2,\n    Wed=3,\n    Thurs=4,\n    Fri=5,\n    Sat=6,\n    Sun=7};\n```\n\n枚举常量实际上是一种受到限制的**整型量**。不可以是小数。\n\n1. 第一种受限的表现：x不能随便取值，只能从1、2、3、4、5、6、7中赋值。\n![image-20210713004400231](../../images/C语言_210617/image-20210713004400231.png)\n2. 第二种受限的表现：即使从1、2、3、4、5、6、7中赋值也要用定义枚举类的变量名赋值，不可直接用数字。\n![image-20210713004708901](../../images/C语言_210617/image-20210713004708901.png)\n3. 正确写法：\n![image-20210713004753195](../../images/C语言_210617/image-20210713004753195.png)\n4. 其他约束：运算的约束，比如不可以自增自减。\n5. 如果没给第一个变量赋值，则默认第一个变量为0，往后的变量值为依次加1；若没给中间某个变量赋值，则默认为上一个变量值加1。\n![image-20210713005317130](../../images/C语言_210617/image-20210713005317130.png)\n如上图，值依次为：-1、0、1、-2、-1、0、1\n### 字符常量和字符串常量\n\n`char ch = 'a';`\n\n给变量ch中存放的不是字符`'a'`，而是字符`'a'`对应的ASCII码值。即编译后转换为`\"char ch = 97;\"`。\n\n打开内存，查`ch`处的存储内容。发现存的是`97`的十六进制形式`61`。\n\n![image-20210713105853322](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105853322.png)\n\n![image-20210713105916869](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713105916869.png)\n![image-20210713105929580](../../images/C语言_210617/image-20210713105929580.png)\n`char`是整型数据类型，`ch`存储的是ASCII码`97`，但输出的形式由我们决定，如果是`printf(\"%d \\n\", ch);`那么就是`97`。如果是`printf(\"%c \\n\",ch);`那么就是`a`。\n\n关于字符对应的ASCII码，我们重点记忆几个字符即可，比如字符a是97，则可以推出其他字符的值。\n#### 特殊符号 - 转义字符及其含义\n\n![image-20210713111900791](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713111900791.png)\n\n重点记三个：\n1. `\\n`是换行符（LF），将当前位置移到下一行开头。ASCII码值是`10`。\n2. `\\r`是回车符（CR），将当前位置移到本行开头。ASCII码值是`13`。\n3. `\\t`是水平制表符（HT），跳到下一个TAB位置。ASCII码值是`9`。\n4. `\\0`是空字符，ASCII码值是`0`。**所以空字符可以有两种赋值形式:`char ch1 = 0;或char ch2 = '\\0';`**\n如果要表示反斜杠字符，可用`\\\\`转义。\n##### 定界符\n\n单引号是字符的定界符：`'a' -> |97|`。如果要表示单引号字符，可用`\\'`转义。\n双引号是字符串的定界符：`\"a\" -> |97|\\0|`。如果要表示双引号字符，可用`\\\"`转义。\n#### 关于空字符（`\\0`）、空格字符（`' '`）和`'0'`字符\n![image-20210713113436447](../../images/C语言_210617/image-20210713113436447.png)\n一定要区分。区分的关键是从ASCII码值来理解。\n1. 空格字符**不是空字符**。**空格字符的ASCII码值是48**。\n2. `char chb = 0;`和`char chc = '\\0';`等效，都是给变量赋ASCII码值0。\n3. 单引号中只有0的时候是字符'0'，其ASCII码值是48。\n#### 头文件`<ctype.h>`\n用来确定包含于字符数据中的类型的函数。\n![image-20210713144419145](../../images/C语言_210617/image-20210713144419145.png)\n## 标识符\n\n必须是**以下划线或字母开头**的**下划线、字母、数字的组合体**。\n\n`_a`; `a4`; `_3`;均可\n\n变量、函数起名时要见名知义，不要用汉语拼音，因为有同音异词，容易引起歧义。\n# 定义和声明\n\n## 定义\n\n所谓的定义就是为这个变量分配一块内存并给它取上一个名字，这个名字就是我们经常所说的变量名。但注意，这个名字一旦和这块内存匹配起来，它们就同生共死，终生不离不弃，并且这块内存的位置也不能被改变。**一个变量在一定的区域内（比如函数内，全局等）只能被定义一次**，如果定义多次，编译器会提示你重复定义同一个变量或对象。\n## 声明\n\n什么是声明：有两重含义，如下：\n第一重含义：告诉编译器，这个名字已经匹配到一块内存地址上了。（但是如果只是声明的话，不开辟内存空间）\n第二重含义：告诉编译器，我这个名字我先预定了，别的地方再也不能用它来作为变量名。\n## 示例\n\n![image-20210712231142222](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712231142222.png)\n\n示例中`float pi = 3.14f;`，`f`表示此数据为单精度类型，若不带`f`默认为双精度。\n\n# 顺序语句、选择语句、循环语句\n## 顺序结构\n按照语句出现的先后顺序依次执行。\n## 选择结构\n根据条件判断是否执行相关语句。\n## 循环结构\n当条件成立时，重复执行某些语句。\n\n```c\n//统计从键盘输入的一行字符的个数。\nint main()\n{\n    int num = 0;\n    printf(\"input a string\\n\");\n    //char ch = '\\0';\n    //scanf_s(\"%c\",&ch);\n    //ch=getchar();\n    while (getchar()!='\\n')\n    {\n        num += 1;\n    }\n    printf(\"%d \\n\",num);\n    return 0;\n}\n```\n\n其中，`getchar();`等效于`scanf_s(\"%c\",&ch);`，前者明显比后者简洁。\n# 函数\n\n通过函数，可以把一个复杂任务分解为若干个易于解决的小任务。充分体现结构化程序设计由粗到精、逐步细化的设计思想。\n\n![image-20210713172544505](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713172544505.png)\n\n## 函数组成部分\n\n```\n返回类型 + 函数名称(形参列表)\n{\n　　函数体\n}\n```\n\n## 进程与程序的关系\n\n![image-20210713151216654](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713151216654.png)\n\n### 进程\n\n进程是程序的一次执行。进程是动态的。\n\n比如，在现实世界中，程序可以看作是乐谱，乐谱不会自己弹奏。有一钢琴，人坐下根据乐谱进行弹奏，弹奏乐谱的过程就是进程。\n\n进程非常重要的概念：以时间为单位进行流失，在经过某几个时间点内要把程序全部执行直至结束。时间点有创建、执行、结束。\n\n### 资源\n\n又如，菜谱给了做饭步骤，菜谱自己不能凭空做出饭。按照菜谱的模式买菜，架火按照菜谱做饭。而做饭要有资源，油、水、调料、火等。\n\n计算机中最重要的两个资源：**时间**和**空间**。\n\n时间针对于CPU，空间针对于内存。\n\n程序被执行时，任何一个进程，将会把用到的存储空间分配给四个区域——**代码区**(test area)、**数据区**(data area)、**堆区**(heap area)、**栈区**(stack area)。\n\n1. data区存放程序的全局变量。\n2. heap区对应着malloc和free开辟和释放的存储空间。\n3. stack区存放函数中定义的局部变量。\n## 可见性（作用域）\n\n可见性指标识符能够被使用的范围：只有在作用域内的标识符才可以被使用。此阶段特性针对**编译和链接**过程。\n\n1. 函数中定义的标识符，包括**形参**和**函数体中定义的局部变量**的作用域都只在该函数内，也称作函数域。\n2. 文件作用域也称全局作用域，定义在所有函数之外的标识符，具有文件作用域。作用域为**从定义处到整个源文件结束**。文件中定义的全局变量和函数都具有文件作用域。\n## 生存期\n\n生命期指的是标识符从程序开始运行时被创建，具有存储空间，到程序运行结束时消亡时释放存储空间的时间段。此阶段针对的是程序的**执行过程**。\n\n1. 局部变量的生存期是：函数被调用，分配存储空间；函数执行结束，释放空间。stack区。\n2. 全局变量的生存期是：从程序执行前开始，到执行后结束。data区。\n\n### 代码示例_生存期\n\n```c\n#include<stdio.h>\nint* fun()\n{\n    int ar[10] = {12,23,34,56,78,89,90,100};\n    printf(\"fun \\n\");\n    for(int i = 0;i < 10;++i)\n    {\n        printf(\"%d \",ar[i]);\n    }\n    printf(\"\\n\");\n    return ar;\n}\nint main()\n{\n    int* p = fun();\n    printf(\"main \\n\");\n    for(int i = 0;i < 10;++i)\n    {\n        printf(\"%d \",p[i]);\n    }\n    return 0;\n}\n```\n#### 运行结果_生存期\n\n![image-20210713163156464](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713163156464.png)\n\n调用的fun结果正常。而main再遍历ar地址时就失效了，后面的数都是随机数。\n\n此例说明，函数的生存期只有在被调用时才拥有其存储空间，调用结束时，其存储空间将被释放。\n#### 思考\n\n数组ar的头地址中的值为何能一直保存？`main`函数自己调用时，为何除了`12`正确，其他都是乱的？\n\n做了以下实验：如果让`fun`函数`return ar+1`，再在`main`函数中遍历，发现运行结果是![image-20210713164713434](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713164713434.png)\n\n即：第一个数据`23`正确保留，后面全乱。由此，对程序的生存期又可见一斑。\n\n但在`dev-C++`环境下不可实现`main`中`for`遍历（运行出错）。这又说明，**不同编译器对于生存期的定义也不尽相同**！\n\n还做了另一实验：将`ar`数组大小调整至`10000`。还是输出`10`个数，输出却正常。\n\n这个例子体现了**指针的失效**！\n\n#### 解释\n\n我们在调用函数时，都会开辟若干个栈帧提供函数中变量的存储空间。在main函数中调用fun()函数时，随即开辟了一些空间存放数组。最后虽然返回了原本数组的首地址并赋给了p指针，但调用结束后变量的生存期殆尽，空间被释放。printf()也是一函数，他的调用难免会覆盖刚才fun()函数占用的栈帧，即残留在栈帧中的数据被重写导致输出达不到预期以为的效果。\n\n而把数组大小调至10000使fun()函数占用的栈帧很大，导致printf()函数等函数正好没有覆盖到刚才某些数组数据占用的空间，最后导致侥幸输出正确。但本质上p指针还是一个失效指针。\n![image-20210715001423769](../../images/C语言_210617/image-20210715001423769.png)\n### 动态生命期\n\n动态生命期对应动态内存的分配、管理。\n# 数组\n\n数组是包含给定类型的一组数据，即一组相同类型元素的集合。\n# 运算符\n\n## 操作数（Operand）\n\n操作数（operand）是程序操纵的数据实体，该数据可以是数值、逻辑值或其他类型。该操作数既可以是常量也可以为变量。\n## 运算符（Operator）\n\n运算符（operator）是可以对数据进行相应操作的符号。如对数据求和操作，用加法运算符`'+'`，求积操作使用乘法运算符`'*'`等。\n\n根据运算符可操作操作数的个数可分为一元运算符（单目运算符）、二元运算符（双目运算符）和多元运算符（C语言中只有一个三元运算符`\" ? : \"`）。\n## 运算符优先级\n\n![image-20210715010003149](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715010003149.png)\n## 运算符举例\n### 取模运算符%\n在C语言中有很多应用：\n1. 判断是否能够整除某个数；\n2. 判断奇偶数，判别质数；\n3. 计算范围。形成循环。\n```c\n#include<stdio.h>\nint main()\n{\n//以下均要求每五个数换一行\n//从0输出100个数（0~99）\n    for(int i=0;i<100;++i)\n    {\n        if(i%5 == 0 && i!=0)\n        {\n            printf(\"\\n\");\n        }\n    printf(\"%3d\",i);\n}\n//重点是条件中加一个边界限制条件i!=0，如果没有的话会在输出前多余一行\n//输出效果\n//  0  1  2  3  4\n//  5  6  7  8  9\n//  ...\n// 95 96 97 98 99\n\n//从1输出100个数（1~100）\n//如果只改变上述代码中for循环中的int i=1;i<=100会出现以下情况：\n//  1  2  3  4\n//  5  6  7  8  9\n//  ...\n// 95 96 97 98 99\n//100\n//所以我们要转变思路，主要转移点就是：先输出，后换行，并限制尾部边界条件，即100输出后不换行。\n    for(int i=1;i<=100;++i)\n    {\n        printf(\"%3d\",i);\n        if(i%5==0 &&　i!=100)\n        {\n            printf(\"\\n\");\n        }\n    }\n//而先输出数字后换行的模式如果对于0~99来说又失效了，会出现如下情况：\n    for(int i=0;i<100;++i)\n    {\n        printf(\"%3d\",i);\n        if(i%5==0 &&　i!=100)\n        {\n            printf(\"\\n\");\n        }\n    }\n//  0\n//  1  2  3  4  5\n//  6  7  8  9 10\n// ...\n// 96 97 98 99\n//可进行如下改进\n    for(int i=0;i<100;++i)\n    {\n        printf(\"%3d\",i);\n        if((i+1)%5==0 &&　(i+1)!=100)\n        {\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n```\n\n![image-20210714155735069](../../images/C语言_210617/image-20210714155735069.png)\n\n```c\n//编程输出如上效果\n//主要思路：两层for循环，用取余思想\n#include<stdio.h>\nint main()\n{\n    const int n = 26;\n    for(int i=0;i<n;++i)\n    {\n        int k=i;\n        for(int j=0;j<n;++j)\n        {\n            printf(\"%d\",k);\n            k=(k+1)%n;//精髓所在\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n4. 求最大公约数的辗转相除法（欧几里得算法）：`gcd(a, b) = gcd(b, a mod b)`\n```c\n#include<stdio.h>\nint main()\n{\n    int a = 0, b = 0;\n    int i = 0;\n    scanf_s(\"%d %d\",&a,&b);\n//遍历算法\n//i = a < b ? a : b;\n//while(i>1)\n//{\n//    if(a%i==0&&b%i==0)\n//    {\n//        break;\n//    }\n//    --i;\n//}\n//printf(\"%d \\n\",i);\n//辗转相除法--35和25：35%25=10;25%10=5;10%5=0\n    while(b!=0)\n    {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    printf(\"%d \\n\",a);\n    return 0;\n}\n```\n\n### 取余和取模的区别\n\n对于整型数a，b来说，取模运算或者求余运算的方法都是求整数商\n1. `c = [a/b];`\n2. 计算模或者余数：`r = a - c * b`\n\n求模运算和求余运算在**第一步不同**：取余运算在取商`c`的值时，向**0方向**舍入(`fix()`函数)；而取模运算在计算商`c`的值时，向**负无穷方向**舍入(`floor()`函数)。\n例如计算：`-7 Mod 4`。那么： `a = -7; b = 4;`\n第一步：求整数商`c`，如进行求模运算`c=-2`(向负无穷方向舍入)；求余`c = -1`(向0方向舍入);\n第二步：计算模和余数的公式相同，但因`c`的值不同，求模时`r = 1`，求余时`r = -3`。\n归纳：当`a`和`b`同号时，求模运算和求余运算所得的`c`的值一致，因此结果一致。当符号异号时，结果不—样。\n**另外各个环境下`%`运算符的含义不同，比如`c/c++`、java为取余，而python则为取模。**\n### `+=, *=`\n\n```c\nint a=3,b=5,c=7;\na *= b + c;\n//a = a * (b+c); //36\n```\n\n说明：别看`*=`里面虽然带乘号，但是它的优先级是很低的。\n### 前置`++`、后置`++`\n\n如果没有赋值语句，效果完全一样：先取`a`、`b`中原数到临时空间`eax`（cpu的内部寄存器），临时空间数据`+1`，再把加`1`后的数值更新到`a`、`b`中。\n![image-20210713184548788](../../images/C语言_210617/image-20210713184548788.png)\n如果有赋值语句。则后置++是先把值赋给c，再+1回写；而前置++是先更新变量值，再赋值到c。\n![image-20210713184644291](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713184644291.png)\n## 其他说明\n\n1. 对于C语言程序，`++i`和`i++`效率是一样的；\n2. 对于GoLang，只有`++i`，没有`i++`；\n3. 在面向对象语言中如`C++`、Java、Python，`++i`效率比较高，`i++`效率低。至于为何，在C++部分讲述。\n# 左值和右值\n\n按字面意思通俗地说。以赋值符号`=`为界，`=`左边的就是左值，`=`右边就是右值。\n更深一层，可以将`L-value`理解成可寻址。A value (computer science) that has an address；`R-value`表示可读。\n# 指针\n\n内存（在程序中称为主存DRAM）是计算机中重要的部件之一，它是外存（硬盘）与CPU进行沟通的桥梁。\n\n![image-20210714162919263](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714162919263.png)\n\n计算机中所有程序的运行都是在内存中进行，为了有效的使用内存，就**把内存以8位二进制（bit）划分为存储单元（也就是 1 字节）**。为了有效的访问到内存的每个存储单元，就给内存存储单元进行了编号，这些编号被称为该**内存存储单元的地址**。\n\n![image-20210714162932627](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714162932627.png)\n\n存储地址的变量称为指针变量。在C 语言中指针就是地址。\n## 打印地址的方式\n### `%x`\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a = 10;\n    printf(\"%x \\n\",&a);//输出了：93fcb4，原本总共是8位，前面的00舍去了\n    printf(\"%08x \\n\",&a);//输出了006ffbc4。%后面补上08，8代表宽度，0代表宽度不够的时候补0\n    printf(\"%08X \\n\",&a);//输出了：001AFDA8。x由小写改为大写，代表字母以大写形式输出。\n    printf(\"0X%08X \\n\",&a);//输出了：0X0113F944。%前加上了\"0X\"，完整、完美地表示了这是一个16进制数。\n    return 0;\n    \n}\n```\n### `%p`\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a = 10;\n    printf(\"%p \\n\",&a);//输出了：012FFBA4\n    printf(\"%#p \\n\",&a);//输出了：0X00AFF8BC，但在VS2019里不支持，VS2012中可以。\n    return 0;\n}\n```\n## 该死的星号`*`\n\n```c\nC/C++ *\n    int a = 10, b = 20;\n\tint c = a * b;\n\t\n\tint * p = &a;//*在此表达式中的作用只是声明、标识。a的地址给的是p而不是*p\n\t*p = 100;//与上面一句中的*作用不同，此处*的作用是指向、解引用。如果p是a的地址，那么*p就是a本身。\n```\n\n上述给了几个表达式。\n\n`a`、`b`、`c`、`p`都是变量。**变量最根本的区别在于：类型**。\n\n要彻底理解星号的不同用处，突破点在于对变量的类型的区分！\n\n`int * p = &a;`此处`*`在左侧的作用只是一个声明。**声明p是一个int类型的指针变量**。就是说，你只要是整型变量，那么我`p`就可以存放你的地址。此例，`a`的地址给的是`p`而不是`*p`。所以`p`和`a`、`b`、`c`不同之处在于，`p`是一个`int`型指针，`a`、`b`、`c`只是`int`型。因此`int p = &a;`这句话就是错误的：`&a`是一个指针，而`p`是`int`型，类型不匹配，无法存放。\n\n`*p = 100;`与`int * p = &a;`中的`*`作用不同，此处`*`的作用是指向、解引用。也就是说，**如果p是a的地址，那么`*p`就是`a`本身**。此处不要拿“间接访问”来解释，在语法上没有这回事。\n## 指针的两个值\n\n![image-20210714170927750](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714170927750.png)\n\n比如：`int a = 10;` `int* p = &a;`\n\n一个是本身的值，即本身存储的值，即本身存储的某个地址值。即`0x0055f864`。此值说明了其指向谁。即`&a`。\n\n另一个是本身存储的地址值的真实内容值，即`a`。\n\n虽然`p`是一个指针，但它也是一个变量，所以他也有自己的地址，即`0x0055f84c`。\n## 逻辑名称与物理地址\n\n比如：我要到邢同学的宿舍去，邢同学的宿舍就是逻辑名称，而12公寓328是其物理地址。那么，邢同学的宿舍和12公寓328实际上就是同一空间。\n## 对应到内存条上\n\n![image-20210714171543412](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714171543412.png)\n\n> 可以拓展的知识点：小端存放与大端存放\n\n## 指针类型的sizeof\n\n32位机的指针一概都是4；64位机的指针一概都是8！\n\n因为**不管你是char类型、短整型、整型的变量的地址，都只是存放首地址**，对于64位机，某一类型的首地址就占用64位bit位，8个字节才能存放；同理，对于32位机，某一类型的首地址就占用32位bit位，4个字节才能存放。\n\n## 指针的类型\n\n### 野指针\n\n```c\n#include<stdio.h>\nint main()\n{\n    int a;\n    int* p;\n}\n```\n\n就像a未初始化，不清楚其值是多少一样。未初始化的p也不知道其指向的是哪个地址。此类指针叫做野指针。\n### 空指针\n\n```c\n#include<stdio.h>\nint main()\n{\n    int* p=NULL;//此处将用0代替NULL赋值\n    int* s=nullptr;//此处将用(void*)0代替nullptr赋值\n}\n```\n\n![image-20210714234134586](../../images/C语言_210617/image-20210714234134586.png)\n### 失效指针\n\n### [代码示例](#代码示例_生存期)\n\n```c\n#include<stdio.h>\nint * fun()\n{\n    int ar[10]={12,23,34,45,56,67,78,89,90,100};\n    int* p=&ar[0];\n    return p;\n}\nint main()\n{\n    inr* ip=fun();\n    for(int i=0;i<10;++i)\n    {\n        printf(\"%d\",*ip);\n        ip=ip+1;\n    }\n}\n```\n\n[运行结果](#运行结果_生存期)\n## NULL与nullptr\n\n实际上还是有一些小的区别。\n\n```c\nint* p = NULL;//此处将用0代替NULL赋值\nint* s = nullptr;//此处将用(void*)0代替nullptr赋值\n```\n\n# 结构体\n\n程序开发人员可以使用结构体来封装一些属性，根据原有的类型，设计出新的类型，在C语言中称为结构体类型。\n在C语言中，结构体是一种数据类型。\n## [C语言中的类型](#基本数据类型)\n\n`char; short; int; long int; long long; float; double; long double; bool;`都是**基本类型**。\n\n`char*; short*;`这种指针类型和`int ar[10]; br[20];`这种数组类型都叫做**结构类型**。\n## 结构体的使用\n\n```c\n#include<stdio.h>\nstruct Student\n{\n    char s_id[10];//学号\n    char s_name[10];//姓名\n    char s_sex[5];//性别\n    int s_age;//年龄\n};\nint main()\n{\n    //定义结构体变量并初始化\n    struct Student stud={\"202001\",\"tulun\",\"man\",15};\n    //sizeof(stud)?\n    //使用.（成员选择(对象)运算符）访问结构体变量的成员\n    printf(\"id: %s \\n\",stud.s_id);\n    printf(\"name: %s \\n\",stud.s_name);\n    printf(\"sex: %s \\n\",stud.s_sex);\n    printf(\"age: %d \\n\",stud.s_age);\n    return 0;\n}\n```\n\n## 结构体的访问形式\n\n```c\nStudent  sx = {...};\nStudent* sp = &sx;\n\n形式一：(*sx).s_id = 202001;//注意，*（取值运算符）优先级低于.（成员选择(对象)运算符），使用必须给*sx加上括号，否则sx直接先和.结合，导致错误。\n形式二：sp->s_id   = 202001;//成员选择(对象指针)运算符\n```\n\n> 掌握如何计算结构体的sizeof。\n# 文件\n\n## 数据流\n\n指程序与数据的交互是以流的形式进行的。进行C语言文件的存取时，都会先进行“打开文件”操作，这个操作就是在打开数据流，而“关闭文件”操作就是关闭数据流。\n## 缓冲区（Buffer）\n\n指在程序执行时，所提供的一块存储空间（在内存中），可用来暂时存放做准备执行的数据。它的设置是为了提高存取效率，因为内存的存取速度比磁盘驱动器快得多。\n\nC语言的文件处理功能依据系统是否设置“缓冲区”分为两种：一种是设置缓冲区，另一种是不设置缓冲区。由于不设置缓冲区的文件处理方式，必须使用较低级别的 I/O 函数(包含在头文件`io.h`和`fcntl.h`中)来直接对磁盘存取，这种方式的存取速度慢，并且由于不是C的标准函数，跨平台操作时容易出问题。下面只介绍第一种处理方式，即设置缓冲区的文件处理方式。\n\n当使用标准I/O函数（包含在头文件`stdio.h`中）时，系统会自动设置缓冲区，并通过数据流来读写文件。当进行文件读取时，不会直接对磁盘进行读取，而是先打开数据流，将磁盘上的文件信息拷贝到缓冲区内，然后程序再从缓冲区中读取所需数据，如下图所示：\n\n![image-20210713225323314](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713225323314.png)\n\n## 文件类型\n\n分为文本文件和二进制文件两种。\n\n文本文件是以字符编码的方式进行保存的。二进制文件将内存中数据原封不至文件中，适用于非字符为主的数据。\n\n如果以记事本打开，只会看到一堆乱码。\n\n其实，除了文本文件外，所有的数据都可以算是二进制文件。二进制文件的优点在于存取速度快，占用空间小，以及可随机存取数据。\n\n## 文件存取方式\n\n包括顺序存取方式和随机存取方式两种。\n\n顺序读取也就是从上往下，一笔一笔读取文件的内容。保存数据时，将数据附加在文件的末尾。这种存取方式常用于文本文件，而被存取的文件则称为顺序文件。\n\n随机存取方式多半以二进制文件为主。它会以一个完整的单位来进行数据的读取和写入，通常以结构为单位。\n\n## C语言提供的标准文件\n\n通常把显示器称为标准输出文件，`printf`就是向这个文件输出数据；\n\n通常把键盘称为标准输入文件，`scanf`就是从这个文件读取数据。\n\n![image-20210713225726024](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713225726024.png)\n# 关键字\n## const\n\nconst在实际编程中用得比较多，const是constant的缩写，意思是“恒定不变的”！它是定义**只读变量**的关键字，或者说 const 是定义常变量的关键字。（可读，不可写）\n\nconst可以修饰变量，数组，指针等；说const定义的是变量，但又相当于常量；说它定义的是常量，但又有变量的属性，所以叫常变量。\n\n用const定义常变量的方法很简单，就在通常定义变量时前面加 const 即可，如：`const int a = 10;`或`int const a = 10;`而且**可以修饰任何类型的变量**，包括数组。\n\n那么用const修饰后和未修饰前有什么区别呢？用const定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着**必须在定义的时候就给它赋初值**。无论是全局常变量还是局部常变量都必须初始化赋值。\n### 注意事项\n\n```c\n#include<stdio.h>\nint main()\n{\n    const int a = 10;\n    int* ip = &a;//这种写法是错误的，会产生二义性，因为这样写的意义何在？你的a到底能变还是不能变！\n    //有一种办法能让此语句成功编译，就是强转类型：int* ip = (int*)&a;但是强转类型会出乱子。详看下文《一家网络公司的某个试题》。\n    //还有一种办法能成立，就是把左式声明部分加上const来修饰，即const int* ip = &a;这样做：ip就可以指向a了，但不可以通过ip改变a。而且这样做会导致下面的语句\"*ip = 100\"报错：“表达式必须是可修改的左值”。因为ip指向的值是拿const修饰的，此处就识别为不可修改了！\n    *ip = 100;\n    return 0;\n}\n```\n\n总结：const不只能修饰普通类型、数组，还能修饰指针（比如修饰指针的其一种特性——**修饰指针的指向能力**，达到了保护的效果，就如`const int* ip = &a`，达到了通过ip只能读取a，不可写的效果）。以此类推，C语言还有：`int* const is;` `const int* const ir;`其中`const int* const ir;`的前一个指针是修饰指向不可改变，后一个const是修饰指针自身不可改变。\n### 一家网络公司的某个试题\n\n```c\n#include<stdio.h>\nint main()\n{\n    const int a = 10;\n    int b = 0;\n    int* ip = (int*)&a;\n    *ip = 100;\n    b = a;\n    printf(\"a = %d \\n\",a);\n    printf(\"b = %d \\n\",b);\n    printf(\"*ip => %d \\n\",*ip);\n    return 0;\n}\n```\n\n`*.cpp`文件的运行结果如下，此结果是比较符合const这个关键字的功能的。\n\n![image-20210715011105297](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715011105297.png)\n\n但是，此运行结果却和调试过程中的显示结果不一致！\n\n![image-20210715010757756](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715010757756.png)\n\n前九行运行是符合普通人（没有深刻理解const）的思路的，`a`通过指针`ip`被赋值`100`。但奇怪的是：第十行运行后`b=a;`这个语句居然是给`b`赋值了`10`。\n\n另外，c文件的输出结果却是：\n\n![image-20210715012709734](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715012709734.png)\n\n这又是怎么一回事？详见下面《解释》的论述。\n#### 解释\n##### cpp文件下的结果\n在`*.cpp`文件中，const变量和宏变量都是替换机制来实现的，但const是在编译时期替换的，宏变量是在预编译时期替换的。\n\n![image-20210715011908929](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715011908929.png)\n![image-20210715012233908](../../images/C语言_210617/image-20210715012233908.png)\n再来一段汇编代码，发现`a=b;`这条语句并不是把a取值给b，而是用`0Ah`（10的十六进制）直接赋给b。\n\n所以，无论输出前对a进行了哪些操作都是徒劳的，因为a早已“偷梁换柱”，所以就会出现了我们单步跟踪结果和最终输出结果不一致的情况。\n\n上例给我们一个启发，不要相信你的眼睛，而要相信你所分析的代码。\n##### C文件下的结果\n\nC文件下的结果居然又成了`a=100, b=100, *ip=100`。接下来我们来分析：\n![image-20210715012838790](../../images/C语言_210617/image-20210715012838790.png)\n对于`b=a;`这个语句，我们可以看出：不像cpp文件那样用`0Ah`直接赋值，而是先取a的值再赋给b。因为`*ip`改变了a的值，所以b的值也将受到影响。\n#### 总结\n对于被const关键字修饰的变量：在cpp文件下是编译时期用具体值替换变量名；而在c文件下，编译时期不替换。于是造成了输出结果的差异。\n#### 拓展--汇编与程序的联系\n**汇编层面下的赋值**（`b=a;`）\ncpu中包含着4个通用数据寄存器：叫做`eax`、`ebx`、`ecx`、`edx`。cpu在进行加减乘除、数据运算时不是在内存中运算的，而是把内存数据拉到寄存器中计算，因为内存的计算速度远比cpu计算速度慢。\n所以，就出现了为何`b=a;`在汇编语言层面上是取出a的值给eax再由eax赋值给b，而不是a直接赋值给b。\n![image-20210715014252117](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715014252117.png)\nDMA方式，也叫做I/O协处理器。当我们内存要移动大块数据时，如果要介入cpu的话太影响运行效率，所以我们大块数据交给DMA（协处理器）进行数据移动，从而把CPU资源腾出来用于计算，提高效率。\n**汇编层面下的解引用**（`*ip=100;`）\n![image-20210715014516247](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715014516247.png)\n首先把ip的值放入到寄存器eax中，那么eax的值就相当于a的地址，再往下，把`64h`（100的十六进制）给了`[eax]`。此时注意：`mov eax,10;`和`mov [eax],10;`这两种访问方式不一样。前者是直接访问方式，把10给了eax；后者是间接访问方式，不是把10给了eax，而是把10给了eax所存放的某个地址里。因此，直接访问是一步汇编实现，间接访问是两步汇编实现，所以直接访问效率要高于间接访问。\n## sizeof关键字\n已在上面章节论述。\n\n此处再引入几个有启发的例子。\n![image-20210714003229156](../../images/C语言_210617/image-20210714003229156.png)\n此题运行后的size还是4，a还是10！可从汇编角度观察究竟！\n![image-20210715021922182](../../images/C语言_210617/image-20210715021922182.png)\n启示：**sizeof只在编译时期计算**而不是运行时期计算，相当于直接替换为4。因此`++a`这个`++`的动作就失去了意义，编译时就直接略去了`++`这个操作。因此后面a的值没有变化。\n![image-20210714003659077](../../images/C语言_210617/image-20210714003659077.png)\n此程序运行后的size大小为8，即double类型所占用的空间。因为在编译时期sizeof就识别到了`(a+0.9)`这个数值为double类型。\n**sizeof的本质是只关心你此处的数值最终的类型**。\n### sizeof和strlen的差异\n![image-20210715021416730](../../images/C语言_210617/image-20210715021416730.png)\n实际结果为：len为6，size为7。因为字符串实际占用了7个字节。字符串的最后是要有`\\0`结尾的；而len的计算是：一碰到`\\0`就结束计算。\n## typedef\n\ntypedef是在计算机编程语言中用来为复杂的声明定义简单的别名。它本身是一种存储之类的关键字，与`auto`、`extern`、`mutable`、`static`、`register`等关键字不能出现在同一个表达式中。\n\n```c\n#include<stdio.h>\ntypedef unsigned char u_int8;\ntypedef unsigned short u_int16;\ntypedef unsigned int u_int32;\ntypedef unsigned long long u_int64;\nint main()\n{\n    u_int8 a;//等效于unsigned char a;\n    u_int64 x;//等效于unsigned long long x;\n    return 0;\n}\n```\n\n一定要记住：凡是合法的变量名声明、数据声明、指针声明，加一个typedef后我们就可以把变量名转换为类型名，把变量声明定义转换为类型声明定义。\n\n```c\nunsigned int UNIT;//原来的变量名声明\ntypedef unsigned int UNIT;//UNIT由一个全局变量转换成了一个类型！\nUNIT a;\n```\n\n```c\nint Array[10];\ntypedef int Array[10];//Array由全局变量转换成了一个“开辟10个空间的整型数组类型”\nArray ar,br,cr;\n```\n\n有人这么认为：认为typedef是用替换原则来实现的，如把`\"Array\"`替换为`\"int[10]\"`，即`Array ar, br, cr;`替换为`int[10] ar,br,cr;`，这是不对的。它是一种类型的**声明**概念。\n\n```c\nint* PINT;\ntypedef int* PINT;\nPINT p,s;//p,s是什么类型呢？回到typedef int* PINT;，把typedef去掉即可得知——p和s都是int*类型。\n```\n\n上例中，`PINT p,s;`和`int* x,y;`是有区别的！我们在编译器中发现，x是整型指针变量，而y是整型变量。因为声明时，我们的星号`*`要和标识符结合，而不是和类型名结合。所以当我们涉及到为多个指针声明时，用到typedef的方式就特别好。\n![image-20210715121438344](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715121438344.png)\n\n```c\nstruct ListNode\n{\n    int data;\n    ListNode* next;\n};\nListNode* LinkList;//原本是一个“某一结构体类型的指针变量”\ntypedef ListNode* LinkList;//由全局结构体指针变量转变为了一个类型\n//如此定义，那么以下两句就等效\nListNode* p;\nLinkList s;\n```\n\n```c\n//此时，LinkList原本是一个“全局结构体类型的指针变量”\nstruct ListNode\n{\n    int data;\n    ListNode* next;\n}*LinkList;\n//我们也加上一个typedef，现在，LinkList就不再是一个指针变量了，而是一个类型。\ntypedef struct ListNode\n{\n    int data;\n    ListNode* next;\n}*LinkList;\n//实际上，以上这种typedef直接在定义结构体时加在前面的写法和typedef ListNode* LinkList;这种写法也是等价的。\n```\n\n```c\n//再来一个奇怪的例子：\n//首先，我们知道，int int;是不可能这样声明定义变量名的。因为他拿关键字（基本数据类型名）来起名字。\n//但如果没拿关键字起名字的话，变量名和类型名可以一样吗？\nstruct ListNode\n{\n    int data;\n    ListNode* next;\n};\nListNode ListNode;//是可以编译通过的，最多就是警告。\n//答案是可以一样！因为此类型名、变量名并非关键字，只要符合标识符的命名规范，是没有任何影响的！\n\n//因此，下例的ListNode原本是一个“结构体类型的变量名”\nstruct ListNode\n{\n    int data;\n    ListNode* next;\n}ListNode;\n//如今我们在结构体定义前加一个typedef，他就可以变为了一个类型名！\ntypedef struct ListNode\n{\n    int data;\n    ListNode* next;\n}ListNode;\n//那么，\ntypedef ListNode ListNode;//就与之等效。\n//这种定义方式常常出现在开源项目中，迷惑调试器，追踪变量时搞混变量名和类型名。为的就是不让你看懂。\n```\n\n```c\n//如此，理解了typedef的含义。我们可以如下使用\ntypedef struct ListNode\n{\n    int data;\n    ListNode* next;\n}ListNode,*LinkList;\nint main()\n{\n    ListNode a;\n    LinkList p;\n    p = &a;\n    return 0;\n}\n```\n\n```c\n//也可用作对枚举类型的定义\ntypedef enum{OK = 0,ERROR = 1} Status;\n```\n## static\n### 修饰局部变量\n静态关键字对于局部变量来说是延长寿命的。也就是说，函数只有被调用时，局部变量才会被初始化，函数调用结束时会释放掉所有局部变量。如果我们给局部变量加上了static修饰，那么函数在第一次被调用时初始化了局部变量，即使调用结束后，局部变量也不会释放，即局部变量的寿命比函数要长。\n\n```c\n#include<stdio.h>\nvoid fun(int x)\n{\n    int a = x;\n    int b = 0;\n    ++a;++b;\n    printf(\"a : %d b = %d \\n\",a,b);\n    return;\n}\nint main()\n{\n    for(int i=10;i>0;--i)\n    {\n        fun(i);\n    }\n    return 0;\n    //将输出：\n    //11 1\n    //10 1\n    //9  1\n    //...\n    //2  1\n}\n```\n\n```c\n#include<stdio.h>\nvoid fun(int x)\n{\n    static int a = x;//这一步是定义a并对a初始化，只执行一次。\n    int b = 0;\n    ++a;++b;\n    printf(\"a : %d b = %d \\n\",a,b);\n    return;\n}\nint main()\n{\n    for(int i=10;i>0;--i)\n    {\n        fun(i);\n    }\n    return 0;\n    //将输出：\n    //11 1\n    //12 1\n    //13 1\n    //...\n    //20 1\n    //此输出结果说明，虽然fun(i)一直在给x传参赋值给a，但是实际上是无效的，因为声明定义语句已经在第一次调用fun函数进行了，“一劳永逸”了\n}\n```\n\n对于第二段代码：在函数被第一次调用时，我们创建a，并把它存放到数据区（data area）。函数结束后，a也不释放。第二次调用时，`static int a = x;`这一语句不再执行。这一步是定义a并对a初始化，只执行一次。但是写成`a = x;`就不一样了。`a = x;`是一句执行语句，在每次函数调用也还是要执行的！\n\n但，static修饰局部变量不改变其作用域。\n### 修饰全局变量\n\n而static修饰全局变量时，不改变其生存期，而改变其可见性（只能在当前cpp文件中可见，即使其他文件中的代码拿extern来修饰这个变量，同一工程的另外cpp文件也不可见）。\n## extern\n\nextern用在全局变量或函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。\n\n假如我们同一个工程下有两个cpp文件，其中有一cpp文件用到了另一个cpp文件的内容。从理论上讲，两个cpp文件各自编译后形成了各自的obj文件，之后链接到了一个exe文件下（这个exe文件就是以工程为单位生成的），理论上，`Test7_10`文件中的`g_max`和`fun()`可以自然地调用`yhp`文件中的变量、函数。编译是可以进行的，但是，生成是不通过的。\n\n![image-20210715124558882](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715124558882.png)\n\n![image-20210715125037821](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210715125037821.png)\n\n我们这时就需要在`Test7_10.cpp`中添加代码了：如下才能运行成功。\n![image-20210715125337615](../../images/C语言_210617/image-20210715125337615.png)\n如果在一个cpp文件中，我们不想让其他文件用extern来调用自己的内容，我们可以在这些内容前加上static修饰（需要是全局变量）。因为，在全局变量前加static会改变其可见性。（只能在当前cpp文件中可见，即使其他文件中的代码拿extern来修饰这个变量，同一工程的另外cpp文件也不可见）。\n\n而如果一个cpp文件已经拿static修饰了变量名，另一个cpp还用extern来引用的话，就会失败，这时出现了下面要论述的技术，也就是让这个引用失败的机制——名字粉碎技术。\n### 名字粉碎技术\n![image-20210714175813243](../../images/C语言_210617/image-20210714175813243.png)\n# VS2019的使用\n\n### 创建项目\n\n![image-20210712150544136](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150544136.png)\n\n![image-20210712150616048](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150616048.png)\n\n![image-20210712150647588](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150647588.png)\n\n![image-20210712150735990](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150735990.png)\n\n![image-20210712150755672](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150755672.png)\n\n![image-20210712150817409](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150817409.png)\n\n![image-20210712150827045](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210712150827045.png)\n## scanf的注意事项\n\nS2019中不再使用`scanf`，而是换为了`scanf_s`。\n输入数据时，要严格按照双引号内的格式来输入。\n### 为何要用`scanf_s`替换`scanf`？\n\nscanf不安全。比如我们定义了一个`int a = 10;` `char buff[8];`\n如果用`scanf(\"%s\",buff);`输入字符串超过8位时，比如输入`yhpingaaaaaaaa`，会把a中的信息“冲掉”。（仅限于`VC++ 6.0`这种比较古老的编译器中）\n最后用`printf(\"a=%x\",a);`查看a时，发现`a=61616161`。61是十六进制，转为十进制为97，表示字符`'a'`的ASCII码值。所以此处就体现出了scanf对内存的不安全性。\n而`scanf_s`则避免了这个问题，我们可以在输入时加一个参数：`scanf_s(\"%s\",buff,8);`限制输入字符串的长度。\n# 有启发意义的代码实验\n\n![image-20210713192127424](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210713192127424.png)\n\n![image-20210714143758025](../../images/C%E8%AF%AD%E8%A8%80_210617/image-20210714143758025.png)\n\n首先我们要清楚16进制与2进制之间的关系，才能清楚存储空间是如何存储数据的。**存储空间中对数据的存放是以十六进制形式存储的**，接下来是对此的举例解释：\n\n比如int占了4个字节，等于占了32个二进制位，而4个二进制位可以转换为1个16进制位，于是int存储的数据可以由`32/4=8位16进制位`来表示。比如我们`int i = 10;`那么在存储空间中就是`(0a 00 00 00)16`。十进制的10转换成了十六进制的a。\n\n接下来我们再来解释为何输出了`\"a=61616161\"`：\n\n函数中的变量是存放在栈区的，因为先定义了`a`，栈底开辟`a`的空间，`a`占用4个字节先存放数值`12`。而后，`char`类型的`buff[8]`数组占用`a`之上的`8`个字节；`scanf`输入`%s`时，不直接存放字符串，而是存放字符串的ASCII码值，比如字符`'a'`的ASCII码值是91，再转换为十六进制值`61`。在存放了一部分字符串`\"yhpingaa\"`之后，原本在内存中给`buff`数组存放的空间不足，剩下的`\"aaaaaa\"`就由上到下（小端存放方式--高位地址存高位数据，低位地址存低位数据）覆盖到了内存中给a变量开辟的存储空间的4个字节中去了，并且还有可能占用了a空间以外的未知内存资源中，因为`int a`只能存放4个字节即4个字符值，而剩余a的数目超过了4个。","categories":["C"]},{"title":"Blog_模板","url":"/Blog_模板/","content":"\n# Content\n\n![](../images/Blog_模板/image-20240719024203996.png)\n\n","categories":["C"]}]