<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/5/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/5/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Linux/Linux_rg%E6%A3%80%E7%B4%A2/">Linux_rg检索</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2025-08-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-10-21</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Linux/Linux_rg%E6%A3%80%E7%B4%A2/" data-flag-title="Linux_rg检索"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="介绍"   >
          <a href="#介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1>
      
<p>rg，全称ripgrep，文本搜索工具，有grep、Ack、Ag。rg全称RipGrep，是一个按行搜索工具，它根据提供的pattern递归地在指定的目录里搜索。由Rust写成，相较于同类工具的特点是快、省电。</p>
<ol>
<li>自动递归搜索</li>
<li>自动忽略.gitignore中的文件以及二进制文件</li>
<li>可以限制文件类型<br />
4. <code>rg -t py foo</code>限定python文件<br />
5. <code>rg -T js foo</code>排除js文件</li>
<li>支持各种文件编码（UTF-8、UTF-16、GBK）</li>
<li>支持搜索常见的压缩文件（gzip、xz、bzip2）</li>
<li>自动高亮匹配的结果</li>
</ol>
<blockquote>
<p>扩展：强中更有强中手，现在更有rg的加强版ripgrep-all，能搜索pdf, e-book, office documents, zip, tar.gz等</p>
</blockquote>

        <h1 id="小试牛刀"   >
          <a href="#小试牛刀" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#小试牛刀"></a> 小试牛刀</h1>
      
<p>以下面的文件为测试文件, 命名为a.txt</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">test1</span><br><span class="line">TEST2</span><br></pre></td></tr></table></div></figure>
<ol>
<li>基础搜索</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rg <span class="string">&#x27;test&#x27;</span> a.txt</span><br><span class="line">1:<span class="built_in">test</span></span><br><span class="line">9:test1</span><br></pre></td></tr></table></div></figure>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;test&#x27;</span> a.txt</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">test1</span><br></pre></td></tr></table></div></figure>
<p>可见，rg和grep的区别有一点在于rg还额外加了行号</p>
<ol start="2">
<li><code>-w</code>有word之意，表示搜索的字符串作为一个独立的单词时才能被匹配到。</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rg -w <span class="string">&#x27;test&#x27;</span> a.txt</span><br><span class="line">1:<span class="built_in">test</span></span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>使用<code>-i</code>选项，不区分大小写</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rg -i <span class="string">&#x27;test&#x27;</span> a.txt</span><br><span class="line">1:<span class="built_in">test</span></span><br><span class="line">9:test1</span><br><span class="line">10:TEST2</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li><code>-l</code>只打印有匹配信息的文件名字</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rg -l <span class="string">&#x27;test&#x27;</span> a.txt</span><br><span class="line">a.txt</span><br></pre></td></tr></table></div></figure>
<ol start="5">
<li><code>-C</code>输出匹配上下几行的内容</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rg -C 2 <span class="string">&#x27;c&#x27;</span> a.txt#意思是，输出<span class="string">&#x27;c&#x27;</span>所在这一行的上下两行信息</span><br><span class="line">2-a</span><br><span class="line">3-b</span><br><span class="line">4:c</span><br><span class="line">5-d</span><br><span class="line">6-e</span><br></pre></td></tr></table></div></figure>

        <h1 id="高级搜索"   >
          <a href="#高级搜索" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#高级搜索"></a> 高级搜索</h1>
      
<ol>
<li>使用<code>-e REGEX</code>来指定正则表达式</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rg -e <span class="string">&quot;*sql&quot;</span> -C2</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>默认rg会忽略<code>.gitignore</code>和隐藏文件，可以使用<code>-uu</code>来查询所有内容</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rg -uu <span class="string">&quot;word&quot;</span> .</span><br></pre></td></tr></table></div></figure>
<ol start="3">
<li>可以使用<code>-t type</code>来指定文件类型</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rg -t markdown <span class="string">&quot;mysql&quot;</span> . <span class="comment">#在md文件中查找&quot;mysql&quot;关键字</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="搜索文件"   >
          <a href="#搜索文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#搜索文件"></a> 搜索文件</h1>
      
<p>列出当前文件夹会进行查询的所有文件，该选项其实可以相当于<code>find . -type f</code>，查找当前目录所有文件。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rg --files .</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/">20250815面试快速复盘</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2025-08-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-18</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/" data-flag-title="20250815面试快速复盘"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="modern-cpp"   >
          <a href="#modern-cpp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#modern-cpp"></a> Modern Cpp</h1>
      
<ol>
<li>auto</li>
<li>范围for循环</li>
<li>函数对象、lambda</li>
<li>智能指针</li>
<li>右值引用</li>
</ol>

        <h2 id="lambda"   >
          <a href="#lambda" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lambda"></a> lambda</h2>
      
<p>按值捕获，在函数体内能变吗？<br />
按引用捕获，为什么能变？</p>

        <h1 id="oop的思想"   >
          <a href="#oop的思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oop的思想"></a> OOP的思想</h1>
      
<ol>
<li>封装，主要从控制访问权限切入</li>
<li>继承
<ol>
<li>隐藏</li>
<li>多重继承
<ol>
<li>菱形继承
<ol>
<li>虚继承</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>多态
<ol>
<li>重载（静多态）：名字相同，参数列表不同。返回值不参与。
<ol>
<li>编译期就确定了。</li>
<li>主要面向泛型编程。</li>
<li>可以通过重载、函数模板实现。</li>
</ol>
</li>
<li>重写（动多态）
<ol>
<li>虚函数（动态联编）</li>
<li>在构造函数中可以调用虚函数，但是没有多态性。</li>
</ol>
</li>
</ol>
</li>
</ol>

        <h2 id="四个类型转换"   >
          <a href="#四个类型转换" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#四个类型转换"></a> 四个类型转换</h2>
      

        <h1 id="智能指针"   >
          <a href="#智能指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h1>
      

        <h2 id="unique和裸指针性能比较"   >
          <a href="#unique和裸指针性能比较" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#unique和裸指针性能比较"></a> unique和裸指针性能比较</h2>
      
<p>如果未开启优化，unique性能确实比裸指针差。<br />
但是如果开启优化，比如release时，unique的反汇编代码，和裸指针一样，而且还是安全的。</p>
<p>unique_ptr性能确实比裸指针差。​​<br />
​​原因：​​ 编译器不会进行内联优化。每次 unique_ptr的构造、析构、移动赋值、<code>reset()</code>、<code>release()</code>操作，以及通过 <code>operator-&gt;</code>或 <code>operator*</code>访问成员/解引用，都会生成对相应成员函数的调用指令。<br />
​​代价：​​ 这些函数调用（即使是简单的）会引入额外的指令（压栈、跳转、弹栈等），增加了代码大小和执行时间。构造/析构可能涉及设置/清除内部指针和可能的自定义删除器状态。移动操作虽然不拷贝资源，但函数调用开销依然存在。<br />
裸指针优势：​​ 裸指针的操作（赋值、解引用、比较）通常直接对应一条或几条非常底层的 CPU 指令（如 mov, lea, cmp），几乎没有额外开销。</p>

        <h2 id="shared的实现原理"   >
          <a href="#shared的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#shared的实现原理"></a> shared的实现原理</h2>
      

        <h2 id="shared需要避免的问题"   >
          <a href="#shared需要避免的问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#shared需要避免的问题"></a> shared需要避免的问题</h2>
      
<p>循环引用。导致对象一直驻存在内存中，无法销毁，内存泄漏。</p>

        <h2 id="weak可以单独使用吗"   >
          <a href="#weak可以单独使用吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#weak可以单独使用吗"></a> weak可以单独使用吗</h2>
      
<p>不可以自己构造，而是通过shared赋值或构造。<br />
主要场景是配合shared使用。</p>

        <h2 id="weak可以直接解引用吗"   >
          <a href="#weak可以直接解引用吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#weak可以直接解引用吗"></a> weak可以直接解引用吗</h2>
      
<p>需要看强引用计数是否为0。<br />
需要调用<code>lock()</code>，返回一个强shared引用。<br />
weak怎么知道的？结构中，有一个控制块，存放了强引用和弱引用计数。</p>

        <h2 id="makeunique和makeshared"   >
          <a href="#makeunique和makeshared" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#makeunique和makeshared"></a> makeunique和makeshared</h2>
      
<p>没使用，则对象和控制块分开存放。<br />
如果使用，则在一起存放。</p>
<p>make的优点：空间局部性好。</p>
<p>什么时候该释放对象内存了？强引用技术为0就该释放了，对象在这时应该就算是失效了。但是如果弱引用计数不为0，那么make的对象就因为控制块未释放而不能释放。</p>
<p><strong>弱引用计数的维护：​</strong>​ 如果存在 <code>std::weak_ptr</code>，还需要维护额外的弱引用计数(<code>weak_count</code>)。当<strong>强引用计数归零时，只销毁对象</strong>；只有<strong>当弱引用计数也归零时，才释放控制块本身</strong>。</p>

        <h1 id="stl"   >
          <a href="#stl" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stl"></a> STL</h1>
      

        <h2 id="六大组件"   >
          <a href="#六大组件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#六大组件"></a> 六大组件</h2>
      
<ol>
<li>容器</li>
<li>迭代器</li>
<li>算法</li>
<li>仿函数</li>
<li>适配器</li>
<li>分配器</li>
</ol>

        <h2 id="容器"   >
          <a href="#容器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#容器"></a> 容器</h2>
      
<p>顺序型：Vector（向量）、List（）、Array<br />
关系型：map、set。unorderedmap、unorderedset。</p>

        <h3 id="set-map的底层"   >
          <a href="#set-map的底层" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#set-map的底层"></a> set、map的底层</h3>
      
<p>有序的，使用红黑树实现的</p>

        <h3 id="unorderedset-unorderedmap的底层"   >
          <a href="#unorderedset-unorderedmap的底层" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#unorderedset-unorderedmap的底层"></a> unorderedset、unorderedmap的底层</h3>
      
<p>哈希表实现。</p>

        <h3 id="如何解决哈希冲突"   >
          <a href="#如何解决哈希冲突" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何解决哈希冲突"></a> 如何解决哈希冲突</h3>
      
<p>哈希冲突是哈希表中无法避免的现象（多个不同键映射到同一个哈希槽位）。以下是解决哈希冲突的主要方法及其特点：</p>

        <h4 id="1-开放定址法-open-addressing"   >
          <a href="#1-开放定址法-open-addressing" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#1-开放定址法-open-addressing"></a> ​<strong>​1. 开放定址法 (Open Addressing)​</strong>​</h4>
      
<p>​<strong>​核心思想​</strong>​：当发生冲突时，在哈希表中​<strong>​寻找下一个空闲槽位​</strong>​存储数据</p>
<ul>
<li>​<strong>​常见探测方式​</strong>​：
<ul>
<li>​<strong>​线性探测 (Linear Probing)​</strong>​：<br />
冲突时顺序检查下一个槽位（<code>index = (hash(key) + i) % size</code>, <code>i=1,2,3...</code>）。<br />
<em>缺点：易产生“聚集效应”，降低查询效率。</em></li>
<li>​<strong>​二次探测 (Quadratic Probing)​</strong>​：<br />
按二次方跳跃探测（<code>index = (hash(key) + i²) % size</code>, <code>i=1,2,3...</code>）。<br />
<em>缺点：可能无法找到空闲槽位（即使存在）。</em></li>
<li>​<strong>​双重散列 (Double Hashing)​</strong>​：<br />
使用第二个哈希函数计算步长（<code>index = (hash1(key) + i * hash2(key)) % size</code>）。<br />
<em>优点：分布更均匀，是开放定址法中的最优方案。</em></li>
</ul>
</li>
<li>​<strong>​适用场景​</strong>​：数据量较小、内存紧凑的场景（如嵌入式系统）。</li>
</ul>

        <h4 id="2-链地址法-separate-chaining"   >
          <a href="#2-链地址法-separate-chaining" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2-链地址法-separate-chaining"></a> ​<strong>​2. 链地址法 (Separate Chaining)​</strong>​</h4>
      
<p>​<strong>​核心思想​</strong>​：将每个哈希槽位作为​<strong>​链表/树的头节点​</strong>​，冲突的键值对存储在同一槽位的链表中。</p>
<ul>
<li>​<strong>​实现方式​</strong>​：
<ul>
<li>冲突时，将新数据​<strong>​插入槽位对应的链表末尾​</strong>​。</li>
<li>查询时遍历链表查找目标键。</li>
</ul>
</li>
<li>​<strong>​优化方案​</strong>​：
<ul>
<li>​<strong>​链表转红黑树​</strong>​（如Java 8+的HashMap）：当链表长度超过阈值（如8）时，将链表转为红黑树，将查询效率从<code>O(n)</code>提升至<code>O(log n)</code>。</li>
</ul>
</li>
<li>​<strong>​优势​</strong>​：
<ul>
<li>处理冲突简单，无聚集问题。</li>
<li>支持高效动态扩容。</li>
</ul>
</li>
<li>​<strong>​工业应用​</strong>​：Java <code>HashMap</code>、Python <code>dict</code>、C++ <code>unordered_map</code>均采用此方案。</li>
</ul>

        <h4 id="3-公共溢出区法-overflow-area"   >
          <a href="#3-公共溢出区法-overflow-area" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#3-公共溢出区法-overflow-area"></a> ​<strong>​3. 公共溢出区法 (Overflow Area)​</strong>​</h4>
      
<p>​<strong>​核心思想​</strong>​：分配独立空间存储所有冲突数据</p>
<ul>
<li>哈希表分为​<strong>​主表​</strong>​和​<strong>​溢出区​</strong>​。</li>
<li>冲突时，将数据存入溢出区，主表对应槽位​<strong>​指向溢出区的链表​</strong>​。</li>
<li>​<strong>​适用场景​</strong>​：冲突率较低或数据量固定的场景（较少用）。</li>
</ul>

        <h4 id="4-再哈希法-rehashing"   >
          <a href="#4-再哈希法-rehashing" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#4-再哈希法-rehashing"></a> ​<strong>​4. 再哈希法 (Rehashing)​</strong>​</h4>
      
<ul>
<li>冲突时使用​<strong>​另一个哈希函数​</strong>​重新计算位置。</li>
<li>需要预置多个哈希函数（如<code>hash1(key)</code>, <code>hash2(key)</code>…）。</li>
<li>​<strong>​缺点​</strong>​：计算成本高，通常用于特殊场景（如布隆过滤器）。</li>
</ul>

        <h4 id="实际工程中的关键考量"   >
          <a href="#实际工程中的关键考量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实际工程中的关键考量"></a> ​<strong>​实际工程中的关键考量​</strong>​</h4>
      
<ol>
<li>​<strong>​负载因子 (Load Factor)​</strong>​<br />
定义：已存储键值对数 / 哈希表总槽位数。<br />
​<strong>​当负载因子超过阈值（如0.75）时触发扩容​</strong>​（如Java HashMap），避免冲突率急剧上升。</li>
<li>​<strong>​动态扩容 (Resizing)​</strong>​<br />
扩容步骤：
<ul>
<li>新建更大的哈希表（通常翻倍）。</li>
<li>将旧表数据​<strong>​重新哈希​</strong>​到新表。</li>
<li><em>均摊时间复杂度为O(1)</em>。</li>
</ul>
</li>
<li>​<strong>​哈希函数设计​</strong>​<br />
目标：尽可能均匀分布（雪崩效应）。<br />
常见算法：MurmurHash、CityHash（非加密场景）；SHA-256（安全场景）。</li>
</ol>

        <h4 id="选择指南"   >
          <a href="#选择指南" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#选择指南"></a> ​<strong>​选择指南​</strong>​</h4>
      
<div class="table-container"><table>
<thead>
<tr>
<th>​<strong>​方法​</strong>​</th>
<th>​<strong>​优势​</strong>​</th>
<th>​<strong>​劣势​</strong>​</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​链地址法​</strong>​</td>
<td>高效处理高冲突，易实现删除</td>
<td>指针占用额外内存，缓存不友好</td>
</tr>
<tr>
<td>​<strong>​开放定址法​</strong>​</td>
<td>内存紧凑，缓存友好</td>
<td>删除复杂，易聚集</td>
</tr>
<tr>
<td>​<strong>​公共溢出区​</strong>​</td>
<td>实现简单</td>
<td>溢出区过大时性能下降</td>
</tr>
</tbody>
</table></div>
<blockquote>
<p>📌 ​<strong>​工业实践建议​</strong>​：</p>
<ul>
<li>通用场景优先选择​<strong>​链地址法​</strong>​（如Java/Python内置实现）。</li>
<li>内存敏感场景（如嵌入式）考虑​<strong>​开放定址法​</strong>​。</li>
<li>务必通过​<strong>​负载因子控制扩容​</strong>​以维持<code>O(1)</code>操作复杂度。</li>
</ul>
</blockquote>

        <h1 id="c程序的编译链接过程"   >
          <a href="#c程序的编译链接过程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c程序的编译链接过程"></a> c程序的编译链接过程</h1>
      
<ol>
<li>预编译。
<ol>
<li>宏定义</li>
<li>代码开关</li>
<li>头文件</li>
</ol>
</li>
<li>编译。
<ol>
<li>生成汇编代码</li>
</ol>
</li>
<li>汇编
<ol>
<li>生成二进制的目标文件</li>
</ol>
</li>
<li>链接
<ol>
<li>生成可执行程序。</li>
</ol>
</li>
</ol>

        <h1 id="浮点数相等怎么判断"   >
          <a href="#浮点数相等怎么判断" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#浮点数相等怎么判断"></a> 浮点数相等怎么判断</h1>
      

        <h1 id="数据结构"   >
          <a href="#数据结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
      

        <h2 id="b树b代表balanced"   >
          <a href="#b树b代表balanced" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#b树b代表balanced"></a> B树（B代表Balanced）</h2>
      
<p>是一个搜索树，而且是平衡的。<br />
BST（Binary Search Tree，二叉搜索树）只有搜索性质，没有平衡性质。</p>
<p>搜索性能：m阶，指的是1个节点，最多有多少分支。N是数据规模：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>m</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_m N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p>

        <h2 id="红黑树的性质通过什么规范达到平衡"   >
          <a href="#红黑树的性质通过什么规范达到平衡" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#红黑树的性质通过什么规范达到平衡"></a> 红黑树的性质（通过什么规范达到平衡）</h2>
      
<ol>
<li>根节点是黑色。</li>
<li>如果左右孩子是NIL, 则把此孩子看作黑色节点; 实际上这个NIL节点是哨兵节点, 可看作一个公共叶子节点;</li>
<li>从每个叶子到根的所有路径上不能有两个连续的红色节点; 如此, 每个红色节点的两个子节点都是黑色。</li>
<li><strong>从任一节点到其每个叶子(可以包含NIL公共叶节点)的所有路径都包含相同数目的黑色节点</strong>。</li>
</ol>
<p>红黑树其实是2-3树的一个变形（不存在4型节点）。<br />
由于不存在4型节点，所以不能出现2个连续的红色节点。</p>
<p><img src="../../images/C%E8%AF%AD%E8%A8%80_%E6%A0%91/image-20250225072634225.png" alt="" /></p>
<p>红黑树最长支的长度 不超过 最短支的长度的2倍。虽然AVL树最大差1，但AVL树插入性能太慢。红黑树就很好地平衡了层数差异和性能。</p>
<p>二叉树的极端形式就是：一支最长、一支最短。<br />
根据<strong>从任一节点到其每个叶子(可以包含NIL公共叶节点)的所有路径都包含相同数目的黑色节点</strong>，只要黑色节点数一样，就算是红黑树。那么：<br />
左子树最长情况下是一红线一黑线交替穿插。右子树最短情况下是全黑。这种情况下，左右两支黑节点数一样，而左支和右支的高度差最大是2倍。</p>

        <h1 id="算法"   >
          <a href="#算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#算法"></a> 算法</h1>
      
<p>以动态规划和数据结构为主  基础题会出现如重载操作符  回文序列等问题<br />
贪心算法和洗牌算法大公司一般都会问<br />
Top k问题</p>

        <h2 id="排序算法"   >
          <a href="#排序算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2>
      
<ol>
<li>插入型：直接插入、希尔排序</li>
<li>选择型：选择排序、堆排序</li>
<li>比较型：冒泡排序、快速排序</li>
<li>归并排序</li>
</ol>

        <h2 id="快速排序的思想"   >
          <a href="#快速排序的思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#快速排序的思想"></a> 快速排序的思想</h2>
      

        <h3 id="怎么选基准值"   >
          <a href="#怎么选基准值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#怎么选基准值"></a> 怎么选基准值</h3>
      
<p>快速排序，越乱序，越快。越有序，越慢</p>
<ol>
<li>随机选，达到乱序的效果。</li>
<li>三位取中。尽量选到靠近中间的值。划分的两支比较均衡。</li>
</ol>

        <h3 id="怎么优化"   >
          <a href="#怎么优化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#怎么优化"></a> 怎么优化</h3>
      
<ol>
<li>规模小的时候，用直接插入排序</li>
<li>递归深度怎么控制。记录一个递归深度的变量，减到零的时候，就使用堆排序进行优化。
<ol>
<li>尾递归的消除</li>
<li>内省排序。</li>
</ol>
</li>
</ol>

        <h2 id="分治算法"   >
          <a href="#分治算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分治算法"></a> 分治算法</h2>
      

        <h2 id="动态规划"   >
          <a href="#动态规划" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
      

        <h3 id="动态规划的思想"   >
          <a href="#动态规划的思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#动态规划的思想"></a> 动态规划的思想</h3>
      
<p>状态重叠？</p>
<p>核心思想：以空间换时间。把原问题拆成几个重叠子问题。通过几个小问题去推导大问题的解。</p>

        <h1 id="操作系统"   >
          <a href="#操作系统" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1>
      

        <h2 id="进程和线程的区别"   >
          <a href="#进程和线程的区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程和线程的区别"></a> 进程和线程的区别</h2>
      
<ol>
<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 执行调度的单位。</li>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程不会涉及这些资源管理信息，而是共享进程的资源。</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程，页表切换开销是比较大的。</li>
</ol>

        <h2 id="进程的通信方式"   >
          <a href="#进程的通信方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程的通信方式"></a> 进程的通信方式</h2>
      
<ol>
<li>管道
<ol>
<li>匿名管道：<code>int pipe(int fd[2])</code>。
<ol>
<li>通信范围是存在父子关系的进程</li>
<li>返回时向传入的fd数组写入了两个描述符。这两个描述符同属一个进程。一个是写端，一个是读端。管道只能一端写入，另一端读出。</li>
<li>fork会复制描述符。为了避免fork后，父子进程读写混乱。父进程关闭读取的 <code>fd[0]</code>，只保留写入的 <code>fd[1]</code>；子进程关闭写入的 <code>fd[1]</code>，只保留读取的 <code>fd[0]</code>。</li>
<li>如果需要双向通信，则应该创建两个管道。</li>
</ol>
</li>
<li>命名管道，也被叫做 <code>FIFO</code>。因为数据是先进先出的传输方式
<ol>
<li>在不相关的进程间（非父子）也能相互通信</li>
<li>需要通过 <code>mkfifo</code> 命令来创建，并且指定管道名字<code>mkfifo myPipe</code></li>
<li>以文件的方式存在：<br />
<code>prw-r--r--. 1 root    root 0 Jul 17 02:45 myPipe</code></li>
<li>向这个文件写入数据时，另一端就可以读取。<br />
<code>echo &quot;hello&quot; &gt; myPipe</code></li>
<li>操作了后，命令就停在这了，因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</li>
</ol>
</li>
<li>效率低，管道不适合进程间频繁地交换数据</li>
</ol>
</li>
<li>消息队列
<ol>
<li>消息队列是保存在内核中的消息链表。存在用户态与内核态之间的数据拷贝开销</li>
</ol>
</li>
<li>共享内存
<ol>
<li>虚拟内存映射到同一块物理内存。</li>
<li>避免了拷贝内核的开销。</li>
</ol>
</li>
<li>信号量
<ol>
<li>同步控制共享内存。</li>
</ol>
</li>
<li>信号
<ol>
<li>异步通信机制。可以为信号定义一个信号处理函数，有信号时，执行回调。</li>
</ol>
</li>
<li>socket</li>
</ol>

        <h3 id="管道图示"   >
          <a href="#管道图示" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#管道图示"></a> 管道图示</h3>
      
<p>进程中pipe创建匿名管道并fork<br />
<img src="../../images/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/image-20250820092506190.png" alt="" /></p>
<p>命令行<code>A | B</code>的原理：Shell进程创建匿名管道，fork出两个子进程。<br />
<img src="../../images/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/image-20250820092600867.png" alt="" /></p>

        <h2 id="进程调度算法"   >
          <a href="#进程调度算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程调度算法"></a> 进程调度算法</h2>
      
<ol>
<li>FIFO（FCFS，First Come First Serve）</li>
<li>最短作业优先</li>
<li>高响应比。兼顾了FIFO和最短作业优先。
<ol>
<li>响应比指：(等待时间+需要执行时间) / 需要执行时间。如果等待时间过长，则优先执行。如果等待时间一致，则谁需要执行时间越短，谁优先</li>
</ol>
</li>
<li>时间片轮转
<ol>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ol>
</li>
<li>最高优先级调度算法
<ol>
<li>两种处理优先级高的方法：非抢占式和抢占式
<ol>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ol>
</li>
</ol>
</li>
<li>多级反馈队列调度算法
<ol>
<li>是「时间片轮转算法」和「最高优先级算法」的综合。</li>
<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短</li>
<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>
</ol>
</li>
</ol>
<p><img src="../../images/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/image-20250820074634077.png" alt="" /></p>

        <h2 id="乐观锁-悲观锁"   >
          <a href="#乐观锁-悲观锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#乐观锁-悲观锁"></a> 乐观锁、悲观锁？</h2>
      
<p>乐观锁是什么场景用。默认不会被改，即多读少写的场景。</p>

        <h2 id="死锁"   >
          <a href="#死锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2>
      

        <h3 id="产生死锁的条件"   >
          <a href="#产生死锁的条件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#产生死锁的条件"></a> 产生死锁的条件</h3>
      
<p>需要同时满足：</p>
<ol>
<li>互斥</li>
<li>持有并等待</li>
<li>不可抢占</li>
<li>环路等待</li>
</ol>

        <h3 id="如何避免死锁"   >
          <a href="#如何避免死锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何避免死锁"></a> 如何避免死锁</h3>
      
<p>银行家算法。</p>
<p>破除四个条件之一就行：<br />
主要是破除环路等待。</p>
<p>最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p>
<p>即，两个线程都先获取互斥锁 A，然后获取互斥锁 B。顺序一致。</p>

        <h3 id="如果发生死锁怎么判断死锁的位置"   >
          <a href="#如果发生死锁怎么判断死锁的位置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如果发生死锁怎么判断死锁的位置"></a> 如果发生死锁，怎么判断死锁的位置</h3>
      
<p>Linux 下的 C 程序，可以使用 <code>pstack</code> + <code>gdb</code> 工具来定位死锁问题</p>
<p>pstack 命令可以显示每个线程的栈跟踪信息（函数调用过程），<code>pstack &lt;pid&gt;</code> 就可以了。</p>
<p><img src="../../images/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/image-20250820073330063.png" alt="" /></p>
<p>但是，还不能够确认这两个线程是在互相等待对方的锁的释放，因为我们看不到它们是等在哪个锁对象，</p>
<p>可以使用 gdb 工具进一步确认（<code>gdb -p &lt;pid&gt;</code>）。<br />
<code>info thread</code>：打印线程信息。每个线程对应了一个LWP。<br />
<code>thread 2</code>：切换到指定线程<br />
<code>bt</code>：打印函数堆栈<br />
<code>frame 3</code>：打印某个函数帧的信息（函数代码）<br />
<code>p mutex_A</code>：打印互斥量的内容值。<code>__owner</code>标示了哪个线程（LWP）持有。</p>
<p><img src="../../images/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/image-20250820073440504.png" alt="" /></p>

        <h2 id="线程崩溃了进程会崩溃吗"   >
          <a href="#线程崩溃了进程会崩溃吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程崩溃了进程会崩溃吗"></a> 线程崩溃了，进程会崩溃吗？</h2>
      
<p>不管是子线程还是主线程崩溃，进程都会崩溃。<br />
比如，子线程非法访问无权限内存。</p>
<p>段错误。（segment fault）</p>

        <h2 id="内存泄漏如何排查"   >
          <a href="#内存泄漏如何排查" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存泄漏如何排查"></a> 内存泄漏如何排查？</h2>
      
<ol>
<li>静态分析工具​​（预防阶段）
<ol>
<li>编译器警告​​：开启 <code>-Wall -Wextra</code>（GCC/Clang）或 <code>/W4</code>（MSVC）</li>
<li>Clang-Tidy​​：使用 <code>clang-tidy -checks=*,-llvm* *.cpp</code> --检查代码模式</li>
<li>Cppcheck​​：运行 <code>cppcheck --enable=all --inconclusive</code></li>
</ol>
</li>
<li>动态分析（运行时检测）
<ol>
<li>Linux、Mac首选：Valgrind工具。</li>
<li>跨平台高效方案：AddressSanitizer (ASan)​​</li>
</ol>
</li>
</ol>
<p>也可以重载new、delete，用一个map存储创建、删除对象的记录：程序退出时检查 <code>allocMap</code>剩余项</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::map&lt;<span class="type">void</span>*, std::string&gt; allocMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    allocMap[ptr] = fmt::format(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, file, line);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    allocMap.<span class="built_in">erase</span>(ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new new(__FILE__, __LINE__)  <span class="comment">// 关键宏定义</span></span></span><br></pre></td></tr></table></div></figure>

        <h2 id="页面置换算法"   >
          <a href="#页面置换算法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2>
      
<ol>
<li>最佳页面置换算法。基本思路是，置换在「未来」最长时间不访问的页面。实际无法实现，意义是衡量算法的效率</li>
<li>FIFO：选择在内存驻留时间最长的页面淘汰。有Belady现象。即cache容量越大，缺页率越高。</li>
<li>LRU（Least Recently Used，近来最少使用）
<ol>
<li>选择最长时间没有被访问的页面淘汰。</li>
<li>近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。</li>
<li>可以用哈希表 + 双链表实现。哈希表存key，双链表是cache。
<ol>
<li>如果我们每次默认从链表头部添加元素，那么显然越靠头部的元素就是<strong>最近使用</strong>的，越靠尾部的元素就是<strong>最久未使用</strong>的</li>
<li>如果调用了一个cache中的页面，需要把它移动到头部。</li>
<li>为什么要用双链不用单链？
<ol>
<li>因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。</li>
</ol>
</li>
<li>为什么要在链表中同时存储 key，而不是只存储 val？
<ol>
<li>当缓存容量已满，我们不仅仅要删除尾部的元素，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键。</li>
</ol>
</li>
</ol>
</li>
<li>总的来说：使用 ​<strong>​哈希表 + 严格排序的双链表​</strong>​</li>
</ol>
</li>
<li>时钟页面置换算法
<ol>
<li>使用 <strong>​哈希表​</strong> + <strong>​循环链表</strong> + 表针，表针指向最老的页面</li>
<li>发生缺页中断时，算法首先检查表针指向的页面。
<ol>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止。</li>
</ol>
</li>
</ol>
</li>
<li>最不常用页面淘汰
<ol>
<li>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</li>
<li>实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面</li>
<li>要增加一个计数器来实现</li>
<li>如果要对这个计数器查找哪个页面访问次数最小，需要查找链表本身，如果链表长度很大，是非常耗时的，效率不高</li>
<li>还有个缺陷：LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面
<ol>
<li>解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</li>
</ol>
</li>
</ol>
</li>
</ol>

        <h3 id="lru图示"   >
          <a href="#lru图示" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lru图示"></a> LRU图示</h3>
      
<p><img src="../../images/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/image-20250820075643281.png" alt="" /></p>

        <h3 id="lru实现"   >
          <a href="#lru实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lru实现"></a> LRU实现</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k = <span class="number">0</span>, <span class="type">int</span> v = <span class="number">0</span>) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    Node* dummy; <span class="comment">// 哨兵节点</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; key_to_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个节点（抽出一本书）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        x-&gt;prev-&gt;next = x-&gt;next;</span><br><span class="line">        x-&gt;next-&gt;prev = x-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头添加一个节点（把一本书放到最上面）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(Node* x)</span> </span>&#123;</span><br><span class="line">        x-&gt;prev = dummy;</span><br><span class="line">        x-&gt;next = dummy-&gt;next;</span><br><span class="line">        x-&gt;prev-&gt;next = x;</span><br><span class="line">        x-&gt;next-&gt;prev = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 key 对应的节点，同时把该节点移到链表头部</span></span><br><span class="line">    <span class="function">Node* <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key_to_node.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_to_node.<span class="built_in">end</span>()) &#123; <span class="comment">// 没有这本书</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* node = it-&gt;second; <span class="comment">// 有这本书</span></span><br><span class="line">        <span class="built_in">remove</span>(node); <span class="comment">// 把这本书抽出来</span></span><br><span class="line">        <span class="built_in">push_front</span>(node); <span class="comment">// 放到最上面</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity</span>(capacity), <span class="built_in">dummy</span>(<span class="keyword">new</span> <span class="built_in">Node</span>()) &#123;</span><br><span class="line">        dummy-&gt;prev = dummy;</span><br><span class="line">        dummy-&gt;next = dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key); <span class="comment">// get_node 会把对应节点移到链表头部</span></span><br><span class="line">        <span class="keyword">return</span> node ? node-&gt;value : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* node = <span class="built_in">get_node</span>(key); <span class="comment">// get_node 会把对应节点移到链表头部</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123; <span class="comment">// 有这本书</span></span><br><span class="line">            node-&gt;value = value; <span class="comment">// 更新 value</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        key_to_node[key] = node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value); <span class="comment">// 新书</span></span><br><span class="line">        <span class="built_in">push_front</span>(node); <span class="comment">// 放到最上面</span></span><br><span class="line">        <span class="keyword">if</span> (key_to_node.<span class="built_in">size</span>() &gt; capacity) &#123; <span class="comment">// 书太多了</span></span><br><span class="line">            Node* back_node = dummy-&gt;prev;</span><br><span class="line">            key_to_node.<span class="built_in">erase</span>(back_node-&gt;key);</span><br><span class="line">            <span class="built_in">remove</span>(back_node); <span class="comment">// 去掉最后一本书</span></span><br><span class="line">            <span class="keyword">delete</span> back_node; <span class="comment">// 释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="clock图示"   >
          <a href="#clock图示" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#clock图示"></a> Clock图示</h3>
      
<p><img src="../../images/20250815%E9%9D%A2%E8%AF%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E7%9B%98/image-20250820085133517.png" alt="" /></p>

        <h1 id="网络"   >
          <a href="#网络" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#网络"></a> 网络</h1>
      

        <h2 id="io复用"   >
          <a href="#io复用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#io复用"></a> IO复用？</h2>
      

        <h2 id="输入网址显示网页都经历了什么过程"   >
          <a href="#输入网址显示网页都经历了什么过程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#输入网址显示网页都经历了什么过程"></a> 输入网址，显示网页，都经历了什么过程</h2>
      
<ol>
<li>域名解析 - DNS</li>
<li>协议对应端口。http是80端口，https是443端口。
<ol>
<li>https需要额外握手，确认证书</li>
<li>浏览器发送http请求。请求内容，是TCP报文的数据部分。</li>
</ol>
</li>
<li>两个IP + 端口，可以组成一个TCP连接。走传输层。</li>
<li>交给网络层。走路由器</li>
<li>再交给数据链路层。</li>
</ol>

        <h2 id="3次握手"   >
          <a href="#3次握手" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#3次握手"></a> 3次握手</h2>
      
<p>第3次可以携带数据。</p>

        <h2 id="4次挥手"   >
          <a href="#4次挥手" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#4次挥手"></a> 4次挥手</h2>
      

        <h2 id="ip协议分类"   >
          <a href="#ip协议分类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ip协议分类"></a> IP协议分类？</h2>
      
<p>忘了。五类。</p>

        <h2 id="多播地址-广播地址的区别"   >
          <a href="#多播地址-广播地址的区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#多播地址-广播地址的区别"></a> 多播地址、广播地址的区别？</h2>
      

        <h2 id="tcp和udp分片"   >
          <a href="#tcp和udp分片" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcp和udp分片"></a> TCP和UDP分片？</h2>
      
<p>根据MTU，TCP报文有标识位。在传输层本身就可以分片。<br />
但UDP没有分片标识位。如果UDP报文很大，用的是IP层报文提供的底层分片服务。<br />
但是，这可能会导致，一但一个IP包丢失，全部数据就会全丢弃，大大增加丢包概率。<br />
可以在应用层控制UDP传输的数据不要太大，达到一个分片的效果。这样，即使丢IP包，也只丢失了小部分数据，而不是一丢丢一串。</p>

        <h3 id="如果就是想传一个很大的udp数据包怎么办"   >
          <a href="#如果就是想传一个很大的udp数据包怎么办" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如果就是想传一个很大的udp数据包怎么办"></a> 如果就是想传一个很大的UDP数据包怎么办？</h3>
      
<p>如果要求UDP报文100%传达，需要模拟实现TCP功能或者QUIC协议。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/4/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/154/">154</a><a class="extend next" rel="next" href="/page/6/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">308</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>