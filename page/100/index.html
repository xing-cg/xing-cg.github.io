<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/100/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/100/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Cpp/Cpp_%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B_%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/">Cpp_原子类型_无锁队列</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-01</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Cpp/Cpp_%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B_%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" data-flag-title="Cpp_原子类型_无锁队列"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="线程安全问题"   >
          <a href="#线程安全问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程安全问题"></a> 线程安全问题</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">count++;</span><br><span class="line">count--;	<span class="comment">/* 是线程不安全的 */</span></span><br></pre></td></tr></table></div></figure>
<p>后置<code>++</code>有多个动作：</p>
<ol>
<li>取出count的值为tmp</li>
<li>计算<code>count + 1</code></li>
<li><code>count + 1</code>的结果赋给count</li>
<li>返回tmp</li>
</ol>
<p>对应于多条指令。</p>
<p>传统地解决，可以用加锁的方式</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>但是，互斥锁是比较耗费资源的，如果临界区的代码比较轻量级，那么传统mutex锁相对而言就比较小题大做了。</p>
<p>现在有新机制解决：指令级并发。</p>
<p>如果想让这么多动作在一条指令内做完的话，需要让处理器支持这样的操作，而不用锁机制，因此这种叫做无锁结构。</p>

        <h1 id="原子类型"   >
          <a href="#原子类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#原子类型"></a> 原子类型</h1>
      
<p>定义于<code>&lt;atomic&gt;</code><br />
原子类型，封装了一个值，保证其的访问不会导致数据竞争，并且可用于同步不同线程之间的内存访问。</p>

        <h2 id="atomic_flag"   >
          <a href="#atomic_flag" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic_flag"></a> <code>atomic_flag</code></h2>
      
<p>初始化可以赋值为<code>ATOMIC_FLAG_INIT</code>，意为无状态，对应false。</p>
<ol>
<li><code>test_and_set()</code>：置位为有状态，对应true，并返回调用之前的状态。这是一个原子操作，不会被其他线程干扰。</li>
<li><code>clear()</code>重置flag为无状态</li>
</ol>

        <h3 id="atomic_flag做自旋锁"   >
          <a href="#atomic_flag做自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic_flag做自旋锁"></a> <code>atomic_flag</code>做自旋锁</h3>
      
<p>以下就是一个用<code>atomic_flag</code>做忙等待的例子：</p>
<ol>
<li>初始flag为无状态</li>
<li>调用一次<code>test_and_set()</code>置位flag为有状态</li>
<li>while中一直调用<code>test_and_set()</code>，测试它的状态，直到为无状态时，退出循环，结束程序。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br><span class="line">    flag.<span class="built_in">test_and_set</span>();</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>给定一个<code>atomic_flag</code>，初始为无状态，同时启动10个线程，操作之前，调用<code>test_and_set</code>，如果测试为无状态，说明没有其他线程在操作，就可以进行操作。<br />
操作完毕后，<code>clear</code>重置flag为无状态。下一个线程就可以探测到无状态，开始它的操作。</p>
<p>此时，<code>atomic_flag</code>就相当于自旋锁的作用。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::atomic_flag lock_output = ATOMIC_FLAG_INIT;</span><br><span class="line">std::counting_semaphore&lt;<span class="number">10</span>&gt; sema&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">while</span> (lock_output.<span class="built_in">test_and_set</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread #&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// unlock</span></span><br><span class="line">    lock_output.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::jthread t[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i] = std::<span class="built_in">jthread</span>(&amp;worker, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sema.<span class="built_in">release</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread #1</span><br><span class="line">thread #5</span><br><span class="line">thread #4</span><br><span class="line">thread #7</span><br><span class="line">thread #2</span><br><span class="line">thread #10</span><br><span class="line">thread #6</span><br><span class="line">thread #3</span><br><span class="line">thread #9</span><br><span class="line">thread #8</span><br></pre></td></tr></table></div></figure>

        <h2 id="atomic"   >
          <a href="#atomic" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic"></a> atomic</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">atomic</span>;</span><br></pre></td></tr></table></div></figure>
<p>原子对象的主要特征是，从不同线程访问值不会导致数据竞争（即，这样做是明确定义的行为，访问顺序正确）。<br />
通常，对于所有其他对象，如果同时访问同一对象而导致数据争用，则该操作将被视为未定义行为。</p>
<p>原子对象能够通过<strong>指定不同的内存顺序</strong>来<strong>同步对其线程中其他非原子对象的访问</strong>。</p>

        <h1 id="relaxed-ordering的问题"   >
          <a href="#relaxed-ordering的问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#relaxed-ordering的问题"></a> Relaxed Ordering的问题</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// A</span></span><br><span class="line">x.<span class="built_in">store</span>(r1, std::memory_order_relaxed); <span class="comment">// B</span></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// C</span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed); <span class="comment">// D</span></span><br></pre></td></tr></table></div></figure>
<p>标记为 <code>memory_order_relaxed</code> 的原子操作不是同步操作。它们不会在并发内存访问中强加顺序，它们只保证原子性和修改顺序的一致性。<br />
例如，x 和 y 初始为零。<br />
以上程序就会允许产生 <code>r1 == r2 == 42</code>，在线程 1 内，A 在 B 之前被排序，并且在线程 2 内，C 在 D 之前被排序。<br />
但是没有什么可以阻止 D 在 A 之前 修改了 y，并且 B 在 C 之前 修改 x 。<br />
D 对 y 的副作用对于线程 1 中的 load A 是可见的，B 对 x 的副作用对于线程 2 中的 load C 是可见的。</p>
<p>特别是，如果在线程 2 中 D 在 C 之前完成，这可能会发生，这可能是在运行时发生的，或者由于编译器重新排序导致的。</p>
<blockquote>
<p>实际上，A、B是不能调换的，因为编译器会看到，同在线程1中，B中的 <code>r1</code> 的值依赖于上一句的A对 <code>r1</code> 的操作。<br />
而C、D之间就没有依赖了，因为 D 操作的是 <code>42</code>，是个常量。<br />
所以，经过线程并发、内存重排，可能的执行顺序有：<br />
A B C D  此时 x、y、r1、r2的值：0、0、0、42<br />
A B D C  此时 x、y、r1、r2的值：0、42、0、0<br />
A C D B  此时 x、y、r1、r2的值：0、42、0、0<br />
A D C B  此时 x、y、r1、r2的值：0、42、0、0<br />
C A D B  此时 x、y、r1、r2的值：0、42、0、0<br />
<strong>D A C B</strong>  此时 x、y、r1、r2的值：<strong>42、42、42、42</strong>  =&gt; 这时便出现了<code>r1 == r2 == 42</code><br />
C D A B  此时 x、y、r1、r2的值：42、42、42、0<br />
D C A B  此时 x、y、r1、r2的值：0、42、42、0</p>
</blockquote>
<p>怎么解决呢？<br />
见下文</p>

        <h1 id="内存顺序"   >
          <a href="#内存顺序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存顺序"></a> 内存顺序</h1>
      
<p>原子操作只是提供了不同线程读写的同步。<br />
但是<strong>没有提供操作顺序的同步</strong>。</p>
<p>比如：线程1修改原子值a，线程2读取原子值a。</p>
<p>两个线程各自的读写操作，确实是保证了不会有脏值。<br />
但是线程1、线程2的顺序没有做控制，<br />
如果线程2想要读出旧值，但是线程1在线程2读值前进行写操作，还是会导致线程2读出脏值。</p>
<p>因此需要提供内存顺序机制。</p>
<p>下面举一个类似的例子，怎么通过原子变量+内存顺序控制，让consumer确保producer执行完毕后，再 load 出 b 的值。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order::relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order::release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// memory_order_acquire表示必须排序在x store、y store之后</span></span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">load</span>(std::memory_order::acquire))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">load</span>(std::memory_order::relaxed))</span><br><span class="line">        ++c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="literal">false</span>;</span><br><span class="line">    b = <span class="literal">false</span>;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono::literals;</span><br><span class="line">    <span class="function">std::jthread <span class="title">th2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::jthread <span class="title">th</span><span class="params">(producer)</span></span>;</span><br><span class="line"></span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    th<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<div class="table-container"><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>relaxed</td>
<td>CPU和编译器可以重新排序变量顺序。<br>这是一种松散的内存顺序，不保证不同线程中的内存访问对原子操作进行排序。</td>
</tr>
<tr>
<td>consume（废弃）</td>
<td>针对某个原子变量的访问指令（store）重排到此指令（load）前。<strong>即自己load排到针对某个变量的release操作后</strong>。（在<code>C++26</code>中被废弃了，推荐用acquire）</td>
</tr>
<tr>
<td>acquire</td>
<td>所有访问指令（store）排到此指令（load）前。<strong>即自己load排到所有release操作后</strong>。</td>
</tr>
<tr>
<td>release</td>
<td>所有访问指令（load）排到此指令（store）之后。即自己store排到所有consume、acquire操作之前。<br>扮演了一个同步点（synchronization point）的角色。</td>
</tr>
<tr>
<td>acq_rel</td>
<td>The operation loads acquiring and stores releasing。<br>该操作可能扮演两种角色。<br>比如<code>std::atomic::exchange</code>操作，两个变量交换：<br>需要load值，可能需要等待release；<br>需要store值，即产生release，需要给其他acquire、consume通知。</td>
</tr>
<tr>
<td>seq_cst</td>
<td>sequentially consistent，意思是该操作以顺序一致的方式排序。一旦所有可能对其他线程产生可见副作用的内存访问已经发生，则所有操作使用此内存顺序。<br>这是最严格的内存顺序，保证了在非原子内存访问中线程交互之间的意外副作用最小。<br>对于consume和acquire的load，顺序一致的store操作被认为是release操作。</td>
</tr>
</tbody>
</table></div>

        <h1 id="lock_free测试"   >
          <a href="#lock_free测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lock_free测试"></a> lock_free测试</h1>
      
<p>测试以确定原子模板包含的类型是否支持无锁。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;<span class="type">int</span>&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;<span class="type">int</span>&gt;&#123;&#125;.is_always_lock_free &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>经过测试后发现，不超过8字节（64位）的数据结构，并且没有虚函数表的数据结构，是支持无锁的。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;<span class="type">int</span> x, y; <span class="built_in">A</span>() &#123;&#125;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;<span class="type">int</span> a[<span class="number">2</span>];&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;<span class="type">int</span> a[<span class="number">3</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;A&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;B&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;C&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="无锁编程的原理"   >
          <a href="#无锁编程的原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无锁编程的原理"></a> 无锁编程的原理</h1>
      

        <h2 id="cascompare-and-swap"   >
          <a href="#cascompare-and-swap" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cascompare-and-swap"></a> CAS（Compare-And-Swap）</h2>
      
<p>CAS在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一模一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。（具有ABA问题：用版本号或时间戳解决）</p>
<p>现代CPU提供​<strong>​CAS（Compare-And-Swap）​</strong>​ 等原子指令，可在单个指令周期内完成类似以下的判断函数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CAS</span><span class="params">(T* ptr, T old_val, T new_val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*ptr == old_val)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr = new_val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>以上类似的操作，实际指令执行期间不会被中断，避免了数据竞争。</p>
<p>比如，用这个特性，实现一个自旋锁：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr;</span><br><span class="line">    *old_ptr = new;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当 flag 为 0 时，函数返回false，退出。加锁成功。flag被修改为 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;&#125; <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="内存顺序-2"   >
          <a href="#内存顺序-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存顺序-2"></a> 内存顺序</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">data = <span class="number">42</span>;                                       <span class="comment">// 1. 写数据</span></span><br><span class="line">flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);        <span class="comment">// 2. 释放屏障：保证 1 一定在 2 前完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) != <span class="number">1</span>)<span class="comment">// 3. 获取屏障：保证读到 flag = 1 时，才退出循环</span></span><br><span class="line">    ;                                            <span class="comment">//    一定能看到data=42</span></span><br><span class="line"><span class="built_in">read</span>(data);                                      <span class="comment">// 4. 安全读取数据</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="无锁数据结构的实现模式"   >
          <a href="#无锁数据结构的实现模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无锁数据结构的实现模式"></a> 无锁数据结构的实现模式</h1>
      

        <h2 id="读-修改-写循环read-modify-write-loop"   >
          <a href="#读-修改-写循环read-modify-write-loop" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#读-修改-写循环read-modify-write-loop"></a> ”读-修改-写“循环（Read-Modify-Write Loop）</h2>
      
<p>这是实现无锁的关键思维之一：<strong>乐观并发控制</strong>：<strong>先执行操作，提交前，验证数据（tail）未被修改，如果未被修改，再提交</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CAS</span><span class="params">(Node* old_ptr, Node* new_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == old_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span> = new_ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">    Node* old_tail;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        old_tail = tail.<span class="built_in">load</span>();              <span class="comment">// 读</span></span><br><span class="line">        new_node-&gt;next = old_tail;           <span class="comment">// 修改</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">CAS</span>(old_tail, new_node)); <span class="comment">// 把 tail 改为 new_node（失败则重试）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="帮助机制helping-mechanism"   >
          <a href="#帮助机制helping-mechanism" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#帮助机制helping-mechanism"></a> 帮助机制（Helping Mechanism）​</h2>
      
<p>当线程A发现线程B的操作未完成时，主动协助推进（如无锁队列中帮其他线程移动tail指针）。</p>

        <h2 id="分离并发关注点如头尾指针分离"   >
          <a href="#分离并发关注点如头尾指针分离" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分离并发关注点如头尾指针分离"></a> ​​分离并发关注点（如头尾指针分离）​</h2>
      
<p>将数据结构拆分为多个可独立更新的部分，减少竞争点。</p>
<p>这是实现无锁的关键思维之二：​<strong>​局部性原理（Locality Principle）</strong>：通过数据分片（如分槽队列）减少缓存行冲突：<br />
对齐64位。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) PaddedAtomic</span><br><span class="line">&#123; </span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; count;  <span class="comment">// 独占缓存行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="aba问题乐观锁问题"   >
          <a href="#aba问题乐观锁问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#aba问题乐观锁问题"></a> ABA问题（乐观锁问题）</h1>
      
<p>乐观锁会出现这种问题。</p>
<p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突（一般实现方式是通过加版本号然后进行版本号的对比方式实现）</p>
<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁。而是通过业务实现锁的功能。<br />
不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程。<br />
这种方式节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能。<br />
不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源。<br />
所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>

        <h2 id="问题场景"   >
          <a href="#问题场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题场景"></a> 问题场景</h2>
      
<p>比如说线程一从数据库中取出库存数 3，这时候线程二也从数据库中取出库存数 3。<br />
<strong>线程二进行了一些操作变成了 2</strong>。<strong>但是然后线程二在线程一拿到操作权之前，又将库存数变成了 3</strong>。<br />
这时候：线程一进行 CAS 操作发现数据库中仍然是 3，然后线程一操作成功。<br />
尽管线程一的 CAS 操作成功，但是不代表这个过程就是没有问题的。</p>

        <h2 id="解决方案"   >
          <a href="#解决方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2>
      
<p>使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是脏数据，需要处理。</p>
<p>使用带版本号的指针：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VersionedPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* ptr;</span><br><span class="line">    <span class="type">uint64_t</span> version;  <span class="comment">// 每次修改+1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="内存回收挑战"   >
          <a href="#内存回收挑战" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存回收挑战"></a> 内存回收挑战</h1>
      
<div class="table-container"><table>
<thead>
<tr>
<th>方法</th>
<th>原理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hazard Pointers</td>
<td>线程本地记录&quot;危险指针&quot;（有的也叫风险指针），延迟删除其他线程可能访问的内存</td>
<td>Linux内核常用</td>
</tr>
<tr>
<td>Epoch-Based Reclaim</td>
<td>将内存标记为待回收，当所有线程都不持有旧epoch时才删除</td>
<td>NVIDIA库常用</td>
</tr>
<tr>
<td>RCU（Read-Copy-Update）</td>
<td>读操作无同步，写操作创建副本延迟回收</td>
<td>Linux内核链表</td>
</tr>
</tbody>
</table></div>

        <h1 id="mpmc无锁队列"   >
          <a href="#mpmc无锁队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mpmc无锁队列"></a> MPMC无锁队列</h1>
      

        <h2 id="node的设计伪共享预防-aba问题解决"   >
          <a href="#node的设计伪共享预防-aba问题解决" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#node的设计伪共享预防-aba问题解决"></a> Node的设计（伪共享预防、ABA问题解决）</h2>
      
<ul>
<li>​<strong>​伪共享预防​</strong>​：<code>alignas(64)</code>和填充确保 头尾 在不同缓存行</li>
<li><strong>ABA问题防护​</strong>​：通过<code>version</code>版本号区分指针复用</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T* data;  <span class="comment">// 数据指针（避免拷贝开销）</span></span><br><span class="line">    std::atomic&lt;Node*&gt; next; <span class="comment">// 原子指针</span></span><br><span class="line">    <span class="comment">// 防止伪共享</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(T*) - <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VersionedPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* ptr;</span><br><span class="line">    <span class="type">uint64_t</span> version;  <span class="comment">// ABA防护</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeMPMCQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 节点结构：带缓存行填充防止伪共享</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        T* data;  <span class="comment">// 存储实际数据指针（避免对象拷贝开销）</span></span><br><span class="line">        std::atomic&lt;Node*&gt; next;  <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="comment">// 确保每个节点独占缓存行（64字节）</span></span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(T*) - <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;)];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带版本号的指针（解决ABA问题）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) VersionedPtr</span><br><span class="line">    &#123;</span><br><span class="line">        Node* ptr;</span><br><span class="line">        <span class="type">uint64_t</span> version;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证头尾指针不在同一缓存行</span></span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; head;</span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span>];  <span class="comment">// 填充确保tail在下一个缓存行</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="队列初始化哨兵dummy头节点"   >
          <a href="#队列初始化哨兵dummy头节点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#队列初始化哨兵dummy头节点"></a> 队列初始化（哨兵dummy头节点）</h2>
      
<p><strong>作用​</strong>​：保证非空队列始终存在头节点，避免头尾指针竞态</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockFreeMPMCQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化哑元节点（dummy node）</span></span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 头尾指针指向同一个节点</span></span><br><span class="line">        VersionedPtr init = &#123;dummy, <span class="number">0</span>&#125;;</span><br><span class="line">        head.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">        tail.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="入队操作"   >
          <a href="#入队操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#入队操作"></a> 入队操作</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 入队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建新节点并填充数据</span></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            new_node-&gt;data = <span class="keyword">new</span> <span class="built_in">T</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> new_node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. CAS循环：找到真正的尾节点</span></span><br><span class="line">        VersionedPtr current_tail;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 原子获取当前尾指针</span></span><br><span class="line">            <span class="comment">// current_tail是std::atomic&lt;VersionedPtr&gt;类型的</span></span><br><span class="line">            <span class="comment">// 还要取出其成员 ptr。是 Node* 类型</span></span><br><span class="line">            current_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_tail = current_tail.ptr;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 定义新的 Node * next，先让它指向尾节点的 next</span></span><br><span class="line">            Node* next = (real_tail-&gt;next).<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查期间尾指针是否变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_tail.ptr != tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr)</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 发生变化则循环重试</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 情况A：尾节点后是空位置（理想情况）</span></span><br><span class="line">                VersionedPtr new_ptr&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="comment">// 尝试将新节点链接到尾节点后面</span></span><br><span class="line">                <span class="comment">// 关键CAS：</span></span><br><span class="line">                    <span class="comment">// 如果成功，则 原子更新尾节点的 next 指针，即尾节点的 next 指向 new_node</span></span><br><span class="line">                    <span class="comment">// 如果失败，则 real_tail-&gt;next 的值 写入到 next 中（详见函数的作用）</span></span><br><span class="line">                    <span class="comment">// 总之不会阻塞。</span></span><br><span class="line">                <span class="keyword">if</span> (real_tail-&gt;next.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">                    next, new_node, </span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 链接成功，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 情况B：发现尾指针滞后，帮助其它线程推进</span></span><br><span class="line">                <span class="comment">// 意思就是说，现在的 next 不是 null，说明这是一个其他人入队创建的节点</span></span><br><span class="line">                VersionedPtr other_ptr&#123;next, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试更新尾指针到后继节点（避免竞争导致的阻塞）</span></span><br><span class="line">                <span class="comment">// 即，把队列的 tail 改为 other_ptr</span></span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_tail, other_ptr,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 尝试更新全局尾指针（允许失败，因为有可能有人帮忙推进了）</span></span><br><span class="line">        <span class="comment">// 即，把队列的 tail 改为 new_tail</span></span><br><span class="line">        VersionedPtr new_tail&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">        tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            current_tail, new_tail,</span><br><span class="line">            std::memory_order_release,</span><br><span class="line">            std::memory_order_relaxed);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="compare_exchange_weak和strong"   >
          <a href="#compare_exchange_weak和strong" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#compare_exchange_weak和strong"></a> <code>compare_exchange_weak</code>和strong</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                             std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                             std::memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>两个函数都是：<br />
Atomically compares the <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/objects.html"  title="cpp/language/object">value representation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (since C++20) of <code>*this</code> with that of expected. If those are bitwise-equal, replaces the former with desired (performs read-modify-write operation). Otherwise, loads the actual value stored in <code>*this</code> into expected (performs load operation).<br />
比较<code>*this</code>和<code>expected</code>的值，若相等，则把<code>*this</code>替换为<code>desired</code>（执行<code>read-modify-write operation</code>，即：读-修改-写），返回真。否则，把<code>*this</code>实际的值，存到<code>expected</code>中（执行<code>load operation</code>），返回假。</p>
<p>参数：<br />
<code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>都在后面有两个内存顺序的参数，第一个内存顺序指的是，成功时，做<code>read‑modify‑write operation</code>的内存顺序；第二个内存顺序指的是，失败时，做<code>load operation</code>的内存顺序。</p>
<p>与 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://legacy.cplusplus.com/atomic_compare_exchange_strong" >compare_exchange_strong</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 不同的是，这个弱版本允许通过返回 <code>false</code>来虚假地失败，即使<code>*expected</code> 确实与 obj 中包含的值相等。<br />
对于某些循环算法来说，这可能是可接受的行为，并且可能在某些平台上导致显著更好的性能。<br />
对于这些虚假的失败，函数返回<code>false</code>，但不修改预期。</p>

        <h2 id="出队操作"   >
          <a href="#出队操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#出队操作"></a> 出队操作</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 出队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VersionedPtr current_head;</span><br><span class="line">        Node* real_tail;</span><br><span class="line">        Node* next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 原子获取头尾指针（关键）</span></span><br><span class="line">            current_head = head.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_head = current_head.ptr;</span><br><span class="line">            </span><br><span class="line">            real_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr;</span><br><span class="line">            </span><br><span class="line">            next = (real_head-&gt;next).<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一致性检查：防止读取过程中数据结构变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_head.ptr != head.<span class="built_in">load</span>(std::memory_order_acquire).ptr)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 2. 队列状态判断</span></span><br><span class="line">            <span class="keyword">if</span> (real_head == real_tail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 情况A：队列为空</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况B：尾指针滞后，帮助推进</span></span><br><span class="line">                VersionedPtr new_tail&#123;next, tail.<span class="built_in">load</span>().version + <span class="number">1</span>&#125;;</span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    tail.<span class="built_in">load</span>(), new_tail,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 情况C：正常出队</span></span><br><span class="line">                <span class="comment">// 移动数据前预先加载（减少持有锁时间）</span></span><br><span class="line">                <span class="comment">// 注意，我们是有哑元节点的，现在获取到的head不是真实的head，而是dummy</span></span><br><span class="line">                <span class="comment">// dummy的下一个才是真实有数据的head，因此在这里取next的data</span></span><br><span class="line">                T* data_ptr = next-&gt;data;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试移动头指针</span></span><br><span class="line">                VersionedPtr new_head&#123;next, current_head.version + <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_head, new_head,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 出队成功：转移数据</span></span><br><span class="line">                    result = std::<span class="built_in">move</span>(*data_ptr);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 安全删除旧头节点（工业实现需延迟回收）</span></span><br><span class="line">                    <span class="keyword">delete</span> data_ptr;</span><br><span class="line">                    <span class="keyword">delete</span> real_head;  <span class="comment">// 实际应使用危险指针回收</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="析构"   >
          <a href="#析构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#析构"></a> 析构</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    ~<span class="built_in">LockFreeMPMCQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历删除所有节点（实际应用中需处理并发安全）</span></span><br><span class="line">        <span class="keyword">while</span> (Node* node = head.<span class="built_in">load</span>().ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            head.<span class="built_in">store</span>(&#123;node-&gt;next, <span class="number">0</span>&#125;, std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">delete</span> node-&gt;data;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="完整代码"   >
          <a href="#完整代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeMPMCQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 节点结构：带缓存行填充防止伪共享</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        T* data;  <span class="comment">// 存储实际数据指针（避免对象拷贝开销）</span></span><br><span class="line">        std::atomic&lt;Node*&gt; next;  <span class="comment">// 下一个节点指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保每个节点独占缓存行（64字节）</span></span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(T*) - <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;)];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带版本号的指针（解决ABA问题）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) VersionedPtr &#123;</span><br><span class="line">        Node* ptr;</span><br><span class="line">        <span class="type">uint64_t</span> version;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证头尾指针不在同一缓存行</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; head;</span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span>];  <span class="comment">// 填充确保tail在下一个缓存行</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockFreeMPMCQueue</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化哑元节点（dummy node）</span></span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 头尾指针指向同一个节点</span></span><br><span class="line">        VersionedPtr init = &#123;dummy, <span class="number">0</span>&#125;;</span><br><span class="line">        head.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">        tail.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LockFreeMPMCQueue</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历删除所有节点（实际应用中需处理并发安全）</span></span><br><span class="line">        <span class="keyword">while</span> (Node* node = head.<span class="built_in">load</span>().ptr) &#123;</span><br><span class="line">            head.<span class="built_in">store</span>(&#123;node-&gt;next, <span class="number">0</span>&#125;, std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">delete</span> node-&gt;data;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建新节点并填充数据</span></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            new_node-&gt;data = <span class="keyword">new</span> <span class="built_in">T</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">delete</span> new_node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. CAS循环：找到真正的尾节点</span></span><br><span class="line">        VersionedPtr current_tail;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 原子获取当前尾指针</span></span><br><span class="line">            current_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_tail = current_tail.ptr;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试将新节点链接到尾节点后面</span></span><br><span class="line">            Node* next = real_tail-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查期间尾指针是否变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_tail.ptr != tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr) </span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 发生变化则重试</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 情况A：尾节点后是空位置（理想情况）</span></span><br><span class="line">                VersionedPtr new_ptr&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 关键CAS：原子更新尾节点的next指针</span></span><br><span class="line">                <span class="keyword">if</span> (real_tail-&gt;next.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">                    next, new_node, </span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 链接成功，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况B：发现尾指针滞后，帮助其它线程推进</span></span><br><span class="line">                VersionedPtr new_ptr&#123;next, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试更新尾指针到后继节点（避免竞争导致的阻塞）</span></span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_tail, new_ptr,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 尝试更新全局尾指针（允许失败）</span></span><br><span class="line">        VersionedPtr new_tail&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">        tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            current_tail, new_tail,</span><br><span class="line">            std::memory_order_release,</span><br><span class="line">            std::memory_order_relaxed);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T&amp; result)</span> </span>&#123;</span><br><span class="line">        VersionedPtr current_head;</span><br><span class="line">        Node* real_tail;</span><br><span class="line">        Node* next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 原子获取头尾指针（关键）</span></span><br><span class="line">            current_head = head.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_head = current_head.ptr;</span><br><span class="line">            real_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr;</span><br><span class="line">            next = real_head-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一致性检查：防止读取过程中数据结构变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_head.ptr != head.<span class="built_in">load</span>(std::memory_order_acquire).ptr)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 2. 队列状态判断</span></span><br><span class="line">            <span class="keyword">if</span> (real_head == real_tail) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 情况A：队列为空</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况B：尾指针滞后，帮助推进</span></span><br><span class="line">                VersionedPtr new_tail&#123;next, tail.<span class="built_in">load</span>().version + <span class="number">1</span>&#125;;</span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    tail.<span class="built_in">load</span>(), new_tail,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况C：正常出队</span></span><br><span class="line">                <span class="comment">// 移动数据前预先加载（减少持有锁时间）</span></span><br><span class="line">                T* data_ptr = next-&gt;data;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试移动头指针</span></span><br><span class="line">                VersionedPtr new_head&#123;next, current_head.version + <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_head, new_head,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 出队成功：转移数据</span></span><br><span class="line">                    result = std::<span class="built_in">move</span>(*data_ptr);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 安全删除旧头节点（工业实现需延迟回收）</span></span><br><span class="line">                    <span class="keyword">delete</span> data_ptr;</span><br><span class="line">                    <span class="keyword">delete</span> real_head;  <span class="comment">// 实际应使用危险指针回收</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="内存回收危险指针"   >
          <a href="#内存回收危险指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存回收危险指针"></a> 内存回收（危险指针）</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hazard Pointer简单实现（线程本地注册）</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> std::vector&lt;Node*&gt; <span class="title">hp_records</span><span class="params">(<span class="number">2</span>)</span></span>;  <span class="comment">// 通常每个线程2个足够</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetireNode</span><span class="params">(Node* old)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查其他线程是否引用该节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsPointerHazard</span>(old))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加入待删除列表（延迟处理）</span></span><br><span class="line">        retired_list.<span class="built_in">push_back</span>(old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="无锁是忙等待吗"   >
          <a href="#无锁是忙等待吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无锁是忙等待吗"></a> 无锁是忙等待吗？</h1>
      
<p>无锁编程并不等同于忙等待（Busy-Waiting），其核心在于「非阻塞」，而非具体等待方式。​​</p>
<ol>
<li>​<strong>​「非阻塞」的定义​</strong>
<ul>
<li><em>Lock-Free</em>：至少一个线程能前进</li>
<li><em>Wait-Free</em>：所有线程都能在有限步完成</li>
</ul>
</li>
<li>​<strong>​延迟与吞吐的权衡​</strong>​
<ul>
<li>​<strong>​忙等待​</strong>​：牺牲CPU，以降低延迟（高频交易系统）</li>
<li>​<strong>​阻塞等待​</strong>​：加大延迟，以加大吞吐（Web服务器连接池）</li>
</ul>
</li>
</ol>
<p>无锁编程可​<strong>​根据竞争强度动态选择等待策略​</strong>​：</p>
<ol>
<li>低竞争时短暂自旋（利用CPU流水线）</li>
<li>中竞争时退避+主动让出CPU</li>
<li>高竞争时进入操作系统阻塞队列</li>
</ol>
<p>​<strong>​核心目标是以最小开销维持「至少一个线程前进」的非阻塞特性​</strong>​，而非强制忙等待。</p>
<p>实际无锁设计中可通过多种策略避免忙等：</p>

        <h2 id="操作系统级阻塞等待"   >
          <a href="#操作系统级阻塞等待" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#操作系统级阻塞等待"></a> 操作系统级阻塞等待</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++20 前（使用 futex）</span></span><br><span class="line"><span class="keyword">while</span> (!atomic_var.<span class="built_in">compare_exchange_weak</span>(...))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">syscall</span>(SYS_futex, &amp;atomic_var, FUTEX_WAIT, ...);  <span class="comment">// 主动让出CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++20 后（std::atomic::wait）</span></span><br><span class="line">atomic_var.<span class="built_in">wait</span>(old_val, std::memory_order_relaxed);  <span class="comment">// 线程挂起直到值变化</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="定时退避策略"   >
          <a href="#定时退避策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#定时退避策略"></a> 定时退避策略</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> retries = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">CAS</span>(ptr, old_val, new_val))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (retries++ &gt; MAX_SPIN)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();     <span class="comment">// 放弃时间片，通知调度器切换</span></span><br><span class="line">        retries = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _mm_pause();                  <span class="comment">// x86 自旋等待指令（降低CPU功耗）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="队列化竞争机制排队锁"   >
          <a href="#队列化竞争机制排队锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#队列化竞争机制排队锁"></a> 队列化竞争机制（排队锁）</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Waiter</span> &#123; std::atomic&lt;Waiter*&gt; next; &#125;;</span><br><span class="line">std::atomic&lt;Waiter*&gt; tail_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Waiter w;</span><br><span class="line">    w.next = <span class="literal">nullptr</span>;</span><br><span class="line">    Waiter* prev = tail_.<span class="built_in">exchange</span>(&amp;w, std::memory_order_acq_rel);</span><br><span class="line">    <span class="keyword">if</span> (prev)</span><br><span class="line">    &#123;</span><br><span class="line">        prev-&gt;next = &amp;w;                      <span class="comment">// 排队</span></span><br><span class="line">        <span class="keyword">while</span> (w.next.<span class="built_in">load</span>() != &amp;w) &#123;&#125;       <span class="comment">// 等待前驱节点唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Waiter* w = ...;</span><br><span class="line">    <span class="keyword">if</span> (!w-&gt;next)</span><br><span class="line">    &#123;                           <span class="comment">// 无后续等待者</span></span><br><span class="line">        <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(w, <span class="literal">nullptr</span>)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!w-&gt;next.<span class="built_in">load</span>())    <span class="comment">// 等待后继节点就绪</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 唤醒下一个</span></span><br><span class="line">    w-&gt;next.<span class="built_in">load</span>()-&gt;next.<span class="built_in">store</span>(w-&gt;next.<span class="built_in">load</span>()-&gt;next, ...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比"></a> 对比</h2>
      
<div class="table-container"><table>
<thead>
<tr>
<th><strong>策略​</strong>​</th>
<th>实现方式</th>
<th>适用场景</th>
<th>CPU占用</th>
<th>延迟</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​忙等待​</strong>​</td>
<td><code>while(!CAS)</code></td>
<td>极低延迟场景（&lt;100ns）</td>
<td>100%核心</td>
<td>极低</td>
</tr>
<tr>
<td>​<strong>​主动退让​</strong>​</td>
<td><code>std::this_thread::yield()</code></td>
<td>用户态竞争适中</td>
<td>&lt; 30%</td>
<td>微秒级</td>
</tr>
<tr>
<td>​<strong>​操作系统阻塞​</strong>​</td>
<td><code>futex</code> / <code>atomic::wait</code></td>
<td>高竞争/长等待</td>
<td>~0%</td>
<td>毫秒级</td>
</tr>
<tr>
<td>​<strong>​队列化调度​</strong>​</td>
<td>MCS锁等排队机制</td>
<td>严格公平性要求</td>
<td>随队列转移</td>
<td>亚毫秒级</td>
</tr>
</tbody>
</table></div>

        <h2 id="工业级案例"   >
          <a href="#工业级案例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工业级案例"></a> 工业级案例</h2>
      

        <h3 id="linux内核futex"   >
          <a href="#linux内核futex" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#linux内核futex"></a> Linux内核Futex</h3>
      
<ul>
<li>首次CAS竞争失败后，通过<code>FUTEX_WAIT</code>系统调用挂起线程</li>
<li>解锁时通过<code>FUTEX_WAKE</code>唤醒等待线程</li>
</ul>

        <h3 id="java的aqsabstract-queued-synchronizer"   >
          <a href="#java的aqsabstract-queued-synchronizer" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java的aqsabstract-queued-synchronizer"></a> ​​Java的AQS（Abstract Queued Synchronizer）​</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquire(arg)) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 无锁尝试</span></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire()) </span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);       <span class="comment">// 挂起线程（JVM层面）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="c20原子等待"   >
          <a href="#c20原子等待" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c20原子等待"></a> C++20原子等待</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">while</span> (!flag.<span class="built_in">wait</span>(<span class="number">1</span>, std::memory_order_seq_cst)); <span class="comment">// 阻塞直至值!=1</span></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">flag.<span class="built_in">store</span>(<span class="number">2</span>);</span><br><span class="line">flag.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有等待者</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="总线锁和缓存锁"   >
          <a href="#总线锁和缓存锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总线锁和缓存锁"></a> 总线锁和缓存锁</h1>
      

        <h2 id="总线锁bus-lock"   >
          <a href="#总线锁bus-lock" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总线锁bus-lock"></a> 总线锁（Bus Lock）</h2>
      
<p>当CPU执行带<code>LOCK</code>前缀的指令（如<code>CMPXCHG</code>）时，会通过芯片组发出​<strong>​硬件信号​</strong>​，​<strong>​独占整个内存总线（Bus）​</strong>​ 。此时其他CPU的所有内存访问请求将被阻塞，直到当前操作完成。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    CPU核心A-&gt;&gt;内存总线: LOCK#信号（总线锁定）</span><br><span class="line">    内存总线-&gt;&gt;所有CPU: 阻塞其他内存请求</span><br><span class="line">    CPU核心A-&gt;&gt;内存: 执行原子操作（如CAS）</span><br><span class="line">    内存总线-&gt;&gt;所有CPU: 解锁</span><br></pre></td></tr></table></div></figure>
<p>特点</p>
<ul>
<li>​<strong>​全局性锁定​</strong>​：锁定期间所有内存操作均被阻塞（包括非竞争数据）</li>
<li>​<strong>​性能开销大​</strong>​：原子操作串行化，多核性能急剧下降</li>
<li>​<strong>​兼容性强​</strong>​：早期x86处理器的唯一选择（如80486）</li>
</ul>

        <h2 id="缓存锁cache-locking-mesi优化"   >
          <a href="#缓存锁cache-locking-mesi优化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存锁cache-locking-mesi优化"></a> 缓存锁（Cache Locking）—— MESI优化</h2>
      
<p>核心：缓存一致性协议（Cache Coherence）</p>
<p>现代CPU通过​<strong>​MESI协议​</strong>​（Modified/Exclusive/Shared/Invalid）维护多核缓存一致性：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    Modified --&gt;|写回| Invalid</span><br><span class="line">    Exclusive --&gt;|其他核读| Shared</span><br><span class="line">    Shared --&gt;|写| Modified</span><br><span class="line">    Invalid --&gt;|写| Exclusive</span><br></pre></td></tr></table></div></figure>

        <h3 id="缓存锁的触发条件以intel-cpu为例"   >
          <a href="#缓存锁的触发条件以intel-cpu为例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存锁的触发条件以intel-cpu为例"></a> 缓存锁的触发条件（以Intel CPU为例）</h3>
      
<p>当原子操作访问的数据满足：</p>
<ol>
<li>​<strong>​对齐在缓存行内​</strong>​（通常64字节对齐）</li>
<li>​<strong>​目标地址未跨缓存行​</strong>​（Non-split Access）</li>
<li>​<strong>​CPU支持缓存锁定技术​</strong>​（几乎所有现代处理器）</li>
</ol>

        <h3 id="工作流程"   >
          <a href="#工作流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：两个线程在核 0 和核 1 上执行原子操作</span></span><br><span class="line"><span class="comment">// 初始状态：变量 X 被核 0 和核 1 缓存（Shared状态）</span></span><br><span class="line"><span class="number">1.</span> 核<span class="number">0</span>执行原子操作（如X++）:</span><br><span class="line">   - 发出RFO（Request For Ownership）消息</span><br><span class="line">   - 其他核心将X的缓存行置为Invalid</span><br><span class="line">   - 核<span class="number">0</span>将缓存行置为Modified状态</span><br><span class="line">   - 执行修改（未触发总线锁）</span><br><span class="line"><span class="number">2.</span> 核<span class="number">1</span>尝试操作X：</span><br><span class="line">   - 发现缓存失效（Invalid）</span><br><span class="line">   - 从核<span class="number">0</span>的缓存中读取最新数据（缓存行状态转为Shared）</span><br></pre></td></tr></table></div></figure>

        <h3 id="避免缓存冲突"   >
          <a href="#避免缓存冲突" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#避免缓存冲突"></a> 避免缓存冲突</h3>
      

        <h4 id="内存对齐避免总线锁"   >
          <a href="#内存对齐避免总线锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存对齐避免总线锁"></a> 内存对齐避免总线锁</h4>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：变量可能跨缓存行</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unaligned</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">62</span>]; <span class="comment">// 62字节填充</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; x; <span class="comment">// 位于62-66字节（跨越两个缓存行）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：强制缓存行对齐</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Aligned</span><br><span class="line">&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; x; <span class="comment">// 独占一个缓存行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>检测方法：Linux下<code>perf c2c</code>可检测缓存行冲突（False Sharing）</p>
</blockquote>

        <h4 id="写竞争下的性能差异"   >
          <a href="#写竞争下的性能差异" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#写竞争下的性能差异"></a> 写竞争下的性能差异​</h4>
      
<p>当两个CPU核心频繁写​<strong>​同一缓存行​</strong>​时：</p>
<ul>
<li>​<strong>​缓存锁场景​</strong>​：缓存行在<code>Modified</code>↔<code>Invalid</code>状态间震荡，产生大量RFO消息</li>
<li>​<strong>​解决方案​</strong>​：​<strong>​伪共享隔离（False Sharing Elimination）</strong></li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多核计数器优化（每个核独占缓存行）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PerCoreCounter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line">PerCoreCounter counters[CPU_CORES]; </span><br></pre></td></tr></table></div></figure>

        <h2 id="特殊场景总线锁不可避免"   >
          <a href="#特殊场景总线锁不可避免" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#特殊场景总线锁不可避免"></a> 特殊场景总线锁不可避免</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK XCHG [mem], reg  ; 显式LOCK前缀</span><br><span class="line">CMPXCHG16B m128       ; 128位跨缓存行操作</span><br><span class="line">一个未对齐的LOCK操作    ; 如对跨64字节边界的int操作</span><br></pre></td></tr></table></div></figure>

        <h2 id="对比-2"   >
          <a href="#对比-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比-2"></a> 对比</h2>
      
<div class="table-container"><table>
<thead>
<tr>
<th>​<strong>​特征​</strong>​</th>
<th>总线锁</th>
<th>缓存锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​锁定范围​</strong>​</td>
<td>整个内存总线</td>
<td>单个缓存行</td>
</tr>
<tr>
<td>​<strong>​性能影响​</strong>​</td>
<td>全局停顿，性能损失严重</td>
<td>仅影响涉及特定缓存行的操作</td>
</tr>
<tr>
<td>​<strong>​触发条件​</strong>​</td>
<td><code>LOCK</code>前缀指令</td>
<td>内存对齐且未跨缓存行的原子操作</td>
</tr>
<tr>
<td>​<strong>​实现技术​</strong>​</td>
<td>硬件信号硬阻塞</td>
<td>MESI缓存一致性协议</td>
</tr>
<tr>
<td>​<strong>​现代应用​</strong>​</td>
<td>仅作兜底（如跨缓存行操作）</td>
<td>99%原子操作的默认实现</td>
</tr>
<tr>
<td>​<strong>​能耗​</strong>​</td>
<td>高（总线开关）</td>
<td>低（仅缓存状态切换）</td>
</tr>
</tbody>
</table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-09</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" data-flag-title="单例模式"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>单例模式简介</li>
<li>饿汉式单例模式</li>
<li>懒汉式单例模式</li>
<li>线程安全的单例模式</li>
</ol>

        <h1 id="单例模式简介"   >
          <a href="#单例模式简介" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#单例模式简介"></a> 单例模式简介</h1>
      
<p>单例模式指的是，无论怎么获取，<strong>永远只能得到该类类型的唯一一个实例对象</strong>，那么设计一个单例就必须要满足下面三个条件：</p>
<ol>
<li>构造函数私有化，这样用户就不能任意定义该类型的对象了</li>
<li>定义该类型唯一的对象</li>
<li>通过一个static静态成员方法返回唯一的对象实例</li>
</ol>

        <h1 id="饿汉式本身线程安全"   >
          <a href="#饿汉式本身线程安全" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#饿汉式本身线程安全"></a> 饿汉式（本身线程安全）</h1>
      
<p><strong>饿汉式</strong>单例模式，顾名思义，就是程序启动时就实例化了该对象，并没有推迟到第一次使用该对象时再进行实例化；如果运行过程中没有使用到，该实例对象就被浪费掉了。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> CSingleton single;</span><br><span class="line">	<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 防止外部使用拷贝构造产生新的对象</span></span><br><span class="line">&#125;;</span><br><span class="line">CSingleton CSingleton::single;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSingleton *p1 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p2 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p3 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>打印<code>0016E138 0016E138 0016E138</code><br />
可以看到，三次获取的CSingleton对象都是同一个对象实例，这是一个<strong>饿汉式</strong>单例模式。</p>

        <h1 id="懒汉式线程不安全"   >
          <a href="#懒汉式线程不安全" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#懒汉式线程不安全"></a> 懒汉式（线程不安全）</h1>
      
<p><strong>懒汉式</strong>单例模式，顾名思义，将对象的实例化延迟到第一次使用它的时刻。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == single)</span><br><span class="line">		&#123;</span><br><span class="line">			single = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> CSingleton *single;</span><br><span class="line">	<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::single = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSingleton *p1 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p2 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p3 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>符合单例模式的要求，三次获取的都是同一个对象，而且程序启动时，只对single指针初始化了空值，等第一次调用<code>getInstance</code>函数时，由于single指针为<code>nullptr</code>，才进行对象的实例化，所以是一个<strong>懒汉式</strong>单例模式。</p>

        <h1 id="没有释放单例对象-内存泄漏"   >
          <a href="#没有释放单例对象-内存泄漏" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#没有释放单例对象-内存泄漏"></a> 没有释放单例对象 - 内存泄漏</h1>
      
<p>但是上面的代码有一个问题：只有new没有delete！作为<code>C++</code>开发者，资源的分配和回收，我们必须要考虑清楚，不能糊涂。</p>
<p>这个问题确实棘手，首先资源的释放如果交给用户来操作，难免会忘记写delete，又或者多次delete，可能错误释放野指针。我们可以利用static静态对象在程序结束时自动析构这么一个特征，给出如下释放资源的代码：在单例类中定义一个嵌套类，在嵌套类的析构函数中，自动释放外层类的资源。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == single)</span><br><span class="line">		&#123;</span><br><span class="line">			single = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> CSingleton *single;</span><br><span class="line">	<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个嵌套类，在该类的析构函数中，自动释放外层类的资源</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CRelease</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">CRelease</span>() &#123; <span class="keyword">delete</span> single; &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 通过该静态对象在程序结束时自动析构的特点，来释放外层类的对象资源</span></span><br><span class="line">	<span class="type">static</span> CRelease release;</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::single = <span class="literal">nullptr</span>;</span><br><span class="line">CSingleton::CRelease CSingleton::release;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSingleton *p1 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p2 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p3 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h1 id="线程安全的懒汉式-锁"   >
          <a href="#线程安全的懒汉式-锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程安全的懒汉式-锁"></a> 线程安全的懒汉式 - 锁</h1>
      
<p>在开发服务器程序的时候，经常会用到多线程，多线程要考虑代码的线程安全特性，不能让代码在多线程环境下出现竞态条件，否则就要进行线程互斥操作，我们来考虑一下上面两种单例模式，如果用在多线程环境当中，是否是线程安全的单例模式。</p>
<ol>
<li>饿汉单例模式的线程安全特性
<ol>
<li>饿汉单例模式中，单例对象定义成了一个static静态对象，它是在程序启动时，main函数运行之前就初始化好的，因此不存在线程安全问题，可以放心在多线程环境中使用。</li>
</ol>
</li>
<li>懒汉单例模式的线程安全特性
<ol>
<li>懒汉单例模式，获取单例对象的方法如下：</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == single)</span><br><span class="line">    &#123;</span><br><span class="line">        single = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>很明显，这个<code>getInstance</code>是个不可重入函数，也就它在多线程环境中执行，会出现竞态条件问题，首先搞清楚这句代码，<code>single = new CSingleton()</code>它会做三件事情，开辟内存，调用构造函数，给single指针赋值，那么在多线程环境下，就有可能出现如下问题：</p>
<ol>
<li>线程A先调用getInstance函数，由于single为<code>nullptr</code>，进入if语句</li>
<li>new操作先开辟内存，此时A线程的CPU时间片到了，切换到B线程</li>
<li>B线程由于single为<code>nullptr</code>，也进入if语句了，开始new操作</li>
</ol>
<p>很明显，上面两个线程都进入了if语句，都试图new一个新的对象，不符合单例模式的设计，那该如何处理呢？应该为getInstance函数内部加锁，在线程间进行互斥操作。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  	</span>&#123;</span><br><span class="line">  		<span class="comment">// 获取互斥锁</span></span><br><span class="line">  		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">  		<span class="keyword">if</span> (<span class="literal">nullptr</span> == single)</span><br><span class="line">  		&#123;</span><br><span class="line">  			single = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">// 释放互斥锁</span></span><br><span class="line">  		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">  		<span class="keyword">return</span> single;</span><br><span class="line">  	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  	<span class="type">static</span> CSingleton *single;</span><br><span class="line">  	<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  	~<span class="built_in">CSingleton</span>() </span><br><span class="line">  	&#123;</span><br><span class="line">  		<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">  		cout &lt;&lt; <span class="string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl; </span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;);</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">class</span> <span class="title class_">CRelease</span></span><br><span class="line">  	&#123;</span><br><span class="line">  	<span class="keyword">public</span>:</span><br><span class="line">  		~<span class="built_in">CRelease</span>() &#123; <span class="keyword">delete</span> single; &#125;</span><br><span class="line">  	&#125;;</span><br><span class="line">  	<span class="type">static</span> CRelease release;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 定义线程间的互斥锁</span></span><br><span class="line">  	<span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::single = <span class="literal">nullptr</span>;</span><br><span class="line">CSingleton::CRelease CSingleton::release;</span><br><span class="line"><span class="comment">// 互斥锁的初始化</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> CSingleton::mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSingleton *p1 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    CSingleton *p2 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    CSingleton *p3 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的代码，是一个线程安全的懒汉单例模式，但是效率太低，因为每次调用getInstance都需要加锁解锁，除了第一次调用，后面对getInstance函数持续的加解锁实在时没有必要，所以这里需要使用<code>锁+双重判断</code>，也叫<strong>双重检验锁</strong>，把上面的getInstance函数代码修改如下：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (<span class="literal">nullptr</span> == single)</span><br><span class="line">  	&#123;</span><br><span class="line">        <span class="comment">// 获取互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            这里需要再添加一个if判断，否则当两个</span></span><br><span class="line"><span class="comment">            线程都进入这里，又会多次new对象，不符合单例模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == single)</span><br><span class="line">        &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放互斥锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果把mutex封装为一个类，那么更加符合面向对象的思想。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对互斥锁操作的封装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMutex</span>()&#123;<span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);&#125;  <span class="comment">// 初始化锁</span></span><br><span class="line">    ~<span class="built_in">CMutex</span>()&#123;<span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);&#125;  <span class="comment">// 销毁锁 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);&#125;  <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);&#125;  <span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == single)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取互斥锁</span></span><br><span class="line">            mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                这里需要再添加一个if判断，否则当两个</span></span><br><span class="line"><span class="comment">                线程都进入这里，又会多次new对象，不符合</span></span><br><span class="line"><span class="comment">                单例模式的涉及</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == single)</span><br><span class="line">            &#123;</span><br><span class="line">                single = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放互斥锁</span></span><br><span class="line">            mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> CSingleton *single;</span><br><span class="line">    <span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CRelease</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CRelease</span>() &#123; <span class="keyword">delete</span> single; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> CRelease release;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程间的静态互斥锁</span></span><br><span class="line">    <span class="type">static</span> CMutex mutex;</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::single = <span class="literal">nullptr</span>;</span><br><span class="line">CSingleton::CRelease CSingleton::release;</span><br><span class="line"><span class="comment">// 定义互斥锁静态对象</span></span><br><span class="line">CMutex CSingleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSingleton *p1 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    CSingleton *p2 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    CSingleton *p3 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSingleton()</span><br><span class="line">~CSingleton()</span><br></pre></td></tr></table></div></figure>

        <h1 id="线程安全的懒汉式-call_once"   >
          <a href="#线程安全的懒汉式-call_once" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程安全的懒汉式-call_once"></a> 线程安全的懒汉式 - <code>call_once</code></h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// call_once</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    	<span class="comment">// 确保线程安全的只初始化一次</span></span><br><span class="line">		std::<span class="built_in">call_once</span>(once_flag, init);</span><br><span class="line">		<span class="keyword">return</span> single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    	<span class="comment">// 无需检查 if (!single)，因为 call_once 保证只执行一次</span></span><br><span class="line">		single = <span class="keyword">new</span> CSingleton;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> CSingleton * single;</span><br><span class="line">	<span class="type">static</span> std::once_flag once_flag;</span><br><span class="line">	<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	CSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CRelease</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">CRelease</span>() &#123; <span class="keyword">delete</span> single; &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">static</span> CRelease release;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类外定义</span></span><br><span class="line">CSingleton* CSingleton::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::once_flag CSingleton::once_flag;</span><br><span class="line">CSingleton::CRelease CSingleton::release; <span class="comment">// 程序结束时自动调用析构</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSingleton* p1 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton* p2 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton* p3 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSingleton()</span><br><span class="line">~CSingleton()</span><br></pre></td></tr></table></div></figure>

        <h1 id="更简洁的线程安全的懒汉式"   >
          <a href="#更简洁的线程安全的懒汉式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#更简洁的线程安全的懒汉式"></a> 更简洁的线程安全的懒汉式</h1>
      
<p>下面这个懒汉单例模式是否是线程安全的，代码如下：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> CSingleton single; <span class="comment">// 懒汉式单例模式，定义唯一的对象实例</span></span><br><span class="line">		<span class="keyword">return</span> &amp;single;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">CSingleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CSingleton()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSingleton *p1 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p2 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	CSingleton *p3 = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面的单例模式在多线程环境中使用时，会不会出现这种情况，线程A第一次调用getInstance函数的时候，single对象第一次初始化，此时线程B也调用getInstance函数，会不会也进行single对象的初始化呢，因为此时线程A并没有初始化完single？</p>
<p>在Linux环境中，通过g++编译上面的代码，命令如下：<br />
<code>g++ -o main main.cpp -g</code><br />
生成可执行文件main，用gdb进行调试，到getInstance函数，并打印该函数的汇编指令，如下：</p>
<p><img src="../../images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20220410090711941.png" alt="image-20220410090711941" /></p>
<p>可以看到，<strong>对于static静态局部变量的初始化，编译器会自动对它的初始化进行加锁和解锁控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量，因此上面的懒汉单例模式是线程安全的单例模式！</strong></p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
      
<p>一个看似小小的单例模式，却可以串联面向对象思想，到软件设计思想，到设计模式，再到Linux操作系统的进程和线程模型，线程间的互斥和通信。</p>
<hr />
<p>参考文献：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88544524?spm=1001.2014.3001.5502" >C++设计模式 - 单例模式_单例模式大秦坑王-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/99/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/99/">99</a><span class="page-number current">100</span><a class="page-number" href="/page/101/">101</a><span class="space">&hellip;</span><a class="page-number" href="/page/151/">151</a><a class="extend next" rel="next" href="/page/101/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">302</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>