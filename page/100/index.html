<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/100/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/100/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%A1%B9%E7%9B%AE/%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/">集群服务器</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-03</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/" data-flag-title="集群服务器"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>项目需求及目标</li>
<li>开发环境</li>
<li><code>Json</code>介绍</li>
<li><code>muduo</code>网络库编程</li>
<li>服务器集群</li>
<li>基于<code>发布-订阅</code>的<code>Redis</code>——服务器中间件</li>
<li>数据库设计</li>
</ol>
<p>本项目要用到的技术栈：</p>
<ol>
<li><code>Json</code>序列化和反序列化；</li>
<li><code>muduo</code>网络库开发；</li>
<li><code>nginx</code>源码编译安装和环境部署；</li>
<li><code>nginx</code>的<code>tcp</code>负载均衡器配置；</li>
<li><code>redis</code>缓存服务器编程实践；</li>
<li>基于<code>发布-订阅</code>的服务器中间件<code>redis</code>消息队列编程实践；</li>
<li><code>MySQL</code>数据库编程；</li>
<li><code>CMake</code>构建编译环境；</li>
<li><code>Github</code>托管项目</li>
</ol>
<p>本项目的内容包含了：通常开发的服务器，网络、业务、数据模块（数据库、数据的操作），<br />
项目中要把三大模块区分开，项目初期时以登录模块为主线，分三大块推进。</p>

        <h1 id="项目需求及目标"   >
          <a href="#项目需求及目标" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#项目需求及目标"></a> 项目需求及目标</h1>
      
<ul>
<li>项目需求
<ol>
<li>客户端新用户注册</li>
<li>客户端用户登录</li>
<li>添加好友和添加群组</li>
<li>好友聊天和群组聊天</li>
<li><code>nginx</code>配置<code>tcp</code>负载均衡</li>
<li>集群聊天系统支持客户端跨服务器通信</li>
</ol>
</li>
<li>项目目标
<ol>
<li>掌握服务器的网络<code>I/O</code>模块，业务模块，数据模块分层的设计思想</li>
<li>掌握<code>C++</code> <code>muduo</code>网络库的编程以及实现原理</li>
<li>掌握<code>Json</code>的编程应用</li>
<li>掌握<code>nginx</code>配置部署<code>tcp</code>负载均衡器的原理及应用</li>
<li>掌握服务器中间件的应用场景和基于<code>发布-订阅</code>的<code>redis</code>编程实践以及应用原理</li>
<li>掌握<code>CMake</code>构建自动化编程环境</li>
</ol>
</li>
</ul>

        <h1 id="开发环境"   >
          <a href="#开发环境" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开发环境"></a> 开发环境</h1>
      
<p>muduo库基于boost库，需要先安装boost。</p>
<figure class="highlight sh"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf boost_1_69_0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> boost_1_69_0/</span><br><span class="line">./bootstrap.sh <span class="comment">#运行bootstrap.sh工程编译构建程序</span></span><br><span class="line">./b2 <span class="comment">#源码根目录下生成了b2程序，运行b2程序</span></span><br><span class="line"><span class="comment">#编译完成后，会有如下打印: The Boost C++ Libraries were successfully built!</span></span><br><span class="line"><span class="built_in">sudo</span> ./b2 install <span class="comment">#把上面的boost库头文件和lib库文件安装在默认的Linux系统头文件和库文件的搜索路径下</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="工程目录"   >
          <a href="#工程目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工程目录"></a> 工程目录</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">include目录是头文件放的位置。</span><br><span class="line"></span><br><span class="line">server和client的代码在同一工程中，最后生成时可以把C/S分开生成到bin目录下。</span><br><span class="line">可按server和client分类，</span><br><span class="line">比如生成代码所需用到的头文件可以分别放在/include/server和/include/client，</span><br><span class="line">而server和client共需的头文件直接放到/include下。比如消息的id。</span><br><span class="line"></span><br><span class="line">src放源码。</span><br><span class="line"></span><br><span class="line">thirdparty是第三方库文件夹，比如放json.hpp。</span><br><span class="line"></span><br><span class="line">本项目没有生成lib库(.a/.so)，所以没有lib文件夹。</span><br></pre></td></tr></table></div></figure>

        <h1 id="cmakeliststxt编写"   >
          <a href="#cmakeliststxt编写" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cmakeliststxt编写"></a> CMakeLists.txt编写</h1>
      

        <h2 id="根目录"   >
          <a href="#根目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#根目录"></a> 根目录</h2>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(chat)</span><br><span class="line"><span class="comment"># 配置编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -g)</span><br><span class="line"><span class="comment"># 配置最终的可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 配置头文件的搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/server)</span><br><span class="line"><span class="comment"># 加载子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></div></figure>

        <h2 id="src"   >
          <a href="#src" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#src"></a> <code>/src</code></h2>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(server)</span><br></pre></td></tr></table></div></figure>

        <h2 id="srcserver"   >
          <a href="#srcserver" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#srcserver"></a> <code>/src/server</code></h2>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义了一个SRC_LIST变量，包含了该目录下所有的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment"># 指定生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(ChatServer <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 指定可执行文件链接时 需要依赖的库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(CharServer muduo_net muduo_base pthread)</span><br></pre></td></tr></table></div></figure>

        <h1 id="json介绍"   >
          <a href="#json介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#json介绍"></a> JSON介绍</h1>
      
<p>JSON，全拼：JavaScript Object Notation</p>
<p>JSON是一种轻量级的数据交换格式（也叫数据序列化方式）。</p>
<p>JSON采用完全<strong>独立于编程语言</strong>的文本格式来存储和表示数据。</p>
<p>简洁和清晰的层次结构使得JSON成为理想的数据交换语言。</p>
<p>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>
<p>JSON的用处就是下图：<br />
<img src="../../images/%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220413164124873.png" alt="image-20220413164124873" /></p>

        <h2 id="json第三方库"   >
          <a href="#json第三方库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#json第三方库"></a> JSON第三方库</h2>
      
<p>本项目选用的是<code>JSON for Modern C++</code>，由德国人<code>nlohmann</code>编写的在<code>C++</code>下使用的<code>JSON</code>库。特点如下：</p>
<ol>
<li>整个代码由一个头文件<code>json.hpp</code>包含，没有依赖关系，使用方便；</li>
<li>使用C++11标准编写；</li>
<li>使得JSON像STL容器一样，而且STL和JSON容器之间可以相互转换；</li>
<li>所有类都经过严格的单元测试，覆盖100％的代码，包括所有特殊的行为。此外，还检查了Valgrind是否有内存泄漏。为了保持高质量，该项目遵循“核心基础设施”倡议的最佳实践。</li>
</ol>

        <h2 id="测试json"   >
          <a href="#测试json" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试json"></a> 测试JSON</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* json序列化 示例1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msg_type&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    js[<span class="string">&quot;from&quot;</span>] = <span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;to&quot;</span>] = <span class="string">&quot;li si&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;hello, i&#x27;m zhang san&quot;</span>;</span><br><span class="line">    cout &lt;&lt; js &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;from&quot;:&quot;zhang san&quot;,&quot;msg&quot;:&quot;hello, i&#x27;m zhang san&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;li si&quot;&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="能直接添加二维key-value"   >
          <a href="#能直接添加二维key-value" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#能直接添加二维key-value"></a> 能直接添加二维key - value</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* JSON 序列化 实例2 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	json js;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    js[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;zhang san&quot;</span>] = <span class="string">&quot;i&#x27;m zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;li si&quot;</span>] = <span class="string">&quot;i&#x27;m li si&quot;</span>;</span><br><span class="line">    <span class="comment">/* 上面两句等同于下面这句一次性添加数组对象 */</span></span><br><span class="line"><span class="comment">/*  js[&quot;msg&quot;] = &#123;&#123;&quot;zhang san&quot;, &quot;i&#x27;m zhang san&quot;&#125;, &#123;&quot;li si&quot;, &quot;i&#x27;m li si&quot;&#125;&#125;; */</span></span><br><span class="line">	cout &lt;&lt; js &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:[1,2,3,4,5],&quot;msg&quot;:&#123;&quot;li si&quot;:&quot;i&#x27;m li si&quot;,&quot;zhang san&quot;:&quot;i&#x27;m zhang san&quot;&#125;,&quot;name&quot;:&quot;zhang san&quot;&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="stl容器内容导入json"   >
          <a href="#stl容器内容导入json" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stl容器内容导入json"></a> STL容器内容导入JSON</h3>
      
<p>这个JSON库强大到直接把<code>C++</code> <code>STL</code>中的容器内容可以直接序列化成Json字符串，代码如下：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* json序列化 实例3 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 直接序列化一个vector容器</span></span><br><span class="line">    js[<span class="string">&quot;list&quot;</span>] = vec;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;黄山&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;华山&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;泰山&quot;</span>&#125;);</span><br><span class="line">    <span class="comment">// 直接序列化一个map容器</span></span><br><span class="line">    js[<span class="string">&quot;path&quot;</span>] = m;</span><br><span class="line">    cout &lt;&lt; js &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;list&quot;:[1,2,5],&quot;path&quot;:[[1,&quot;黄山&quot;],[2,&quot;华山&quot;],[3,&quot;泰山&quot;]]&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="api"   >
          <a href="#api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#api"></a> API</h2>
      

        <h3 id="dump序列化"   >
          <a href="#dump序列化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#dump序列化"></a> dump（序列化）</h3>
      
<p>生成的字符串内容和<code>&lt;&lt; json</code>的一样。返回一个string对象。</p>
<p><code>cout &lt;&lt;</code>能输出 JSON 对象是因为重载了<code>&lt;&lt;</code>运算符；而要实际生成<code>string</code>可用<code>dump()</code>，生成的字符串内容和<code>&lt;&lt; json</code>的一样。传输数据时，不要传<code>string</code>对象，而是要传<code>string</code>实际指向的字符串首指针，<code>c_str()</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msg_type&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    js[<span class="string">&quot;from&quot;</span>] = <span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;to&quot;</span>] = <span class="string">&quot;li si&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;hello, i&#x27;m zhang san&quot;</span>;</span><br><span class="line">    string sendBuf = js.<span class="built_in">dump</span>();</span><br><span class="line">    cout &lt;&lt; sendBuf.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="parse反序列化为json对象可以赋值给stl容器"   >
          <a href="#parse反序列化为json对象可以赋值给stl容器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#parse反序列化为json对象可以赋值给stl容器"></a> parse（反序列化为JSON对象，可以赋值给STL容器）</h3>
      
<p>解析string类型的字符串，生成一个JSON对象。可以转换为容器。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msg_type&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    js[<span class="string">&quot;from&quot;</span>] = <span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;to&quot;</span>] = <span class="string">&quot;li si&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;hello, i&#x27;m zhang san&quot;</span>;</span><br><span class="line">    cout &lt;&lt; js &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string recvBuf = <span class="built_in">func1</span>();</span><br><span class="line">    json json_obj = json::<span class="built_in">parse</span>(recvBuf);</span><br><span class="line">    cout &lt;&lt; json_obj[<span class="string">&quot;msg_type&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; json_obj[<span class="string">&quot;from&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; json_obj[<span class="string">&quot;to&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; json_obj[<span class="string">&quot;msg&quot;</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">&quot;zhang san&quot;</span><br><span class="line">&quot;li si&quot;</span><br><span class="line">&quot;hello, what are you doing now?&quot;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	json js;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string recvBuf = <span class="built_in">func2</span>();</span><br><span class="line">    json json_obj = json::<span class="built_in">parse</span>(recvBuf);</span><br><span class="line">    <span class="keyword">auto</span> arr = json_obj[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    cout &lt;&lt; json_obj[<span class="string">&quot;id&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br><span class="line">3</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 直接序列化一个vector容器</span></span><br><span class="line">    js[<span class="string">&quot;list&quot;</span>] = vec;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="string">&quot;黄山&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">2</span>, <span class="string">&quot;华山&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;泰山&quot;</span>&#125;);</span><br><span class="line">    <span class="comment">// 直接序列化一个map容器</span></span><br><span class="line">    js[<span class="string">&quot;path&quot;</span>] = m;</span><br><span class="line">    cout &lt;&lt; js &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = json_obj[<span class="string">&quot;list&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp; v : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mymap = json_obj[<span class="string">&quot;path&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; p : mymap)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 5 </span><br><span class="line">1 黄山</span><br><span class="line">2 华山</span><br><span class="line">3 泰山</span><br></pre></td></tr></table></div></figure>

        <h1 id="网络io模块"   >
          <a href="#网络io模块" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#网络io模块"></a> 网络IO模块</h1>
      

        <h2 id="main入口需要处理服务器程序异常退出如sigint信号"   >
          <a href="#main入口需要处理服务器程序异常退出如sigint信号" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#main入口需要处理服务器程序异常退出如sigint信号"></a> main入口（⭐需要处理服务器程序异常退出，如SIGINT信号）</h2>
      
<p>诸如被kill、或者Ctrl + C终止服务器主程序时，需要处理信号，绑定回调<code>void resetHandler(int)</code><br />
在ChatService中，调用reset函数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;chatserver.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;chatservice.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;muduo/base/Logging.h&gt;</span>  <span class="comment">// LOG_ERROR &lt;&lt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理服务器Ctrl+C结束后，重置user状态信息 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetHandler</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;服务器因SIGINT信号退出，用户状态已重置。&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, resetHandler);</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6000</span>)</span></span>;</span><br><span class="line">    <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;ChatServer&quot;</span>)</span></span>;</span><br><span class="line">    ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    loop.<span class="built_in">loop</span>();    <span class="comment">//开启事件循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>ChatService中的<code>reset()</code>函数，就是调用<code>_userModel</code>的<code>resetAllState()</code>方法。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 业务重置方法，通常在服务器异常退出时调用 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 把所有online用户的状态置为offline */</span></span><br><span class="line">    _userModel.<span class="built_in">resetAllState</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>即重置所有用户的状态信息，把所有 online 的改成 offline 。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重置所有用户的状态信息 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserModel::resetAllState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = <span class="string">&quot;update user set state = &#x27;offline&#x27; where state = &#x27;online&#x27;&quot;</span>;</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="chatserver"   >
          <a href="#chatserver" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#chatserver"></a> ChatServer</h2>
      

        <h3 id="成员属性"   >
          <a href="#成员属性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员属性"></a> 成员属性</h3>
      
<ol>
<li><code>TcpServer m_server</code> - <strong>基于事件驱动的、IO复用+epoll+线程池</strong>的服务器类，完全<strong>基于Reactor模型</strong></li>
<li><code>EventLoop *m_loop</code> - mainLoop的指针, 保存事件循环. 有了事件循环的指针，可以在合适的时候调用quit退出事件循环；</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 组合的muduo库，实现服务器功能的类对象 */</span></span><br><span class="line">    TcpServer _server;</span><br><span class="line">    <span class="comment">/* 指向事件循环对象的指针 */</span></span><br><span class="line">    EventLoop *_loop;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数"   >
          <a href="#成员函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h3>
      

        <h4 id="构造"   >
          <a href="#构造" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#构造"></a> 构造</h4>
      
<p>参数为<code>loop</code>指针, <code>listenAddr</code>, <code>name</code>, 用于初始化TcpServer</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/* 初始化聊天服务器对象 */</span></span><br><span class="line"><span class="built_in">ChatServer</span>(EventLoop* loop,</span><br><span class="line">           <span class="type">const</span> InetAddress&amp; listenAddr,</span><br><span class="line">           <span class="type">const</span> string&amp; nameArg);</span><br></pre></td></tr></table></div></figure>

        <h4 id="start"   >
          <a href="#start" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#start"></a> <code>start()</code></h4>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="onconnectiononmessage"   >
          <a href="#onconnectiononmessage" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#onconnectiononmessage"></a> <code>onConnection</code>/<code>onMessage</code></h4>
      
<p>连接创建/断开的回调函数</p>
<p>读写事件发生的回调函数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">/* 上报链接相关信息的回调函数（连接创建，连接断开）*/</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line">   <span class="comment">/* 上报读写事件相关信息的回调函数 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp;, Buffer*, Timestamp)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="头文件"   >
          <a href="#头文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHATSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHATSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器的主类;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要注册两个方法:</span></span><br><span class="line"><span class="comment"> * 给TcpServer注册新用户的连接、连接断开的、已连接用户的可读写事件;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 初始化聊天服务器对象 */</span></span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop* loop,</span><br><span class="line">               <span class="type">const</span> InetAddress&amp; listenAddr,</span><br><span class="line">               <span class="type">const</span> string&amp; nameArg);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 启动服务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 上报链接相关信息的回调函数（连接创建，连接断开）*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line">    <span class="comment">/* 上报读写事件相关信息的回调函数 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp;, Buffer*, Timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 组合的muduo库，实现服务器功能的类对象 */</span></span><br><span class="line">    TcpServer _server;</span><br><span class="line">    <span class="comment">/* 指向事件循环对象的指针 */</span></span><br><span class="line">    EventLoop *_loop;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h2 id="reactor模型"   >
          <a href="#reactor模型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#reactor模型"></a> Reactor模型</h2>
      
<p>本项目基于muduo库，模型是<strong>基于事件驱动的、IO复用+epoll+线程池</strong>的网络，完全<strong>基于Reactor模型</strong>，线程暂时设置为 4 个，有一个主Reactor是 IO 线程，主要负责新用户的连接，3个 sub-Reactor 是工作线程，主要负责已连接用户的读写事件的处理。</p>

        <h2 id="客户端异常退出的业务代码解决"   >
          <a href="#客户端异常退出的业务代码解决" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端异常退出的业务代码解决"></a> （⭐）客户端异常退出的业务代码解决</h2>
      
<p>需要知道，如果客户端异常断网的话，是不会发送TCP报文的，更不会发送JSON信息。<br />
但是好在muduo网络库为我们封装了处理客户端异常断网的逻辑，我们只需要在onConnection回调里处理客户端断开的逻辑就好了。<br />
既然客户端断开了，需要在Service层面记录用户退出。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;<span class="built_in">connected</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">cloentCloseException</span>(conn);</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::clientCloseException</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    User user;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">        <span class="comment">// 从 map 表中找到该 conn 的用户，删除连接信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = _userConnMap.<span class="built_in">begin</span>(); it != _userConnMap.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second == conn)</span><br><span class="line">            &#123;</span><br><span class="line">                user.<span class="built_in">setId</span>(it-&gt;first);</span><br><span class="line">                _userConnMap.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新用户的状态信息</span></span><br><span class="line">    <span class="keyword">if</span> (user.<span class="built_in">getId</span>() != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        user.<span class="built_in">setState</span>(<span class="string">&quot;offline&quot;</span>);</span><br><span class="line">        _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="数据库设计"   >
          <a href="#数据库设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据库设计"></a> 数据库设计</h1>
      
<p>User表</p>
<div class="table-container"><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>INT</td>
<td>用户id</td>
<td>PRIMARY KEY、AUTO_INCREMENT</td>
</tr>
<tr>
<td>name</td>
<td>VARCHAR(50)</td>
<td>用户名</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>password</td>
<td>VARCHAR(50)</td>
<td>用户密码</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>state</td>
<td>ENUM(‘online’, ‘offline’)</td>
<td>当前登录状态</td>
<td>DEFAULT ‘offline’</td>
</tr>
<tr>
<td>Friend表</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>INT</td>
<td>用户id</td>
<td>NOT NULL、联合主键</td>
</tr>
<tr>
<td>friendid</td>
<td>INT</td>
<td>好友id</td>
<td>NOT NULL、联合主键</td>
</tr>
<tr>
<td>AllGroup表</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>INT</td>
<td>群组id</td>
<td>PRIMARY KEY、AUTO_INCREMENT</td>
</tr>
<tr>
<td>groupname</td>
<td>VARCHAR(50)</td>
<td>群组名称</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>groupdesc</td>
<td>VARCHAR(200)</td>
<td>群组描述</td>
<td>DEFAULT ‘’</td>
</tr>
</tbody>
</table></div>
<p>GroupUser表</p>
<div class="table-container"><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>groupid</td>
<td>INT</td>
<td>群组id</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>userid</td>
<td>INT</td>
<td>群组成员id</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>grouprole</td>
<td>ENUM(‘creator’, ‘normal’)</td>
<td>群组身份</td>
<td>DEFAULT ‘normal’</td>
</tr>
<tr>
<td>OfflineMessage表</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>字段说明</th>
<th>约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>INT</td>
<td>用户id</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>message</td>
<td>VARCHAR(500)</td>
<td>离线消息（JSON字符串）</td>
<td>NOT NULL</td>
</tr>
</tbody>
</table></div>

        <h1 id="业务模块"   >
          <a href="#业务模块" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#业务模块"></a> 业务模块</h1>
      

        <h2 id="业务模块与网络模块解耦-回调"   >
          <a href="#业务模块与网络模块解耦-回调" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#业务模块与网络模块解耦-回调"></a> （⭐）业务模块与网络模块解耦 - 回调</h2>
      
<p>考虑问题：<br />
网络模块收到的消息如何派发到业务模块？</p>
<p>让网络模块的代码和业务模块的代码解耦。</p>
<p>假设有一个用户在做登录业务，登录业务包含<code>messageID</code>，<code>name</code>，<code>password</code>，要验证用户名密码是否正确。</p>
<p>解耦的方案有两种：</p>
<ol>
<li>使用基于面向接口的编程。（抽象基类）</li>
<li><strong>基于回调函数</strong>的操作。</li>
</ol>

        <h2 id="业务类型"   >
          <a href="#业务类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#业务类型"></a> 业务类型</h2>
      
<ol>
<li>登录 - <code>LOGIN_MSG/ACK</code></li>
<li>注册 - <code>REG_MSG/ACK</code></li>
<li>加好友 - <code>ADD_FRIEND_MSG</code></li>
<li>一对一聊天 - <code>ONE_CHAT_MSG</code></li>
<li>创建群组 - <code>CREATE_GROUP_MSG</code></li>
<li>加入群组 - <code>ADD_GROUP_MSG</code></li>
<li>群聊 - <code>GROUP_CHAT_MSG</code></li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUBLIC_H</span></span><br><span class="line"><span class="comment">/* server和client的公共文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnMsgType</span>  <span class="comment">//En表示Enum枚举</span></span><br><span class="line">&#123;</span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,      <span class="comment">//登录 消息id, 与chatservice中的login方法绑定</span></span><br><span class="line">    LOGIN_MSG_ACK,      <span class="comment">//登录响应</span></span><br><span class="line"></span><br><span class="line">    REG_MSG,            <span class="comment">//注册 消息id, 与chatservice中的reg方法绑定</span></span><br><span class="line">    REG_MSG_ACK,        <span class="comment">//注册响应</span></span><br><span class="line"></span><br><span class="line">    ADD_FRIEND_MSG,     <span class="comment">//添加好友</span></span><br><span class="line">    ONE_CHAT_MSG,       <span class="comment">//一对一聊天</span></span><br><span class="line"></span><br><span class="line">    CREATE_GROUP_MSG,   <span class="comment">//创建群组</span></span><br><span class="line">    ADD_GROUP_MSG,      <span class="comment">//加入群组</span></span><br><span class="line">    GROUP_CHAT_MSG      <span class="comment">//群聊</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnLoginErrType</span></span><br><span class="line">&#123;</span><br><span class="line">    LOGIN_SUCCEESS = <span class="number">0</span>,</span><br><span class="line">    LOGIN_REPEAT = <span class="number">1</span>,</span><br><span class="line">    LOGIN_NOTFOUND = <span class="number">2</span>,</span><br><span class="line">    LOGIN_WRONGPWD = <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h3 id="业务消息对应的json格式"   >
          <a href="#业务消息对应的json格式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#业务消息对应的json格式"></a> 业务消息对应的JSON格式</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>业务类型</th>
<th>JSON示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>登录请求消息</td>
<td><code>&quot;msgid&quot;:1,&quot;id&quot;:22,&quot;password&quot;:&quot;123&quot;</code></td>
</tr>
<tr>
<td>登录响应消息</td>
<td><code>&quot;msgid&quot;:2,&quot;errno&quot;:0,&quot;id&quot;:22,&quot;name&quot;:&quot;xcg&quot;</code>或<code>&quot;msgid&quot;:2,&quot;errno&quot;:1,&quot;errmsg&quot;:&quot;this account is online!&quot;</code>或<code>&quot;msgid&quot;:2,&quot;errno&quot;:2,&quot;errmsg&quot;:&quot;id not found!&quot;</code>或<code>&quot;msgid&quot;:2,&quot;errno&quot;:3,&quot;errmsg&quot;:&quot;password wrong!&quot;</code></td>
</tr>
<tr>
<td>注册请求消息</td>
<td><code>&quot;msgid&quot;:3,&quot;name&quot;:&quot;xcg&quot;,&quot;password&quot;:&quot;123&quot;</code></td>
</tr>
<tr>
<td>注册响应消息</td>
<td><code>&quot;msgid&quot;:4,&quot;errno&quot;:0,&quot;id&quot;:22</code>或<code>&quot;msgid&quot;:4,&quot;errno&quot;:1</code></td>
</tr>
<tr>
<td>加好友请求消息</td>
<td><code>&quot;msgid&quot;:5,&quot;friendid&quot;:12</code></td>
</tr>
<tr>
<td>一对一聊天消息</td>
<td><code>&quot;msgid&quot;:6,&quot;to&quot;:12,&quot;msg&quot;:&quot;hello!&quot;</code></td>
</tr>
<tr>
<td>创建群组请求消息</td>
<td><code>&quot;msgid&quot;:7,&quot;groupname&quot;:&quot;group1&quot;,&quot;groupdesc&quot;:&quot;this is a group.&quot;</code></td>
</tr>
<tr>
<td>加入群组请求消息</td>
<td><code>&quot;msgid&quot;:8,&quot;id&quot;:22,&quot;groupid&quot;:10</code></td>
</tr>
<tr>
<td>群聊请求消息</td>
<td><code>&quot;msgid&quot;:9,&quot;id&quot;:22,&quot;groupid&quot;:10,&quot;msg&quot;:&quot;hello, everyone!&quot;</code></td>
</tr>
<tr>
<td>注销请求消息</td>
<td><code>&quot;msgid&quot;:10,&quot;id&quot;:22</code></td>
</tr>
</tbody>
</table></div>

        <h2 id="chatservice"   >
          <a href="#chatservice" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#chatservice"></a> ChatService</h2>
      

        <h3 id="前置处理"   >
          <a href="#前置处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#前置处理"></a> 前置处理</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示处理消息的事件回调方法类型 */</span></span><br><span class="line"><span class="keyword">using</span> MsgHandler = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr&amp;, json&amp;, Timestamp)&gt;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员属性-2"   >
          <a href="#成员属性-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员属性-2"></a> 成员属性</h3>
      

        <h4 id="m_msghandlermap"   >
          <a href="#m_msghandlermap" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#m_msghandlermap"></a> <code>m_msgHandlerMap</code></h4>
      
<p>是一个<code>unordered_map&lt;int, MsgHandler&gt; </code></p>
<p>映射消息类型id 和 事件回调函数</p>
<p>在启动业务服务之前，里面的key value都提前添加好了，不用处理线程安全问题。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">/* 存储消息id和其对应的业务处理方法 */</span></span><br><span class="line">   unordered_map&lt;<span class="type">int</span>, MsgHandler&gt; m_msgHandlerMap;</span><br></pre></td></tr></table></div></figure>

        <h4 id="m_userconnectionmap"   >
          <a href="#m_userconnectionmap" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#m_userconnectionmap"></a> <code>m_userConnectionMap</code></h4>
      
<p>是一个<code>unordered_map&lt;int, TcpConnectionPtr&gt;</code></p>
<p>存储在线用户的通信连接状态。这是聊天服务器实现<strong>长连接的基础</strong>。</p>
<p>需要处理线程安全问题。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">/* 存储在线用户的通信连接 */</span></span><br><span class="line">   unordered_map&lt;<span class="type">int</span>, TcpConnectionPtr&gt; m_userConnectionMap;</span><br></pre></td></tr></table></div></figure>

        <h4 id="mutex-m_connmutex"   >
          <a href="#mutex-m_connmutex" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mutex-m_connmutex"></a> <code>mutex m_connMutex</code></h4>
      
<p>定义互斥锁，保证<code>m_userConnectionMap</code>的线程安全</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">/* 定义互斥锁，保证m_userConnectionMap的线程安全 */</span></span><br><span class="line">   mutex _connMutex;</span><br></pre></td></tr></table></div></figure>

        <h4 id="数据操作类对象"   >
          <a href="#数据操作类对象" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据操作类对象"></a> 数据操作类对象</h4>
      
<ol>
<li>UserModel - <code>m_userModel</code></li>
<li>OfflineMsgModel - <code>m_offlineMsgModel</code></li>
<li>FriendModel - <code>friendModel</code></li>
<li>GroupModel - <code>groupModel</code></li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   UserModel       _userModel;         <span class="comment">/* 数据操作类对象 */</span></span><br><span class="line">   OfflineMsgModel _offlineMsgModel;   <span class="comment">/* 数据操作类对象 */</span></span><br><span class="line">   FriendModel     _friendModel;       <span class="comment">/* 数据操作类对象 */</span></span><br><span class="line">   GroupModel      _groupModel;        <span class="comment">/* 数据操作类对象 */</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数-2"   >
          <a href="#成员函数-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-2"></a> 成员函数</h3>
      

        <h4 id="构造函数单例"   >
          <a href="#构造函数单例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#构造函数单例"></a> 构造函数（⭐单例）</h4>
      
<p>私有化, 单例处理</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">static</span> ChatService * <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">ChatService</span>();</span><br></pre></td></tr></table></div></figure>

        <h4 id="业务接口"   >
          <a href="#业务接口" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#业务接口"></a> 业务接口</h4>
      
<ol>
<li>login - 登陆业务</li>
<li>reg - 注册业务</li>
<li>addFriend - 添加好友业务</li>
<li>oneChat - 一对一聊天业务</li>
<li>createGroup - 创建群组业务</li>
<li>addGroup - 加入群组业务</li>
<li>groupChat - 群组聊天业务</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 处理登录业务 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">   <span class="comment">/* 处理注册业务 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">reg</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 添加好友业务 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">addFriend</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">   <span class="comment">/* 一对一聊天业务 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">oneChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建群组业务 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">createGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">   <span class="comment">/* 加入群组业务 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">addGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">   <span class="comment">/* 群组聊天业务 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">groupChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="gethandler"   >
          <a href="#gethandler" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#gethandler"></a> getHandler</h4>
      
<p>获取消息对应的处理器</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 获取消息对应的处理器 */</span></span><br><span class="line">   <span class="function">MsgHandler <span class="title">getHandler</span><span class="params">(<span class="type">int</span> msgid)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="clientcloseexception"   >
          <a href="#clientcloseexception" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#clientcloseexception"></a> clientCloseException</h4>
      
<p>处理客户端异常退出</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 处理客户端异常退出 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">clientCloseException</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp; conn)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="reset"   >
          <a href="#reset" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#reset"></a> reset</h4>
      
<p>业务重置方法，通常在服务器异常退出时调用</p>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 业务重置方法，通常在服务器异常退出时调用 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="头文件-2"   >
          <a href="#头文件-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#头文件-2"></a> 头文件</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHATSERVICE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHATSERVICE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;usermodel.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;offlinemsgmodel.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;friendmodel.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;groupmodel.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示处理消息的事件回调方法类型 */</span></span><br><span class="line"><span class="keyword">using</span> MsgHandler = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr&amp;, json&amp;, Timestamp)&gt;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天服务器业务类. </span></span><br><span class="line"><span class="comment"> * 用映射关系来存储消息id和具体处理函数. </span></span><br><span class="line"><span class="comment"> * 此类有一个实例就够了，所以采用单例模式. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatService</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 获取单例对象的接口函数 */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ChatService* <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 处理登录业务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">    <span class="comment">/* 处理注册业务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reg</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加好友业务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFriend</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">    <span class="comment">/* 一对一聊天业务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oneChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建群组业务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">    <span class="comment">/* 加入群组业务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line">    <span class="comment">/* 群组聊天业务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">groupChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 获取消息对应的处理器 */</span></span><br><span class="line">    <span class="function">MsgHandler <span class="title">getHandler</span><span class="params">(<span class="type">int</span> msgid)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 处理客户端异常退出 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clientCloseException</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp; conn)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 业务重置方法，通常在服务器异常退出时调用 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ChatService</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UserModel       _userModel;         <span class="comment">/* 数据操作类对象 */</span></span><br><span class="line">    OfflineMsgModel _offlineMsgModel;   <span class="comment">/* 数据操作类对象 */</span></span><br><span class="line">    FriendModel     _friendModel;       <span class="comment">/* 数据操作类对象 */</span></span><br><span class="line">    GroupModel      _groupModel;        <span class="comment">/* 数据操作类对象 */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义互斥锁，保证m_userConnectionMap的线程安全 */</span></span><br><span class="line">    mutex _connMutex;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 存储消息id和其对应的业务处理方法 */</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, MsgHandler&gt; _msgHandlerMap;</span><br><span class="line">    <span class="comment">/* 存储在线用户的通信连接 */</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, TcpConnectionPtr&gt; _userConnectionMap;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h2 id="登录业务需要处理的长连接问题-线程安全问题"   >
          <a href="#登录业务需要处理的长连接问题-线程安全问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#登录业务需要处理的长连接问题-线程安全问题"></a> （⭐）登录业务需要处理的长连接问题、线程安全问题</h2>
      
<p>需要ChatService类中有一个记录用户的连接状态才行。<br />
因为聊天服务器需要保持一个给用户推送消息的状态。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, TcpConnectionPtr&gt; _userConnMap;</span><br><span class="line">    mutex _connMutex;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理登录业务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                        json &amp;js, Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 从json参数获取账号、密码信息 */</span></span><br><span class="line">    <span class="type">int</span> id = js[<span class="string">&quot;id&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    string password = js[<span class="string">&quot;password&quot;</span>];</span><br><span class="line">    User user = _userModel.<span class="built_in">query</span>(id);</span><br><span class="line"></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">&quot;msgid&quot;</span>] = LOGIN_MSG_ACK;</span><br><span class="line">    <span class="keyword">if</span>(user.<span class="built_in">getId</span>() == id &amp;&amp; user.<span class="built_in">getPassword</span>() == password)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(user.<span class="built_in">getState</span>() == <span class="string">&quot;online&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 该用户已经登录在线，不允许重复登陆 */</span></span><br><span class="line">            response[<span class="string">&quot;errno&quot;</span>] = LOGIN_REPEAT;</span><br><span class="line">            response[<span class="string">&quot;errmsg&quot;</span>] = <span class="string">&quot;该用户已经登录&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(user.<span class="built_in">getState</span>() == <span class="string">&quot;offline&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 登陆成功 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 记录用户连接信息 */</span></span><br><span class="line">                lock_guard&lt;mutex&gt; <span class="built_in">lock</span>(_connMutex);</span><br><span class="line">                _userConnectionMap.<span class="built_in">insert</span>(&#123;id, conn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CLUSTER__</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 集群环境下, 向redis订阅此id </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            m_redis.<span class="built_in">subscribe</span>(id);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">/* 更新用户状态信息 */</span></span><br><span class="line">            user.<span class="built_in">setState</span>(<span class="string">&quot;online&quot;</span>);</span><br><span class="line">            _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">            response[<span class="string">&quot;errno&quot;</span>] = LOGIN_SUCCEESS;</span><br><span class="line">            response[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">            response[<span class="string">&quot;name&quot;</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">            <span class="comment">/* 查询该用户是否在离线时未收到的消息 */</span></span><br><span class="line">            vector&lt;string&gt; offlineMsgVec = _offlineMsgModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!offlineMsgVec.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                response[<span class="string">&quot;offlinemsg&quot;</span>] = offlineMsgVec;</span><br><span class="line">                <span class="comment">/* 把该用户的所有离线消息从从数据中删除掉 */</span></span><br><span class="line">                _offlineMsgModel.<span class="built_in">remove</span>(id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 查询该用户的好友信息，并返回 */</span></span><br><span class="line">            vector&lt;User&gt; userVec = _friendModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!userVec.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;string&gt; friendJsonInfoVec;</span><br><span class="line">                <span class="keyword">for</span>(User &amp;user : userVec)</span><br><span class="line">                &#123;</span><br><span class="line">                    json js;</span><br><span class="line">                    js[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">                    js[<span class="string">&quot;name&quot;</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">                    js[<span class="string">&quot;state&quot;</span>] = user.<span class="built_in">getState</span>();</span><br><span class="line">                    friendJsonInfoVec.<span class="built_in">push_back</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                response[<span class="string">&quot;friends&quot;</span>] = friendJsonInfoVec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(user.<span class="built_in">getId</span>() != id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 登录失败，用户不存在 */</span></span><br><span class="line">        response[<span class="string">&quot;errno&quot;</span>] = LOGIN_NOTFOUND;</span><br><span class="line">        response[<span class="string">&quot;errmsg&quot;</span>] = <span class="string">&quot;用户不存在&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(user.<span class="built_in">getPassword</span>() != password)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 登录失败，密码不匹配 */</span></span><br><span class="line">        response[<span class="string">&quot;errno&quot;</span>] = LOGIN_WRONGPWD;</span><br><span class="line">        response[<span class="string">&quot;errmsg&quot;</span>] = <span class="string">&quot;密码验证失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="离线消息的处理包括集群环境下"   >
          <a href="#离线消息的处理包括集群环境下" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#离线消息的处理包括集群环境下"></a> （⭐）离线消息的处理（包括集群环境下）</h2>
      
<p>用OfflineMessage数据表存储离线消息。<br />
当用户登陆时，ChatService去数据表查询是否有该用户id的离线消息。如果有，则推送。</p>
<p>当处于集群环境时，某一台服务器中的<code>_userConnectionMap</code>只记录了在该服务器在线的用户，<br />
所以用户可能在本服务器offline，而在其他服务器上online，<br />
所以真实的在线状态应该去数据库的<code>User</code>表中查询（<code>_userModel.query(id); user.getState() == &quot;online&quot;;</code>）<br />
如果真的是offline，则才存储离线消息。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一对一聊天业务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::oneChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> to = js[<span class="string">&quot;to&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = _userConnectionMap.<span class="built_in">find</span>(to);</span><br><span class="line">        <span class="keyword">if</span>(it != _userConnectionMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 接收方在线，转发消息 */</span></span><br><span class="line">            <span class="comment">/* 服务器主动推送消息给接收方 */</span></span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());    <span class="comment">// it-&gt;second 表示 </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CLUSTER__</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群环境下, 需要查询对方(to)是否在线;</span></span><br><span class="line"><span class="comment">     * 不可通过服务器connMap查询, 是通过数据库信息;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User user = _userModel.<span class="built_in">query</span>(to);</span><br><span class="line">    <span class="keyword">if</span>(user.<span class="built_in">getState</span>() == <span class="string">&quot;online&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_redis.<span class="built_in">publish</span>(to, js.<span class="built_in">dump</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 接收方离线，存储离线消息 */</span></span><br><span class="line">    _offlineMsgModel.<span class="built_in">insert</span>(to, js.<span class="built_in">dump</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 群组聊天业务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::groupChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid = js[<span class="string">&quot;id&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="type">int</span> groupid = js[<span class="string">&quot;groupid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; useridVec = _groupModel.<span class="built_in">queryGroupUsers</span>(userid, groupid);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> offline = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> reallyOffline = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id : useridVec)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> it = _userConnectionMap.<span class="built_in">find</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(it != _userConnectionMap.<span class="built_in">end</span>())<span class="comment">//在本台服务器上线</span></span><br><span class="line">            &#123;</span><br><span class="line">                offline = <span class="literal">false</span>;</span><br><span class="line">                reallyOffline = <span class="literal">false</span>;</span><br><span class="line">                it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CLUSTER__</span></span><br><span class="line">        <span class="keyword">if</span>(offline)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 集群环境下, 需要判断其是否在其他服务器上在线;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            User user = _userModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(user.<span class="built_in">getState</span>() == <span class="string">&quot;online&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                reallyOffline = <span class="literal">false</span>;</span><br><span class="line">                m_redis.<span class="built_in">publish</span>(id, js.<span class="built_in">dump</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span>(reallyOffline)</span><br><span class="line">        &#123;</span><br><span class="line">            _offlineMsgModel.<span class="built_in">insert</span>(id, js.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        reallyOffline = <span class="literal">true</span>;</span><br><span class="line">        offline = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理登录业务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                        json &amp;js, Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 从json参数获取账号、密码信息 */</span></span><br><span class="line">    <span class="type">int</span> id = js[<span class="string">&quot;id&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    string password = js[<span class="string">&quot;password&quot;</span>];</span><br><span class="line">    User user = _userModel.<span class="built_in">query</span>(id);</span><br><span class="line"></span><br><span class="line">    json response;</span><br><span class="line">    response[<span class="string">&quot;msgid&quot;</span>] = LOGIN_MSG_ACK;</span><br><span class="line">    <span class="keyword">if</span>(user.<span class="built_in">getId</span>() == id &amp;&amp; user.<span class="built_in">getPassword</span>() == password)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(user.<span class="built_in">getState</span>() == <span class="string">&quot;online&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 该用户已经登录在线，不允许重复登陆 */</span></span><br><span class="line">            response[<span class="string">&quot;errno&quot;</span>] = LOGIN_REPEAT;</span><br><span class="line">            response[<span class="string">&quot;errmsg&quot;</span>] = <span class="string">&quot;该用户已经登录&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(user.<span class="built_in">getState</span>() == <span class="string">&quot;offline&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 登陆成功 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 记录用户连接信息 */</span></span><br><span class="line">                lock_guard&lt;mutex&gt; <span class="built_in">lock</span>(_connMutex);</span><br><span class="line">                _userConnectionMap.<span class="built_in">insert</span>(&#123;id, conn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CLUSTER__</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 集群环境下, 向redis订阅此id </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            m_redis.<span class="built_in">subscribe</span>(id);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">/* 更新用户状态信息 */</span></span><br><span class="line">            user.<span class="built_in">setState</span>(<span class="string">&quot;online&quot;</span>);</span><br><span class="line">            _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">            response[<span class="string">&quot;errno&quot;</span>] = LOGIN_SUCCEESS;</span><br><span class="line">            response[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">            response[<span class="string">&quot;name&quot;</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">            <span class="comment">/* 查询该用户是否在离线时未收到的消息 */</span></span><br><span class="line">            vector&lt;string&gt; offlineMsgVec = _offlineMsgModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!offlineMsgVec.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                response[<span class="string">&quot;offlinemsg&quot;</span>] = offlineMsgVec;</span><br><span class="line">                <span class="comment">/* 把该用户的所有离线消息从从数据中删除掉 */</span></span><br><span class="line">                _offlineMsgModel.<span class="built_in">remove</span>(id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 查询该用户的好友信息，并返回 */</span></span><br><span class="line">            vector&lt;User&gt; userVec = _friendModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!userVec.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;string&gt; friendJsonInfoVec;</span><br><span class="line">                <span class="keyword">for</span>(User &amp;user : userVec)</span><br><span class="line">                &#123;</span><br><span class="line">                    json js;</span><br><span class="line">                    js[<span class="string">&quot;id&quot;</span>] = user.<span class="built_in">getId</span>();</span><br><span class="line">                    js[<span class="string">&quot;name&quot;</span>] = user.<span class="built_in">getName</span>();</span><br><span class="line">                    js[<span class="string">&quot;state&quot;</span>] = user.<span class="built_in">getState</span>();</span><br><span class="line">                    friendJsonInfoVec.<span class="built_in">push_back</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                response[<span class="string">&quot;friends&quot;</span>] = friendJsonInfoVec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(user.<span class="built_in">getId</span>() != id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 登录失败，用户不存在 */</span></span><br><span class="line">        response[<span class="string">&quot;errno&quot;</span>] = LOGIN_NOTFOUND;</span><br><span class="line">        response[<span class="string">&quot;errmsg&quot;</span>] = <span class="string">&quot;用户不存在&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(user.<span class="built_in">getPassword</span>() != password)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 登录失败，密码不匹配 */</span></span><br><span class="line">        response[<span class="string">&quot;errno&quot;</span>] = LOGIN_WRONGPWD;</span><br><span class="line">        response[<span class="string">&quot;errmsg&quot;</span>] = <span class="string">&quot;密码验证失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="数据模块"   >
          <a href="#数据模块" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据模块"></a> 数据模块</h1>
      

        <h2 id="业务模块与数据模块解耦-orm框架"   >
          <a href="#业务模块与数据模块解耦-orm框架" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#业务模块与数据模块解耦-orm框架"></a> （⭐）业务模块与数据模块解耦 - ORM框架</h2>
      
<blockquote>
<p>Object Relation Map - 对象关系映射。</p>
</blockquote>
<p>在这个框架中，业务层操作的都是对象，看不到具体的SQL操作。</p>
<p>在DAO层（数据层），才有具体的数据库操作。</p>
<p>解决了痛点：业务模块、数据模块之间的解耦。</p>

        <h2 id="搭建mysql数据库环境"   >
          <a href="#搭建mysql数据库环境" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#搭建mysql数据库环境"></a> 搭建MySQL数据库环境</h2>
      
<p>(以下命令基于Ubuntu环境)</p>
<ol>
<li>安装mysql-server和mysql开发包, 包括mysql头文件和动态库文件</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install mysql-server		<span class="comment">#安装最新版MySQL服务器</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install libmysqlclient-dev <span class="comment">#安装开发包</span></span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>初始的用户名和密码是自动生成的，按下面步骤修改mysql的root用户密码为123456</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /etc/mysql/debian.cnf</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">host = localhost</span><br><span class="line">user = debian-sys-maint 			<span class="comment">#初始的用户名</span></span><br><span class="line">password = Kk3TbShbFNvjvhpM			<span class="comment">#初始的密码</span></span><br><span class="line">socket = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></div></figure>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用上面初始的用户名和密码，登录mysql server，修改root用户的密码，命令如下：</span></span><br><span class="line">~$ mysql -u debian-sys-maint -pKk3TbShbFNvjvhpM</span><br><span class="line"><span class="comment">#-u后面是上面查看的用户名; -p后面紧跟上面查看的密码</span></span><br></pre></td></tr></table></div></figure>
<p>更改密码：参考 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/mrcan666/article/details/124163537?spm=1001.2014.3001.5502" >https://blog.csdn.net/mrcan666/article/details/124163537?spm=1001.2014.3001.5502</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ol start="3">
<li>设置MySQL字符编码utf-8，以支持中文操作</li>
</ol>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;char%&quot;; # 先查看MySQL默认的字符编码</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name			   | Value			   			|</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | latin1                     |#不支持中文！！！</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set character_set_server=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></div></figure>
<ol start="4">
<li>修改表的字符编码：<code>alter table user default character set utf8;</code></li>
<li>修改属性的字符编码：<code>alter table user modify column name varchar(50) character set utf8;</code></li>
</ol>

        <h2 id="mysql类-封装mysql操作"   >
          <a href="#mysql类-封装mysql操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mysql类-封装mysql操作"></a> MySQL类 - 封装MySQL操作</h2>
      
<p>需要引入<code>mysql/mysql.h</code>头文件</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br></pre></td></tr></table></div></figure>

        <h3 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量"></a> 成员变量</h3>
      

        <h4 id="mysql-m_conn"   >
          <a href="#mysql-m_conn" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mysql-m_conn"></a> <code>MYSQL *m_conn</code></h4>
      
<p>记录MYSQL类型的指针, 以获取这个mysql连接</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *m_conn;</span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数-3"   >
          <a href="#成员函数-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-3"></a> 成员函数</h3>
      

        <h4 id="构造析构"   >
          <a href="#构造析构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#构造析构"></a> 构造/析构</h4>
      
<p>初始化/释放数据库连接</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 初始化数据库连接 */</span></span><br><span class="line">   <span class="built_in">MySQL</span>();</span><br><span class="line">   <span class="comment">/* 释放数据库连接资源 */</span></span><br><span class="line">   ~<span class="built_in">MySQL</span>();</span><br></pre></td></tr></table></div></figure>

        <h4 id="getconnection"   >
          <a href="#getconnection" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#getconnection"></a> getConnection</h4>
      
<p>获取连接, 即获取成员<code>m_conn</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 获取连接 */</span></span><br><span class="line">   <span class="function">MYSQL * <span class="title">getConnection</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="connect"   >
          <a href="#connect" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#connect"></a> connect</h4>
      
<p>连接数据库, 返回值为bool, 说明连接成功与否</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 连接数据库 */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="query"   >
          <a href="#query" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#query"></a> query</h4>
      
<p>查询操作, 参数是string类型的sql语句, 返回值为<code>MYSQL_RES</code>, 即MySQL结果集类型</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 查询操作 */</span></span><br><span class="line">   <span class="function">MYSQL_RES * <span class="title">query</span><span class="params">(string sql)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="update"   >
          <a href="#update" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#update"></a> update</h4>
      
<p>更新操作, 参数是string类型的sql语句, 返回值为bool, 说明更新成功与否</p>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 更新操作 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="代码实现"   >
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3>
      
<p>前置全局声明</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span>	<span class="comment">//日志工具</span></span></span><br><span class="line"><span class="comment">/* 数据库配置信息 */</span></span><br><span class="line"><span class="type">static</span> string server = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">static</span> string user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">static</span> string password = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">static</span> string dbname = <span class="string">&quot;chat&quot;</span>;</span><br></pre></td></tr></table></div></figure>

        <h4 id="构造-2"   >
          <a href="#构造-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#构造-2"></a> 构造</h4>
      
<p>调用<code>mysql_init</code>, 实际上只是对mysql连接进行空间资源的开辟, 返回一个指针赋给<code>m_conn</code>成员, 没有真正连接, 因此传入nullptr</p>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化数据库连接 */</span></span><br><span class="line">MySQL::<span class="built_in">MySQL</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="析构"   >
          <a href="#析构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#析构"></a> 析构</h4>
      
<p>调用<code>mysql_close(m_conn)</code>, 对MySQL连接资源进行释放</p>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 释放数据库连接资源 */</span></span><br><span class="line">MySQL::~<span class="built_in">MySQL</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_conn != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">mysql_close</span>(m_conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="getconnection-2"   >
          <a href="#getconnection-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#getconnection-2"></a> getConnection</h4>
      
<p>获取连接, 即返回<code>m_conn</code>成员</p>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取连接 */</span></span><br><span class="line"><span class="function">MYSQL * <span class="title">MySQL::getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="connect-2"   >
          <a href="#connect-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#connect-2"></a> connect</h4>
      
<p>连接数据库, 内部调用<code>mysql_real_connect</code>, 传入<code>m_conn</code>, 以及server地址, user号, 密码, 要连接的数据库name, 服务器端口;</p>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 连接数据库 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MySQL::connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(m_conn, server.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),</span><br><span class="line">                                  password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), <span class="number">3306</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* C/C++代码默认的编码字符是ASCII，如果不设置，则从MySQL上拉下来的中文无法正常显示 */</span></span><br><span class="line">        <span class="built_in">mysql_query</span>(m_conn, <span class="string">&quot;set name gbk&quot;</span>);</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;connect mysql success!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;connect mysql failed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="query-2"   >
          <a href="#query-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#query-2"></a> query</h4>
      
<p>查询操作</p>
<ol>
<li>内部调用<code>mysql_query</code>, 传入<code>m_conn</code>, <code>sql-string</code>的C风格字符串首址；
<ol>
<li><code>mysql_query</code>的返回值：
<ol>
<li>如果查询成功，返回0;</li>
<li>如果出现错误，返回非0值。</li>
<li>返回值需要调用<code>mysql_use_result(m_conn)</code>获取结果集, 再return</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查询操作 */</span></span><br><span class="line"><span class="function">MYSQL_RES * <span class="title">MySQL::query</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(m_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; sql &lt;&lt; <span class="string">&quot;查询失败!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_use_result</span>(m_conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>update - 更新操作
<ol>
<li>内部调用<code>mysql_query</code>, 传入<code>m_conn</code>, <code>sql-string</code>的C风格字符串首址;</li>
<li>判断<code>mysql_query</code>的返回值, 若为<strong>非 0 则更新失败</strong>; 若为 <strong>0 则更新成功</strong>;</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 更新操作 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MySQL::update</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(m_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; sql &lt;&lt; <span class="string">&quot;更新失败!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="model层-对业务层封装底层数据库的操作"   >
          <a href="#model层-对业务层封装底层数据库的操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#model层-对业务层封装底层数据库的操作"></a> Model层 - 对业务层封装底层数据库的操作</h2>
      
<p>以User类的操作为例</p>

        <h3 id="user类"   >
          <a href="#user类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#user类"></a> User类</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 属于映射类;</span></span><br><span class="line"><span class="comment"> * 匹配User表的ORM类;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">int</span> id = <span class="number">-1</span>, string name=<span class="string">&quot;&quot;</span>, string password=<span class="string">&quot;&quot;</span>, string state=<span class="string">&quot;offline&quot;</span>)</span><br><span class="line">        : <span class="built_in">id_</span>(id), <span class="built_in">name_</span>(name), <span class="built_in">password_</span>(password), <span class="built_in">state_</span>(state)</span><br><span class="line">    &#123;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;id_ = id;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;name_ = name;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPassword</span><span class="params">(string password)</span></span>&#123;password_ = password;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(string state)</span></span>&#123;state_ = state;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> id_;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> name_;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getPassword</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> password_;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> state_;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id_;</span><br><span class="line">    string name_;</span><br><span class="line">    string password_;</span><br><span class="line">    string state_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h3 id="usermodel类"   >
          <a href="#usermodel类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#usermodel类"></a> UserModel类</h3>
      
<ol>
<li>insert - 参数为User的引用, 返回值为bool</li>
<li>query - 参数为id, 返回值为User</li>
<li>updateState - 更新用户的状态信息, 参数为User的一个临时副本, 返回bool</li>
<li>resetAllState - 重置所有用户的状态信息</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USERMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USERMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;user.hpp&quot;</span></span></span><br><span class="line"><span class="comment">/* User表的数据操作类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserModel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* User表的增加方法 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(User &amp;user)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 根据用户号码查询用户信息 */</span></span><br><span class="line">    <span class="function">User <span class="title">query</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 更新用户的状态信息 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">updateState</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">/* 重置所有用户的状态信息 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetAllState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h3 id="代码实现-2"   >
          <a href="#代码实现-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;usermodel.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;db.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* User表的增加方法 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UserModel::insert</span><span class="params">(User &amp;user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1.组装SQL语句 */</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into user(name, password, state) values(&#x27;%s&#x27;, &#x27;%s&#x27;, &#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">        user.<span class="built_in">getName</span>().<span class="built_in">c_str</span>(), user.<span class="built_in">getPassword</span>().<span class="built_in">c_str</span>(), user.<span class="built_in">getState</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mysql.<span class="built_in">update</span>(sql))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 获取插入成功的用户数据生成的主键id */</span></span><br><span class="line">            <span class="comment">/* 以下的mysql_insert_id是生成id的方法之一 */</span></span><br><span class="line">            user.<span class="built_in">setId</span>(<span class="built_in">mysql_insert_id</span>(mysql.<span class="built_in">getConnection</span>()));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 注册失败 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 根据用户号码查询用户信息 */</span></span><br><span class="line"><span class="function">User <span class="title">UserModel::query</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1.组装SQL语句 */</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;select * from user where id = %d&quot;</span>, id);</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* mysql.query内部申请了资源，处理完成User的构造后，需要free */</span></span><br><span class="line">        MYSQL_RES *res = mysql.<span class="built_in">query</span>(sql);  <span class="comment">// 此query为MySQL的query，和update同级。</span></span><br><span class="line">        <span class="keyword">if</span>(res != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res);</span><br><span class="line">            <span class="keyword">if</span>(row != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                User user;</span><br><span class="line">                user.<span class="built_in">setId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">                user.<span class="built_in">setName</span>(row[<span class="number">1</span>]);</span><br><span class="line">                user.<span class="built_in">setPassword</span>(row[<span class="number">2</span>]);</span><br><span class="line">                user.<span class="built_in">setState</span>(row[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果没有有效的查询结果，返回一个默认User，id为-1，表示出错 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">User</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 更新用户的状态信息 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UserModel::updateState</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1.组装SQL语句 */</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;update user set state = &#x27;%s&#x27; where id = %d&quot;</span>, user.<span class="built_in">getState</span>().<span class="built_in">c_str</span>(), user.<span class="built_in">getId</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mysql.<span class="built_in">update</span>(sql))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 重置所有用户的状态信息 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserModel::resetAllState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] = <span class="string">&quot;update user set state = &#x27;offline&#x27; where state = &#x27;online&#x27;&quot;</span>;</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="测试"   >
          <a href="#测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1>
      
<p>点对点聊天</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ChatServer</span><br></pre></td></tr></table></div></figure>
<p>点对点聊天的json格式：<code>&#123;&quot;msgid&quot;:5,&quot;from&quot;:&quot;from_name&quot;,&quot;to&quot;:to_id,&quot;msg&quot;:&quot;......&quot;&#125;</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 注册</span><br><span class="line">telnet 127.0.0.1 6000</span><br><span class="line">&#123;&quot;msgid&quot;:3,&quot;name&quot;:&quot;test0511&quot;,&quot;password&quot;:&quot;123&quot;&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#登录后一对一聊天</span><br><span class="line">&#123;&quot;msgid&quot;:1,&quot;id&quot;:22,&quot;password&quot;:&quot;123&quot;&#125;</span><br><span class="line">&#123;&quot;msgid&quot;:6,&quot;from&quot;:&quot;test0511&quot;,&quot;to&quot;:13,&quot;msg&quot;:&quot;hello zhang san, i am test0511!&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;msgid&quot;:1,&quot;id&quot;:13,&quot;password&quot;:&quot;123456&quot;&#125;</span><br><span class="line">&#123;&quot;msgid&quot;:6,&quot;from&quot;:&quot;zhang san&quot;,&quot;to&quot;:22,&quot;msg&quot;:&quot;hello test0511, i&#x27;m zhang san!&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xcg</span></span><br><span class="line">telnet 127.0.0.1 6000</span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:1,<span class="string">&quot;id&quot;</span>:22,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;	<span class="comment">#登录</span></span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:5,<span class="string">&quot;from&quot;</span>:<span class="string">&quot;xcg&quot;</span>,<span class="string">&quot;to&quot;</span>:13,<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;hello zhang san, i&#x27;m xcg!&quot;</span>&#125;	<span class="comment">#发送消息</span></span><br><span class="line"><span class="comment"># 发送离线消息</span></span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:5,<span class="string">&quot;from&quot;</span>:<span class="string">&quot;xcg&quot;</span>,<span class="string">&quot;to&quot;</span>:13,<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;hello - 1&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:5,<span class="string">&quot;from&quot;</span>:<span class="string">&quot;xcg&quot;</span>,<span class="string">&quot;to&quot;</span>:13,<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;hello - 2&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:5,<span class="string">&quot;from&quot;</span>:<span class="string">&quot;xcg&quot;</span>,<span class="string">&quot;to&quot;</span>:13,<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;hello - 3&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zhang san</span></span><br><span class="line">telnet 127.0.0.1 6000</span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:1,<span class="string">&quot;id&quot;</span>:13,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;	<span class="comment">#登录</span></span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:6,<span class="string">&quot;from&quot;</span>:<span class="string">&quot;zhang san&quot;</span>,<span class="string">&quot;to&quot;</span>:22,<span class="string">&quot;msg&quot;</span>:<span class="string">&quot;hello xcg, i&#x27;m zhang san!&quot;</span>&#125;#发送消息</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h1 id="好友业务"   >
          <a href="#好友业务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#好友业务"></a> 好友业务</h1>
      
<ol>
<li>显示有哪些已添加的好友，id</li>
<li>添加好友</li>
</ol>
<p>但是业务并不严格，只要知道其id即可聊天。</p>
<p>总体业务流程：向服务器发起添加好友的请求，服务器就把关系添加到friend表中，初版本不用征询对方的同意。</p>
<p>friend表就两个字段：<code>userid</code>、<code>friendid</code>是联合主键。</p>

        <h2 id="测试-2"   >
          <a href="#测试-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试-2"></a> 测试</h2>
      
<p>添加好友、登陆成功后显示好友列表</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ChatServer</span><br></pre></td></tr></table></div></figure>
<p>添加好友的JSON格式：<code>&#123;&quot;msgid&quot;:6,&quot;id&quot;:22,&quot;friendid&quot;:13&#125;</code>。此语句意为：id为22的用户主动添加id为13的用户为好友，建立双向关系。</p>
<p>添加后，查看friend表中是否有信息，应有一个<code>id:22 - friendid:13</code>。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from friend;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xcg</span></span><br><span class="line">telnet 127.0.0.1 6000</span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:1,<span class="string">&quot;id&quot;</span>:22,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;	<span class="comment"># 登录</span></span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:6,<span class="string">&quot;id&quot;</span>:22,<span class="string">&quot;friendid&quot;</span>:13&#125;	<span class="comment"># 添加id:13为好友</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ctrl + ] -&gt; quit 退出</span></span><br><span class="line"><span class="comment"># 重新登陆</span></span><br><span class="line">telnet 127.0.0.1 6000</span><br><span class="line">&#123;<span class="string">&quot;msgid&quot;</span>:1,<span class="string">&quot;id&quot;</span>:22,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123&quot;</span>&#125;	<span class="comment"># 登录</span></span><br><span class="line"><span class="comment"># 看看是否返回好友列表</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="群组业务"   >
          <a href="#群组业务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#群组业务"></a> 群组业务</h1>
      
<ol>
<li>管理员创建群</li>
<li>用户加入群</li>
<li>群聊</li>
</ol>

        <h2 id="表"   >
          <a href="#表" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#表"></a> 表</h2>
      
<p>与群组业务相关的有两张表：一个是<code>AllGroup</code>表，一个是<code>GroupUser</code>表。</p>
<p>AllGroup表有三个字段：id、groupname、groupdesc(群组描述)</p>
<p>GroupUser表，因为群和成员之间是多对多的关系，所以需要此中间表来描述这个关系。有三个字段：<code>groupid</code>、<code>userid</code>、<code>grouprole</code>(成员在群中的权限)。</p>
<p><code>groupid</code>和<code>userid</code>是联合主键。</p>
<p>这两张表都是处理群组业务的，所以对应的model只创建了一个。</p>

        <h2 id="model"   >
          <a href="#model" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#model"></a> model</h2>
      
<p>groupmodel.hpp</p>

        <h1 id="负载均衡"   >
          <a href="#负载均衡" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h1>
      
<p>负载均衡器, 亦叫做反向代理服务器, 在集群服务器架构中, 作为统一接收客户端请求的端口。</p>
<p>其根据配置所界定的负载算法，把客户端的请求分发到业务服务器上。</p>
<p>要做的三件事情：</p>
<ol>
<li>把 client 的请求按照负载均衡算法分发到具体的业务服务器 ChatServer 上面；
<ol>
<li>相应地, 服务器的响应也要经过负载均衡器, 准确地返回给这个 client 。</li>
<li>服务器的响应消息，也可以通过服务器和客户端建立一个 IP 隧道实现，达到直接连接, 这样的效率更好;</li>
</ol>
</li>
<li>能够和 ChatServer 保持心跳机制，监测 ChatServer 故障；</li>
<li>能够发现新添加的 ChatServer 设备，方便扩展服务器数量，最好是能够平滑地完成这个过程，而不是需要重启负载均衡服务器导致服务停止。</li>
</ol>

        <h2 id="nginx负载均衡模块"   >
          <a href="#nginx负载均衡模块" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx负载均衡模块"></a> nginx负载均衡模块</h2>
      
<p>本项目选择 Nginx 的 TCP 负载均衡模块，要解决的问题</p>
<ol>
<li>如何进行 Nginx 源码编译，包含 TCP 负载均衡模块</li>
<li><code>nginx.conf</code> 配置文件中如何配置负载均衡</li>
<li>Nginx 的平滑加载配置文件启动</li>
</ol>
<p>nginx在1.9版本之前，只支持http协议web服务器的负载均衡，<br />
<strong>从1.9版本开始以后，Nginx开始支持 TCP 的长连接负载均衡</strong>，<br />
但是 Nginx 默认不编译 TCP 负载均衡模块，<br />
编写它时，需要加入<code>--with-stream</code>参数来激活这个模块。</p>

        <h3 id="编译安装流程记得带-with-stream"   >
          <a href="#编译安装流程记得带-with-stream" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#编译安装流程记得带-with-stream"></a> 编译安装流程（记得带<code>--with-stream</code>）</h3>
      
<p>以<code>nginx-1.12.2.tar.gz</code>为例;</p>
<p>nginx编译安装需要先安装pcre、openssl、zlib等库。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>对开源产品发行源代码的编译安装, 一般都是:</p>
<ol>
<li>先执行<code>./configure</code>, 生产相应的makefile文件;</li>
<li><code>make</code>, 进行编译</li>
<li><code>make install</code>, 进行安装</li>
</ol>
</blockquote>
<p>解压<code>nginx-1.12.2.tar.gz</code>后，进入<code>nginx-1.12.2</code>目录，<br />
先运行<code>./configure --with-stream</code>生成<code>Makefile</code>后，<br />
运行<code>make</code>，最后<code>make install</code>。<br />
make install命令会向系统路径拷贝文件，所以需要在root用户下执行。</p>
<p>编译完成后，默认安装在了<code>/usr/local/nginx</code>目录。</p>
<p><code>nginx</code>目录下，可执行文件在<code>sbin</code>目录里，配置文件在<code>conf</code>目录里。</p>

        <h3 id="配置文件"   >
          <a href="#配置文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h3>
      
<p>如何配置负载均衡?</p>
<p><code>/usr/local/nginx/conf/nginx.conf</code>中, 可以看到http字段, 这是基于http的负载均衡配置;</p>
<figure class="highlight nginx"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /var/www/hexo;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>而本项目是 TCP 服务器, 需要写到<code>stream</code>下, 表示基于TCP的负载均衡配置;</p>
<ol>
<li>server字段
<ol>
<li>listen - nginx负载均衡器将要监听的端口号</li>
<li><code>proxy_pass</code> - 所有在listen字段端口号上的请求都将分发到这个标记字段所填充到信息中</li>
</ol>
</li>
<li>upstream字段 - 可用于负载均衡的服务器信息
<ol>
<li><code>server IP:Port weight=权重 max_fail=最多失败次数 fail_timeout=最长等待响应时间</code></li>
</ol>
</li>
</ol>
<figure class="highlight nginx"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx tcp loadbalance config</span></span><br><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> MyServer &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:6000</span> weight=<span class="number">1</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:6002</span> weight=<span class="number">1</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># proxy connect timeout 1s;</span></span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">8000</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> MyServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="常用操作"   >
          <a href="#常用操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#常用操作"></a> 常用操作</h3>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload		<span class="comment"># 重新加载配置文件，平滑启动</span></span><br><span class="line">nginx -s stop		<span class="comment"># 停止nginx服务</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="nginx的网络模型设计accpet锁解决惊群现象reactors-in-process-one-loop-per-process"   >
          <a href="#nginx的网络模型设计accpet锁解决惊群现象reactors-in-process-one-loop-per-process" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx的网络模型设计accpet锁解决惊群现象reactors-in-process-one-loop-per-process"></a> Nginx的网络模型设计（accpet锁解决惊群现象）（reactors in process - one loop per process）</h3>
      
<p>我们上面的网络IO模块的 muduo 的网络设计是：reactors in threads - one loop per thread.</p>
<p>而 Nginx 服务器的网络模块设计是基于进程的，采用多个 Reactor 充当 I/O 进程和工作<strong>进程</strong>，通过一把 accept 锁完美解决多个 Reactors 的惊群现象。<br />
因此Nginx服务器的模型是：<strong>reactors in process - one loop per process</strong></p>

        <h2 id="更加高并发把负载均衡器也集群lvs负载均衡器"   >
          <a href="#更加高并发把负载均衡器也集群lvs负载均衡器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#更加高并发把负载均衡器也集群lvs负载均衡器"></a> 更加高并发？把负载均衡器也集群！（LVS负载均衡器）</h2>
      
<p>负载均衡也分为很多种,</p>
<ol>
<li>可分为业务层负载均衡器，通过业务分发;</li>
<li>也可分为传输层的负载均衡器，通过UDP/TCP分发;</li>
<li>网络层的负载均衡器，通过IP分发;</li>
<li>数据链路层的负载均衡器，通过数据帧分发;</li>
</ol>
<p>如何更进一步提高并发量?</p>
<p>可以把负载均衡器也进行集群处理, 前端使用一个偏底层的 LVS 负载均衡器, 即, 一台 LVS 加多台 Nginx 服务器的模型。</p>
<p>LVS的并发量很容易扩展到十几万;</p>

        <h1 id="redis优化跨服务器通信"   >
          <a href="#redis优化跨服务器通信" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis优化跨服务器通信"></a> Redis优化跨服务器通信</h1>
      
<p>本项目中, 用户间的通信模型无非有两种：一对一聊天、群聊。</p>
<p>集群环境中，即用户可能分布在不同服务器主机上。</p>
<p>如果按照之前的代码逻辑，每台服务器上的一个 Server 都只有一个<code>m_userConnectionMap</code>（因为这个是ChatService中的成员，而ChatService是单例模式）。</p>
<p>所以用户给对方发消息后，如果接收方用户不在同一台服务器上，那么该消息就会被当作离线消息，这显然是不对的。</p>
<p>那么怎么解决跨服务器通信呢？</p>

        <h2 id="多个服务器广播通信虽能解决但是太差"   >
          <a href="#多个服务器广播通信虽能解决但是太差" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#多个服务器广播通信虽能解决但是太差"></a> 多个服务器广播通信（虽能解决，但是太差）</h2>
      
<p><strong>最直观的想法</strong>是让各个ChatServer服务器互相之间直接建立TCP连接进行通信，相当于在服务器网络之间进行广播。<br />
<img src="../../images/%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20250803032633484.png" alt="" /><br />
这样的设计使得各个服务器之间耦合度太高，不利于系统扩展，并且会占用系统大量的 socket 资源，各服务器之间的带宽压力很大，不能够节省资源给更多的客户端提供服务，因此不是一个好的设计。</p>

        <h2 id="redis-消息队列-解耦设计"   >
          <a href="#redis-消息队列-解耦设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-消息队列-解耦设计"></a> Redis 消息队列 解耦设计</h2>
      
<p>集群部署的服务器之间进行通信，最好的方式就是引入中间件消息队列，<br />
解耦各个服务器，使整个系统松耦合，提高服务器的响应能力，节省服务器的带宽资源。</p>
<p>所以答案是引入服务器中间件如消息队列。<br />
<img src="../../images/%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/image-20250803032927009.png" alt="" /></p>
<p>如此一来, <strong>服务器仅需做的工作是：向中间件发布订阅消息，之后等待中间件通知去取消息</strong>。</p>
<p>在集群分布式环境中，经常使用的中间件消息队列有 ActiveMQ 、RabbitMQ 、Kafka 等，都是应用场景广泛并且性能很好的消息队列，供集群服务器之间，分布式服务之间进行消息通信。</p>
<p>限于本项目业务类型并不是非常复杂，对并发请求量也没有太高的要求，因此本项目中间件消息队列选型的是：基于发布-订阅模式的 Redis。</p>

        <h2 id="redis环境安装和配置"   >
          <a href="#redis环境安装和配置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis环境安装和配置"></a> Redis环境安装和配置</h2>
      
<ol>
<li>Ubuntu安装redis服务命令</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install redis-server</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>安装完成后会自动启动redis服务，通过ps命令确认; redis默认端口为6379</li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></div></figure>

        <h2 id="redis-cli测试redis-server"   >
          <a href="#redis-cli测试redis-server" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-cli测试redis-server"></a> redis-cli测试redis-server</h2>
      
<p>启动redis-cli客户端，连接redis server体验一下数据缓存功能</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set &quot;abc&quot; &quot;hello world&quot; #设置key-value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get &quot;abc&quot;</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></div></figure>

        <h3 id="redis-订阅-发布"   >
          <a href="#redis-订阅-发布" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis-订阅-发布"></a> Redis 订阅 / 发布</h3>
      
<p>Redis 的发布-订阅机制：发布-订阅模式包含了两种角色，分别是消息的发布者和消息的订阅者。</p>
<p>订阅者可以订阅一个或者多个频道 channel ，发布者可以向指定的频道 channel 发送消息，所有订阅此频道的订阅者都会收到此消息。</p>
<p>订阅频道的命令是 subscribe，可以同时订阅多个频道，用法是<code>subscribe channel1 [channel2] ...</code>;</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe 13</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;13&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish 13 &quot;hello, 13&quot; #另一端推送消息给13</span><br></pre></td></tr></table></div></figure>
<p>订阅了<code>13</code>频道 的用户收到的消息:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;13&quot;</span><br><span class="line">3) &quot;hello, 13&quot;</span><br></pre></td></tr></table></div></figure>

        <h2 id="对应于本项目"   >
          <a href="#对应于本项目" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对应于本项目"></a> 对应于本项目</h2>
      
<p>由于服务器是集群化的, 所以登录到本系统的用户可能不在同一聊天服务器上, 需要观察Redis中间件来获取消息;</p>
<p>即, 用户是观察者, 消息队列是被观察者;</p>
<p>某一用户登陆到聊天系统后,</p>
<ol>
<li>服务器需要向 Redis 订阅某一频道的消息, 这个频道的id号即为该用户的id号;</li>
<li>当该用户给另一用户发送消息时, 发现其不在本服务器中, 需要向该频道发布消息;</li>
</ol>

        <h1 id="redis发布-订阅的客户端编程-封装为redis类"   >
          <a href="#redis发布-订阅的客户端编程-封装为redis类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#redis发布-订阅的客户端编程-封装为redis类"></a> Redis发布-订阅的客户端编程 - 封装为Redis类</h1>
      
<p>redis支持多种不同的客户端编程语言，例如 Java 对应 Jedis ，PHP对应 phpredis ，<strong>C++对应的是 hiredis</strong>。</p>

        <h2 id="hiredis-安装步骤"   >
          <a href="#hiredis-安装步骤" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#hiredis-安装步骤"></a> hiredis 安装步骤</h2>
      
<ol>
<li><code>git clone https://github.com/redis/hiredis</code></li>
<li><code>make &amp;&amp; make install</code></li>
</ol>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line">make</span><br><span class="line">...</span><br><span class="line"><span class="built_in">sudo</span> make install <span class="comment">#拷贝生成的动态库到/usr/local/lib目录下</span></span><br><span class="line"><span class="comment"># 如果提示没有找到hiredis动态库，则执行下面</span></span><br><span class="line"><span class="comment"># sudo ldconfig /usr/local/lib</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="成员变量-2"   >
          <a href="#成员变量-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员变量-2"></a> 成员变量</h2>
      
<ol>
<li>hiredis同步上下文对象
<ol>
<li>一个专门负责publish消息</li>
<li>一个专门负责subscribe消息</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">/* hiredis同步上下文对象, 负责publish消息 */</span></span><br><span class="line">   redisContext * m_publish_context;</span><br><span class="line">   <span class="comment">/* hiredis同步上下文对象, 负责subscribe消息 */</span></span><br><span class="line">   redisContext * m_subscribe_context;</span><br></pre></td></tr></table></div></figure>
<ol start="2">
<li>回调操作, 收到订阅的消息, 给service层上报</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">/* 回调操作, 收到订阅的消息, 给service层上报 */</span></span><br><span class="line">   MessageCallback m_notify_handler;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<ol>
<li>对于&quot;hiredis上下文对象&quot;的理解:</li>
</ol>
<ul>
<li>相当于一个redis-cli, 存储了连接相关的信息;</li>
</ul>
<ol start="2">
<li>为什么要写两个上下文对象?</li>
</ol>
<ul>
<li>如果上下文对象正在subscribe那么其将会阻塞, 所以 subscribe 和 publish 需要分开操作;</li>
</ul>
</blockquote>

        <h2 id="成员函数-4"   >
          <a href="#成员函数-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数-4"></a> 成员函数</h2>
      

        <h3 id="构造析构-2"   >
          <a href="#构造析构-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#构造析构-2"></a> 构造/析构</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Redis</span>();</span><br><span class="line">   ~<span class="built_in">Redis</span>();</span><br></pre></td></tr></table></div></figure>

        <h3 id="connect-3"   >
          <a href="#connect-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#connect-3"></a> connect</h3>
      
<p>连接Redis服务器</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 连接Redis服务器 */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="发布订阅消息"   >
          <a href="#发布订阅消息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#发布订阅消息"></a> 发布/订阅消息</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 向指定的redis频道发布消息 */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">publish</span><span class="params">(<span class="type">int</span> channel, string message)</span></span>;</span><br><span class="line">   <span class="comment">/* 向指定的redis频道订阅消息 */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">subscribe</span><span class="params">(<span class="type">int</span> channel)</span></span>;</span><br><span class="line">   <span class="comment">/* 向指定的redis频道取消订阅消息 */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">int</span> channel)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="observer_channel_message"   >
          <a href="#observer_channel_message" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#observer_channel_message"></a> <code>observer_channel_message</code></h3>
      
<p>在独立线程中接收订阅频道中的消息</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">/* 在独立线程中接收订阅频道中的消息 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">observer_channel_message</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="init_notify_handler"   >
          <a href="#init_notify_handler" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#init_notify_handler"></a> <code>init_notify_handler</code></h3>
      
<p>初始化向业务层上报频道消息 的回调函数, 需要用到一个int(频道号), 一个消息内容字符串</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">using</span> MessageCallback = function&lt;<span class="built_in">void</span>(<span class="type">int</span>, string)&gt;;</span><br><span class="line">   <span class="comment">/* 初始化向业务层上报频道消息 的回调函数, 需要用到int(频道号), 消息内容字符串 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">init_notify_handler</span><span class="params">(MessageCallback cb)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h2 id="代码实现-3"   >
          <a href="#代码实现-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现-3"></a> 代码实现</h2>
      

        <h3 id="构造-3"   >
          <a href="#构造-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#构造-3"></a> 构造</h3>
      
<p>只是对两个上下文对象指针赋nullptr, 没有实际构造</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redis::<span class="built_in">Redis</span>()</span><br><span class="line">   : <span class="built_in">m_publish_context</span>(<span class="literal">nullptr</span>), <span class="built_in">m_subscribe_context</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="析构-2"   >
          <a href="#析构-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#析构-2"></a> 析构</h3>
      
<p>调用<code>redisFree</code>释放上下文对象资源</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Redis::~<span class="built_in">Redis</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(m_publish_context != <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">redisFree</span>(m_publish_context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(m_subscribe_context != <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">redisFree</span>(m_subscribe_context);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="connect-4"   >
          <a href="#connect-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#connect-4"></a> connect</h3>
      
<ol>
<li>对context进行实际的申请资源/构造, 返回指针赋给成员, 底层调用<code>redisConnect</code></li>
<li>创建线程, 执行<code>observer_channel_message</code>, 即循环等待Redis频道的reply</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_publish_context = <span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">nullptr</span> == m_publish_context)</span><br><span class="line">   &#123;</span><br><span class="line">       cerr &lt;&lt; <span class="string">&quot;connect redis failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m_subscribe_context = <span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">nullptr</span> == m_subscribe_context)</span><br><span class="line">   &#123;</span><br><span class="line">       cerr &lt;&lt; <span class="string">&quot;connect redis failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 由于subscribe操作是阻塞的, </span></span><br><span class="line"><span class="comment">    * 在实际的使用环境下, 不可能因为一个订阅操作去阻塞一个服务器, </span></span><br><span class="line"><span class="comment">    * 所以要用一个单独的线程来完成监听频道上的事件,</span></span><br><span class="line"><span class="comment">    * 有消息则给业务层进行上报; </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">thread <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       [&amp;]() &#123; observer_channel_message();&#125; )</span></span>;</span><br><span class="line">   t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;connect redis-server success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="publish"   >
          <a href="#publish" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#publish"></a> publish</h3>
      
<p>相当于向redis-server发送命令, reply接收命令执行结果</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::publish</span><span class="params">(<span class="type">int</span> channel, string message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 相当于向redis-server发送命令, reply接收命令执行结果 */</span></span><br><span class="line">   redisReply * reply = (redisReply*)<span class="built_in">redisCommand</span>(</span><br><span class="line">       m_publish_context, <span class="string">&quot;PUBLISH %d %s&quot;</span>, channel, message.<span class="built_in">c_str</span>());</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">nullptr</span> == reply)</span><br><span class="line">   &#123;</span><br><span class="line">       cerr &lt;&lt; <span class="string">&quot;publish command failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="subscribe"   >
          <a href="#subscribe" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#subscribe"></a> subscribe</h3>
      
<p>相当于把redisCommand细化了, 只操作了发命令, 接收结果交给单独的线程做了, 详见<code>observer_channel_message</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::subscribe</span><span class="params">(<span class="type">int</span> channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(REDIS_ERR == <span class="built_in">redisAppendCommand</span>(</span><br><span class="line">       m_subscribe_context, <span class="string">&quot;SUBSCRIBE %d&quot;</span>, channel))</span><br><span class="line">   &#123;</span><br><span class="line">       cerr &lt;&lt; <span class="string">&quot;subscribe command failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 循环发送缓冲区内容, 直到发送完毕 */</span></span><br><span class="line">   <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!done)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(REDIS_ERR == <span class="built_in">redisBufferWrite</span>(m_subscribe_context, &amp;done))</span><br><span class="line">       &#123;</span><br><span class="line">           cerr &lt;&lt; <span class="string">&quot;subscribe command failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里不做redisReply的操作,</span></span><br><span class="line"><span class="comment">    * 这是个阻塞的操作, 放在observer_channel_message中做;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="unsubscribe"   >
          <a href="#unsubscribe" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#unsubscribe"></a> unsubscribe</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::unsubscribe</span><span class="params">(<span class="type">int</span> channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(REDIS_ERR == <span class="built_in">redisAppendCommand</span>(</span><br><span class="line">       m_subscribe_context, <span class="string">&quot;UNSUBSCRIBE %d&quot;</span>, channel))</span><br><span class="line">   &#123;</span><br><span class="line">       cerr &lt;&lt; <span class="string">&quot;unsubscribe command failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 循环发送缓冲区内容, 直到发送完毕 */</span></span><br><span class="line">   <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(!done)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(REDIS_ERR == <span class="built_in">redisBufferWrite</span>(m_subscribe_context, &amp;done))</span><br><span class="line">       &#123;</span><br><span class="line">           cerr &lt;&lt; <span class="string">&quot;unsubscribe command failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这里不做redisReply的操作,</span></span><br><span class="line"><span class="comment">    * 这是个阻塞的操作, 放在observer_channel_message中做;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="observer_channel_message-2"   >
          <a href="#observer_channel_message-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#observer_channel_message-2"></a> <code>observer_channel_message</code></h3>
      
<ul>
<li>Redis频道如果有消息, 则有三个字段,
<ol>
<li>对应的是redisGetReply返回的<code>reply-&gt;element[0],[1],[2]</code>;</li>
<li>本项目的<code>element[1]</code>对应的是频道号;</li>
<li>本项目的<code>element[2]</code>对应的是消息体;</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::observer_channel_message</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   redisReply *reply = <span class="literal">nullptr</span>;</span><br><span class="line">   <span class="type">int</span> res = REDIS_ERR;</span><br><span class="line">   <span class="keyword">while</span>(REDIS_OK==(res = <span class="built_in">redisGetReply</span>(</span><br><span class="line">                               m_subscribe_context, (<span class="type">void</span>**)&amp;reply)))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(reply != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">          reply-&gt;element[<span class="number">2</span>] != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">          reply-&gt;element[<span class="number">2</span>]-&gt;str != <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">/* 给业务层上报频道上发生的消息, 即频道号+消息体 */</span></span><br><span class="line">           <span class="built_in">m_notify_handler</span>(<span class="built_in">atoi</span>(reply-&gt;element[<span class="number">1</span>]-&gt;str),</span><br><span class="line">                            reply-&gt;element[<span class="number">2</span>]-&gt;str );</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(res == REDIS_ERR)</span><br><span class="line">   &#123;</span><br><span class="line">       cerr &lt;&lt; <span class="string">&quot;redisGetReply err&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cerr &lt;&lt; <span class="string">&quot;observer_channel_message quit&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="init_notify_handler-2"   >
          <a href="#init_notify_handler-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#init_notify_handler-2"></a> <code>init_notify_handler</code></h3>
      
<p>设置<code>m_notify_handler</code>回调</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::init_notify_handler</span><span class="params">(MessageCallback cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_notify_handler = cb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>redisCommand和redisAppendCommand的区别:</p>
<ol>
<li>redisAppendCommand只是把命令先写到本地缓存中;</li>
<li>写到缓存之后还需要调用redisBufferWrite把缓存中的命令发送到Redis服务器;</li>
<li>最后, 如果要获得reply, 还需要调用redisGetReply获取结果, 这个操作对于subscribe是阻塞的;</li>
<li>由于publish操作一般不会阻塞, 所以直接调用redisCommand;</li>
<li>由于subscribe操作最后的redisGetReply将会阻塞, 所以我们把这几个步骤单独写出来, 粒度减小, 追求效率;</li>
</ol>
</blockquote>

        <h2 id="chatservice加入redis组件"   >
          <a href="#chatservice加入redis组件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#chatservice加入redis组件"></a> ChatService加入Redis组件</h2>
      
<p>首先, 需要在<code>chatservice.hpp</code>中, 引入头文件<code>&quot;redis.hpp&quot;</code>; 然后在<code>ChatService</code>的类成员变量中声明一个<code>Redis m_redis</code>redis操作对象;</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Redis m_redis;</span><br></pre></td></tr></table></div></figure>
<p>在ChatService类中, 添加一个处理redis业务的成员函数<code>handleRedisSubscribeMessage</code></p>
   <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRedisSubscribeMessage</span><span class="params">(<span class="type">int</span> channel, string message)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>在<code>chatservice.cpp</code>中, ChatService的构造函数中, 需要添加连接redis服务器的操作;<br />
如果连接成功, 给redis设置回调函数为<code>handleRedisSubscribeMessage</code>, 参数为chatservice对象指针, channel, message;</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ChatService::<span class="built_in">ChatService</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">if</span>(m_redis.<span class="built_in">connect</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       m_redis.<span class="built_in">init_notify_handler</span>(std::<span class="built_in">bind</span>(</span><br><span class="line">           &amp;ChatService::handleRedisSubscribeMessage, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Cpp/Cpp_%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B_%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/">Cpp_原子类型_无锁队列</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-01</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Cpp/Cpp_%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B_%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" data-flag-title="Cpp_原子类型_无锁队列"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="线程安全问题"   >
          <a href="#线程安全问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程安全问题"></a> 线程安全问题</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">count++;</span><br><span class="line">count--;	<span class="comment">/* 是线程不安全的 */</span></span><br></pre></td></tr></table></div></figure>
<p>后置<code>++</code>有多个动作：</p>
<ol>
<li>取出count的值为tmp</li>
<li>计算<code>count + 1</code></li>
<li><code>count + 1</code>的结果赋给count</li>
<li>返回tmp</li>
</ol>
<p>对应于多条指令。</p>
<p>传统地解决，可以用加锁的方式</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>但是，互斥锁是比较耗费资源的，如果临界区的代码比较轻量级，那么传统mutex锁相对而言就比较小题大做了。</p>
<p>现在有新机制解决：指令级并发。</p>
<p>如果想让这么多动作在一条指令内做完的话，需要让处理器支持这样的操作，而不用锁机制，因此这种叫做无锁结构。</p>

        <h1 id="原子类型"   >
          <a href="#原子类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#原子类型"></a> 原子类型</h1>
      
<p>定义于<code>&lt;atomic&gt;</code><br />
原子类型，封装了一个值，保证其的访问不会导致数据竞争，并且可用于同步不同线程之间的内存访问。</p>

        <h2 id="atomic_flag"   >
          <a href="#atomic_flag" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic_flag"></a> <code>atomic_flag</code></h2>
      
<p>初始化可以赋值为<code>ATOMIC_FLAG_INIT</code>，意为无状态，对应false。</p>
<ol>
<li><code>test_and_set()</code>：置位为有状态，对应true，并返回调用之前的状态。这是一个原子操作，不会被其他线程干扰。</li>
<li><code>clear()</code>重置flag为无状态</li>
</ol>

        <h3 id="atomic_flag做自旋锁"   >
          <a href="#atomic_flag做自旋锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic_flag做自旋锁"></a> <code>atomic_flag</code>做自旋锁</h3>
      
<p>以下就是一个用<code>atomic_flag</code>做忙等待的例子：</p>
<ol>
<li>初始flag为无状态</li>
<li>调用一次<code>test_and_set()</code>置位flag为有状态</li>
<li>while中一直调用<code>test_and_set()</code>，测试它的状态，直到为无状态时，退出循环，结束程序。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br><span class="line">    flag.<span class="built_in">test_and_set</span>();</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>给定一个<code>atomic_flag</code>，初始为无状态，同时启动10个线程，操作之前，调用<code>test_and_set</code>，如果测试为无状态，说明没有其他线程在操作，就可以进行操作。<br />
操作完毕后，<code>clear</code>重置flag为无状态。下一个线程就可以探测到无状态，开始它的操作。</p>
<p>此时，<code>atomic_flag</code>就相当于自旋锁的作用。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::atomic_flag lock_output = ATOMIC_FLAG_INIT;</span><br><span class="line">std::counting_semaphore&lt;<span class="number">10</span>&gt; sema&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// lock</span></span><br><span class="line">    <span class="keyword">while</span> (lock_output.<span class="built_in">test_and_set</span>())</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread #&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// unlock</span></span><br><span class="line">    lock_output.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::jthread t[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i] = std::<span class="built_in">jthread</span>(&amp;worker, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sema.<span class="built_in">release</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread #1</span><br><span class="line">thread #5</span><br><span class="line">thread #4</span><br><span class="line">thread #7</span><br><span class="line">thread #2</span><br><span class="line">thread #10</span><br><span class="line">thread #6</span><br><span class="line">thread #3</span><br><span class="line">thread #9</span><br><span class="line">thread #8</span><br></pre></td></tr></table></div></figure>

        <h2 id="atomic"   >
          <a href="#atomic" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic"></a> atomic</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">atomic</span>;</span><br></pre></td></tr></table></div></figure>
<p>原子对象的主要特征是，从不同线程访问值不会导致数据竞争（即，这样做是明确定义的行为，访问顺序正确）。<br />
通常，对于所有其他对象，如果同时访问同一对象而导致数据争用，则该操作将被视为未定义行为。</p>
<p>原子对象能够通过<strong>指定不同的内存顺序</strong>来<strong>同步对其线程中其他非原子对象的访问</strong>。</p>

        <h1 id="relaxed-ordering的问题"   >
          <a href="#relaxed-ordering的问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#relaxed-ordering的问题"></a> Relaxed Ordering的问题</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// A</span></span><br><span class="line">x.<span class="built_in">store</span>(r1, std::memory_order_relaxed); <span class="comment">// B</span></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// C</span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed); <span class="comment">// D</span></span><br></pre></td></tr></table></div></figure>
<p>标记为 <code>memory_order_relaxed</code> 的原子操作不是同步操作。它们不会在并发内存访问中强加顺序，它们只保证原子性和修改顺序的一致性。<br />
例如，x 和 y 初始为零。<br />
以上程序就会允许产生 <code>r1 == r2 == 42</code>，在线程 1 内，A 在 B 之前被排序，并且在线程 2 内，C 在 D 之前被排序。<br />
但是没有什么可以阻止 D 在 A 之前 修改了 y，并且 B 在 C 之前 修改 x 。<br />
D 对 y 的副作用对于线程 1 中的 load A 是可见的，B 对 x 的副作用对于线程 2 中的 load C 是可见的。</p>
<p>特别是，如果在线程 2 中 D 在 C 之前完成，这可能会发生，这可能是在运行时发生的，或者由于编译器重新排序导致的。</p>
<blockquote>
<p>实际上，A、B是不能调换的，因为编译器会看到，同在线程1中，B中的 <code>r1</code> 的值依赖于上一句的A对 <code>r1</code> 的操作。<br />
而C、D之间就没有依赖了，因为 D 操作的是 <code>42</code>，是个常量。<br />
所以，经过线程并发、内存重排，可能的执行顺序有：<br />
A B C D  此时 x、y、r1、r2的值：0、0、0、42<br />
A B D C  此时 x、y、r1、r2的值：0、42、0、0<br />
A C D B  此时 x、y、r1、r2的值：0、42、0、0<br />
A D C B  此时 x、y、r1、r2的值：0、42、0、0<br />
C A D B  此时 x、y、r1、r2的值：0、42、0、0<br />
<strong>D A C B</strong>  此时 x、y、r1、r2的值：<strong>42、42、42、42</strong>  =&gt; 这时便出现了<code>r1 == r2 == 42</code><br />
C D A B  此时 x、y、r1、r2的值：42、42、42、0<br />
D C A B  此时 x、y、r1、r2的值：0、42、42、0</p>
</blockquote>
<p>怎么解决呢？<br />
见下文</p>

        <h1 id="内存顺序"   >
          <a href="#内存顺序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存顺序"></a> 内存顺序</h1>
      
<p>原子操作只是提供了不同线程读写的同步。<br />
但是<strong>没有提供操作顺序的同步</strong>。</p>
<p>比如：线程1修改原子值a，线程2读取原子值a。</p>
<p>两个线程各自的读写操作，确实是保证了不会有脏值。<br />
但是线程1、线程2的顺序没有做控制，<br />
如果线程2想要读出旧值，但是线程1在线程2读值前进行写操作，还是会导致线程2读出脏值。</p>
<p>因此需要提供内存顺序机制。</p>
<p>下面举一个类似的例子，怎么通过原子变量+内存顺序控制，让consumer确保producer执行完毕后，再 load 出 b 的值。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order::relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order::release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// memory_order_acquire表示必须排序在x store、y store之后</span></span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">load</span>(std::memory_order::acquire))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">load</span>(std::memory_order::relaxed))</span><br><span class="line">        ++c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="literal">false</span>;</span><br><span class="line">    b = <span class="literal">false</span>;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono::literals;</span><br><span class="line">    <span class="function">std::jthread <span class="title">th2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>s);</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::jthread <span class="title">th</span><span class="params">(producer)</span></span>;</span><br><span class="line"></span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    th<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<div class="table-container"><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>relaxed</td>
<td>CPU和编译器可以重新排序变量顺序。<br>这是一种松散的内存顺序，不保证不同线程中的内存访问对原子操作进行排序。</td>
</tr>
<tr>
<td>consume（废弃）</td>
<td>针对某个原子变量的访问指令（store）重排到此指令（load）前。<strong>即自己load排到针对某个变量的release操作后</strong>。（在<code>C++26</code>中被废弃了，推荐用acquire）</td>
</tr>
<tr>
<td>acquire</td>
<td>所有访问指令（store）排到此指令（load）前。<strong>即自己load排到所有release操作后</strong>。</td>
</tr>
<tr>
<td>release</td>
<td>所有访问指令（load）排到此指令（store）之后。即自己store排到所有consume、acquire操作之前。<br>扮演了一个同步点（synchronization point）的角色。</td>
</tr>
<tr>
<td>acq_rel</td>
<td>The operation loads acquiring and stores releasing。<br>该操作可能扮演两种角色。<br>比如<code>std::atomic::exchange</code>操作，两个变量交换：<br>需要load值，可能需要等待release；<br>需要store值，即产生release，需要给其他acquire、consume通知。</td>
</tr>
<tr>
<td>seq_cst</td>
<td>sequentially consistent，意思是该操作以顺序一致的方式排序。一旦所有可能对其他线程产生可见副作用的内存访问已经发生，则所有操作使用此内存顺序。<br>这是最严格的内存顺序，保证了在非原子内存访问中线程交互之间的意外副作用最小。<br>对于consume和acquire的load，顺序一致的store操作被认为是release操作。</td>
</tr>
</tbody>
</table></div>

        <h1 id="lock_free测试"   >
          <a href="#lock_free测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lock_free测试"></a> lock_free测试</h1>
      
<p>测试以确定原子模板包含的类型是否支持无锁。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;<span class="type">int</span>&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;<span class="type">int</span>&gt;&#123;&#125;.is_always_lock_free &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>经过测试后发现，不超过8字节（64位）的数据结构，并且没有虚函数表的数据结构，是支持无锁的。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;<span class="type">int</span> x, y; <span class="built_in">A</span>() &#123;&#125;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;<span class="type">int</span> a[<span class="number">2</span>];&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;<span class="type">int</span> a[<span class="number">3</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;A&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;B&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// true</span></span><br><span class="line">    std::wcout &lt;&lt; std::boolalpha &lt;&lt; std::atomic&lt;C&gt;&#123;&#125;.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl; <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="无锁编程的原理"   >
          <a href="#无锁编程的原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无锁编程的原理"></a> 无锁编程的原理</h1>
      

        <h2 id="cascompare-and-swap"   >
          <a href="#cascompare-and-swap" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cascompare-and-swap"></a> CAS（Compare-And-Swap）</h2>
      
<p>CAS在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一模一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。（具有ABA问题：用版本号或时间戳解决）</p>
<p>现代CPU提供​<strong>​CAS（Compare-And-Swap）​</strong>​ 等原子指令，可在单个指令周期内完成类似以下的判断函数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CAS</span><span class="params">(T* ptr, T old_val, T new_val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*ptr == old_val)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr = new_val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>以上类似的操作，实际指令执行期间不会被中断，避免了数据竞争。</p>
<p>比如，用这个特性，实现一个自旋锁：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr;</span><br><span class="line">    *old_ptr = new;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当 flag 为 0 时，函数返回false，退出。加锁成功。flag被修改为 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">    &#123;&#125; <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="内存顺序-2"   >
          <a href="#内存顺序-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存顺序-2"></a> 内存顺序</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line">data = <span class="number">42</span>;                                       <span class="comment">// 1. 写数据</span></span><br><span class="line">flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);        <span class="comment">// 2. 释放屏障：保证 1 一定在 2 前完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) != <span class="number">1</span>)<span class="comment">// 3. 获取屏障：保证读到 flag = 1 时，才退出循环</span></span><br><span class="line">    ;                                            <span class="comment">//    一定能看到data=42</span></span><br><span class="line"><span class="built_in">read</span>(data);                                      <span class="comment">// 4. 安全读取数据</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="无锁数据结构的实现模式"   >
          <a href="#无锁数据结构的实现模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无锁数据结构的实现模式"></a> 无锁数据结构的实现模式</h1>
      

        <h2 id="读-修改-写循环read-modify-write-loop"   >
          <a href="#读-修改-写循环read-modify-write-loop" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#读-修改-写循环read-modify-write-loop"></a> ”读-修改-写“循环（Read-Modify-Write Loop）</h2>
      
<p>这是实现无锁的关键思维之一：<strong>乐观并发控制</strong>：<strong>先执行操作，提交前，验证数据（tail）未被修改，如果未被修改，再提交</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CAS</span><span class="params">(Node* old_ptr, Node* new_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == old_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span> = new_ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">    Node* old_tail;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        old_tail = tail.<span class="built_in">load</span>();              <span class="comment">// 读</span></span><br><span class="line">        new_node-&gt;next = old_tail;           <span class="comment">// 修改</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!tail.<span class="built_in">CAS</span>(old_tail, new_node)); <span class="comment">// 把 tail 改为 new_node（失败则重试）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="帮助机制helping-mechanism"   >
          <a href="#帮助机制helping-mechanism" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#帮助机制helping-mechanism"></a> 帮助机制（Helping Mechanism）​</h2>
      
<p>当线程A发现线程B的操作未完成时，主动协助推进（如无锁队列中帮其他线程移动tail指针）。</p>

        <h2 id="分离并发关注点如头尾指针分离"   >
          <a href="#分离并发关注点如头尾指针分离" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分离并发关注点如头尾指针分离"></a> ​​分离并发关注点（如头尾指针分离）​</h2>
      
<p>将数据结构拆分为多个可独立更新的部分，减少竞争点。</p>
<p>这是实现无锁的关键思维之二：​<strong>​局部性原理（Locality Principle）</strong>：通过数据分片（如分槽队列）减少缓存行冲突：<br />
对齐64位。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) PaddedAtomic</span><br><span class="line">&#123; </span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; count;  <span class="comment">// 独占缓存行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="aba问题乐观锁问题"   >
          <a href="#aba问题乐观锁问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#aba问题乐观锁问题"></a> ABA问题（乐观锁问题）</h1>
      
<p>乐观锁会出现这种问题。</p>
<p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突（一般实现方式是通过加版本号然后进行版本号的对比方式实现）</p>
<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁。而是通过业务实现锁的功能。<br />
不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程。<br />
这种方式节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能。<br />
不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源。<br />
所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>

        <h2 id="问题场景"   >
          <a href="#问题场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题场景"></a> 问题场景</h2>
      
<p>比如说线程一从数据库中取出库存数 3，这时候线程二也从数据库中取出库存数 3。<br />
<strong>线程二进行了一些操作变成了 2</strong>。<strong>但是然后线程二在线程一拿到操作权之前，又将库存数变成了 3</strong>。<br />
这时候：线程一进行 CAS 操作发现数据库中仍然是 3，然后线程一操作成功。<br />
尽管线程一的 CAS 操作成功，但是不代表这个过程就是没有问题的。</p>

        <h2 id="解决方案"   >
          <a href="#解决方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2>
      
<p>使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是脏数据，需要处理。</p>
<p>使用带版本号的指针：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VersionedPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* ptr;</span><br><span class="line">    <span class="type">uint64_t</span> version;  <span class="comment">// 每次修改+1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="内存回收挑战"   >
          <a href="#内存回收挑战" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存回收挑战"></a> 内存回收挑战</h1>
      
<div class="table-container"><table>
<thead>
<tr>
<th>方法</th>
<th>原理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hazard Pointers</td>
<td>线程本地记录&quot;危险指针&quot;（有的也叫风险指针），延迟删除其他线程可能访问的内存</td>
<td>Linux内核常用</td>
</tr>
<tr>
<td>Epoch-Based Reclaim</td>
<td>将内存标记为待回收，当所有线程都不持有旧epoch时才删除</td>
<td>NVIDIA库常用</td>
</tr>
<tr>
<td>RCU（Read-Copy-Update）</td>
<td>读操作无同步，写操作创建副本延迟回收</td>
<td>Linux内核链表</td>
</tr>
</tbody>
</table></div>

        <h1 id="mpmc无锁队列"   >
          <a href="#mpmc无锁队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mpmc无锁队列"></a> MPMC无锁队列</h1>
      

        <h2 id="node的设计伪共享预防-aba问题解决"   >
          <a href="#node的设计伪共享预防-aba问题解决" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#node的设计伪共享预防-aba问题解决"></a> Node的设计（伪共享预防、ABA问题解决）</h2>
      
<ul>
<li>​<strong>​伪共享预防​</strong>​：<code>alignas(64)</code>和填充确保 头尾 在不同缓存行</li>
<li><strong>ABA问题防护​</strong>​：通过<code>version</code>版本号区分指针复用</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T* data;  <span class="comment">// 数据指针（避免拷贝开销）</span></span><br><span class="line">    std::atomic&lt;Node*&gt; next; <span class="comment">// 原子指针</span></span><br><span class="line">    <span class="comment">// 防止伪共享</span></span><br><span class="line">    <span class="type">char</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(T*) - <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VersionedPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* ptr;</span><br><span class="line">    <span class="type">uint64_t</span> version;  <span class="comment">// ABA防护</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeMPMCQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 节点结构：带缓存行填充防止伪共享</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        T* data;  <span class="comment">// 存储实际数据指针（避免对象拷贝开销）</span></span><br><span class="line">        std::atomic&lt;Node*&gt; next;  <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="comment">// 确保每个节点独占缓存行（64字节）</span></span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(T*) - <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;)];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带版本号的指针（解决ABA问题）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) VersionedPtr</span><br><span class="line">    &#123;</span><br><span class="line">        Node* ptr;</span><br><span class="line">        <span class="type">uint64_t</span> version;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证头尾指针不在同一缓存行</span></span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; head;</span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span>];  <span class="comment">// 填充确保tail在下一个缓存行</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="队列初始化哨兵dummy头节点"   >
          <a href="#队列初始化哨兵dummy头节点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#队列初始化哨兵dummy头节点"></a> 队列初始化（哨兵dummy头节点）</h2>
      
<p><strong>作用​</strong>​：保证非空队列始终存在头节点，避免头尾指针竞态</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockFreeMPMCQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化哑元节点（dummy node）</span></span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 头尾指针指向同一个节点</span></span><br><span class="line">        VersionedPtr init = &#123;dummy, <span class="number">0</span>&#125;;</span><br><span class="line">        head.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">        tail.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="入队操作"   >
          <a href="#入队操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#入队操作"></a> 入队操作</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 入队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建新节点并填充数据</span></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            new_node-&gt;data = <span class="keyword">new</span> <span class="built_in">T</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> new_node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. CAS循环：找到真正的尾节点</span></span><br><span class="line">        VersionedPtr current_tail;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 原子获取当前尾指针</span></span><br><span class="line">            <span class="comment">// current_tail是std::atomic&lt;VersionedPtr&gt;类型的</span></span><br><span class="line">            <span class="comment">// 还要取出其成员 ptr。是 Node* 类型</span></span><br><span class="line">            current_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_tail = current_tail.ptr;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 定义新的 Node * next，先让它指向尾节点的 next</span></span><br><span class="line">            Node* next = (real_tail-&gt;next).<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查期间尾指针是否变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_tail.ptr != tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr)</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 发生变化则循环重试</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 情况A：尾节点后是空位置（理想情况）</span></span><br><span class="line">                VersionedPtr new_ptr&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="comment">// 尝试将新节点链接到尾节点后面</span></span><br><span class="line">                <span class="comment">// 关键CAS：</span></span><br><span class="line">                    <span class="comment">// 如果成功，则 原子更新尾节点的 next 指针，即尾节点的 next 指向 new_node</span></span><br><span class="line">                    <span class="comment">// 如果失败，则 real_tail-&gt;next 的值 写入到 next 中（详见函数的作用）</span></span><br><span class="line">                    <span class="comment">// 总之不会阻塞。</span></span><br><span class="line">                <span class="keyword">if</span> (real_tail-&gt;next.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">                    next, new_node, </span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 链接成功，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 情况B：发现尾指针滞后，帮助其它线程推进</span></span><br><span class="line">                <span class="comment">// 意思就是说，现在的 next 不是 null，说明这是一个其他人入队创建的节点</span></span><br><span class="line">                VersionedPtr other_ptr&#123;next, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试更新尾指针到后继节点（避免竞争导致的阻塞）</span></span><br><span class="line">                <span class="comment">// 即，把队列的 tail 改为 other_ptr</span></span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_tail, other_ptr,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 尝试更新全局尾指针（允许失败，因为有可能有人帮忙推进了）</span></span><br><span class="line">        <span class="comment">// 即，把队列的 tail 改为 new_tail</span></span><br><span class="line">        VersionedPtr new_tail&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">        tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            current_tail, new_tail,</span><br><span class="line">            std::memory_order_release,</span><br><span class="line">            std::memory_order_relaxed);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="compare_exchange_weak和strong"   >
          <a href="#compare_exchange_weak和strong" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#compare_exchange_weak和strong"></a> <code>compare_exchange_weak</code>和strong</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                             std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                             std::memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>两个函数都是：<br />
Atomically compares the <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/objects.html"  title="cpp/language/object">value representation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> (since C++20) of <code>*this</code> with that of expected. If those are bitwise-equal, replaces the former with desired (performs read-modify-write operation). Otherwise, loads the actual value stored in <code>*this</code> into expected (performs load operation).<br />
比较<code>*this</code>和<code>expected</code>的值，若相等，则把<code>*this</code>替换为<code>desired</code>（执行<code>read-modify-write operation</code>，即：读-修改-写），返回真。否则，把<code>*this</code>实际的值，存到<code>expected</code>中（执行<code>load operation</code>），返回假。</p>
<p>参数：<br />
<code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>都在后面有两个内存顺序的参数，第一个内存顺序指的是，成功时，做<code>read‑modify‑write operation</code>的内存顺序；第二个内存顺序指的是，失败时，做<code>load operation</code>的内存顺序。</p>
<p>与 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://legacy.cplusplus.com/atomic_compare_exchange_strong" >compare_exchange_strong</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 不同的是，这个弱版本允许通过返回 <code>false</code>来虚假地失败，即使<code>*expected</code> 确实与 obj 中包含的值相等。<br />
对于某些循环算法来说，这可能是可接受的行为，并且可能在某些平台上导致显著更好的性能。<br />
对于这些虚假的失败，函数返回<code>false</code>，但不修改预期。</p>

        <h2 id="出队操作"   >
          <a href="#出队操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#出队操作"></a> 出队操作</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 出队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VersionedPtr current_head;</span><br><span class="line">        Node* real_tail;</span><br><span class="line">        Node* next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 原子获取头尾指针（关键）</span></span><br><span class="line">            current_head = head.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_head = current_head.ptr;</span><br><span class="line">            </span><br><span class="line">            real_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr;</span><br><span class="line">            </span><br><span class="line">            next = (real_head-&gt;next).<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一致性检查：防止读取过程中数据结构变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_head.ptr != head.<span class="built_in">load</span>(std::memory_order_acquire).ptr)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 2. 队列状态判断</span></span><br><span class="line">            <span class="keyword">if</span> (real_head == real_tail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 情况A：队列为空</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况B：尾指针滞后，帮助推进</span></span><br><span class="line">                VersionedPtr new_tail&#123;next, tail.<span class="built_in">load</span>().version + <span class="number">1</span>&#125;;</span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    tail.<span class="built_in">load</span>(), new_tail,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 情况C：正常出队</span></span><br><span class="line">                <span class="comment">// 移动数据前预先加载（减少持有锁时间）</span></span><br><span class="line">                <span class="comment">// 注意，我们是有哑元节点的，现在获取到的head不是真实的head，而是dummy</span></span><br><span class="line">                <span class="comment">// dummy的下一个才是真实有数据的head，因此在这里取next的data</span></span><br><span class="line">                T* data_ptr = next-&gt;data;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试移动头指针</span></span><br><span class="line">                VersionedPtr new_head&#123;next, current_head.version + <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_head, new_head,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 出队成功：转移数据</span></span><br><span class="line">                    result = std::<span class="built_in">move</span>(*data_ptr);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 安全删除旧头节点（工业实现需延迟回收）</span></span><br><span class="line">                    <span class="keyword">delete</span> data_ptr;</span><br><span class="line">                    <span class="keyword">delete</span> real_head;  <span class="comment">// 实际应使用危险指针回收</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="析构"   >
          <a href="#析构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#析构"></a> 析构</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    ~<span class="built_in">LockFreeMPMCQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历删除所有节点（实际应用中需处理并发安全）</span></span><br><span class="line">        <span class="keyword">while</span> (Node* node = head.<span class="built_in">load</span>().ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            head.<span class="built_in">store</span>(&#123;node-&gt;next, <span class="number">0</span>&#125;, std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">delete</span> node-&gt;data;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="完整代码"   >
          <a href="#完整代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeMPMCQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 节点结构：带缓存行填充防止伪共享</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        T* data;  <span class="comment">// 存储实际数据指针（避免对象拷贝开销）</span></span><br><span class="line">        std::atomic&lt;Node*&gt; next;  <span class="comment">// 下一个节点指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保每个节点独占缓存行（64字节）</span></span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span> - <span class="built_in">sizeof</span>(T*) - <span class="built_in">sizeof</span>(std::atomic&lt;Node*&gt;)];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带版本号的指针（解决ABA问题）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) VersionedPtr &#123;</span><br><span class="line">        Node* ptr;</span><br><span class="line">        <span class="type">uint64_t</span> version;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证头尾指针不在同一缓存行</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; head;</span><br><span class="line">        <span class="type">char</span> padding[<span class="number">64</span>];  <span class="comment">// 填充确保tail在下一个缓存行</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;VersionedPtr&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockFreeMPMCQueue</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化哑元节点（dummy node）</span></span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 头尾指针指向同一个节点</span></span><br><span class="line">        VersionedPtr init = &#123;dummy, <span class="number">0</span>&#125;;</span><br><span class="line">        head.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">        tail.<span class="built_in">store</span>(init, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LockFreeMPMCQueue</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历删除所有节点（实际应用中需处理并发安全）</span></span><br><span class="line">        <span class="keyword">while</span> (Node* node = head.<span class="built_in">load</span>().ptr) &#123;</span><br><span class="line">            head.<span class="built_in">store</span>(&#123;node-&gt;next, <span class="number">0</span>&#125;, std::memory_order_relaxed);</span><br><span class="line">            <span class="keyword">delete</span> node-&gt;data;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建新节点并填充数据</span></span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            new_node-&gt;data = <span class="keyword">new</span> <span class="built_in">T</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">delete</span> new_node;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. CAS循环：找到真正的尾节点</span></span><br><span class="line">        VersionedPtr current_tail;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 原子获取当前尾指针</span></span><br><span class="line">            current_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_tail = current_tail.ptr;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试将新节点链接到尾节点后面</span></span><br><span class="line">            Node* next = real_tail-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查期间尾指针是否变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_tail.ptr != tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr) </span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 发生变化则重试</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// 情况A：尾节点后是空位置（理想情况）</span></span><br><span class="line">                VersionedPtr new_ptr&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 关键CAS：原子更新尾节点的next指针</span></span><br><span class="line">                <span class="keyword">if</span> (real_tail-&gt;next.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">                    next, new_node, </span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 链接成功，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况B：发现尾指针滞后，帮助其它线程推进</span></span><br><span class="line">                VersionedPtr new_ptr&#123;next, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试更新尾指针到后继节点（避免竞争导致的阻塞）</span></span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_tail, new_ptr,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 尝试更新全局尾指针（允许失败）</span></span><br><span class="line">        VersionedPtr new_tail&#123;new_node, current_tail.version + <span class="number">1</span>&#125;;</span><br><span class="line">        tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">            current_tail, new_tail,</span><br><span class="line">            std::memory_order_release,</span><br><span class="line">            std::memory_order_relaxed);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作（多线程安全）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(T&amp; result)</span> </span>&#123;</span><br><span class="line">        VersionedPtr current_head;</span><br><span class="line">        Node* real_tail;</span><br><span class="line">        Node* next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 原子获取头尾指针（关键）</span></span><br><span class="line">            current_head = head.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            Node* real_head = current_head.ptr;</span><br><span class="line">            real_tail = tail.<span class="built_in">load</span>(std::memory_order_acquire).ptr;</span><br><span class="line">            next = real_head-&gt;next.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一致性检查：防止读取过程中数据结构变化</span></span><br><span class="line">            <span class="keyword">if</span> (current_head.ptr != head.<span class="built_in">load</span>(std::memory_order_acquire).ptr)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 2. 队列状态判断</span></span><br><span class="line">            <span class="keyword">if</span> (real_head == real_tail) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="comment">// 情况A：队列为空</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况B：尾指针滞后，帮助推进</span></span><br><span class="line">                VersionedPtr new_tail&#123;next, tail.<span class="built_in">load</span>().version + <span class="number">1</span>&#125;;</span><br><span class="line">                tail.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    tail.<span class="built_in">load</span>(), new_tail,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况C：正常出队</span></span><br><span class="line">                <span class="comment">// 移动数据前预先加载（减少持有锁时间）</span></span><br><span class="line">                T* data_ptr = next-&gt;data;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 尝试移动头指针</span></span><br><span class="line">                VersionedPtr new_head&#123;next, current_head.version + <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                    current_head, new_head,</span><br><span class="line">                    std::memory_order_release,</span><br><span class="line">                    std::memory_order_relaxed)) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 出队成功：转移数据</span></span><br><span class="line">                    result = std::<span class="built_in">move</span>(*data_ptr);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 安全删除旧头节点（工业实现需延迟回收）</span></span><br><span class="line">                    <span class="keyword">delete</span> data_ptr;</span><br><span class="line">                    <span class="keyword">delete</span> real_head;  <span class="comment">// 实际应使用危险指针回收</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="内存回收危险指针"   >
          <a href="#内存回收危险指针" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存回收危险指针"></a> 内存回收（危险指针）</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hazard Pointer简单实现（线程本地注册）</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> std::vector&lt;Node*&gt; <span class="title">hp_records</span><span class="params">(<span class="number">2</span>)</span></span>;  <span class="comment">// 通常每个线程2个足够</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetireNode</span><span class="params">(Node* old)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查其他线程是否引用该节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsPointerHazard</span>(old))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加入待删除列表（延迟处理）</span></span><br><span class="line">        retired_list.<span class="built_in">push_back</span>(old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="无锁是忙等待吗"   >
          <a href="#无锁是忙等待吗" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无锁是忙等待吗"></a> 无锁是忙等待吗？</h1>
      
<p>无锁编程并不等同于忙等待（Busy-Waiting），其核心在于「非阻塞」，而非具体等待方式。​​</p>
<ol>
<li>​<strong>​「非阻塞」的定义​</strong>
<ul>
<li><em>Lock-Free</em>：至少一个线程能前进</li>
<li><em>Wait-Free</em>：所有线程都能在有限步完成</li>
</ul>
</li>
<li>​<strong>​延迟与吞吐的权衡​</strong>​
<ul>
<li>​<strong>​忙等待​</strong>​：牺牲CPU，以降低延迟（高频交易系统）</li>
<li>​<strong>​阻塞等待​</strong>​：加大延迟，以加大吞吐（Web服务器连接池）</li>
</ul>
</li>
</ol>
<p>无锁编程可​<strong>​根据竞争强度动态选择等待策略​</strong>​：</p>
<ol>
<li>低竞争时短暂自旋（利用CPU流水线）</li>
<li>中竞争时退避+主动让出CPU</li>
<li>高竞争时进入操作系统阻塞队列</li>
</ol>
<p>​<strong>​核心目标是以最小开销维持「至少一个线程前进」的非阻塞特性​</strong>​，而非强制忙等待。</p>
<p>实际无锁设计中可通过多种策略避免忙等：</p>

        <h2 id="操作系统级阻塞等待"   >
          <a href="#操作系统级阻塞等待" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#操作系统级阻塞等待"></a> 操作系统级阻塞等待</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++20 前（使用 futex）</span></span><br><span class="line"><span class="keyword">while</span> (!atomic_var.<span class="built_in">compare_exchange_weak</span>(...))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">syscall</span>(SYS_futex, &amp;atomic_var, FUTEX_WAIT, ...);  <span class="comment">// 主动让出CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++20 后（std::atomic::wait）</span></span><br><span class="line">atomic_var.<span class="built_in">wait</span>(old_val, std::memory_order_relaxed);  <span class="comment">// 线程挂起直到值变化</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="定时退避策略"   >
          <a href="#定时退避策略" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#定时退避策略"></a> 定时退避策略</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> retries = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">CAS</span>(ptr, old_val, new_val))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (retries++ &gt; MAX_SPIN)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();     <span class="comment">// 放弃时间片，通知调度器切换</span></span><br><span class="line">        retries = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _mm_pause();                  <span class="comment">// x86 自旋等待指令（降低CPU功耗）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="队列化竞争机制排队锁"   >
          <a href="#队列化竞争机制排队锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#队列化竞争机制排队锁"></a> 队列化竞争机制（排队锁）</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Waiter</span> &#123; std::atomic&lt;Waiter*&gt; next; &#125;;</span><br><span class="line">std::atomic&lt;Waiter*&gt; tail_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Waiter w;</span><br><span class="line">    w.next = <span class="literal">nullptr</span>;</span><br><span class="line">    Waiter* prev = tail_.<span class="built_in">exchange</span>(&amp;w, std::memory_order_acq_rel);</span><br><span class="line">    <span class="keyword">if</span> (prev)</span><br><span class="line">    &#123;</span><br><span class="line">        prev-&gt;next = &amp;w;                      <span class="comment">// 排队</span></span><br><span class="line">        <span class="keyword">while</span> (w.next.<span class="built_in">load</span>() != &amp;w) &#123;&#125;       <span class="comment">// 等待前驱节点唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Waiter* w = ...;</span><br><span class="line">    <span class="keyword">if</span> (!w-&gt;next)</span><br><span class="line">    &#123;                           <span class="comment">// 无后续等待者</span></span><br><span class="line">        <span class="keyword">if</span> (tail_.<span class="built_in">compare_exchange_strong</span>(w, <span class="literal">nullptr</span>)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!w-&gt;next.<span class="built_in">load</span>())    <span class="comment">// 等待后继节点就绪</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 唤醒下一个</span></span><br><span class="line">    w-&gt;next.<span class="built_in">load</span>()-&gt;next.<span class="built_in">store</span>(w-&gt;next.<span class="built_in">load</span>()-&gt;next, ...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比"></a> 对比</h2>
      
<div class="table-container"><table>
<thead>
<tr>
<th><strong>策略​</strong>​</th>
<th>实现方式</th>
<th>适用场景</th>
<th>CPU占用</th>
<th>延迟</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​忙等待​</strong>​</td>
<td><code>while(!CAS)</code></td>
<td>极低延迟场景（&lt;100ns）</td>
<td>100%核心</td>
<td>极低</td>
</tr>
<tr>
<td>​<strong>​主动退让​</strong>​</td>
<td><code>std::this_thread::yield()</code></td>
<td>用户态竞争适中</td>
<td>&lt; 30%</td>
<td>微秒级</td>
</tr>
<tr>
<td>​<strong>​操作系统阻塞​</strong>​</td>
<td><code>futex</code> / <code>atomic::wait</code></td>
<td>高竞争/长等待</td>
<td>~0%</td>
<td>毫秒级</td>
</tr>
<tr>
<td>​<strong>​队列化调度​</strong>​</td>
<td>MCS锁等排队机制</td>
<td>严格公平性要求</td>
<td>随队列转移</td>
<td>亚毫秒级</td>
</tr>
</tbody>
</table></div>

        <h2 id="工业级案例"   >
          <a href="#工业级案例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工业级案例"></a> 工业级案例</h2>
      

        <h3 id="linux内核futex"   >
          <a href="#linux内核futex" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#linux内核futex"></a> Linux内核Futex</h3>
      
<ul>
<li>首次CAS竞争失败后，通过<code>FUTEX_WAIT</code>系统调用挂起线程</li>
<li>解锁时通过<code>FUTEX_WAKE</code>唤醒等待线程</li>
</ul>

        <h3 id="java的aqsabstract-queued-synchronizer"   >
          <a href="#java的aqsabstract-queued-synchronizer" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#java的aqsabstract-queued-synchronizer"></a> ​​Java的AQS（Abstract Queued Synchronizer）​</h3>
      
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquire(arg)) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 无锁尝试</span></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire()) </span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);       <span class="comment">// 挂起线程（JVM层面）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="c20原子等待"   >
          <a href="#c20原子等待" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c20原子等待"></a> C++20原子等待</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">while</span> (!flag.<span class="built_in">wait</span>(<span class="number">1</span>, std::memory_order_seq_cst)); <span class="comment">// 阻塞直至值!=1</span></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">flag.<span class="built_in">store</span>(<span class="number">2</span>);</span><br><span class="line">flag.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有等待者</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="总线锁和缓存锁"   >
          <a href="#总线锁和缓存锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总线锁和缓存锁"></a> 总线锁和缓存锁</h1>
      

        <h2 id="总线锁bus-lock"   >
          <a href="#总线锁bus-lock" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总线锁bus-lock"></a> 总线锁（Bus Lock）</h2>
      
<p>当CPU执行带<code>LOCK</code>前缀的指令（如<code>CMPXCHG</code>）时，会通过芯片组发出​<strong>​硬件信号​</strong>​，​<strong>​独占整个内存总线（Bus）​</strong>​ 。此时其他CPU的所有内存访问请求将被阻塞，直到当前操作完成。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    CPU核心A-&gt;&gt;内存总线: LOCK#信号（总线锁定）</span><br><span class="line">    内存总线-&gt;&gt;所有CPU: 阻塞其他内存请求</span><br><span class="line">    CPU核心A-&gt;&gt;内存: 执行原子操作（如CAS）</span><br><span class="line">    内存总线-&gt;&gt;所有CPU: 解锁</span><br></pre></td></tr></table></div></figure>
<p>特点</p>
<ul>
<li>​<strong>​全局性锁定​</strong>​：锁定期间所有内存操作均被阻塞（包括非竞争数据）</li>
<li>​<strong>​性能开销大​</strong>​：原子操作串行化，多核性能急剧下降</li>
<li>​<strong>​兼容性强​</strong>​：早期x86处理器的唯一选择（如80486）</li>
</ul>

        <h2 id="缓存锁cache-locking-mesi优化"   >
          <a href="#缓存锁cache-locking-mesi优化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存锁cache-locking-mesi优化"></a> 缓存锁（Cache Locking）—— MESI优化</h2>
      
<p>核心：缓存一致性协议（Cache Coherence）</p>
<p>现代CPU通过​<strong>​MESI协议​</strong>​（Modified/Exclusive/Shared/Invalid）维护多核缓存一致性：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    Modified --&gt;|写回| Invalid</span><br><span class="line">    Exclusive --&gt;|其他核读| Shared</span><br><span class="line">    Shared --&gt;|写| Modified</span><br><span class="line">    Invalid --&gt;|写| Exclusive</span><br></pre></td></tr></table></div></figure>

        <h3 id="缓存锁的触发条件以intel-cpu为例"   >
          <a href="#缓存锁的触发条件以intel-cpu为例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓存锁的触发条件以intel-cpu为例"></a> 缓存锁的触发条件（以Intel CPU为例）</h3>
      
<p>当原子操作访问的数据满足：</p>
<ol>
<li>​<strong>​对齐在缓存行内​</strong>​（通常64字节对齐）</li>
<li>​<strong>​目标地址未跨缓存行​</strong>​（Non-split Access）</li>
<li>​<strong>​CPU支持缓存锁定技术​</strong>​（几乎所有现代处理器）</li>
</ol>

        <h3 id="工作流程"   >
          <a href="#工作流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：两个线程在核 0 和核 1 上执行原子操作</span></span><br><span class="line"><span class="comment">// 初始状态：变量 X 被核 0 和核 1 缓存（Shared状态）</span></span><br><span class="line"><span class="number">1.</span> 核<span class="number">0</span>执行原子操作（如X++）:</span><br><span class="line">   - 发出RFO（Request For Ownership）消息</span><br><span class="line">   - 其他核心将X的缓存行置为Invalid</span><br><span class="line">   - 核<span class="number">0</span>将缓存行置为Modified状态</span><br><span class="line">   - 执行修改（未触发总线锁）</span><br><span class="line"><span class="number">2.</span> 核<span class="number">1</span>尝试操作X：</span><br><span class="line">   - 发现缓存失效（Invalid）</span><br><span class="line">   - 从核<span class="number">0</span>的缓存中读取最新数据（缓存行状态转为Shared）</span><br></pre></td></tr></table></div></figure>

        <h3 id="避免缓存冲突"   >
          <a href="#避免缓存冲突" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#避免缓存冲突"></a> 避免缓存冲突</h3>
      

        <h4 id="内存对齐避免总线锁"   >
          <a href="#内存对齐避免总线锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存对齐避免总线锁"></a> 内存对齐避免总线锁</h4>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：变量可能跨缓存行</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unaligned</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">62</span>]; <span class="comment">// 62字节填充</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; x; <span class="comment">// 位于62-66字节（跨越两个缓存行）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：强制缓存行对齐</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Aligned</span><br><span class="line">&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; x; <span class="comment">// 独占一个缓存行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>检测方法：Linux下<code>perf c2c</code>可检测缓存行冲突（False Sharing）</p>
</blockquote>

        <h4 id="写竞争下的性能差异"   >
          <a href="#写竞争下的性能差异" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#写竞争下的性能差异"></a> 写竞争下的性能差异​</h4>
      
<p>当两个CPU核心频繁写​<strong>​同一缓存行​</strong>​时：</p>
<ul>
<li>​<strong>​缓存锁场景​</strong>​：缓存行在<code>Modified</code>↔<code>Invalid</code>状态间震荡，产生大量RFO消息</li>
<li>​<strong>​解决方案​</strong>​：​<strong>​伪共享隔离（False Sharing Elimination）</strong></li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多核计数器优化（每个核独占缓存行）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PerCoreCounter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">64</span>) std::atomic&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line">PerCoreCounter counters[CPU_CORES]; </span><br></pre></td></tr></table></div></figure>

        <h2 id="特殊场景总线锁不可避免"   >
          <a href="#特殊场景总线锁不可避免" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#特殊场景总线锁不可避免"></a> 特殊场景总线锁不可避免</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK XCHG [mem], reg  ; 显式LOCK前缀</span><br><span class="line">CMPXCHG16B m128       ; 128位跨缓存行操作</span><br><span class="line">一个未对齐的LOCK操作    ; 如对跨64字节边界的int操作</span><br></pre></td></tr></table></div></figure>

        <h2 id="对比-2"   >
          <a href="#对比-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#对比-2"></a> 对比</h2>
      
<div class="table-container"><table>
<thead>
<tr>
<th>​<strong>​特征​</strong>​</th>
<th>总线锁</th>
<th>缓存锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>​<strong>​锁定范围​</strong>​</td>
<td>整个内存总线</td>
<td>单个缓存行</td>
</tr>
<tr>
<td>​<strong>​性能影响​</strong>​</td>
<td>全局停顿，性能损失严重</td>
<td>仅影响涉及特定缓存行的操作</td>
</tr>
<tr>
<td>​<strong>​触发条件​</strong>​</td>
<td><code>LOCK</code>前缀指令</td>
<td>内存对齐且未跨缓存行的原子操作</td>
</tr>
<tr>
<td>​<strong>​实现技术​</strong>​</td>
<td>硬件信号硬阻塞</td>
<td>MESI缓存一致性协议</td>
</tr>
<tr>
<td>​<strong>​现代应用​</strong>​</td>
<td>仅作兜底（如跨缓存行操作）</td>
<td>99%原子操作的默认实现</td>
</tr>
<tr>
<td>​<strong>​能耗​</strong>​</td>
<td>高（总线开关）</td>
<td>低（仅缓存状态切换）</td>
</tr>
</tbody>
</table></div>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/99/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/99/">99</a><span class="page-number current">100</span><a class="page-number" href="/page/101/">101</a><span class="space">&hellip;</span><a class="page-number" href="/page/152/">152</a><a class="extend next" rel="next" href="/page/101/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">303</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>