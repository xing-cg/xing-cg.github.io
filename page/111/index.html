<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/111/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/111/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.0.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Cpp/Cpp_%E7%BA%BF%E7%A8%8B%E5%BA%93/">Cpp_线程库</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-27</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Cpp/Cpp_%E7%BA%BF%E7%A8%8B%E5%BA%93/" data-flag-title="Cpp_线程库"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>线程的构造</li>
<li>detach、join</li>
<li><code>mutex</code>、<code>recursive_mutex</code>、<code>shared_mutex</code></li>
<li><code>lock_guard</code>、<code>unique_lock</code>、<code>shared_lock</code></li>
<li>chrono</li>
<li><code>std::ref</code></li>
<li>jthread
<ol>
<li>线程取消</li>
</ol>
</li>
<li>条件变量
<ol>
<li>wait、<code>wait_for</code>、<code>wait_until</code></li>
</ol>
</li>
<li>future、promise
<ol>
<li><code>packaged_task</code></li>
<li>async</li>
</ol>
</li>
<li>信号量</li>
<li>闩锁（latch）、屏障（Barrier）</li>
</ol>

        <h1 id="chrono"   >
          <a href="#chrono" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#chrono"></a> chrono</h1>
      
<p><code>std::this_thread::sleep_for</code>可以用于线程睡眠。</p>
<ol>
<li>可以使用<code>&lt;chrono&gt;</code>库下的<code>std::chrono::milliseconds(n)</code>来指定时间单位。</li>
<li><code>C++17</code>之后可以使用<code>using namespace std::chrono_literals</code>用于把字面常量标识符映射为秒、毫秒等。</li>
</ol>
<p><img src="../../images/Cpp_%E7%BA%BF%E7%A8%8B%E5%BA%93/image-20240722225224344.png" alt="" /></p>

        <h1 id="thread创建线程-卖票程序"   >
          <a href="#thread创建线程-卖票程序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread创建线程-卖票程序"></a> thread创建线程 - 卖票程序</h1>
      
<ol>
<li>用<code>std::thread</code>构造。
<ol>
<li>参数1填函数地址。</li>
<li>参数2填函数参数，没有则不填。</li>
<li>遵循的是RAII，构造完即开始运行。</li>
</ol>
</li>
<li>线程对象有<code>detach</code>方法用来脱离主线程的管理。防止主线程先于子线程结束导致线程因为整个进程提前终止而未执行完毕。</li>
<li>也可以使用<code>th.join()</code>方法来让主线程等待子线程执行结束。相当于WaitForSingleObject</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(&amp;station)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th2</span><span class="params">(&amp;station2)</span></span>;</span><br><span class="line">    th.<span class="built_in">detach</span>();</span><br><span class="line">    th<span class="number">2.</span><span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">//std::this_thread::sleep_for(std::chrono::milliseconds(5000));</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5000</span>ms);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #1: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #2: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="输出"   >
          <a href="#输出" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#输出"></a> 输出</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Station #1: 100</span><br><span class="line">Station #1: 99</span><br><span class="line">...</span><br><span class="line">Station #1: ...</span><br><span class="line">...</span><br><span class="line">Station #1: 89</span><br><span class="line">Station #1: 88</span><br><span class="line">Station #1: 87</span><br><span class="line">Station #2: 86</span><br><span class="line">Station #2: 85</span><br><span class="line">...</span><br><span class="line">Station #2: ...</span><br><span class="line">...</span><br><span class="line">Station #2: 67</span><br><span class="line">Station #2: 66</span><br><span class="line">Station #2: 65</span><br><span class="line">Station #2: 64</span><br><span class="line">Station #2: 63</span><br><span class="line">Station #2: 62</span><br><span class="line">Station #1: 61</span><br><span class="line">Station #1: 60</span><br><span class="line">...</span><br><span class="line">Station #1: ...</span><br><span class="line">...</span><br><span class="line">Station #1: 5</span><br><span class="line">Station #1: 4</span><br><span class="line">Station #1: 3</span><br><span class="line">Station #1: 2</span><br><span class="line">Station #1: 1</span><br><span class="line">Station #2: 0</span><br></pre></td></tr></table></div></figure>
<p>发现把0号票卖掉了，错误。</p>

        <h1 id="mutex互斥量"   >
          <a href="#mutex互斥量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mutex互斥量"></a> mutex（互斥量）</h1>
      
<p>定义于<code>&lt;mutex&gt;</code>中。</p>

        <h2 id="mutex特性构造函数以及不可复制性"   >
          <a href="#mutex特性构造函数以及不可复制性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mutex特性构造函数以及不可复制性"></a> mutex特性：构造函数以及不可复制性</h2>
      
<p>在<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://legacy.cplusplus.com/reference/mutex/mutex/mutex/" >mutex构造函数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中指出，构造一个mutex对象，初始状态是解锁。<br />
mutex对象不能被复制、移动（复制构造函数和赋值运算符都被删除）<br />
因此，要特别注意你创建的mutex的生命周期，不建议建立在栈帧随时塌陷的位置。</p>

        <h2 id="recursive_mutex多次互斥量"   >
          <a href="#recursive_mutex多次互斥量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#recursive_mutex多次互斥量"></a> recursive_mutex（多次互斥量）</h2>
      
<p>单纯的mutex只能锁一次。<br />
<code>recursive_mutex</code>可以锁多次，也可以解锁多次。</p>

        <h2 id="基于c标准线程库互斥量的卖票程序"   >
          <a href="#基于c标准线程库互斥量的卖票程序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基于c标准线程库互斥量的卖票程序"></a> 基于C++标准线程库互斥量的卖票程序</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;print&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seller</span><span class="params">(std::string <span class="type">const</span>&amp; name, <span class="type">int</span>&amp; ticketsNum, std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::jthread&gt; vec_jthreads;</span><br><span class="line">    <span class="type">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line">    std::mutex mx;</span><br><span class="line">    <span class="comment">// start new thread</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;seller &quot;</span> &lt;&lt; i;</span><br><span class="line">        vec_jthreads.<span class="built_in">emplace_back</span>(seller, ss.<span class="built_in">str</span>(), std::<span class="built_in">ref</span>(tickets), std::<span class="built_in">ref</span>(mx));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; jth : vec_jthreads)</span><br><span class="line">    &#123;</span><br><span class="line">        jth.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">println</span>(<span class="string">&quot;Finally, tickets remain: &#123;&#125;&quot;</span>, tickets);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seller</span><span class="params">(std::string <span class="type">const</span>&amp; name, <span class="type">int</span>&amp; tickets, std::mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1000</span>ms);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, name, tickets);</span><br><span class="line">            --tickets;</span><br><span class="line">            mx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="输出-2"   >
          <a href="#输出-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#输出-2"></a> 输出</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Station #1: 500</span><br><span class="line">Station #1: 499</span><br><span class="line">...</span><br><span class="line">Station #1: ...</span><br><span class="line">...</span><br><span class="line">Station #1: 394</span><br><span class="line">Station #1: 393</span><br><span class="line">----------------------</span><br><span class="line">Station #2: 392</span><br><span class="line">Station #2: 391</span><br><span class="line">...</span><br><span class="line">Station #2: ...</span><br><span class="line">...</span><br><span class="line">Station #2: 5</span><br><span class="line">Station #2: 4</span><br><span class="line">Station #2: 3</span><br><span class="line">Station #2: 2</span><br><span class="line">Station #2: 1</span><br></pre></td></tr></table></div></figure>

        <h2 id="分析"   >
          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
      
<p>可以看到线程1、2各自持有锁的跨度还是挺大的，这是因为在<code>跨平台C++线程库</code>在Windows下的执行是用<code>Windows临界区</code>实现的。</p>

        <h1 id="作为引用传入线程函数参数stdref"   >
          <a href="#作为引用传入线程函数参数stdref" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#作为引用传入线程函数参数stdref"></a> 作为引用传入线程函数参数（<code>std::ref</code>）</h1>
      
<ol>
<li><code>std::mutex</code>锁是不可复制的。只能通过引用传递。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mx;</span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(&amp;station, mx)</span></span>; <span class="comment">// error</span></span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此时，虽然线程函数参数类型为引用，但实际写的代码中，“mx”这个形式和值类型的形式不能区分，编译器无法对其直接解析为引用，产生二义性。（即编译器默认都先按照值传递处理，之后才去处理、区分是否为引用）<br />
2. 因此不能直接裸传，为了显式指出此变量为引用类型，要包装一层“引用包裹器”。<code>std::reference_wrapper(mx)</code>，也可以简写为<code>std::ref(mx)</code>。在实际使用到该引用类型变量时，包裹器会自己释放出实际内容。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mx;</span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(&amp;station, std::ref(mx))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th2</span><span class="params">(&amp;station2, std::ref(mx))</span></span>;</span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    th<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="解析stdref"   >
          <a href="#解析stdref" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解析stdref"></a> 解析<code>std::ref</code></h2>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> &amp; ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;thread fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	ret = n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;thread fun end&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">tha</span><span class="params">(fun, <span class="number">5</span>, std::ref(x))</span></span>;</span><br><span class="line">	tha.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; endl;		<span class="comment">//输出5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">tha</span><span class="params">(fun, <span class="number">5</span>, x)</span></span>;		<span class="comment">//编译不通过</span></span><br><span class="line">	tha.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>为什么直接传x不能编译通过呢？因为thread的构造距离start线程中间有一层可变参模板组件：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(Function&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fn</span>, <span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _Start(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>thread的构造需要先通过这个组件，则由于<code>args</code>是按<code>[模板 &amp;&amp;]</code>接收，如果直接单纯传<code>x</code>，则会识别为普通的<code>int</code>值传递，在到达<code>_Start</code>接口后，<code>x</code>的<code>int</code>类型与参数类型<code>int &amp;</code>不匹配，无法编译通过。</p>
<p>所以需要一个特殊的机制，用<code>std::ref</code>显式指出把<code>x</code>按引用方式传递（传地址），如此，在经过模板时，按转发引用处理，经过<code>_Start</code>接口的完美转发后作为右值<strong>隐式转换</strong>为<code>int &amp;</code>类型，如此便可编译通过，达到按引用传参的目的。</p>
<p>为什么是隐式转换？</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::ref的底层是reference_wrapper类，其中有隐式转换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reference_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> type = _Ty;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Uty</span>&gt;</span><br><span class="line">    <span class="built_in">reference_wrapper</span>(_Uty&amp;&amp; _Val)</span><br><span class="line">    &#123;</span><br><span class="line">        _Ty&amp; _Ref = <span class="built_in">static_cast</span>&lt;_Uty&amp;&amp;&gt;(_Val);</span><br><span class="line">        _Ptr      = &amp;_Ref;	<span class="comment">/*_STD addressof(_Ref);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ty* _Ptr&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>测试</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//std::ref的底层是reference_wrapper类，其中有隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_reference_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> type = _Ty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Uty</span>&gt;</span><br><span class="line">    <span class="built_in">my_reference_wrapper</span>(_Uty&amp;&amp; _Val)</span><br><span class="line">    &#123;</span><br><span class="line">        _Ty&amp; _Ref = <span class="built_in">static_cast</span>&lt;_Uty&amp;&amp;&gt;(_Val);</span><br><span class="line">        _Ptr = &amp;_Ref;	<span class="comment">/*_STD addressof(_Ref);*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> _Ty&amp;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ty* _Ptr&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    x = n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread fun end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">tha</span><span class="params">(fun, <span class="number">5</span>, my_reference_wrapper&lt;<span class="type">int</span>&gt;(x))</span></span>;</span><br><span class="line">    tha.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fn</span>, <span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(_Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _Start(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>构造tha时的第三个参数是<code>my_reference_wrapper&lt;int&gt;(x)</code>，是个右值！传入thread可变参模板函数，完美转发，右值叠加右值，依然是右值，调用<code>_Start</code>时优先匹配<code>&amp;&amp;</code>类型的参数，但是发现没有，而且只有一个匹配的选项是：<code>(int n, int &amp; x)</code>，是<code>int&amp;</code>类型，于是乎，无奈之举，调用成员函数<code>operator _Ty()</code>，即为隐式转换为<code>&amp;Ty</code>的左值引用类型。</p>
<p>如此一来，即可把线程函数外部的<code>x</code>按引用传递。</p>

        <h1 id="变量的作用域"   >
          <a href="#变量的作用域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#变量的作用域"></a> 变量的作用域</h1>
      
<p>Modern Cpp引入了一些变量的作用域关键字。<br />
变量的作用域类型：</p>
<ol>
<li>全局</li>
<li>auto（局部）：在当前栈帧下</li>
<li>thread_local：用于修饰全局变量。不同线程访问相同名字的全局变量，会自动生成副本，对此名字变量的操作只在当前线程有效，不会影响到其他人。</li>
</ol>

        <h1 id="lock_guard"   >
          <a href="#lock_guard" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lock_guard"></a> lock_guard</h1>
      
<p>定义于<code>&lt;mutex&gt;</code>中。用于帮助管理mutex。<br />
RAII对象。自动管理生命周期。<br />
需要一个mutex锁来构造。构造后立刻对mutex上锁，直到<code>lock_guard</code>自身析构时对mutex解锁。<br />
与mutex一样，<code>lock_guard</code>对象无法复制/移动。</p>
<blockquote>
<p><code>lock_guard</code>是一个模板类，需要一个模板参数，如填写<code>&lt;std::mutex&gt;</code>。在<code>C++17</code>后，不用填写模板参数，可以自动判断程序代码大括号中的参数类型。</p>
</blockquote>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mx;</span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(&amp;station, std::ref(mx))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th2</span><span class="params">(&amp;station2, std::ref(mx))</span></span>;</span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    th<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lck&#123; mx &#125;;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #1: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 退出此括号时，lck析构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard lck&#123; mx &#125;; <span class="comment">// 在`C++17`后，不用填写模板参数，可以自动判断程序代码大括号中的参数类型。</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #2: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 退出此括号时，lck析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="unique_lock"   >
          <a href="#unique_lock" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#unique_lock"></a> unique_lock</h1>
      
<p>是<code>lock_guard</code>的多功能版，可以自己控制unlock、转移所有权。<br />
定义于<code>&lt;mutex&gt;</code>中</p>
<ol>
<li>和<code>lock_guard</code>用法一样，但是<code>unique_lock</code>支持转移给另一个<code>unique_lock</code>。（需要使用<code>std::move</code>）</li>
<li>有unlock、release、swap方法。</li>
<li>可以管理普通<code>mutex</code>，也可以管理<code>shared_mutex</code>。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mx;</span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(&amp;station, std::ref(mx))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th2</span><span class="params">(&amp;station2, std::ref(mx))</span></span>;</span><br><span class="line">    th.<span class="built_in">join</span>();</span><br><span class="line">    th<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_lock lck&#123; mx &#125;;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #1: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">            std::unique_lock lck2 = std::<span class="built_in">move</span>(lck);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 退出此括号时，lck2、lck析构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// station2 ...</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="输出-3"   >
          <a href="#输出-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#输出-3"></a> 输出</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Station #1: 100</span><br><span class="line">Station #1: 99</span><br><span class="line">...</span><br><span class="line">Station #1: ...</span><br><span class="line">...</span><br><span class="line">Station #1: 67</span><br><span class="line">Station #1: 66</span><br><span class="line">Station #2: 65</span><br><span class="line">Station #2: 64</span><br><span class="line">...</span><br><span class="line">Station #2: ...</span><br><span class="line">...</span><br><span class="line">Station #2: 8</span><br><span class="line">Station #2: 7</span><br><span class="line">Station #2: 6</span><br><span class="line">Station #2: 5</span><br><span class="line">Station #2: 4</span><br><span class="line">Station #2: 3</span><br><span class="line">Station #2: 2</span><br><span class="line">Station #2: 1</span><br></pre></td></tr></table></div></figure>

        <h1 id="shared_mutex共享互斥量"   >
          <a href="#shared_mutex共享互斥量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#shared_mutex共享互斥量"></a> shared_mutex（共享互斥量）</h1>
      
<p>定义于<code>&lt;shared_mutex&gt;</code>，<code>C++17</code>给出的共享互斥量。</p>
<p>Shared mutexes are especially useful when shared data can be safely read by any number of threads simultaneously, but a thread may only write the same data when no other thread is reading or writing at the same time.</p>
<p>消费者可以共同访问，但不能和生产者一起共享。</p>
<ol>
<li>提供的方法：
<ol>
<li><code>lock_shared</code>用于消费者共享互斥量。</li>
<li><code>lock</code>用于生产者独占互斥量。</li>
<li><code>lock</code>和<code>lock</code>，<code>lock</code>和<code>lock_shared</code>都互斥。</li>
</ol>
</li>
<li>在生产者消费者模型中，<code>lock_shared</code>、<code>unlock_shared</code>用于<code>n</code>个消费者一起进入消费。<code>lock</code>、<code>unlock</code>用于阻断<strong>所有消费者、其他生产者</strong>进入。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> tickets&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::shared_mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::shared_mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">(std::shared_mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_mutex mx;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">(&amp;station, std::ref(mx))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(&amp;station2, std::ref(mx))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(&amp;produce, std::ref(mx))</span></span>;</span><br><span class="line"></span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">(std::shared_mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mx.<span class="built_in">lock</span>();</span><br><span class="line">        std::wcout &lt;&lt; <span class="string">L&quot;Producer: &quot;</span> &lt;&lt; ++tickets &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">500</span>ms);</span><br><span class="line">        mx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::shared_mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mx.<span class="built_in">lock_shared</span>();</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #1: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">            mx.<span class="built_in">unlock_shared</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mx.<span class="built_in">unlock_shared</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::shared_mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mx.<span class="built_in">lock_shared</span>();</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #2: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">            mx.<span class="built_in">unlock_shared</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mx.<span class="built_in">unlock_shared</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="输出-4"   >
          <a href="#输出-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#输出-4"></a> 输出</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Producer: 1</span><br><span class="line">Station #2: 1</span><br><span class="line">Station #1: 0</span><br><span class="line">Producer: 0</span><br><span class="line">Producer: 1</span><br><span class="line">Producer: 2</span><br><span class="line">Producer: 3</span><br><span class="line">Station #2: 3</span><br><span class="line">Station #1: 2</span><br><span class="line">Station #1: 1</span><br><span class="line">Producer: 1</span><br><span class="line">Producer: 2</span><br><span class="line">Producer: 3</span><br><span class="line">Station #2: 3</span><br><span class="line">Station #2: 2</span><br><span class="line">Station #2: 1</span><br><span class="line">Producer: 1</span><br><span class="line">Station #2: 1</span><br><span class="line">Producer: 1</span><br><span class="line">Producer: 2</span><br><span class="line">Producer: 3</span><br><span class="line">Producer: 4</span><br><span class="line"> ...</span><br></pre></td></tr></table></div></figure>

        <h2 id="分析-2"   >
          <a href="#分析-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2>
      
<ol>
<li>输出中看到1个producer和2个consumer是互斥的，有一方在则另一方不动。</li>
<li>输出中看到0号票有时候也会被卖掉。证明了<code>mx.lock_shared()</code>只是让n个消费者同时拿到锁，并且没有做进一步的同步管理。</li>
</ol>

        <h1 id="shared_lock和unique_lock搭配管理shared_mutex"   >
          <a href="#shared_lock和unique_lock搭配管理shared_mutex" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#shared_lock和unique_lock搭配管理shared_mutex"></a> shared_lock和unique_lock搭配管理shared_mutex</h1>
      
<ol>
<li>把<code>shared_mutex</code>的开锁解锁的动作让锁管理器（<code>shared_lock</code>和<code>unique_lock</code>）接管。</li>
<li><code>shared_mutex</code>的lock、unlock动作让<code>unique_lock</code>接管</li>
<li><code>shared_mutex</code>的lock_shared、unlock_shared动作让<code>shared_lock</code>接管。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> tickets&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::shared_mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station2</span><span class="params">(std::shared_mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">(std::shared_mutex&amp; mx)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_mutex mx;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">(&amp;station, std::ref(mx))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(&amp;station2, std::ref(mx))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">(&amp;produce, std::ref(mx))</span></span>;</span><br><span class="line"></span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">(std::shared_mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_lock lck&#123; mx &#125;;</span><br><span class="line">        std::wcout &lt;&lt; <span class="string">L&quot;Producer: &quot;</span> &lt;&lt; ++tickets &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">500</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">station</span><span class="params">(std::shared_mutex&amp; mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_lock lck&#123; mx &#125;;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #1: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">station2</span>(std::shared_mutex&amp; mx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_lock lck&#123; mx &#125;;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Station #2: &quot;</span> &lt;&lt; tickets-- &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="c多线程与lambda表达式结合"   >
          <a href="#c多线程与lambda表达式结合" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c多线程与lambda表达式结合"></a> <code>C++</code>多线程与lambda表达式结合</h1>
      
<p>使用lambda表达式定义一个线程函数：每100ms打印从0到100。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#Include &lt;thread&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(<span class="number">100</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="lambda函数参数的处理"   >
          <a href="#lambda函数参数的处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lambda函数参数的处理"></a> lambda函数参数的处理</h2>
      
<p>lambda表达式作为线程函数，如果有其自己的内部参数，那么就需要传入lambda表达式后，再传入其使用的参数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#Include &lt;thread&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> nums&#123; <span class="number">100</span> &#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([](<span class="keyword">auto</span> nu) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nu; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(<span class="number">100</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            nu = <span class="number">50</span>; <span class="comment">// 带不回去</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, nums)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([](<span class="type">int</span>&amp; nu) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nu; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(<span class="number">100</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            nu = <span class="number">50</span>;  <span class="comment">// 带回去修改了nums的值</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, std::ref(nums))</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ol>
<li>参数按值传递：lambda形参类型可以用auto。</li>
<li>参数按引用传递：传参时必须用<code>std::ref</code>。此时由于有引用包裹器，auto不能推导。所以lambda形参类型不可以用<code>auto &amp;</code>，也不可以用<code>auto &amp;&amp;</code>，必须明确<code>ClassName &amp;</code></li>
</ol>

        <h1 id="jthread"   >
          <a href="#jthread" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#jthread"></a> jthread</h1>
      
<p><code>C++20</code>下的加强版thread类</p>
<ol>
<li>如果main函数中没写t1的join，那么会先到<code>return 0;</code>，之后在main即将return 0时，t1析构时，自动地为t1调用join，则最后主线程等待t1结束后一起退出。如果明确写了join则按照普通thread的join时机。</li>
<li>如果只写detach，那么最后就不会自动加join，主线程退出时子线程也会退出。</li>
</ol>

        <h2 id="线程取消"   >
          <a href="#线程取消" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程取消"></a> 线程取消</h2>
      
<p><img src="../../images/Cpp_%E7%BA%BF%E7%A8%8B%E5%BA%93/image-20240723044901963.png" alt="" /><br />
这些 <code>stop_XXX</code> 类型都在<code>&lt;stop_token&gt;</code>中定义，旨在使<code>jthread</code>取消，尽管它们也可以独立使用 <code>std::jthread</code> - 例如，中断<code>std::condition_variable_any</code>等待函数，或用于自定义线程管理实现。事实上，它们甚至不需要用于“停止”任何东西，而是可以用于线程安全的一次性函数调用触发器。（这段话的意思大概是，<code>stop_token</code>只是叫做“停止”，但实际上没有真的停止动作）</p>

        <h3 id="stop_token-stop_requested"   >
          <a href="#stop_token-stop_requested" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stop_token-stop_requested"></a> stop_token、stop_requested</h3>
      
<ol>
<li>
<p>token会共享一个标记性的对象</p>
</li>
<li>
<p>线程可以<code>get_stop_token</code>获得token</p>
</li>
<li>
<p>线程可以<code>request_stop</code>通知停止</p>
<ol>
<li>旧的让线程停止的手段：需要建立如Windows下的Event，通过Event让线程停止。现在这种<code>stop_token</code>方法使线程停止更简洁了。</li>
</ol>
</li>
<li>
<p>如果要传入<code>stop_token</code>，jthread的线程函数中内部的第1个参数必须写<code>std::stop_token</code></p>
</li>
<li>
<p>jthread提供了<code>request_stop</code>函数。提供了<code>get_stop_token</code>函数。</p>
</li>
</ol>
<p>以下程序表示：</p>
<ol>
<li>主线程创建t1，内部有一个tok每100ms查看是否有外部请求停止。</li>
<li>程序执行3s后，主线程调用<code>t1.request_stop()</code>请求t1停止。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t1</span><span class="params">([](std::stop_token tok) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (tok.stop_requested())</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(<span class="number">100</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">        </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">request_stop</span>();</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3>
      
<p>传输文件过程中，通过token这种类似于信号的东西，用于控制另一个线程。（传统方法是需要WaitForSingleObject，较为繁琐）<br />
这是一种面向对象的设计，token可以通过传参传递，按照事件通知的方式，按需快速使用。</p>

        <h3 id="stop_possible"   >
          <a href="#stop_possible" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stop_possible"></a> stop_possible</h3>
      
<p>可看<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/stop_token/stop_possible" >std::stop_token::stop_possible</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的代码示例。</p>

        <h3 id="stop_source"   >
          <a href="#stop_source" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stop_source"></a> stop_source</h3>
      
<p>jthread对象可以通过调用<code>get_stop_source</code>，返回与 <code>jthread</code> 对象内部保存的相同共享停止状态关联的 <code>std::stop_source</code>。</p>
<p>获取到jthread的source后就不用操作jthread了，可以通过source进行：</p>
<ol>
<li><code>source.get_token()</code>，就相当于<code>t1.get_stop_token()</code></li>
<li><code>source.request_stop()</code></li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stop_token&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t1</span><span class="params">([](std::stop_token tok) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (tok.stop_requested())</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(<span class="number">100</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> source = t<span class="number">1.</span><span class="built_in">get_stop_source</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">    source.<span class="built_in">request_stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="stop_callback"   >
          <a href="#stop_callback" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stop_callback"></a> stop_callback</h3>
      
<p>定义于<code>&lt;stop_token&gt;</code>，用于搭配<code>stop_token</code>使用，指示线程取消后进行的回调操作。</p>
<ol>
<li>需要一个<code>stop_token</code>和一个函数作为构造</li>
<li>当该<code>stop_token</code>对应的线程得到<code>stop_requested</code>信号时，调用<code>stop_callback</code>构造时绑定的函数。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stop_token&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t1</span><span class="params">([](std::stop_token tok) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (tok.stop_requested())</span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::this_thread::sleep_for(<span class="number">100</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::stop_callback cb&#123; t<span class="number">1.</span><span class="built_in">get_stop_token</span>(), []() -&gt; <span class="type">void</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::wcout &lt;&lt; <span class="string">L&quot;Stopped!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">request_stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>可能的输出：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">Stopped!</span><br><span class="line">28</span><br></pre></td></tr></table></div></figure>

        <h1 id="条件变量wait"   >
          <a href="#条件变量wait" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#条件变量wait"></a> 条件变量（wait）</h1>
      
<p>从<code>C++11</code>就开始引入了</p>
<p>类似于Windows下的信号（事件）。</p>
<p><code>Modern C++</code>中通用的用于通知、等待的工具。</p>
<p>需要和锁配套使用，因为cv的wait方法需要传入一个<code>std::unique_lock&lt;std::mutex&gt;</code>参数</p>
<p>以下程序说的是：</p>
<ol>
<li>创建一个t1线程</li>
<li>t1线程尝试拿mx锁</li>
<li>拿到mx后，在mx锁上面wait，释放锁，之后休眠（进入等待队列）</li>
<li>如果没有通知则一直阻塞。</li>
<li>主线程休眠3s</li>
<li>主线程notify通知等待队列，唤醒了t1线程。</li>
<li>子线程t1被唤醒后，必须重新获取锁，才能返回从而继续下一步。</li>
</ol>
<p>综上所述，wait有三大步骤：</p>
<ol>
<li>释放锁</li>
<li>休眠，进入等待队列</li>
<li>被唤醒，尝试获取锁。
<ol>
<li>如果成功则进行下一步操作。</li>
<li>如果暂时没拿到锁则阻塞，直到拿到锁后才能进行下一步。
<ol>
<li>但这是因抢锁而导致阻塞，和wait的等待队列是两码事！</li>
<li>也就是说（再次强调）：wait是主动阻塞（wait之前拿到了锁，但是条件为假，主动放弃了锁）。而一旦条件为真，且被唤醒后，抢锁没抢到，则是被动阻塞。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>除了这三大步骤，还有一大前提：系统假定在wait调用前，其中的mx互斥量已上锁。所以必须在拿到锁之后才能wait。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t1</span><span class="params">([]() -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::unique_lock lck&#123; mx &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">        cv.wait(lck);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            </span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(<span class="number">100</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
      
<p>据《操作系统导论》P252 30.1节 中的提示：</p>
<blockquote>
<p>推荐在发notify信号时总是持有锁</p>
<p>尽管并不是所有情况下都严格需要，但有效且简单的做法还是在使用条件变量发送notify信号时持有锁（指要发送notify的线程）。有的例子是必须加锁的情况，但也有一些情况可以不加锁，而这可能是你应该避免（避免再去分情况考虑）的。因此，<strong>为了简单</strong>，请在调用 signal（也就是notify） 时持有锁（hold the lock when calling signal）。</p>
<p>这个提示的反面，即调用 wait 时持有锁，但这就不只是建议了，wait 的语义是强制要求前提持有锁的。因为 wait 调用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。</p>
<p>因此，可以提出一般化形式，保证程序正确：调用 signal 和 wait 时都要持有锁（hold the lock when calling signal or wait）。</p>
</blockquote>
<p>就拿上面的例子来说，如果不对<code>notify_one</code>加以同步控制的话，有可能t1线程在lck上锁的时候，主线程恰好<code>notify_one</code>，导致在其wait之前唤醒，则wait之后再也没有唤醒的机会，程序就一直阻塞了。</p>
<p>所以，在主线程中的<code>cv.notify_one()</code>语句之前加锁（记得和t1中mutex变量一致）。<br />
而且既然在<code>cv.notify_one()</code>之前加了锁，就要在<code>cv.notify_one()</code>之后解锁，是因为wait被唤醒之后还需要得到锁才能脱离阻塞继续下一步操作。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// t1 ...</span></span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">    </span><br><span class="line">    std::unique_lock lck&#123; mx &#125;;    <span class="comment">// add</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    lck.<span class="built_in">unlock</span>();                  <span class="comment">// add</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="wait_for"   >
          <a href="#wait_for" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#wait_for"></a> wait_for</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>在wait的基础上，既可以通过获得通知得到唤醒，也可以计时超时得到唤醒。<br />
即：超时后与<strong>被notify</strong>的行为一样，尝试获取锁，如果成功则下一步，如果失败则阻塞。<br />
但返回值有特点，超时则返回<code>std::cv_status::timeout</code>，其他情况返回<code>std::cv_status::no_timeout</code></p>

        <h3 id="用处结合notify来停止线程"   >
          <a href="#用处结合notify来停止线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#用处结合notify来停止线程"></a> 用处：结合notify来停止线程</h3>
      
<p>wait是用于通知线程<strong>开始</strong>下一步动作。<br />
而<code>wait_for</code>则可以用于通知线程<strong>停止</strong>。</p>
<p>以下程序是说：2个条件变量，<code>cv</code>和<code>cv2</code>，<code>cv</code>用于<code>wait</code>，以决定何时开始。<code>cv2</code>用于<code>wait_for</code>，结合返回值status，在一段时间等待停止的信号。<br />
主线程：</p>
<ol>
<li>在释放了cv对应的lck后，子线程wait成功获取到锁开始下一步。</li>
<li>休眠3s，保证子线程可以至少执行3s。</li>
<li>之后与子线程竞争lck2锁，一旦主线程拿到了，当即notify给cv2，之后释放锁。</li>
</ol>
<p>子线程：</p>
<ol>
<li>在cv上等待，一旦获取lck则下一步。</li>
<li>每次for循环都先抢lck2锁
<ol>
<li>在主线程休眠的3s内，肯定能抢到。并且每次wait_for释放锁也不会被别人抢，即不会被notify，所以返回值应该都是timeout</li>
<li>3s主线程唤醒后，与主线程竞争lck2锁
<ol>
<li>如果子先抢到了，则这一次for循环在wait_for时lck2释放50ms，如果主线程在此期间抢到了，并且发了notify，则status为<code>no_timeout</code>，子线程break结束。此情况下只能打印一半。</li>
<li>也有可能：for每次循环结束时，释放锁，主线程在很小很小的空挡内抢到锁，导致提前notify，错过cv2等待的时机，但是这个可能很小。此情况下1000个数全部输出。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::mutex mx, mx2;</span><br><span class="line">std::condition_variable cv, cv2;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t1</span><span class="params">([]() -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::unique_lock lck&#123; mx &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">        cv.wait(lck);</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Got the Notify to Start!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock lck2&#123; mx2 &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (<span class="keyword">auto</span> status = cv<span class="number">2.</span>wait_for(lck2, <span class="number">50</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">                status == std::cv_status::no_timeout)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Got the Notify to Out!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Timeout: No Notify&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    std::unique_lock lck&#123; mx &#125;;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    lck.<span class="built_in">unlock</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">    std::unique_lock lck2&#123; mx2 &#125;;</span><br><span class="line">    cv<span class="number">2.</span><span class="built_in">notify_one</span>();</span><br><span class="line">    lck<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">Got the Notify to Start!</span><br><span class="line">0</span><br><span class="line">Timeout: No Notify</span><br><span class="line">1</span><br><span class="line">Timeout: No Notify</span><br><span class="line">2</span><br><span class="line">Timeout: No Notify</span><br><span class="line">3</span><br><span class="line">Timeout: No Notify</span><br><span class="line">4</span><br><span class="line">Timeout: No Notify</span><br><span class="line">5</span><br><span class="line">Timeout: No Notify</span><br><span class="line">6</span><br><span class="line">Timeout: No Notify</span><br><span class="line">7</span><br><span class="line">Timeout: No Notify</span><br><span class="line">8</span><br><span class="line">Timeout: No Notify</span><br><span class="line">9</span><br><span class="line">Timeout: No Notify</span><br><span class="line">10</span><br><span class="line">Timeout: No Notify</span><br><span class="line">11</span><br><span class="line">Timeout: No Notify</span><br><span class="line">12</span><br><span class="line">Timeout: No Notify</span><br><span class="line">13</span><br><span class="line">Timeout: No Notify</span><br><span class="line">14</span><br><span class="line">Timeout: No Notify</span><br><span class="line">15</span><br><span class="line">Timeout: No Notify</span><br><span class="line">16</span><br><span class="line">Timeout: No Notify</span><br><span class="line">17</span><br><span class="line">Timeout: No Notify</span><br><span class="line">18</span><br><span class="line">Timeout: No Notify</span><br><span class="line">19</span><br><span class="line">Timeout: No Notify</span><br><span class="line">20</span><br><span class="line">Timeout: No Notify</span><br><span class="line">21</span><br><span class="line">Timeout: No Notify</span><br><span class="line">22</span><br><span class="line">Timeout: No Notify</span><br><span class="line">23</span><br><span class="line">Timeout: No Notify</span><br><span class="line">24</span><br><span class="line">Timeout: No Notify</span><br><span class="line">25</span><br><span class="line">Timeout: No Notify</span><br><span class="line">26</span><br><span class="line">Timeout: No Notify</span><br><span class="line">27</span><br><span class="line">Timeout: No Notify</span><br><span class="line">28</span><br><span class="line">Timeout: No Notify</span><br><span class="line">29</span><br><span class="line">Timeout: No Notify</span><br><span class="line">30</span><br><span class="line">Timeout: No Notify</span><br><span class="line">31</span><br><span class="line">Timeout: No Notify</span><br><span class="line">32</span><br><span class="line">Timeout: No Notify</span><br><span class="line">33</span><br><span class="line">Timeout: No Notify</span><br><span class="line">34</span><br><span class="line">Timeout: No Notify</span><br><span class="line">35</span><br><span class="line">Timeout: No Notify</span><br><span class="line">36</span><br><span class="line">Timeout: No Notify</span><br><span class="line">37</span><br><span class="line">Timeout: No Notify</span><br><span class="line">38</span><br><span class="line">Timeout: No Notify</span><br><span class="line">39</span><br><span class="line">Timeout: No Notify</span><br><span class="line">40</span><br><span class="line">Timeout: No Notify</span><br><span class="line">41</span><br><span class="line">Timeout: No Notify</span><br><span class="line">42</span><br><span class="line">Timeout: No Notify</span><br><span class="line">43</span><br><span class="line">Timeout: No Notify</span><br><span class="line">44</span><br><span class="line">Timeout: No Notify</span><br><span class="line">45</span><br><span class="line">Timeout: No Notify</span><br><span class="line">46</span><br><span class="line">Timeout: No Notify</span><br><span class="line">47</span><br><span class="line">Timeout: No Notify</span><br><span class="line">48</span><br><span class="line">Got the Notify to Out!</span><br></pre></td></tr></table></div></figure>

        <h3 id="问题"   >
          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
      
<p>上面那个程序，经过VS编译运行在Windows11时，很有可能会出现这种情况：<br />
（为了让问题更加明显，主线程部分代码改为以下：加长了第二段睡眠时间，并且在睡眠前后加输出提示）</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;After Sleep 1s...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::unique_lock lck&#123; mx &#125;;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    lck.<span class="built_in">unlock</span>();</span><br><span class="line">    </span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;Before Sleep 8s...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">8</span>s);</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;After Sleep 8s...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::unique_lock lck2&#123; mx2 &#125;;</span><br><span class="line">    cv<span class="number">2.</span><span class="built_in">notify_one</span>();</span><br><span class="line">    lck<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>主线程明明8秒后才会notify_one，但是某时的输出结果下，居然很快就让子线程停止了，这是怎么回事？<br />
观察输出信息，发现，主线程还没输出<code>After Sleep 8s...</code>，子线程就被通知了，证明notify肯定不是主线程发出的。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">After Sleep 1s...</span><br><span class="line">Before Sleep 8s...</span><br><span class="line">Got the Notify to Start!</span><br><span class="line">0</span><br><span class="line">Timeout: No Notify</span><br><span class="line">1</span><br><span class="line">Timeout: No Notify</span><br><span class="line">2</span><br><span class="line">Timeout: No Notify</span><br><span class="line">3</span><br><span class="line">Timeout: No Notify</span><br><span class="line">4</span><br><span class="line">Timeout: No Notify</span><br><span class="line">5</span><br><span class="line">Got the Notify to Out!</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="假唤醒"   >
          <a href="#假唤醒" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#假唤醒"></a> 假唤醒</h2>
      
<p>在wait（普通、for、until）等待过程中，线程可能会因为假唤醒而提前被唤醒，而不是因为条件变量被通知。</p>
<p>假唤醒可以看作是操作系统故意替程序员<code>notify_one</code>，会让子线程会认为<code>wait_for</code>已经被唤醒，从而退出循环。</p>
<blockquote>
<p>普通的<code>wait</code>在Windows下不会假唤醒。而在Unix、Linux、Solaris、AIX中行为可能会不同。</p>
</blockquote>
<p>在当前的代码中，当<code>wait_for</code>返回时，仅通过检查<code>timeout</code>与否来决定是否退出循环。如果是因为假唤醒而返回，<code>status == std::cv_status::no_timeout</code>可能依然为真，这会导致线程提前结束。</p>
<p>为了防止假唤醒带来的问题，通常的做法是在等待后检查共享条件变量状态是否满足。你可以通过在<code>wait_for</code>之后再检查一个bool标志（例如<code>stop_requested</code>）来决定是否退出循环。<br />
在上面的程序中，在全局区定义它，初值为false，并且在<code>cv2.notify_one</code>语句之前置为true。这样，不仅要通过判断是否timeout，还要判断bool标志，以确信是我们自己发出的唤醒。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::mutex mx, mx2;</span><br><span class="line">std::condition_variable cv, cv2;</span><br><span class="line"><span class="type">bool</span> stop_requested = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t1</span><span class="params">([]() -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::unique_lock lck&#123; mx &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">        cv.wait(lck);</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Got the Notify to Start!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock lck2&#123; mx2 &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (<span class="keyword">auto</span> status = cv<span class="number">2.</span>wait_for(lck2, <span class="number">50</span>ms);</span></span></span><br><span class="line"><span class="params"><span class="function">                status == std::cv_status::no_timeout &amp;&amp; stop_requested == <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Got the Notify to Out!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;Timeout: No Notify&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;After Sleep 1s...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::unique_lock lck&#123; mx &#125;;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    lck.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;Before Sleep 8s...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">8</span>s);</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;After Sleep 8s...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::unique_lock lck2&#123; mx2 &#125;;</span><br><span class="line">    stop_requested = <span class="literal">true</span>;</span><br><span class="line">    cv<span class="number">2.</span><span class="built_in">notify_one</span>();</span><br><span class="line">    lck<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="可用lambda表达式作为谓词简化代码"   >
          <a href="#可用lambda表达式作为谓词简化代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#可用lambda表达式作为谓词简化代码"></a> 可用lambda表达式作为谓词简化代码</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(lck, [&amp;stop_requested]() -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> stop_requested; &#125;);</span><br></pre></td></tr></table></div></figure>
<p>输出</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">After Sleep 1s...</span><br><span class="line">Before Sleep 8s...</span><br><span class="line">Got the Notify to Start!</span><br><span class="line">0</span><br><span class="line">Timeout: No Notify</span><br><span class="line">1</span><br><span class="line">Timeout: No Notify</span><br><span class="line">2</span><br><span class="line">Timeout: No Notify</span><br><span class="line">3</span><br><span class="line">Timeout: No Notify</span><br><span class="line">4</span><br><span class="line">Timeout: No Notify</span><br><span class="line">5</span><br><span class="line">Timeout: No Notify</span><br><span class="line">6</span><br><span class="line">Timeout: No Notify</span><br><span class="line">7</span><br><span class="line">Timeout: No Notify</span><br><span class="line">8</span><br><span class="line">Timeout: No Notify</span><br><span class="line">9</span><br><span class="line">Timeout: No Notify</span><br><span class="line">10</span><br><span class="line">Timeout: No Notify</span><br><span class="line">11</span><br><span class="line">Timeout: No Notify</span><br><span class="line">12</span><br><span class="line">Timeout: No Notify</span><br><span class="line">13</span><br><span class="line">Timeout: No Notify</span><br><span class="line">14</span><br><span class="line">Timeout: No Notify</span><br><span class="line">15</span><br><span class="line">Timeout: No Notify</span><br><span class="line">16</span><br><span class="line">Timeout: No Notify</span><br><span class="line">17</span><br><span class="line">Timeout: No Notify</span><br><span class="line">18</span><br><span class="line">Timeout: No Notify</span><br><span class="line">19</span><br><span class="line">Timeout: No Notify</span><br><span class="line">20</span><br><span class="line">Timeout: No Notify</span><br><span class="line">21</span><br><span class="line">Timeout: No Notify</span><br><span class="line">22</span><br><span class="line">Timeout: No Notify</span><br><span class="line">23</span><br><span class="line">Timeout: No Notify</span><br><span class="line">24</span><br><span class="line">Timeout: No Notify</span><br><span class="line">25</span><br><span class="line">Timeout: No Notify</span><br><span class="line">26</span><br><span class="line">Timeout: No Notify</span><br><span class="line">27</span><br><span class="line">Timeout: No Notify</span><br><span class="line">28</span><br><span class="line">Timeout: No Notify</span><br><span class="line">29</span><br><span class="line">Timeout: No Notify</span><br><span class="line">30</span><br><span class="line">Timeout: No Notify</span><br><span class="line">31</span><br><span class="line">Timeout: No Notify</span><br><span class="line">32</span><br><span class="line">Timeout: No Notify</span><br><span class="line">33</span><br><span class="line">Timeout: No Notify</span><br><span class="line">34</span><br><span class="line">Timeout: No Notify</span><br><span class="line">35</span><br><span class="line">Timeout: No Notify</span><br><span class="line">36</span><br><span class="line">Timeout: No Notify</span><br><span class="line">37</span><br><span class="line">Timeout: No Notify</span><br><span class="line">38</span><br><span class="line">Timeout: No Notify</span><br><span class="line">39</span><br><span class="line">Timeout: No Notify</span><br><span class="line">40</span><br><span class="line">Timeout: No Notify</span><br><span class="line">41</span><br><span class="line">Timeout: No Notify</span><br><span class="line">42</span><br><span class="line">Timeout: No Notify</span><br><span class="line">43</span><br><span class="line">Timeout: No Notify</span><br><span class="line">44</span><br><span class="line">Timeout: No Notify</span><br><span class="line">45</span><br><span class="line">Timeout: No Notify</span><br><span class="line">46</span><br><span class="line">Timeout: No Notify</span><br><span class="line">47</span><br><span class="line">Timeout: No Notify</span><br><span class="line">48</span><br><span class="line">Timeout: No Notify</span><br><span class="line">49</span><br><span class="line">Timeout: No Notify</span><br><span class="line">50</span><br><span class="line">Timeout: No Notify</span><br><span class="line">51</span><br><span class="line">Timeout: No Notify</span><br><span class="line">52</span><br><span class="line">Timeout: No Notify</span><br><span class="line">53</span><br><span class="line">Timeout: No Notify</span><br><span class="line">54</span><br><span class="line">Timeout: No Notify</span><br><span class="line">55</span><br><span class="line">Timeout: No Notify</span><br><span class="line">56</span><br><span class="line">Timeout: No Notify</span><br><span class="line">57</span><br><span class="line">Timeout: No Notify</span><br><span class="line">58</span><br><span class="line">Timeout: No Notify</span><br><span class="line">59</span><br><span class="line">Timeout: No Notify</span><br><span class="line">60</span><br><span class="line">Timeout: No Notify</span><br><span class="line">61</span><br><span class="line">Timeout: No Notify</span><br><span class="line">62</span><br><span class="line">Timeout: No Notify</span><br><span class="line">63</span><br><span class="line">Timeout: No Notify</span><br><span class="line">64</span><br><span class="line">Timeout: No Notify</span><br><span class="line">65</span><br><span class="line">Timeout: No Notify</span><br><span class="line">66</span><br><span class="line">Timeout: No Notify</span><br><span class="line">67</span><br><span class="line">Timeout: No Notify</span><br><span class="line">68</span><br><span class="line">Timeout: No Notify</span><br><span class="line">69</span><br><span class="line">Timeout: No Notify</span><br><span class="line">70</span><br><span class="line">Timeout: No Notify</span><br><span class="line">71</span><br><span class="line">Timeout: No Notify</span><br><span class="line">72</span><br><span class="line">Timeout: No Notify</span><br><span class="line">73</span><br><span class="line">Timeout: No Notify</span><br><span class="line">74</span><br><span class="line">Timeout: No Notify</span><br><span class="line">75</span><br><span class="line">Timeout: No Notify</span><br><span class="line">76</span><br><span class="line">Timeout: No Notify</span><br><span class="line">77</span><br><span class="line">Timeout: No Notify</span><br><span class="line">78</span><br><span class="line">Timeout: No Notify</span><br><span class="line">79</span><br><span class="line">Timeout: No Notify</span><br><span class="line">80</span><br><span class="line">Timeout: No Notify</span><br><span class="line">81</span><br><span class="line">Timeout: No Notify</span><br><span class="line">82</span><br><span class="line">Timeout: No Notify</span><br><span class="line">83</span><br><span class="line">Timeout: No Notify</span><br><span class="line">84</span><br><span class="line">Timeout: No Notify</span><br><span class="line">85</span><br><span class="line">Timeout: No Notify</span><br><span class="line">86</span><br><span class="line">Timeout: No Notify</span><br><span class="line">87</span><br><span class="line">Timeout: No Notify</span><br><span class="line">88</span><br><span class="line">Timeout: No Notify</span><br><span class="line">89</span><br><span class="line">Timeout: No Notify</span><br><span class="line">90</span><br><span class="line">Timeout: No Notify</span><br><span class="line">91</span><br><span class="line">Timeout: No Notify</span><br><span class="line">92</span><br><span class="line">Timeout: No Notify</span><br><span class="line">93</span><br><span class="line">Timeout: No Notify</span><br><span class="line">94</span><br><span class="line">Timeout: No Notify</span><br><span class="line">95</span><br><span class="line">Timeout: No Notify</span><br><span class="line">96</span><br><span class="line">Timeout: No Notify</span><br><span class="line">97</span><br><span class="line">Timeout: No Notify</span><br><span class="line">98</span><br><span class="line">Timeout: No Notify</span><br><span class="line">99</span><br><span class="line">Timeout: No Notify</span><br><span class="line">100</span><br><span class="line">Timeout: No Notify</span><br><span class="line">101</span><br><span class="line">Timeout: No Notify</span><br><span class="line">102</span><br><span class="line">Timeout: No Notify</span><br><span class="line">103</span><br><span class="line">Timeout: No Notify</span><br><span class="line">104</span><br><span class="line">Timeout: No Notify</span><br><span class="line">105</span><br><span class="line">Timeout: No Notify</span><br><span class="line">106</span><br><span class="line">Timeout: No Notify</span><br><span class="line">107</span><br><span class="line">Timeout: No Notify</span><br><span class="line">108</span><br><span class="line">Timeout: No Notify</span><br><span class="line">109</span><br><span class="line">Timeout: No Notify</span><br><span class="line">110</span><br><span class="line">Timeout: No Notify</span><br><span class="line">111</span><br><span class="line">Timeout: No Notify</span><br><span class="line">112</span><br><span class="line">Timeout: No Notify</span><br><span class="line">113</span><br><span class="line">Timeout: No Notify</span><br><span class="line">114</span><br><span class="line">Timeout: No Notify</span><br><span class="line">115</span><br><span class="line">Timeout: No Notify</span><br><span class="line">116</span><br><span class="line">Timeout: No Notify</span><br><span class="line">117</span><br><span class="line">Timeout: No Notify</span><br><span class="line">118</span><br><span class="line">Timeout: No Notify</span><br><span class="line">119</span><br><span class="line">Timeout: No Notify</span><br><span class="line">120</span><br><span class="line">Timeout: No Notify</span><br><span class="line">121</span><br><span class="line">Timeout: No Notify</span><br><span class="line">122</span><br><span class="line">Timeout: No Notify</span><br><span class="line">123</span><br><span class="line">Timeout: No Notify</span><br><span class="line">124</span><br><span class="line">Timeout: No Notify</span><br><span class="line">125</span><br><span class="line">Timeout: No Notify</span><br><span class="line">126</span><br><span class="line">Timeout: No Notify</span><br><span class="line">127</span><br><span class="line">Timeout: No Notify</span><br><span class="line">128</span><br><span class="line">Timeout: No Notify</span><br><span class="line">129</span><br><span class="line">After Sleep 8s...</span><br><span class="line">Got the Notify to Out!</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h2 id="wait_until"   >
          <a href="#wait_until" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#wait_until"></a> wait_until</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_until</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>和<code>wait_for</code>行为一样，不同点在于：</p>
<ol>
<li><code>wait_for</code>的时间是时间段、间隔。</li>
<li><code>wait_until</code>的时间是时间点。</li>
</ol>

        <h1 id="future"   >
          <a href="#future" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#future"></a> future</h1>
      
<p>在标头 <code>&lt;future&gt;</code> 中定义</p>
<p>顾名思义，future就是为了用于获取返回值的。内部包装了一个任务或函数。</p>
<p>future是给期待方使用来get获取值的。<br />
promise是给承诺方使用来set设置值的。</p>
<p>以下程序表示：子线程期待一个值，此值由主线程提供。通过给子线程传入future实现。<br />
主线程定义一个promise，生成一个该promise的future传给t子线程函数。<br />
子线程调用<code>fut.get()</code>阻塞式等待主线程对fut相应的promise发送信息。<br />
一旦主线程向promise发送信息，子线程就会被通知，随后返回得到val。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">([](std::future&lt;<span class="type">int</span>&gt; fut) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::wcout &lt;&lt; <span class="string">L&quot;Start &amp; Wait...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> val = fut.get();</span></span></span><br><span class="line"><span class="params"><span class="function">            std::wcout &lt;&lt; <span class="string">L&quot;Got a value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, std::move(fut))</span></span>;</span><br><span class="line">        </span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">50</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Start &amp; Wait...</span><br><span class="line">Got a value: 50</span><br></pre></td></tr></table></div></figure>

        <h2 id="shared_future"   >
          <a href="#shared_future" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#shared_future"></a> shared_future</h2>
      
<p>用<code>shared_future</code>可以让多个线程同时监听一个共享的future。<br />
调用<code>fut.share()</code>即可获得<code>shared_future</code>类型的future，可以传入到线程函数中使用。</p>
<p>不要多次调用<code>fut.share()</code>，否则之前的<code>shared_future</code>会失效。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    <span class="keyword">auto</span> fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="keyword">auto</span> shared_fut = fut.<span class="built_in">share</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::jthread <span class="title">t1</span><span class="params">([](std::shared_future&lt;<span class="type">int</span>&gt; shared_fut) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::wcout &lt;&lt; <span class="string">L&quot;t1 Start &amp; Wait...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> val = shared_fut.get();</span></span></span><br><span class="line"><span class="params"><span class="function">            std::wcout &lt;&lt; <span class="string">L&quot;t1 Got a value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, shared_fut)</span></span>;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t2</span><span class="params">([](std::shared_future&lt;<span class="type">int</span>&gt; shared_fut) -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::wcout &lt;&lt; <span class="string">L&quot;t2 Start &amp; Wait...&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> val = shared_fut.get();</span></span></span><br><span class="line"><span class="params"><span class="function">            std::wcout &lt;&lt; <span class="string">L&quot;t2 Got a value: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, shared_fut)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">50</span>);</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t2 Start &amp; Wait...</span><br><span class="line">t1 Start &amp; Wait...</span><br><span class="line">t2 Got a value: 50</span><br><span class="line">t1 Got a value: 50</span><br></pre></td></tr></table></div></figure>

        <h2 id="packaged_task"   >
          <a href="#packaged_task" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#packaged_task"></a> packaged_task</h2>
      
<p>用于从子线程获得输出值。</p>
<p>与promise一样，packaged_task 是承诺方，是给出值的。可以调用get_future获得其对应的future。期待方可以通过此future获取其返回值。</p>
<p>创建子线程时，传入定义好的 packaged_task，需要<code>std::move</code>移动。</p>
<p>以下程序表示：主线程期待一个值，此值由子线程提供。通过给子线程传入 packaged_task 实现。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::packaged_task&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt; pkg&#123; [](<span class="type">int</span> v) -&gt; <span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = v; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">200</span>ms);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> fut = pkg.<span class="built_in">get_future</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">(std::move(pkg), <span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v = fut.<span class="built_in">get</span>();          <span class="comment">// block</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread got a value: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="async"   >
          <a href="#async" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#async"></a> async</h2>
      
<p>相当于包装好的<code>thread(packaged_task, ...)</code>。可以直接返回一个future。并且定义后相当于直接创建了子线程。</p>
<ol>
<li>参数1：Launch Policy
<ol>
<li>有两个选项：<code>std::launch::deferred</code>、<code>std::launch::async</code>。</li>
<li>默认是<code>std::launch::async</code>，意为立即执行。</li>
<li><code>std::launch::deferred</code>意为在他人<code>fut.get()</code>时才执行。</li>
</ol>
</li>
<li>参数2：fn</li>
<li>参数3：函数参数</li>
</ol>
<p>以下程序表示：主线程期待一个值，此值由子线程提供。通过async创建子线程实现。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fut = std::<span class="built_in">async</span>([](<span class="type">int</span> v) -&gt; <span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = v; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">200</span>ms);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;, <span class="number">50</span>);</span><br><span class="line">    <span class="type">int</span> v = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread got a value: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>以上是async的简单应用。</p>

        <h3 id="异步特性async"   >
          <a href="#异步特性async" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#异步特性async"></a> 异步特性（async）</h3>
      
<p>还有一些特性：所谓异步，就是主线程、async动作互不干扰。比如：<br />
async启动后，主线程打印内容至屏幕、Sleep等等，不会出现和子线程输出的错乱（除了换行以外）。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fut = std::<span class="built_in">async</span>([](<span class="type">int</span> v) -&gt; <span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = v; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">200</span>ms);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;, <span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread begin to Sleep...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread Wake up&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread got a value: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">main thread begin to Sleep...50</span><br><span class="line"></span><br><span class="line">49</span><br><span class="line">48</span><br><span class="line">47</span><br><span class="line">46</span><br><span class="line">45</span><br><span class="line">44</span><br><span class="line">43</span><br><span class="line">42</span><br><span class="line">41</span><br><span class="line">40</span><br><span class="line">39</span><br><span class="line">38</span><br><span class="line">37</span><br><span class="line">36</span><br><span class="line">35</span><br><span class="line">34</span><br><span class="line">33</span><br><span class="line">32</span><br><span class="line">31</span><br><span class="line">30</span><br><span class="line">29</span><br><span class="line">28</span><br><span class="line">27</span><br><span class="line">26</span><br><span class="line">main thread Wake up</span><br><span class="line">25</span><br><span class="line">24</span><br><span class="line">23</span><br><span class="line">22</span><br><span class="line">21</span><br><span class="line">20</span><br><span class="line">19</span><br><span class="line">18</span><br><span class="line">17</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">14</span><br><span class="line">13</span><br><span class="line">12</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">main thread got a value: 3</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h3 id="deferred特性"   >
          <a href="#deferred特性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#deferred特性"></a> deferred特性</h3>
      
<p>至于<code>std::launch::deferred</code>。经过测试：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::deferred,</span><br><span class="line">        [](<span class="type">int</span> v) -&gt; <span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = v; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">200</span>ms);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;, <span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread begin to Sleep...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">5</span>s);</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread Wake up&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;main thread got a value: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>发现，输出：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">main thread begin to Sleep...</span><br><span class="line">main thread Wake up</span><br><span class="line">50</span><br><span class="line">49</span><br><span class="line">48</span><br><span class="line">47</span><br><span class="line">46</span><br><span class="line">45</span><br><span class="line">44</span><br><span class="line">43</span><br><span class="line">42</span><br><span class="line">41</span><br><span class="line">40</span><br><span class="line">39</span><br><span class="line">38</span><br><span class="line">37</span><br><span class="line">36</span><br><span class="line">35</span><br><span class="line">34</span><br><span class="line">33</span><br><span class="line">32</span><br><span class="line">31</span><br><span class="line">30</span><br><span class="line">29</span><br><span class="line">28</span><br><span class="line">27</span><br><span class="line">26</span><br><span class="line">25</span><br><span class="line">24</span><br><span class="line">23</span><br><span class="line">22</span><br><span class="line">21</span><br><span class="line">20</span><br><span class="line">19</span><br><span class="line">18</span><br><span class="line">17</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">14</span><br><span class="line">13</span><br><span class="line">12</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">main thread got a value: 3</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>意味着，该启动策略表示等待主线程先执行一部分内容，直到主线程开始<code>fut.get()</code>时，async再启动。</p>

        <h1 id="信号量"   >
          <a href="#信号量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h1>
      

        <h2 id="信号量和条件变量的对比"   >
          <a href="#信号量和条件变量的对比" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#信号量和条件变量的对比"></a> 信号量和条件变量的对比</h2>
      
<p>条件变量的场景用于精确控制线程的同步，适合同步条件更复杂的场景（条件变量可以搭配一个计数器来达到信号量的效果）。</p>
<p>信号量的使用场景是可以简单地控制对资源的并发访问数量。</p>
<p>条件变量的使用较为灵活，需要手动精确控制加锁。<br />
而信号量的使用就很简单，简单地对计数器加减就是线程安全的。</p>

        <h2 id="api"   >
          <a href="#api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#api"></a> API</h2>
      
<p><code>C++20</code>开始。定义于<code>&lt;semaphore&gt;</code><br />
根据cppreference，信号量是一种轻量级同步原语，用于限制对共享资源的并发访问。信号量相比条件变量更高效，因为条件变量用到了mutex。<br />
分两种：</p>
<ol>
<li><code>counting_semaphore</code>，非负值。</li>
<li><code>binary_semaphore</code>，二值。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">ptrdiff_t</span> = <span class="comment">/* implementation-defined */</span>&gt;</span><br><span class="line"><span class="keyword">class</span> counting_semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> binary_semaphore = std::counting_semaphore&lt;<span class="number">1</span>&gt;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="示例改写windows信号量api"   >
          <a href="#示例改写windows信号量api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#示例改写windows信号量api"></a> 示例：改写Windows信号量API</h2>
      
<p>用<code>C++</code>线程库信号量改写——《Windows_多线程》中<a href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A4%9A%E4%B8%AA%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%90%8C%E6%97%B6%E5%8A%A8%E7%94%BB">示例：多个进度条同时动画</a><br />
比如：<code>std::counting_semaphore&lt;5&gt; semaphore(3);</code>代表最大值为5，初始值为3。如果最大值不填，则默认给一个超大的数。<br />
以下例子：<code>std::counting_semaphore&lt;2&gt; semaphore(2);</code>代表最大值为2，初始值为2。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;2&gt; <span class="title">semaphore</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::jthread <span class="title">t</span><span class="params">([]() -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock lck&#123; start_mx &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">            start_cv.wait(lck);</span></span></span><br><span class="line"><span class="params"><span class="function">            lck.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">            semaphore.acquire();</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">// ...</span></span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            semaphore.release();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="二值信号量当作条件变量使用"   >
          <a href="#二值信号量当作条件变量使用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二值信号量当作条件变量使用"></a> 二值信号量当作条件变量使用</h2>
      
<p>其实就是：<code>using binary_semaphore = std::counting_semaphore&lt;1&gt;;</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">std::binary_semaphore bin_sema&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="comment">/* ... */</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::jthread <span class="title">t</span><span class="params">([]() -&gt; <span class="type">void</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            bin_sema.acquire();</span></span></span><br><span class="line"><span class="params"><span class="function">            bin_sema.release(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            </span></span></span><br><span class="line"><span class="params"><span class="function">            semaphore.acquire();</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">// ...</span></span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            semaphore.release();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> WM_KETDOWN:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wParam == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bin_sema.<span class="built_in">release</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="闩锁latch-屏障barrier"   >
          <a href="#闩锁latch-屏障barrier" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#闩锁latch-屏障barrier"></a> 闩锁（Latch）、屏障（Barrier）</h1>
      
<p>闩锁和屏障是线程协调机制，允许任意数量的线程阻塞，直到预期数量的线程到达。闩锁不能重复使用，而屏障可以重复使用。</p>
<p>主要用于等待n个线程到位，之后做一些事情。<br />
屏障（Barrier）使用之后可以reset重新使用。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Cpp/Cpp_%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8_move%E7%9A%84%E5%AE%9E%E7%8E%B0/">Cpp_右值引用_move的实现</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-22</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Cpp/Cpp_%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8_move%E7%9A%84%E5%AE%9E%E7%8E%B0/" data-flag-title="Cpp_右值引用_move的实现"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>右值引用的例子</li>
<li>右值引用的实现</li>
</ol>

        <h1 id="右值引用的例子"   >
          <a href="#右值引用的例子" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#右值引用的例子"></a> 右值引用的例子</h1>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* p = <span class="literal">NULL</span>) : <span class="built_in">str</span>(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</span><br><span class="line">            str = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">            <span class="built_in">strcpy_s</span>(str, len, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString &amp; src) : <span class="built_in">str</span>(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(src.str != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(src.str) + <span class="number">1</span>;</span><br><span class="line">            str = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">            <span class="built_in">strcpy_s</span>(str, len, src.str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyString</span>(MyString &amp;&amp; src) : <span class="built_in">str</span>(src.str)</span><br><span class="line">    &#123;</span><br><span class="line">        src.str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MyString</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[]str;</span><br><span class="line">        &#125;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;xcgong&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s3</span><span class="params">(std::move(s1))</span></span>;	<span class="comment">//实质上是把s1“强转”为 右值引用 才能进行移动构造</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="move的实现"   >
          <a href="#move的实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#move的实现"></a> move的实现</h1>
      
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_remove_reference</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> type = _Ty;</span><br><span class="line">    <span class="keyword">using</span> _Const_thru_ref_type = <span class="type">const</span> _Ty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_remove_reference</span>&lt;_Ty&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> type = _Ty;</span><br><span class="line">    <span class="keyword">using</span> _Const_thru_ref_type = <span class="type">const</span> _Ty &amp;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_remove_reference</span>&lt;_Ty&amp;&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> type = _Ty;</span><br><span class="line">    <span class="keyword">using</span> _Const_thru_ref_type = <span class="type">const</span> _Ty &amp;&amp;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">my_remove_reference_t</span> = <span class="keyword">typename</span> my_remove_reference&lt;_Ty&gt;::type;</span><br><span class="line"><span class="comment">//my_remove_reference_t&lt;Object&gt; --&gt; my_remove_reference&lt;Object&gt;::type;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Ty&gt;</span></span><br><span class="line"><span class="function"><span class="type">my_remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">my_move</span><span class="params">(_Ty &amp;&amp; _Arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    								<span class="comment">//强转为_Ty纯粹类型的右值引用形式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">my_remove_reference_t</span>&lt;_Ty&gt; &amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;xcgong&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(xcg::my_move(s1))</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	my_move  -&gt;</span></span><br><span class="line"><span class="comment">	    return static_cast&lt;my_remove_reference_t&lt;_Ty&gt; &amp;&amp;&gt;(_Arg);</span></span><br><span class="line"><span class="comment">			my_remove_reference_t&lt;_Ty&gt;  -&gt;</span></span><br><span class="line"><span class="comment">				my_remove_reference&lt;_Ty&gt;::type  -&gt;</span></span><br><span class="line"><span class="comment">					my_remove_reference&lt;MyString&gt;::type  -&gt;</span></span><br><span class="line"><span class="comment">						type == _Ty -&gt; &quot;MyString&quot;</span></span><br><span class="line"><span class="comment">	--&gt; return static_cast&lt;MyString &amp;&amp;&gt;(_Arg);</span></span><br><span class="line"><span class="comment">	效果: _Arg 由 MyString 转为 MyString &amp;&amp;	</span></span><br><span class="line"><span class="comment">则--MyString s2(xcg::my_move(s1))--等效于:</span></span><br><span class="line"><span class="comment">	MyString s2( (MyString &amp;&amp;)s1);</span></span><br><span class="line"><span class="comment">		调用：MyString(MyString &amp;&amp; src), 即移动构造。进行资源拥有权的转移</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="引用类型与模板结合"   >
          <a href="#引用类型与模板结合" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#引用类型与模板结合"></a> 引用类型与模板结合</h1>
      
<p>可测试<code>is_lvalue_reference</code>，这是个模板类，定义于<code>&lt;type_traits&gt;</code>中。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;A&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;A&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;A&amp;&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;<span class="type">int</span>&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;<span class="type">int</span>&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::is_lvalue_reference&lt;<span class="type">int</span>&amp;&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>
<p>可测试<code>is_rvalue_reference</code>，这是个模板类，定义于<code>&lt;type_traits&gt;</code>中。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">static_assert</span></span><br><span class="line">(</span><br><span class="line">    std::is_rvalue_reference_v&lt;A&gt; == <span class="literal">false</span> <span class="keyword">and</span></span><br><span class="line">    std::is_rvalue_reference_v&lt;A&amp;&gt; == <span class="literal">false</span> <span class="keyword">and</span></span><br><span class="line">    std::is_rvalue_reference_v&lt;A&amp;&amp;&gt; != <span class="literal">false</span> <span class="keyword">and</span></span><br><span class="line">    std::is_rvalue_reference_v&lt;<span class="type">char</span>&gt; == <span class="literal">false</span> <span class="keyword">and</span></span><br><span class="line">    std::is_rvalue_reference_v&lt;<span class="type">char</span>&amp;&gt; == <span class="literal">false</span> <span class="keyword">and</span></span><br><span class="line">    std::is_rvalue_reference_v&lt;<span class="type">char</span>&amp;&amp;&gt; != <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(T&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same_v&lt;T&amp;&amp;, <span class="keyword">decltype</span>(x)&gt;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;T&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T&amp;&amp;\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;decltype(x)\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;<span class="keyword">decltype</span>(x)&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;A&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A&amp;\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;A&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A&amp;&amp;\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;A&amp;&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;<span class="type">char</span>&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char&amp;\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;<span class="type">char</span>&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char&amp;&amp;\t&quot;</span> &lt;&lt; std::is_rvalue_reference&lt;<span class="type">char</span>&amp;&amp;&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntest(42)\n&quot;</span>;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">42</span>);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\ntest(x)\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">test</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    A	false</span></span><br><span class="line"><span class="comment">    A&amp;	false</span></span><br><span class="line"><span class="comment">    A&amp;&amp;	true</span></span><br><span class="line"><span class="comment">    char	false</span></span><br><span class="line"><span class="comment">    char&amp;	false</span></span><br><span class="line"><span class="comment">    char&amp;&amp;	true</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">    test(42)</span></span><br><span class="line"><span class="comment">    T	false</span></span><br><span class="line"><span class="comment">    T&amp;&amp;	true</span></span><br><span class="line"><span class="comment">    decltype(x)	true</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">    test(x)</span></span><br><span class="line"><span class="comment">    T	false</span></span><br><span class="line"><span class="comment">    T&amp;&amp;	false</span></span><br><span class="line"><span class="comment">    decltype(x)	false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fac</span><span class="params">(T &amp;&amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/110/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/110/">110</a><span class="page-number current">111</span><a class="page-number" href="/page/112/">112</a><span class="space">&hellip;</span><a class="page-number" href="/page/153/">153</a><a class="extend next" rel="next" href="/page/112/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">305</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v8.0.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>