<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/107/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/107/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/">网络_网络编程流程</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-22</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/" data-flag-title="网络_网络编程流程"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="tcp编程流程"   >
          <a href="#tcp编程流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcp编程流程"></a> TCP编程流程</h1>
      
<p>面试唯一要写代码的。</p>
<ol>
<li>服务器端：
<ol>
<li><code>socket()</code> - 创建套接字 - 所需地址：ip+port</li>
<li><code>bind()</code> - 指定这个套接字是哪个IP:Port</li>
<li><code>listen()</code> - 设置监听队列的大小</li>
<li><code>c = accept()</code> - 接受连接</li>
<li><code>recv()</code> - 接收客户端发送的数据</li>
<li><code>send()</code> - 给客户端发送数据</li>
<li><code>close()</code> - 关闭连接</li>
</ol>
</li>
<li>客户端：
<ol>
<li><code>socket()</code> - 创建套接字</li>
<li><code>connect()</code> - 发起连接</li>
<li><code>send()</code> - 如果建立连接成功，则可以发送数据</li>
<li><code>recv()</code> - 收服务器回复的数据</li>
<li><code>close()</code></li>
</ol>
</li>
</ol>
<blockquote>
<p>客户端的bind：<br />
一般情况下客户端不需要bind，端口号是随机的。如果想要让客户端固定自己发出连接的端口号，可以主动bind。</p>
</blockquote>

        <h1 id="字节序大小端问题"   >
          <a href="#字节序大小端问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#字节序大小端问题"></a> 字节序（大小端问题）</h1>
      
<p>参考：《Linux高性能服务器编程（游双）》5.1.1 主机字节序和网络字节序 一节。</p>
<p>现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位机，下同），那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。</p>
<p>字节序分为大端字节序（big endian）和小端字节序（little endian）。<br />
大端字节序是指一个整数的高位字节（23～31bit）存储在内存的低地址处，低位字节（0～7bit）存储在内存的高地址处。<br />
小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</p>
<p><strong>现代PC（如 x86）大多采用小端字节序</strong>，因此小端字节序又被称为<strong>主机字节序</strong>。两台不同字节序的主机传递数据时，必然发生错误。</p>
<blockquote>
<p>也有系统采用大端字节序，如PowerPC、Java虚拟机。</p>
</blockquote>
<p>解决问题的方法是：发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。因此大端字节序也称为网络字节序。</p>
<p>需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由JAVA编写）通信，也要考虑字节序的问题（JAVA虚拟机采用大端字节序）。</p>
<p>以下代码可用于检查机器的字节序。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byteorder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> bytes[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125; test;</span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> (test.bytes[<span class="number">1</span>] == <span class="number">1</span>)       <span class="comment">// 通过数组[1] 看 高地址 存放的是 高位（1）吗？</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (test.bytes[<span class="number">1</span>] == <span class="number">2</span>)  <span class="comment">// 通过数组[1] 看 高地址 存放的是 低位（2）吗？</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown endianness\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="转换字节序api"   >
          <a href="#转换字节序api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#转换字节序api"></a> 转换字节序API</h2>
      
<p>定义于<code>&lt;netinet/in.h&gt;</code></p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：<br />
这4个函数中，长整型函数通常用来转换IP地址（4字节），短整型函数用来转换端口号（2字节）。<br />
当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort)</span>;</span><br></pre></td></tr></table></div></figure>
<p>它们的含义很明确，比如<code>htonl</code>表示“host to network long”，即将长整型（32bit）的主机字节序数据转化为网络字节序数据。</p>
<ol>
<li><code>h: host</code> / <code>n: network</code></li>
<li>to: transfer to
<ol>
<li>n + l: <code>long int</code> / <code>s: short int</code></li>
<li>h + l: <code>long int</code> / <code>s: short int</code></li>
</ol>
</li>
</ol>

        <h1 id="socket地址结构"   >
          <a href="#socket地址结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#socket地址结构"></a> socket地址结构</h1>
      
<p>常见的协议族：<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20250722065423512.png" alt="" /></p>
<blockquote>
<p>协议族：Protocol Family，简写PF。也称domain。<br />
地址族：Address Family，简写AF。用于标识​<strong>​网络地址和端口号​</strong>​。<br />
AF_INET：Address Family - Internet的简写。Internet采用的协议就是TCP/IP协议族。不带后缀的默认为TCP/IPv4。在 Linux/UNIX/Windows 系统中通用<br />
AF_UNIX：Address Family - UNIX的简写，有的也简写为AF_LOCAL。用于本地进程间通信<br />
AF_PACKET：用于底层的数据链路层访问</p>
</blockquote>

        <h2 id="通用socket地址结构"   >
          <a href="#通用socket地址结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通用socket地址结构"></a> 通用socket地址结构</h2>
      
<p>socket网络编程接口中表示<strong>socket地址</strong>的是结构体<code>sockaddr</code>，其定义如下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;	<span class="comment">//socket address family type</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">//socket address data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><code>sa_family</code>成员是地址族类型（<code>sa_family_t</code>）的变量。<strong>地址族</strong>类型通常与<strong>协议族</strong>类型对应。<br />
<code>sa_data</code>成员用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下图所示。<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20250722070305877.png" alt="" /><br />
可见，14字节根本无法完全容纳多数协议族的地址值。因此，Linux定义了新的通用socket地址结构体：</p>
<blockquote>
<p>这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的</p>
</blockquote>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="专用socket地址结构"   >
          <a href="#专用socket地址结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#专用socket地址结构"></a> 专用socket地址结构</h2>
      
<p>上面提到的两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提供了专门的socket地址结构体。<br />
比如UNIX本地域协议族使用的socket地址结构体<code>sockaddr_un</code>：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">// 搭配 AF_UNIX使用</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];    <span class="comment">// socket unix path 文件路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>TCP/IP的专用socket地址结构，见下文。</p>

        <h1 id="tcpip协议族地址结构"   >
          <a href="#tcpip协议族地址结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcpip协议族地址结构"></a> TCP/IP协议族地址结构</h1>
      
<p>TCP/IP协议族有<code>sockaddr_in</code>和<code>sockaddr_in6</code>两个专用socket地址结构体，分别用于IPv4和IPv6。<br />
定义于<code>&lt;netinet/in.h&gt;</code>中</p>

        <h2 id="ipv4sockaddr_in"   >
          <a href="#ipv4sockaddr_in" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ipv4sockaddr_in"></a> IPv4：sockaddr_in</h2>
      
<p><code>sockaddr_in</code>的in表示Internet（v4）。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPv4 socket地址族结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> 	sin_family;	<span class="comment">//地址族</span></span><br><span class="line">    __be16			sin_port;	<span class="comment">//端口号，__be16 表示 16位大端序，类型是 u_int16_t</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>	<span class="title">sin_addr</span>;</span>	<span class="comment">//IPv4 的 IP地址存放结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>注意命名的规律：<br />
Socket地址族结构体<code>sockaddr_xx</code>成员的前缀都带<code>sxx_</code>。</p>
<p><code>in_addr</code>这个结构体是单独定义的，和socket概念是独立的。用于存放 IPv4 的 IP地址。所以类型名不带”s“前缀。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">// 4个char都是8位2进制，用于存储4个0-255。</span></span><br><span class="line">            u_char s_b1, s_b2, s_b3, s_b4; </span><br><span class="line">        &#125;S_un_b;		<span class="comment">//An IPv4 address formatted as 4 u_chars, 4 * 8 bits</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            u_short s_w1, s_w2;</span><br><span class="line">        &#125;S_un_w;		<span class="comment">//An IPv4 address formatted as 2 u_shorts, 2 * 16bits</span></span><br><span class="line">        </span><br><span class="line">        u_long S_addr;	<span class="comment">//An IPv4 address formatted as 1 u_long, 1 * 32 bits</span></span><br><span class="line">    &#125;S_un;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> s_addr S_un.S_addr	<span class="comment">// u_long</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>其中<code>#define</code>给<code>S_un.S_addr</code>取了别名<code>s_addr</code>。而且用的还是联合体，等效于：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>因此外界访问IP地址只需要：<code>mysocketaddr.sin_addr.s_addr</code>。注意中间的<code>sin_addr</code>是socketIPv4地址族的成员名，要和<code>sin_addr</code>的类型名<code>in_addr</code>区分。</p>

        <h3 id="示例"   >
          <a href="#示例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *echo_host = <span class="string">&quot;192.168.1.20&quot;</span>;</span><br><span class="line">	<span class="type">int</span> ehco_port = <span class="number">7</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">server</span> =</span> (<span class="keyword">struct</span> sockaddr_in*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">	server-&gt;sin_family = AF_INET;</span><br><span class="line">	server-&gt;sin_port = htons(echo_port);</span><br><span class="line">	<span class="comment">//server is a struct of &#x27;sockaddr_in&#x27;</span></span><br><span class="line">	<span class="comment">//so :  sockaddr_in . sin_addr(is a &#x27;in_addr&#x27;)</span></span><br><span class="line">			in_addr . s_addr(is a <span class="meta">#<span class="keyword">define</span> of <span class="string">&#x27;S_un.S_addr&#x27;</span>, S_addr is a u_long)</span></span><br><span class="line">		so, sockaddr_in.in_addr.S_un.S_addr</span><br><span class="line">	<span class="comment">//final we find the u_long variable, 4 bytes, Corresponds to the 4 bytes of ipv4.</span></span><br><span class="line">	server-&gt;sin_addr.s_addr = inet_addr(echo_host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ipv6"   >
          <a href="#ipv6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ipv6"></a> IPv6</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>		sin6_family;	<span class="comment">//AF_INET6</span></span><br><span class="line">    <span class="type">u_inet16_t</span>		sin6_port;		<span class="comment">//port 网络字节序</span></span><br><span class="line">    <span class="type">u_int32_t</span>		sin6_flowinfo;	<span class="comment">//流信息, 应设置为0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>	<span class="title">sin6_addr</span>;</span>		<span class="comment">//IPv6地址结构体</span></span><br><span class="line">    <span class="type">u_int32_t</span>		sin6_scope_id;	<span class="comment">//scope ID,尚处于试验阶段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];	    <span class="comment">//IP地址，16字节 网络字节序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="ip地址字符串转换为整数"   >
          <a href="#ip地址字符串转换为整数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ip地址字符串转换为整数"></a> IP地址字符串转换为整数</h1>
      
<p>人们习惯用点分十进制字符串表示IPv4地址，编程中我们需要把这个字符串转化为整数，才能填入地址结构体。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp)</span>; <span class="comment">//字符串表示的IPv4地址转化为网络字节序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp, <span class="keyword">struct</span> in_addr* inp)</span>;<span class="comment">// 与inet_addr功能相同，但是转化结果是存到了inp中 成功返回1失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;	 <span class="comment">//net to ASCII, IPv4地址的网络字节序转化为字符串表示</span></span><br></pre></td></tr></table></div></figure>
<p>需要注意的是，<code>inet_ntoa</code>函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此<code>inet_ntoa</code>是不可重入的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* szValuel = inet_ntoa(<span class="string">&quot;1.2.3.4&quot;</span>);</span><br><span class="line"><span class="type">char</span>* szValue2 = inet_ntoa(<span class="string">&quot;10.194.71.60&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 1: $s\n&quot;</span>, szValue1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address 2: $s\n&quot;</span>, szValue2);</span><br></pre></td></tr></table></div></figure>
<p>运行这段代码，得到的结果是：<br />
address1: 10.194.71.60<br />
address2: 10.194.71.60<br />
因此多次调用该函数后，前面的结果都会失效。</p>

        <h2 id="推荐使用更新的函数pton-ntop"   >
          <a href="#推荐使用更新的函数pton-ntop" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#推荐使用更新的函数pton-ntop"></a> 推荐使用更新的函数（pton、ntop）</h2>
      
<p>定义于<code>&lt;arpa/inet.h&gt;</code>。这是随IPv6出现的新函数，但同样适用于IPv4。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> cnt)</span>;</span><br></pre></td></tr></table></div></figure>
<p><code>inet_pton</code>成功时返回1，失败则返回0并设置errno。</p>
<p><code>inet_ntop</code>中的cnt参数指定目标存储单元（字符数组）的大小。下面的宏能帮助我们指定这个大小：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></div></figure>
<p>16是：4个3位数+3个点+1个<code>\0</code></p>
<p><code>inet_ntop</code>成功时返回目标存储单元的地址，失败则返回<code>NULL</code>并设置errno。</p>

        <h1 id="建立socket连接api"   >
          <a href="#建立socket连接api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#建立socket连接api"></a> 建立Socket连接API</h1>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* serv_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br></pre></td></tr></table></div></figure>

        <h2 id="socket"   >
          <a href="#socket" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#socket"></a> socket()</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></div></figure>
<ol>
<li><code>socket()</code>方法是用来创建一个套接字，有了套接字就可以通过网络进行数据的收发。创建套接字时要<strong>指定使用的服务类型</strong>，比如使用TCP协议选择流式服务<code>SOCK_STREAM</code>。</li>
<li>参数含义：
<ol>
<li>第一个domain表示Socket Address Family，通常是<code>AF_INET</code>；</li>
<li>第二个参数表示基于的服务类型，通常有基于流式的服务(TCP)和基于数据报的服务(UDP)；</li>
<li>第三个参数指明你是基于什么协议。一般填0，表示默认。因为前两个参数的确定即可约束第三个参数是TCP还是UDP了。</li>
</ol>
</li>
<li>Returns <code>file descriptor</code> on success, <code>-1</code> on error.</li>
</ol>

        <h2 id="bind-命名socket-绑定地址"   >
          <a href="#bind-命名socket-绑定地址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#bind-命名socket-绑定地址"></a> bind() - 命名socket - 绑定地址</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></div></figure>
<ol>
<li><code>bind()</code>方法用来指定套接字使用的IP地址和端口
<ol>
<li>IP地址就是等待被连接的服务器地址。</li>
<li>端口是一个16位的整型值。
<ol>
<li><code>0-1023</code>为知名端口，在linux上，1024以内的端口号只有root用户可以使用。</li>
<li><code>1024-4095</code>为预留端口，用户不可随意使用；</li>
<li><code>4096以上</code>为临时端口，用户按需使用。</li>
</ol>
</li>
</ol>
</li>
<li>sockaddr可以看作是<code>sockaddr_in</code>的抽象类型。</li>
<li>return<code>0</code> on success, or <code>-1</code> on error.</li>
</ol>

        <h2 id="listen"   >
          <a href="#listen" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#listen"></a> listen()</h2>
      
<p>创建2个监听队列，一个存放未完成连接的客户，一个存放已完成连接的客户。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></div></figure>
<ol>
<li>将文件描述符<code>sockfd</code>引用的流socket标记为被动。这个socket后面会被用来接受其他socket的主动连接。</li>
<li>用来创建监听队列。监听队列有<strong>两种</strong>，<strong>一个是存放未完成三次握手的连接</strong>，<strong>一种是存放已完成三次握手的连接</strong>。</li>
<li>第二个参数<code>backlog</code>指定系统监听连接的最大容量数目。如果连接数量超过了队列长度，服务器将不再受理新的连接，客户端会收到<code>ECONNREFUSED</code>错误消息。
<ol>
<li>在内核版本2.2之前，backlog表示所有半连接（SYN_RCVD）、完全连接（ESTABLISHED）的数量上限。</li>
<li>但自2.2之后，它只表示处于完全连接状态的数量上限。处于半连接状态的数量上限则由<code>/proc/svs/net/ipv4/tcp_max_syn_backlog</code>定义。</li>
<li>backlog参数的典型值是5。</li>
<li>系统实际上可以监听的连接数目是超过backlog的。</li>
</ol>
</li>
<li>return <code>0</code> on success, or <code>-1</code> on error.</li>
<li>无法在一个已连接的socket（已经成功执行<code>connect()</code>的或由<code>accept()</code>调用返回的socket）再执行<code>listen()</code>。</li>
</ol>
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20250722090234499.png" alt="" /><br />
图片源于UNIX网络编程_卷1</p>

        <h3 id="具体流程"   >
          <a href="#具体流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#具体流程"></a> 具体流程</h3>
      
<ol>
<li>当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项</li>
<li>然后响应以三路握手的第二个分节：服务器的SYN+ACK响应。</li>
<li>这一项一直保留在未完成连接队列中，直到三路握手的第三个分节（客户对服务器SYN的ACK）到达或者该项超时为止。</li>
<li>如果三路握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。</li>
<li>当进程调用accept时，已完成连接队列中的队头项将返回给进程，
<ol>
<li>或者如果该队列为空，那么进程将被置于休眠状态，直到TCP在该队列中放入一项才唤醒它。</li>
</ol>
</li>
</ol>

        <h2 id="accept"   >
          <a href="#accept" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#accept"></a> accept()</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></div></figure>
<ol>
<li><code>accept()</code>：从已完成连接队列的队头取出一个连接项。每处理一个连接，则<code>accept()</code>返回该连接对应的套接字描述符。如果该队列为空，则accept阻塞。</li>
<li>它会创建一个新socket，并且正是这个新socket会与执行<code>connect()</code>的对等socket进行连接。</li>
<li>由于accept是通用的API，它不知道对方是什么协议族，因此addr是抽象类型，addrlen也是不确定的，需要传指针。</li>
<li><code>accept()</code>调用返回的函数结果是创建的socket对应的文件描述符。</li>
<li>return <code>file descriptor</code> on success, or <code>-1</code> on error.</li>
</ol>

        <h3 id="accept只管取出连接不管连接状态"   >
          <a href="#accept只管取出连接不管连接状态" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#accept只管取出连接不管连接状态"></a> accept只管取出连接，不管连接状态</h3>
      
<p>现在考虑如下情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么服务器对这个连接执行的accept调用是否成<br />
功？<br />
客户端连接成功后，立即断开该客户端的网络连接（类似于拔掉网线）（服务器还没反应过来客户端断网了）。结果发现accept调用能够正常返回。<br />
在服务器上运行netstat命令以查看accept返回的连接socket的状态：发现依然是ESTABLISHED。说明，accept调用对于客户端网络断开毫不知情。</p>
<p>如果客户端建立连接后立即退出客户端程序（客户端发出FIN）。这次accept调用同样正常返回。<br />
服务端netstat命令发现连接状态为<code>CLOSE_WAIT</code>。再次说明：accept只是从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化。</p>

        <h2 id="connect"   >
          <a href="#connect" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#connect"></a> connect()</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* serv_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></div></figure>
<ol>
<li>connect方法将文件描述符<code>sockfd</code>引用的主动socket连接到通过addr和addrlen指定地址的监听socket上。</li>
<li>一般由客户端程序执行，需要指定连接的服务器端的IP地址和端口。该方法执行后，会进行三次握手，建立连接。</li>
<li>return <code>0</code> on success, or <code>-1</code> on error.</li>
</ol>

        <h1 id="数据收发api"   >
          <a href="#数据收发api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据收发api"></a> 数据收发API</h1>
      

        <h2 id="tcp"   >
          <a href="#tcp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buff, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buff, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></div></figure>
<p>recv返回接收的字节数，如果发生错误则返回 <code>-1</code>。如果发生错误，则会设置 <code>errno</code> 来指示错误。<br />
当<strong>流套接字</strong>（如TCP）对等体执行了有序关闭时，返回值为 0（传统的“文件结束”返回）。<br />
如果请求从<strong>流套接字</strong>接收的字节数为 0，也可能返回 0。</p>
<p>send如果成功，将返回已发送的字节数。如果失败，则返回 <code>-1</code>，并设置相应的 <code>errno</code>。</p>

        <h2 id="udp"   >
          <a href="#udp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#udp"></a> UDP</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buff, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buff, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></div></figure>
<p>recvfrom返回接收的字节数，如果发生错误则返回 <code>-1</code>。如果发生错误，则会设置 <code>errno</code> 来指示错误。</p>
<p>不同域（例如 UNIX 和 Internet 域）中的<strong>数据报</strong>套接字（如UDP）允许接收 0 长度数据报。当接收到此类数据报时，返回值为 0。</p>
<p>sendto如果成功，将返回已发送的字节数。如果失败，则返回 <code>-1</code>，并设置相应的 <code>errno</code>。</p>

        <h1 id="linux代码-tcp"   >
          <a href="#linux代码-tcp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#linux代码-tcp"></a> Linux代码 - TCP</h1>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*  int socket(int domain, int type, int protocol);  */</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    </span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = htons(<span class="number">6000</span>);</span><br><span class="line">    ser_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);	<span class="comment">//inet_addr(): make string to integer</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);  */</span></span><br><span class="line">    <span class="type">int</span> res = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    assert(res != <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  int listen(int sockfd, int backlog);  */</span></span><br><span class="line">    res = listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    assert(res != <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">/*  int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);  */</span></span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line">        <span class="type">int</span> conn_fd = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;cli_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (conn_fd == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> num = recv(conn_fd, buff, <span class="number">127</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buff = %s, num = %d\n&quot;</span>, buff, num);</span><br><span class="line">        </span><br><span class="line">        send(conn_fd, <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        close(conn_fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="粘包问题"   >
          <a href="#粘包问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#粘包问题"></a> 粘包问题</h1>
      
<p>TCP是流式服务，数据是以流的形式传输的，在网络层这一层面，不应该考虑粘包的问题。</p>
<p>而是应该在TCP传输的数据本身上做文章。</p>
<p>可以这样处理：发送端每send一次，接收端就recv一次，并且要回发一个ok，发送端recv，等待ok到了之后才send下一个数据。但是这样做效率太低了。</p>
<p>可以加标志位以区分数据的完整性。这是简单的做法。比如：7、3、2，处理之后：<code>[7][3][2]</code></p>
<p>更好的做法是：在每个独立的数据前加一个头部，头部中记录数据的长度。如此便可与下一个数据做区分。</p>

        <h2 id="会引起粘包的客户端代码"   >
          <a href="#会引起粘包的客户端代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#会引起粘包的客户端代码"></a> 会引起粘包的客户端代码</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> client_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 数据交互</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * msg1 = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * msg2 = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    error = send(client_sock, msg1, <span class="built_in">strlen</span>(msg1), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    error = send(client_sock, msg2, <span class="built_in">strlen</span>(msg2), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="客户端改进"   >
          <a href="#客户端改进" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端改进"></a> 客户端改进</h2>
      
<p>为每个消息包一个包裹，前面4个字节存放消息的大小。<br />
使用memmove实现字节移动。（实际就是把消息填入到4字节后的位置）</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> client_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;(server_addr.sin_addr.s_addr));</span><br><span class="line"></span><br><span class="line">    connect(client_sock, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据交互</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * msg1 = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * msg2 = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="type">char</span> data1[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在data1的低地址（占用4个字节）填充msg的长度</span></span><br><span class="line">    *(<span class="type">int</span>*)(data1) = <span class="built_in">strlen</span>(msg1);</span><br><span class="line">    <span class="type">int</span> headLen = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从data1的headLen后面开始，填充msg1的字符串内容</span></span><br><span class="line">    memmove(data1 + headLen, msg1, <span class="built_in">strlen</span>(msg1));</span><br><span class="line"></span><br><span class="line">    error = send(client_sock, data1, headLen + <span class="built_in">strlen</span>(msg1), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> data2[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    *(<span class="type">int</span>*)(data2) = <span class="built_in">strlen</span>(msg2);</span><br><span class="line">    memmove(data2 + headLen, msg2, <span class="built_in">strlen</span>(msg2));</span><br><span class="line">    error = send(client_sock, data2, headLen + <span class="built_in">strlen</span>(msg2), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(client_sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="服务端"   >
          <a href="#服务端" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2>
      
<p>主要逻辑在循环上。<br />
要记录每次读到的长度（readLen），目前未处理的（因为数据不完整）的长度（gotLen）。<br />
当gotLen大于等于4字节时，前4个字节是字符串长度（msgLen）。<br />
再去看gotLen减去headLen（int的4字节），是否大于等于msgLen。如果是，则说明数据完整了，可以取出了。<br />
去除之后，别忘记更新gotLen的值，减去这次已经处理了的headLen和msgLen。<br />
容易遗忘的是，需要把buff中，把本次处理了的headLen、msgLen之后的数据前移覆盖。仍用memmove。<br />
第一层循环，是读到buff，有字节就读。除非返回<code>-1</code>。<br />
第二层循环，是看是否够4个字节，不够就退出第二层循环。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> server_sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;(server_addr.sin_addr.s_addr));</span><br><span class="line">    bind(server_sock, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    listen(server_sock, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> client_sock = accept(server_sock, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">    <span class="comment">// 数据交互</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> headLen = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> gotLen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((readLen = recv(client_sock, buff + gotLen, <span class="keyword">sizeof</span>(buff) - gotLen, <span class="number">0</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gotLen += readLen;</span><br><span class="line">        <span class="keyword">while</span> (gotLen &gt;= headLen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> msgLen = *(<span class="type">int</span>*)buff;</span><br><span class="line">            <span class="keyword">if</span> (gotLen - headLen &gt;= msgLen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> msgBuff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                memmove(msgBuff, buff + headLen, msgLen);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;msgBuff = %s\n&quot;</span>, msgBuff);</span><br><span class="line">                <span class="type">int</span> dataLen = headLen + msgLen;</span><br><span class="line">                memmove(buff, buff + dataLen, gotLen - dataLen);</span><br><span class="line">                gotLen -= dataLen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试"   >
          <a href="#测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mrcan@ubuntu:~/networkProgram$ ./tcpserver </span><br><span class="line">msgBuff = hi</span><br><span class="line">msgBuff = jack</span><br></pre></td></tr></table></div></figure>

        <h1 id="linux代码-udp"   >
          <a href="#linux代码-udp" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#linux代码-udp"></a> Linux代码 - UDP</h1>
      

        <h2 id="服务端-2"   >
          <a href="#服务端-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-2"></a> 服务端</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> server_socket = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    error = inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;(server_addr.sin_addr.s_addr));</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = bind(server_socket, (sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="type">int</span> n = recvfrom(server_socket, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>, (sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recvfrom error!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buff = %s\n&quot;</span>, buff);</span><br><span class="line">        n = sendto(server_socket, <span class="string">&quot;ok&quot;</span>, <span class="number">2</span>, <span class="number">0</span>, (sockaddr*)&amp;client_addr, client_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sendto error!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="客户端"   >
          <a href="#客户端" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> client_socket = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8000</span>);</span><br><span class="line">    error = inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;(server_addr.sin_addr.s_addr));</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> server_addr_len = <span class="keyword">sizeof</span>(server_addr);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        fgets(buff, <span class="keyword">sizeof</span>(buff), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">&quot;end&quot;</span>, buff, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = sendto(client_socket, buff, <span class="built_in">strlen</span>(buff) - <span class="number">1</span>, <span class="number">0</span>, (sockaddr*)&amp;server_addr, server_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sendto error!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        n = recvfrom(client_socket, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>, (sockaddr*)&amp;server_addr, &amp;server_addr_len);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recvfrom error!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buff = %s\n&quot;</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="windows代码"   >
          <a href="#windows代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#windows代码"></a> Windows代码</h1>
      

        <h2 id="要引入的库及链接器配置"   >
          <a href="#要引入的库及链接器配置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#要引入的库及链接器配置"></a> 要引入的库及链接器配置</h2>
      
<p>Windows下的socket编程需要引入<code>WinSock2.h</code>库，还需要预处理链接<code>#pragma comment(lib, &quot;Ws2_32.lib&quot;)</code>。<br />
<code>#pragma comment(lib, &quot;Ws2_32.lib&quot;)</code> 是用于指定链接器选项的预处理指令，在Windows平台的<code>C/C++</code>编程中比较常见。</p>
<ul>
<li><strong>作用</strong>: 这条指令告诉编译器在链接阶段要链接 <code>Ws2_32.lib</code> 库，这是一个包含 Windows Sockets 2 (Winsock) 函数的库。Winsock 提供了网络编程的 API，允许程序进行网络通信，比如创建套接字、发送和接收数据等。
<ul>
<li>通过 <code>#pragma comment(lib, &quot;Ws2_32.lib&quot;)</code>，可以在代码中直接指定要链接的库，这样就不需要在编译或项目设置中手动配置链接器选项。
<ul>
<li>手动配置：右键项目名，Properties，左边栏：Linker - Input，右边的Additional Dependencies，点击右边的下拉键，再点其中的<code>&lt;Edit...&gt;</code>，之后弹出窗口，可以把要输入的库写在输入框中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240827021846342.png" alt="" /></p>
<ul>
<li>如果你在代码中使用了网络函数而没有链接到 <code>Ws2_32.lib</code>，编译器会报错，提示找不到相关的函数定义。</li>
</ul>

        <h2 id="wsastartup"   >
          <a href="#wsastartup" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#wsastartup"></a> WSAStartup</h2>
      
<p>在Microsoft Learn搜索WinSock2，可以找到<code>winsock2.h header</code>的条目。<br />
<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/" >Winsock2.h header</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>编写Windows Socket程序之前，需要WSAStartup初始化。<br />
<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsastartup" >WSAStartup function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>WSAStartup 函数启动进程对 Winsock DLL 的使用。（即初始化Winsock的动态链接库）<br />
别忘了在程序结束前要WSACleanup，表示卸载 Winsock DLL。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;Ws2_32&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WORD wVersionRequested;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */</span></span><br><span class="line">    wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    err = ::<span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line">        <span class="comment">/* Winsock DLL.                                  */</span></span><br><span class="line">        std::wcout &lt;&lt; std::format(<span class="string">L&quot;WSAStartup failed with error : &#123;&#125;\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此处使用到了<a href="../Cpp/Cpp_%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88format%EF%BC%89.md">Cpp_拼接字符串的几种方法（format）</a>中的format库的字符串输出方法。</p>

        <h2 id="创建套接字"   >
          <a href="#创建套接字" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#创建套接字"></a> 创建套接字</h2>
      
<p>用到的是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket" >socket function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240827065503809.png" alt="" /></p>
<ol>
<li>第一个参数是Address Family，因此简称AF，意为地址族规范。
<ol>
<li>当前支持的值为<code>AF_INET</code>或<code>AF_INET6</code>，它们是IPv4和ipv6的Internet地址族格式。</li>
<li>如果安装了地址族的Windows套接字服务提供程序，则支持地址族的其他选项 (例如，与NetBIOS一起使用的<code>AF_NETBIOS</code>)。另外还有苹果的<code>AF_APPLETALK</code>，蓝牙的<code>AF_BTH</code>。</li>
<li>请注意，<code>AF_</code> address系列和<code>PF_</code> protocol系列常量的值是相同的 (例如，AF_INET和PF_INET)，因此可以使用任一常量。</li>
</ol>
</li>
<li>第二个参数是套接字的类型规范。
<ol>
<li>有<code>SOCK_STREAN</code>（TCP）、<code>SOCK_DGRAM</code>（UDP）、<code>SOCK_RAW</code>（原始套接字）、<code>SOCK_RDM</code>（可靠多播）、<code>SOCK_SEQPACKET</code>（伪流数据报套接字）</li>
</ol>
</li>
<li>第三个参数是协议(protocol)。协议参数的可能选项特定于指定的地址族和套接字类型。
<ol>
<li>如果指定值0，则调用者不希望指定协议，并且服务提供者将选择要使用的协议。</li>
<li>当af参数是AF_INET或AF_INET6并且类型是SOCK_RAW时，在IPv6或IPv4分组报头的 protocol 字段中设置为协议指定的值。</li>
<li>该协议字段的常见值：<code>IPPROTO_ICMP</code>、<code>IPPROTO_IGMP</code>、<code>BTHPROTO_RFCOMM</code>、<code>IPPROTO_TCP</code>、<code>IPPROTO_UDP</code>、<code>IPPROTO_ICMPV6</code>、<code>IPPROTO_RM</code></li>
</ol>
</li>
<li>返回值：如果没有发生错误，则socket返回socket的描述符。否则，将返回<code>INVALID_SOCKET</code>，并且可以通过调用<code>WSAGetLastError</code>来检索特定的错误代码。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INVALID_SOCKET  (SOCKET)(~0)  <span class="comment">// 0取反，则是全1</span></span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    SOCKET listen_sock = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (listen_sock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="sockaddr结构"   >
          <a href="#sockaddr结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sockaddr结构"></a> sockaddr结构</h2>
      
<p>重点说一下sockaddr，这是个结构体，包含了：</p>
<ol>
<li><code>sin_family</code></li>
<li><code>sin_addr</code>，是sockaddr中的一个联合体，存放IP地址的整型。可以用<code>inet_addr(&quot;127.0.0.1&quot;)</code>将字符串转化为整型来填入<code>sin_addr.sin_addr</code>。</li>
<li><code>sin_port</code>，需要用<code>htons</code>，主机地址到网络的转换。s表示short，2字节。</li>
</ol>

        <h2 id="bind"   >
          <a href="#bind" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#bind"></a> bind</h2>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-bind" >bind function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240827073919812.png" alt="" /></p>
<ol>
<li>参数1：socket描述符，没有绑定过的。</li>
<li>参数2：本地地址的sockaddr结构的指针</li>
<li>参数3：name参数所指向的值的长度 (以字节为单位)。</li>
<li>返回：如果没有发生错误，返回零。否则，它返回<code>SOCKET_ERROR</code>，并且可以通过调用<code>WSAGetLastError</code>来检索特定的错误代码。</li>
</ol>
<p>关于sockaddr结构：<a href="#sockaddr%E7%BB%93%E6%9E%84">sockaddr结构</a></p>
<p>编写时，发现第二个参数<code>name</code>不能直接填入<code>&amp;server_addr</code>，而是要显式转换为<code>const sockaddr*</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    sockaddr_in server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9008</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">bind</span>(listen_sock,</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;server_addr),</span><br><span class="line">            <span class="built_in">sizeof</span>(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="问题"   >
          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
      
<p>报错：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error C4996: &#x27;inet_addr&#x27;: Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings</span><br></pre></td></tr></table></div></figure>
<p>VS编译器不建议使用<code>inet_addr</code>来转换<code>点分十进制IP地址字符串</code>为<code>网络字节序</code>。而是使用<code>&lt;ws2tcpip.h&gt;</code>库中的<code>inet_pton</code>，即字符串转为整数（p代表字符指针，n代表整数）。<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240828064535457.png" alt="" /></p>
<ol>
<li>参数1，地址族协议</li>
<li>参数2，要转化的字符串</li>
<li>参数3，要写入到哪里的地址</li>
<li>返回值
<ol>
<li>如果没有发生错误，<code>InetPton</code>函数将返回值1，并且<code>pAddrBuf</code>参数指向的缓冲区包含按网络字节顺序排列的二进制数字IP地址。</li>
<li>如果参数指向的字符串不是有效的IPv4点分十进制字符串或有效的IPv6地址字符串，则InetPton函数将返回值0。</li>
<li>如果指向的字符串没问题，有其他错误：返回值为-1，可以通过调用<code>WSAGetLastError</code>获取扩展错误信息。</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    sockaddr_in server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//server_addr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != ::<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9008</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">bind</span>(listen_sock,</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;server_addr),</span><br><span class="line">            <span class="built_in">sizeof</span>(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="listen-2"   >
          <a href="#listen-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#listen-2"></a> listen</h2>
      
<p>将套接字置于侦听传入连接的状态，本质上是设置了一个监听连接套接字的队列。<br />
<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen" >listen function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240828023630523.png" alt="" /></p>
<ol>
<li>参数1，已经绑定了的，但未连接的socket描述符。</li>
<li>参数2，等待连接队列的最大长度。一般设置为<code>SOMAXCONN</code>。</li>
<li>返回值，如果没有错误发生，返回0。否则，将返回<code>SOCKET_ERROR</code>，并且可以通过调用<code>WSAGetLastError</code>来检索特定的错误代码。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">listen</span>(listen_sock, SOMAXCONN))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="accept-2"   >
          <a href="#accept-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#accept-2"></a> accept</h2>
      
<p>从listen的监听队列中选出一个未被连接的，拿出来，产生一个worker socket（连接套接字）。如果监听队列中没有客户端连接，则阻塞，直到有人连接后返回。<br />
在这个阶段，accept函数会把连接到服务端<code>listen_sock</code>上的client的信息填入到参数<code>sockaddr* client_addr</code>中。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept" >accept function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240828072239856.png" alt="" /></p>
<ol>
<li>参数1，已listen的套接字。但最终连接实际上是与accept返回的套接字进行的。</li>
<li>参数2，该缓冲区要填入客户端的地址。addr参数的确切格式由从sockaddr结构创建套接字时建立的地址族确定。</li>
<li>参数3，指向整数的指针，该整数包含addr参数所指向的结构的长度。最好让他指向一个初始化值为<code>sizeof(sockaddr_in)</code>的int值。
<ol>
<li>标志为<code>[in, out]</code>，意为是一个需要正确输入、可能会输出的项：见返回值中对addrlen的描述。</li>
<li>addrlen引用的整数最初需要包含addr指向的空间量（即<code>int addrlen&#123; sizeof(client_addr) &#125;</code>）。函数返回时，它将填入返回的地址的实际长度 (以字节为单位)。</li>
</ol>
</li>
<li>返回值，如果没有发生错误，accept将返回一个SOCKET类型的值，该值是连接套接字的描述符。这个返回值是实际连接的套接字的句柄。
<ol>
<li>否则，将返回<code>INVALID_SOCKET</code>的值，并且可以通过调用<code>WSAGetLastError</code>来检索特定的错误代码。</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sockaddr_in client_addr;</span><br><span class="line">    <span class="type">int</span> addrlen&#123; <span class="built_in">sizeof</span>(client_addr) &#125;;</span><br><span class="line">    SOCKET work_sock = ::<span class="built_in">accept</span>(</span><br><span class="line">        listen_sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;client_addr),</span><br><span class="line">        &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (work_sock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="调试-accept-通过-error-lookup-查询原因"   >
          <a href="#调试-accept-通过-error-lookup-查询原因" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调试-accept-通过-error-lookup-查询原因"></a> 调试 accept - 通过 Error Lookup 查询原因</h2>
      
<p>程序已经通过<code>WSAGetLastError</code>把错误码填入到了err中。如果某个步骤出现了问题，可以看到err中的具体值。<br />
这个值是个整数，可以在VS菜单栏-Tools-External Tools中添加<code>errorlook.exe</code>程序的快捷方式：<br />
Title是自定义的，我们填入Error LookUp。<br />
Command填入<code>C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\Tools\errlook.exe</code><br />
Initial directory填入<code>C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\Tools</code><br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240829061511915.png" alt="" /><br />
添加完毕后，Tools出来的菜单中就会显示了：<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240829061633740.png" alt="" /></p>
<p>如上面的程序，<code>addrlen</code>如果初始化为0时，传给accept函数后，就会导致accept错误。（因为accept文档中给出参数说明：addrlen引用的整数最初需要包含addr指向的空间量。此时我们传入0是没有意义的，accept中的操作可能会读取addrlen的内容，导致错误）</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sockaddr_in client_addr;</span><br><span class="line">    <span class="type">int</span> addrlen&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SOCKET work_sock = ::<span class="built_in">accept</span>(</span><br><span class="line">        listen_sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;client_addr),</span><br><span class="line">        &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (work_sock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>最终err码是10014，那么在ErrorLook中查询：<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240829061728388.png" alt="" /></p>

        <h2 id="客户端-2"   >
          <a href="#客户端-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端-2"></a> 客户端</h2>
      
<p>新建一个空项目，SocketClientStudy，新建文件<code>basic_stream_client.cpp</code>。不用设置为启动项目。</p>
<p>客户端程序需要WSA初始化、创建套接字。<br />
后面直接连接connect，connect的参数和服务器端bind的参数一样：创建<code>sockaddr_in</code>并且填入相关信息（协议、IP地址、端口号）。<br />
<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect" >connect function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240829063508988.png" alt="" /><br />
返回值：如果没有发生错误，返回0。否则返回<code>SOCKET_ERROR</code>，并且可以通过调用<code>WSAGetLastError</code>来检索特定的错误代码。</p>
<ol>
<li>阻塞套接字，返回值指示连接尝试的成功或失败。</li>
<li>非阻塞套接字，连接尝试无法立即完成。在这种情况下，connect将返回<code>SOCKET_ERROR</code>，<code>WSAGetLastError</code>将返回<code>WSAEWOULDBLOCK</code>。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;Ws2_32&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WORD wVersionRequested;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */</span></span><br><span class="line">    wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    err = ::<span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line">        <span class="comment">/* Winsock DLL.                                  */</span></span><br><span class="line">        std::wcout &lt;&lt; std::format(<span class="string">L&quot;WSAStartup failed with error : &#123;&#125;\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SOCKET sock = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sockaddr_in server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//service.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != ::<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9008</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">connect</span>(sock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;server_addr), <span class="built_in">sizeof</span>(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="联调1"   >
          <a href="#联调1" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#联调1"></a> 联调1</h2>
      
<p>单独Build客户端项目：右击客户端项目名-Project Only-Build Only …<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240829070708525.png" alt="" /><br />
若Build成功，则可以启动Server项目了。Server项目直接点击VS全局下的调试即可（快捷键F5）。<br />
启动Server之后，若成功地阻塞在accept，则可以单独启动客户端项目了：右击客户端项目-Debug-Start New Instance<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240829070915611.png" alt="" /><br />
之后，可以很轻松地在此两个项目中流转、单步调试。</p>

        <h2 id="服务端-显示连接的客户端信息"   >
          <a href="#服务端-显示连接的客户端信息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-显示连接的客户端信息"></a> 服务端-显示连接的客户端信息</h2>
      
<p>想要显示连接的客户端的IP地址和端口号。<br />
<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetntopw" >InetNtopW function (ws2tcpip.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>对于IP地址，在编写服务端的bind、客户端的connect时，声明<code>sockaddr_in</code>时，都需要使用<code>inet_pton</code>来填入<code>sin_addr</code>。这是让IP地址字符串转换为整数值填入联合体。<br />
而我们想要从<code>sockaddr_in</code>获得字符串形式的IP地址时，需要用<code>inet_ntop</code>，注意，不能直接读取<code>sockaddr_in</code>，而是<code>sockaddr_in.sin_addr</code>。详见<a href="#sockaddr%E7%BB%93%E6%9E%84">sockaddr结构</a><br />
对于端口号，对于网络程序来说，需要使用<code>htons</code>使主机字节序转为网络字节序（类似于IP地址从字符串转换为计算机程序可理解的整型值），填入<code>sin_port</code>。而对于人类的可读性来讲，需要从网络字节序转为主机字节序（类似于IP地址从整数值转换为人类可理解的字符串），需要：<code>ntohs</code>。</p>
<blockquote>
<p><code>inet_pton</code>和<code>inet_ntop</code>都是ANSI版本的。<br />
<code>InetNtopW</code>是Unicode版本的。参数除了<code>pStringBuf</code>的类型为PWSTR不一样，其他一样。见<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetntopw" >InetNtopW function (ws2tcpip.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><code>htons</code>：h代表host，to意为转换，n为net，s为short（2字节）。还有<code>htonl</code>，为long int（4字节）。</p>
</blockquote>
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240829221004234.png" alt="" /></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">wchar_t</span> addr_str[<span class="number">46</span>] = <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">InetNtopW</span>(AF_INET, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;client_addr.sin_addr), addr_str, <span class="number">46</span>);</span><br><span class="line">    std::wcout &lt;&lt; std::format(<span class="string">L&quot;client address: &#123;&#125;, port: &#123;&#125;\n&quot;</span>, addr_str, <span class="built_in">ntohs</span>(client_addr.sin_port));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="服务端-发送消息"   >
          <a href="#服务端-发送消息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-发送消息"></a> 服务端-发送消息</h2>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send" >send function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>建立好socket通道后，可以直接在此socket上send，recv。<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240830004003760.png" alt="" /></p>
<ol>
<li>参数1，已连接的socket</li>
<li>参数2，要发送的数据的指针</li>
<li>参数3，要发送的数据的大小（字节数）</li>
<li>参数4，指定调用方式的标志，可以按位OR。如无特殊需要，填0即可。</li>
<li>返回值，如果没有发生错误，将返回已发送的总字节数，该字节数可以小于len参数中请求发送的字节数。若错误，将返回<code>SOCKET_ERROR</code>，并且可以通过调用<code>WSAGetLastError</code>来检索特定的错误代码。</li>
</ol>
<div class="table-container"><table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_DONTROUTE</td>
<td>Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.<br>指定数据不应进行路由。Windows套接字服务提供程序可以选择忽略此标志。</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>Sends OOB data (stream-style socket such as SOCK_STREAM only).<br>发送OOB数据 (仅流式套接字，如SOCK_STREAM)</td>
</tr>
<tr>
<td>要注意，由于我们想要发送的是一个Unicode字符串，而参数<code>buf</code>的类型是<code>const char *</code>。</td>
<td></td>
</tr>
<tr>
<td>首先，不能以wstring对象的单位发送，应当发送其中的内容<code>message.c_str()</code>。</td>
<td></td>
</tr>
<tr>
<td>其次，<code>message.c_str()</code>返回类型为<code>const wchar_t *</code>，而TCP的send是要按字节流进行发送的，所以要显式转换指针为<code>const char*</code>，这里的<code>char*</code>和字符没有关系，而是表示按字节。</td>
<td></td>
</tr>
</tbody>
</table></div>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::wstring message&#123; <span class="string">L&quot;Welcome to server!&quot;</span> &#125;;</span><br><span class="line">    ::<span class="built_in">send</span>(</span><br><span class="line">        work_sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(message.<span class="built_in">c_str</span>()),</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * message.<span class="built_in">size</span>(),</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="send的阻塞问题"   >
          <a href="#send的阻塞问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#send的阻塞问题"></a> send的阻塞问题</h3>
      
<p>如果传输系统内没有可用的缓冲区空间来保存要传输的数据，如果套接字不是非阻塞模式，send将阻塞。<br />
在面向流的非阻塞套接字上，写入的字节数可以介于1和请求长度之间，具体取决于客户端和服务器计算机上的缓冲区可用性。</p>

        <h2 id="服务端-接收消息"   >
          <a href="#服务端-接收消息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-接收消息"></a> 服务端-接收消息</h2>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-recv" >recv function (winsock2.h)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240830044512192.png" alt="" /></p>
<ol>
<li>参数1，已连接的socket</li>
<li>参数2，要接收数据的buf指针</li>
<li>参数3，buf的字节大小</li>
<li>参数4，影响此函数行为的标志</li>
<li>返回值，如果没有发生错误，recv返回接收到的字节数，buf参数指向的缓冲区将填入接收到的数据。
<ol>
<li>如果套接字是面向连接的，并且远程端已正常关闭连接，则recv将立即返回0，接收到0字节。</li>
<li>如果是异常断开，将返回<code>SOCKET_ERROR</code>的值，并且可以通过调用<code>WSAGetLastError</code>来检索特定的错误代码。
<ol>
<li>如果连接已重置，错误为<code>WSAECONNRESET</code>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">wchar_t</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> bytes_received = ::<span class="built_in">recv</span>(work_sock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buf), <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_received &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::wcout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="recv的阻塞问题"   >
          <a href="#recv的阻塞问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#recv的阻塞问题"></a> recv的阻塞问题</h3>
      
<p>如果套接字上没有可用的传入数据，则recv调用将根据为阻塞并等待数据到达。<br />
如果套接字是非阻塞的。将返回<code>SOCKET_ERROR</code>，并将错误代码设置为<code>WSAEWOULDBLOCK</code>。</p>

        <h2 id="客户端-接收消息"   >
          <a href="#客户端-接收消息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端-接收消息"></a> 客户端-接收消息</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">wchar_t</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> bytes_received = ::<span class="built_in">recv</span>(</span><br><span class="line">        sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buf),</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * <span class="built_in">sizeof</span>(buf),</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_received &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::wcout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="客户端-发送消息"   >
          <a href="#客户端-发送消息" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端-发送消息"></a> 客户端-发送消息</h2>
      
<p>可以使用<code>std::wcin</code>作为Unicode标准输入到buf。<br />
buf中的内容会被覆盖。（但是用wcin作为输入有个缺陷，就是如果句子中间被空格断开了的话，只能填入buf空格之前的字符）<br />
注意，buf的类型是<code>wchar_t buf[100]</code>，是C风格的wchar数组，因此在计算有效长度len时（即不包含第一个<code>\0</code>），需要使用<code>wcslen(buf)</code>。如果要计算有效长度的字节大小，还需要乘以<code>sizeof(wchar_t)</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;Please input what you want to send to server: &quot;</span>;</span><br><span class="line">    std::wcin &gt;&gt; buf;</span><br><span class="line">    <span class="type">int</span> bytes_sent = ::<span class="built_in">send</span>(</span><br><span class="line">        sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(buf),</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * <span class="built_in">wcslen</span>(buf),</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="客户端-收尾工作"   >
          <a href="#客户端-收尾工作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端-收尾工作"></a> 客户端-收尾工作</h2>
      
<p>类似于指针管理，先释放资源，再把描述符置为无效。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ::<span class="built_in">closesocket</span>(sock);</span><br><span class="line">    sock = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="服务端-收尾工作"   >
          <a href="#服务端-收尾工作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-收尾工作"></a> 服务端-收尾工作</h2>
      
<p>类似于指针管理，先释放资源，再把描述符置为无效。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ::<span class="built_in">closesocket</span>(work_sock);</span><br><span class="line">    work_sock = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">closesocket</span>(listen_sock);</span><br><span class="line">    listen_sock = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="联调2"   >
          <a href="#联调2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#联调2"></a> 联调2</h2>
      
<p>分别运行、调试两端程序的方法同<a href="#%E8%81%94%E8%B0%831">联调1</a>。<br />
测试结果：<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240830061031808.png" alt="" /></p>
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/image-20240830061150520.png" alt="" /></p>

        <h2 id="可选客户端-bind"   >
          <a href="#可选客户端-bind" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#可选客户端-bind"></a> 【可选】客户端-bind</h2>
      
<p>见<a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84bind">客户端的bind</a>。<br />
需要在connect到server之前进行客户端的bind。需要声明一个本地的<code>sockaddr_in</code>，填入自己的协议、地址、端口号。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create socket...</span></span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    local.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;local.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local.sin_port = <span class="built_in">htons</span>(<span class="number">10000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">bind</span>(sock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;local), <span class="built_in">sizeof</span>(local)))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// connect ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试：<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20240830063739465.png" alt="" /><br />
发现，客户端的端口号确实改成了我们自定义的10000。</p>

        <h2 id="服务端-循环多次accept"   >
          <a href="#服务端-循环多次accept" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-循环多次accept"></a> 服务端-循环多次accept</h2>
      
<p>在accept到send、recv直到<code>closesocket(work_sock)</code>外面包一个while循环即可。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// accept ...</span></span><br><span class="line">        <span class="comment">// send ...</span></span><br><span class="line">        <span class="comment">// recv ...</span></span><br><span class="line">        ::<span class="built_in">closesocket</span>(work_sock);</span><br><span class="line">        work_sock = INVALID_SOCKET;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ::<span class="built_in">closesocket</span>(listen_sock);</span><br><span class="line">    listen_sock = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>但要注意，如果想要在一个主机上运行多个客户端，则客户端不能自定义为固定的端口号。即不能主动bind。<br />
经测试，可以运行2个客户端，排队连接：<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20240830064811774.png" alt="" /></p>

        <h2 id="服务端-修改监听队列大小"   >
          <a href="#服务端-修改监听队列大小" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-修改监听队列大小"></a> 服务端-修改监听队列大小</h2>
      
<p>如果修改服务端监听队列大小为1，会产生什么影响？</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">listen</span>(listen_sock, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>经测试，发现启动前2个客户端的connect正常：</p>
<ol>
<li>第1个客户端在第2个客户端启动之前，connect很快返回。此时第1个客户端还没输入消息，占用了连接。</li>
<li>第2个客户端在监听队列中等待第1个客户端结束。因此connect阻塞。</li>
</ol>
<p>但第3个客户端启动后，发现监听队列满了，因此会connect失败，立即返回<code>SOCKET_ERROR</code>。</p>

        <h2 id="服务端-循环多线程accept"   >
          <a href="#服务端-循环多线程accept" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务端-循环多线程accept"></a> 服务端-循环+多线程accept</h2>
      
<p>使用<code>jthread</code>+<code>lambda表达式</code>封装每一个客户端被服务端accept后，服务端的操作。注意构造完毕jthread后需要detach，否则默认会join，导致主线程等待子线程结束从而无法处理其他网络事务。<br />
还有，由于使用到了<code>client_addr</code>和<code>work_sock</code>，需要在lambda表达式的<code>[]</code>中进行捕获。<br />
在lambda表达式中，如果要修改某些值（此例中要修改<code>client_addr</code>和<code>addr_str</code>），默认是不允许的，如果要修改，需要修饰其为<code>mutable</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// WSAStartup</span></span><br><span class="line">    <span class="comment">// Create Socket</span></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// accept ...</span></span><br><span class="line">        <span class="function">std::jthread <span class="title">t</span><span class="params">([client_addr, work_sock]() <span class="keyword">mutable</span></span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">wchar_t</span> addr_str[<span class="number">46</span>] = <span class="string">L&quot;&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                InetNtopW(AF_INET, <span class="keyword">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;client_addr.sin_addr), addr_str, <span class="number">46</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                std::wcout &lt;&lt; std::format(<span class="string">L&quot;client address: &#123;&#125;, port: &#123;&#125;\n&quot;</span>, addr_str, ntohs(client_addr.sin_port));</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">// send ...</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">// recv ...</span></span></span></span><br><span class="line"><span class="params"><span class="function">                ::closesocket(work_sock);</span></span></span><br><span class="line"><span class="params"><span class="function">                work_sock = INVALID_SOCKET;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ::<span class="built_in">closesocket</span>(listen_sock);</span><br><span class="line">    listen_sock = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="更多测试客户端bind固定端口开启多个客户端"   >
          <a href="#更多测试客户端bind固定端口开启多个客户端" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#更多测试客户端bind固定端口开启多个客户端"></a> 更多测试：客户端bind固定端口，开启多个客户端</h3>
      
<p>客户端bind固定端口10000，开启多个客户端。<br />
在开启第2个客户端时，bind函数会失败，立即返回<code>SOCKET_ERROR</code>。<br />
此时关闭所有客户端。<br />
短时间内，再重新启动一个客户端，绑定的还是10000。还是会失败，此时bind成功，但connect是失败的。bind成功是因为目前10000端口只有一个客户端占用。connect失败是因为这个端口不久前刚被使用过，还没有完全失效。这与四次握手释放的时间有关系，默认在2分钟内相同的端口号不可重用。<br />
我们可以通过<code>WSAGetLastError()</code>获得错误码+Error Lookup查询详细的connect失败描述：<br />
经调试，connect失败时的错误码为10048。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">connect</span>(sock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;server_addr), <span class="built_in">sizeof</span>(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20240910022156675.png" alt="" /><br />
一个socket五元组地址只能用一次。</p>
<blockquote>
<p>五元组的组成：协议、网络地址、端口号。<br />
协议：客户端、服务端是一致的。共1个。<br />
网络地址：客户端、服务端各有一个。共2个。<br />
端口号：客户端、服务端各有一个。共2个。<br />
因此称为五元组。</p>
</blockquote>
<p>由于客户端中刚使用过的10000端口还未完全失效，因此无法很快地重用。</p>

        <h2 id="结合协程"   >
          <a href="#结合协程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#结合协程"></a> 结合协程</h2>
      
<p>在VS中，同一解决方案，多个项目：一个是服务器项目，一个是客户端项目，还有现在要提到的协程项目。为了使用协程，在解决方案中引入协程项目后，还需要在使用到它的项目中（如服务器项目）添加现有项（Add Existing Item），在Header Files中添加<code>.hpp</code>、<code>.h</code>文件，在Source Files中添加<code>.cpp</code>文件。然后，在代码文件中<code>#include &quot;../Coroutines/Agave.hpp&quot;</code>引入相应头文件以使用库。（在VS中，项目的当前目录都是以<code>.vcxproj</code>为基准的）</p>
<p>用协程函数封装上面lambda表达式中做的事情。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Coroutines-STD20/Agave.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// Fore Declaration</span></span><br><span class="line"><span class="function">agave::IAsyncAction <span class="title">worker_async</span><span class="params">(sockaddr_in client_addr, SOCKET work_sock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// WSAStartup</span></span><br><span class="line">    <span class="comment">// create socket</span></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... accept</span></span><br><span class="line">        <span class="built_in">worker_async</span>(client_addr, work_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="built_in">closesocket</span>(listen_sock);</span><br><span class="line">    listen_sock = INVALID_SOCKET;</span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">agave::IAsyncAction <span class="title">worker_async</span><span class="params">(sockaddr_in client_addr, SOCKET work_sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// let this function run on the child thread instead of the main thread.</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">agave::resume_background</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">wchar_t</span> addr_str[<span class="number">46</span>] = <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">InetNtopW</span>(AF_INET, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;client_addr.sin_addr), addr_str, <span class="number">46</span>);</span><br><span class="line">    std::wcout &lt;&lt; std::format(<span class="string">L&quot;client address: &#123;&#125;, port: &#123;&#125;\n&quot;</span>, addr_str, <span class="built_in">ntohs</span>(client_addr.sin_port));</span><br><span class="line">    <span class="comment">// send ...</span></span><br><span class="line">    <span class="comment">// recv ...</span></span><br><span class="line">    ::<span class="built_in">closesocket</span>(work_sock);</span><br><span class="line">    work_sock = INVALID_SOCKET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="结合线程池"   >
          <a href="#结合线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#结合线程池"></a> 结合线程池</h2>
      
<p>线程池的设计、代码见<a href="../%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0_bubo.md">线程池_bubo</a></p>
<p>新建项目<code>StreamServer</code>，新建源文件<code>stream_server_threadpool.cpp</code>。文件内容先拷贝<code>basic_stream_server.cpp</code>的，之后再作调整。</p>
<p>该项目引入头文件（Add Existing Item）：</p>
<ol>
<li>线程池部分：<code>ITask.h</code>、<code>ThreadPool.h</code></li>
<li>协程部分：<code>Agave.hpp</code>、<code>AgaveDetails.hpp</code>、<code>B_Object.hpp</code>、<code>BJobScheduler.h</code></li>
</ol>
<p>引入源文件（Add Existing Item）：</p>
<ol>
<li>线程池部分：<code>ThreadPool.cpp</code></li>
<li>协程部分：<code>BJobScheduler.cpp</code>。</li>
</ol>
<p>记得调整项目的<code>C++</code>标准为<code>C++20</code>。</p>

        <h3 id="task"   >
          <a href="#task" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#task"></a> Task</h3>
      
<p>新建<code>network_task.h</code>。<br />
需要设计什么？</p>
<ol>
<li>必须实现ITask的接口<code>run_task</code>。</li>
<li>根据<code>basic_stream_server.cpp</code>中的<code>worker_async(sockaddr_in client_addr, SOCKET work_sock)</code>接口，服务器要生成一个网络任务需要传入<code>client_addr</code>和<code>work_sock</code>（服务端<code>accept</code>后返回的sock）。因此<code>network_task</code>构造函数需要有这两个作为参数，以及需要有成员变量存储这两个。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ThreadPool/ITask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkTask</span> : <span class="keyword">public</span> thpool::ITask</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">NetworkTask</span>(sockaddr_in client_addr, SOCKET work_sock);</span><br><span class="line">	~<span class="built_in">NetworkTask</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">run_task</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	sockaddr_in				_client_addr;</span><br><span class="line">	SOCKET					_work_sock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>实现：<br />
主要实现<code>run_task</code>，代码内容是：</p>
<ol>
<li>服务端-显示连接的客户端信息</li>
<li>服务端-发送消息、接收消息</li>
<li>服务端-收尾工作</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream_server_threadpool.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"></span><br><span class="line">NetworkTask::<span class="built_in">NetworkTask</span>(sockaddr_in client_addr, SOCKET work_sock) : _client_addr&#123; client_addr &#125;, _work_sock&#123; work_sock &#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NetworkTask::~<span class="built_in">NetworkTask</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkTask::run_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">wchar_t</span> addr_str[<span class="number">46</span>] = <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">InetNtopW</span>(AF_INET, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;_client_addr.sin_addr), addr_str, <span class="number">46</span>);</span><br><span class="line">    std::wcout &lt;&lt; std::format(<span class="string">L&quot;client address: &#123;&#125;, port: &#123;&#125;\n&quot;</span>, addr_str, <span class="built_in">ntohs</span>(_client_addr.sin_port));</span><br><span class="line">    <span class="comment">// send ...</span></span><br><span class="line">    std::wstring message&#123; <span class="string">L&quot;Welcome to server!&quot;</span> &#125;;</span><br><span class="line">    ::<span class="built_in">send</span>(</span><br><span class="line">        _work_sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(message.<span class="built_in">c_str</span>()),</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * message.<span class="built_in">size</span>(),</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// recv ...</span></span><br><span class="line">    <span class="type">wchar_t</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> bytes_received = ::<span class="built_in">recv</span>(_work_sock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buf), <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_received &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::wcout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="built_in">closesocket</span>(_work_sock);</span><br><span class="line">    _work_sock = INVALID_SOCKET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="调用线程池"   >
          <a href="#调用线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调用线程池"></a> 调用线程池</h3>
      
<p>原先<code>basic_stream_server.cpp</code>中获得<code>work_sock</code>之后，可以调整其后的行为，让其调用协程（实际是用协程函数封装了后续收发行为）。那么此处，可以更改为调用线程池。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_task.h&quot;</span>                <span class="comment">// add</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ThreadPool/ThreadPool.h&quot;</span>    <span class="comment">// add</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;Ws2_32&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thpool::ThreadPool threadpool&#123; <span class="number">10</span> &#125;; <span class="comment">// add</span></span><br><span class="line">    </span><br><span class="line">    WORD wVersionRequested;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */</span></span><br><span class="line">    wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    err = ::<span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line">        <span class="comment">/* Winsock DLL.                                  */</span></span><br><span class="line">        std::wcout &lt;&lt; std::format(<span class="string">L&quot;WSAStartup failed with error : &#123;&#125;\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SOCKET listen_sock = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (listen_sock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sockaddr_in server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//service.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != ::<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9008</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">bind</span>(listen_sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;server_addr),</span><br><span class="line">        <span class="built_in">sizeof</span>(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">listen</span>(listen_sock, SOMAXCONN))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sockaddr_in client_addr;</span><br><span class="line">        <span class="type">int</span> addrlen&#123; <span class="built_in">sizeof</span>(client_addr) &#125;;</span><br><span class="line">        SOCKET work_sock = ::<span class="built_in">accept</span>(</span><br><span class="line">            listen_sock,</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;client_addr),</span><br><span class="line">            &amp;addrlen);</span><br><span class="line">        <span class="keyword">if</span> (work_sock == INVALID_SOCKET)</span><br><span class="line">        &#123;</span><br><span class="line">            err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// adjust: 调用线程池</span></span><br><span class="line">        threadpool.<span class="built_in">add_task</span>(std::<span class="built_in">shared_ptr</span>&lt;thpool::ITask&gt;(<span class="keyword">new</span> NetworkTask&#123; client_addr, work_sock &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">closesocket</span>(listen_sock);</span><br><span class="line">    listen_sock = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="测试-2"   >
          <a href="#测试-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试-2"></a> 测试</h4>
      
<p>运行1个服务端、3个客户端。<br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20240927061849838.png" alt="" /><br />
3个客户端分别输入<code>ThisIs1/2/3</code><br />
<img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20240927061953070.png" alt="" /></p>

        <h3 id="调用线程池同时使用协程"   >
          <a href="#调用线程池同时使用协程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调用线程池同时使用协程"></a> 调用线程池同时使用协程</h3>
      
<p>新建源文件<code>stream_server_threadpool_coroutine.cpp</code>，内容暂时拷贝<code>stream_server_threadpool.cpp</code>。<br />
新建头文件<code>coroutine_task.hpp</code>。与<code>network_task.hpp</code>不同，其需要一个function。<br />
协程和任务之间用function来作为媒介，可以把fn看作是协程函数<code>agave::IAsyncAction worker_async</code>，传入给CoroutineTask。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ThreadPool/ITask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoroutineTask</span> : <span class="keyword">public</span> thpool::ITask</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CoroutineTask</span>(std::function&lt;<span class="built_in">void</span>(<span class="type">void</span>)&gt; cb) : _cb&#123; cb &#125;</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">run_task</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_cb)</span><br><span class="line">		&#123;</span><br><span class="line">			_cb();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt;		_cb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>调用线程池同时使用协程时，我们是设置协程的背景，绑定一个线程池。<br />
即在建立线程池后给出如下的<code>set_bg_entry</code>，达到的效果是：每当协程函数调用<code>co_await agave::resume_background()</code>时，都会从背景绑定的线程池中抽取线程资源执行协程函数。<br />
具体的：在<code>set_bg_entry</code>中填入一个lambda表达式，捕获创建好的线程池，在该线程池中添加任务<code>add_task</code>，即创建一个<code>CoroutineTask</code>，使用<code>fn</code>作为参数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream_server_threadpool_coroutine.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ThreadPool/ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Coroutines/Agave.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;coroutine_task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;Ws2_32&quot;</span>)</span></span><br><span class="line"><span class="function">agave::IAsyncAction <span class="title">worker_async</span><span class="params">(sockaddr_in client_addr, SOCKET work_sock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thpool::ThreadPool threadpool&#123; <span class="number">10</span> &#125;;</span><br><span class="line">    agave::<span class="built_in">set_bg_entry</span>(</span><br><span class="line">        [&amp;threadpool](std::function&lt;<span class="built_in">void</span>(<span class="type">void</span>)&gt; fn)</span><br><span class="line">            &#123;</span><br><span class="line">                threadpool.<span class="built_in">add_task</span>(std::<span class="built_in">shared_ptr</span>&lt;thpool::ITask&gt;(<span class="keyword">new</span> CoroutineTask&#123; fn &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">    WORD wVersionRequested;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */</span></span><br><span class="line">    wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    err = ::<span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line">        <span class="comment">/* Winsock DLL.                                  */</span></span><br><span class="line">        std::wcout &lt;&lt; std::format(<span class="string">L&quot;WSAStartup failed with error : &#123;&#125;\n&quot;</span>, err);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SOCKET listen_sock = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (listen_sock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sockaddr_in server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//service.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != ::<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9008</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">bind</span>(listen_sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> sockaddr*&gt;(&amp;server_addr),</span><br><span class="line">        <span class="built_in">sizeof</span>(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCKET_ERROR == ::<span class="built_in">listen</span>(listen_sock, SOMAXCONN))</span><br><span class="line">    &#123;</span><br><span class="line">        err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sockaddr_in client_addr;</span><br><span class="line">        <span class="type">int</span> addrlen&#123; <span class="built_in">sizeof</span>(client_addr) &#125;;</span><br><span class="line">        SOCKET work_sock = ::<span class="built_in">accept</span>(</span><br><span class="line">            listen_sock,</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;client_addr),</span><br><span class="line">            &amp;addrlen);</span><br><span class="line">        <span class="keyword">if</span> (work_sock == INVALID_SOCKET)</span><br><span class="line">        &#123;</span><br><span class="line">            err = ::<span class="built_in">WSAGetLastError</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">worker_async</span>(client_addr, work_sock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">closesocket</span>(listen_sock);</span><br><span class="line">    listen_sock = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    ::<span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">agave::IAsyncAction <span class="title">worker_async</span><span class="params">(sockaddr_in client_addr, SOCKET work_sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// let this function run on the child thread instead of the main thread.</span></span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">agave::resume_background</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">wchar_t</span> addr_str[<span class="number">46</span>] = <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">InetNtopW</span>(AF_INET, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;client_addr.sin_addr), addr_str, <span class="number">46</span>);</span><br><span class="line">    std::wcout &lt;&lt; std::format(<span class="string">L&quot;client address: &#123;&#125;, port: &#123;&#125;\n&quot;</span>, addr_str, <span class="built_in">ntohs</span>(client_addr.sin_port));</span><br><span class="line">    <span class="comment">// send ...</span></span><br><span class="line">    std::wstring message&#123; <span class="string">L&quot;Welcome to server!&quot;</span> &#125;;</span><br><span class="line">    ::<span class="built_in">send</span>(</span><br><span class="line">        work_sock,</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(message.<span class="built_in">c_str</span>()),</span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * message.<span class="built_in">size</span>(),</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// recv ...</span></span><br><span class="line">    <span class="type">wchar_t</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> bytes_received = ::<span class="built_in">recv</span>(work_sock, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buf), <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_received &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::wcout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="built_in">closesocket</span>(work_sock);</span><br><span class="line">    work_sock = INVALID_SOCKET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="测试-3"   >
          <a href="#测试-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试-3"></a> 测试</h4>
      
<p><img src="../../images/%E7%BD%91%E7%BB%9C_TCP%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B/image-20240927065028838.png" alt="" /></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Linux/Linux_%E5%88%87%E6%8D%A2%E6%BA%90/">Linux_切换源</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-07</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Linux/Linux_%E5%88%87%E6%8D%A2%E6%BA%90/" data-flag-title="Linux_切换源"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="切换源"   >
          <a href="#切换源" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#切换源"></a> 切换源</h1>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak <span class="comment">#备份原来的列表</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/apt/sources.list <span class="comment">#修改源</span></span><br><span class="line"><span class="comment"># 将文件内容替换成源文件内容</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update <span class="comment">#更新列表</span></span><br></pre></td></tr></table></div></figure>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/106/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/106/">106</a><span class="page-number current">107</span><a class="page-number" href="/page/108/">108</a><span class="space">&hellip;</span><a class="page-number" href="/page/151/">151</a><a class="extend next" rel="next" href="/page/108/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">302</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>