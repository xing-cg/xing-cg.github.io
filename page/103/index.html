<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/103/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/103/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%A1%B9%E7%9B%AE/git/">git</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-16</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/git/" data-flag-title="git"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>新建仓库</li>
<li>git init</li>
<li>git remote add</li>
</ol>

        <h1 id="如何让本地指向远程仓库"   >
          <a href="#如何让本地指向远程仓库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何让本地指向远程仓库"></a> 如何让本地指向远程仓库</h1>
      
<ol>
<li>
<p>创建一个目录，使用git init命令将其变为一个可以通过git管理的仓库</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.<span class="built_in">mkdir</span>一个目录</span><br><span class="line">2.<span class="built_in">cd</span> 创建的目录</span><br><span class="line">3.git init .</span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>git remote是管理远程仓库的命令，git remote add [name] [url]可以给当前目录下的git添加一个远程仓库。这里的url我填的是gitee仓库的ssh地址。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add mygitee git@gitee.com:mrcan/distributed-system-framework.git</span><br><span class="line"><span class="comment"># git remote -v 可以查看远程仓库的信息</span></span><br></pre></td></tr></table></div></figure>
</li>
</ol>

        <h1 id="本地-远程进行同步"   >
          <a href="#本地-远程进行同步" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#本地-远程进行同步"></a> 本地、远程进行同步</h1>
      
<ol>
<li>
<p>生成密钥</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>切换到家目录下的&quot;.ssh&quot;文件夹，发现有id_rsa和id_rsa.pub，后者是公钥，公钥给别人，连接时根据其他用户输入的公钥经过加密算法与服务器上的私钥比对。</p>
</li>
<li>
<p>cat id_rsa.pub，把公钥内容拷贝下来，在gitee上的项目管理中找到部署公钥管理。</p>
</li>
<li>
<p>配置git全局用户名、邮箱</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&#x27;xcg&#x27;</span></span><br><span class="line">git config --global user.email <span class="string">&#x27;1933966629@qq.com&#x27;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li>
<p>使用git branch -r查看远程的分支有哪些，或者-a查看所有分支（包括本地分支）</p>
</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%A1%B9%E7%9B%AE/SGI-STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/">SGI-STL和Nginx内存池剖析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-07</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/SGI-STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/" data-flag-title="SGI-STL和Nginx内存池剖析"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<p>内存池是为了更高效地管理小块内存的频繁开辟、释放。</p>
<ol>
<li><code>C++</code> STL：标准模板库。</li>
<li>SGI STL：第三方厂商开发的，后来被纳入<code>C++</code>标准，成为了<code>C++</code> STL中管理内存的底层实现。</li>
<li>Nginx内存池设计</li>
</ol>

        <h1 id="c-stl空间配置器"   >
          <a href="#c-stl空间配置器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c-stl空间配置器"></a> <code>C++ STL</code>空间配置器</h1>
      
<p>先用vector举个例子</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> _Alloc = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>可以看到，vector第二个模板参数是一个空间配置器。</p>
<p>主要包含了四个方法：</p>
<ol>
<li><code>allocate</code>：负责给容器开辟内存空间=&gt;<code>malloc</code></li>
<li><code>deallocate</code>：负责释放容器内存空间=&gt;<code>free</code></li>
<li><code>construct</code>：负责在容器中构造对象=&gt;<code>定位new</code>：是基于已经开辟好了的容器空间中直接构造的。</li>
<li><code>destroy</code>：负责析构容器中的对象=&gt;<code>p-&gt;~T()</code></li>
</ol>
<p>空间配置器的核心作用：</p>
<ol>
<li>拆开了new的两个操作——对象的内存开辟、对象构造；</li>
<li>拆开了delete的两个操作——对象的析构，内存的内存释放。<br />
把空间和对象本身分开，在容器这个场景下更为适合。</li>
</ol>

        <h1 id="sgi-stl-的两级-allocator"   >
          <a href="#sgi-stl-的两级-allocator" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sgi-stl-的两级-allocator"></a> SGI STL 的两级 allocator</h1>
      
<p>提供了两个allocator的实现：</p>
<ol>
<li>一级allocator，实际上就是<code>malloc/free</code>；</li>
<li>二级allocator，是基于内存池的内存管理。<br />
本文主要剖析SGI的二级allocator，即内存池的实现。</li>
</ol>
<p>通过阅读源码，发现：</p>
<p>SGI STL底层对于容器的对象的构造、析构是通过自定义的全局模板函数Construct和Destroy完成的。<br />
而点进去发现本质上仍是通过<strong>定位new</strong>、<strong>调用对象的析构</strong>函数完成的。这些都是内存申请、释放工作之外的动作。</p>
<p>因此，可以推断，SGI STL的空间配置器<strong>主要工作的区别在于 allocate 和 deallocate</strong>，即<strong>对容器内存申请、释放的管理</strong>。</p>

        <h1 id="sgi-stl-内存池的实现"   >
          <a href="#sgi-stl-内存池的实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sgi-stl-内存池的实现"></a> SGI STL 内存池的实现</h1>
      
<p>内存池的粒度信息</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; _ALIGN = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; _MAX_BYTES = <span class="number">128</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; _NFREELISTS = <span class="number">16</span> &#125;;</span><br></pre></td></tr></table></div></figure>
<p>每一个内存chunk块的头信息</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">_Obj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">_Obj</span>* _M_free_list_link;</span><br><span class="line">    <span class="type">char</span> _M_client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>组织所有自由链表的指针数组。<br />
这是静态变量，多线程共享，volatile避免了读取缓存的脏数据。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];</span><br></pre></td></tr></table></div></figure>
<p>图示：<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807041312313.png" alt="" /><br />
一个数组，第 1 个位置存放的是 8 字节的内存池，第 2 个位置存放的是 16 字节的内存池，…，最后一个位置存放的是 128 字节的内存池。数组的大小和每个位置对应的字节数由<strong>内存池的粒度信息</strong>决定。<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807041752139.png" alt="" /></p>

        <h2 id="allocatesize_t"   >
          <a href="#allocatesize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#allocatesize_t"></a> <code>allocate(size_t)</code></h2>
      
<p>定义在<code>stl_alloc.h</code>中</p>
<p>统一的allocate接口。外部申请 n 个字节。如果是大块内存，则普通malloc。<br />
如果是128字节及以下的内存，则会从内存池中分配，这就是二级空间配置。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="type">size_t</span>) _MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 核心代码</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回 freelist 的某下标的指针（二级指针）</span></span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#     <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 去看 freelist 这个下标，有没有已开辟且由空闲的块</span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="literal">nullptr</span>)  <span class="comment">// 没有空闲块，或者没开辟。</span></span><br><span class="line">      &#123;</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                      <span class="comment">// 有空闲块。</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 让 这个下标 指向下一块空闲块。（见_Obj联合体定义）</span></span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">          <span class="comment">// 返回的是 __result 这个空闲块</span></span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="_s_freelist_indexsize_t"   >
          <a href="#_s_freelist_indexsize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_freelist_indexsize_t"></a> <code>_S_freelist_index(size_t)</code></h3>
      
<p>用于返回freelist的下标，0下标存放的是8字节的内存池块。1下标存放的是16字节的内存池块。以此类推。<br />
比如，<br />
外部申请 1 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(1 + 8 - 1) / 8 - 1 = 1 - 1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />
外部申请 7 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(7 + 8 - 1) / 8 - 1 = 1 - 1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />
外部申请 8 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>8</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(8 + 8 - 1) / 8 - 1 = 1 - 1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />
外部申请 9 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>2</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(9 + 8 - 1) / 8 - 1 = 2 - 1 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="type">size_t</span> _S_freelist_index(<span class="type">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (__bytes + (<span class="type">size_t</span>)_ALIGN - <span class="number">1</span> ) / (<span class="type">size_t</span>)_ALIGN      - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="_s_round_upsize_t"   >
          <a href="#_s_round_upsize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_round_upsize_t"></a> <code>_S_round_up(size_t)</code></h3>
      
<p>外部申请 n 字节，返回的是 n 字节对应的在内存池块中，一小块的实际大小（8的整数倍）。<br />
类似于向上取整（取8的整倍数的最小值），比如输入1到8，输出8。输入9到16，输出16。（输入0，输出0）<br />
比如，<br />
外部申请 1 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1000</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>0111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1000</mn><mi mathvariant="normal">&amp;</mi><mn>1000</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">(1 + 8 - 1) \&amp; \sim(8 - 1) = 8 \&amp; \sim(7) = 1000 \&amp; \sim(0111) = 1000 \&amp; 1000 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span><br />
外部申请 7 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>15</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>15</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1110</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>0111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1110</mn><mi mathvariant="normal">&amp;</mi><mn>1000</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">(7 + 8 - 1) \&amp; \sim(15 - 1) = 15 \&amp; \sim(7) = 1110 \&amp; \sim(0111) = 1110 \&amp; 1000 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span><br />
外部申请 8 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>8</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>16</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>15</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1111</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>0111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1111</mn><mi mathvariant="normal">&amp;</mi><mn>1000</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">(8 + 8 - 1) \&amp; \sim(16 - 1) = 15 \&amp; \sim(7) = 1111 \&amp; \sim(0111) = 1111 \&amp; 1000 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span><br />
外部申请 9 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>17</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>16</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>10000</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>00111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>10000</mn><mi mathvariant="normal">&amp;</mi><mn>11000</mn><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">(9 + 8 - 1) \&amp; \sim(17 - 1) = 16 \&amp; \sim(7) = 10000 \&amp; \sim(00111) = 10000 \&amp; 11000 = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line">_S_round_up(<span class="type">size_t</span> __bytes) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (__bytes + (<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="_s_refillsize_t"   >
          <a href="#_s_refillsize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_refillsize_t"></a> <code>_S_refill(size_t)</code></h2>
      
<p>调用<code>_S_chunk_alloc(__n, __nobjs)</code>，在内存池块中尽量找一个合适的小字节块。<br />
<code>_S_chunk_alloc</code>内部会帮你处理底层的开辟内存池，处理内存碎片，管理内存池的指示信息等等。<br />
由于<code>_S_chunk_alloc</code>第二个参数<code>__nobjs</code>传入的是引用，有可能<code>__nobjs</code>会被改变。<br />
调用之前，<code>__nobjs</code>是我们想要申请的小字节块的个数。<br />
调用结束后，<code>__nobjs</code>更新为了实际分配到的小字节块的个数。<br />
如果是 1 ，此次分配完之后，这个内存池块正好用完了，不构建freelist下标的链表。<br />
其他情况，构建相应的freelist下标的链表。<br />
for循环中做的是遍历内存池大块中的每个单元小块，联合体<code>_Obj*</code>的<code>_M_free_list_link</code>指向紧挨着的下一个单元小块。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that __n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    </span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="type">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">    </span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">    __result = (_Obj*)__chunk;</span><br><span class="line">    *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);</span><br><span class="line">    <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++)</span><br><span class="line">    &#123;</span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj*)((<span class="type">char</span>*)__next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i)</span><br><span class="line">        &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>图示：<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807041752139.png" alt="" /></p>

        <h2 id="_s_chunk_allocsize_t-int-nobjs"   >
          <a href="#_s_chunk_allocsize_t-int-nobjs" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_chunk_allocsize_t-int-nobjs"></a> <code>_S_chunk_alloc(size_t, int&amp; nobjs)</code></h2>
      
<p>在内存池块中尽量找一个合适的小字节块。<br />
期间，可能会改变外部传入的<code>__nobjs</code>。（因为是引用，外部会受影响）</p>
<p><code>__total_bytes</code>记录的是欲开辟的内存池大小（根据<code>__nobjs</code>，这个是小字节块数）。<br />
<code>__bytes_left</code>指的是<code>_S_end_free - _S_start_free</code>，指目前未被开发的大小。</p>

        <h3 id="__bytes_left还足够返回无需开辟新空间"   >
          <a href="#__bytes_left还足够返回无需开辟新空间" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#__bytes_left还足够返回无需开辟新空间"></a> <code>__bytes_left</code>还足够，返回，无需开辟新空间</h3>
      
<p>如果<code>__bytes_left</code>还足够（至少是 1 个小字节块），则返回<code>_S_start_free</code>。同时移动<code>_S_start_free</code>到新的位置。<br />
成功返回。无需额外操作。</p>
<hr />

        <h3 id="__bytes_left不足开辟新的更大的内存池块"   >
          <a href="#__bytes_left不足开辟新的更大的内存池块" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#__bytes_left不足开辟新的更大的内存池块"></a> <code>__bytes_left</code>不足，开辟新的更大的内存池块</h3>
      
<p>如果<code>__bytes_left</code>不足，则将要开辟新的更大的内存池块。<code>__bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4)</code></p>

        <h4 id="__bytes_left-0头插到合适的一个链表管理这个内存碎片"   >
          <a href="#__bytes_left-0头插到合适的一个链表管理这个内存碎片" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#__bytes_left-0头插到合适的一个链表管理这个内存碎片"></a> <code>__bytes_left &gt; 0</code>，头插到合适的一个链表，管理这个内存碎片</h4>
      
<p>如果<code>__bytes_left &gt; 0</code>。这时，为了不浪费<code>__bytes_left</code>而造成内存碎片，把这部分尚余的小内存给其对应的freelist下标的链头插。比如，剩余 32 字节，则找下标 3 ，<strong>头插</strong>进去。（见下文图示）</p>

        <h4 id="开辟新的大块内存_malloc正常"   >
          <a href="#开辟新的大块内存_malloc正常" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开辟新的大块内存_malloc正常"></a> 开辟新的大块内存_malloc正常</h4>
      
<p>以下是<code>__bytes_left</code>不足时，都需要做的操作，目的是开辟新的大块内存。返回的地址赋给<code>_S_start_free</code>。</p>
<hr />
<p>如果malloc正常（<code>malloc返回 != 0</code>），更新<code>_S_heap_size += __bytes_to_get;</code>，更新<code>_S_end_free = _S_start_free + __bytes_to_get;</code>。</p>
<p>malloc成功，递归调用<code>return(_S_chunk_alloc(__size, __nobjs));</code>。</p>

        <h4 id="开辟新的大块内存_malloc失败找内存池中已开辟的大单元链表的空间"   >
          <a href="#开辟新的大块内存_malloc失败找内存池中已开辟的大单元链表的空间" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开辟新的大块内存_malloc失败找内存池中已开辟的大单元链表的空间"></a> 开辟新的大块内存_malloc失败：找内存池中已开辟的大单元链表的空间</h4>
      
<hr />
<p>如果malloc失败（<code>malloc返回 == 0</code>）。则处理：<br />
遍历freelist的下标各个内存池块。从<code>size_t __n</code>对应的freelist下标，依次往后找有没有还有空闲的。</p>
<p><code>__i</code>初始化为<code>__n</code>，循环，每次<code>__i += (size_t) _ALIGN</code>（即加8）。比如，<code>__n</code>等于 40 字节，我们依次去找40、48、56等等的freelist下标的内存池块，看看有没有能分配出来空间的。</p>
<p>如果有，则<code>_S_start_free</code>指向第一个空闲块。更新<code>_S_end_free = _S_start_free + __i;</code><br />
好了，成功在更大单元的内存池块找到，递归调用<code>return(_S_chunk_alloc(__size, __nobjs));</code>。</p>

        <h4 id="开辟新的大块内存_malloc失败异常处理"   >
          <a href="#开辟新的大块内存_malloc失败异常处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开辟新的大块内存_malloc失败异常处理"></a> 开辟新的大块内存_malloc失败：异常处理</h4>
      
<hr />
<p>如果以上的for循环找了后面更大单元的内存池块，仍没有可用空间，则是系统内存不足的迹象：<br />
需要调用<code>malloc_alloc::allocate(__bytes_to_get);</code>。<br />
内部最后一次进行普通malloc的挣扎。<br />
如果malloc仍然返回 0 ，则进行异常处理（绑定的回调）。</p>
<hr />
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="type">size_t</span> __size, </span><br><span class="line">                                                            <span class="type">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* __result;</span><br><span class="line">    <span class="type">size_t</span> __total_bytes = __size * __nobjs;</span><br><span class="line">    <span class="type">size_t</span> __bytes_left = _S_end_free - _S_start_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes)</span><br><span class="line">    &#123;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size)</span><br><span class="line">    &#123;</span><br><span class="line">        __nobjs = (<span class="type">int</span>)(__bytes_left / __size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> __bytes_to_get = <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        _S_start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">            _Obj* __p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size; __i &lt;= (<span class="type">size_t</span>) _MAX_BYTES; __i += (<span class="type">size_t</span>) _ALIGN)</span><br><span class="line">            &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p)</span><br><span class="line">                &#123;</span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="type">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            _S_start_free = (<span class="type">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;</span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;</span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="头插小内存碎片图示"   >
          <a href="#头插小内存碎片图示" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#头插小内存碎片图示"></a> 头插小内存碎片，图示</h3>
      
<p><img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807063843813.png" alt="" /></p>

        <h3 id="oom异常处理"   >
          <a href="#oom异常处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oom异常处理"></a> oom异常处理</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result)</span><br><span class="line">    &#123;</span><br><span class="line">        __result = _S_oom_malloc(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler)</span><br><span class="line">        &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        </span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (__result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>(__result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="_s_start_free-_s_end_free-_s_heap_size"   >
          <a href="#_s_start_free-_s_end_free-_s_heap_size" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_start_free-_s_end_free-_s_heap_size"></a> <code>_S_start_free</code>、<code>_S_end_free</code>、<code>_S_heap_size</code></h3>
      
<p>这三个变量，只会在<code>_S_chunk_alloc(size_t, int&amp;)</code>函数执行中改变。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></div></figure>

        <h2 id="deallocatevoid-p-size_t"   >
          <a href="#deallocatevoid-p-size_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#deallocatevoid-p-size_t"></a> <code>deallocate(void* p, size_t)</code></h2>
      
<p>定义于<code>stl_alloc.h</code></p>
<p>头插归还，看图示。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="type">size_t</span>) _MAX_BYTES)</span><br><span class="line">        &#123;</span><br><span class="line">            malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _Obj* __STL_VOLATILE*  __my_free_list = </span><br><span class="line">                _S_free_list + _S_freelist_index(__n);</span><br><span class="line">            _Obj* __q = (_Obj*)__p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#           <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">            <span class="comment">/*REFERENCED*/</span></span><br><span class="line">            _Lock __lock_instance;</span><br><span class="line"><span class="meta">#           <span class="keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">    </span><br><span class="line">            __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = __q;</span><br><span class="line">            <span class="comment">// lock is released here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807073716103.png" alt="" /></p>

        <h2 id="reallocatevoid-p-old_sz-new_sz"   >
          <a href="#reallocatevoid-p-old_sz-new_sz" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#reallocatevoid-p-old_sz-new_sz"></a> <code>reallocate(void* p, old_sz, new_sz)</code></h2>
      
<p>对已开辟的内存池块的扩容、缩容。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">reallocate</span>(<span class="type">void</span>* __p,</span><br><span class="line">                                                    <span class="type">size_t</span> __old_sz,</span><br><span class="line">                                                    <span class="type">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* __result;</span><br><span class="line">    <span class="type">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__old_sz &gt; (<span class="type">size_t</span>)_MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="type">size_t</span>)_MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(__p);</span><br><span class="line">    &#125;</span><br><span class="line">    __result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">    __copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;</span><br><span class="line">    <span class="built_in">memcpy</span>(__result, __p, __copy_sz);</span><br><span class="line">    <span class="built_in">deallocate</span>(__p, __old_sz);</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="sgi-stl内存池总结"   >
          <a href="#sgi-stl内存池总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sgi-stl内存池总结"></a> SGI STL内存池总结</h2>
      
<p>SGI STL 二级空间配置器内存池的实现优点：</p>
<ol>
<li>对于每一个字节数的chunk块分配，都是给出一部分进行使用，另一部分作为备用，这个备用可以给当前字节数使用，也可以给其它字节数使用</li>
<li>对于备用内存池划分完chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块再次分配出去，备用内存池使用的干干净净！防止小块内存频繁的分配，释放，造成内存很多的碎片出来，内存没有更多的连续的大内存块。所以应用对于小块内存的操作，一般都会使用内存池来进行管理。</li>
<li>malloc内存分配失败，还会调用<code>oom_malloc</code>这么一个预先设置好的以后的回调函数，如果没设置，则<code>throw bad_alloc</code>。设置了则<code>for(;;)(*oom_malloc_handler)();</code>。</li>
</ol>

        <h1 id="nginx内存池设计和实现"   >
          <a href="#nginx内存池设计和实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx内存池设计和实现"></a> Nginx内存池设计和实现</h1>
      
<p>区分大小内存块的申请和释放，大于池尺寸的定义为大内存块，使用单独的大内存块链表保存，即时分配和释放；小于等于池尺寸的定义为小内存块，直接从预先分配的内存块中提取，不够就扩充池中的内存，在生命周期内对小块内存不做释放，直到最后统一销毁。</p>

        <h2 id="nginx内存池结构图"   >
          <a href="#nginx内存池结构图" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx内存池结构图"></a> Nginx内存池结构图</h2>
      
<p><img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250719234700476.png" alt="" /></p>

        <h2 id="nginx源码"   >
          <a href="#nginx源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx源码"></a> Nginx源码</h2>
      
<p>本次分析的是Nginx-release-1.13.1的源码。<br />
src目录下，有好多模块，其中内存池的模块位于<code>/src/core</code>目录下。使用的是C语言。<br />
对于不同的操作系统，有不同的实现，位于<code>/src/os/unix</code>和<code>/src/os/win32</code>下。</p>

        <h2 id="指标"   >
          <a href="#指标" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#指标"></a> 指标</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 ngx_palloc.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86.</span></span><br><span class="line"><span class="comment"> * On Windows NT it decreases a number of locked pages in a kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_DEFAULT_POOL_SIZE    (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MIN_POOL_SIZE                                                     \</span></span><br><span class="line"><span class="meta">    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \</span></span><br><span class="line"><span class="meta">              NGX_POOL_ALIGNMENT)</span></span><br></pre></td></tr></table></div></figure>
<ol>
<li><code>NGX_MAX_ALLOC_FROM_POOL</code>定义了可以从内存池中申请的最大内存。默认是<code>Nginx页面大小减1</code>。x86系统下是<code>4096字节减1</code>。</li>
<li><code>NGX_DEFAULT_POOL_SIZE</code>定义了Nginx内存池默认大小。是<code>16 * 1024B</code> 即 <code>16KB</code>。</li>
<li><code>NGX_POOL_ALIGNMENT</code>，内存池，分配内存时的对齐大小。默认是16。</li>
<li><code>NGX_MIN_POOL_SIZE</code>定义了内存池的最小大小。
<ol>
<li>其需要通过<code>ngx_align</code>计算，定义如下：发现和STL的<code>round_up</code>一样，向上取 d 的整 a 倍数。比如，a等于16、d等于7的话，那d取整后就是16，d等于17的话，取整后就是32。</li>
<li>其中d是<code>(sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t))</code>。a是<code>NGX_POOL_ALIGNMENT</code>，默认是16。</li>
</ol>
</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 ngx_config.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align(d, a)     ( ( (d) + (a - 1) ) &amp; ~(a - 1))</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="关键数据结构"   >
          <a href="#关键数据结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关键数据结构"></a> 关键数据结构</h2>
      
<p>定义于<code>ngx_palloc.h</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typdef strcut</span><br><span class="line">&#123;</span><br><span class="line">    u_char        *last;       <span class="comment">// 当前数据块中内存分配指针的当前位置</span></span><br><span class="line">    u_char        *end;        <span class="comment">// 内存块的结束位置</span></span><br><span class="line">    <span class="type">ngx_pool_t</span>    *next;       <span class="comment">// 内存池由多块内存块组成，指向下一个数据块的位置</span></span><br><span class="line">    <span class="type">ngx_uint_t</span>    failed;      <span class="comment">// 当前数据块内存不足引起分配失败的次数</span></span><br><span class="line">&#125; <span class="type">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">ngx_pool_data_t</span>    d;        <span class="comment">// 上面那个结构体：内存池当前的数据区指针的结构体</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span>             max;      <span class="comment">// max 指的是 Nginx 一次分配小块内存大小 的最大值。</span></span><br><span class="line">    <span class="type">ngx_pool_t</span>         *current; <span class="comment">// 当前正在使用的数据块的指针</span></span><br><span class="line">    <span class="type">ngx_chain_t</span>        *chain;   <span class="comment">// 把内存池链接起来</span></span><br><span class="line">    <span class="type">ngx_pool_large_t</span>   *large;   <span class="comment">// 指向大数据块的指针（大数据块是指size &gt; max的数据）</span></span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span> *cleanup; <span class="comment">// 类似于析构函数，在 内存free 之前，对内存上的数据进行处理，比如释放指针对应的外部资源</span></span><br><span class="line">    <span class="type">ngx_log_t</span>          *<span class="built_in">log</span>;     </span><br><span class="line">&#125;; <span class="comment">// in ngx_core.h: typedef struct ngx_pool_s ngx_pool_t;</span></span><br></pre></td></tr></table></div></figure>
<p>在<code>ngx_core.h</code>中，</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br></pre></td></tr></table></div></figure>
<p>即<code>npx_pool_t</code>是<code>struct ngx_pool_s</code>的别名。</p>
<p>在Nginx内存池中，<code>npx_pool_t</code>这个结构只出现在第一个内存池块的头部上，后续链接的内存池块头部只有<code>ngx_pool_data_t</code>。</p>
<p><code>struct ngx_pool_s</code>（别名<code>ngx_pool_t</code>）结构示意图（大小为1024的池）<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250719235439957.png" alt="" /></p>

        <h2 id="npx_create_pool创建内存池"   >
          <a href="#npx_create_pool创建内存池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#npx_create_pool创建内存池"></a> <code>npx_create_pool</code>创建内存池</h2>
      
<p>声明于<code>ngx_palloc.h</code>，定义于<code>ngx_palloc.c</code>。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_pool_t</span> * <span class="title function_">ngx_create_pool</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br></pre></td></tr></table></div></figure>
<p>返回<code>npx_pool_t *</code>。</p>
<p>开辟指定大小的内存池。根据不同系统、不同的对齐方法，调用不同的API。<br />
一般是普通的malloc。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_pool_t</span> * <span class="title function_">ngx_create_pool</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    <span class="comment">// 如果不用内存对齐，则实际就是普通的 malloc</span></span><br><span class="line">    <span class="comment">// 如果需要内存对齐，则调用posix_memalign(void ** p, size_t alignment, size_t size)</span></span><br><span class="line">    <span class="comment">// 或 memalign(size_t alignment, size_t size)</span></span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个内存池大块，指向这个新开辟的内存池大块的头信息之后。</span></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    <span class="comment">// 内存池的结束位置，整个大块的尾部。</span></span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size 更新为 除去头信息大小的 实际存储数据的大小</span></span><br><span class="line">    size = size - <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    <span class="comment">// 若 size 小于 MAX_ALLOC，则 max为size，size 大于 MAX_ALLOC 则 max 为 MAX_ALLOC</span></span><br><span class="line">    <span class="comment">// max 指的是 Nginx 一次分配小块内存大小 的最大值。如果用户申请大于max，则按大块数据块处理。</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line">    <span class="comment">// 指向自己，首地址（包含头信息）</span></span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="ngx_memalignpool_alignment-size-log或ngx_allocsize-log"   >
          <a href="#ngx_memalignpool_alignment-size-log或ngx_allocsize-log" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_memalignpool_alignment-size-log或ngx_allocsize-log"></a> <code>ngx_memalign(POOL_ALIGNMENT, size, log)</code>或<code>ngx_alloc(size, log)</code></h3>
      
<p>这是个宏定义，定义于<code>/src/os/unix</code>和<code>/src/os/win32</code>下的<code>ngx_alloc.h</code>。</p>
<p>在Unix下，有对齐的区别：如果要做内存对齐，则<code>size_t alignment</code>参数生效，否则忽略对齐参数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>
<p>在Win32下，没有对齐限制。<code>#define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)</code></p>
<p>名字上，暂时一样。但是相应的<code>ngx_alloc(size, log)</code>函数，在两个操作系统上就是不同的实现了。<br />
我们看Unix的：实际就是套了个<strong>普通malloc</strong>。然后输出了一些日志信息。<br />
定义于<code>/src/os/unix/ngx_alloc.c</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="从创建好的内存池中申请内存"   >
          <a href="#从创建好的内存池中申请内存" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#从创建好的内存池中申请内存"></a> 从创建好的内存池中申请内存</h2>
      
<p>定义于<code>ngx_palloc.c</code><br />
3个接口：<code>ngx_palloc</code>、<code>ngx_pnalloc</code>、<code>ngx_pcalloc</code></p>
<ol>
<li><code>ngx_palloc</code>和<code>ngx_pnalloc</code>的区别在于在申请<strong>小块内存</strong>时，<strong>前者考虑对齐</strong>，后者不考虑对齐</li>
<li><code>ngx_pcalloc</code>是调用<code>ngx_palloc</code>，之后的额外操作是<strong>清零申请的区域</strong>。</li>
</ol>

        <h3 id="ngx_pallocpool-size"   >
          <a href="#ngx_pallocpool-size" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_pallocpool-size"></a> <code>ngx_palloc(pool, size)</code></h3>
      
<p>如果用户申请小于等于pool头信息中max大小的内存，则按小块管理。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_palloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。</span></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_pnalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。</span></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_pcalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    p = ngx_palloc(pool, size);</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_memzero(p, size);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="ngx_palloc_smallpool-size-align"   >
          <a href="#ngx_palloc_smallpool-size-align" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_palloc_smallpool-size-align"></a> <code>ngx_palloc_small(pool, size, align)</code></h3>
      
<p>第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。</p>
<p>找current，即从该内存池大块之中分配内存。</p>
<p><code>ngx_align_ptr</code>，将<code>p-&gt;d.last</code>指向的可用数据地址按<code>NGX_ALIGNMENT</code>对齐到指定数（默认是32）的倍数，比如如果地址是8，则舍弃一部分内存，对齐到32。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ngx_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">ngx_palloc_small</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size, <span class="type">ngx_uint_t</span> align)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    <span class="comment">// 从 pool 头信息找到当前可用的内存池大块</span></span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 当前数据块中可分配的内存的开始位置</span></span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align)</span><br><span class="line">        &#123;</span><br><span class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// end 是当前数据块中可分配的内存的结束位置，与开始位置相减，如果大于等于用户申请的大小</span></span><br><span class="line">        <span class="comment">// 则 直接返回 m ，即开始位置，把 last 位置 下移 size，表示分配了 size 大小</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>) (p-&gt;d.end - m) &gt;= size)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 目前的数据块 大小 不够 size，则遍历找下一个数据块。</span></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line">    <span class="comment">// 直到所有数据块都不够用，则</span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_block(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="ngx_align_ptrp-a内存对齐"   >
          <a href="#ngx_align_ptrp-a内存对齐" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_align_ptrp-a内存对齐"></a> <code>ngx_align_ptr(p, a)</code>内存对齐</h4>
      
<p>定义于<code>ngx_config.h</code></p>
<p>如果没有定义<code>NGX_ALIGNMENT</code>，则默认是<code>sizeof(unsigned long)</code>，按照32位对齐。这是内存单元对齐。</p>
<blockquote>
<p>注意要和<code>ngx_palloc.h</code>中定义的<code>#define NGX_POOL_ALIGNMENT 16</code>区分。那是内存池对齐。</p>
</blockquote>
<p>即向定义的对齐大小（32）向上取整32倍。</p>
<p>操作是：传入的指针地址，加上指针大小32（4字节，32位）减1，和32减1取反后，相与。<br />
比如：传入的指针地址是8：<code>0000 1000</code>（前面补0），则加32减1：<code>0010 1000</code><br />
<code>0010 0000 - 1 = 0001 1111</code>取反<code>1110 0000</code>（前面补1）。<code>0010 1000</code>和<code>1110 0000</code>相与后：<code>0010 0000</code>，由原先的8，对齐到了32。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NGX_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_ALIGNMENT   sizeof(unsigned long)    <span class="comment">/* platform word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line"><span class="meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_palloc_blockpool-size再开辟一大块内存池"   >
          <a href="#ngx_palloc_blockpool-size再开辟一大块内存池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_palloc_blockpool-size再开辟一大块内存池"></a> <code>ngx_palloc_block(pool, size)</code>再开辟一大块内存池</h2>
      
<p>从pool的头块找到<code>end - pool</code>的大小，这是内存池每一个大块的大小（包含头信息的大小）</p>
<p>这是为了<strong>再开辟一大块内存池</strong>做准备。</p>
<p><code>ngx_memalign</code>和第一次创建内存池一样，如果没有对齐要求，则普通malloc。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">ngx_palloc_block</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">size_t</span>       psize;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p, *new;</span><br><span class="line">    <span class="comment">// 一整个内存池大块（包含头信息）的大小。</span></span><br><span class="line">    psize = (<span class="type">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"></span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new = (<span class="type">ngx_pool_t</span> *) m;</span><br><span class="line">    <span class="comment">// psize是整个内存池块的大小。m是开始，则end指向这个新开辟的内存池块的末尾</span></span><br><span class="line">    new-&gt;d.end = m + psize;</span><br><span class="line">    <span class="comment">// next暂时指向NULL。</span></span><br><span class="line">    new-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放普通内存池块的头信息</span></span><br><span class="line">    m += <span class="keyword">sizeof</span>(<span class="type">ngx_pool_data_t</span>);</span><br><span class="line">    <span class="comment">// 内存对齐 m ，存储实际数据的开始地址</span></span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="comment">// 分配出去 size 大小的内存，last（下一个空闲内存的开始地址）更新到新位置</span></span><br><span class="line">    new-&gt;d.last = m + size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从整个内存池的current到后续一长串，给每一个内存池块的failed计数加1。</span></span><br><span class="line">    <span class="comment">// 如果发现当前这个内存池块的failed是4，则current指向这个failed次数过多内存池块的下一个内存池块。 </span></span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出for 循环后，p 更新到了 最后一个内存池块。同时，当前pool的current指向的是第一个failed不为4的内存池块</span></span><br><span class="line">    <span class="comment">// 尾插。链接起来新开辟的这个内存池块。</span></span><br><span class="line">    p-&gt;d.next = new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_palloc_largepool-size大块内存分配管理"   >
          <a href="#ngx_palloc_largepool-size大块内存分配管理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_palloc_largepool-size大块内存分配管理"></a> <code>ngx_palloc_large(pool, size)</code>大块内存分配管理</h2>
      
<p>用户申请比<code>pool-&gt;max</code>大的内存时，按大块内存分配管理。<br />
用<code>ngx_alloc</code>分配size大小的内存（和分配内存池块的方法一样）见<a href="#%60ngx_memalign(POOL_ALIGNMENT,%20size,%20log)%60%E6%88%96%60ngx_alloc(size,%20log)%60"><code>ngx_memalign(POOL_ALIGNMENT, size, log)</code>或<code>ngx_alloc(size, log)</code></a>。<br />
遍历找large链的前5个，看是否有large的alloc为空的，直接让alloc指向一开始malloc得到的p。<br />
如果连续找了5个，发现large的alloc都不为空，则跳出循环，不再找了。<br />
这个for循环是为了快速在前5个large中，找到一个之前开辟的，但已经空闲了的大内存块头信息，其alloc管理的大内存块已经释放了，所以为NULL，直接让alloc指向一开始malloc得到的p即可。</p>
<p>如果没有进入循环，说明large一开始就是空的，内存池没有申请过大块内存；或者是找了5个发现large的alloc都不空：执行下面的操作（头插大内存块的头信息到pool的large链）：</p>
<p>记录大内存块（large管理）的 头信息<code>ngx_pool_large_t</code>，是按照<code>ngx_palloc_small</code>方法，存放到了内存池块的小块内存中。<br />
<code>ngx_palloc_small</code>返回空说明系统内存不够用了，失败，释放一开始malloc得到的大块内存，返回NULL。</p>
<p>如果正常，则在这个大块内存头信息填写：<br />
<code>alloc</code>，即这个大块内存的地址，为一开始malloc得到的地址。<br />
<code>next</code>，指向pool的large链头，pool的large指向这个新大块内存的头信息。相当于头插！只不过插的是大内存块的头信息。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">ngx_palloc_large</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>              *p;</span><br><span class="line">    <span class="type">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *large;</span><br><span class="line"></span><br><span class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录 大块 内存（large管理）的 头信息，存放到内存池块管理的小块内存中。</span></span><br><span class="line">    <span class="comment">// 返回空说明 系统 内存不够用了，失败。</span></span><br><span class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>图示：<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807115333694.png" alt="" /></p>
<p>如图，大块内存的头信息，是按小块内存管理，分配到了内存池块中。</p>
<p>下面要提到的外部资源所绑定的清理的头信息，也像是大块内存头信息一样，按小块内存管理，分配到了内存池块中。</p>

        <h2 id="ngx_pool_cleanup_add分配一个需要管理外部资源的数据比如指针-fd"   >
          <a href="#ngx_pool_cleanup_add分配一个需要管理外部资源的数据比如指针-fd" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_pool_cleanup_add分配一个需要管理外部资源的数据比如指针-fd"></a> <code>ngx_pool_cleanup_add</code>分配一个需要管理外部资源的数据（比如指针、fd）</h2>
      
<p>按小块内存分配<code>ngx_pool_cleanup_t</code>，这是清理的头信息块。<br />
有：handler、data、next。</p>
<p>之后才是分配size。</p>
<p>之后，像头插大内存块的头信息链表一样，头插清理类的头信息链表。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_pool_cleanup_t</span> * <span class="title function_">ngx_pool_cleanup_add</span><span class="params">(<span class="type">ngx_pool_t</span> *p, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    c = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size)</span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="通过返回的ngx_pool_cleanup_t-绑定清理回调函数"   >
          <a href="#通过返回的ngx_pool_cleanup_t-绑定清理回调函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通过返回的ngx_pool_cleanup_t-绑定清理回调函数"></a> 通过返回的<code>ngx_pool_cleanup_t *</code>绑定清理回调函数</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">pData</span> =</span> ngx_alloc(<span class="number">512</span>);</span><br><span class="line">pData-&gt;p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(pData-&gt;p, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_release</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ngx_pool_cleanup_t</span> *pclean = ngx_pool_cleanup_add(pool, <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">pclean-&gt;handler = &amp;my_release;</span><br><span class="line">pclean-&gt;data = pData-&gt;p;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_pfreepool-void-p大块内存释放"   >
          <a href="#ngx_pfreepool-void-p大块内存释放" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_pfreepool-void-p大块内存释放"></a> <code>ngx_pfree(pool, void *p)</code>大块内存释放</h2>
      
<p>用于释放大块内存。先free，后把large头信息中的alloc置空。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_pfree</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line"></span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="小块内存释放无"   >
          <a href="#小块内存释放无" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#小块内存释放无"></a> 小块内存释放：无</h2>
      
<p>Nginx的小块内存一旦分配了之后，就无法精确地回收。</p>
<p>不像SGI STL一样，假设A、B、C三个小内存单元相邻，A、C空闲，A是freelist的第一个空闲块，A的next是C。现在释放B，则B头插到freelist，现在是B连着A连着C。这样可以精确地释放，并下次还能重新分配（可以发现，由于是头插到了freelist的第一个空闲区域，所以最后释放的最先分配）。</p>
<p>Nginx呢，每个内存池块只是由<code>last</code>和<code>end</code>两个指针管理，只能指示当前内存池块的未分配的部分。</p>
<p>当已分配的部分中，有 1 个小块内存要释放，无法精确管理。所以Nginx只能连续地释放一整段空间，与last相连。</p>

        <h2 id="ngx_reset_poolpool"   >
          <a href="#ngx_reset_poolpool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_reset_poolpool"></a> <code>ngx_reset_pool(pool)</code></h2>
      
<p>遍历large链表，释放每个大块内存。最后large置空。<br />
遍历每个内存池块，把last拉到头信息的末尾即可，相当于释放了内存池的数据。最后current置为pool。<br />
注意，只是释放了大块内存，所有内存池块都没有free，只是更新了last。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_reset_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == pool) <span class="comment">// 第一个内存池，有pool头信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;d.last = (u_char*)p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>           <span class="comment">// 其余的内存池，只有小头信息，没有pool大头</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_data_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_destroy_poolpool"   >
          <a href="#ngx_destroy_poolpool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_destroy_poolpool"></a> <code>ngx_destroy_pool(pool)</code></h2>
      
<ol>
<li>遍历“清理”链表，每个都按照绑定的handler释放其data外部资源。</li>
<li>遍历large链表，释放每个大块内存。</li>
<li>遍历每个内存池块，释放每个内存池块。</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_destroy_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="nginx和stl释放内存的策略适用的场景"   >
          <a href="#nginx和stl释放内存的策略适用的场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx和stl释放内存的策略适用的场景"></a> Nginx和STL释放内存的策略适用的场景</h1>
      
<p>Nginx大块内存分配=》内存释放ngx_free函数<br />
Nginx小块内存分配=》没有提供任何的内存释放函数。</p>
<p>实际上，从小块内存的分配方式来看（直接通过last指针偏移来分配内存），根本没法进行中间部分的小块内存的回收。</p>
<p>Nginx本质：HTTP服务器是一个短链接的服务器，客户端（浏览器）发起一个request请求，到达Nginx服务器以后，处理完成，Nginx给客户端返回一个response响应，HTTP服务器就主动断开tcp连接。<br />
假设HTTP 1.1 keep-alive：60s，HTTP服务器（nginx）返回响应以后，需要等待60s，60s之内客户端又发来请求，重置这个时间；<br />
否则60s之内没有客户端发来的响应，Nginx也是最终会主动断开连接，此时Nginx可以调用ngx_reset_pool重置内存池了，等待下一次客户端的请求。</p>
<p>因此，Nginx内存池的设计适用于间歇性、短连接的服务。虽然有内存泄漏，但效率高，空间换时间。</p>
<p>如果是长连接，且小块内存分配、释放较多，最好用STL二级空间配置器，避免内存泄漏过多。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/102/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/102/">102</a><span class="page-number current">103</span><a class="page-number" href="/page/104/">104</a><span class="space">&hellip;</span><a class="page-number" href="/page/153/">153</a><a class="extend next" rel="next" href="/page/104/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">305</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>