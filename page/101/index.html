<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/101/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/101/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%A1%B9%E7%9B%AE/SGI-STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/">SGI-STL和Nginx内存池剖析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-04-08</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-07</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/SGI-STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/" data-flag-title="SGI-STL和Nginx内存池剖析"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<p>内存池是为了更高效地管理小块内存的频繁开辟、释放。</p>
<ol>
<li><code>C++</code> STL：标准模板库。</li>
<li>SGI STL：第三方厂商开发的，后来被纳入<code>C++</code>标准，成为了<code>C++</code> STL中管理内存的底层实现。</li>
<li>Nginx内存池设计</li>
</ol>

        <h1 id="c-stl空间配置器"   >
          <a href="#c-stl空间配置器" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c-stl空间配置器"></a> <code>C++ STL</code>空间配置器</h1>
      
<p>先用vector举个例子</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> _Alloc = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>可以看到，vector第二个模板参数是一个空间配置器。</p>
<p>主要包含了四个方法：</p>
<ol>
<li><code>allocate</code>：负责给容器开辟内存空间=&gt;<code>malloc</code></li>
<li><code>deallocate</code>：负责释放容器内存空间=&gt;<code>free</code></li>
<li><code>construct</code>：负责在容器中构造对象=&gt;<code>定位new</code>：是基于已经开辟好了的容器空间中直接构造的。</li>
<li><code>destroy</code>：负责析构容器中的对象=&gt;<code>p-&gt;~T()</code></li>
</ol>
<p>空间配置器的核心作用：</p>
<ol>
<li>拆开了new的两个操作——对象的内存开辟、对象构造；</li>
<li>拆开了delete的两个操作——对象的析构，内存的内存释放。<br />
把空间和对象本身分开，在容器这个场景下更为适合。</li>
</ol>

        <h1 id="sgi-stl-的两级-allocator"   >
          <a href="#sgi-stl-的两级-allocator" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sgi-stl-的两级-allocator"></a> SGI STL 的两级 allocator</h1>
      
<p>提供了两个allocator的实现：</p>
<ol>
<li>一级allocator，实际上就是<code>malloc/free</code>；</li>
<li>二级allocator，是基于内存池的内存管理。<br />
本文主要剖析SGI的二级allocator，即内存池的实现。</li>
</ol>
<p>通过阅读源码，发现：</p>
<p>SGI STL底层对于容器的对象的构造、析构是通过自定义的全局模板函数Construct和Destroy完成的。<br />
而点进去发现本质上仍是通过<strong>定位new</strong>、<strong>调用对象的析构</strong>函数完成的。这些都是内存申请、释放工作之外的动作。</p>
<p>因此，可以推断，SGI STL的空间配置器<strong>主要工作的区别在于 allocate 和 deallocate</strong>，即<strong>对容器内存申请、释放的管理</strong>。</p>

        <h1 id="sgi-stl-内存池的实现"   >
          <a href="#sgi-stl-内存池的实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sgi-stl-内存池的实现"></a> SGI STL 内存池的实现</h1>
      
<p>内存池的粒度信息</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; _ALIGN = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; _MAX_BYTES = <span class="number">128</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; _NFREELISTS = <span class="number">16</span> &#125;;</span><br></pre></td></tr></table></div></figure>
<p>每一个内存chunk块的头信息</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">_Obj</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">_Obj</span>* _M_free_list_link;</span><br><span class="line">    <span class="type">char</span> _M_client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>组织所有自由链表的指针数组。<br />
这是静态变量，多线程共享，volatile避免了读取缓存的脏数据。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];</span><br></pre></td></tr></table></div></figure>
<p>图示：<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807041312313.png" alt="" /><br />
一个数组，第 1 个位置存放的是 8 字节的内存池，第 2 个位置存放的是 16 字节的内存池，…，最后一个位置存放的是 128 字节的内存池。数组的大小和每个位置对应的字节数由<strong>内存池的粒度信息</strong>决定。<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807041752139.png" alt="" /></p>

        <h2 id="allocatesize_t"   >
          <a href="#allocatesize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#allocatesize_t"></a> <code>allocate(size_t)</code></h2>
      
<p>定义在<code>stl_alloc.h</code>中</p>
<p>统一的allocate接口。外部申请 n 个字节。如果是大块内存，则普通malloc。<br />
如果是128字节及以下的内存，则会从内存池中分配，这就是二级空间配置。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="type">size_t</span>) _MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 核心代码</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回 freelist 的某下标的指针（二级指针）</span></span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#     <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 去看 freelist 这个下标，有没有已开辟且由空闲的块</span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="literal">nullptr</span>)  <span class="comment">// 没有空闲块，或者没开辟。</span></span><br><span class="line">      &#123;</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                      <span class="comment">// 有空闲块。</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 让 这个下标 指向下一块空闲块。（见_Obj联合体定义）</span></span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">          <span class="comment">// 返回的是 __result 这个空闲块</span></span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="_s_freelist_indexsize_t"   >
          <a href="#_s_freelist_indexsize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_freelist_indexsize_t"></a> <code>_S_freelist_index(size_t)</code></h3>
      
<p>用于返回freelist的下标，0下标存放的是8字节的内存池块。1下标存放的是16字节的内存池块。以此类推。<br />
比如，<br />
外部申请 1 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(1 + 8 - 1) / 8 - 1 = 1 - 1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />
外部申请 7 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(7 + 8 - 1) / 8 - 1 = 1 - 1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />
外部申请 8 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>8</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(8 + 8 - 1) / 8 - 1 = 1 - 1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />
外部申请 9 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>8</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>2</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(9 + 8 - 1) / 8 - 1 = 2 - 1 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="type">size_t</span> _S_freelist_index(<span class="type">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (__bytes + (<span class="type">size_t</span>)_ALIGN - <span class="number">1</span> ) / (<span class="type">size_t</span>)_ALIGN      - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="_s_round_upsize_t"   >
          <a href="#_s_round_upsize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_round_upsize_t"></a> <code>_S_round_up(size_t)</code></h3>
      
<p>外部申请 n 字节，返回的是 n 字节对应的在内存池块中，一小块的实际大小（8的整数倍）。<br />
类似于向上取整（取8的整倍数的最小值），比如输入1到8，输出8。输入9到16，输出16。（输入0，输出0）<br />
比如，<br />
外部申请 1 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>8</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1000</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>0111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1000</mn><mi mathvariant="normal">&amp;</mi><mn>1000</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">(1 + 8 - 1) \&amp; \sim(8 - 1) = 8 \&amp; \sim(7) = 1000 \&amp; \sim(0111) = 1000 \&amp; 1000 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span><br />
外部申请 7 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>7</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>15</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>15</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1110</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>0111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1110</mn><mi mathvariant="normal">&amp;</mi><mn>1000</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">(7 + 8 - 1) \&amp; \sim(15 - 1) = 15 \&amp; \sim(7) = 1110 \&amp; \sim(0111) = 1110 \&amp; 1000 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span><br />
外部申请 8 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>8</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>16</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>15</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1111</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>0111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1111</mn><mi mathvariant="normal">&amp;</mi><mn>1000</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">(8 + 8 - 1) \&amp; \sim(16 - 1) = 15 \&amp; \sim(7) = 1111 \&amp; \sim(0111) = 1111 \&amp; 1000 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span><br />
外部申请 9 字节，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>9</mn><mo>+</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>17</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>16</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>=</mo><mn>10000</mn><mi mathvariant="normal">&amp;</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>00111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>10000</mn><mi mathvariant="normal">&amp;</mi><mn>11000</mn><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">(9 + 8 - 1) \&amp; \sim(17 - 1) = 16 \&amp; \sim(7) = 10000 \&amp; \sim(00111) = 10000 \&amp; 11000 = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">&amp;</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line">_S_round_up(<span class="type">size_t</span> __bytes) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (__bytes + (<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="type">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="_s_refillsize_t"   >
          <a href="#_s_refillsize_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_refillsize_t"></a> <code>_S_refill(size_t)</code></h2>
      
<p>调用<code>_S_chunk_alloc(__n, __nobjs)</code>，在内存池块中尽量找一个合适的小字节块。<br />
<code>_S_chunk_alloc</code>内部会帮你处理底层的开辟内存池，处理内存碎片，管理内存池的指示信息等等。<br />
由于<code>_S_chunk_alloc</code>第二个参数<code>__nobjs</code>传入的是引用，有可能<code>__nobjs</code>会被改变。<br />
调用之前，<code>__nobjs</code>是我们想要申请的小字节块的个数。<br />
调用结束后，<code>__nobjs</code>更新为了实际分配到的小字节块的个数。<br />
如果是 1 ，此次分配完之后，这个内存池块正好用完了，不构建freelist下标的链表。<br />
其他情况，构建相应的freelist下标的链表。<br />
for循环中做的是遍历内存池大块中的每个单元小块，联合体<code>_Obj*</code>的<code>_M_free_list_link</code>指向紧挨着的下一个单元小块。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that __n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    </span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="type">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">    </span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">    __result = (_Obj*)__chunk;</span><br><span class="line">    *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);</span><br><span class="line">    <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++)</span><br><span class="line">    &#123;</span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj*)((<span class="type">char</span>*)__next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i)</span><br><span class="line">        &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>图示：<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807041752139.png" alt="" /></p>

        <h2 id="_s_chunk_allocsize_t-int-nobjs"   >
          <a href="#_s_chunk_allocsize_t-int-nobjs" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_chunk_allocsize_t-int-nobjs"></a> <code>_S_chunk_alloc(size_t, int&amp; nobjs)</code></h2>
      
<p>在内存池块中尽量找一个合适的小字节块。<br />
期间，可能会改变外部传入的<code>__nobjs</code>。（因为是引用，外部会受影响）</p>
<p><code>__total_bytes</code>记录的是欲开辟的内存池大小（根据<code>__nobjs</code>，这个是小字节块数）。<br />
<code>__bytes_left</code>指的是<code>_S_end_free - _S_start_free</code>，指目前未被开发的大小。</p>

        <h3 id="__bytes_left还足够返回无需开辟新空间"   >
          <a href="#__bytes_left还足够返回无需开辟新空间" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#__bytes_left还足够返回无需开辟新空间"></a> <code>__bytes_left</code>还足够，返回，无需开辟新空间</h3>
      
<p>如果<code>__bytes_left</code>还足够（至少是 1 个小字节块），则返回<code>_S_start_free</code>。同时移动<code>_S_start_free</code>到新的位置。<br />
成功返回。无需额外操作。</p>
<hr />

        <h3 id="__bytes_left不足开辟新的更大的内存池块"   >
          <a href="#__bytes_left不足开辟新的更大的内存池块" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#__bytes_left不足开辟新的更大的内存池块"></a> <code>__bytes_left</code>不足，开辟新的更大的内存池块</h3>
      
<p>如果<code>__bytes_left</code>不足，则将要开辟新的更大的内存池块。<code>__bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4)</code></p>

        <h4 id="__bytes_left-0头插到合适的一个链表管理这个内存碎片"   >
          <a href="#__bytes_left-0头插到合适的一个链表管理这个内存碎片" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#__bytes_left-0头插到合适的一个链表管理这个内存碎片"></a> <code>__bytes_left &gt; 0</code>，头插到合适的一个链表，管理这个内存碎片</h4>
      
<p>如果<code>__bytes_left &gt; 0</code>。这时，为了不浪费<code>__bytes_left</code>而造成内存碎片，把这部分尚余的小内存给其对应的freelist下标的链头插。比如，剩余 32 字节，则找下标 3 ，<strong>头插</strong>进去。（见下文图示）</p>

        <h4 id="开辟新的大块内存_malloc正常"   >
          <a href="#开辟新的大块内存_malloc正常" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开辟新的大块内存_malloc正常"></a> 开辟新的大块内存_malloc正常</h4>
      
<p>以下是<code>__bytes_left</code>不足时，都需要做的操作，目的是开辟新的大块内存。返回的地址赋给<code>_S_start_free</code>。</p>
<hr />
<p>如果malloc正常（<code>malloc返回 != 0</code>），更新<code>_S_heap_size += __bytes_to_get;</code>，更新<code>_S_end_free = _S_start_free + __bytes_to_get;</code>。</p>
<p>malloc成功，递归调用<code>return(_S_chunk_alloc(__size, __nobjs));</code>。</p>

        <h4 id="开辟新的大块内存_malloc失败找内存池中已开辟的大单元链表的空间"   >
          <a href="#开辟新的大块内存_malloc失败找内存池中已开辟的大单元链表的空间" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开辟新的大块内存_malloc失败找内存池中已开辟的大单元链表的空间"></a> 开辟新的大块内存_malloc失败：找内存池中已开辟的大单元链表的空间</h4>
      
<hr />
<p>如果malloc失败（<code>malloc返回 == 0</code>）。则处理：<br />
遍历freelist的下标各个内存池块。从<code>size_t __n</code>对应的freelist下标，依次往后找有没有还有空闲的。</p>
<p><code>__i</code>初始化为<code>__n</code>，循环，每次<code>__i += (size_t) _ALIGN</code>（即加8）。比如，<code>__n</code>等于 40 字节，我们依次去找40、48、56等等的freelist下标的内存池块，看看有没有能分配出来空间的。</p>
<p>如果有，则<code>_S_start_free</code>指向第一个空闲块。更新<code>_S_end_free = _S_start_free + __i;</code><br />
好了，成功在更大单元的内存池块找到，递归调用<code>return(_S_chunk_alloc(__size, __nobjs));</code>。</p>

        <h4 id="开辟新的大块内存_malloc失败异常处理"   >
          <a href="#开辟新的大块内存_malloc失败异常处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#开辟新的大块内存_malloc失败异常处理"></a> 开辟新的大块内存_malloc失败：异常处理</h4>
      
<hr />
<p>如果以上的for循环找了后面更大单元的内存池块，仍没有可用空间，则是系统内存不足的迹象：<br />
需要调用<code>malloc_alloc::allocate(__bytes_to_get);</code>。<br />
内部最后一次进行普通malloc的挣扎。<br />
如果malloc仍然返回 0 ，则进行异常处理（绑定的回调）。</p>
<hr />
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="type">size_t</span> __size, </span><br><span class="line">                                                            <span class="type">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* __result;</span><br><span class="line">    <span class="type">size_t</span> __total_bytes = __size * __nobjs;</span><br><span class="line">    <span class="type">size_t</span> __bytes_left = _S_end_free - _S_start_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes)</span><br><span class="line">    &#123;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size)</span><br><span class="line">    &#123;</span><br><span class="line">        __nobjs = (<span class="type">int</span>)(__bytes_left / __size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> __bytes_to_get = <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        _S_start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">            _Obj* __p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size; __i &lt;= (<span class="type">size_t</span>) _MAX_BYTES; __i += (<span class="type">size_t</span>) _ALIGN)</span><br><span class="line">            &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p)</span><br><span class="line">                &#123;</span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="type">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            _S_start_free = (<span class="type">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;</span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;</span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="头插小内存碎片图示"   >
          <a href="#头插小内存碎片图示" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#头插小内存碎片图示"></a> 头插小内存碎片，图示</h3>
      
<p><img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807063843813.png" alt="" /></p>

        <h3 id="oom异常处理"   >
          <a href="#oom异常处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#oom异常处理"></a> oom异常处理</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result)</span><br><span class="line">    &#123;</span><br><span class="line">        __result = _S_oom_malloc(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="type">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler)</span><br><span class="line">        &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        (*__my_malloc_handler)();</span><br><span class="line">        </span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (__result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>(__result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="_s_start_free-_s_end_free-_s_heap_size"   >
          <a href="#_s_start_free-_s_end_free-_s_heap_size" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#_s_start_free-_s_end_free-_s_heap_size"></a> <code>_S_start_free</code>、<code>_S_end_free</code>、<code>_S_heap_size</code></h3>
      
<p>这三个变量，只会在<code>_S_chunk_alloc(size_t, int&amp;)</code>函数执行中改变。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> __threads, <span class="type">int</span> __inst&gt;</span><br><span class="line"><span class="type">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></div></figure>

        <h2 id="deallocatevoid-p-size_t"   >
          <a href="#deallocatevoid-p-size_t" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#deallocatevoid-p-size_t"></a> <code>deallocate(void* p, size_t)</code></h2>
      
<p>定义于<code>stl_alloc.h</code></p>
<p>头插归还，看图示。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* __p, <span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (__n &gt; (<span class="type">size_t</span>) _MAX_BYTES)</span><br><span class="line">        &#123;</span><br><span class="line">            malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _Obj* __STL_VOLATILE*  __my_free_list = </span><br><span class="line">                _S_free_list + _S_freelist_index(__n);</span><br><span class="line">            _Obj* __q = (_Obj*)__p;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#           <span class="keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">            <span class="comment">/*REFERENCED*/</span></span><br><span class="line">            _Lock __lock_instance;</span><br><span class="line"><span class="meta">#           <span class="keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">    </span><br><span class="line">            __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = __q;</span><br><span class="line">            <span class="comment">// lock is released here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807073716103.png" alt="" /></p>

        <h2 id="reallocatevoid-p-old_sz-new_sz"   >
          <a href="#reallocatevoid-p-old_sz-new_sz" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#reallocatevoid-p-old_sz-new_sz"></a> <code>reallocate(void* p, old_sz, new_sz)</code></h2>
      
<p>对已开辟的内存池块的扩容、缩容。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">reallocate</span>(<span class="type">void</span>* __p,</span><br><span class="line">                                                    <span class="type">size_t</span> __old_sz,</span><br><span class="line">                                                    <span class="type">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* __result;</span><br><span class="line">    <span class="type">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__old_sz &gt; (<span class="type">size_t</span>)_MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="type">size_t</span>)_MAX_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(__p);</span><br><span class="line">    &#125;</span><br><span class="line">    __result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">    __copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;</span><br><span class="line">    <span class="built_in">memcpy</span>(__result, __p, __copy_sz);</span><br><span class="line">    <span class="built_in">deallocate</span>(__p, __old_sz);</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="sgi-stl内存池总结"   >
          <a href="#sgi-stl内存池总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sgi-stl内存池总结"></a> SGI STL内存池总结</h2>
      
<p>SGI STL 二级空间配置器内存池的实现优点：</p>
<ol>
<li>对于每一个字节数的chunk块分配，都是给出一部分进行使用，另一部分作为备用，这个备用可以给当前字节数使用，也可以给其它字节数使用</li>
<li>对于备用内存池划分完chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块再次分配出去，备用内存池使用的干干净净！防止小块内存频繁的分配，释放，造成内存很多的碎片出来，内存没有更多的连续的大内存块。所以应用对于小块内存的操作，一般都会使用内存池来进行管理。</li>
<li>malloc内存分配失败，还会调用<code>oom_malloc</code>这么一个预先设置好的以后的回调函数，如果没设置，则<code>throw bad_alloc</code>。设置了则<code>for(;;)(*oom_malloc_handler)();</code>。</li>
</ol>

        <h1 id="nginx内存池设计和实现"   >
          <a href="#nginx内存池设计和实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx内存池设计和实现"></a> Nginx内存池设计和实现</h1>
      
<p>区分大小内存块的申请和释放，大于池尺寸的定义为大内存块，使用单独的大内存块链表保存，即时分配和释放；小于等于池尺寸的定义为小内存块，直接从预先分配的内存块中提取，不够就扩充池中的内存，在生命周期内对小块内存不做释放，直到最后统一销毁。</p>

        <h2 id="nginx内存池结构图"   >
          <a href="#nginx内存池结构图" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx内存池结构图"></a> Nginx内存池结构图</h2>
      
<p><img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250719234700476.png" alt="" /></p>

        <h2 id="nginx源码"   >
          <a href="#nginx源码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx源码"></a> Nginx源码</h2>
      
<p>本次分析的是Nginx-release-1.13.1的源码。<br />
src目录下，有好多模块，其中内存池的模块位于<code>/src/core</code>目录下。使用的是C语言。<br />
对于不同的操作系统，有不同的实现，位于<code>/src/os/unix</code>和<code>/src/os/win32</code>下。</p>

        <h2 id="指标"   >
          <a href="#指标" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#指标"></a> 指标</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 ngx_palloc.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * NGX_MAX_ALLOC_FROM_POOL should be (ngx_pagesize - 1), i.e. 4095 on x86.</span></span><br><span class="line"><span class="comment"> * On Windows NT it decreases a number of locked pages in a kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_DEFAULT_POOL_SIZE    (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_MIN_POOL_SIZE                                                     \</span></span><br><span class="line"><span class="meta">    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \</span></span><br><span class="line"><span class="meta">              NGX_POOL_ALIGNMENT)</span></span><br></pre></td></tr></table></div></figure>
<ol>
<li><code>NGX_MAX_ALLOC_FROM_POOL</code>定义了可以从内存池中申请的最大内存。默认是<code>Nginx页面大小减1</code>。x86系统下是<code>4096字节减1</code>。</li>
<li><code>NGX_DEFAULT_POOL_SIZE</code>定义了Nginx内存池默认大小。是<code>16 * 1024B</code> 即 <code>16KB</code>。</li>
<li><code>NGX_POOL_ALIGNMENT</code>，内存池，分配内存时的对齐大小。默认是16。</li>
<li><code>NGX_MIN_POOL_SIZE</code>定义了内存池的最小大小。
<ol>
<li>其需要通过<code>ngx_align</code>计算，定义如下：发现和STL的<code>round_up</code>一样，向上取 d 的整 a 倍数。比如，a等于16、d等于7的话，那d取整后就是16，d等于17的话，取整后就是32。</li>
<li>其中d是<code>(sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t))</code>。a是<code>NGX_POOL_ALIGNMENT</code>，默认是16。</li>
</ol>
</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 ngx_config.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align(d, a)     ( ( (d) + (a - 1) ) &amp; ~(a - 1))</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="关键数据结构"   >
          <a href="#关键数据结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关键数据结构"></a> 关键数据结构</h2>
      
<p>定义于<code>ngx_palloc.h</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typdef strcut</span><br><span class="line">&#123;</span><br><span class="line">    u_char        *last;       <span class="comment">// 当前数据块中内存分配指针的当前位置</span></span><br><span class="line">    u_char        *end;        <span class="comment">// 内存块的结束位置</span></span><br><span class="line">    <span class="type">ngx_pool_t</span>    *next;       <span class="comment">// 内存池由多块内存块组成，指向下一个数据块的位置</span></span><br><span class="line">    <span class="type">ngx_uint_t</span>    failed;      <span class="comment">// 当前数据块内存不足引起分配失败的次数</span></span><br><span class="line">&#125; <span class="type">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">ngx_pool_data_t</span>    d;        <span class="comment">// 上面那个结构体：内存池当前的数据区指针的结构体</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span>             max;      <span class="comment">// max 指的是 Nginx 一次分配小块内存大小 的最大值。</span></span><br><span class="line">    <span class="type">ngx_pool_t</span>         *current; <span class="comment">// 当前正在使用的数据块的指针</span></span><br><span class="line">    <span class="type">ngx_chain_t</span>        *chain;   <span class="comment">// 把内存池链接起来</span></span><br><span class="line">    <span class="type">ngx_pool_large_t</span>   *large;   <span class="comment">// 指向大数据块的指针（大数据块是指size &gt; max的数据）</span></span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span> *cleanup; <span class="comment">// 类似于析构函数，在 内存free 之前，对内存上的数据进行处理，比如释放指针对应的外部资源</span></span><br><span class="line">    <span class="type">ngx_log_t</span>          *<span class="built_in">log</span>;     </span><br><span class="line">&#125;; <span class="comment">// in ngx_core.h: typedef struct ngx_pool_s ngx_pool_t;</span></span><br></pre></td></tr></table></div></figure>
<p>在<code>ngx_core.h</code>中，</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> <span class="title">ngx_pool_t</span>;</span></span><br></pre></td></tr></table></div></figure>
<p>即<code>npx_pool_t</code>是<code>struct ngx_pool_s</code>的别名。</p>
<p>在Nginx内存池中，<code>npx_pool_t</code>这个结构只出现在第一个内存池块的头部上，后续链接的内存池块头部只有<code>ngx_pool_data_t</code>。</p>
<p><code>struct ngx_pool_s</code>（别名<code>ngx_pool_t</code>）结构示意图（大小为1024的池）<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250719235439957.png" alt="" /></p>

        <h2 id="npx_create_pool创建内存池"   >
          <a href="#npx_create_pool创建内存池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#npx_create_pool创建内存池"></a> <code>npx_create_pool</code>创建内存池</h2>
      
<p>声明于<code>ngx_palloc.h</code>，定义于<code>ngx_palloc.c</code>。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_pool_t</span> * <span class="title function_">ngx_create_pool</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br></pre></td></tr></table></div></figure>
<p>返回<code>npx_pool_t *</code>。</p>
<p>开辟指定大小的内存池。根据不同系统、不同的对齐方法，调用不同的API。<br />
一般是普通的malloc。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_pool_t</span> * <span class="title function_">ngx_create_pool</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    <span class="comment">// 如果不用内存对齐，则实际就是普通的 malloc</span></span><br><span class="line">    <span class="comment">// 如果需要内存对齐，则调用posix_memalign(void ** p, size_t alignment, size_t size)</span></span><br><span class="line">    <span class="comment">// 或 memalign(size_t alignment, size_t size)</span></span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个内存池大块，指向这个新开辟的内存池大块的头信息之后。</span></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    <span class="comment">// 内存池的结束位置，整个大块的尾部。</span></span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size 更新为 除去头信息大小的 实际存储数据的大小</span></span><br><span class="line">    size = size - <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">    <span class="comment">// 若 size 小于 MAX_ALLOC，则 max为size，size 大于 MAX_ALLOC 则 max 为 MAX_ALLOC</span></span><br><span class="line">    <span class="comment">// max 指的是 Nginx 一次分配小块内存大小 的最大值。如果用户申请大于max，则按大块数据块处理。</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line">    <span class="comment">// 指向自己，首地址（包含头信息）</span></span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="ngx_memalignpool_alignment-size-log或ngx_allocsize-log"   >
          <a href="#ngx_memalignpool_alignment-size-log或ngx_allocsize-log" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_memalignpool_alignment-size-log或ngx_allocsize-log"></a> <code>ngx_memalign(POOL_ALIGNMENT, size, log)</code>或<code>ngx_alloc(size, log)</code></h3>
      
<p>这是个宏定义，定义于<code>/src/os/unix</code>和<code>/src/os/win32</code>下的<code>ngx_alloc.h</code>。</p>
<p>在Unix下，有对齐的区别：如果要做内存对齐，则<code>size_t alignment</code>参数生效，否则忽略对齐参数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ngx_memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>
<p>在Win32下，没有对齐限制。<code>#define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)</code></p>
<p>名字上，暂时一样。但是相应的<code>ngx_alloc(size, log)</code>函数，在两个操作系统上就是不同的实现了。<br />
我们看Unix的：实际就是套了个<strong>普通malloc</strong>。然后输出了一些日志信息。<br />
定义于<code>/src/os/unix/ngx_alloc.c</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="从创建好的内存池中申请内存"   >
          <a href="#从创建好的内存池中申请内存" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#从创建好的内存池中申请内存"></a> 从创建好的内存池中申请内存</h2>
      
<p>定义于<code>ngx_palloc.c</code><br />
3个接口：<code>ngx_palloc</code>、<code>ngx_pnalloc</code>、<code>ngx_pcalloc</code></p>
<ol>
<li><code>ngx_palloc</code>和<code>ngx_pnalloc</code>的区别在于在申请<strong>小块内存</strong>时，<strong>前者考虑对齐</strong>，后者不考虑对齐</li>
<li><code>ngx_pcalloc</code>是调用<code>ngx_palloc</code>，之后的额外操作是<strong>清零申请的区域</strong>。</li>
</ol>

        <h3 id="ngx_pallocpool-size"   >
          <a href="#ngx_pallocpool-size" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_pallocpool-size"></a> <code>ngx_palloc(pool, size)</code></h3>
      
<p>如果用户申请小于等于pool头信息中max大小的内存，则按小块管理。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_palloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。</span></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_pnalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。</span></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ngx_pcalloc</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    p = ngx_palloc(pool, size);</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_memzero(p, size);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="ngx_palloc_smallpool-size-align"   >
          <a href="#ngx_palloc_smallpool-size-align" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_palloc_smallpool-size-align"></a> <code>ngx_palloc_small(pool, size, align)</code></h3>
      
<p>第3个参数是标志位，1表示考虑对齐，0表示不考虑对齐。</p>
<p>找current，即从该内存池大块之中分配内存。</p>
<p><code>ngx_align_ptr</code>，将<code>p-&gt;d.last</code>指向的可用数据地址按<code>NGX_ALIGNMENT</code>对齐到指定数（默认是32）的倍数，比如如果地址是8，则舍弃一部分内存，对齐到32。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ngx_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">ngx_palloc_small</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size, <span class="type">ngx_uint_t</span> align)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p;</span><br><span class="line">    <span class="comment">// 从 pool 头信息找到当前可用的内存池大块</span></span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 当前数据块中可分配的内存的开始位置</span></span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align)</span><br><span class="line">        &#123;</span><br><span class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// end 是当前数据块中可分配的内存的结束位置，与开始位置相减，如果大于等于用户申请的大小</span></span><br><span class="line">        <span class="comment">// 则 直接返回 m ，即开始位置，把 last 位置 下移 size，表示分配了 size 大小</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>) (p-&gt;d.end - m) &gt;= size)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 目前的数据块 大小 不够 size，则遍历找下一个数据块。</span></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line">    <span class="comment">// 直到所有数据块都不够用，则</span></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_block(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="ngx_align_ptrp-a内存对齐"   >
          <a href="#ngx_align_ptrp-a内存对齐" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_align_ptrp-a内存对齐"></a> <code>ngx_align_ptr(p, a)</code>内存对齐</h4>
      
<p>定义于<code>ngx_config.h</code></p>
<p>如果没有定义<code>NGX_ALIGNMENT</code>，则默认是<code>sizeof(unsigned long)</code>，按照32位对齐。这是内存单元对齐。</p>
<blockquote>
<p>注意要和<code>ngx_palloc.h</code>中定义的<code>#define NGX_POOL_ALIGNMENT 16</code>区分。那是内存池对齐。</p>
</blockquote>
<p>即向定义的对齐大小（32）向上取整32倍。</p>
<p>操作是：传入的指针地址，加上指针大小32（4字节，32位）减1，和32减1取反后，相与。<br />
比如：传入的指针地址是8：<code>0000 1000</code>（前面补0），则加32减1：<code>0010 1000</code><br />
<code>0010 0000 - 1 = 0001 1111</code>取反<code>1110 0000</code>（前面补1）。<code>0010 1000</code>和<code>1110 0000</code>相与后：<code>0010 0000</code>，由原先的8，对齐到了32。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NGX_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_ALIGNMENT   sizeof(unsigned long)    <span class="comment">/* platform word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line"><span class="meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_palloc_blockpool-size再开辟一大块内存池"   >
          <a href="#ngx_palloc_blockpool-size再开辟一大块内存池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_palloc_blockpool-size再开辟一大块内存池"></a> <code>ngx_palloc_block(pool, size)</code>再开辟一大块内存池</h2>
      
<p>从pool的头块找到<code>end - pool</code>的大小，这是内存池每一个大块的大小（包含头信息的大小）</p>
<p>这是为了<strong>再开辟一大块内存池</strong>做准备。</p>
<p><code>ngx_memalign</code>和第一次创建内存池一样，如果没有对齐要求，则普通malloc。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">ngx_palloc_block</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="type">size_t</span>       psize;</span><br><span class="line">    <span class="type">ngx_pool_t</span>  *p, *new;</span><br><span class="line">    <span class="comment">// 一整个内存池大块（包含头信息）的大小。</span></span><br><span class="line">    psize = (<span class="type">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"></span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new = (<span class="type">ngx_pool_t</span> *) m;</span><br><span class="line">    <span class="comment">// psize是整个内存池块的大小。m是开始，则end指向这个新开辟的内存池块的末尾</span></span><br><span class="line">    new-&gt;d.end = m + psize;</span><br><span class="line">    <span class="comment">// next暂时指向NULL。</span></span><br><span class="line">    new-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    new-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放普通内存池块的头信息</span></span><br><span class="line">    m += <span class="keyword">sizeof</span>(<span class="type">ngx_pool_data_t</span>);</span><br><span class="line">    <span class="comment">// 内存对齐 m ，存储实际数据的开始地址</span></span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="comment">// 分配出去 size 大小的内存，last（下一个空闲内存的开始地址）更新到新位置</span></span><br><span class="line">    new-&gt;d.last = m + size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从整个内存池的current到后续一长串，给每一个内存池块的failed计数加1。</span></span><br><span class="line">    <span class="comment">// 如果发现当前这个内存池块的failed是4，则current指向这个failed次数过多内存池块的下一个内存池块。 </span></span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出for 循环后，p 更新到了 最后一个内存池块。同时，当前pool的current指向的是第一个failed不为4的内存池块</span></span><br><span class="line">    <span class="comment">// 尾插。链接起来新开辟的这个内存池块。</span></span><br><span class="line">    p-&gt;d.next = new;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_palloc_largepool-size大块内存分配管理"   >
          <a href="#ngx_palloc_largepool-size大块内存分配管理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_palloc_largepool-size大块内存分配管理"></a> <code>ngx_palloc_large(pool, size)</code>大块内存分配管理</h2>
      
<p>用户申请比<code>pool-&gt;max</code>大的内存时，按大块内存分配管理。<br />
用<code>ngx_alloc</code>分配size大小的内存（和分配内存池块的方法一样）见<a href="#%60ngx_memalign(POOL_ALIGNMENT,%20size,%20log)%60%E6%88%96%60ngx_alloc(size,%20log)%60"><code>ngx_memalign(POOL_ALIGNMENT, size, log)</code>或<code>ngx_alloc(size, log)</code></a>。<br />
遍历找large链的前5个，看是否有large的alloc为空的，直接让alloc指向一开始malloc得到的p。<br />
如果连续找了5个，发现large的alloc都不为空，则跳出循环，不再找了。<br />
这个for循环是为了快速在前5个large中，找到一个之前开辟的，但已经空闲了的大内存块头信息，其alloc管理的大内存块已经释放了，所以为NULL，直接让alloc指向一开始malloc得到的p即可。</p>
<p>如果没有进入循环，说明large一开始就是空的，内存池没有申请过大块内存；或者是找了5个发现large的alloc都不空：执行下面的操作（头插大内存块的头信息到pool的large链）：</p>
<p>记录大内存块（large管理）的 头信息<code>ngx_pool_large_t</code>，是按照<code>ngx_palloc_small</code>方法，存放到了内存池块的小块内存中。<br />
<code>ngx_palloc_small</code>返回空说明系统内存不够用了，失败，释放一开始malloc得到的大块内存，返回NULL。</p>
<p>如果正常，则在这个大块内存头信息填写：<br />
<code>alloc</code>，即这个大块内存的地址，为一开始malloc得到的地址。<br />
<code>next</code>，指向pool的large链头，pool的large指向这个新大块内存的头信息。相当于头插！只不过插的是大内存块的头信息。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">ngx_palloc_large</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>              *p;</span><br><span class="line">    <span class="type">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *large;</span><br><span class="line"></span><br><span class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录 大块 内存（large管理）的 头信息，存放到内存池块管理的小块内存中。</span></span><br><span class="line">    <span class="comment">// 返回空说明 系统 内存不够用了，失败。</span></span><br><span class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>图示：<br />
<img src="../../images/SGI%20STL%E5%92%8CNginx%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/image-20250807115333694.png" alt="" /></p>
<p>如图，大块内存的头信息，是按小块内存管理，分配到了内存池块中。</p>
<p>下面要提到的外部资源所绑定的清理的头信息，也像是大块内存头信息一样，按小块内存管理，分配到了内存池块中。</p>

        <h2 id="ngx_pool_cleanup_add分配一个需要管理外部资源的数据比如指针-fd"   >
          <a href="#ngx_pool_cleanup_add分配一个需要管理外部资源的数据比如指针-fd" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_pool_cleanup_add分配一个需要管理外部资源的数据比如指针-fd"></a> <code>ngx_pool_cleanup_add</code>分配一个需要管理外部资源的数据（比如指针、fd）</h2>
      
<p>按小块内存分配<code>ngx_pool_cleanup_t</code>，这是清理的头信息块。<br />
有：handler、data、next。</p>
<p>之后才是分配size。</p>
<p>之后，像头插大内存块的头信息链表一样，头插清理类的头信息链表。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_pool_cleanup_t</span> * <span class="title function_">ngx_pool_cleanup_add</span><span class="params">(<span class="type">ngx_pool_t</span> *p, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    c = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="type">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size)</span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="通过返回的ngx_pool_cleanup_t-绑定清理回调函数"   >
          <a href="#通过返回的ngx_pool_cleanup_t-绑定清理回调函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通过返回的ngx_pool_cleanup_t-绑定清理回调函数"></a> 通过返回的<code>ngx_pool_cleanup_t *</code>绑定清理回调函数</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">pData</span> =</span> ngx_alloc(<span class="number">512</span>);</span><br><span class="line">pData-&gt;p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(pData-&gt;p, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_release</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ngx_pool_cleanup_t</span> *pclean = ngx_pool_cleanup_add(pool, <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">pclean-&gt;handler = &amp;my_release;</span><br><span class="line">pclean-&gt;data = pData-&gt;p;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_pfreepool-void-p大块内存释放"   >
          <a href="#ngx_pfreepool-void-p大块内存释放" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_pfreepool-void-p大块内存释放"></a> <code>ngx_pfree(pool, void *p)</code>大块内存释放</h2>
      
<p>用于释放大块内存。先free，后把large头信息中的alloc置空。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_pfree</span><span class="params">(<span class="type">ngx_pool_t</span> *pool, <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line"></span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="小块内存释放无"   >
          <a href="#小块内存释放无" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#小块内存释放无"></a> 小块内存释放：无</h2>
      
<p>Nginx的小块内存一旦分配了之后，就无法精确地回收。</p>
<p>不像SGI STL一样，假设A、B、C三个小内存单元相邻，A、C空闲，A是freelist的第一个空闲块，A的next是C。现在释放B，则B头插到freelist，现在是B连着A连着C。这样可以精确地释放，并下次还能重新分配（可以发现，由于是头插到了freelist的第一个空闲区域，所以最后释放的最先分配）。</p>
<p>Nginx呢，每个内存池块只是由<code>last</code>和<code>end</code>两个指针管理，只能指示当前内存池块的未分配的部分。</p>
<p>当已分配的部分中，有 1 个小块内存要释放，无法精确管理。所以Nginx只能连续地释放一整段空间，与last相连。</p>

        <h2 id="ngx_reset_poolpool"   >
          <a href="#ngx_reset_poolpool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_reset_poolpool"></a> <code>ngx_reset_pool(pool)</code></h2>
      
<p>遍历large链表，释放每个大块内存。最后large置空。<br />
遍历每个内存池块，把last拉到头信息的末尾即可，相当于释放了内存池的数据。最后current置为pool。<br />
注意，只是释放了大块内存，所有内存池块都没有free，只是更新了last。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_reset_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == pool) <span class="comment">// 第一个内存池，有pool头信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;d.last = (u_char*)p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>           <span class="comment">// 其余的内存池，只有小头信息，没有pool大头</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="type">ngx_pool_data_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ngx_destroy_poolpool"   >
          <a href="#ngx_destroy_poolpool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ngx_destroy_poolpool"></a> <code>ngx_destroy_pool(pool)</code></h2>
      
<ol>
<li>遍历“清理”链表，每个都按照绑定的handler释放其data外部资源。</li>
<li>遍历large链表，释放每个大块内存。</li>
<li>遍历每个内存池块，释放每个内存池块。</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_destroy_pool</span><span class="params">(<span class="type">ngx_pool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="type">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="type">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="nginx和stl释放内存的策略适用的场景"   >
          <a href="#nginx和stl释放内存的策略适用的场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#nginx和stl释放内存的策略适用的场景"></a> Nginx和STL释放内存的策略适用的场景</h1>
      
<p>Nginx大块内存分配=》内存释放ngx_free函数<br />
Nginx小块内存分配=》没有提供任何的内存释放函数。</p>
<p>实际上，从小块内存的分配方式来看（直接通过last指针偏移来分配内存），根本没法进行中间部分的小块内存的回收。</p>
<p>Nginx本质：HTTP服务器是一个短链接的服务器，客户端（浏览器）发起一个request请求，到达Nginx服务器以后，处理完成，Nginx给客户端返回一个response响应，HTTP服务器就主动断开tcp连接。<br />
假设HTTP 1.1 keep-alive：60s，HTTP服务器（nginx）返回响应以后，需要等待60s，60s之内客户端又发来请求，重置这个时间；<br />
否则60s之内没有客户端发来的响应，Nginx也是最终会主动断开连接，此时Nginx可以调用ngx_reset_pool重置内存池了，等待下一次客户端的请求。</p>
<p>因此，Nginx内存池的设计适用于间歇性、短连接的服务。虽然有内存泄漏，但效率高，空间换时间。</p>
<p>如果是长连接，且小块内存分配、释放较多，最好用STL二级空间配置器，避免内存泄漏过多。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%A1%B9%E7%9B%AE/%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0_future%E5%8E%9F%E7%90%86/">设计并实现线程池_future原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-03</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0_future%E5%8E%9F%E7%90%86/" data-flag-title="设计并实现线程池_future原理"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="知识储备"   >
          <a href="#知识储备" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#知识储备"></a> 知识储备</h1>
      

        <h2 id="并发和并行"   >
          <a href="#并发和并行" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#并发和并行"></a> 并发和并行</h2>
      
<ul>
<li>并发</li>
</ul>
<p>单核上，CPU时间片轮转，多个线程轮流执行。物理上是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），宏观上看就像是多个线程在共同执行，这样的场景称作并发(concurrent)。</p>
<ul>
<li>并行</li>
</ul>
<p>在多核或者多CPU上，多个线程在同一时刻执行，这样的场景才是真正的并行(parallel)。</p>

        <h2 id="两种密集型程序"   >
          <a href="#两种密集型程序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#两种密集型程序"></a> 两种密集型程序</h2>
      
<p>多线程程序一定好吗？不一定，要看具体的应用场景。</p>
<ul>
<li>IO密集型：程序里面指令的执行，涉及IO操作较多，比如设备、文件、网络操作（等待客户端的连接），可能会把程序阻塞。如果CPU时间片再分配给这种线程，相当于浪费了CPU资源。</li>
<li>CPU密集型：程序里面的指令都是做计算用的，不会阻塞。</li>
</ul>
<hr />
<ul>
<li>多核情况下
<ol>
<li>IO密集型和CPU密集型虽然对并行计算有不同的需求，IO密集型更适合设计成多线程程序。但是在多核情况下两种密集型程序都是有必要用多线程来处理的。</li>
<li>线程进行调度时，内核中有这样两个队列：runnable，就绪的或正在调度的队列。如果因IO操作有线程阻塞了，则将会进入阻塞队列，blocking queue。</li>
</ol>
</li>
<li>单核情况下
<ol>
<li>IO密集型的程序依然适合设计为多线程程序。</li>
<li>CPU密集型程序不再适合！这就相当于只有一个计算器，却让多个人分段算。线程的调度有额外的花费：线程的上下文切换。CPU寄存器信息会保存在线程栈上，下次还要再恢复到CPU中，实属麻烦。</li>
</ol>
</li>
</ul>

        <h2 id="线程的代价"   >
          <a href="#线程的代价" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程的代价"></a> 线程的代价</h2>
      
<p>为了完成任务，创建很多线程可以吗？线程越多越好吗？</p>
<ul>
<li>线程的创建和销毁都是非常“重”的操作，需要进入内核态。在执行任务的过程中，没有集中资源去干正事，而是去花费很大力度创建/销毁？
<ul>
<li>需要给线程创建<code>PCB(task_struct)</code>、线程的内核栈、页目录、页表</li>
<li>描述地址空间相应的数据结构：<code>vm_area_struct</code></li>
<li>内核创建完后，还要返回用户态</li>
<li>线程执行完业务，还要销毁线程，又要切换一次</li>
</ul>
</li>
<li>线程栈本身占用大量内存，每一个线程都需要线程栈，栈几乎都被占用完了，还怎么做事情？
<ul>
<li>32位地址空间，共4G，用户空间有3G。</li>
<li>线程共享进程的地址空间。</li>
<li>可在linux下执行<code>ulimt -a</code>命令观察stack size默认栈大小，为8192字节即8M。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>∗</mo><mn>1024</mn><mi>M</mi><mo>=</mo><mn>3072</mn><mi>M</mi><mo separator="true">,</mo><mn>3072</mn><mi>M</mi><mi mathvariant="normal">/</mi><mn>8</mn><mi>M</mi><mo>=</mo><mn>384</mn></mrow><annotation encoding="application/x-tex">3*1024M=3072M, 3072M/8M=384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">7</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">7</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord">4</span></span></span></span>个。这说明32位环境下，最多创建384个线程。</li>
</ul>
</li>
<li>线程的上下文切换要占用大量时间
<ul>
<li>线程过多，线程的调度是需要进行上下文切换的，上下文切换花费CPU时间也特别多，CPU的利用率就不高了。</li>
</ul>
</li>
<li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机
<ul>
<li>如果在某一时刻，大量的IO操作准备好了，那么一时间线程是来不及处理的。</li>
</ul>
</li>
</ul>

        <h1 id="线程同步"   >
          <a href="#线程同步" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h1>
      

        <h2 id="线程互斥"   >
          <a href="#线程互斥" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程互斥"></a> 线程互斥</h2>
      
<p>某段代码能不能多线程环境下执行？看这段代码是否存在<strong>竞态条件</strong>，即有无临界区代码段。（代码片段在多线程环境下执行，随着线程的调度顺序不同而得到不同的执行结果）。如果有，则要通过线程同步来保证它的原子操作。</p>
<p>如果在多线程环境下不存在竞态条件，则称之为<strong>可重入的</strong>。</p>

        <h3 id="互斥锁"   >
          <a href="#互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h3>
      
<ul>
<li>lock</li>
<li><code>try_lock</code></li>
<li><code>lock_guard</code></li>
<li><code>unique_lock</code></li>
</ul>

        <h3 id="atomic原子类型"   >
          <a href="#atomic原子类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic原子类型"></a> atomic原子类型</h3>
      
<ul>
<li>CAS操作（无锁机制）
<ul>
<li>无锁队列、无锁链表、无锁数组</li>
<li>实际上使用的是轻量级、效率高的锁，不是没用锁。</li>
</ul>
</li>
</ul>

        <h2 id="线程通信"   >
          <a href="#线程通信" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h2>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88792621" >GDB调试C++11多线程死锁</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="条件变量"   >
          <a href="#条件变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h3>
      

        <h3 id="信号量"   >
          <a href="#信号量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
      
<p>看作资源计数没有限制的mutex互斥锁。mutex互斥锁的资源计数只能是0或者1。</p>

        <h3 id="区别"   >
          <a href="#区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
      
<ul>
<li>二元信号量和互斥锁的区别
<ul>
<li>mutex只能是哪个线程获取锁，由哪个线程释放锁。</li>
<li><code>sem.wait()</code>和<code>sem.post()</code>则可以处在不同的线程中调用。</li>
</ul>
</li>
</ul>

        <h1 id="线程池"   >
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h1>
      
<p>线程池的优势：</p>
<p>服务进程启动之初，事先创建好线程池里面的线程，当业务到来需要分配线程时直接从线程池中获取一个空闲线程执行task任务即可，task执行完成之后把线程归还到线程池中继续给后续task提供服务，而不用释放线程。</p>

        <h2 id="项目介绍"   >
          <a href="#项目介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#项目介绍"></a> 项目介绍</h2>
      
<p>本项目所实现的线程池和对象池、内存池、STL库的意义一样，只能称作一个库，而不能作为一个独立运行的中间件，必须镶嵌在应用程序中。最终项目表现形式为一种提供给他人的<strong>动态库</strong>，比如用到了<code>mysql.h</code>头文件，<code>libmysqlclient.so</code>动态库。动态库需要编译出来。</p>

        <h3 id="使用方式"   >
          <a href="#使用方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h3>
      
<ul>
<li>启动线程池</li>
</ul>
<p>如果你想在应用程序中或者代码中使用本项目的线程池，你可以</p>
<ol>
<li>直接<code>ThreadPool pool;</code>定义一个<code>pool</code>对象；</li>
<li>而后则可以调用<code>pool.sexMode(fixed(default) | cached);</code>接口设置线程池的运行模式，默认为固定模式。</li>
<li>然后<code>pool.start();</code>启动线程池。start不会阻塞。</li>
</ol>
<p>启动线程池意味着线程池开始创建若干线程，就绪，等待任务过来执行任务。</p>
<ul>
<li>提交任务</li>
</ul>
<p>调用方只要按以下形式调用API即可：<code>Result result = pool.submitTask(concreteTask);</code></p>
<p>调用方无需关心内部操作，包括线程分配、执行过程。</p>
<p>有时调用方需要获取任务执行的结果，可用<code>T res = result.get().Cast&lt;T&gt;();</code>获得任务结果。任务结果的返回值是任意类型，具体类型T由用户指出。（此处用到了C++17中的Any类型）</p>

        <h1 id="线程池的设计"   >
          <a href="#线程池的设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池的设计"></a> 线程池的设计</h1>
      

        <h2 id="类成员"   >
          <a href="#类成员" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类成员"></a> 类成员</h2>
      
<p>首先说一说抽象出的类：线程池类、线程池中的线程类。</p>
<ol>
<li>既然是线程池，就要有一个<strong>存放线程的容器</strong>
<ol>
<li>我们最好能实时监控线程池中线程的数量、以及上限阈值，避免线程数量走向极端从而影响性能（线程数量不是越多越好，坏处：1、线程栈空间冗余；2、上下文切换过程时间多于执行操作）</li>
</ol>
</li>
<li>还要有一个存放待完成任务的容器，即<strong>任务队列</strong>
<ol>
<li>考不考虑线程安全问题？必须考虑，外层用户提交任务要放数据，下层线程执行任务要取数据。</li>
<li>任务不能堆积过多。对于任务队列，也要有一个上限阈值。</li>
</ol>
</li>
</ol>

        <h2 id="通用化的实现-task设计-继承多态思想"   >
          <a href="#通用化的实现-task设计-继承多态思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通用化的实现-task设计-继承多态思想"></a> 通用化的实现 - Task设计 - 继承多态思想</h2>
      
<p>任务类型需要达到通用性，所以要用到继承、多态的思想。用基类指针可以指向各种各样的派生类对象。</p>
<p>所以需要<strong>设计一个抽象类Task。内部提供一个纯虚函数<code>virtual void run() = 0</code></strong>。如果要设计特定的任务，则继承（实现）之，重写run函数即可。</p>

        <h2 id="线程通信的保证-mtxcv"   >
          <a href="#线程通信的保证-mtxcv" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程通信的保证-mtxcv"></a> 线程通信的保证 - mtx+cv</h2>
      
<p>因为涉及到放任务、取任务，所以很明显是个生产者消费者模型。</p>
<p>必然<strong>用到互斥锁+条件变量，从而对任务队列进行互斥保护</strong>、达到正确的线程通信。</p>

        <h2 id="线程池的模式"   >
          <a href="#线程池的模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池的模式"></a> 线程池的模式</h2>
      
<ul>
<li>fixed模式
<ul>
<li>线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。</li>
</ul>
</li>
<li>cached模式
<ul>
<li>线程池里面的线程个数是可动态增长的，根据任务的数量动态地增加线程的数量，但是会设置一个线程数量的阈值。任务处理完成后，如果动态增长的线程空闲60s而没有其他任务待处理，那么就关闭线程，保持池中线程的最初数量。</li>
</ul>
</li>
</ul>

        <h3 id="代码形式"   >
          <a href="#代码形式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码形式"></a> 代码形式</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">setMode</span>(<span class="built_in">fixed</span>(<span class="keyword">default</span>) | cached);</span><br><span class="line">    pool.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="提交任务api"   >
          <a href="#提交任务api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#提交任务api"></a> 提交任务API</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result result = pool.<span class="built_in">submitTask</span>(concreteTask);</span><br><span class="line">result.<span class="built_in">get</span>().<span class="built_in">Cast</span>&lt;T&gt;();</span><br></pre></td></tr></table></div></figure>

        <h1 id="线程池类threadpool"   >
          <a href="#线程池类threadpool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池类threadpool"></a> 线程池类（ThreadPool）</h1>
      
<p>线程池，不光要管理线程，而且要集成一个任务队列。要对外提供提交任务的接口。</p>
<p>其中的线程去取任务，做，然后返回任务结果。（这是线程类里的事情）</p>
<p>管理的线程，用 vector 管理。<br />
管理的任务，用 queue 管理。任务队列要保证线程安全。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">PoolMode</span></span><br><span class="line">&#123;</span><br><span class="line">    MODE_FIXED,     <span class="comment">// 固定数量的线程</span></span><br><span class="line">    MODE_CACHED,    <span class="comment">// 线程数量可动态增长</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">/* 设置线程池的工作模式 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span></span>;</span><br><span class="line">    <span class="comment">/* 设置初始的线程数量 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInitThreadSize</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">/* 设置task队列任务数量最大阈值 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshHold)</span></span>;</span><br><span class="line">    <span class="comment">/* 启动线程池 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PoolMode m_poolMode;                <span class="comment">//当前线程池工作模式</span></span><br><span class="line">    std::vector&lt;Thread*&gt; m_threads;     <span class="comment">//线程列表</span></span><br><span class="line">    <span class="type">int</span> m_initThreadSize;               <span class="comment">//初始的线程数量</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列容器。</span></span><br><span class="line"><span class="comment">     * 特别要注意，需要用 shared_ptr 强引用用户传来的 task ，</span></span><br><span class="line"><span class="comment">     * 以保证任务对象的生命期。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Task&gt;&gt; m_taskQueue;</span><br><span class="line">    <span class="comment">/* 目前任务队列中的任务数量 */</span></span><br><span class="line">    std::atomic_int m_taskNum;</span><br><span class="line">    <span class="comment">/* 任务队列最大上限阈值 */</span></span><br><span class="line">    <span class="type">int</span> m_taskQueMaxThreshHold;</span><br><span class="line">    <span class="comment">/* 保护安全地操作任务队列 */</span></span><br><span class="line">    std::mutex m_taskQueMtx;</span><br><span class="line">    <span class="comment">/* 表示任务队列不满 */</span></span><br><span class="line">    std::condition_variable m_taskQueNotFull;</span><br><span class="line">    <span class="comment">/* 表示任务队列不空 */</span></span><br><span class="line">    std::condition_variable m_taskQueNotEmpty;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="threadpool构造-析构"   >
          <a href="#threadpool构造-析构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadpool构造-析构"></a> ThreadPool构造、析构</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线程池构造 */</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">   : <span class="built_in">m_initThreadSize</span>(<span class="number">4</span>),</span><br><span class="line">     <span class="built_in">m_taskNum</span>(<span class="number">0</span>),</span><br><span class="line">     <span class="built_in">m_taskQueMaxThreshHold</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">     <span class="built_in">m_poolMode</span>(PoolMode::MODE_FIXED)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="设置参数"   >
          <a href="#设置参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#设置参数"></a> 设置参数</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置线程池的工作模式 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_poolMode = mode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置初始的线程数量 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setInitThreadSize</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_initThreadSize = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置task队列任务数量最大阈值 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshHold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_taskQueMaxThreshHold = threshHold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="启动线程池"   >
          <a href="#启动线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#启动线程池"></a> 启动线程池</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 启动线程池 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h2 id="给线程池提交任务"   >
          <a href="#给线程池提交任务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#给线程池提交任务"></a> 给线程池提交任务</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h1 id="thread类"   >
          <a href="#thread类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread类"></a> Thread类</h1>
      

        <h2 id="线程函数定义在哪个位置呢"   >
          <a href="#线程函数定义在哪个位置呢" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程函数定义在哪个位置呢"></a> 线程函数定义在哪个位置呢？</h2>
      
<ul>
<li>思考：线程函数定义在哪个位置呢？
<ul>
<li>如果写在Thread类中，那么定义在 ThreadPool 的变量则不容易被函数所访问。</li>
<li>定义为全局函数呢？线程池里的变量都是私有的，也不易访问。</li>
<li>结论：OOP的手法，写在ThreadPool中。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.h */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* 定义线程函数 */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="怎么把线程函数扔给thread对象"   >
          <a href="#怎么把线程函数扔给thread对象" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#怎么把线程函数扔给thread对象"></a> 怎么把线程函数扔给Thread对象</h2>
      
<ul>
<li>线程对象是在线程池里构建的，线程启动执行也是在线程池里做的，</li>
<li>那么创建 thread 线程对象时需要把线程函数给到 thread 线程对象。怎么把函数扔给对象？怎么解决这个技术问题？
<ul>
<li>引入<code>&lt;functional&gt;</code>，用<code>std::bind()</code>把函数对象绑定。在线程池 start 时，构造 thread 时传入</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_initThreadSize = initThreadSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads.<span class="built_in">emplace_back</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="头文件"   >
          <a href="#头文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h2>
      
<p>由上述 Thread 类构造时对函数对象的处理，可以得到 Thread 类的大致属性需求、构造参数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 线程函数对象类型别名 */</span></span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Thread</span>(ThreadFunc func);</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadFunc m_func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="start-函数创建线程后分离线程"   >
          <a href="#start-函数创建线程后分离线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#start-函数创建线程后分离线程"></a> start 函数（创建线程后，分离线程）</h2>
      
<ul>
<li>start 函数 - 启动线程，创建一个线程来执行一个线程函数
<ul>
<li>需要注意：出了start函数作用域之后线程对象会析构，但是线程函数不能消失，他还要去消费任务队列上的任务。<strong>所以线程对象需要设置为分离线程，否则程序会挂掉</strong>。</li>
<li>分离的效果就是：<strong>线程对象</strong>和它所<strong>启动的线程（实质的线程</strong>）分离开了。独立存在，互不关心对方的生命期。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">/* 启动线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(m_func)</span></span>;	<span class="comment">//线程对象t，线程函数m_func</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="简单测试"   >
          <a href="#简单测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简单测试"></a> 简单测试</h1>
      
<ul>
<li>简单测试，默认启动 4 个线程。启动后在不同的线程分别执行 threadFunc 函数。
<ul>
<li>注意：创建的线程分离之后，执行完毕后会自动回收。但是可能存在主线程启动后看不到打印结果的情况，那是因为主线程结束地太快，导致没能看到（实际中的服务器主线程不会很快结束，而是保持）。为了看到执行结果，可以睡眠一段时间。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid:&quot;</span> </span><br><span class="line">      &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;end threadFunc&quot;</span> </span><br><span class="line">      &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 线程池项目测试.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="智能指针解决避免手动释放"   >
          <a href="#智能指针解决避免手动释放" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#智能指针解决避免手动释放"></a> 智能指针解决避免手动释放</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_initThreadSize = initThreadSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">        m_threads.<span class="built_in">emplace_back</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>但是这样会出现编译不过的问题，为什么呢？因为报错发现<code>unique_ptr</code>的拷贝构造已经删除，这是唯一性智能指针的语义决定的。而移动构造没有删除，意味可以用右值进行资源转移，所以我们需要在<code>ptr</code>前加<code>std::move</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_threads.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br></pre></td></tr></table></div></figure>

        <h1 id="submittask"   >
          <a href="#submittask" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#submittask"></a> submitTask</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 获取锁 */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_taskQueMtx)</span></span>;</span><br><span class="line">    <span class="comment">/* 线程的通信，等待任务队列有空余 */</span></span><br><span class="line">    <span class="comment">//while(taskQue_.size() == taskQueMaxThreshHold_)&#123; notFull_.wait(); &#125;</span></span><br><span class="line">    m_taskQueNotFull.<span class="built_in">wait</span>(</span><br><span class="line">        lock,</span><br><span class="line">        [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_taskQueue.<span class="built_in">size</span>() &lt; m_taskQueMaxThreshHold;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* 如果有空余，把任务放到任务队列中 */</span></span><br><span class="line">	m_taskQueue.<span class="built_in">emplace</span>(sp);</span><br><span class="line">    ++m_taskNum;</span><br><span class="line">    <span class="comment">/* 因为新放了任务，任务队列肯定不空了，通知notEmpty_上的等待线程 */</span></span><br><span class="line">    m_taskQueNotEmpty.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="服务降级wait_fortime"   >
          <a href="#服务降级wait_fortime" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务降级wait_fortime"></a> 服务降级（<code>wait_for(time)</code>）</h2>
      
<p>为了性能更加优化，我们限制用户提交任务的最长阻塞时间是<code>1s</code>，如果提交任务超过了 1s 说明目前线程池的任务队列压力比较大，防止短时间内积压很多任务，则规定为提交任务失败，返回。称为<strong>服务降级</strong>。</p>
<p>需要用到<code>wait</code>的两个延伸，<code>wait_for(time)</code>，<code>wait_until(endtime)</code>。返回值为bool值，<code>false</code>表示到时间后条件依然没满足。</p>
<p>以下说的是：如果等了超过 1 秒，说明满的状态已经超过了 1 秒，<code>wait_for</code>返回 <code>false</code> ，<code>if</code> 条件成立，提交失败。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!m_taskQueNotFull.<span class="built_in">wait_for</span>(</span><br><span class="line">    lock,</span><br><span class="line">    std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">    [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; (<span class="type">size_t</span>)taskQueMaxThreshHold_;</span><br><span class="line">    &#125;))</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr&lt;&lt;<span class="string">&quot;task queue is full, submit out of time failed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="threadfunc"   >
          <a href="#threadfunc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadfunc"></a> ThreadFunc</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">    <span class="comment">/* 块作用域 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 先获取锁 */</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_taskQueMtx)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">/* 等待notEmpty条件 */</span></span><br><span class="line">        m_taskQueNotEmpty.<span class="built_in">wait</span>(</span><br><span class="line">            lock,</span><br><span class="line">            [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m_taskQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">/* 从任务队列中取一个任务出来 */</span></span><br><span class="line">        task = m_taskQueue.<span class="built_in">front</span>();</span><br><span class="line">        m_taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">        --m_taskNum;</span><br><span class="line">        <span class="comment">/* 如果有剩余任务，继续通知其他线程来取任务 */</span></span><br><span class="line">        <span class="keyword">if</span> (m_taskQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_taskQueNotEmpty.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 取出了一个任务，任务队列此时肯定不满了，对等待提交任务的人进行通知 */</span></span><br><span class="line">        m_taskQueNotFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当前线程负责执行这个任务, 没必要拥有锁, 脱离块作用域, 释放锁 */</span></span><br><span class="line">    <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)</span><br><span class="line">        task-&gt;<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="测试1"   >
          <a href="#测试1" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试1"></a> 测试1</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">test example:</span><br><span class="line"><span class="comment">/* 以下为提交3个任务，预估结果为3个线程获取任务成功，1个没有获取到，一直阻塞 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">	pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 若4个线程，提交5个任务，则最先完成并抢到锁的线程能再次获得第5个任务 */</span></span><br><span class="line"><span class="comment">/* 若4个线程，提交10个任务，并把队列容量设为4，则可能有2个任务提交失败 */</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="线程执行的返回值future和packaged_task的实现原理"   >
          <a href="#线程执行的返回值future和packaged_task的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程执行的返回值future和packaged_task的实现原理"></a> 线程执行的返回值（future和packaged_task的实现原理）</h1>
      
<p>比如，计算1到30000的和。线程1计算1到10000，2计算10001到20000，3计算20001到30000。<br />
主线程给每一个线程分配计算的区间，并等待他们算完之后返回结果，合并最终的结果即可。<br />
但是，怎么能拿到线程的返回值呢？</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">    	: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin_; i &lt;= end_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>问题1：怎么设计run函数的返回值，可以表示任意的类型？</li>
<li>问题2：如何设计这里的Result机制？</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>, <span class="number">10000</span>));</span><br><span class="line">Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">10001</span>, <span class="number">20000</span>));</span><br><span class="line">Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">20001</span>, <span class="number">30000</span>));</span><br><span class="line">res<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">res<span class="number">2.</span><span class="built_in">get</span>();</span><br><span class="line">res<span class="number">3.</span><span class="built_in">get</span>();</span><br></pre></td></tr></table></div></figure>

        <h2 id="any类型-按需返回具体类型"   >
          <a href="#any类型-按需返回具体类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#any类型-按需返回具体类型"></a> Any类型 - 按需返回具体类型</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Any</span>(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Any</span>(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这个构造函数可以让 Any 类型接收任意其他的数据 */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T data)</span> : base_(std::make_unique&lt;Derived&lt;T&gt;&gt;(data))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="comment">/* 这个方法能把 Any 对象里面存储的 data 数据提取出来 */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">cast_</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// base_ 是定义在 Any 类中的一个 std::unique_ptr&lt;Base&gt;</span></span><br><span class="line">        <span class="comment">// get() 可以获得 其实际指针</span></span><br><span class="line">        Derive&lt;T&gt;* pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;*&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span>(pd == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;type is unmatch!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;data_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>(T data) : <span class="built_in">data_</span>(data)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 实际的 data 存在 Derived 类中。</span></span><br><span class="line">        T data_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义一个基类的指针 */</span></span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    Result res = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>, <span class="number">10000</span>));</span><br><span class="line">    <span class="type">int</span> sum = res.<span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如此一来：<br />
res调用get，等待 task 执行完毕，<code>get()</code>就能返回一个<code>Any</code>。这个 <code>Any</code> 的模板参数指明了里面存放的数据是 <code>int</code> 型， <code>Any</code> 对象调用其 <code>cast_</code>， 取出了里面存放的数据。（通过<code>dynamic_cast&lt;Derive&lt;int&gt;*&gt;</code>）如果类型不匹配，则抛出异常。</p>

        <h2 id="自实现信号量类"   >
          <a href="#自实现信号量类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自实现信号量类"></a> 自实现信号量类</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="type">int</span> limit = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">resLimit_</span>(limit)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Semaphore</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/* 获取一个信号量资源 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="comment">/* 等待信号量有资源，没有资源的话，阻塞当前线程 */</span></span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> resLimit_ &gt; <span class="number">0</span>;&#125;);</span><br><span class="line">        --resLimit_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 增加一个信号量资源 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        ++resLimit_;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 信号量目前拥有的资源数</span></span><br><span class="line">    <span class="type">int</span> resLimit_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="result设计"   >
          <a href="#result设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#result设计"></a> （⭐）Result设计</h2>
      
<p>先分析一下局势：</p>
<ol>
<li>Task里面肯定有结果</li>
<li>外部有一个Result要接收结果</li>
<li>Task里面的结果怎么巧妙地转移到Result上面？</li>
<li>其实Task不用专门有一个Any成员变量保存。</li>
<li>可以直接在Task中保存一个Result指针。</li>
<li>外部Result也绑定一个Task作为成员对象。<strong>为了让Task延长生命期，Result需要用<code>shared_ptr&lt;Task&gt;</code>构造</strong>。</li>
<li><code>Result</code>构造函数中，只需要执行：<code>task_-&gt;setResult(this);</code>，便可以移花接木，把Task成员变量<code>result_</code>指向外部的Result。</li>
<li>这样，Task内部，run完之后，返回了Any，Task便可以主动调用<code>result_-&gt;setVal(run())</code>。把结果写回外部的Result内部。</li>
</ol>
<p>submitTask接口返回类型需要让用户能接收到线程任务的返回值，并且要求可以是任意类型，所以改为Result。相应的，我们需要设计这样的Result类型。</p>
<ul>
<li>思考，return时用下面哪种方式？
<ul>
<li><code>task-&gt;getResult();</code>还是<code>Result(task);</code>？</li>
<li>要执行的task从队列中<code>taskQue_.pop()</code>，接着调用完毕后Task就会析构（注意，submitTask传入的是shared_ptr，引用计数减1，如果此时没有其他人引用该Task，将会析构，里面的any存储的结果就失效了），即task生命期现在只存在于<code>threadFunc</code>函数中。</li>
<li>如果是<code>task-&gt;getResult();</code>
<ul>
<li>若task中的Result是以值形式存的，则肯定不行，因为task析构之后，Result也会析构。</li>
<li>若task中的Result是以指针形式存的，则必须指定到一个外部资源保存。比如存到堆上。
<ul>
<li>如果是在堆上保存，还必须提供一个getResult接口，返回Result的指针，即<code>result_</code>成员变量。这样，可以做到把Result安全地保存下来。</li>
</ul>
</li>
</ul>
</li>
<li>但是，可以以更为巧妙的方式！<code>Result(task);</code>
<ul>
<li>Result绑定了这个task（用shared智能指针管理，让task对象的生命期延至和Result对等），在Result的构造函数中，调用<code>task-&gt;setResult(this);</code>！！！居然巧妙地把“外部资源地址”指向了外部待接收结果的Result自己！避免了堆上建立的烦恼。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Result <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span>;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;;</span><br><span class="line">--------------------------</span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">	<span class="keyword">if</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/*		思考，return时用下面哪种方式？	*/</span></span><br><span class="line"><span class="comment">/*      return task-&gt;getResult();	 */</span></span><br><span class="line">        <span class="comment">// 此时是提交任务失败的返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Result</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*	思考，return时用下面哪种方式？	*/</span></span><br><span class="line"><span class="comment">/*  return task-&gt;getResult();	 */</span></span><br><span class="line">    <span class="comment">// 此时是提交任务成功后的返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>经过上面的讨论，Result类成员里需要绑定一个Task对象。即下面的<code>task_</code>。下面是Result成员和其构造。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实现接收提交到线程池的task任务执行完成后的返回值类型Result */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid = <span class="literal">true</span>);</span><br><span class="line">    ~<span class="built_in">Result</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 存储任务的返回值 */</span></span><br><span class="line">    Any any_;</span><br><span class="line">    <span class="comment">/* 线程通信信号量 */</span></span><br><span class="line">    Semaphore sem_;</span><br><span class="line">    <span class="comment">/* 指向对应获取返回值的任务对象 */</span></span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;</span><br><span class="line">    <span class="comment">/* 任务执行是否有效/成功 */</span></span><br><span class="line">    std::atomic_bool isValid_;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line"><span class="comment">//threadpool.cpp</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid)</span><br><span class="line">    : <span class="built_in">isValid_</span>(isValid), <span class="built_in">task_</span>(task)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数"   >
          <a href="#成员函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h3>
      
<ul>
<li>问题1：setVal函数，获取任务执行完的返回值，记录在any成员。</li>
<li>问题2：get函数，用户调用这个方法获取task的返回值（没执行完需要阻塞）</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVal</span><span class="params">(Any any)</span></span>;</span><br><span class="line">    <span class="function">Any <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Any any_;</span><br><span class="line">    Semaphore sem_;</span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;</span><br><span class="line">    std::atomic_bool isValid_;</span><br><span class="line">&#125;;</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">/* 	用户调用的 */</span></span><br><span class="line"><span class="function">Any <span class="title">Result::get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isValid_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 阻塞用户的线程直到task通知其执行完毕 */</span></span><br><span class="line">    sem_.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(any_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 谁调用？答案是 Task 的 run 结束之后，通过Result * result_ 间接调用次函数，通知 get() 唤醒拿结果 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Result::setVal</span><span class="params">(Any any)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 存储task的返回值 */</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;any_ = std::<span class="built_in">move</span>(any);</span><br><span class="line">    sem_.<span class="built_in">post</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="task增加方法把结果写入result"   >
          <a href="#task增加方法把结果写入result" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#task增加方法把结果写入result"></a> Task增加方法，把结果写入Result</h2>
      
<p>思想：在threadFun函数中，不仅要靠task对象Task类中的run方法执行具体哪种任务，还要把任务的返回值给到result，可以用exec来封装，exec没有多态，run有多态。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task::exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result_ != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// run()结束之后，setVal才能被调用成功，此时影响到了 result_ 中保存的信号量 +1，因此 外部的result.get()不再阻塞</span></span><br><span class="line">	    result_-&gt;<span class="built_in">setVal</span>(<span class="built_in">run</span>());	<span class="comment">//如此可知，task中需要封装一个result对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>();</span><br><span class="line">    ~<span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setResult</span><span class="params">(Result *res)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*	没必要用shared智能指针，否则就会出现：Result中有shared_ptr&lt;Task&gt;，Task中有shared_ptr&lt;Result&gt;。循环引用，无法释放！*/</span></span><br><span class="line">    Result *result_;	<span class="comment">//result对象的生命周期长于task，不怕。</span></span><br><span class="line">&#125;;</span><br><span class="line">----------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task::setResult</span><span class="params">(Result *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result_ = res;</span><br><span class="line">&#125;</span><br><span class="line">Task::<span class="built_in">Task</span>()</span><br><span class="line">    : <span class="built_in">result_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;       </span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">/* 谁调用setResult？此 Result 不是 Result 里的 val ， 而是保存 Val 的一个地方，不要搞混了 */</span></span><br><span class="line"><span class="comment">// 外部可以通过 task 来 指定 Result 要保存到哪个地方。</span></span><br><span class="line"><span class="comment">// 比如可以传入 外部 Result 的 this 指针；也可以 new 一个 Result 在 堆上，set 到堆上地址</span></span><br><span class="line"><span class="comment">// 如果 Result 绑定了一个 task 就可以 通过这个 task 设置 Result 为 自己（this）</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid)</span><br><span class="line">	: <span class="built_in">isValid_</span>(isValid), <span class="built_in">task_</span>(task)</span><br><span class="line">&#123;</span><br><span class="line">    task_-&gt;<span class="built_in">setResult</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试2master-slave模型"   >
          <a href="#测试2master-slave模型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试2master-slave模型"></a> 测试2（Master - Slave模型）</h2>
      
<p>Master - Slave模型，Master线程用来分解任务，然后给各个Slave线程分配任务，等待各个Slave线程执行完任务，返回结果。最后Master线程合并各个任务结果，输出。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">    	: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function">Any <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        uLong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uLong i = begin_; i &lt;= end_; ++i)</span><br><span class="line">            sum += i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> uLong = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>, <span class="number">100000000</span>));</span><br><span class="line">    Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">100000001</span>, <span class="number">200000000</span>));</span><br><span class="line">    Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>, <span class="number">300000000</span>));</span><br><span class="line">    uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    uLong sum2 = res<span class="number">2.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    uLong sum3 = res<span class="number">3.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    cout &lt;&lt; sum1 + sum2 + sum3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试结果：</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407095057418.png" alt="image-20220407095057418" /></p>

        <h1 id="cached模式线程池"   >
          <a href="#cached模式线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cached模式线程池"></a> cached模式线程池</h1>
      
<p>主要的使用点：submitTask函数中，可能需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程。</p>
<ul>
<li>需要处理的问题
<ul>
<li>问题1，用户自己如何设置线程池的工作模式</li>
<li>问题2，submitTask函数中，根据任务数量和空闲线程的数量，判断是否需要创建新的线程</li>
<li>问题3，threadFunc函数中，有可能已经创建了很多的线程，如果空闲时间超过60s，需要结束、回收。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    <span class="comment">/* 用户自己设置线程池的工作模式 */</span></span><br><span class="line">    pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">    <span class="comment">/* 开始启动线程池 */</span></span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="切换工作模式"   >
          <a href="#切换工作模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#切换工作模式"></a> 切换工作模式</h2>
      
<p>为了防止用户在线程池启动后再去切换线程池的工作模式，我们需要给线程池添加一个状态变量，以控制用户能否对线程池的工作模式进行切换。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 检查pool的运行状态 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 表示当前线程池的启动 */</span></span><br><span class="line">    std::atomic_bool isPoolRunning_;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 设置线程池的状态为运行态 */</span></span><br><span class="line">    isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ThreadPool::checkRunningState</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isPoolRunning_;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkRunningState</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    poolMode_ = mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="创建更多线程"   >
          <a href="#创建更多线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#创建更多线程"></a> 创建更多线程</h2>
      
<p>cached模式：任务处理比较紧急，场景是小而快的任务。</p>
<p>ThreadPool需要添加记录一个空闲线程数量的变量。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录空闲线程的数量 */</span></span><br><span class="line">    std::atomic_int idleThreadSize_;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 空闲线程数量需要加1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 每启动一个线程就给idleThreadSize_加1，表示多了一个空闲线程 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 空闲线程数量需要减1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*			...			*/</span></span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            notEmpty_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> taskQue_.<span class="built_in">size</span>()&gt;<span class="number">0</span>;&#125;);</span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*			...			*/</span></span><br><span class="line">    	notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task != <span class="literal">nullptr</span>) task -&gt; <span class="built_in">exec</span>();</span><br><span class="line">    ++idleThreadSize_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>现在来增加 submitTask 函数对 cached 模式处理的细节。<br />
有一点要注意，就是尽管任务非常多，但是我们要对线程的数量设一定的上限值。<br />
即需要给 ThreadPool 类增加一个线程数量阈值变量。</p>
<p>然后为了比较线程池当前线程的数量状况，也要添加一个记录线程总数量的变量。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 设置线程池cached模式下的线程阈值 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span></span>;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 线程数量上限阈值 */</span></span><br><span class="line">    <span class="type">int</span> threadSizeThreshHold_;</span><br><span class="line">    <span class="comment">/* 记录当前线程池里面线程的总数量 */</span></span><br><span class="line">    std::atomic_int curThreadSize_;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;;</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">curThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">threadSizeThreshHold_</span>(THREAD_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 记录初始线程个数 */</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line">    <span class="comment">/* 创建线程对象 */</span></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 启动所有线程 */</span></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkRunningState</span>() || poolMode_==PoolMode::MODE_FIXED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    threadSizeThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="comment">/* 关注三个状态：</span></span><br><span class="line"><span class="comment"> * 1.线程池的工作模式是否是cached；</span></span><br><span class="line"><span class="comment"> * 2.任务数量是否已经大于空闲线程数量；</span></span><br><span class="line"><span class="comment"> * 3.线程总数量是否没有超过线程数量上限；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建新线程 */</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>));</span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();	<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="任务处理完毕回收多余线程"   >
          <a href="#任务处理完毕回收多余线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#任务处理完毕回收多余线程"></a> 任务处理完毕，回收多余线程</h2>
      
<p>超过<code>initThreadSize_</code>数量的线程要进行回收。</p>
<p><strong>当前时间 比 上一次线程执行完毕的时间</strong> 大于 60s 后回收。</p>
<blockquote>
<p><code>C++11</code>中提供了高精度时间API - <code>std::chrono::high_resolution_clock().now()</code>;</p>
</blockquote>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_IDLE_TIME = <span class="number">60</span>;	<span class="comment">//单位s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 上一次线程执行完任务的时间 */</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">    	Task task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line">            <span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line">            <span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line">            <span class="comment">// 锁 + 双重判断</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line">                <span class="keyword">if</span> (!isPoolRunning_)</span><br><span class="line">                &#123;</span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                        &lt;&lt; std::endl;</span><br><span class="line">                    exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//while(taskQue_.size() &gt; 0) // 不再去判断 taskQue_.size() &gt; 0，即使size是0，也一直等待60s</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* 超时 1s 返回 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">//返回的是time_point类型</span></span><br><span class="line">                        <span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line">                        <span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 开始回收当前线程 */</span></span><br><span class="line">                            <span class="comment">/* 修改记录线程数量的相关变量 */</span></span><br><span class="line">                            <span class="comment">/* 把线程从线程列表容器中删除 */</span></span><br><span class="line">                            <span class="comment">/* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */</span></span><br><span class="line">                            <span class="comment">/* 我们需要有一个映射关系来记录：threadid =&gt; thread对象 =&gt; 删除 */</span></span><br><span class="line">                            thread_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                            --curThreadSize_;</span><br><span class="line">                            --idleThreadSize_;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                                &lt;&lt; std::endl;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//&#125; // while(taskQue_.size() &gt; 0) 结束</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// poolMode_ != PoolMode::MODE_CACHED</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock <span class="comment">/* , [&amp;]()-&gt;bool &#123; return taskQue_.size() &gt; 0; &#125; */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end while (taskQueue_.size() == 0)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 taskQueue_.size() != 0 而 我们又拿到了 任务队列的锁，可以直接取走任务</span></span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">            taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125; <span class="comment">// end std::unique_lock&lt;std::mutex&gt; lock(taskQueMtx_);</span></span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        <span class="comment">/* 线程执行完任务后更新lastTime */</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="问题怎么知道线程函数对应的是线程列表容器中的哪一个线程对象"   >
          <a href="#问题怎么知道线程函数对应的是线程列表容器中的哪一个线程对象" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题怎么知道线程函数对应的是线程列表容器中的哪一个线程对象"></a> 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象？</h2>
      
<p>我们需要有一个映射关系来记录：<code>threadid - thread对象</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;</span><br></pre></td></tr></table></div></figure>
<p>所以，Thread对象需要封装一个id值。<br />
然后，在线程函数<code>threadFunc</code>传入<code>int threadid</code>参数。<br />
这样，该 id 的Thread在线程函数中计时自己的空闲时间，若连续 wait 了 60s（每wait一次1s超时返回），说明任务过少，空闲线程过多。<br />
只有知道了 id 号，才能让 ThreadPool 记录的 线程map 精确地删除。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Thread</span>(ThreadFunc func);</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 启动线程 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">    <span class="comment">// 这是属于 Thread类 共享的计数器。表示曾经已生成了多少个线程对象</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> generateId;</span><br><span class="line">    <span class="comment">// 当前Thread 对象的ID</span></span><br><span class="line">    <span class="type">int</span> threadId_;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="type">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">	: <span class="built_in">func_</span>(func), <span class="built_in">threadId</span>(++generateId_)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread::getId</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadId_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后，最大的变化来了，把原先的线程列表的vector容器变成了unordered_map。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_; <span class="comment">// 线程列表</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>因此，在 start 启动线程池的操作中，生成线程的动作就要有所变化</p>
<p>要预留一个占位符<code>_1</code>，这是给线程函数的传入参数的位置，<code>threadid</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启线程池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize = std::thread::hardware_concurrency())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始线程个数</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建thread线程对象的时候，把线程函数给到thread线程对象</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        <span class="comment">// threads_.emplace_back(std::move(ptr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动所有线程  std::vector&lt;Thread*&gt; threads_;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>(); <span class="comment">// 需要去执行一个线程函数</span></span><br><span class="line">        idleThreadSize_++;    <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="改为无序哈希表存储id-thread对象映射关系后的代码调整"   >
          <a href="#改为无序哈希表存储id-thread对象映射关系后的代码调整" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#改为无序哈希表存储id-thread对象映射关系后的代码调整"></a> 改为无序哈希表存储id、Thread对象映射关系，后的代码调整</h2>
      

        <h3 id="submittask-2"   >
          <a href="#submittask-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#submittask-2"></a> submitTask</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thead&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="threadpool的threadfuncint-threadid接口添加int参数"   >
          <a href="#threadpool的threadfuncint-threadid接口添加int参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadpool的threadfuncint-threadid接口添加int参数"></a> ThreadPool的<code>threadFunc(int threadid)</code>接口添加int参数</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义线程函数，加了一个参数threadid */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="thread中using-threadfunc的stdfunctionvoidint"   >
          <a href="#thread中using-threadfunc的stdfunctionvoidint" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread中using-threadfunc的stdfunctionvoidint"></a> Thread中<code>using ThreadFunc</code>的<code>std::function&lt;void(int)&gt;</code></h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 要和threadFunc函数参数一致 */</span></span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="thread的start多传入一个threadid_"   >
          <a href="#thread的start多传入一个threadid_" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread的start多传入一个threadid_"></a> Thread的start，多传入一个<code>threadId_</code></h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_, threadId_)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试3"   >
          <a href="#测试3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试3"></a> 测试3</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">		: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Any <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">        uLong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uLong i = begin_; i &lt;= end_; ++i)</span><br><span class="line">            sum += i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 在submitTask函数中 加打印线程的相关信息 */</span></span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thead&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,</span><br><span class="line">                      <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();	<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 暂时修改超时时间，方便测试观察 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_IDLE_TIME = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">                    	<span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 默认初始四线程，六任务。</span></span><br><span class="line"><span class="comment"> * 每个任务都至少消耗3秒，</span></span><br><span class="line"><span class="comment"> * 开始时会把四个线程都占住，会创建新的线程来完成后两个任务</span></span><br><span class="line"><span class="comment"> * 全部任务完成后，超过10秒后，会把多余的2个线程回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TASK_MAX_THRESHHOLD = INT32_MAX;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadPool pool;</span><br><span class="line">        pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">        Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>,<span class="number">100000000</span>));			<span class="comment">//1</span></span><br><span class="line">        Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">100000001</span>,<span class="number">200000000</span>));	<span class="comment">//2</span></span><br><span class="line">        Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));	<span class="comment">//3</span></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//5</span></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//6</span></span><br><span class="line">        uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">        uLong sum2 = res<span class="number">2.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">        uLong sum3 = res<span class="number">3.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试结果</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172417250.png" alt="image-20220407172417250" /></p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172451064.png" alt="image-20220407172451064" /></p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172642102.png" alt="image-20220407172642102" /></p>

        <h2 id="问题threadpool对象析构以后怎么样把线程池相关的线程资源全部回收"   >
          <a href="#问题threadpool对象析构以后怎么样把线程池相关的线程资源全部回收" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题threadpool对象析构以后怎么样把线程池相关的线程资源全部回收"></a> 问题：ThreadPool对象析构以后，怎么样把线程池相关的线程资源全部回收</h2>
      
<p>在析构函数中，用户线程需要等待线程池线程，这是两类不同的线程，需要通过线程间通信来达到等待完成。</p>
<p>线程间通信可以用信号量、条件变量，都可以，我们在ThreadPool类中使用一个条件变量<code>exitCond_</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 等待线程资源全部回收 */</span></span><br><span class="line">    std::condition_variable exitCond_;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在析构函数中，</p>
<ol>
<li>置<code>isPoolRunning_</code>为false，如此线程函数进去之后发现线程池要关闭了，
<ol>
<li>如果任务队列为0，则就直接退出。</li>
<li>如果任务队列不为0则取任务。</li>
</ol>
</li>
<li><code>notEmpty_.notify_all();</code>，最后一波唤醒，让所有线程醒来，看有没有任务，没任务就收工。</li>
<li>ThreadPool关注<code>exitCond_</code>，若有人通知了，则说明是线程陆陆续续在退出了，直到<code>threads_.size() == 0</code>，说明所有线程都退出了。这时候，线程池就可以放心析构了。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">/* 等待线程池中所有的线程返回，有两种状态：阻塞/执行中 */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="项目推进时遇到了什么问题"   >
          <a href="#项目推进时遇到了什么问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#项目推进时遇到了什么问题"></a> 项目推进时遇到了什么问题？</h1>
      
<ol>
<li>实现核心功能时的问题：如何通用地获取提交任务后的返回值，即Any，Result的设计。</li>
<li>设计线程池资源回收的，是以…的方式实现的，测试时，有时会出现死锁的现象</li>
</ol>

        <h2 id="调试方法"   >
          <a href="#调试方法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调试方法"></a> 调试方法</h2>
      
<p>gdb调试，attach到正在死锁的进程，把线程栈打印出来，在哪一个函数的哪一句话不动了。</p>
<p>问题要素：<br />
1、线程池要结束，要释放整个池子的资源了。<br />
2、线程池的成员<code>isPoolRunning_</code>状态置为了<code>false</code>。</p>
<p>以上两个要素</p>
<p>1，不受线程池内的线程目前的状态而影响，线程的状态：在等待任务、在执行任务。<br />
2，<code>isPoolRunning_</code>必将影响线程的代码路径。</p>
<p><code>isPoolRunning_</code>在线程池<code>start</code>时置为<code>true</code>。</p>
<p>我们设计的ThreadPool不用考虑成员的析构问题，最主要的两个成员容器：<br />
1、无序map中的线程对象是<code>unique_ptr</code>管理的。<br />
2、queue中的任务队列是<code>shared_ptr</code>管理的。<br />
3、其余的变量都是非指针变量。</p>
<p>ThreadPool析构时仅仅只是把<code>isPoolRunning_</code>置<code>false</code>就可以了吗？<br />
当然不可以。线程池要等待线程池里面所有的线程返回。<br />
目前线程可能在<code>threadFunc</code>函数中阻塞在<code>notEmpty</code>上，另一种是正在执行任务中。</p>
<p>此时就需要不同线程的通信。即用户线程和线程池中的线程之间进行通信。<br />
用信号量、条件变量都可以。<br />
我们用条件变量。<br />
在ThreadPool中定义一个成员，<code>std::condition_variable exitCond_;</code> 等待线程资源全部回收</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* 我们暂且在这个位置 唤醒notEmpty_上的所有线程 */</span>	<span class="comment">//实际上，是留了一个坑</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="comment">/* 表明：要等待到threads_.size()等于0 */</span></span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能会产生死锁的情况：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>,<span class="number">10000000</span>));</span><br><span class="line">    uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    cout &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main over!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment"> * tid: 9624尝试获取任务..</span></span><br><span class="line"><span class="comment"> * tid: 9624获取任务成功...</span></span><br><span class="line"><span class="comment"> * tid:tid: 1664尝试获取任务...</span></span><br><span class="line"><span class="comment"> * 9624begin!</span></span><br><span class="line"><span class="comment"> * tid: 15228尝试获取任务...</span></span><br><span class="line"><span class="comment"> * tid:6796尝试获取任务...</span></span><br><span class="line"><span class="comment"> * tid:9624end!</span></span><br><span class="line"><span class="comment"> * tid:9624尝试获取任务...5000000050000000</span></span><br><span class="line"><span class="comment"> * main over!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * threadid:6796 exit!</span></span><br><span class="line"><span class="comment"> * threadid:s1664 exit!</span></span><br><span class="line"><span class="comment"> * threadid:15228 exit!</span></span><br><span class="line"><span class="comment"> *		//发现，抢到任务的线程回不来了。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="代码分析"   >
          <a href="#代码分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main函数所在的主线程，即用户创建线程池的线程 */</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 线程池中的每个线程的线程函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lastTime = ...;</span><br><span class="line">    <span class="keyword">while</span>(isPoolRunning_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;		<span class="comment">//抢锁动作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务... &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">while</span>(taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* timeout==wait_for的返回值 意味着等待超时了 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//回收长时间空闲的线程</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 否则，说明被唤醒了，有任务了，且抢到锁了，继续往下 */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/* 若不是cached模式，则按部就班老实等待 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">if</span>(!isPoolRunning_)</span><br><span class="line">            &#123;</span><br><span class="line">                threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                    &lt;&lt; <span class="string">&quot; exit:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">/* 每一个线程删除后，都通知exitCond_一下，唤醒用户主线程 */</span></span><br><span class="line">                exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 若被唤醒了，有任务了，且抢到锁了，而且确认了isPoolRunning，则可以取得任务 */</span></span><br><span class="line">        --idleThreadSize_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>第一种情况：线程是固定模式，任务队列空时，等待在<code>notEmpty_</code>上。这种情况我们不怕，因为线程池析构函数已经写了<code>notEmpty_.notify_all()</code>;</p>
<p>第二种情况：<code>task-&gt;exec()</code>中，即线程执行任务中。这种也没事，线程执行完任务再次进入while循环判断时发现<code>isPoolRunning_为false</code>了，则删除线程，退出。</p>
<p>第三种情况才是关键，线程<code>task-&gt;exec()</code> 执行完后进入了<code>while (isPoolRunning_)</code>循环，到了获取锁语句之前的位置。这时，线程池关闭了，也就是说在Running状态切换为<code>false</code>！现在，线程池、子线程的下一个动作都是对<code>taskQueMtx_</code>进行加锁！而最关键的，<strong>如果能够“阴差阳错地”进入第二个<code>while</code>循环，那么就会在<code>notEmpty_</code>上等死</strong>，因为此时线程池在语义上是已经关闭了，没人再去唤醒它。</p>
<p>第三种情况中的第一种情况：线程池抢到锁，又在<code>exitCond_</code>上<code>wait</code>阻塞，而子线程虽然能抢到锁，但是会死在<code>notEmpty_</code>上。</p>
<p>第三种情况中的第二种情况：子线程抢到锁，往下执行，则没有任务时，在<code>notEmpty_</code>上等待会放弃锁，阻塞自己，线程池之后会抢到锁，等待线程结束。<strong>这时没有人去唤醒notEmpty_上的子线程了。死锁。这是问题之关键</strong>。</p>
<p>那么，第三种情况怎么解决死锁问题呢？</p>
<p>我们注意到，第三种情况中第一种情况的问题是因为线程池<code>exitCond_.wait()</code>后，进入了第一个<code>while</code>后争抢<code>lock</code>的线程可能拿到锁后，顺理成章进入第二个<code>while</code>中，若恰逢没有任务，则死在了<code>notEmpty_</code>上。所以为了防止错误的时机进入到第二个<code>while</code>循环中，在条件处首先再判断一次<code>isPoolRunning_</code>。</p>

        <h3 id="31的解决方案锁双重判断"   >
          <a href="#31的解决方案锁双重判断" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#31的解决方案锁双重判断"></a> 3.1的解决方案：锁+双重判断</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lastTime = ...;</span><br><span class="line">    <span class="keyword">while</span>(isPoolRunning_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; ... &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">while</span>(isPoolRunning_ &amp;&amp; taskQue_.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//退出while的两种情况：1.!Running, 2.Running &amp;&amp; taskQue_.size()!=0</span></span><br><span class="line">            <span class="keyword">if</span>(!isPoolRunning_)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取任务成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        lastTime = ...;</span><br><span class="line">    &#125;</span><br><span class="line">    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如此一来，线程池先抢到锁，再在<code>exitCond_</code>上<code>wait</code>阻塞释放锁后，子线程得到锁向下走到了第二个while语句，由于再次判断<code>isPoolRunning_</code>，这时发现改变为<code>false</code>了，就不会走到<code>notEmpty_.wait()</code>了。灰溜溜去做删除动作了。</p>

        <h3 id="32的解决方案调整加锁位置"   >
          <a href="#32的解决方案调整加锁位置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#32的解决方案调整加锁位置"></a> 3.2的解决方案：调整加锁位置</h3>
      
<p>虽然3.1解决了<code>isPoolRunning</code>状态脏读这个漏洞问题，但是依旧不能解决“子线程先抢到锁”从而在<code>notEmpty_</code>上等待这种情况发生。即使子线程释放了锁，但是没有人再去唤醒<code>notEmpty_</code>，因为原来的语序是先唤醒，再抢锁。所以我们要让用户线程的加锁、唤醒放在子线程wait之后，<strong>要让子线程wait释放了锁之后，才让用户线程唤醒<code>notEmpty_</code></strong>！于是：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>调换了一下第二、第三句，即子线程先抢到锁后wait在<code>notEmpty_</code>上后释放锁，用户线程再抢到锁之后才去<code>notify_all()</code>它，那么阻塞的子线程被唤醒了，往下执行，发现<code>isPoolRunning_</code>变为<code>false</code>了，灰溜溜去做删除动作了。完美解决问题。</p>

        <h1 id="编译为动态库"   >
          <a href="#编译为动态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#编译为动态库"></a> 编译为动态库</h1>
      

        <h2 id="直接在命令行使用g编译"   >
          <a href="#直接在命令行使用g编译" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#直接在命令行使用g编译"></a> 直接在命令行使用<code>g++</code>编译</h2>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o libxcg-threadpool.so -fPIC -shared [源文件如: threadpool.cpp] -std=c++17</span><br></pre></td></tr></table></div></figure>

        <h2 id="用cmake构建编译"   >
          <a href="#用cmake构建编译" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#用cmake构建编译"></a> 用cmake构建编译</h2>
      

        <h3 id="根目录"   >
          <a href="#根目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#根目录"></a> 根目录</h3>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(xcg-threadpool)</span><br><span class="line"><span class="comment">#配置编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -g)</span><br><span class="line"><span class="comment">#配置最终的库文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#配置头文件的搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#加载子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></div></figure>

        <h3 id="src目录"   >
          <a href="#src目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#src目录"></a> src目录</h3>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义了SRC_LIST变量，包含了该目录下所有的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment">#指定生成可执行文件</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment">#指定可执行文件链接时 需要依赖的库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(xcg-threadpool pthread)</span><br></pre></td></tr></table></div></figure>

        <h1 id="使用动态库编译可执行文件"   >
          <a href="#使用动态库编译可执行文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用动态库编译可执行文件"></a> 使用动态库编译可执行文件</h1>
      
<p>首先需要把动态库<code>libxcg-threadpool.so</code>移动到<code>/usr/lib</code>或<code>/usr/local/lib</code>；把动态库对应的头文件<code>threadpool.h</code>移动到<code>/usr/include</code>或<code>/usr/local/include</code>下。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp -std=c++17 -lxcg-threadpool -lpthread</span><br></pre></td></tr></table></div></figure>

        <h1 id="重构简洁版的线程池"   >
          <a href="#重构简洁版的线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#重构简洁版的线程池"></a> 重构简洁版的线程池</h1>
      
<p>要对外提供一个简单易用的submitTask接口。<br />
让用户直接传一个：<code>future result = submitTask(func, 1, 2);</code><br />
而不用再去继承一个抽象的Task了，甚至还得<code>make_shared&lt;MyTask()&gt;(func, 1, 2);</code>，这样太繁琐了。</p>
<p>主要用到的技巧就是：可变参模板，万能引用，函数绑定器，完美转发。<br />
submitTask的返回类型无法写出，需要用到auto占位，之后用decltype进行推导。</p>

        <h2 id="threadpool成员变量"   >
          <a href="#threadpool成员变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadpool成员变量"></a> ThreadPool成员变量</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;</span><br><span class="line">    <span class="type">int</span> initThreadSize_;</span><br><span class="line">    <span class="type">int</span> threadSizeThreshHold_;</span><br><span class="line">    std::atomic_int curThreadSize_;</span><br><span class="line">    std::atomic_int idleThreadSize_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="comment">// 此处之前的版本是智能指针管理的task，目前不需要了。</span></span><br><span class="line">    <span class="comment">// 因为我们把sharedptr对Task的包装都在submitTask内部进行封装了。</span></span><br><span class="line">    std::queue&lt;Task&gt; taskQue_;</span><br><span class="line"></span><br><span class="line">    std::atomic_int taskSize_;</span><br><span class="line">    <span class="type">int</span> taskQueMaxThreshHold_;</span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;</span><br><span class="line">    std::condition_variable notFull_;</span><br><span class="line">    std::condition_variable notEmpty_;</span><br><span class="line">    std::condition_variable exitCond_;</span><br><span class="line"></span><br><span class="line">    PoolMode poolMode_;</span><br><span class="line">    std::atomic_bool isPoolRunning_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="优化submittask"   >
          <a href="#优化submittask" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化submittask"></a> 优化submitTask</h2>
      
<p>以下的关键点：任务队列中存储的任务（lambda）捕获了<code>shared_ptr</code>，因此当这个任务被执行时，它仍然持有一个<code>shared_ptr</code>，这样<code>packaged_task</code>就不会在执行前被销毁。<br />
当任务执行完毕，这个lambda就会被销毁，那么它持有的<code>shared_ptr</code>也会被销毁（引用计数减一）。如果这时没有其他<code>shared_ptr</code>引用（比如在<code>submitTask</code>函数中，除了任务队列中的那个<code>shared_ptr</code>，还有<code>submitTask</code>函数中的局部变量<code>task</code>），那么<code>packaged_task</code>就会在任务执行完毕后被销毁。</p>
<p>但是，在submitTask函数中，我们返回了一个<code>future</code>，这个<code>future</code>是与<code>packaged_task</code>关联的。值得注意的是，<code>std::packaged_task</code>的析构不会影响其关联的<code>future</code>吗？不会。因为<code>std::future</code>是通过共享状态（shared state）与<code>std::packaged_task</code>关联的，这个共享状态独立于<code>packaged_task</code>对象。也就是说，即使<code>packaged_task</code>对象销毁了，只要共享状态还存在（因为<code>future</code>还持有），那么<code>future</code>仍然可以正常工作。所以，<code>packaged_task</code>对象销毁后，<code>future</code>的<code>get()</code>仍然可以正常返回结果（或者异常）。</p>
<p>我们要明确的：<br />
future只是负责持有结果。但<br />
<strong>future 不会延长 task 的生命周期​</strong>​，</p>
<ul>
<li><code>std::future</code> 只管理​<strong>​共享状态​</strong>​（shared state）的生命周期（存储结果的内存区域）</li>
<li>​<strong>​不会​</strong>​延长关联的 <code>packaged_task</code> 对象的生命周期</li>
<li><code>future</code> 只依赖共享状态，不依赖 <code>packaged_task</code> 对象本身。即共享状态的生命周期独立于 <code>packaged_task</code>
<ul>
<li>由最后一个引用它的 <code>future</code> 或 <code>shared_future</code> 管理</li>
<li>与 <code>packaged_task</code> 对象的销毁无关</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class PackagedTask &#123;</span><br><span class="line">        +operator()()</span><br><span class="line">        +get_future()</span><br><span class="line">        -shared_state* </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class SharedState &#123;</span><br><span class="line">        +result</span><br><span class="line">        +ready_flag</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Future &#123;</span><br><span class="line">        +shared_state*</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PackagedTask --&gt; SharedState : 独占拥有</span><br><span class="line">    Future --&gt; SharedState : 只读引用</span><br></pre></td></tr></table></div></figure>
<p>关键点：</p>
<ol>
<li><code>packaged_task</code> ​<strong>​独占拥有​</strong>​共享状态的生命周期</li>
<li><code>future</code> ​<strong>​只持有对共享状态的弱引用​</strong>​</li>
<li>移动、销毁 <code>packaged_task</code> 会​<strong>​转移共享状态的所有权​</strong>。但是不会销毁SharedState，因为外部还有Future在观察。
<ol>
<li>因此，其实也可以在之前就保存下来task的future，然后再去把task转移给任务队列。这样无所谓task是否在外部获得结果之前销毁了。
<ol>
<li>但是这样会限制task在移动之后的操作，无法在移动之后获得future了。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>关键点：</p>
<ol>
<li>​<strong>​共享所有权​</strong>​：
<ul>
<li>任务队列和工作线程共同持有 <code>shared_ptr</code>。
<ul>
<li>（⭐）当 lambda 被放入队列时，<code>shared_ptr</code> 的引用计数增加</li>
</ul>
</li>
<li>最后一个持有者释放时 <code>packaged_task</code> 才会销毁
<ul>
<li>当队列中的 lambda 被销毁时，<code>shared_ptr</code> 引用计数减少</li>
</ul>
</li>
</ul>
</li>
<li>​<strong>​生命周期安全​</strong>​：
<ul>
<li>即使 <code>submitTask</code> 返回，只要队列或线程持有 <code>shared_ptr</code></li>
<li><code>packaged_task</code> 对象会一直存活到任务执行完成</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    std::future&lt;RType&gt; result = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">        [&amp;]() -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;task queue is full, submit task failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 这里，用 lambda 表达式 充当 线程函数 func，函数中只返回一个空RType()</span></span><br><span class="line">        <span class="comment">// RType()即一个默认构造的 future</span></span><br><span class="line">        <span class="comment">// 但是可能会出现两个问题：</span></span><br><span class="line">        <span class="comment">// 1. RType 没有默认构造函数（如 std::atomic），</span></span><br><span class="line">        <span class="comment">// 2. 语义不准确，应该显式指出 提交失败的原因</span></span><br><span class="line">        <span class="comment">// auto task = std::make_shared&lt;std::packaged_task&lt;RType()&gt;&gt;(</span></span><br><span class="line">        <span class="comment">//     []() -&gt; RType &#123; return RType(); &#125;);</span></span><br><span class="line">        <span class="comment">// task();</span></span><br><span class="line">        <span class="comment">// return task-&gt;get_future();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 改进方案一：</span></span><br><span class="line">        <span class="comment">// return std::async(std::launch::deferred, </span></span><br><span class="line">        <span class="comment">//     [] &#123; throw std::runtime_error(&quot;Task queue full&quot;); &#125;).share().get_future();</span></span><br><span class="line">        <span class="comment">// 改进方案二：</span></span><br><span class="line">        std::promise&lt;RType&gt; p;</span><br><span class="line">        p.<span class="built_in">set_exception</span>(std::<span class="built_in">make_exception_ptr</span>(std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue full&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键：task这个shared_ptr，由这个lambda表达式捕获了，之后这个task的生命周期就和任务队列一致了。</span></span><br><span class="line">    taskQue_.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">    ++taskSize_;</span><br><span class="line"></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">        &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">        &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建新的线程对象</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::make_unique&lt;<span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholder::_1));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="再次优化submittask"   >
          <a href="#再次优化submittask" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#再次优化submittask"></a> 再次优化submitTask</h2>
      
<ul>
<li><code>future</code> 只依赖共享状态，不依赖 <code>packaged_task</code> 对象本身。即共享状态的生命周期独立于 <code>packaged_task</code>
<ul>
<li>由最后一个引用它的 <code>future</code> 或 <code>shared_future</code> 管理</li>
<li>与 <code>packaged_task</code> 对象的销毁无关</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class PackagedTask &#123;</span><br><span class="line">        +operator()()</span><br><span class="line">        +get_future()</span><br><span class="line">        -shared_state* </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class SharedState &#123;</span><br><span class="line">        +result</span><br><span class="line">        +ready_flag</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Future &#123;</span><br><span class="line">        +shared_state*</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PackagedTask --&gt; SharedState : 独占拥有</span><br><span class="line">    Future --&gt; SharedState : 只读引用</span><br></pre></td></tr></table></div></figure>
<p>关键点：</p>
<ol>
<li><code>packaged_task</code> ​<strong>​独占拥有​</strong>​共享状态的生命周期</li>
<li><code>future</code> ​<strong>​只持有对共享状态的弱引用​</strong>​</li>
<li>移动、销毁 <code>packaged_task</code> 会​<strong>​转移共享状态的所有权​</strong>。但是不会销毁SharedState，因为外部还有Future在观察。
<ol>
<li>因此，其实也可以在之前就保存下来task的future，然后再去把task转移给任务队列。这样无所谓task是否在外部获得结果之前销毁了。
<ol>
<li>移动task的缺点：但是这样会限制task在移动之后的操作，无法在移动之后获得future了。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>优化点：</p>
<ol>
<li>完美转发捕获（C++20）代替 <code>std::bind</code>，更高效且避免额外开销</li>
<li>移动task到lambda中，而不是建立<code>shared_ptr</code>来管理它。比<code>shared_ptr</code>版本更轻量高效（减少一次堆分配）。<br />
注意点：<br />
为什么需要mutable？</li>
</ol>
<p>因为<code>packaged_task</code>的<code>operator()</code>调用会改变<code>packaged_task</code>对象（它内部会执行任务并将结果存储到共享状态，所以会改变<code>packaged_task</code>的状态），因此<code>lambda</code>的调用运算符必须声明为<code>mutable</code>，否则编译器会认为你在一个<code>const</code>的<code>lambda</code>中试图修改捕获的对象。<br />
所以，这里mutable是必须的。</p>
<p>在完美转发捕获可变参时，为什么也需要加mutable？<br />
我们通过完美转发捕获了<code>func</code>和<code>args</code>。在lambda体内，我们调用了<code>func</code>，并使用了<code>std::forward&lt;Args&gt;(args)...</code>来转发参数。由于<strong>转发可能意味着移动（当参数是右值时），这会修改捕获的<code>args</code></strong>（移动后，对象的状态被改变，通常为空或有效状态被转移）。因此，我们需要<code>mutable</code>来允许对捕获的变量进行修改（包括移动操作）。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 创建任务和future</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::<span class="built_in">packaged_task</span>&lt;<span class="built_in">RType</span>()&gt;(</span><br><span class="line">        [func = std::forward&lt;Func&gt;(func), ...args = std::forward&lt;Args&gt;(args)] () <span class="keyword">mutable</span> </span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">func</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;); <span class="comment">// ✅ 完美转发捕获(C++20)</span></span><br><span class="line">    </span><br><span class="line">    std::future&lt;RType&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 锁保护队列操作</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 检查队列容量</span></span><br><span class="line">    <span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, <span class="number">1</span>s, </span><br><span class="line">        [&amp;] &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 优雅的错误处理</span></span><br><span class="line">        std::promise&lt;RType&gt; p;</span><br><span class="line">        p.<span class="built_in">set_exception</span>(</span><br><span class="line">            std::<span class="built_in">make_exception_ptr</span>(std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue full&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">get_future</span>(); <span class="comment">// ⏱️ 立即就绪的异常future</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 提交任务到队列</span></span><br><span class="line">    taskQue_.<span class="built_in">emplace</span>([task = std::<span class="built_in">move</span>(task)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">task</span>(); <span class="comment">// ✅ 执行移动后的任务</span></span><br><span class="line">    &#125;);</span><br><span class="line">    ++taskSize_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 通知工作线程</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 动态扩缩容逻辑 (CACHED模式)</span></span><br><span class="line">    <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED &amp;&amp; </span><br><span class="line">        taskSize_ &gt; idleThreadSize_ &amp;&amp;</span><br><span class="line">        curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... 创建新线程 (省略细节)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 🎯 返回有效的future</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="threadfunc的重构"   >
          <a href="#threadfunc的重构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadfunc的重构"></a> threadFunc的重构</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_IDLE_TIME = <span class="number">60</span>;	<span class="comment">//单位s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 上一次线程执行完任务的时间 */</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处之前的版本是智能指针管理的task，目前不需要了。</span></span><br><span class="line">        <span class="comment">// 因为我们把sharedptr对Task的包装都在submitTask内部进行封装了。</span></span><br><span class="line">    	Task task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line">            <span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line">            <span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line">            <span class="comment">// 锁 + 双重判断</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line">                <span class="keyword">if</span> (!isPoolRunning_)</span><br><span class="line">                &#123;</span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                        &lt;&lt; std::endl;</span><br><span class="line">                    exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//while(taskQue_.size() &gt; 0) // 不再去判断 taskQue_.size() &gt; 0，即使size是0，也一直等待60s</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* 超时 1s 返回 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">//返回的是time_point类型</span></span><br><span class="line">                        <span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line">                        <span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 开始回收当前线程 */</span></span><br><span class="line">                            <span class="comment">/* 修改记录线程数量的相关变量 */</span></span><br><span class="line">                            <span class="comment">/* 把线程从线程列表容器中删除 */</span></span><br><span class="line">                            <span class="comment">/* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */</span></span><br><span class="line">                            <span class="comment">/* 我们需要有一个映射关系来记录：threadid =&gt; thread对象 =&gt; 删除 */</span></span><br><span class="line">                            thread_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                            --curThreadSize_;</span><br><span class="line">                            --idleThreadSize_;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                                &lt;&lt; std::endl;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//&#125; // while(taskQue_.size() &gt; 0) 结束</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// poolMode_ != PoolMode::MODE_CACHED</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock <span class="comment">/* , [&amp;]()-&gt;bool &#123; return taskQue_.size() &gt; 0; &#125; */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end while (taskQueue_.size() == 0)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 taskQueue_.size() != 0 而 我们又拿到了 任务队列的锁，可以直接取走任务</span></span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">            taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125; <span class="comment">// end std::unique_lock&lt;std::mutex&gt; lock(taskQueMtx_);</span></span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        <span class="comment">/* 线程执行完任务后更新lastTime */</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">2</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res1 = pool.<span class="built_in">submitTask</span>(sum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res2 = pool.<span class="built_in">submitTask</span>([](<span class="type">int</span> begin, <span class="type">int</span> end) -&gt; <span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res3 = pool.<span class="built_in">submitTask</span>(sum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res4 = pool.<span class="built_in">submitTask</span>(sum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res<span class="number">4.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/100/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/100/">100</a><span class="page-number current">101</span><a class="page-number" href="/page/102/">102</a><span class="space">&hellip;</span><a class="page-number" href="/page/150/">150</a><a class="extend next" rel="next" href="/page/102/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">300</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">57</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>