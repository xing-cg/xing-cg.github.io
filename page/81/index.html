<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/81/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/81/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/">MySQL_范式设计</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-15</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/" data-flag-title="MySQL_范式设计"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>关系型数据库范式</li>
<li>应用范式的好处</li>
<li>第一范式</li>
<li>第二范式</li>
<li>第三范式</li>
<li>BC范式</li>
<li>第四范式</li>
</ol>

        <h1 id="应用范式的好处"   >
          <a href="#应用范式的好处" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用范式的好处"></a> 应用范式的好处</h1>
      
<p>范式和表的设计有什么关系呢？可以说是息息相关，表设计过程中需要知道的规则，在范式设计中，都会有所提及。可以说，范式是表设计原则的提炼。</p>
<p>表设计原则是告诉我们怎么设计表之间的关联，并且尽量减少数据冗余。</p>
<p>而应用范式最重要的好处也是<strong>减少数据冗余</strong>。由此带来的好处有：</p>
<ol>
<li>消除异常（插入异常、更新异常、删除异常）</li>
<li>让数据组织地更加和谐</li>
</ol>

        <h1 id="第一范式"   >
          <a href="#第一范式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第一范式"></a> 第一范式</h1>
      
<blockquote>
<ol>
<li>每一列保持原子特性</li>
<li>不符合第一范式则不能称作关系型数据库。比如key-value，因为key对应的value可能包含了各种杂乱的信息，例如json数据。</li>
</ol>
</blockquote>
<p>列都是基本数据项，不能再进行分割，否则设计成一对多的实体关系。</p>
<p>例如表中的地址字段，可以再细分为省、市、区等不可再分割的字段。</p>
<p><img src="../../images/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20220516163422062.png" alt="image-20220516163422062" /></p>
<p>上图的Employee表中的Address字段，就没有遵循第一范式。即地址信息可以细分为很多详细的地址。如果没有去规范地址的分类，则就会造成地址数据粒度太粗。如果我们要查询某一特定地址的雇员信息，还要从地址字符串中提取相关信息，过于麻烦。</p>
<p><img src="../../images/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20220516163314051.png" alt="image-20220516163314051" /></p>
<p>我们现在将Address抽取出来作为一个单独的表，让地址字段分成更详细的city、country、street三个字段。再让Employee表与其关联，则可解决Address粒度过粗的问题。</p>
<p>查询指定EmployeeID的职员的地址信息。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 方法一：带in的子查询，子查询效率较低</span><br><span class="line">select * from EmployeeAddress where addressID in (select AddressID from Employee where EmployeeID=1);</span><br><span class="line"># 用连接查询效率高一些。</span><br></pre></td></tr></table></div></figure>

        <h1 id="第二范式"   >
          <a href="#第二范式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第二范式"></a> 第二范式</h1>
      
<blockquote>
<p>属性完全依赖于主键 - 主要针对联合主键</p>
</blockquote>
<p>非主属性（不是主键的字段）必须完全依赖主关键字（包括联合主键的每一列），如果不是完全依赖主键，应该拆分成新的实体，设计成一对多的实体关系。</p>
<p>例如教务系统中的选课：选课关系表为<code>SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)</code>。则<code>(学号, 课程名称)</code>是联合主键，但是学分字段只与课程名称有关，与学号无关，相当于只依赖联合主键的其中一个字段 - <code>课程名称</code>，不符合第二范式。其中，学分在此表中属于冗余存储。除此之外，<code>姓名</code>和<code>年龄</code>字段也属于冗余存储。</p>
<p>学生和课程之间，属于多对多的关系。</p>
<p>学生表：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>年龄</th>
</tr>
</thead>
</table></div>
<p>课程表：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>课程id</th>
<th>课程名称</th>
<th>学分</th>
</tr>
</thead>
</table></div>
<p>选课情况（中间表）：</p>
<div class="table-container"><table>
<thead>
<tr>
<th>学号</th>
<th>课程id</th>
<th>成绩</th>
</tr>
</thead>
</table></div>
<hr />
<p>再例如，上面的Employee表。经历了第一范式之后，仍存在问题。</p>
<p>该表存在联合主键<code>(EmployeeID, departmentName)</code>。表中<code>Name</code>字段明显与<code>departmentName</code>不存在关系。因此不符合第二范式。</p>
<p>则把department有关信息</p>
<p><img src="../../images/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20220516202334294.png" alt="image-20220516202334294" /></p>

        <h1 id="第三范式"   >
          <a href="#第三范式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第三范式"></a> 第三范式</h1>
      
<blockquote>
<p>属性不依赖于其他非主属性。</p>
<p>一般的关系型数据库满足第三范式就足够了。</p>
</blockquote>
<p>要求一个数据表中不包含已在其他表中已包含的非主关键字信息。</p>
<p>示例：学生关系表为<code>Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)</code>，字段<code>学号</code>是主键。但是，字段<code>学院地点</code>、<code>学院电话</code>依赖于非主属性<code>所在学院</code>，并不依赖于主键<code>学号</code>。因此该设计不符合第三范式。应该把学院单独设计成一张表，学院和学生是一对多的关系。</p>
<hr />
<p>再如Employee表中的问题，发现字段<code>jobDescription</code>并不依赖于主键<code>EmployeeID</code>，而是依赖非主属性<code>job</code>。不符合第三范式。因此把<code>job</code>有关的属性抽取出来单独作为<code>job</code>表。工作和雇员也是一对多的关系。</p>
<p><img src="../../images/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20220517082159583.png" alt="image-20220517082159583" /></p>

        <h1 id="bc范式"   >
          <a href="#bc范式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#bc范式"></a> BC范式</h1>
      
<blockquote>
<p>每个表中只有一个候选键</p>
</blockquote>
<p>BC范式是在第三范式的基础上的一种特殊情况，即每个表中只有一个<strong>候选键</strong>（在一个数据库中，每行的值都不相同，则可称为候选键）。Employee表中可以看出，每一个员工的<code>email</code>都是唯一的（逻辑上来说，邮箱是单人单用），则上表不符合BC范式。</p>
<p>应把邮箱单独抽出作为一张表。邮箱与雇员属于一对一的关系。</p>
<p><img src="../../images/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20220517084229658.png" alt="image-20220517084229658" /></p>

        <h1 id="第四范式"   >
          <a href="#第四范式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#第四范式"></a> 第四范式</h1>
      
<blockquote>
<p>消除表中的多值依赖</p>
</blockquote>
<p>简单来说，第四范式就是要消除表中的多值依赖，也就是说可以减少数据一致性的工作。比如Employee表中的字段<code>skill</code>，有的人是<code>&quot;java, mysql&quot;</code>，有的人是<code>&quot;Java, MySQL&quot;</code>，这样数据就不一致了。</p>
<p>解决方案就是将多值属性放入一个新表。Employee表则是把<code>skill</code>抽出作为一张表。雇员和技能是一对多的关系。</p>
<p><img src="../../images/MySQL_%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/image-20220517085547889.png" alt="image-20220517085547889" /></p>
<div class="table-container"><table>
<thead>
<tr>
<th>skill</th>
<th>EmployeeID</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++</td>
<td>1000</td>
</tr>
<tr>
<td>Java</td>
<td>1000</td>
</tr>
<tr>
<td>MySQL</td>
<td>2000</td>
</tr>
<tr>
<td>Golang</td>
<td>2000</td>
</tr>
<tr>
<td>Rust</td>
<td>1000</td>
</tr>
<tr>
<td>C++</td>
<td>2000</td>
</tr>
</tbody>
</table></div>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
      
<ul>
<li>
<p>范式含义</p>
</li>
<li>
<p>好处</p>
</li>
</ul>
<p>应用数据库范式可以带来许多好处,但是最重要的好处归结为三点：</p>
<ol>
<li>减少数据沉余(这是最主要的好处，其他好处都是由此而附带的)</li>
<li>消除异常(插入异常、更新异常、删除异常</li>
<li>让数据组织的更加和谐</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<p>但是数据库范式绝对不是越高越好，范式越高，意味着表越多，多表联合查询的机率就越大，SQL的效率就变低。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Linux/Linux_exit/">Linux_exit</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-15</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Linux/Linux_exit/" data-flag-title="Linux_exit"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li></li>
<li><code>exit</code></li>
<li>僵死进程</li>
</ol>

        <h1 id="进程终止方式"   >
          <a href="#进程终止方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程终止方式"></a> 进程终止方式</h1>
      
<p><img src="../../images/Linux_exit/image-20220515093901952.png" alt="image-20220515093901952" /></p>

        <h2 id="进程5种正常终止方式"   >
          <a href="#进程5种正常终止方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程5种正常终止方式"></a> 进程5种正常终止方式</h2>
      
<ol>
<li>
<p>从main返回，即在main函数内执行<code>return</code>语句，等效于调用<code>exit</code>。</p>
</li>
<li>
<p>调用<code>exit</code>函数。此函数由<code>ISO C</code>定义，其操作包括调用各终止处理程序（终止处理程序在调用<code>atexit</code>函数时登记），然后关闭所有标准I/O流等。因为<code>ISO C</code>并不处理文件描述符、多进程（父进程和子进程）以及作业控制，所以这一定义对UNIX系统而言是不完整的。</p>
</li>
<li>
<p>调用<code>_exit</code>或<code>_Exit</code>函数。<code>ISO C</code>定义<code>_Exit</code>，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗取决于实现方式。在UNIX系统中，<code>_Exit</code>和<code>_exit</code>是同义的，并不冲洗标准I/O流。<code>_exit</code>函数由<code>exit</code>调用，它处理UNIX系统特定的细节。<code>_exit</code>是由<code>POSIX.1</code>说明的。</p>
<blockquote>
<p>在大多数UNIX系统实现中，<code>exit(3)</code>是标准C库中的一个函数，而<code>_exit(2)</code>则是一个系统调用。</p>
</blockquote>
</li>
<li>
<p>最后一个线程从其启动例程返回中执行return语句。但是该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。</p>
</li>
<li>
<p>从最后一个线程调用<code>pthread_exit</code>函数。如同前面一样，在这种情况中，进程终止状态总是0，这与传送给<code>pthread_exit</code>的参数无关。</p>
</li>
</ol>

        <h2 id="进程3种异常终止方式"   >
          <a href="#进程3种异常终止方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#进程3种异常终止方式"></a> 进程3种异常终止方式</h2>
      
<ol>
<li>调用abort。产生<code>SIGABRT</code>信号，这是下一种异常终止的一种特例。</li>
<li>当进程接收到某些信号时。信号可由进程自身（如调用<code>abort</code>函数）、其他进程或内核产生。例如，若进程引用地址空间之外的存储单元、或者除以0，内核就会为该进程产生相应的信号。</li>
<li>最后一个线程对取消(cancellation)请求做出响应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止。</li>
</ol>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
      
<p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。</p>
<p>对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(<code>exit</code>、<code>_exit</code>和<code>_Exit</code>)，实现这一点的方法是将其退出状态(<code>exit status</code>)作为参数传送给函数。在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的终止状态(<code>termination status</code>)。在任意一种情况下，该终止进程的父进程都能用<code>wait</code>或<code>waitpid</code>函数取得其终止状态。</p>
<p>注意，这里使用了“<strong>退出状态</strong>”(它是传递给向3个终止函数的参数，或<code>main</code>的返回值)和“<strong>终止状态</strong>”两个术语，以表示有所区别。在最后调用<code>_exit</code>时，内核将退出状态转换成终止状态。</p>
<p>父进程检查子进程终止状态的方法有很多。如果子进程正常终止，则父进程可以获得子进程的退出状态。</p>

        <h1 id="父子进程终止问题"   >
          <a href="#父子进程终止问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#父子进程终止问题"></a> 父子进程终止问题</h1>
      

        <h2 id="孤儿进程"   >
          <a href="#孤儿进程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#孤儿进程"></a> 孤儿进程</h2>
      
<p>在说明<code>fork</code>函数时，显而易见，子进程是在父进程调用fork后生成的。上面又说明了子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，又将如何呢？其回答是：</p>
<p>如果某进程的父进程已经终止，它们的父进程都改变为<code>init</code>进程。我们称这些进程由<code>init</code>进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则更改该进程的父进程ID为1 (<code>init</code>进程的ID)。这种处理方法保证了每个进程有一个父进程。</p>

        <h2 id="僵死进程"   >
          <a href="#僵死进程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#僵死进程"></a> 僵死进程</h2>
      
<p>另一个我们关心的情况是，如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用<code>wait</code>或<code>waitpid</code>时可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。</p>
<p>内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<strong>僵死进程(zombie)</strong>。<code>ps(1)</code>命令将僵死进程的状态打印为<code>Z</code>。如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程。</p>
<blockquote>
<p>最后一个要考虑的问题是：一个由<code>init</code>进程收养的进程终止时会发生什么？它会不会变成一个僵死进程？</p>
<p>对此问题的回答是“否”，因为<code>init</code>被编写成无论何时只要有一个子进程终止，init就会调用一个<code>wait</code>函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。</p>
<p>当提及“一个<code>init</code>的子进程”时，这指的可能是<code>init</code>直接产生的进程（如getty进程），也可能是其父进程已终止，由<code>init</code>收养的进程。</p>
</blockquote>

        <h1 id="退出函数"   >
          <a href="#退出函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#退出函数"></a> 退出函数</h1>
      
<p>3个函数用于正常终止一个程序：<code>_exit</code>和<code>_Exit</code>立即进入内核，<code>exit</code>则先执行一些清理处理，然后返回内核。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></div></figure>
<p>调用这三个函数的进程对其他进程有一定影响（如其父进程和子进程）。</p>
<blockquote>
<p>使用不同头文件的原因是<code>exit</code>和<code>_Exit</code>是由<code>ISO C</code>说明的，而<code>_exit</code>是由<code>POSIX.1</code>说明的。</p>
</blockquote>
<p>由于历史原因，<code>exit</code>函数总是执行一个标准I/O库的清理关闭操作：对于所有打开流调用<code>fclose</code>函数，这造成输出缓冲中的所有数据都被冲洗（写到文件上）。</p>
<p>3个退出函数都带一个整型参数，称为<strong>终止状态</strong>（或退出状态，<code>exit status</code>)。大多数UNIX系统shell都提供检查进程终止状态的方法。如果(a)调用这些函数时不带终止状态，或<code>(b)main</code>执行了一个无返回值的<code>return</code>语句，或<code>(c)main</code>没有声明返回类型为整型，则该进程的终止状态是未定义的。但是，若main的返回类型是整型，并且main执行到最后一条语句时返回（隐式返回），那么该进程的终止状态是0。</p>
<blockquote>
<p>这种处理是ISO C标准1999版引入的。历史上，若main函数终止时没有显式使用return语句或调用exit函数，那么进程终止状态是未定义的。</p>
<p>比如以下程序：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>对该程序进行编译，然后运行，则可见到其终止码是随机的。如果在不同的系统上编译该程序，我们很可能得到不同的终止码，这<strong>取决于main函数返回时栈和寄存器的内容</strong></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">hello,world</span><br><span class="line">$ <span class="built_in">echo</span> $?	<span class="comment"># $? 为终止状态码</span></span><br><span class="line">13</span><br></pre></td></tr></table></div></figure>
<p>现在，我们启用1999 ISO C编译器扩展，则可见到终止码改变了：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -std=c99 hello.c	<span class="comment"># 启用gcc的1999 ISO C扩展</span></span><br><span class="line">hello.c:4: warning: <span class="built_in">return</span> <span class="built_in">type</span> defaults to <span class="string">&#x27;int&#x27;</span></span><br><span class="line">$ ./a.out</span><br><span class="line">hello,world</span><br><span class="line">$ <span class="built_in">echo</span> $?	<span class="comment"># $? 为终止状态码</span></span><br><span class="line">0			<span class="comment"># 此处处理为0</span></span><br></pre></td></tr></table></div></figure>
</blockquote>
<p>main函数返回一个整型值与用该值调用<code>exit</code>是等价的。于是在main函数中<code>exit(0);</code>等价于<code>return(0);</code>。</p>

        <h1 id="wait"   >
          <a href="#wait" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#wait"></a> wait</h1>
      
<p>当一个进程正常或异常终止时，内核就向其父进程发送<code>SIGCHLD</code>信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。</p>
<p>父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。</p>
<p>现在需要知道的是调用<code>wait</code>或<code>waitpid</code>的进程可能会发生什么。</p>
<ul>
<li>如果其所有子进程都还在运行，则阻塞。</li>
<li>如果<strong>一个</strong>子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，则立即出错返回。</li>
</ul>
<p>如果进程由于接收到<code>SIGCHLD</code>信号而调用<code>wait</code>， 我们期望<code>wait</code>会立即返回。但是如果在随机时间点调用<code>wait</code>， 则进程可能会阻塞。</p>

        <h2 id="api"   >
          <a href="#api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#api"></a> api</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> * statloc)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> * statloc, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">//两个函数返回值：若成功，返回进程ID；若出错，返回0或-1</span></span><br></pre></td></tr></table></div></figure>
<p>这两个函数的区别如下。</p>
<ul>
<li>在一个子进程终止前，<code>wait</code>使其调用者阻塞；而<code>waitpid</code>有一选项，可使调用者不阻塞。</li>
<li><code>waitpid</code>并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。</li>
</ul>
<p>如果子进程已经终止，并且是一个僵死进程，则<code>wait</code>立即返回并取得该子进程的状态；否则<code>wait</code>使其调用者阻塞，直到一个子进程终止。如调用者阻塞而且它有多个子进程，则在其某一子进程终止时，<code>wait</code>就立即返回。因为<code>wait</code>返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。</p>
<p>这两个函数的参数<code>statloc</code>是一个整型指针。如果<code>statloc</code>不是一个空指针，则终止进程的<strong>终止状态就存放在它所指向的单元</strong>内。如果不关心终止状态，则可将该参数指定为空指针。</p>
<p>依据传统，这两个函数返回的整型状态字是由实现定义的。其中某些位表示退出状态（正常返回），其他位则指示信号编号（异常返回），有一位指示是否产生了<code>core</code>文件等。<code>POSIX.1</code>规定，终止状态用定义在<code>&lt;sys/wait.h&gt;</code>中的各个宏来查看。有4个互斥的宏可用来取得进程终止的原因，它们的名字都以<code>WIF</code>开始。基于这4个宏中哪一个值为真，就可选用其他宏来取得退出状态、信号编号等。</p>
<p><img src="../../images/Linux_exit/image-20220515100404070.png" alt="image-20220515100404070" /></p>
<p>正如前面所述，如果一个进程有几个子进程，那么只要有一个子进程终止，wait就返回。</p>
<p>如果要等待一个指定的进程终止（如果知道要等待进程的ID），那么该如何做呢？在早期的UNIX版本中，必须调用<code>wait</code>，然后将其返回的进程ID和所期望的进程ID相比较。如果终止进程不是所期望的，则将该进程ID和终止状态保存起来，然后再次调用<code>wait</code>。反复这样做，直到所期望的进程终止。下一次又想等待一个特定进程时，先查看已终止的进程列表，若其中已有要等待的进程，则获取相关信息；否则调用<code>wait</code>。其实，我们需要的是等待一个特定进程的函数。POSIX定义了<code>waitpid</code>函数以提供这种功能（以及其他一些功能）。<br />
对于<code>waitpid</code>函数中<code>pid</code>参数的作用解释如下。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>参数值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pid==-1</code></td>
<td>等待任一子进程。此种情况下，<code>waitpid</code>与<code>wait</code>等效。</td>
</tr>
<tr>
<td><code>pid&gt;0</code></td>
<td>等待进程ID与pid相等的子进程。</td>
</tr>
<tr>
<td><code>pid==0</code></td>
<td>等待<strong>组ID</strong>等于调用进程组ID的任一子进程。</td>
</tr>
<tr>
<td><code>pid&lt;-1</code></td>
<td>等待<strong>组ID</strong>等于pid绝对值的任一子进程。</td>
</tr>
</tbody>
</table></div>
<p><code>waitpid</code>函数返回终止子进程的进程ID，并将该子进程的终止状态存放在由<code>statloc</code>指向的存储单元中。</p>
<p>对于<code>wait</code>，其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返回另一种出错）。但是对于<code>waitpid</code>，如果指定的进程或进程组不存在，或者参数<code>pid</code>指定的进程不是调用进程的子进程，都可能出错。</p>
<p>options参数使我们能进一步控制<code>waitpid</code>的操作。此参数或者是0，或者是下表中常量按位或运算的结果。</p>
<p><img src="../../images/Linux_exit/image-20220515101143654.png" alt="image-20220515101143654" /></p>
<p>waitpid函数提供了wait函数没有提供的3个功能。</p>
<ol>
<li><code>waitpid</code>可等待一个特定的进程；而<code>wait</code>则返回任一终止子进程的状态。在讨论<code>popen</code>函数时会再说明这一功能。</li>
<li><code>waitpid</code>提供了一个<code>wait</code>的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。</li>
<li><code>waitpid</code>通过<code>WUNTRACED</code>和<code>WCONTINUED</code>选项支持作业控制。</li>
</ol>

        <h1 id="避免僵死进程的方法"   >
          <a href="#避免僵死进程的方法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#避免僵死进程的方法"></a> 避免僵死进程的方法</h1>
      
<p>回忆有关僵死进程的讨论。如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态直到父进程终止，实现这一要求的诀窍是调用fork两次。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)	<span class="comment">//第一个子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)	<span class="comment">//子进程再次fork</span></span><br><span class="line">        &#123;</span><br><span class="line">            err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)		<span class="comment">//子进程退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child&#x27;s child, parent pid = %ld\n&quot;</span>, (<span class="type">long</span>)getppid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != pid)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在fork之后，如果不使第二个子进程休眠，那么它可能比其父进程先执行，于是它打印的父进程ID将是创建它的父进程，而不是<code>init</code>进程（进程ID 1）。第二个子进程调用sleep以保证在打印父进程ID时第一个子进程已终止。</p>
<p>执行程序得到：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">$ child&#x27;s child, parent pid = 1</span><br></pre></td></tr></table></div></figure>
<p>注意，当原先的进程（也就是exec本程序的进程）终止时，shell打印其提示符，这在第二个子进程打印其父进程ID之前。</p>

        <h1 id="竞争条件"   >
          <a href="#竞争条件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#竞争条件"></a> 竞争条件</h1>
      
<p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了<strong>竞争条件(race condition)</strong>。如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行，那么fork函数就会是竞争条件活跃的滋生地。</p>
<p>通常，我们不能预料哪一个进程先运行。即使我们知道哪一个进程先运行，在该进程开始运行后所发生的事情也依赖于系统负载以及内核的调度算法。</p>
<p>在上个程序中，当第二个子进程打印其父进程ID时，我们看到了一个潜在的竞争条件。如果第二个子进程在第一个子进程之前运行，则最终其父进程将会是第一个子进程，则就会成为僵死进程。但是，如果第一个子进程先运行，并有足够的时间到达并执行<code>exit</code>（最关键是在第二个子进程退出前，第一个子进程退出，使第二个子进程变为孤儿进程），则第二个子进程的父进程就是<code>init</code>。即使在程序中调用<code>sleep</code>，也不能保证什么。如果系统负载很重，那么在<code>sleep</code>返回之后、第一个子进程得到机会运行之前，第二个子进程可能恢复运行。这种形式的问题很难调试，因为在大部分时间，这种问题并不出现。</p>
<p>如果一个进程希望等待一个子进程终止，则它必须调用<code>wait</code>函数中的一个；反过来，如果一个进程要等待其父进程终止，则可使用下列形式的循环：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid()!=<span class="number">1</span>)</span><br><span class="line">	sleep(<span class="number">1</span>)；</span><br></pre></td></tr></table></div></figure>
<p>这种形式的循环称为轮询(polling)，它的问题是浪费了CPU时间，因为调用者每隔1s都被唤醒，然后进行条件测试。</p>
<p>为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制作为解决此方面问题的一种用法。各种形式的进程间通信(IPC)也可解决此问题。</p>
<p>在父进程和子进程的关系中，常常出现下述情况。在fork之后，父进程和子进程都有一些事情要做。例如，父进程可能要用子进程ID更新日志文件中的一个记录，而子进程则可能要为父进程创建一个文件。在本例中，要求每个进程在执行完它的一套初始化操作后要通知对方，并且在继续运行之前，要等待另一方完成其初始化操作。这种情况可以用代码描述如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line">TELL_WAIT();</span><br><span class="line"><span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errsys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TELL_PARENT(getppid());</span><br><span class="line">    WAIT_PARENT();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">TELL_CHILD(pid);</span><br><span class="line">WAIT_CHILD();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>
<p>假定在头文件<code>apue.h</code>中定义了需要使用的各个变量。</p>
<p>5个例程<code>TELL_WAIT</code>、<code>TELL_PARENT</code>、<code>TELL_CHILD</code>、<code>WAIT_PARENT</code>以及<code>WAIT_CHILD</code>可以是宏，也可以是函数。</p>
<p>实现这些TELL和WAIT例程的不同方法：使用信号的一种实现；使用管道的一种实现。</p>
<p>以下程序，子进程、父进程分别输出两个字符串，因为输出依赖于内核使这两个进程运行的顺序及每个进程运行的时间长度，所以该程序包含了一个竞争条件。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatime</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        charatatime(<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        charatatime(<span class="string">&quot;output from parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatime</span><span class="params">(chat * str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * ptr;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);	<span class="comment">//set unbuffered</span></span><br><span class="line">    <span class="keyword">for</span>(ptr = str; (c = *ptr++) != <span class="number">0</span>; )	<span class="comment">//赋值语句的返回值是所赋的值，即*ptr</span></span><br><span class="line">    &#123;</span><br><span class="line">        putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在程序中将标准输出设置为不带缓冲的，于是每个字符输出都需调用一次<code>write</code>。本例的目的是使内核能尽可能多次地在两个进程之间进行切换，以便演示竞争条件。（如果不这样做，可能也就决不会见到下面所示的输出。没有看到具有错误的输出并不意味着竞争条件不存在，这只是意味着在此特定的系统上未能见到它。)下面的实际输出说明该程序的运行结果是会改变的。</p>
<p><img src="../../images/Linux_exit/image-20220515173120942.png" alt="image-20220515173120942" /></p>
<p>修改这个程序，使其使用<code>TELL</code>和<code>WAIT</code>函数，于是形成了以下程序。行首标以<code>+</code>号的行是新增加的行。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&quot;apue.h&quot;</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatime</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">+       TELL_WAIT();</span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            err_sys(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">+           WAIT_PARENT();	<span class="comment">//parent goes first</span></span><br><span class="line">            charatatime(<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            charatatime(<span class="string">&quot;output from parent\n&quot;</span>);</span><br><span class="line">+           TELL_CHILD(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">charatatime</span><span class="params">(chat * str)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * ptr;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);	<span class="comment">//set unbuffered</span></span><br><span class="line">        <span class="keyword">for</span>(ptr = str; (c = *ptr++) != <span class="number">0</span>; )	<span class="comment">//赋值语句的返回值是所赋的值，即*ptr</span></span><br><span class="line">        &#123;</span><br><span class="line">            putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>运行此程序则能得到所预期的两个进程的输出不再交叉混合，且父进程先输出。</p>
<p>如果将fork之后的行改成以下代码，则子进程先输出：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    charatatime(<span class="string">&quot;output from child\n&quot;</span>);</span><br><span class="line">    TELL_PARENT(getppid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    WAIT_CHILD();	<span class="comment">//child goes first</span></span><br><span class="line">    charatatime(<span class="string">&quot;output from parent\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/80/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/80/">80</a><span class="page-number current">81</span><a class="page-number" href="/page/82/">82</a><span class="space">&hellip;</span><a class="page-number" href="/page/144/">144</a><a class="extend next" rel="next" href="/page/82/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">287</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">54</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>