<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/82/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/82/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">外观模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-13</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" data-flag-title="外观模式"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt"><p>外观模式是一种使用频率非常高的<strong>结构型设计模式</strong>，它通过引入一个外观角色来简化客户端与子系统之间的交互，<strong>为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度</strong>，且客户端调用非常方便。</p>

        <h1 id="引例"   >
          <a href="#引例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#引例"></a> 引例</h1>
      
<p>不知道大家有没有比较过自己泡茶和去茶馆喝茶的区别，如果是自己泡茶需要自行准备茶叶、茶具和开水，如图所示。<br />
<img src="../../images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20220509175118569.png" alt="image-20220509175118569" /></p>
<p>而去茶馆喝茶，最简单的方式就是跟茶馆服务员说想要一杯什么样的茶。正因为茶馆有服务员，顾客无须直接和茶叶、茶具、开水等交互，整个泡茶过程由服务员来完成，顾客只需与服务员交互即可，整个过程非常简单省事，如图所示。<br />
<img src="../../images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20220509175152669.png" alt="image-20220509175152669" /></p>
<p>在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别<strong>需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互</strong>。</p>
<p>外观模式通过引入一个**外观类(Facade)**来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。</p>
<p>在外观模式中，那些<strong>需要交互的业务类被称为子系统(Subsystem)</strong>。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大。而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度，如图所示。<br />
<img src="../../images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20220509175402273.png" alt="image-20220509175402273" /></p>

        <h1 id="外观模式"   >
          <a href="#外观模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#外观模式"></a> 外观模式</h1>
      
<p>外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</p>
<ul>
<li>定义</li>
</ul>
<p>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br />
Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</p>
<p>外观模式又称为门面模式，它是一种对象结构型模式。外观模式<strong>是迪米特法则的一种具体实现</strong>，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p>

        <h1 id="外观模式结构与实现"   >
          <a href="#外观模式结构与实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#外观模式结构与实现"></a> 外观模式结构与实现</h1>
      

        <h2 id="模式结构"   >
          <a href="#模式结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#模式结构"></a> 模式结构</h2>
      
<p>外观模式没有一个一般化的类图描述。下图可以简单地描述外观模式的结构：<br />
<img src="../../images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20220509185718460.png" alt="image-20220509185718460" /></p>
<p>外观模式包含如下两个角色：</p>
<ul>
<li>
<p><strong>Facade（外观角色）</strong></p>
<ul>
<li>在客户端可以调用它的方法</li>
<li>在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；</li>
<li>在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li>
</ul>
</li>
<li>
<p><strong>SubSystem（子系统角色）</strong></p>
<ul>
<li>在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；</li>
<li>每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；</li>
<li>子系统并不知道外观的存在，<strong>对于子系统而言，外观角色仅仅是另外一个客户端</strong>而已。</li>
</ul>
</li>
</ul>

        <h2 id="模式实现"   >
          <a href="#模式实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#模式实现"></a> 模式实现</h2>
      
<p>外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化。</p>
<p>而外观模式的引入在很大程度上降低了类与类之间的耦合关系，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。</p>

        <h3 id="子系统"   >
          <a href="#子系统" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#子系统"></a> 子系统</h3>
      
<p>外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//业务实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="外观类"   >
          <a href="#外观类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#外观类"></a> 外观类</h3>
      
<p>在引入外观类之后，与子系统业务类之间的交互统一由外观类来完成，在外观类中通常存在如下代码：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SubSystemA * obja;</span><br><span class="line">	SubSystemB * objb;</span><br><span class="line">	SubSystemC * objc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Facade</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        obja = <span class="keyword">new</span> <span class="built_in">SubSystemA</span>();</span><br><span class="line">        objb = <span class="keyword">new</span> <span class="built_in">SubSystemB</span>();</span><br><span class="line">        objc = <span class="keyword">new</span> <span class="built_in">SubSystemC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obja-&gt;<span class="built_in">MethodA</span>();</span><br><span class="line">        objb-&gt;<span class="built_in">MethodB</span>();</span><br><span class="line">        objc-&gt;<span class="built_in">MethodC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="客户端"   >
          <a href="#客户端" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h3>
      
<p>由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。引入外观类后，客户端代码变得非常简单，典型代码如下：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Facade facade = <span class="keyword">new</span> <span class="built_in">Facade</span>();</span><br><span class="line">    facade-&gt;<span class="built_in">Method</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="外观模式应用实例"   >
          <a href="#外观模式应用实例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#外观模式应用实例"></a> 外观模式应用实例</h1>
      
<p>下面通过一个应用实例来进一步学习和理解外观模式。</p>
<p>某软件公司欲开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分：<strong>读取源文件、加密、保存加密之后的文件</strong>。其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这三个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这三个操作的业务代码封装在三个不同的类中。</p>
<p>现使用外观模式设计该文件加密模块。</p>

        <h2 id="实例类图"   >
          <a href="#实例类图" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实例类图"></a> 实例类图</h2>
      
<p>通过分析，本实例结构图如下。</p>
<p><img src="../../images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20220509200434876.png" alt="image-20220509200434876" /></p>
<p>图中，EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。</p>

        <h2 id="示例代码"   >
          <a href="#示例代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h2>
      

        <h3 id="filereader"   >
          <a href="#filereader" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#filereader"></a> FileReader</h3>
      
<p>文件读取类，充当子系统类。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FILEREADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEREADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileReader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">Read</span><span class="params">(<span class="type">const</span> string &amp; fileNameSrc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;读取文件，获取明文。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">fstream <span class="title">fs</span><span class="params">(fileNameSrc.c_str(), ios_base::in)</span></span>;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">if</span>(fs.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(fs &gt;&gt; s)</span><br><span class="line">            &#123;</span><br><span class="line">                ss &lt;&lt; s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不能打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h3 id="ciphermachine"   >
          <a href="#ciphermachine" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ciphermachine"></a> CipherMachine</h3>
      
<p>数据加密类，充当子系统类。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CIPHERMACHINE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIPHERMACHINE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CipherMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">Encrypt</span><span class="params">(<span class="type">const</span> string &amp; plainText)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;数据加密，将明文转换为密文！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string es = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">vc</span><span class="params">(plainText.begin(), plainText.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; c : vc)</span><br><span class="line">        &#123;</span><br><span class="line">            es += (c % <span class="number">36</span>) + <span class="number">65</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; es &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> es;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h3 id="filewriter"   >
          <a href="#filewriter" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#filewriter"></a> FileWriter</h3>
      
<p>文件保存类，充当子系统类。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FILEWRITER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEWRITER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileWriter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">const</span> string &amp; encryptStr, <span class="type">const</span> string&amp; fileNameDes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;保存密码，写入文件。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">fstream <span class="title">fs</span><span class="params">(fileNameDes, ios_base::out)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(fs.<span class="built_in">is_open</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            fs.<span class="built_in">write</span>(encryptStr.<span class="built_in">c_str</span>(), encryptStr.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;文件写入失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h3 id="encryptfacade"   >
          <a href="#encryptfacade" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#encryptfacade"></a> EncryptFacade</h3>
      
<p>加密外观类，充当外观类。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ENCRYPTFACADE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENCRYPTFACADE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ciphermachine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;filereader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;filewriter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncryptFacade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;FileReader&gt; reader;</span><br><span class="line">    shared_ptr&lt;FileWriter&gt; writer;</span><br><span class="line">    shared_ptr&lt;CipherMachine&gt; cipher;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EncryptFacade</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        reader = <span class="built_in">make_shared</span>&lt;FileReader&gt;();</span><br><span class="line">        cipher = <span class="built_in">make_shared</span>&lt;CipherMachine&gt;();</span><br><span class="line">        writer = <span class="built_in">make_shared</span>&lt;FileWriter&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FileEncrypt</span><span class="params">(<span class="type">const</span> string &amp; fileNameSrc, <span class="type">const</span> string &amp; fileNameDes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string plainStr = reader-&gt;<span class="built_in">Read</span>(fileNameSrc);</span><br><span class="line">        string encryptStr = cipher-&gt;<span class="built_in">Encrypt</span>(plainStr);</span><br><span class="line">        writer-&gt;<span class="built_in">Write</span>(encryptStr, fileNameDes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h2 id="客户端代码"   >
          <a href="#客户端代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端代码"></a> 客户端代码</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;encryptfacade.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;EncryptFacade&gt; ef = <span class="built_in">make_unique</span>&lt;EncryptFacade&gt;();</span><br><span class="line">    ef-&gt;<span class="built_in">FileEncrypt</span>(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;./code.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="运行结果"   >
          <a href="#运行结果" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读取文件，获取明文。(19060212119ChenggongXing)</span><br><span class="line">数据加密，将明文转换为密文！</span><br><span class="line">NVMSMNONNV`a^C``DC`QbC`</span><br><span class="line">保存密码，写入文件。</span><br></pre></td></tr></table></div></figure>
<p>发现，目录下多了一个code.txt，里面存放的是密文。</p>

        <h1 id="抽象外观类"   >
          <a href="#抽象外观类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#抽象外观类"></a> 抽象外观类</h1>
      
<p>在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类来对系统进行改进，在一定程度上可以解决该问题。</p>
<p>在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，<strong>对于新的业务需求，不需要修改原有外观类</strong>，而是<strong>增加一个新的具体外观类</strong>，由新的具体外观类来关联新的子系统对象，同时<strong>通过修改配置文件来达到不修改任何源代码并更换外观类</strong>的目的。</p>

        <h2 id="实例分析"   >
          <a href="#实例分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实例分析"></a> 实例分析</h2>
      
<p>下面通过一个具体实例来学习如何使用抽象外观类：如果在应用实例“文件加密模块”中需要更换一个加密类，不再使用原有的基于求模运算的加密类CipherMachine，而改为新加密类NewCipherMachine，其代码如下：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NEWCIPHERMACHINE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWCIPHERMACHINE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewCipherMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">Encrypt</span><span class="params">(<span class="type">const</span> string &amp; plainText)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;数据加密，将明文转换为密文！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string es = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">vc</span><span class="params">(plainText.begin(), plainText.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; c : vc)</span><br><span class="line">        &#123;</span><br><span class="line">            es += (c % <span class="number">36</span>) + <span class="number">60</span>;	<span class="comment">//由原来的+65变为+60</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; es &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> es;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>
<p>如果不增加新的外观类，只能通过修改原有外观类EncryptFacade的源代码来实现加密类的更换，将原有的对CipherMachine类型对象的引用改为对NewCipherMachine类型对象的引用，这违背了开闭原则，因此需要通过增加新的外观类来实现对子系统对象引用的改变。</p>

        <h2 id="解决方案"   >
          <a href="#解决方案" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2>
      
<p>如果增加一个新的外观类NewEncryptFacade来与FileReader类、FileWriter类以及新增加的NewCipherMachine类进行交互，虽然原有系统类库无须做任何修改，但是因为客户端代码中原来针对EncryptFacade类进行编程，现在需要改为NewEncryptFacade类，因此需要修改客户端源代码。</p>
<p>如何在不修改客户端代码的前提下使用新的外观类呢？</p>
<p>解决方法之一是：引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类，引入抽象外观类之后的文件加密模块结构图如图所示：</p>
<p><img src="../../images/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20220510085052559.png" alt="image-20220510085052559" /></p>

        <h2 id="代码实现"   >
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
      
<ul>
<li>抽象外观类AbstractEncryptFacade</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ABSTRACTENCRYPTFACADE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABSTRACTENCRYPTFACADE_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractEncryptFacade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FileEncrypt</span><span class="params">(<span class="type">const</span> string &amp; fileNameSrc, <span class="type">const</span> string &amp; fileNameDes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>
<ul>
<li>新增具体加密外观类NewEncryptFacade代码如下：</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NEWENCRYPTFACADE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWENCRYPTFACADE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;abstractencryptfacade.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;newciphermachine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;filereader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;filewriter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewEncryptFacade</span> : <span class="keyword">public</span> AbstractEncryptFacade</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;FileReader&gt; reader;</span><br><span class="line">    shared_ptr&lt;FileWriter&gt; writer;</span><br><span class="line">    shared_ptr&lt;NewCipherMachine&gt; cipher;	<span class="comment">//new</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewEncryptFacade</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        reader = <span class="built_in">make_shared</span>&lt;FileReader&gt;();</span><br><span class="line">        cipher = <span class="built_in">make_shared</span>&lt;NewCipherMachine&gt;();</span><br><span class="line">        writer = <span class="built_in">make_shared</span>&lt;FileWriter&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 实现抽象函数 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FileEncrypt</span><span class="params">(<span class="type">const</span> string &amp; fileNameSrc, <span class="type">const</span> string &amp; fileNameDes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string plainStr = reader-&gt;<span class="built_in">Read</span>(fileNameSrc);</span><br><span class="line">        string encryptStr = cipher-&gt;<span class="built_in">Encrypt</span>(plainStr);</span><br><span class="line">        writer-&gt;<span class="built_in">Write</span>(encryptStr, fileNameDes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h2 id="引入配置文件"   >
          <a href="#引入配置文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#引入配置文件"></a> 引入配置文件</h2>
      
<p>我们的配置文件使用json来处理，引入一个适用于cpp的json第三方库，使用json.hpp。</p>
<figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cipher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;new&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>还需要写对应配套的map映射生成具体使用的对象。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;abstractencryptfacade.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;encryptfacade.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;newencryptfacade.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;functional&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;string, function&lt;unique_ptr&lt;AbstractEncryptFacade&gt;()&gt;&gt; s_facade_map = </span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;old&quot;</span>, []()-&gt;unique_ptr&lt;AbstractEncryptFacade&gt; &#123;<span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;EncryptFacade&gt;();&#125;&#125;,</span><br><span class="line">    &#123; <span class="string">&quot;new&quot;</span>, []()-&gt;unique_ptr&lt;AbstractEncryptFacade&gt; &#123;<span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;NewEncryptFacade&gt;();&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

        <h2 id="客户端改写"   >
          <a href="#客户端改写" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#客户端改写"></a> 客户端改写</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;encryptfacade.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json j;</span><br><span class="line">    <span class="function">ifstream <span class="title">jfile</span><span class="params">(<span class="string">&quot;../config.json&quot;</span>)</span></span>;</span><br><span class="line">    jfile &gt;&gt; j;</span><br><span class="line">    jfile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    unique_ptr&lt;AbstractEncryptFacade&gt; ef = s_facade_map[j.<span class="built_in">at</span>(<span class="string">&quot;cipher&quot;</span>)]();</span><br><span class="line">    ef-&gt;<span class="built_in">FileEncrypt</span>(<span class="string">&quot;../file.txt&quot;</span>, <span class="string">&quot;../code.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读取文件，获取明文。</span><br><span class="line">数据加密，将明文转换为密文！</span><br><span class="line">IQHNHIJIIQ[\Y&gt;[[?&gt;[L]&gt;[</span><br><span class="line">保存密码，写入文件。</span><br></pre></td></tr></table></div></figure>
<p>原有外观类EncryptFacade也需作为抽象外观类AbstractEncryptFacade类的子类，更换具体外观类时只需修改配置文件，无须修改源代码，符合开闭原则。</p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
      
<p>外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。</p>
<p>在几乎所有的软件中都能够找到外观模式的应用，如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度。所有涉及到与多个业务对象交互的场景都可以考虑使用外观模式进行重构。</p>

        <h2 id="优点"   >
          <a href="#优点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2>
      
<ol>
<li>它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</li>
<li>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</li>
<li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li>
</ol>

        <h2 id="缺点"   >
          <a href="#缺点" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2>
      
<ol>
<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li>
</ol>

        <h2 id="适用场景"   >
          <a href="#适用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h2>
      
<p>在以下情况下可以考虑使用外观模式：</p>
<ol>
<li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</li>
<li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Linux/Linux_%E5%BA%93/">Linux_库</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-13</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/Linux/Linux_%E5%BA%93/" data-flag-title="Linux_库"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>库文件</li>
<li>静态库</li>
<li>共享库（动态链接库）</li>
</ol>

        <h1 id="一段代码"   >
          <a href="#一段代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一段代码"></a> 一段代码</h1>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>众所周知，引入的<code>.h</code>文件只是引入了一堆函数的声明，在这个源代码和<code>.h</code>文件中并没有实现这些函数。那么<code>printf</code>谁帮我们实现的呢？</p>
<p>答案就是，c程序自动链接了<code>libc.so</code>库文件。</p>

        <h1 id="举例"   >
          <a href="#举例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#举例"></a> 举例</h1>
      
<p>C语言编程中经常使用的<code>printf()</code>，显然不是我们自己实现的，它是在c标准库中实现的。c标准库即<code>libc.so</code>（后面带<code>.6</code>表示版本号，如<code>libc.so.6</code>），此库文件在系统中充当共享库。</p>
<p>库中存放的是什么？——预先编译好的方法，把这些方法打包为一个集合，就是库文件。</p>
<p>比如，<code>add.c</code>、<code>max.c</code>分别编译为<code>add.o</code>、<code>max.o</code>，把编译好的二进制文件打包到<code>libfoo.a</code>或<code>libfoo.so</code>。以后我们要是想使用<code>add.o</code>或<code>max.o</code>中的方法时，链接<code>libfoo</code>库即可成功调用。为了方便他人使用，往往会给调用方再提供一个头文件<code>foo.h</code>，以声明此库中包含哪些接口。</p>

        <h1 id="库文件"   >
          <a href="#库文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#库文件"></a> 库文件</h1>
      
<p>预先编译好的方法（函数）的集合。</p>
<p>库文件通常存放到<code>/lib</code>、<code>/usr/lib</code>下。</p>
<p>头文件通常存放到<code>/usr/include</code>下。</p>

        <h2 id="库文件使编译链接方便了"   >
          <a href="#库文件使编译链接方便了" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#库文件使编译链接方便了"></a> 库文件使编译链接方便了</h2>
      
<ul>
<li>我们编写第一个版本的代码，只有一个文件<code>main.c</code></li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此版本我们把<code>add</code>函数的声明、实现全部写到了此文件中。</p>
<p>测试编译链接——单文件的编译链接很方便。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c</span><br></pre></td></tr></table></div></figure>
<p>按上面语句编译即可成功。</p>
<ul>
<li>我们编写第二个版本的代码，把add函数抽出来写到第二个文件中。</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>改写main.c，对于add函数只在此文件中声明</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此时如果再像第一次那样编译就行不通了<code>gcc -o main main.c</code>，报错：</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220507200930308.png" alt="image-20220507200930308" /></p>
<p>这时，就得这样编译链接才能通过：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c add.c</span><br></pre></td></tr></table></div></figure>
<p>后面得加个<code>add.c</code>才行。</p>
<p><strong>这时，就很有可能出现了一个现象：好多人可能都需要调用<code>add.c</code>里面的函数</strong>。</p>
<p>此时出现了诸多问题：</p>
<ol>
<li>如果直接给你add.c，这个源码就要暴露给所有人了，不利于隐藏代码实现细节。</li>
<li>实际上，<code>gcc -o main main.c add.c</code>不是一步到位生成main的，而是隐藏了好多过程，如果大家都要用add.c那么大家在每一次生成main之前，都需要另外先编译好add.c，才能与main.o链接生成main。这样重复的工作我们是要想办法避免的，即直接给你编译好的<code>.o</code>文件。</li>
</ol>
<p>针对以上问题，我们<code>gcc -c add.c</code>编译add.c文件为.o文件。直接给用户编译好的<code>.o</code>文件，即可解决此问题。</p>
<p>此时，我们要想通过<code>main.c</code>和<code>add.o</code>生成<code>main</code>可执行文件时，可以如此：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c add.o</span><br></pre></td></tr></table></div></figure>
<p>生成<code>.o</code>文件解决了两个问题，接下来的问题：<strong>以后我们可能不止有<code>add.o</code>，还可能有很多其他的<code>.o</code>文件，比如<code>max.o</code>。能不能打包为一个文件呢？这样就很方便了。——这就是库文件</strong>。</p>

        <h1 id="静态库"   >
          <a href="#静态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#静态库"></a> 静态库</h1>
      
<p><code>libxx.a</code>。</p>
<p>编译链接时，把被链接的库程序的一部分包含到要生成的可执行文件中。</p>

        <h2 id="如何生产静态库ar命令"   >
          <a href="#如何生产静态库ar命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何生产静态库ar命令"></a> 如何生产静态库？ar命令</h2>
      
<p>我们把<code>add.c</code>和<code>max.c</code>做成一个静态库。</p>
<p>add.c文件内容略。</p>
<p>max.c文件：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>把两个.c文件分别<code>gcc -c add.c max.c</code>生成了两个.o文件。</p>
<p>然后，使用ar命令将指出的.o文件生成静态库。</p>
<blockquote>
<p>为什么是ar呢？因为静态库的英文是archive。</p>
</blockquote>
<p>ar命令格式：<code>ar [选项] 库名 若干.o文件</code></p>
<div class="table-container"><table>
<thead>
<tr>
<th>ar命令的选项参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>创建库</td>
</tr>
<tr>
<td>r</td>
<td>将方法添加到库中</td>
</tr>
<tr>
<td>v</td>
<td>显示过程</td>
</tr>
</tbody>
</table></div>
<p>则用以下命令即可把add.o、max.o打包为一个静态库文件<code>libfoo.a</code></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar crv libfoo.a add.o max.o</span><br></pre></td></tr></table></div></figure>
<p>执行结果：<img src="../../images/Linux_%E5%BA%93/image-20220507204616204.png" alt="image-20220507204616204" /></p>

        <h2 id="链接静态库"   >
          <a href="#链接静态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#链接静态库"></a> 链接静态库</h2>
      
<p>我们当前目录下只有<code>libfoo.a</code>、<code>main.c</code>。</p>
<p>首先，<code>gcc -o main main.c</code>肯定是不能编译通过的。</p>
<p>其次，<code>gcc -o main main.c libfoo.a</code>是可以编译通过的。但是这不是一个好的办法，这样做的话每次链接需要把库文件拷贝到当前目录，而且还需要打出库的全名。</p>
<ul>
<li>标准的做法：<code>-L</code>指明库所在的目录，<code>-l</code>指明你要链接的库名。
<ul>
<li>在我们的例子中，库所在的目录是<code>.</code>；库名为<code>foo</code>，即<code>&quot;lib&quot;</code>的后半部分，不带<code>.a</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -L. -lfoo</span><br></pre></td></tr></table></div></figure>

        <h2 id="库文件及其头文件标准目录"   >
          <a href="#库文件及其头文件标准目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#库文件及其头文件标准目录"></a> 库文件及其头文件标准目录</h2>
      
<p>我们为了给调用者声明它可以通过某库文件调用哪些函数，需要另外编写一个<code>foo.h</code>头文件。</p>
<p><strong>注意，在编写<code>.c</code>文件时，需要<code>#include&lt;foo.h&gt;</code></strong>，如此就不用一个个自己声明函数了。</p>
<p>foo.h文件</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></div></figure>
<p>改写main.c文件</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;foo.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c = add(a, b);	<span class="comment">// add函数已经声明于foo.h</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>标准目录</li>
</ul>
<p>标准的位置，同时是<code>gcc</code>程序链接时默认扫描的位置是<code>/usr/include</code>。</p>
<p>相应的库文件的默认扫描位置，<code>/lib</code>、<code>/usr/lib</code>。</p>
<p>我们把我们自己编写的<code>foo.h</code>和<code>libfoo.a</code>移到标准目录。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line"><span class="built_in">mv</span> foo.h /usr/include</span><br><span class="line"><span class="built_in">mv</span> libfoo.a /usr/lib</span><br></pre></td></tr></table></div></figure>
<p>现在的编译链接过程，由于头文件、库文件都在标准目录底下，可以不加<code>-L</code>参数，但是仍然必须在后面指定<code>-l库名</code>，即<code>-lfoo</code>，便可编译链接成功。</p>
<p><strong>注意：除了链接<code>libc.so</code>c标准库，<code>-l</code>通常不可省略，这就相当于c标准库是系统亲生的，用得很多，就默认可以省略。</strong></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -lfoo</span><br></pre></td></tr></table></div></figure>

        <h1 id="动态库"   >
          <a href="#动态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#动态库"></a> 动态库</h1>
      
<p><code>libxx.so</code>。</p>
<p>编译链接时，不会把被链接的库程序的一部分包含到要生成的可执行文件中。只做一个标记，只验证链接的库有没有问题。生成的可执行文件在运行时动态地加载动态库去运行，所以动态库一旦删除则无法运行。</p>
<p>再回到那个众人皆知的代码。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>我们编译它。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c</span><br></pre></td></tr></table></div></figure>
<p>怎么证明<code>main</code>程序链接了<code>libc.so</code>库文件呢？</p>

        <h2 id="ldd命令"   >
          <a href="#ldd命令" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ldd命令"></a> ldd命令</h2>
      
<p><code>ldd</code>命令可以查看编译好的二进制程序需要链接的库文件信息。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd main</span><br></pre></td></tr></table></div></figure>
<p>我们的main程序使用到了<code>printf</code>的库，即<code>libc.so</code>，bash下输入<code>ldd main</code>的结果是：</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220507194717251.png" alt="image-20220507194717251" /></p>

        <h2 id="如何生产动态库"   >
          <a href="#如何生产动态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#如何生产动态库"></a> 如何生产动态库？</h2>
      
<p>我们把<code>add.o</code>和<code>max.o</code>做成一个动态库。</p>
<p>生成动态库，使用的是gcc命令。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfoo.so add.o max.o</span><br></pre></td></tr></table></div></figure>
<p>其中，<code>-shared</code>参数表示产生共享对象，<code>-fPIC</code>：</p>

        <h2 id="链接动态库"   >
          <a href="#链接动态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#链接动态库"></a> 链接动态库</h2>
      
<p>暂且如下编译链接main.c程序</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c ./libfoo.so</span><br></pre></td></tr></table></div></figure>
<p>这样得到了一个程序<code>main</code>，此程序使用了<code>libfoo.so</code>里面的<code>add</code>函数。从<code>main.c</code>的角度看，自己被链接成为可执行文件的这一步，在之前的静态链接中会把<code>main.o</code>和<code>libfoo.so</code>结合到一起。但是在动态链接里，<code>libfoo.so</code>没有被链接进来，链接的输入目标文件只有<code>main.o</code>（当然还有C语言运行库，我们这里暂时忽略）。但是上面gcc的命令行中，后面也加上了<code>./libfoo.so</code>这是咋回事？</p>
<blockquote>
<ul>
<li><strong>关于模块</strong></li>
</ul>
<p>在静态链接时，整个程序最终只有一个可执行文件，它是一个不可分割的整体；</p>
<p>但在动态链接下，一个程序被分成了若干个文件，有程序的主要部分，即可执行文件<code>main</code>和程序所依赖的共享对象<code>libfoo.so</code>。很多时候我们把这些部分称为模块，即动态链接下的可执行文件和共享对象都可看作是程序的模块。</p>
</blockquote>

        <h2 id="动态链接的原理细节"   >
          <a href="#动态链接的原理细节" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#动态链接的原理细节"></a> 动态链接的原理细节</h2>
      
<p>谈谈动态链接的机制，当程序模块<code>main.c</code>被编译成为<code>main.o</code>时，编译器还不知道<code>add</code>函数的地址。当链接器将<code>main.o</code>链接成可执行文件时，这时候<strong>链接器必须确定<code>main.o</code>中所引用的<code>add</code>函数的性质</strong>：</p>
<ol>
<li>如果<code>add</code>是一个定义于其他静态目标模块中的函数，那么链接器将会按照静态链接的规则，将<code>main.o</code>中的<code>add</code>地址引用<strong>重定位</strong>；</li>
<li>如果<code>add</code>是一个定义在某个动态共享对象中的函数，<strong>那么链接器就会将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行</strong>。</li>
</ol>
<p>那么这里就有个问题，链接器如何知道<code>add</code>的引用是一个静态符号还是一个动态符号？这实际上就是我们的gcc命令后面要写<code>libfoo.so</code>的原因。<code>libfoo.so</code>中保存了完整的符号信息（因为运行时进行动态链接还须使用符号信息)，把<code>libfoo.so</code>也作为链接的输入文件之一，链接器在解析符号时就可以知道：<code>add</code>是一个定义在<code>libfoo.so</code>的动态符号。这样链接器就可以对<code>add</code>的引用做特殊的处理，使它成为一个对动态符号的引用。</p>

        <h2 id="动态链接程序运行时地址空间分布"   >
          <a href="#动态链接程序运行时地址空间分布" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#动态链接程序运行时地址空间分布"></a> 动态链接程序运行时地址空间分布</h2>
      
<p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，那就是可执行文件本身，静态链接下的进程虚拟地址空间的分布很清晰明了。但是对于动态链接来说，除了可执行文件本身之外，还有它所依赖的共享目标文件。那么这种情况下，进程的地址空间分布又会怎样呢？</p>
<p>我们还是以上面的程序为例，我们对程序做适当的修改，在<code>main.c</code>中里面调用<code>sleep</code>函数。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">xcg@instance-bkdrtyrm:~/ld-learn$ ./main &amp;</span><br><span class="line">[1] 764261</span><br><span class="line">xcg@instance-bkdrtyrm:~/ld-learn$ 10 + 20 = 30</span><br><span class="line"><span class="built_in">cat</span> /proc/764261/maps </span><br><span class="line">55f2437e2000-55f2437e3000 r--p 00000000 <span class="built_in">fc</span>:01 1201223            /home/xcg/ld-learn/main</span><br><span class="line">55f2437e3000-55f2437e4000 r-xp 00001000 <span class="built_in">fc</span>:01 1201223            /home/xcg/ld-learn/main</span><br><span class="line">55f2437e4000-55f2437e5000 r--p 00002000 <span class="built_in">fc</span>:01 1201223            /home/xcg/ld-learn/main</span><br><span class="line">55f2437e5000-55f2437e6000 r--p 00002000 <span class="built_in">fc</span>:01 1201223            /home/xcg/ld-learn/main</span><br><span class="line">55f2437e6000-55f2437e7000 rw-p 00003000 <span class="built_in">fc</span>:01 1201223            /home/xcg/ld-learn/main</span><br><span class="line">55f244377000-55f244398000 rw-p 00000000 00:00 0                  [heap]</span><br><span class="line">7f814f30e000-7f814f311000 rw-p 00000000 00:00 0 </span><br><span class="line">7f814f311000-7f814f333000 r--p 00000000 <span class="built_in">fc</span>:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7f814f333000-7f814f4ab000 r-xp 00022000 <span class="built_in">fc</span>:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7f814f4ab000-7f814f4f9000 r--p 0019a000 <span class="built_in">fc</span>:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7f814f4f9000-7f814f4fd000 r--p 001e7000 <span class="built_in">fc</span>:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7f814f4fd000-7f814f4ff000 rw-p 001eb000 <span class="built_in">fc</span>:01 394589             /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">7f814f4ff000-7f814f503000 rw-p 00000000 00:00 0 </span><br><span class="line">7f814f50b000-7f814f50c000 r--p 00000000 <span class="built_in">fc</span>:01 1201222            /home/xcg/ld-learn/libfoo.so</span><br><span class="line">7f814f50c000-7f814f50d000 r-xp 00001000 <span class="built_in">fc</span>:01 1201222            /home/xcg/ld-learn/libfoo.so</span><br><span class="line">7f814f50d000-7f814f50e000 r--p 00002000 <span class="built_in">fc</span>:01 1201222            /home/xcg/ld-learn/libfoo.so</span><br><span class="line">7f814f50e000-7f814f50f000 r--p 00002000 <span class="built_in">fc</span>:01 1201222            /home/xcg/ld-learn/libfoo.so</span><br><span class="line">7f814f50f000-7f814f510000 rw-p 00003000 <span class="built_in">fc</span>:01 1201222            /home/xcg/ld-learn/libfoo.so</span><br><span class="line">7f814f510000-7f814f512000 rw-p 00000000 00:00 0 </span><br><span class="line">7f814f512000-7f814f513000 r--p 00000000 <span class="built_in">fc</span>:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7f814f513000-7f814f536000 r-xp 00001000 <span class="built_in">fc</span>:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7f814f536000-7f814f53e000 r--p 00024000 <span class="built_in">fc</span>:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7f814f53f000-7f814f540000 r--p 0002c000 <span class="built_in">fc</span>:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7f814f540000-7f814f541000 rw-p 0002d000 <span class="built_in">fc</span>:01 394574             /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">7f814f541000-7f814f542000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffc5ff25000-7ffc5ff46000 rw-p 00000000 00:00 0                  [stack]</span><br><span class="line">7ffc5fff5000-7ffc5fff8000 r--p 00000000 00:00 0                  [vvar]</span><br><span class="line">7ffc5fff8000-7ffc5fff9000 r-xp 00000000 00:00 0                  [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0          [vsyscall]</span><br></pre></td></tr></table></div></figure>
<p>我们看到，整个进程虚拟地址空间中，多出了几个文件的映射：</p>
<ol>
<li>
<p><code>libfoo.so</code>与<code>main</code>一样，它们都是被操作系统用同样的方法映射至进程的虚拟地址空间，只是<strong>它们占据的虚拟地址和长度不同</strong>。</p>
</li>
<li>
<p><code>main</code>除了使用<code>libfoo.so</code>以外，它还用到了动态链接形式的C语言运行库<code>libc-2.31.so</code>。</p>
</li>
<li>
<p>另外还有一个很值得关注的共享对象就是<code>ld-2.31.so</code>，它实际上是Linux下的动态链接器。动态链接器与普通共享对象一样被映射到了进程的地址空间。</p>
</li>
</ol>
<p>在系统开始运行<code>main</code>之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给<code>main</code>，然后开始执行。</p>
<p>我们通过readelf工具来查看<code>libfoo.so</code>的装载属性，就如我们在前面查看普通程序一样：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l libfoo.so</span><br></pre></td></tr></table></div></figure>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">xcg@instance-bkdrtyrm:~/ld-learn$ readelf -l libfoo.so </span><br><span class="line"></span><br><span class="line">Elf file <span class="built_in">type</span> is DYN (Shared object file)</span><br><span class="line">Entry point 0x1040</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x00000000000004c8 0x00000000000004c8  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000</span><br><span class="line">                 0x0000000000000139 0x0000000000000139  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000</span><br><span class="line">                 0x00000000000000cc 0x00000000000000cc  R      0x1000</span><br><span class="line">  LOAD           0x0000000000002e80 0x0000000000003e80 0x0000000000003e80</span><br><span class="line">                 0x00000000000001a0 0x00000000000001a8  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000002e90 0x0000000000003e90 0x0000000000003e90</span><br><span class="line">                 0x0000000000000150 0x0000000000000150  RW     0x8</span><br><span class="line">  NOTE           0x00000000000002a8 0x00000000000002a8 0x00000000000002a8</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  NOTE           0x00000000000002c8 0x00000000000002c8 0x00000000000002c8</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      0x4</span><br><span class="line">  GNU_PROPERTY   0x00000000000002a8 0x00000000000002a8 0x00000000000002a8</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  GNU_EH_FRAME   0x0000000000002000 0x0000000000002000 0x0000000000002000</span><br><span class="line">                 0x000000000000002c 0x000000000000002c  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000002e80 0x0000000000003e80 0x0000000000003e80</span><br><span class="line">                 0x0000000000000180 0x0000000000000180  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.property .note.gnu.build-id .gnu.hash .dynsym .dynstr .rela.dyn </span><br><span class="line">   01     .init .plt .plt.got .text .fini </span><br><span class="line">   02     .eh_frame_hdr .eh_frame </span><br><span class="line">   03     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   04     .dynamic </span><br><span class="line">   05     .note.gnu.property </span><br><span class="line">   06     .note.gnu.build-id </span><br><span class="line">   07     .note.gnu.property </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got</span><br></pre></td></tr></table></div></figure>
<p>动态库文件除了文件的类型与普通程序不同以外，其他几乎与普通程序一样。有一点比较不同的是，<strong>动态链接模块的装载地址是从地址<code>0x00000000</code>开始的</strong>。我们知道这个地址是无效地址，并且从<strong>上面的进程虚拟空间分布看到，<code>libfoo.so</code>的最终装载地址并不是<code>0x00000000</code>，而是其他具体值</strong>。从这一点我们可以推断，<strong>共享对象的最终装载地址在编译时是不确定的</strong>，而<strong>是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象</strong>。</p>
<p>当然，这仅仅是一个推断，至于为什么要这样做，为什么不将每个共享对象在进程中的地址固定，或者在真正的系统中是怎么运作的？</p>

        <h2 id="装载地址"   >
          <a href="#装载地址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#装载地址"></a> 装载地址</h2>
      
<p>我们设想是否可以让共享对象在任意地址加载？这个问题另一种表述方法就是：共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。与此不同的是，可执行文件基本可以确定自己在进程虚拟空间中的起始位置，因为可执行文件往往是第一个被加载的文件，它可以选择一个固定空闲的地址，比如Linux下一般都是0x08040000，Windows下一般都是0x0040000。</p>

        <h3 id="装载时重定位"   >
          <a href="#装载时重定位" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#装载时重定位"></a> 装载时重定位</h3>
      
<p>为了能够使共享对象在任意地址装载，我们首先能想到的方法就是静态链接中的重定位。这个想法的基本思路是在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。假设函数<code>add</code>相对于代码段的起始地址是0x100，当模块被装载到0x10000000时，我们假设代码段位于模块的最开始，即代码段的装载地址也是0x10000000，那么我们就可以确定<code>add</code>的地址为0x10000100。这时候，系统遍历模块中的重定位表，把所有对<code>add</code>的地址引用都重定位至0x10000100。</p>
<p>事实上，类似的方法在很早以前就存在。早在没有虚拟存储概念的情况下，程序是直接被装载进物理内存的。当同时有多个程序运行的时候，操作系统根据当时内存空闲情况，动态分配一块大小合适的物理内存给程序，所以程序被装载的地址是不确定的。系统在装载程序的时候需要对程序的指令和数据中对绝对地址的引用进行重定位。但这种重定位比前面提到过的静态链接中的重定位要简单得多，因为整个程序是按照一个整体被加载的，程序中指令和数据的相对位置是不会改变的。比如一个程序在编译时假设被装载的目标地址为0x1000，但是在装载时操作系统发现0x1000这个地址已经被别的程序使用了，从0x4000开始有一块足够大的空间可以容纳该程序，那么该程序就可以被装载至0x4000，程序指令或数据中的所有绝对引用只要都加上0x3000的偏移量就可以了。</p>
<p>我们前面在静态链接时提到过重定位，那时的重定位叫做<strong>链接时重定位</strong>(Link Time Relocation)，而现在这种情况经常被称为<strong>装载时重定位</strong>(Load Time Relocation)。在Windows中，这种装载时重定位又被叫做<strong>基址重置</strong>(Rebasing)。</p>
<p>这种情况与我们碰到的问题很相似，<strong>都是程序模块在编译时目标地址不确定而需要在装载时将模块重定位</strong>。但是装载时重定位的方法并不适合用来解决上面的共享对象中所存在的问题。可以想象，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，<strong>由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来讲是不同的</strong>。当然，动态连接库中的可修改数据部分对于不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。</p>
<p>Liux和GCC支持这种装载时重定位的方法，我们前面在产生共享对象时，使用了两个GCC参数<code>-shared</code>和<code>-fPIC</code>，如果只使用<code>-shared</code>，那么输出的共享对象就是使用装载时重定位的方法。</p>

        <h3 id="地址无关代码"   >
          <a href="#地址无关代码" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#地址无关代码"></a> 地址无关代码</h3>
      
<p>那么什么是<code>-fPIC</code>呢？使用这个参数会有什么效果呢？</p>
<p>装载时重定位是<strong>解决动态模块中有绝对地址引用</strong>的办法之一，但是它有一个很大的<strong>缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势</strong>。我们还需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题。其实我们的目的很简单，<strong>希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变</strong>，所以实现的基本想法就是<strong>把指令中那些需要被修改的部分分离出来</strong>，<strong>跟数据部分放在一起</strong>，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是目前被称为<strong>地址无关代码(PIC, Position-independent Code)的技术</strong>。</p>
<p>对于现代的机器来说，产生地址无关的代码并不麻烦。我们先来分析模块中各种类型的地址引用方式。</p>

        <h4 id="模块中各种类型的地址引用方式"   >
          <a href="#模块中各种类型的地址引用方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#模块中各种类型的地址引用方式"></a> 模块中各种类型的地址引用方式</h4>
      
<ol>
<li><strong>把共享对象模块中的地址引用按照是否为跨模块分成两类</strong>：模块内部引用和模块外部引用；</li>
<li><strong>按照不同的引用方式</strong>又可以分为指令引用（函数）和数据访问。</li>
</ol>
<p>则得到了4种情况。</p>
<ol>
<li>模块内部的函数调用、跳转等。</li>
<li>模块内部的数据访问，比如模块中定义的全局变量、静态变量。</li>
<li>是模块外部的函数调用、跳转等。</li>
<li>是模块外部的数据访问，比如其他模块中定义的全局变量。</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ext</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1</span>;	<span class="comment">//case 2, inner-module data</span></span><br><span class="line">    b = <span class="number">2</span>;	<span class="comment">//case 4, inter-module data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bar();	<span class="comment">//case 1, inner-module function</span></span><br><span class="line">    ext();	<span class="comment">//case 3, inter-module function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<ul>
<li><strong>关于模块内部和模块外部</strong></li>
</ul>
<p>当编译器在编译时，它实际上并不能确定变量b和函数ext()是模块外部的还是模块内部的，因为它们有可能被定义在同一个共享对象的其他目标文件中。由于没法确定，编译器只能把它们都当作模块外部的函数和变量来处理。MSVC编译器提供了<code>__declspec(dllimport)</code>编译器扩展来表示一个符号是模块内部的还是模块外部的。</p>
</blockquote>
<ul>
<li>模块内部调用或跳转</li>
</ul>
<p>这4种情况中，第一种类型应该是最简单的，那就是模块内部调用。因为被调用的函数与调用者都处于同一个模块，它们之间的相对位置是固定的，所以这种情况比较简单。对于现代的系统来讲，模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。比如上面例子中foo对bar的调用可能产生如下代码：</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509112233608.png" alt="image-20220509112233608" /></p>
<p>foo中对bar的调用的那条指令实际上是一条相对地址调用指令，相对偏移调用指令如图。<br />
<img src="../../images/Linux_%E5%BA%93/image-20220509151553766.png" alt="image-20220509151553766" /></p>
<p>这条指令中的后4个字节是目的地址相对于当前指令的下一条指令的偏移，即<code>0xFFFFFFE8</code>（小端）。<code>0xFFFFFFE8</code>是<code>-24</code>的补码形式，即<code>bar</code>的地址为<code>0x804835c+(-24)=0x8048344</code>。那么只要bar和foo的相对位置不变，这条指令是地址无关的。即无论模块被装载到哪个位置，这条指令都是有效的。这种相对地址的方式对于jmp指令也有效。</p>
<p>这样看起来第一个模块内部调用或跳转很容易解决，但实际上这种方式还有一定的问题，这里存在一个叫做<strong>共享对象全局符号介入(Global Symbol Interposition)问题</strong>，但在这里，可以简单地把它当作相对地址调用/跳转。</p>
<ul>
<li>模块内部数据访问</li>
</ul>
<p>接着来看看第二种类型，模块内部的数据访问。很明显，指令中不能直接包含数据的绝对地址，那么唯一的办法就是<strong>相对寻址</strong>。我们知道，一个模块前面一般是若干个页的代码，后面紧跟着若千个页的数据，这些页之间的相对位置是固定的，也就是说，<strong>任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的</strong>，那么<strong>只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据</strong>了。</p>
<p>现代的体系结构中，数据的相对寻址往往没有相对与当前指令地址（PC）的寻址方式，所以ELF用了一个很巧妙的办法来得到当前的PC值，然后再加上一个偏移量就可以达到访问相应变量的目的了。得到PC值的方法很多，我们来看看最常用的一种，也是现在ELF的共享对象里面用的一种方法：</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509141654740.png" alt="image-20220509141654740" /></p>
<p>这是对上面的例子中的代码先编译成共享对象然后反汇编的结果。用粗体表示的是<code>bar()</code>函数中访问模块内部变量<code>a</code>的相应代码。</p>
<p>从上面的指令中可以看到，它先调用了一个叫<code>__i686.get_pc_thunk.cx</code>的函数，这个函数的作用就是把返回地址的值放到ecx寄存器，即把call的下一条指令的地址放到ecx寄存器。</p>
<blockquote>
<p>我们知道当处理器执行call指令以后，下一条指令的地址会被压到栈顶，而esp寄存器就是始终指向栈顶的，那么当<code>__i686.get_pc_thunk.cx</code>执行<code>mov(%esp), %ecx</code>的时候，返回地址就被赋值到ecx寄存器了。</p>
</blockquote>
<p>接着执行一条add指令和一条mov指令，可以看到变量<code>a</code>的地址是add指令地址（保存在ecx寄存器）加上两个偏移量<code>0x118c</code>和<code>0x28</code>（<code>0x28(%ecx)</code>相当于<code>%ecx+0x28</code>），即如果模块被装载到<code>0x10000000</code>这个地址的话，那么变量a的实际地址将是<code>0x10000000+0x454+0x118c+0x28=0x10001608</code>。</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509151732270.png" alt="image-20220509151732270" /></p>
<ul>
<li>模块间数据访问</li>
</ul>
<p>模块间的数据访问比模块内部稍微麻烦一点，因为模块间的数据访问目标地址要等到装载时才决定，比如上面例子中的变量b，它被定义在其他模块中，并且该地址在装载时才能确定。我们前面提到要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面，很明显，这些其他模块的全局变量的地址是跟模块装载地址有关的。<strong>ELF的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表</strong>(GlobalOffset Table, GOT)，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用，它的基本机制如图所示。<br />
<img src="../../images/Linux_%E5%BA%93/image-20220509153306467.png" alt="image-20220509153306467" /></p>
<p>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4个字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<p>我们来看看GOT如何做到指令的地址无关性。从第二种类型的数据访问我们了解到，模块在编译时可以确定模块内部变量相对与当前指令的偏移，那么我们也可以<strong>在编译时确定GOT相对于当前指令的偏移</strong>。确定GOT的位置跟上面的访问变量a的方法基本一样，通过得到PC值然后加上一个偏移量，就可以得到GOT的位置。然后我们根据变量地址在GOT中的偏移就可以得到变量的地址，当然GOT中每个地址对应于哪个变量是由编译器决定的，比如第一个地址对应变量b，第二个对应变量c等。</p>
<p>让我们再回顾刚才函数<code>bar()</code>的反汇编代码。为访问变量b，我们的程序首先计算出变量b的地址在GOT中的位置，即<code>0x10000000+0x454+0x118c+(-8)=0x100015d8</code>（<code>0xfffffff8</code>为<code>-8</code>的补码表示），然后使用寄存器间接寻址方式给变量b赋值2。</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509141654740.png" alt="image-20220509141654740" /></p>
<p>我们也可以使用objdump来查看GOT的位置：</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509154001142.png" alt="image-20220509154001142" /></p>
<p>可以看到GOT在文件中的偏移是<code>0x15d0</code>，我们再来看看<code>pic.so</code>的需要在动态链接时重定位项：</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509154033873.png" alt="image-20220509154033873" /></p>
<p>可以看到变量b的地址需要重定位，它位于<code>0x15d8</code>，也就是GOT中偏移8，相当于是GOT中的第三项(每四个字节一项) 。从上面重定位项中看到，变量b的地址的偏移为<code>0x15d8</code>，正好对应了我们前面通过指令计算出来的偏移值，即<code>0x100015d8-0x10000000=0x15d8</code>。</p>
<ul>
<li>模块间调用、跳转</li>
</ul>
<p>对于模块间调用和跳转，我们也可以采用上面的方法来解决。与上面的类型有所不同的是，GOT中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转，基本的原理如图所示。<br />
<img src="../../images/Linux_%E5%BA%93/image-20220509154400584.png" alt="image-20220509154400584" /></p>
<p>调用<code>ext()</code>函数的方法与上面访问变量b的方法基本类似，先得到当前指令地址PC，然后加上一个偏移得到函数地址在GOT中的偏移，然后一个间接调用。</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509154449640.png" alt="image-20220509154449640" /></p>
<ul>
<li>小结</li>
</ul>
<p>4种地址引用方式在理论上都实现了地址无关性，将它们总结一下，如表。</p>
<p><img src="../../images/Linux_%E5%BA%93/image-20220509154617511.png" alt="image-20220509154617511" /></p>

        <h2 id="-fpic"   >
          <a href="#-fpic" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#-fpic"></a> -fPIC</h2>
      
<p>生成动态库用到的参数<code>fPIC</code>即是指明GCC产生地址无关代码。实际上GCC还提供了另外一个类似的参数叫做<code>-fpic</code>，即<code>PIC</code>3个字母小写。这两个参数从功能上来讲完全一样，都是指示GCC产生地址无关代码。唯一的区别是，<code>-fPIC</code>产生的代码要大，而<code>-fpic</code>产生的代码相对较小，而且较快。</p>
<p>那么我们为什么不使用<code>-fpic</code>而要使用<code>-fPIC</code>呢？原因是，由于地址无关代码都是跟硬件平台相关的，不同的平台有着不同的实现， <code>-fpic</code>在某些平台上会有一些限制，比如全局符号的数量或者代码的长度等，而<code>-fPIC</code>则没有这样的限制。所以为了方便起见，绝大部分情况下我们都使用<code>-fPIC</code>参数来产生地址无关代码。</p>
<ul>
<li>如何区分一个DSO(Dynamic Shared Object, 动态共享对象)是否为PIC？</li>
</ul>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -d foo.so | grep TEXTREL</span><br></pre></td></tr></table></div></figure>
<p>如果上面的命令有任何输出那么<code>foo.so</code>就不是PIC的，否则为PIC的。因为PIC的DSO是不会包含任何代码段重定位表的，TEXTREL表示代码段重定位表地址。</p>
<ul>
<li>PIC与PIE</li>
</ul>
<p>地址无关代码技术除了可以用在共享对象上面，它也可以用于可执行文件，一个以地址无关方式编译的可执行文件被称作地址无关可执行文件(PIE, Position-Independent Executable)。与GCC的<code>-fPIC</code>和<code>-fpic</code>参数类似，产生PIE的参数为<code>-fPIE</code>或<code>-f pie</code>。</p>

        <h2 id="共享模块的全局变量问题"   >
          <a href="#共享模块的全局变量问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#共享模块的全局变量问题"></a> 共享模块的全局变量问题</h2>
      
<p>在谈到动态库的装载地址时，说到了地址无关性问题。地址无关性问题就这么解决了吗？看起来好像是的。但仔细看看前面的4种地址引用方式的分类，会有一个小问题：我们上面的情况中没有包含<strong>定义在模块内部的全局变量</strong>的情况。把它跟模块内部的静态变量一样处理可以吗？的确，粗略一看模块内部的全局变量和静态变量的地址都可以通过上面所列出的类型两种方法来解决。但是有一种情况很特殊，我们来看看会产生什么问题。</p>
<p>有一种很特殊的情况是，当<strong>一个模块引用了一个定义在共享对象的全局变量</strong>的时候，比如一个共享对象定义了一个全局变量global，而模块module.c中是这么引用的：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global;	<span class="comment">//定义在一个共享对象</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    global = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>当编译器编译module.c时，它<strong>无法根据这个上下文判断global是定义在同一个模块的的其他目标文件还是定义在另外一个共享对象之中</strong>，即<strong>无法判断是否为跨模块间的调用</strong>。<br />
假设module.c是程序可执行文件的一部分，那么在这种情况下，由于程序主模块的代码并不是地址无关代码，也就是说代码不会使用这种类似于PIC的机制，它引用这个全局变量的方式跟普通数据访问方式一样，编译器会产生这样的代码：<br />
<code>movl $0x1, xxxxxxxx</code></p>
<p><code>XXXXXXXX</code>就是global的地址。由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的“.bss”段创建一个global变量的副本。那么问题就很明显了，现在global变量定义在原先的共享对象中，而在可执行文件的“.bss”段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。</p>
<p>于是解决的办法只有一个，那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。<strong>ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量</strong>，也就是说当作前面的类型四，通过GOT来实现变量的访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本， 那么GOT中的相应地址就指向模块内部的该变量副本。</p>
<p>假设module.c是一个共享对象的一部分，那么GCC编译器在<code>-fPIC</code>的情况下，就会把对global的调用按照跨模块模式产生代码。原因也很简单：<strong>编译器无法确定对global的引用是跨模块的还是模块内部的</strong>。<strong>即使是模块内部的，即模块内部的全局变量的引用，按照上面的结论，还是会产生跨模块代码，因为global可能被可执行文件引用</strong>，从而使得共享模块中对global的引用要执行可执行文件中的global副本。</p>
<blockquote>
<p>Q&amp;A</p>
<p>Q：如果一个共享对象<code>lib.so</code>中定义了一个全局变量<code>G</code>，而进程A和进程B都使用了<code>lib.so</code>，那么当进程A改变这个全局变量<code>G</code>的值时，进程B中的G会受到影响吗？<br />
A：不会。因为当<code>lib.so</code>被两个进程加载时，它的数据段部分在每个进程中都有独立的副本，从这个角度看，<strong>共享对象中的全局变量实际上和定义在程序内部的全局变量没什么区别</strong>。任何一个进程访问的只是自己的那个副本，而不会影响其他进程。</p>
<p>Q：那么，如果我们把这个问题的条件改成同一个进程中的线程A和线程B，它们是否看得到对方对<code>lib.so</code>中的全局变量G的修改呢？<br />
A：对于同一个进程的两个线程来说，它们访问的是同一个进程地址空间，也就是同一个<code>lib.so</code>的副本，所以它们对G的修改，对方都是看得到的。</p>
<p>Q：那么我们可不可以做到跟前面答案相反的情况呢？比如要求<strong>两个进程共享一个共享对象的副本</strong>或要求<strong>两个线程访问全局变量的不同副本</strong>，这两种需求都是存在的，比如多个进程可以共享同一个全局变量就可以用来实现进程间通信；而多个线程访问全局变量的不同副本可以防止不同线程之间对全局变量的干扰，比如C语言运行库的erron全局变量。<br />
A：实际上这两种需求都是有相应的解决方法的，<strong>多进程共享全局变量又叫做“共享数据段”</strong>，在介绍Windows DLL的时候会碰到它。而<strong>多个线程访问不同的全局变量副本又被叫做“线程私有存储”</strong>(Thread Local Storage)。</p>
</blockquote>

        <h2 id="数据段地址无关性"   >
          <a href="#数据段地址无关性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#数据段地址无关性"></a> 数据段地址无关性</h2>
      
<p>通过上面的方法，我们能够保证共享对象中的代码部分地址无关，但是数据部分是不是也有绝对地址引用的问题呢？让我们来看看这样一段代码：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> * p = &amp;a;</span><br></pre></td></tr></table></div></figure>
<p>如果某个共享对象里面有这样一段代码的话，那么指针p的地址就是一个绝对地址，它指向变量a，而变量a的地址会随着共享对象的装载地址改变而改变。那么有什么办法解决这个问题呢？</p>
<p><strong>对于数据段来说，它在每个进程都有一份独立的副本</strong>，所以并不担心被进程改变。从这点来看，我们<strong>可以选择装载时重定位</strong>的方法来解决数据段中绝对地址引用问题。<strong>对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表</strong>，这个重定位表里面包含了<code>R_386_RELATIVE</code>类型的重定位入口，用于解决上述问题。当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。</p>
<p>实际上，我们<strong>甚至可以让代码段也使用这种装载时重定位的方法，而不使用地址无关代码</strong>。从前面的例子中我们看到，我们在编译共享对象时使用了<code>-fPIC</code>参数，这个参数表示产生地址无关的代码段。如果我们不使用这个参数来产生共享对象又会怎么样呢？</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o pic.so pic.c</span><br></pre></td></tr></table></div></figure>
<p>上面这个命令就会产生一个不使用地址无关代码而使用装载时重定位的共享对象。但正如我们前面分析过的一样，如果代码不是地址无关的，它就不能被多个进程之间共享，于是也就失去了节省内存的优点。但是装载时重定位的共享对象的运行速度要比使用地址无关代码的共享对象快，因为它<strong>省去了地址无关代码中每次访问全局数据和函数时需要做一次计算当前地址以及间接地址寻址的过程</strong>。</p>
<p>对于可执行文件来说，<strong>默认情况下，如果可执行文件是动态链接的，那么GCC会使用PIC的方法来产生可执行文件的代码段部分</strong>，以便于不同的进程能够共享代码段，节省内存。</p>
<p>所以我们可以看到，动态链接的可执行文件中存在“.got”这样的段。</p>

        <h1 id="延迟绑定"   >
          <a href="#延迟绑定" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延迟绑定"></a> 延迟绑定</h1>
      
<p>动态链接的确有很多优势，比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。据统计ELF程序在静态链接下要比动态库稍微快点，大约为<code>1%~5%</code>，当然这取决于程序本身的特性及运行环境等。</p>
<p>动态链接比静态链接慢的主要原因是：</p>
<ol>
<li>动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后再进行间接跳转，如此一来，程序的运行速度必定会减慢。</li>
<li>另外一个减慢运行速度的原因是动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要进行一次链接工作，正如我们上面提到的，动态链接器会寻找并装载所需要的共享对象，然后进行符号查找地址重定位等工作，这些工作势必减慢程序的启动速度。</li>
</ol>
<p>这是影响动态链接性能的两个主要问题，我们将介绍优化动态链接性能的一些方法。</p>

        <h2 id="优化的突破口"   >
          <a href="#优化的突破口" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化的突破口"></a> 优化的突破口</h2>
      
<p>在动态链接下，程序模块之间包含了大量的函数引用（全局变量往往比较少，因为大量的全局变量会导致模块之间耦合度变大）。所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找以及重定位，这也是我们上面提到的减慢动态链接性能的第二个原因。</p>
<p>不过可以想象，在一个<strong>程序运行过程中，可能很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者是一些用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费</strong>。所以ELF采用了一种叫做**延迟绑定(Lazy Binding)**的做法，<strong>基本的思想就是当函数第一次被用到时才由动态链接器进行绑定（符号查找、重定位等）</strong>，如果没有用到则不进行绑定。这样的做法可以大大加快程序的启动速度，特别有利于一些有大量函数引用和大量模块的程序。</p>

        <h2 id="延迟绑定实现"   >
          <a href="#延迟绑定实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#延迟绑定实现"></a> 延迟绑定实现</h2>
      
<p>ELF使用**PLT(Procedure Linkage Table)**的方法来实现，这种方法使用了一些很精巧的指令序列来完成。</p>
<p>在开始详细介绍PLT之前，我们先从动态链接器的角度设想一下：</p>
<p>假设<code>liba.so</code>需要调用<code>libc.so</code>中的<code>bar()</code>函数，那么当<code>liba.so</code>中第一次调用<code>bar()</code>时，这时候就需要<strong>调用动态链接器中的某个函数来完成地址绑定工作</strong>，我们假设这个函数叫做<code>lookup()</code>，那么<code>lookup()</code>需要知道哪些必要的信息才能完成这个函数地址绑定工作呢？答案很明显，<strong><code>lookup()</code>至少需要知道这个地址绑定发生在哪个模块，哪个函数</strong>。那么我们可以假设<code>lookup</code>的原型为<code>lookup(module, function)</code>，这两个参数的值在我们这个例子中分别为<code>liba.so</code>和<code>bar()</code>。</p>
<p>在<code>Glibc</code>中，我们这里的<code>lookup()</code>函数真正的名字叫<code>_dl_runtime_resolve()</code>。</p>
<p>当我们调用某个外部模块的函数时，如果按照通常的做法应该是通过GOT中相应的项进行间接跳转。<strong>PLT为了实现延迟绑定，在这个过程中间又增加了一层间接跳转</strong>。调用函数并<strong>不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转</strong>。每个外部函数在PLT中都有一个相应的项，比如<code>bar()</code>函数在PLT中的项的地址我们称之为<code>bar@plt</code>。让我们来看看bar@plt的实现：</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">bar@plt:</span></span><br><span class="line"><span class="keyword">jmp</span> *(bar@GOT)</span><br><span class="line"><span class="keyword">push</span> n</span><br><span class="line"><span class="keyword">push</span> moduleID</span><br><span class="line">jump _dl_runtime_resolve</span><br></pre></td></tr></table></div></figure>
<p><code>bar@plt</code>的第一条指令是一条通过GOT间接跳转的指令。<code>bar@GOT</code>表示GOT中保存<code>bar()</code>这个函数相应的项。如果链接器在初始化阶段已经初始化该项，并且将<code>bar()</code>的地址填入该项，那么这个跳转指令的结果就是我们所期望的，跳转到<code>bar()</code>，实现函数正确调用。</p>
<p>但是为了实现延迟绑定，链接器在初始化阶段并没有将<code>bar()</code>的地址填入到该项，而是将上面代码中第二条指令<code>push n</code>的地址填入到<code>bar@GOT</code>中，这个步骤不需要查找任何符号，所以代价很低。很明显，第一条指令的效果是跳转到第二条指令，相当于没有进行任何操作。</p>
<p>第二条指令将一个数字n压入堆栈中，这个数字是bar这个符号引用在重定位表<code>.rel.plt</code>中的下标，接着又是一条<code>push</code>指令将模块的ID压入到堆栈，然后跳转到<code>_dl_runtime_resolve</code>。这实际上就是在实现我们前面提到的<code>lookup(module, function)</code>这个函数的调用：先将所需要决议符号的下标压入堆栈，再将模块ID压入堆栈，然后调用动态链接器的<code>_dl_runtime_resolve()</code>函数来完成符号解析和重定位工作。<code>_dl_runtime_resolve()</code>在进行一系列工作以后将<code>bar()</code>的真正地址填入到<code>bar@GOT</code>中。</p>
<p>一旦<code>bar()</code>这个函数被解析完毕，当我们再次调用<code>bar@plt</code>时，第一条<code>jmp</code>指令就能够跳转到真正的<code>bar()</code>函数中，<code>bar()</code>函数返回的时候会根据堆栈里面保存的<code>EIP</code>直接返回到调用者，而不会再继续执行<code>bar@plt</code>中第二条指令开始的那段代码，那段代码只会在符号未被解析时执行一次。</p>
<p>上面我们描述的是PLT的基本原理，PLT真正的实现要比它的结构稍微复杂一些。ELF将GOT拆分成了两个表叫做<code>.got</code>和<code>.got.plt</code>。其中<code>.got</code>用来保存全局变量引用的地址，<code>.got.plt</code>用来保存函数引用的地址。也就是说，所有对于外部函数的引用全部被分离出来放到了<code>.got.plt</code>中。另外<code>.got.plt</code>还有一个特殊的地方是它的前三项是有特殊意义的，分别含义如下：</p>
<ol>
<li>第一项保存的是<code>.dynamic</code>段的地址，这个段描述了本模块动态链接相关的信息，我们在后面还会介绍<code>.dynamic</code>段。</li>
<li>第二项保存的是本模块的ID。</li>
<li>第三项保存的是<code>_dl_runtime_resolve()</code>的地址。</li>
</ol>
<p>其中第二项和第三项由动态链接器在装载共享模块的时候负责将它们初始化。<code>.got.plt</code>的其余项分别对应每个外部函数的引用。PLT的结构也与我们示例中的PLT稍有不同，为了减少代码的重复，ELF把上面例子中的最后两条指令放到PLT中的第一项。并且规定每一项的长度是16个字节，刚好用来存放3条指令，实际的PLT基本结构如图所示。<br />
<img src="../../images/Linux_%E5%BA%93/image-20220509165057010.png" alt="image-20220509165057010" /></p>
<p>实际的PLT基本结构代码如下：</p>
<figure class="highlight x86asm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PLT0:</span></span><br><span class="line"><span class="keyword">push</span> *(GOT + <span class="number">4</span>)</span><br><span class="line">jump *(GOT + <span class="number">8</span>)</span><br><span class="line">...</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">bar@plt:</span></span><br><span class="line"><span class="keyword">jmp</span> *(bar@GOT)</span><br><span class="line"><span class="keyword">push</span> n</span><br><span class="line">jump PLT0</span><br></pre></td></tr></table></div></figure>
<p>PLT在ELF文件中以独立的段存放，段名通常叫做<code>.plt</code>，因为它本身是一些地址无关的代码，所以可以跟代码段等一起合并成同一个可读可执行的<code>Segment</code>被装载入内存。</p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
      
<p>我们分析了使用动态链接技术的原因，即使用动态链接可以更加有效地利用内存和磁盘资源，可以更加方便地维护升级程序，可以让程序的重用变得更加可行和有效。</p>
<p>接着我们介绍了动态链接的基本例子，分析了动态链接中装载地址不确定时如何解决绝对地址引用的问题。</p>
<p><strong>装载时重定位</strong>和<strong>地址无关代码</strong>是解决绝对地址引用问题的两个方法。</p>
<ol>
<li>装载时重定位的缺点是<strong>无法共享代码段，但是它的运行速度较快</strong>；</li>
<li>地址无关代码的缺点是<strong>运行速度稍慢，但它可以实现代码段在各个进程之间的共享</strong>。</li>
</ol>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/81/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/81/">81</a><span class="page-number current">82</span><a class="page-number" href="/page/83/">83</a><span class="space">&hellip;</span><a class="page-number" href="/page/142/">142</a><a class="extend next" rel="next" href="/page/83/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">284</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">54</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>