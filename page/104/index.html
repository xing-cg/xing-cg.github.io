<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/104/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/104/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%A1%B9%E7%9B%AE/%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0_future%E5%8E%9F%E7%90%86/">设计并实现线程池_future原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-03</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/%E8%AE%BE%E8%AE%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0_future%E5%8E%9F%E7%90%86/" data-flag-title="设计并实现线程池_future原理"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="知识储备"   >
          <a href="#知识储备" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#知识储备"></a> 知识储备</h1>
      

        <h2 id="并发和并行"   >
          <a href="#并发和并行" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#并发和并行"></a> 并发和并行</h2>
      
<ul>
<li>并发</li>
</ul>
<p>单核上，CPU时间片轮转，多个线程轮流执行。物理上是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），宏观上看就像是多个线程在共同执行，这样的场景称作并发(concurrent)。</p>
<ul>
<li>并行</li>
</ul>
<p>在多核或者多CPU上，多个线程在同一时刻执行，这样的场景才是真正的并行(parallel)。</p>

        <h2 id="两种密集型程序"   >
          <a href="#两种密集型程序" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#两种密集型程序"></a> 两种密集型程序</h2>
      
<p>多线程程序一定好吗？不一定，要看具体的应用场景。</p>
<ul>
<li>IO密集型：程序里面指令的执行，涉及IO操作较多，比如设备、文件、网络操作（等待客户端的连接），可能会把程序阻塞。如果CPU时间片再分配给这种线程，相当于浪费了CPU资源。</li>
<li>CPU密集型：程序里面的指令都是做计算用的，不会阻塞。</li>
</ul>
<hr />
<ul>
<li>多核情况下
<ol>
<li>IO密集型和CPU密集型虽然对并行计算有不同的需求，IO密集型更适合设计成多线程程序。但是在多核情况下两种密集型程序都是有必要用多线程来处理的。</li>
<li>线程进行调度时，内核中有这样两个队列：runnable，就绪的或正在调度的队列。如果因IO操作有线程阻塞了，则将会进入阻塞队列，blocking queue。</li>
</ol>
</li>
<li>单核情况下
<ol>
<li>IO密集型的程序依然适合设计为多线程程序。</li>
<li>CPU密集型程序不再适合！这就相当于只有一个计算器，却让多个人分段算。线程的调度有额外的花费：线程的上下文切换。CPU寄存器信息会保存在线程栈上，下次还要再恢复到CPU中，实属麻烦。</li>
</ol>
</li>
</ul>

        <h2 id="线程的代价"   >
          <a href="#线程的代价" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程的代价"></a> 线程的代价</h2>
      
<p>为了完成任务，创建很多线程可以吗？线程越多越好吗？</p>
<ul>
<li>线程的创建和销毁都是非常“重”的操作，需要进入内核态。在执行任务的过程中，没有集中资源去干正事，而是去花费很大力度创建/销毁？
<ul>
<li>需要给线程创建<code>PCB(task_struct)</code>、线程的内核栈、页目录、页表</li>
<li>描述地址空间相应的数据结构：<code>vm_area_struct</code></li>
<li>内核创建完后，还要返回用户态</li>
<li>线程执行完业务，还要销毁线程，又要切换一次</li>
</ul>
</li>
<li>线程栈本身占用大量内存，每一个线程都需要线程栈，栈几乎都被占用完了，还怎么做事情？
<ul>
<li>32位地址空间，共4G，用户空间有3G。</li>
<li>线程共享进程的地址空间。</li>
<li>可在linux下执行<code>ulimt -a</code>命令观察stack size默认栈大小，为8192字节即8M。</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>∗</mo><mn>1024</mn><mi>M</mi><mo>=</mo><mn>3072</mn><mi>M</mi><mo separator="true">,</mo><mn>3072</mn><mi>M</mi><mi mathvariant="normal">/</mi><mn>8</mn><mi>M</mi><mo>=</mo><mn>384</mn></mrow><annotation encoding="application/x-tex">3*1024M=3072M, 3072M/8M=384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">7</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">7</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord">4</span></span></span></span>个。这说明32位环境下，最多创建384个线程。</li>
</ul>
</li>
<li>线程的上下文切换要占用大量时间
<ul>
<li>线程过多，线程的调度是需要进行上下文切换的，上下文切换花费CPU时间也特别多，CPU的利用率就不高了。</li>
</ul>
</li>
<li>大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机
<ul>
<li>如果在某一时刻，大量的IO操作准备好了，那么一时间线程是来不及处理的。</li>
</ul>
</li>
</ul>

        <h1 id="线程同步"   >
          <a href="#线程同步" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h1>
      

        <h2 id="线程互斥"   >
          <a href="#线程互斥" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程互斥"></a> 线程互斥</h2>
      
<p>某段代码能不能多线程环境下执行？看这段代码是否存在<strong>竞态条件</strong>，即有无临界区代码段。（代码片段在多线程环境下执行，随着线程的调度顺序不同而得到不同的执行结果）。如果有，则要通过线程同步来保证它的原子操作。</p>
<p>如果在多线程环境下不存在竞态条件，则称之为<strong>可重入的</strong>。</p>

        <h3 id="互斥锁"   >
          <a href="#互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h3>
      
<ul>
<li>lock</li>
<li><code>try_lock</code></li>
<li><code>lock_guard</code></li>
<li><code>unique_lock</code></li>
</ul>

        <h3 id="atomic原子类型"   >
          <a href="#atomic原子类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#atomic原子类型"></a> atomic原子类型</h3>
      
<ul>
<li>CAS操作（无锁机制）
<ul>
<li>无锁队列、无锁链表、无锁数组</li>
<li>实际上使用的是轻量级、效率高的锁，不是没用锁。</li>
</ul>
</li>
</ul>

        <h2 id="线程通信"   >
          <a href="#线程通信" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h2>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88792621" >GDB调试C++11多线程死锁</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="条件变量"   >
          <a href="#条件变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h3>
      

        <h3 id="信号量"   >
          <a href="#信号量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
      
<p>看作资源计数没有限制的mutex互斥锁。mutex互斥锁的资源计数只能是0或者1。</p>

        <h3 id="区别"   >
          <a href="#区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
      
<ul>
<li>二元信号量和互斥锁的区别
<ul>
<li>mutex只能是哪个线程获取锁，由哪个线程释放锁。</li>
<li><code>sem.wait()</code>和<code>sem.post()</code>则可以处在不同的线程中调用。</li>
</ul>
</li>
</ul>

        <h1 id="线程池"   >
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h1>
      
<p>线程池的优势：</p>
<p>服务进程启动之初，事先创建好线程池里面的线程，当业务到来需要分配线程时直接从线程池中获取一个空闲线程执行task任务即可，task执行完成之后把线程归还到线程池中继续给后续task提供服务，而不用释放线程。</p>

        <h2 id="项目介绍"   >
          <a href="#项目介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#项目介绍"></a> 项目介绍</h2>
      
<p>本项目所实现的线程池和对象池、内存池、STL库的意义一样，只能称作一个库，而不能作为一个独立运行的中间件，必须镶嵌在应用程序中。最终项目表现形式为一种提供给他人的<strong>动态库</strong>，比如用到了<code>mysql.h</code>头文件，<code>libmysqlclient.so</code>动态库。动态库需要编译出来。</p>

        <h3 id="使用方式"   >
          <a href="#使用方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h3>
      
<ul>
<li>启动线程池</li>
</ul>
<p>如果你想在应用程序中或者代码中使用本项目的线程池，你可以</p>
<ol>
<li>直接<code>ThreadPool pool;</code>定义一个<code>pool</code>对象；</li>
<li>而后则可以调用<code>pool.sexMode(fixed(default) | cached);</code>接口设置线程池的运行模式，默认为固定模式。</li>
<li>然后<code>pool.start();</code>启动线程池。start不会阻塞。</li>
</ol>
<p>启动线程池意味着线程池开始创建若干线程，就绪，等待任务过来执行任务。</p>
<ul>
<li>提交任务</li>
</ul>
<p>调用方只要按以下形式调用API即可：<code>Result result = pool.submitTask(concreteTask);</code></p>
<p>调用方无需关心内部操作，包括线程分配、执行过程。</p>
<p>有时调用方需要获取任务执行的结果，可用<code>T res = result.get().Cast&lt;T&gt;();</code>获得任务结果。任务结果的返回值是任意类型，具体类型T由用户指出。（此处用到了C++17中的Any类型）</p>

        <h1 id="线程池的设计"   >
          <a href="#线程池的设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池的设计"></a> 线程池的设计</h1>
      

        <h2 id="类成员"   >
          <a href="#类成员" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#类成员"></a> 类成员</h2>
      
<p>首先说一说抽象出的类：线程池类、线程池中的线程类。</p>
<ol>
<li>既然是线程池，就要有一个<strong>存放线程的容器</strong>
<ol>
<li>我们最好能实时监控线程池中线程的数量、以及上限阈值，避免线程数量走向极端从而影响性能（线程数量不是越多越好，坏处：1、线程栈空间冗余；2、上下文切换过程时间多于执行操作）</li>
</ol>
</li>
<li>还要有一个存放待完成任务的容器，即<strong>任务队列</strong>
<ol>
<li>考不考虑线程安全问题？必须考虑，外层用户提交任务要放数据，下层线程执行任务要取数据。</li>
<li>任务不能堆积过多。对于任务队列，也要有一个上限阈值。</li>
</ol>
</li>
</ol>

        <h2 id="通用化的实现-task设计-继承多态思想"   >
          <a href="#通用化的实现-task设计-继承多态思想" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通用化的实现-task设计-继承多态思想"></a> 通用化的实现 - Task设计 - 继承多态思想</h2>
      
<p>任务类型需要达到通用性，所以要用到继承、多态的思想。用基类指针可以指向各种各样的派生类对象。</p>
<p>所以需要<strong>设计一个抽象类Task。内部提供一个纯虚函数<code>virtual void run() = 0</code></strong>。如果要设计特定的任务，则继承（实现）之，重写run函数即可。</p>

        <h2 id="线程通信的保证-mtxcv"   >
          <a href="#线程通信的保证-mtxcv" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程通信的保证-mtxcv"></a> 线程通信的保证 - mtx+cv</h2>
      
<p>因为涉及到放任务、取任务，所以很明显是个生产者消费者模型。</p>
<p>必然<strong>用到互斥锁+条件变量，从而对任务队列进行互斥保护</strong>、达到正确的线程通信。</p>

        <h2 id="线程池的模式"   >
          <a href="#线程池的模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池的模式"></a> 线程池的模式</h2>
      
<ul>
<li>fixed模式
<ul>
<li>线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。</li>
</ul>
</li>
<li>cached模式
<ul>
<li>线程池里面的线程个数是可动态增长的，根据任务的数量动态地增加线程的数量，但是会设置一个线程数量的阈值。任务处理完成后，如果动态增长的线程空闲60s而没有其他任务待处理，那么就关闭线程，保持池中线程的最初数量。</li>
</ul>
</li>
</ul>

        <h3 id="代码形式"   >
          <a href="#代码形式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码形式"></a> 代码形式</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">setMode</span>(<span class="built_in">fixed</span>(<span class="keyword">default</span>) | cached);</span><br><span class="line">    pool.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="提交任务api"   >
          <a href="#提交任务api" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#提交任务api"></a> 提交任务API</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result result = pool.<span class="built_in">submitTask</span>(concreteTask);</span><br><span class="line">result.<span class="built_in">get</span>().<span class="built_in">Cast</span>&lt;T&gt;();</span><br></pre></td></tr></table></div></figure>

        <h1 id="线程池类threadpool"   >
          <a href="#线程池类threadpool" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池类threadpool"></a> 线程池类（ThreadPool）</h1>
      
<p>线程池，不光要管理线程，而且要集成一个任务队列。要对外提供提交任务的接口。</p>
<p>其中的线程去取任务，做，然后返回任务结果。（这是线程类里的事情）</p>
<p>管理的线程，用 vector 管理。<br />
管理的任务，用 queue 管理。任务队列要保证线程安全。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">PoolMode</span></span><br><span class="line">&#123;</span><br><span class="line">    MODE_FIXED,     <span class="comment">// 固定数量的线程</span></span><br><span class="line">    MODE_CACHED,    <span class="comment">// 线程数量可动态增长</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">/* 设置线程池的工作模式 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMode</span><span class="params">(PoolMode mode)</span></span>;</span><br><span class="line">    <span class="comment">/* 设置初始的线程数量 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInitThreadSize</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    <span class="comment">/* 设置task队列任务数量最大阈值 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshHold)</span></span>;</span><br><span class="line">    <span class="comment">/* 启动线程池 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PoolMode m_poolMode;                <span class="comment">//当前线程池工作模式</span></span><br><span class="line">    std::vector&lt;Thread*&gt; m_threads;     <span class="comment">//线程列表</span></span><br><span class="line">    <span class="type">int</span> m_initThreadSize;               <span class="comment">//初始的线程数量</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列容器。</span></span><br><span class="line"><span class="comment">     * 特别要注意，需要用 shared_ptr 强引用用户传来的 task ，</span></span><br><span class="line"><span class="comment">     * 以保证任务对象的生命期。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;Task&gt;&gt; m_taskQueue;</span><br><span class="line">    <span class="comment">/* 目前任务队列中的任务数量 */</span></span><br><span class="line">    std::atomic_int m_taskNum;</span><br><span class="line">    <span class="comment">/* 任务队列最大上限阈值 */</span></span><br><span class="line">    <span class="type">int</span> m_taskQueMaxThreshHold;</span><br><span class="line">    <span class="comment">/* 保护安全地操作任务队列 */</span></span><br><span class="line">    std::mutex m_taskQueMtx;</span><br><span class="line">    <span class="comment">/* 表示任务队列不满 */</span></span><br><span class="line">    std::condition_variable m_taskQueNotFull;</span><br><span class="line">    <span class="comment">/* 表示任务队列不空 */</span></span><br><span class="line">    std::condition_variable m_taskQueNotEmpty;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="threadpool构造-析构"   >
          <a href="#threadpool构造-析构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadpool构造-析构"></a> ThreadPool构造、析构</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线程池构造 */</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">   : <span class="built_in">m_initThreadSize</span>(<span class="number">4</span>),</span><br><span class="line">     <span class="built_in">m_taskNum</span>(<span class="number">0</span>),</span><br><span class="line">     <span class="built_in">m_taskQueMaxThreshHold</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">     <span class="built_in">m_poolMode</span>(PoolMode::MODE_FIXED)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="设置参数"   >
          <a href="#设置参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#设置参数"></a> 设置参数</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置线程池的工作模式 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_poolMode = mode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置初始的线程数量 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setInitThreadSize</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_initThreadSize = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置task队列任务数量最大阈值 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setTaskQueMaxThreshHold</span><span class="params">(<span class="type">int</span> threshHold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_taskQueMaxThreshHold = threshHold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="启动线程池"   >
          <a href="#启动线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#启动线程池"></a> 启动线程池</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 启动线程池 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h2 id="给线程池提交任务"   >
          <a href="#给线程池提交任务" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#给线程池提交任务"></a> 给线程池提交任务</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; task)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h1 id="thread类"   >
          <a href="#thread类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread类"></a> Thread类</h1>
      

        <h2 id="线程函数定义在哪个位置呢"   >
          <a href="#线程函数定义在哪个位置呢" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程函数定义在哪个位置呢"></a> 线程函数定义在哪个位置呢？</h2>
      
<ul>
<li>思考：线程函数定义在哪个位置呢？
<ul>
<li>如果写在Thread类中，那么定义在 ThreadPool 的变量则不容易被函数所访问。</li>
<li>定义为全局函数呢？线程池里的变量都是私有的，也不易访问。</li>
<li>结论：OOP的手法，写在ThreadPool中。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.h */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* 定义线程函数 */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="怎么把线程函数扔给thread对象"   >
          <a href="#怎么把线程函数扔给thread对象" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#怎么把线程函数扔给thread对象"></a> 怎么把线程函数扔给Thread对象</h2>
      
<ul>
<li>线程对象是在线程池里构建的，线程启动执行也是在线程池里做的，</li>
<li>那么创建 thread 线程对象时需要把线程函数给到 thread 线程对象。怎么把函数扔给对象？怎么解决这个技术问题？
<ul>
<li>引入<code>&lt;functional&gt;</code>，用<code>std::bind()</code>把函数对象绑定。在线程池 start 时，构造 thread 时传入</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_initThreadSize = initThreadSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads.<span class="built_in">emplace_back</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="头文件"   >
          <a href="#头文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h2>
      
<p>由上述 Thread 类构造时对函数对象的处理，可以得到 Thread 类的大致属性需求、构造参数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 线程函数对象类型别名 */</span></span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Thread</span>(ThreadFunc func);</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadFunc m_func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="start-函数创建线程后分离线程"   >
          <a href="#start-函数创建线程后分离线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#start-函数创建线程后分离线程"></a> start 函数（创建线程后，分离线程）</h2>
      
<ul>
<li>start 函数 - 启动线程，创建一个线程来执行一个线程函数
<ul>
<li>需要注意：出了start函数作用域之后线程对象会析构，但是线程函数不能消失，他还要去消费任务队列上的任务。<strong>所以线程对象需要设置为分离线程，否则程序会挂掉</strong>。</li>
<li>分离的效果就是：<strong>线程对象</strong>和它所<strong>启动的线程（实质的线程</strong>）分离开了。独立存在，互不关心对方的生命期。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* threadpool.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">/* 启动线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(m_func)</span></span>;	<span class="comment">//线程对象t，线程函数m_func</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="简单测试"   >
          <a href="#简单测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#简单测试"></a> 简单测试</h1>
      
<ul>
<li>简单测试，默认启动 4 个线程。启动后在不同的线程分别执行 threadFunc 函数。
<ul>
<li>注意：创建的线程分离之后，执行完毕后会自动回收。但是可能存在主线程启动后看不到打印结果的情况，那是因为主线程结束地太快，导致没能看到（实际中的服务器主线程不会很快结束，而是保持）。为了看到执行结果，可以睡眠一段时间。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;begin threadFunc tid:&quot;</span> </span><br><span class="line">      &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;end threadFunc&quot;</span> </span><br><span class="line">      &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 线程池项目测试.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="智能指针解决避免手动释放"   >
          <a href="#智能指针解决避免手动释放" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#智能指针解决避免手动释放"></a> 智能指针解决避免手动释放</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_initThreadSize = initThreadSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>)</span><br><span class="line">        );</span><br><span class="line">        m_threads.<span class="built_in">emplace_back</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_initThreadSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_threads[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>但是这样会出现编译不过的问题，为什么呢？因为报错发现<code>unique_ptr</code>的拷贝构造已经删除，这是唯一性智能指针的语义决定的。而移动构造没有删除，意味可以用右值进行资源转移，所以我们需要在<code>ptr</code>前加<code>std::move</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_threads.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br></pre></td></tr></table></div></figure>

        <h1 id="submittask"   >
          <a href="#submittask" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#submittask"></a> submitTask</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给线程池提交任务 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 获取锁 */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_taskQueMtx)</span></span>;</span><br><span class="line">    <span class="comment">/* 线程的通信，等待任务队列有空余 */</span></span><br><span class="line">    <span class="comment">//while(taskQue_.size() == taskQueMaxThreshHold_)&#123; notFull_.wait(); &#125;</span></span><br><span class="line">    m_taskQueNotFull.<span class="built_in">wait</span>(</span><br><span class="line">        lock,</span><br><span class="line">        [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_taskQueue.<span class="built_in">size</span>() &lt; m_taskQueMaxThreshHold;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* 如果有空余，把任务放到任务队列中 */</span></span><br><span class="line">	m_taskQueue.<span class="built_in">emplace</span>(sp);</span><br><span class="line">    ++m_taskNum;</span><br><span class="line">    <span class="comment">/* 因为新放了任务，任务队列肯定不空了，通知notEmpty_上的等待线程 */</span></span><br><span class="line">    m_taskQueNotEmpty.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="服务降级wait_fortime"   >
          <a href="#服务降级wait_fortime" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#服务降级wait_fortime"></a> 服务降级（<code>wait_for(time)</code>）</h2>
      
<p>为了性能更加优化，我们限制用户提交任务的最长阻塞时间是<code>1s</code>，如果提交任务超过了 1s 说明目前线程池的任务队列压力比较大，防止短时间内积压很多任务，则规定为提交任务失败，返回。称为<strong>服务降级</strong>。</p>
<p>需要用到<code>wait</code>的两个延伸，<code>wait_for(time)</code>，<code>wait_until(endtime)</code>。返回值为bool值，<code>false</code>表示到时间后条件依然没满足。</p>
<p>以下说的是：如果等了超过 1 秒，说明满的状态已经超过了 1 秒，<code>wait_for</code>返回 <code>false</code> ，<code>if</code> 条件成立，提交失败。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!m_taskQueNotFull.<span class="built_in">wait_for</span>(</span><br><span class="line">    lock,</span><br><span class="line">    std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">    [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; (<span class="type">size_t</span>)taskQueMaxThreshHold_;</span><br><span class="line">    &#125;))</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr&lt;&lt;<span class="string">&quot;task queue is full, submit out of time failed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="threadfunc"   >
          <a href="#threadfunc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadfunc"></a> ThreadFunc</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">    <span class="comment">/* 块作用域 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 先获取锁 */</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_taskQueMtx)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">/* 等待notEmpty条件 */</span></span><br><span class="line">        m_taskQueNotEmpty.<span class="built_in">wait</span>(</span><br><span class="line">            lock,</span><br><span class="line">            [&amp;]()-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m_taskQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">/* 从任务队列中取一个任务出来 */</span></span><br><span class="line">        task = m_taskQueue.<span class="built_in">front</span>();</span><br><span class="line">        m_taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">        --m_taskNum;</span><br><span class="line">        <span class="comment">/* 如果有剩余任务，继续通知其他线程来取任务 */</span></span><br><span class="line">        <span class="keyword">if</span> (m_taskQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_taskQueNotEmpty.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 取出了一个任务，任务队列此时肯定不满了，对等待提交任务的人进行通知 */</span></span><br><span class="line">        m_taskQueNotFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当前线程负责执行这个任务, 没必要拥有锁, 脱离块作用域, 释放锁 */</span></span><br><span class="line">    <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)</span><br><span class="line">        task-&gt;<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="测试1"   >
          <a href="#测试1" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试1"></a> 测试1</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">test example:</span><br><span class="line"><span class="comment">/* 以下为提交3个任务，预估结果为3个线程获取任务成功，1个没有获取到，一直阻塞 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">	pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">	pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;());</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 若4个线程，提交5个任务，则最先完成并抢到锁的线程能再次获得第5个任务 */</span></span><br><span class="line"><span class="comment">/* 若4个线程，提交10个任务，并把队列容量设为4，则可能有2个任务提交失败 */</span></span><br></pre></td></tr></table></div></figure>

        <h1 id="线程执行的返回值future和packaged_task的实现原理"   >
          <a href="#线程执行的返回值future和packaged_task的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程执行的返回值future和packaged_task的实现原理"></a> 线程执行的返回值（future和packaged_task的实现原理）</h1>
      
<p>比如，计算1到30000的和。线程1计算1到10000，2计算10001到20000，3计算20001到30000。<br />
主线程给每一个线程分配计算的区间，并等待他们算完之后返回结果，合并最终的结果即可。<br />
但是，怎么能拿到线程的返回值呢？</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">    	: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin_; i &lt;= end_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>问题1：怎么设计run函数的返回值，可以表示任意的类型？</li>
<li>问题2：如何设计这里的Result机制？</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>, <span class="number">10000</span>));</span><br><span class="line">Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">10001</span>, <span class="number">20000</span>));</span><br><span class="line">Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">20001</span>, <span class="number">30000</span>));</span><br><span class="line">res<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">res<span class="number">2.</span><span class="built_in">get</span>();</span><br><span class="line">res<span class="number">3.</span><span class="built_in">get</span>();</span><br></pre></td></tr></table></div></figure>

        <h2 id="any类型-按需返回具体类型"   >
          <a href="#any类型-按需返回具体类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#any类型-按需返回具体类型"></a> Any类型 - 按需返回具体类型</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Any</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Any</span>(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Any&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Any</span>(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Any&amp; <span class="keyword">operator</span>=(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这个构造函数可以让 Any 类型接收任意其他的数据 */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Any</span><span class="params">(T data)</span> : base_(std::make_unique&lt;Derived&lt;T&gt;&gt;(data))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="comment">/* 这个方法能把 Any 对象里面存储的 data 数据提取出来 */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    T <span class="title">cast_</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// base_ 是定义在 Any 类中的一个 std::unique_ptr&lt;Base&gt;</span></span><br><span class="line">        <span class="comment">// get() 可以获得 其实际指针</span></span><br><span class="line">        Derive&lt;T&gt;* pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;*&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span>(pd == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;type is unmatch!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;data_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derived</span>(T data) : <span class="built_in">data_</span>(data)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 实际的 data 存在 Derived 类中。</span></span><br><span class="line">        T data_;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义一个基类的指针 */</span></span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    Result res = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>, <span class="number">10000</span>));</span><br><span class="line">    <span class="type">int</span> sum = res.<span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如此一来：<br />
res调用get，等待 task 执行完毕，<code>get()</code>就能返回一个<code>Any</code>。这个 <code>Any</code> 的模板参数指明了里面存放的数据是 <code>int</code> 型， <code>Any</code> 对象调用其 <code>cast_</code>， 取出了里面存放的数据。（通过<code>dynamic_cast&lt;Derive&lt;int&gt;*&gt;</code>）如果类型不匹配，则抛出异常。</p>

        <h2 id="自实现信号量类"   >
          <a href="#自实现信号量类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#自实现信号量类"></a> 自实现信号量类</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Semaphore</span>(<span class="type">int</span> limit = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">resLimit_</span>(limit)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Semaphore</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/* 获取一个信号量资源 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="comment">/* 等待信号量有资源，没有资源的话，阻塞当前线程 */</span></span><br><span class="line">        cond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> resLimit_ &gt; <span class="number">0</span>;&#125;);</span><br><span class="line">        --resLimit_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 增加一个信号量资源 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        ++resLimit_;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 信号量目前拥有的资源数</span></span><br><span class="line">    <span class="type">int</span> resLimit_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="result设计"   >
          <a href="#result设计" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#result设计"></a> （⭐）Result设计</h2>
      
<p>先分析一下局势：</p>
<ol>
<li>Task里面肯定有结果</li>
<li>外部有一个Result要接收结果</li>
<li>Task里面的结果怎么巧妙地转移到Result上面？</li>
<li>其实Task不用专门有一个Any成员变量保存。</li>
<li>可以直接在Task中保存一个Result指针。</li>
<li>外部Result也绑定一个Task作为成员对象。<strong>为了让Task延长生命期，Result需要用<code>shared_ptr&lt;Task&gt;</code>构造</strong>。</li>
<li><code>Result</code>构造函数中，只需要执行：<code>task_-&gt;setResult(this);</code>，便可以移花接木，把Task成员变量<code>result_</code>指向外部的Result。</li>
<li>这样，Task内部，run完之后，返回了Any，Task便可以主动调用<code>result_-&gt;setVal(run())</code>。把结果写回外部的Result内部。</li>
</ol>
<p>submitTask接口返回类型需要让用户能接收到线程任务的返回值，并且要求可以是任意类型，所以改为Result。相应的，我们需要设计这样的Result类型。</p>
<ul>
<li>思考，return时用下面哪种方式？
<ul>
<li><code>task-&gt;getResult();</code>还是<code>Result(task);</code>？</li>
<li>要执行的task从队列中<code>taskQue_.pop()</code>，接着调用完毕后Task就会析构（注意，submitTask传入的是shared_ptr，引用计数减1，如果此时没有其他人引用该Task，将会析构，里面的any存储的结果就失效了），即task生命期现在只存在于<code>threadFunc</code>函数中。</li>
<li>如果是<code>task-&gt;getResult();</code>
<ul>
<li>若task中的Result是以值形式存的，则肯定不行，因为task析构之后，Result也会析构。</li>
<li>若task中的Result是以指针形式存的，则必须指定到一个外部资源保存。比如存到堆上。
<ul>
<li>如果是在堆上保存，还必须提供一个getResult接口，返回Result的指针，即<code>result_</code>成员变量。这样，可以做到把Result安全地保存下来。</li>
</ul>
</li>
</ul>
</li>
<li>但是，可以以更为巧妙的方式！<code>Result(task);</code>
<ul>
<li>Result绑定了这个task（用shared智能指针管理，让task对象的生命期延至和Result对等），在Result的构造函数中，调用<code>task-&gt;setResult(this);</code>！！！居然巧妙地把“外部资源地址”指向了外部待接收结果的Result自己！避免了堆上建立的烦恼。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Result <span class="title">submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span>;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;;</span><br><span class="line">--------------------------</span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">	<span class="keyword">if</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/*		思考，return时用下面哪种方式？	*/</span></span><br><span class="line"><span class="comment">/*      return task-&gt;getResult();	 */</span></span><br><span class="line">        <span class="comment">// 此时是提交任务失败的返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Result</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*	思考，return时用下面哪种方式？	*/</span></span><br><span class="line"><span class="comment">/*  return task-&gt;getResult();	 */</span></span><br><span class="line">    <span class="comment">// 此时是提交任务成功后的返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>经过上面的讨论，Result类成员里需要绑定一个Task对象。即下面的<code>task_</code>。下面是Result成员和其构造。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实现接收提交到线程池的task任务执行完成后的返回值类型Result */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid = <span class="literal">true</span>);</span><br><span class="line">    ~<span class="built_in">Result</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 存储任务的返回值 */</span></span><br><span class="line">    Any any_;</span><br><span class="line">    <span class="comment">/* 线程通信信号量 */</span></span><br><span class="line">    Semaphore sem_;</span><br><span class="line">    <span class="comment">/* 指向对应获取返回值的任务对象 */</span></span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;</span><br><span class="line">    <span class="comment">/* 任务执行是否有效/成功 */</span></span><br><span class="line">    std::atomic_bool isValid_;</span><br><span class="line">&#125;</span><br><span class="line">------------------</span><br><span class="line"><span class="comment">//threadpool.cpp</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid)</span><br><span class="line">    : <span class="built_in">isValid_</span>(isValid), <span class="built_in">task_</span>(task)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h3 id="成员函数"   >
          <a href="#成员函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h3>
      
<ul>
<li>问题1：setVal函数，获取任务执行完的返回值，记录在any成员。</li>
<li>问题2：get函数，用户调用这个方法获取task的返回值（没执行完需要阻塞）</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVal</span><span class="params">(Any any)</span></span>;</span><br><span class="line">    <span class="function">Any <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Any any_;</span><br><span class="line">    Semaphore sem_;</span><br><span class="line">    std::shared_ptr&lt;Task&gt; task_;</span><br><span class="line">    std::atomic_bool isValid_;</span><br><span class="line">&#125;;</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">/* 	用户调用的 */</span></span><br><span class="line"><span class="function">Any <span class="title">Result::get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isValid_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 阻塞用户的线程直到task通知其执行完毕 */</span></span><br><span class="line">    sem_.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(any_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 谁调用？答案是 Task 的 run 结束之后，通过Result * result_ 间接调用次函数，通知 get() 唤醒拿结果 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Result::setVal</span><span class="params">(Any any)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 存储task的返回值 */</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;any_ = std::<span class="built_in">move</span>(any);</span><br><span class="line">    sem_.<span class="built_in">post</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="task增加方法把结果写入result"   >
          <a href="#task增加方法把结果写入result" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#task增加方法把结果写入result"></a> Task增加方法，把结果写入Result</h2>
      
<p>思想：在threadFun函数中，不仅要靠task对象Task类中的run方法执行具体哪种任务，还要把任务的返回值给到result，可以用exec来封装，exec没有多态，run有多态。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task::exec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result_ != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// run()结束之后，setVal才能被调用成功，此时影响到了 result_ 中保存的信号量 +1，因此 外部的result.get()不再阻塞</span></span><br><span class="line">	    result_-&gt;<span class="built_in">setVal</span>(<span class="built_in">run</span>());	<span class="comment">//如此可知，task中需要封装一个result对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>();</span><br><span class="line">    ~<span class="built_in">Task</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setResult</span><span class="params">(Result *res)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*	没必要用shared智能指针，否则就会出现：Result中有shared_ptr&lt;Task&gt;，Task中有shared_ptr&lt;Result&gt;。循环引用，无法释放！*/</span></span><br><span class="line">    Result *result_;	<span class="comment">//result对象的生命周期长于task，不怕。</span></span><br><span class="line">&#125;;</span><br><span class="line">----------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task::setResult</span><span class="params">(Result *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result_ = res;</span><br><span class="line">&#125;</span><br><span class="line">Task::<span class="built_in">Task</span>()</span><br><span class="line">    : <span class="built_in">result_</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;       </span><br><span class="line">&#125;</span><br><span class="line">----------------</span><br><span class="line"><span class="comment">/* 谁调用setResult？此 Result 不是 Result 里的 val ， 而是保存 Val 的一个地方，不要搞混了 */</span></span><br><span class="line"><span class="comment">// 外部可以通过 task 来 指定 Result 要保存到哪个地方。</span></span><br><span class="line"><span class="comment">// 比如可以传入 外部 Result 的 this 指针；也可以 new 一个 Result 在 堆上，set 到堆上地址</span></span><br><span class="line"><span class="comment">// 如果 Result 绑定了一个 task 就可以 通过这个 task 设置 Result 为 自己（this）</span></span><br><span class="line">Result::<span class="built_in">Result</span>(std::std::shared_ptr&lt;Task&gt; task, <span class="type">bool</span> isValid)</span><br><span class="line">	: <span class="built_in">isValid_</span>(isValid), <span class="built_in">task_</span>(task)</span><br><span class="line">&#123;</span><br><span class="line">    task_-&gt;<span class="built_in">setResult</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试2master-slave模型"   >
          <a href="#测试2master-slave模型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试2master-slave模型"></a> 测试2（Master - Slave模型）</h2>
      
<p>Master - Slave模型，Master线程用来分解任务，然后给各个Slave线程分配任务，等待各个Slave线程执行完任务，返回结果。最后Master线程合并各个任务结果，输出。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">    	: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function">Any <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        uLong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uLong i = begin_; i &lt;= end_; ++i)</span><br><span class="line">            sum += i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> uLong = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>, <span class="number">100000000</span>));</span><br><span class="line">    Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">100000001</span>, <span class="number">200000000</span>));</span><br><span class="line">    Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>, <span class="number">300000000</span>));</span><br><span class="line">    uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    uLong sum2 = res<span class="number">2.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    uLong sum3 = res<span class="number">3.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    cout &lt;&lt; sum1 + sum2 + sum3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试结果：</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407095057418.png" alt="image-20220407095057418" /></p>

        <h1 id="cached模式线程池"   >
          <a href="#cached模式线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cached模式线程池"></a> cached模式线程池</h1>
      
<p>主要的使用点：submitTask函数中，可能需要根据任务数量和空闲线程的数量，判断是否需要创建新的线程。</p>
<ul>
<li>需要处理的问题
<ul>
<li>问题1，用户自己如何设置线程池的工作模式</li>
<li>问题2，submitTask函数中，根据任务数量和空闲线程的数量，判断是否需要创建新的线程</li>
<li>问题3，threadFunc函数中，有可能已经创建了很多的线程，如果空闲时间超过60s，需要结束、回收。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    <span class="comment">/* 用户自己设置线程池的工作模式 */</span></span><br><span class="line">    pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">    <span class="comment">/* 开始启动线程池 */</span></span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="切换工作模式"   >
          <a href="#切换工作模式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#切换工作模式"></a> 切换工作模式</h2>
      
<p>为了防止用户在线程池启动后再去切换线程池的工作模式，我们需要给线程池添加一个状态变量，以控制用户能否对线程池的工作模式进行切换。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 检查pool的运行状态 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkRunningState</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 表示当前线程池的启动 */</span></span><br><span class="line">    std::atomic_bool isPoolRunning_;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 设置线程池的状态为运行态 */</span></span><br><span class="line">    isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ThreadPool::checkRunningState</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isPoolRunning_;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setMode</span><span class="params">(PoolMode mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkRunningState</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    poolMode_ = mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="创建更多线程"   >
          <a href="#创建更多线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#创建更多线程"></a> 创建更多线程</h2>
      
<p>cached模式：任务处理比较紧急，场景是小而快的任务。</p>
<p>ThreadPool需要添加记录一个空闲线程数量的变量。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录空闲线程的数量 */</span></span><br><span class="line">    std::atomic_int idleThreadSize_;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 空闲线程数量需要加1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 每启动一个线程就给idleThreadSize_加1，表示多了一个空闲线程 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 空闲线程数量需要减1 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*			...			*/</span></span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            notEmpty_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> taskQue_.<span class="built_in">size</span>()&gt;<span class="number">0</span>;&#125;);</span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*			...			*/</span></span><br><span class="line">    	notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task != <span class="literal">nullptr</span>) task -&gt; <span class="built_in">exec</span>();</span><br><span class="line">    ++idleThreadSize_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>现在来增加 submitTask 函数对 cached 模式处理的细节。<br />
有一点要注意，就是尽管任务非常多，但是我们要对线程的数量设一定的上限值。<br />
即需要给 ThreadPool 类增加一个线程数量阈值变量。</p>
<p>然后为了比较线程池当前线程的数量状况，也要添加一个记录线程总数量的变量。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 设置线程池cached模式下的线程阈值 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span></span>;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 线程数量上限阈值 */</span></span><br><span class="line">    <span class="type">int</span> threadSizeThreshHold_;</span><br><span class="line">    <span class="comment">/* 记录当前线程池里面线程的总数量 */</span></span><br><span class="line">    std::atomic_int curThreadSize_;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;;</span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>()</span><br><span class="line">	: <span class="built_in">initThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">idleThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">curThreadSize_</span>(<span class="number">0</span>),</span><br><span class="line">	  <span class="built_in">taskQueMaxThreshHold_</span>(TASK_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">threadSizeThreshHold_</span>(THREAD_MAX_THRESHHOLD),</span><br><span class="line">	  <span class="built_in">poolMode_</span>(PoolMode::MODE_FIXED),</span><br><span class="line">	  <span class="built_in">isPoolRunning_</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 记录初始线程个数 */</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line">    <span class="comment">/* 创建线程对象 */</span></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="comment">/* 启动所有线程 */</span></span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::setThreadSizeThreshHold</span><span class="params">(<span class="type">int</span> threshhold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">checkRunningState</span>() || poolMode_==PoolMode::MODE_FIXED)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    threadSizeThreshHold_ = threshhold;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="comment">/* 关注三个状态：</span></span><br><span class="line"><span class="comment"> * 1.线程池的工作模式是否是cached；</span></span><br><span class="line"><span class="comment"> * 2.任务数量是否已经大于空闲线程数量；</span></span><br><span class="line"><span class="comment"> * 3.线程总数量是否没有超过线程数量上限；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建新线程 */</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>));</span><br><span class="line">        threads_.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();	<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="任务处理完毕回收多余线程"   >
          <a href="#任务处理完毕回收多余线程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#任务处理完毕回收多余线程"></a> 任务处理完毕，回收多余线程</h2>
      
<p>超过<code>initThreadSize_</code>数量的线程要进行回收。</p>
<p><strong>当前时间 比 上一次线程执行完毕的时间</strong> 大于 60s 后回收。</p>
<blockquote>
<p><code>C++11</code>中提供了高精度时间API - <code>std::chrono::high_resolution_clock().now()</code>;</p>
</blockquote>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_IDLE_TIME = <span class="number">60</span>;	<span class="comment">//单位s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 上一次线程执行完任务的时间 */</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">    	Task task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line">            <span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line">            <span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line">            <span class="comment">// 锁 + 双重判断</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line">                <span class="keyword">if</span> (!isPoolRunning_)</span><br><span class="line">                &#123;</span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                        &lt;&lt; std::endl;</span><br><span class="line">                    exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//while(taskQue_.size() &gt; 0) // 不再去判断 taskQue_.size() &gt; 0，即使size是0，也一直等待60s</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* 超时 1s 返回 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">//返回的是time_point类型</span></span><br><span class="line">                        <span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line">                        <span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 开始回收当前线程 */</span></span><br><span class="line">                            <span class="comment">/* 修改记录线程数量的相关变量 */</span></span><br><span class="line">                            <span class="comment">/* 把线程从线程列表容器中删除 */</span></span><br><span class="line">                            <span class="comment">/* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */</span></span><br><span class="line">                            <span class="comment">/* 我们需要有一个映射关系来记录：threadid =&gt; thread对象 =&gt; 删除 */</span></span><br><span class="line">                            thread_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                            --curThreadSize_;</span><br><span class="line">                            --idleThreadSize_;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                                &lt;&lt; std::endl;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//&#125; // while(taskQue_.size() &gt; 0) 结束</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// poolMode_ != PoolMode::MODE_CACHED</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock <span class="comment">/* , [&amp;]()-&gt;bool &#123; return taskQue_.size() &gt; 0; &#125; */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end while (taskQueue_.size() == 0)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 taskQueue_.size() != 0 而 我们又拿到了 任务队列的锁，可以直接取走任务</span></span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">            taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125; <span class="comment">// end std::unique_lock&lt;std::mutex&gt; lock(taskQueMtx_);</span></span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        <span class="comment">/* 线程执行完任务后更新lastTime */</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="问题怎么知道线程函数对应的是线程列表容器中的哪一个线程对象"   >
          <a href="#问题怎么知道线程函数对应的是线程列表容器中的哪一个线程对象" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题怎么知道线程函数对应的是线程列表容器中的哪一个线程对象"></a> 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象？</h2>
      
<p>我们需要有一个映射关系来记录：<code>threadid - thread对象</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;</span><br></pre></td></tr></table></div></figure>
<p>所以，Thread对象需要封装一个id值。<br />
然后，在线程函数<code>threadFunc</code>传入<code>int threadid</code>参数。<br />
这样，该 id 的Thread在线程函数中计时自己的空闲时间，若连续 wait 了 60s（每wait一次1s超时返回），说明任务过少，空闲线程过多。<br />
只有知道了 id 号，才能让 ThreadPool 记录的 线程map 精确地删除。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">Thread</span>(ThreadFunc func);</span><br><span class="line">    ~<span class="built_in">Thread</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/* 启动线程 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ThreadFunc func_;</span><br><span class="line">    <span class="comment">// 这是属于 Thread类 共享的计数器。表示曾经已生成了多少个线程对象</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> generateId;</span><br><span class="line">    <span class="comment">// 当前Thread 对象的ID</span></span><br><span class="line">    <span class="type">int</span> threadId_;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="type">int</span> Thread::generateId_ = <span class="number">0</span>;</span><br><span class="line">Thread::<span class="built_in">Thread</span>(ThreadFunc func)</span><br><span class="line">	: <span class="built_in">func_</span>(func), <span class="built_in">threadId</span>(++generateId_)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread::getId</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadId_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后，最大的变化来了，把原先的线程列表的vector容器变成了unordered_map。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_; <span class="comment">// 线程列表</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>因此，在 start 启动线程池的操作中，生成线程的动作就要有所变化</p>
<p>要预留一个占位符<code>_1</code>，这是给线程函数的传入参数的位置，<code>threadid</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启线程池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="type">int</span> initThreadSize = std::thread::hardware_concurrency())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置线程池的运行状态</span></span><br><span class="line">    isPoolRunning_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始线程个数</span></span><br><span class="line">    initThreadSize_ = initThreadSize;</span><br><span class="line">    curThreadSize_ = initThreadSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建thread线程对象的时候，把线程函数给到thread线程对象</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thread&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        <span class="comment">// threads_.emplace_back(std::move(ptr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动所有线程  std::vector&lt;Thread*&gt; threads_;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; initThreadSize_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        threads_[i]-&gt;<span class="built_in">start</span>(); <span class="comment">// 需要去执行一个线程函数</span></span><br><span class="line">        idleThreadSize_++;    <span class="comment">// 记录初始空闲线程的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="改为无序哈希表存储id-thread对象映射关系后的代码调整"   >
          <a href="#改为无序哈希表存储id-thread对象映射关系后的代码调整" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#改为无序哈希表存储id-thread对象映射关系后的代码调整"></a> 改为无序哈希表存储id、Thread对象映射关系，后的代码调整</h2>
      

        <h3 id="submittask-2"   >
          <a href="#submittask-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#submittask-2"></a> submitTask</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thead&gt;(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="threadpool的threadfuncint-threadid接口添加int参数"   >
          <a href="#threadpool的threadfuncint-threadid接口添加int参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadpool的threadfuncint-threadid接口添加int参数"></a> ThreadPool的<code>threadFunc(int threadid)</code>接口添加int参数</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 定义线程函数，加了一个参数threadid */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="thread中using-threadfunc的stdfunctionvoidint"   >
          <a href="#thread中using-threadfunc的stdfunctionvoidint" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread中using-threadfunc的stdfunctionvoidint"></a> Thread中<code>using ThreadFunc</code>的<code>std::function&lt;void(int)&gt;</code></h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 要和threadFunc函数参数一致 */</span></span><br><span class="line">    <span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="thread的start多传入一个threadid_"   >
          <a href="#thread的start多传入一个threadid_" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#thread的start多传入一个threadid_"></a> Thread的start，多传入一个<code>threadId_</code></h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_, threadId_)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="测试3"   >
          <a href="#测试3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试3"></a> 测试3</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="keyword">public</span> Task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTask</span>(<span class="type">int</span> begin, <span class="type">int</span> end)</span><br><span class="line">		: <span class="built_in">begin_</span>(begin), <span class="built_in">end_</span>(end)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Any <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;begin!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">        uLong sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uLong i = begin_; i &lt;= end_; ++i)</span><br><span class="line">            sum += i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;end!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 在submitTask函数中 加打印线程的相关信息 */</span></span><br><span class="line"><span class="function">Result <span class="title">ThreadPool::submitTask</span><span class="params">(std::shared_ptr&lt;Task&gt; sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*			...			*/</span></span><br><span class="line">    <span class="keyword">if</span>(poolMode == PoolMode::MODE_CACHED</span><br><span class="line">      &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">      &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread ...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;Thead&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc,</span><br><span class="line">                      <span class="keyword">this</span>, std::placeholders::_1)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();	<span class="comment">//启动线程</span></span><br><span class="line">        <span class="comment">/* 修改线程个数相关的变量 */</span></span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(sp);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 暂时修改超时时间，方便测试观察 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_IDLE_TIME = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">                    	<span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line">					<span class="comment">/*			...			*/</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* 默认初始四线程，六任务。</span></span><br><span class="line"><span class="comment"> * 每个任务都至少消耗3秒，</span></span><br><span class="line"><span class="comment"> * 开始时会把四个线程都占住，会创建新的线程来完成后两个任务</span></span><br><span class="line"><span class="comment"> * 全部任务完成后，超过10秒后，会把多余的2个线程回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TASK_MAX_THRESHHOLD = INT32_MAX;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_MAX_THRESHHOLD = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadPool pool;</span><br><span class="line">        pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">        pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">        Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>,<span class="number">100000000</span>));			<span class="comment">//1</span></span><br><span class="line">        Result res2 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">100000001</span>,<span class="number">200000000</span>));	<span class="comment">//2</span></span><br><span class="line">        Result res3 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));	<span class="comment">//3</span></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//5</span></span><br><span class="line">        pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">200000001</span>,<span class="number">300000000</span>));					<span class="comment">//6</span></span><br><span class="line">        uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">        uLong sum2 = res<span class="number">2.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">        uLong sum3 = res<span class="number">3.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试结果</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172417250.png" alt="image-20220407172417250" /></p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172451064.png" alt="image-20220407172451064" /></p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A02.0/image-20220407172642102.png" alt="image-20220407172642102" /></p>

        <h2 id="问题threadpool对象析构以后怎么样把线程池相关的线程资源全部回收"   >
          <a href="#问题threadpool对象析构以后怎么样把线程池相关的线程资源全部回收" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题threadpool对象析构以后怎么样把线程池相关的线程资源全部回收"></a> 问题：ThreadPool对象析构以后，怎么样把线程池相关的线程资源全部回收</h2>
      
<p>在析构函数中，用户线程需要等待线程池线程，这是两类不同的线程，需要通过线程间通信来达到等待完成。</p>
<p>线程间通信可以用信号量、条件变量，都可以，我们在ThreadPool类中使用一个条件变量<code>exitCond_</code>。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 等待线程资源全部回收 */</span></span><br><span class="line">    std::condition_variable exitCond_;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在析构函数中，</p>
<ol>
<li>置<code>isPoolRunning_</code>为false，如此线程函数进去之后发现线程池要关闭了，
<ol>
<li>如果任务队列为0，则就直接退出。</li>
<li>如果任务队列不为0则取任务。</li>
</ol>
</li>
<li><code>notEmpty_.notify_all();</code>，最后一波唤醒，让所有线程醒来，看有没有任务，没任务就收工。</li>
<li>ThreadPool关注<code>exitCond_</code>，若有人通知了，则说明是线程陆陆续续在退出了，直到<code>threads_.size() == 0</code>，说明所有线程都退出了。这时候，线程池就可以放心析构了。</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">/* 等待线程池中所有的线程返回，有两种状态：阻塞/执行中 */</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>() == <span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="项目推进时遇到了什么问题"   >
          <a href="#项目推进时遇到了什么问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#项目推进时遇到了什么问题"></a> 项目推进时遇到了什么问题？</h1>
      
<ol>
<li>实现核心功能时的问题：如何通用地获取提交任务后的返回值，即Any，Result的设计。</li>
<li>设计线程池资源回收的，是以…的方式实现的，测试时，有时会出现死锁的现象</li>
</ol>

        <h2 id="调试方法"   >
          <a href="#调试方法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#调试方法"></a> 调试方法</h2>
      
<p>gdb调试，attach到正在死锁的进程，把线程栈打印出来，在哪一个函数的哪一句话不动了。</p>
<p>问题要素：<br />
1、线程池要结束，要释放整个池子的资源了。<br />
2、线程池的成员<code>isPoolRunning_</code>状态置为了<code>false</code>。</p>
<p>以上两个要素</p>
<p>1，不受线程池内的线程目前的状态而影响，线程的状态：在等待任务、在执行任务。<br />
2，<code>isPoolRunning_</code>必将影响线程的代码路径。</p>
<p><code>isPoolRunning_</code>在线程池<code>start</code>时置为<code>true</code>。</p>
<p>我们设计的ThreadPool不用考虑成员的析构问题，最主要的两个成员容器：<br />
1、无序map中的线程对象是<code>unique_ptr</code>管理的。<br />
2、queue中的任务队列是<code>shared_ptr</code>管理的。<br />
3、其余的变量都是非指针变量。</p>
<p>ThreadPool析构时仅仅只是把<code>isPoolRunning_</code>置<code>false</code>就可以了吗？<br />
当然不可以。线程池要等待线程池里面所有的线程返回。<br />
目前线程可能在<code>threadFunc</code>函数中阻塞在<code>notEmpty</code>上，另一种是正在执行任务中。</p>
<p>此时就需要不同线程的通信。即用户线程和线程池中的线程之间进行通信。<br />
用信号量、条件变量都可以。<br />
我们用条件变量。<br />
在ThreadPool中定义一个成员，<code>std::condition_variable exitCond_;</code> 等待线程资源全部回收</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* 我们暂且在这个位置 唤醒notEmpty_上的所有线程 */</span>	<span class="comment">//实际上，是留了一个坑</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="comment">/* 表明：要等待到threads_.size()等于0 */</span></span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能会产生死锁的情况：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">4</span>);</span><br><span class="line">    Result res1 = pool.<span class="built_in">submitTask</span>(std::<span class="built_in">make_shared</span>&lt;MyTask&gt;(<span class="number">1</span>,<span class="number">10000000</span>));</span><br><span class="line">    uLong sum1 = res<span class="number">1.</span><span class="built_in">get</span>().<span class="built_in">cast_</span>&lt;uLong&gt;();</span><br><span class="line">    cout &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main over!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果</span></span><br><span class="line"><span class="comment"> * tid: 9624尝试获取任务..</span></span><br><span class="line"><span class="comment"> * tid: 9624获取任务成功...</span></span><br><span class="line"><span class="comment"> * tid:tid: 1664尝试获取任务...</span></span><br><span class="line"><span class="comment"> * 9624begin!</span></span><br><span class="line"><span class="comment"> * tid: 15228尝试获取任务...</span></span><br><span class="line"><span class="comment"> * tid:6796尝试获取任务...</span></span><br><span class="line"><span class="comment"> * tid:9624end!</span></span><br><span class="line"><span class="comment"> * tid:9624尝试获取任务...5000000050000000</span></span><br><span class="line"><span class="comment"> * main over!</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * threadid:6796 exit!</span></span><br><span class="line"><span class="comment"> * threadid:s1664 exit!</span></span><br><span class="line"><span class="comment"> * threadid:15228 exit!</span></span><br><span class="line"><span class="comment"> *		//发现，抢到任务的线程回不来了。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="代码分析"   >
          <a href="#代码分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main函数所在的主线程，即用户创建线程池的线程 */</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 线程池中的每个线程的线程函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lastTime = ...;</span><br><span class="line">    <span class="keyword">while</span>(isPoolRunning_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;		<span class="comment">//抢锁动作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务... &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">while</span>(taskQue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* timeout==wait_for的返回值 意味着等待超时了 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//回收长时间空闲的线程</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 否则，说明被唤醒了，有任务了，且抢到锁了，继续往下 */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/* 若不是cached模式，则按部就班老实等待 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">if</span>(!isPoolRunning_)</span><br><span class="line">            &#123;</span><br><span class="line">                threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;threadid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                    &lt;&lt; <span class="string">&quot; exit:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">/* 每一个线程删除后，都通知exitCond_一下，唤醒用户主线程 */</span></span><br><span class="line">                exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 若被唤醒了，有任务了，且抢到锁了，而且确认了isPoolRunning，则可以取得任务 */</span></span><br><span class="line">        --idleThreadSize_;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tid:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>第一种情况：线程是固定模式，任务队列空时，等待在<code>notEmpty_</code>上。这种情况我们不怕，因为线程池析构函数已经写了<code>notEmpty_.notify_all()</code>;</p>
<p>第二种情况：<code>task-&gt;exec()</code>中，即线程执行任务中。这种也没事，线程执行完任务再次进入while循环判断时发现<code>isPoolRunning_为false</code>了，则删除线程，退出。</p>
<p>第三种情况才是关键，线程<code>task-&gt;exec()</code> 执行完后进入了<code>while (isPoolRunning_)</code>循环，到了获取锁语句之前的位置。这时，线程池关闭了，也就是说在Running状态切换为<code>false</code>！现在，线程池、子线程的下一个动作都是对<code>taskQueMtx_</code>进行加锁！而最关键的，<strong>如果能够“阴差阳错地”进入第二个<code>while</code>循环，那么就会在<code>notEmpty_</code>上等死</strong>，因为此时线程池在语义上是已经关闭了，没人再去唤醒它。</p>
<p>第三种情况中的第一种情况：线程池抢到锁，又在<code>exitCond_</code>上<code>wait</code>阻塞，而子线程虽然能抢到锁，但是会死在<code>notEmpty_</code>上。</p>
<p>第三种情况中的第二种情况：子线程抢到锁，往下执行，则没有任务时，在<code>notEmpty_</code>上等待会放弃锁，阻塞自己，线程池之后会抢到锁，等待线程结束。<strong>这时没有人去唤醒notEmpty_上的子线程了。死锁。这是问题之关键</strong>。</p>
<p>那么，第三种情况怎么解决死锁问题呢？</p>
<p>我们注意到，第三种情况中第一种情况的问题是因为线程池<code>exitCond_.wait()</code>后，进入了第一个<code>while</code>后争抢<code>lock</code>的线程可能拿到锁后，顺理成章进入第二个<code>while</code>中，若恰逢没有任务，则死在了<code>notEmpty_</code>上。所以为了防止错误的时机进入到第二个<code>while</code>循环中，在条件处首先再判断一次<code>isPoolRunning_</code>。</p>

        <h3 id="31的解决方案锁双重判断"   >
          <a href="#31的解决方案锁双重判断" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#31的解决方案锁双重判断"></a> 3.1的解决方案：锁+双重判断</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lastTime = ...;</span><br><span class="line">    <span class="keyword">while</span>(isPoolRunning_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Task&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; ... &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">while</span>(isPoolRunning_ &amp;&amp; taskQue_.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//退出while的两种情况：1.!Running, 2.Running &amp;&amp; taskQue_.size()!=0</span></span><br><span class="line">            <span class="keyword">if</span>(!isPoolRunning_)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取任务成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)task-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        lastTime = ...;</span><br><span class="line">    &#125;</span><br><span class="line">    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;线程退出&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如此一来，线程池先抢到锁，再在<code>exitCond_</code>上<code>wait</code>阻塞释放锁后，子线程得到锁向下走到了第二个while语句，由于再次判断<code>isPoolRunning_</code>，这时发现改变为<code>false</code>了，就不会走到<code>notEmpty_.wait()</code>了。灰溜溜去做删除动作了。</p>

        <h3 id="32的解决方案调整加锁位置"   >
          <a href="#32的解决方案调整加锁位置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#32的解决方案调整加锁位置"></a> 3.2的解决方案：调整加锁位置</h3>
      
<p>虽然3.1解决了<code>isPoolRunning</code>状态脏读这个漏洞问题，但是依旧不能解决“子线程先抢到锁”从而在<code>notEmpty_</code>上等待这种情况发生。即使子线程释放了锁，但是没有人再去唤醒<code>notEmpty_</code>，因为原来的语序是先唤醒，再抢锁。所以我们要让用户线程的加锁、唤醒放在子线程wait之后，<strong>要让子线程wait释放了锁之后，才让用户线程唤醒<code>notEmpty_</code></strong>！于是：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    isPoolRunning_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    exitCond_.<span class="built_in">wait</span>(lock, [&amp;]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> threads_.<span class="built_in">size</span>()==<span class="number">0</span>;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>调换了一下第二、第三句，即子线程先抢到锁后wait在<code>notEmpty_</code>上后释放锁，用户线程再抢到锁之后才去<code>notify_all()</code>它，那么阻塞的子线程被唤醒了，往下执行，发现<code>isPoolRunning_</code>变为<code>false</code>了，灰溜溜去做删除动作了。完美解决问题。</p>

        <h1 id="编译为动态库"   >
          <a href="#编译为动态库" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#编译为动态库"></a> 编译为动态库</h1>
      

        <h2 id="直接在命令行使用g编译"   >
          <a href="#直接在命令行使用g编译" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#直接在命令行使用g编译"></a> 直接在命令行使用<code>g++</code>编译</h2>
      
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o libxcg-threadpool.so -fPIC -shared [源文件如: threadpool.cpp] -std=c++17</span><br></pre></td></tr></table></div></figure>

        <h2 id="用cmake构建编译"   >
          <a href="#用cmake构建编译" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#用cmake构建编译"></a> 用cmake构建编译</h2>
      

        <h3 id="根目录"   >
          <a href="#根目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#根目录"></a> 根目录</h3>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(xcg-threadpool)</span><br><span class="line"><span class="comment">#配置编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -g)</span><br><span class="line"><span class="comment">#配置最终的库文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#配置头文件的搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#加载子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></div></figure>

        <h3 id="src目录"   >
          <a href="#src目录" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#src目录"></a> src目录</h3>
      
<figure class="highlight cmake"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义了SRC_LIST变量，包含了该目录下所有的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="comment">#指定生成可执行文件</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment">#指定可执行文件链接时 需要依赖的库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(xcg-threadpool pthread)</span><br></pre></td></tr></table></div></figure>

        <h1 id="使用动态库编译可执行文件"   >
          <a href="#使用动态库编译可执行文件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#使用动态库编译可执行文件"></a> 使用动态库编译可执行文件</h1>
      
<p>首先需要把动态库<code>libxcg-threadpool.so</code>移动到<code>/usr/lib</code>或<code>/usr/local/lib</code>；把动态库对应的头文件<code>threadpool.h</code>移动到<code>/usr/include</code>或<code>/usr/local/include</code>下。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp -std=c++17 -lxcg-threadpool -lpthread</span><br></pre></td></tr></table></div></figure>

        <h1 id="重构简洁版的线程池"   >
          <a href="#重构简洁版的线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#重构简洁版的线程池"></a> 重构简洁版的线程池</h1>
      
<p>要对外提供一个简单易用的submitTask接口。<br />
让用户直接传一个：<code>future result = submitTask(func, 1, 2);</code><br />
而不用再去继承一个抽象的Task了，甚至还得<code>make_shared&lt;MyTask()&gt;(func, 1, 2);</code>，这样太繁琐了。</p>
<p>主要用到的技巧就是：可变参模板，万能引用，函数绑定器，完美转发。<br />
submitTask的返回类型无法写出，需要用到auto占位，之后用decltype进行推导。</p>

        <h2 id="threadpool成员变量"   >
          <a href="#threadpool成员变量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadpool成员变量"></a> ThreadPool成员变量</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::unique_ptr&lt;Thread&gt;&gt; threads_;</span><br><span class="line">    <span class="type">int</span> initThreadSize_;</span><br><span class="line">    <span class="type">int</span> threadSizeThreshHold_;</span><br><span class="line">    std::atomic_int curThreadSize_;</span><br><span class="line">    std::atomic_int idleThreadSize_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="comment">// 此处之前的版本是智能指针管理的task，目前不需要了。</span></span><br><span class="line">    <span class="comment">// 因为我们把sharedptr对Task的包装都在submitTask内部进行封装了。</span></span><br><span class="line">    std::queue&lt;Task&gt; taskQue_;</span><br><span class="line"></span><br><span class="line">    std::atomic_int taskSize_;</span><br><span class="line">    <span class="type">int</span> taskQueMaxThreshHold_;</span><br><span class="line"></span><br><span class="line">    std::mutex taskQueMtx_;</span><br><span class="line">    std::condition_variable notFull_;</span><br><span class="line">    std::condition_variable notEmpty_;</span><br><span class="line">    std::condition_variable exitCond_;</span><br><span class="line"></span><br><span class="line">    PoolMode poolMode_;</span><br><span class="line">    std::atomic_bool isPoolRunning_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h2 id="优化submittask"   >
          <a href="#优化submittask" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#优化submittask"></a> 优化submitTask</h2>
      
<p>以下的关键点：任务队列中存储的任务（lambda）捕获了<code>shared_ptr</code>，因此当这个任务被执行时，它仍然持有一个<code>shared_ptr</code>，这样<code>packaged_task</code>就不会在执行前被销毁。<br />
当任务执行完毕，这个lambda就会被销毁，那么它持有的<code>shared_ptr</code>也会被销毁（引用计数减一）。如果这时没有其他<code>shared_ptr</code>引用（比如在<code>submitTask</code>函数中，除了任务队列中的那个<code>shared_ptr</code>，还有<code>submitTask</code>函数中的局部变量<code>task</code>），那么<code>packaged_task</code>就会在任务执行完毕后被销毁。</p>
<p>但是，在submitTask函数中，我们返回了一个<code>future</code>，这个<code>future</code>是与<code>packaged_task</code>关联的。值得注意的是，<code>std::packaged_task</code>的析构不会影响其关联的<code>future</code>吗？不会。因为<code>std::future</code>是通过共享状态（shared state）与<code>std::packaged_task</code>关联的，这个共享状态独立于<code>packaged_task</code>对象。也就是说，即使<code>packaged_task</code>对象销毁了，只要共享状态还存在（因为<code>future</code>还持有），那么<code>future</code>仍然可以正常工作。所以，<code>packaged_task</code>对象销毁后，<code>future</code>的<code>get()</code>仍然可以正常返回结果（或者异常）。</p>
<p>我们要明确的：<br />
future只是负责持有结果。但<br />
<strong>future 不会延长 task 的生命周期​</strong>​，</p>
<ul>
<li><code>std::future</code> 只管理​<strong>​共享状态​</strong>​（shared state）的生命周期（存储结果的内存区域）</li>
<li>​<strong>​不会​</strong>​延长关联的 <code>packaged_task</code> 对象的生命周期</li>
<li><code>future</code> 只依赖共享状态，不依赖 <code>packaged_task</code> 对象本身。即共享状态的生命周期独立于 <code>packaged_task</code>
<ul>
<li>由最后一个引用它的 <code>future</code> 或 <code>shared_future</code> 管理</li>
<li>与 <code>packaged_task</code> 对象的销毁无关</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class PackagedTask &#123;</span><br><span class="line">        +operator()()</span><br><span class="line">        +get_future()</span><br><span class="line">        -shared_state* </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class SharedState &#123;</span><br><span class="line">        +result</span><br><span class="line">        +ready_flag</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Future &#123;</span><br><span class="line">        +shared_state*</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PackagedTask --&gt; SharedState : 独占拥有</span><br><span class="line">    Future --&gt; SharedState : 只读引用</span><br></pre></td></tr></table></div></figure>
<p>关键点：</p>
<ol>
<li><code>packaged_task</code> ​<strong>​独占拥有​</strong>​共享状态的生命周期</li>
<li><code>future</code> ​<strong>​只持有对共享状态的弱引用​</strong>​</li>
<li>移动、销毁 <code>packaged_task</code> 会​<strong>​转移共享状态的所有权​</strong>。但是不会销毁SharedState，因为外部还有Future在观察。
<ol>
<li>因此，其实也可以在之前就保存下来task的future，然后再去把task转移给任务队列。这样无所谓task是否在外部获得结果之前销毁了。
<ol>
<li>但是这样会限制task在移动之后的操作，无法在移动之后获得future了。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>关键点：</p>
<ol>
<li>​<strong>​共享所有权​</strong>​：
<ul>
<li>任务队列和工作线程共同持有 <code>shared_ptr</code>。
<ul>
<li>（⭐）当 lambda 被放入队列时，<code>shared_ptr</code> 的引用计数增加</li>
</ul>
</li>
<li>最后一个持有者释放时 <code>packaged_task</code> 才会销毁
<ul>
<li>当队列中的 lambda 被销毁时，<code>shared_ptr</code> 引用计数减少</li>
</ul>
</li>
</ul>
</li>
<li>​<strong>​生命周期安全​</strong>​：
<ul>
<li>即使 <code>submitTask</code> 返回，只要队列或线程持有 <code>shared_ptr</code></li>
<li><code>packaged_task</code> 对象会一直存活到任务执行完成</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RType</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    std::future&lt;RType&gt; result = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>),</span><br><span class="line">        [&amp;]() -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;task queue is full, submit task failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 这里，用 lambda 表达式 充当 线程函数 func，函数中只返回一个空RType()</span></span><br><span class="line">        <span class="comment">// RType()即一个默认构造的 future</span></span><br><span class="line">        <span class="comment">// 但是可能会出现两个问题：</span></span><br><span class="line">        <span class="comment">// 1. RType 没有默认构造函数（如 std::atomic），</span></span><br><span class="line">        <span class="comment">// 2. 语义不准确，应该显式指出 提交失败的原因</span></span><br><span class="line">        <span class="comment">// auto task = std::make_shared&lt;std::packaged_task&lt;RType()&gt;&gt;(</span></span><br><span class="line">        <span class="comment">//     []() -&gt; RType &#123; return RType(); &#125;);</span></span><br><span class="line">        <span class="comment">// task();</span></span><br><span class="line">        <span class="comment">// return task-&gt;get_future();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 改进方案一：</span></span><br><span class="line">        <span class="comment">// return std::async(std::launch::deferred, </span></span><br><span class="line">        <span class="comment">//     [] &#123; throw std::runtime_error(&quot;Task queue full&quot;); &#125;).share().get_future();</span></span><br><span class="line">        <span class="comment">// 改进方案二：</span></span><br><span class="line">        std::promise&lt;RType&gt; p;</span><br><span class="line">        p.<span class="built_in">set_exception</span>(std::<span class="built_in">make_exception_ptr</span>(std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue full&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">get_future</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键：task这个shared_ptr，由这个lambda表达式捕获了，之后这个task的生命周期就和任务队列一致了。</span></span><br><span class="line">    taskQue_.<span class="built_in">emplace</span>([task]() &#123; (*task)(); &#125;);</span><br><span class="line">    ++taskSize_;</span><br><span class="line"></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED</span><br><span class="line">        &amp;&amp; taskSize_ &gt; idleThreadSize_</span><br><span class="line">        &amp;&amp; curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; create new thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 创建新的线程对象</span></span><br><span class="line">        <span class="keyword">auto</span> ptr = std::make_unique&lt;<span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::threadFunc, <span class="keyword">this</span>, std::placeholder::_1));</span><br><span class="line">        <span class="type">int</span> threadId = ptr-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        threads_.<span class="built_in">emplace</span>(threadId, std::<span class="built_in">move</span>(ptr));</span><br><span class="line">        threads_[threadId]-&gt;<span class="built_in">start</span>();</span><br><span class="line">        ++curThreadSize_;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="再次优化submittask"   >
          <a href="#再次优化submittask" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#再次优化submittask"></a> 再次优化submitTask</h2>
      
<ul>
<li><code>future</code> 只依赖共享状态，不依赖 <code>packaged_task</code> 对象本身。即共享状态的生命周期独立于 <code>packaged_task</code>
<ul>
<li>由最后一个引用它的 <code>future</code> 或 <code>shared_future</code> 管理</li>
<li>与 <code>packaged_task</code> 对象的销毁无关</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class PackagedTask &#123;</span><br><span class="line">        +operator()()</span><br><span class="line">        +get_future()</span><br><span class="line">        -shared_state* </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class SharedState &#123;</span><br><span class="line">        +result</span><br><span class="line">        +ready_flag</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Future &#123;</span><br><span class="line">        +shared_state*</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PackagedTask --&gt; SharedState : 独占拥有</span><br><span class="line">    Future --&gt; SharedState : 只读引用</span><br></pre></td></tr></table></div></figure>
<p>关键点：</p>
<ol>
<li><code>packaged_task</code> ​<strong>​独占拥有​</strong>​共享状态的生命周期</li>
<li><code>future</code> ​<strong>​只持有对共享状态的弱引用​</strong>​</li>
<li>移动、销毁 <code>packaged_task</code> 会​<strong>​转移共享状态的所有权​</strong>。但是不会销毁SharedState，因为外部还有Future在观察。
<ol>
<li>因此，其实也可以在之前就保存下来task的future，然后再去把task转移给任务队列。这样无所谓task是否在外部获得结果之前销毁了。
<ol>
<li>移动task的缺点：但是这样会限制task在移动之后的操作，无法在移动之后获得future了。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>优化点：</p>
<ol>
<li>完美转发捕获（C++20）代替 <code>std::bind</code>，更高效且避免额外开销</li>
<li>移动task到lambda中，而不是建立<code>shared_ptr</code>来管理它。比<code>shared_ptr</code>版本更轻量高效（减少一次堆分配）。<br />
注意点：<br />
为什么需要mutable？</li>
</ol>
<p>因为<code>packaged_task</code>的<code>operator()</code>调用会改变<code>packaged_task</code>对象（它内部会执行任务并将结果存储到共享状态，所以会改变<code>packaged_task</code>的状态），因此<code>lambda</code>的调用运算符必须声明为<code>mutable</code>，否则编译器会认为你在一个<code>const</code>的<code>lambda</code>中试图修改捕获的对象。<br />
所以，这里mutable是必须的。</p>
<p>在完美转发捕获可变参时，为什么也需要加mutable？<br />
我们通过完美转发捕获了<code>func</code>和<code>args</code>。在lambda体内，我们调用了<code>func</code>，并使用了<code>std::forward&lt;Args&gt;(args)...</code>来转发参数。由于<strong>转发可能意味着移动（当参数是右值时），这会修改捕获的<code>args</code></strong>（移动后，对象的状态被改变，通常为空或有效状态被转移）。因此，我们需要<code>mutable</code>来允许对捕获的变量进行修改（包括移动操作）。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submitTask</span><span class="params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(func(args...))</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RType = <span class="keyword">decltype</span>(<span class="built_in">func</span>(args...));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 创建任务和future</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::<span class="built_in">packaged_task</span>&lt;<span class="built_in">RType</span>()&gt;(</span><br><span class="line">        [func = std::forward&lt;Func&gt;(func), ...args = std::forward&lt;Args&gt;(args)] () <span class="keyword">mutable</span> </span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">func</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;); <span class="comment">// ✅ 完美转发捕获(C++20)</span></span><br><span class="line">    </span><br><span class="line">    std::future&lt;RType&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 锁保护队列操作</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 检查队列容量</span></span><br><span class="line">    <span class="keyword">if</span> (!notFull_.<span class="built_in">wait_for</span>(lock, <span class="number">1</span>s, </span><br><span class="line">        [&amp;] &#123; <span class="keyword">return</span> taskQue_.<span class="built_in">size</span>() &lt; taskQueMaxThreshHold_; &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 优雅的错误处理</span></span><br><span class="line">        std::promise&lt;RType&gt; p;</span><br><span class="line">        p.<span class="built_in">set_exception</span>(</span><br><span class="line">            std::<span class="built_in">make_exception_ptr</span>(std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue full&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">get_future</span>(); <span class="comment">// ⏱️ 立即就绪的异常future</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 提交任务到队列</span></span><br><span class="line">    taskQue_.<span class="built_in">emplace</span>([task = std::<span class="built_in">move</span>(task)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">task</span>(); <span class="comment">// ✅ 执行移动后的任务</span></span><br><span class="line">    &#125;);</span><br><span class="line">    ++taskSize_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 通知工作线程</span></span><br><span class="line">    notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 动态扩缩容逻辑 (CACHED模式)</span></span><br><span class="line">    <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED &amp;&amp; </span><br><span class="line">        taskSize_ &gt; idleThreadSize_ &amp;&amp;</span><br><span class="line">        curThreadSize_ &lt; threadSizeThreshHold_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... 创建新线程 (省略细节)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 🎯 返回有效的future</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="threadfunc的重构"   >
          <a href="#threadfunc的重构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#threadfunc的重构"></a> threadFunc的重构</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_IDLE_TIME = <span class="number">60</span>;	<span class="comment">//单位s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadFunc</span><span class="params">(<span class="type">int</span> threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 上一次线程执行完任务的时间 */</span></span><br><span class="line">    <span class="keyword">auto</span> lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处之前的版本是智能指针管理的task，目前不需要了。</span></span><br><span class="line">        <span class="comment">// 因为我们把sharedptr对Task的包装都在submitTask内部进行封装了。</span></span><br><span class="line">    	Task task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(taskQueMtx_)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;尝试获取任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// cached模式下，有可能已经创建了很多的线程，但是空闲时间超过60s，应该把多余的线程</span></span><br><span class="line">            <span class="comment">// 结束回收掉（超过initThreadSize_数量的线程要进行回收）</span></span><br><span class="line">            <span class="comment">// 当前时间 - 上一次线程执行的时间 &gt; 60s</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每一秒中返回一次   怎么区分：超时返回？还是有任务待执行返回</span></span><br><span class="line">            <span class="comment">// 锁 + 双重判断</span></span><br><span class="line">            <span class="keyword">while</span> (taskQueue_.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 线程池要结束，回收线程资源</span></span><br><span class="line">                <span class="keyword">if</span> (!isPoolRunning_)</span><br><span class="line">                &#123;</span><br><span class="line">                    threads_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                        &lt;&lt; std::endl;</span><br><span class="line">                    exitCond_.<span class="built_in">notify_all</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (poolMode_ == PoolMode::MODE_CACHED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//while(taskQue_.size() &gt; 0) // 不再去判断 taskQue_.size() &gt; 0，即使size是0，也一直等待60s</span></span><br><span class="line">                    <span class="comment">//&#123;</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* 超时 1s 返回 */</span></span><br><span class="line">                    <span class="keyword">if</span>(std::cv_status::timeout ==</span><br><span class="line">                       notEmpty_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span> now = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>(); <span class="comment">//返回的是time_point类型</span></span><br><span class="line">                        <span class="keyword">auto</span> dur = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(now - lastTime);</span><br><span class="line">                        <span class="keyword">if</span>(dur.<span class="built_in">count</span>() &gt;= THREAD_MAX_IDLE_TIME</span><br><span class="line">                          &amp;&amp; curThreadSize_ &gt; initThreadSize_)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/* 开始回收当前线程 */</span></span><br><span class="line">                            <span class="comment">/* 修改记录线程数量的相关变量 */</span></span><br><span class="line">                            <span class="comment">/* 把线程从线程列表容器中删除 */</span></span><br><span class="line">                            <span class="comment">/* 问题：怎么知道线程函数对应的是线程列表容器中的哪一个线程对象 */</span></span><br><span class="line">                            <span class="comment">/* 我们需要有一个映射关系来记录：threadid =&gt; thread对象 =&gt; 删除 */</span></span><br><span class="line">                            thread_.<span class="built_in">erase</span>(threadid);</span><br><span class="line">                            --curThreadSize_;</span><br><span class="line">                            --idleThreadSize_;</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;threadid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; exit!&quot;</span></span><br><span class="line">                                &lt;&lt; std::endl;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//&#125; // while(taskQue_.size() &gt; 0) 结束</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// poolMode_ != PoolMode::MODE_CACHED</span></span><br><span class="line">                &#123;</span><br><span class="line">                    notEmpty_.<span class="built_in">wait</span>(lock <span class="comment">/* , [&amp;]()-&gt;bool &#123; return taskQue_.size() &gt; 0; &#125; */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end while (taskQueue_.size() == 0)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 taskQueue_.size() != 0 而 我们又拿到了 任务队列的锁，可以直接取走任务</span></span><br><span class="line">            --idleThreadSize_;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;tid: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;获取任务成功...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            task = taskQue_.<span class="built_in">front</span>();</span><br><span class="line">            taskQue_.<span class="built_in">pop</span>();</span><br><span class="line">            --taskSize_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (taskQue_.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty_.<span class="built_in">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notFull_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125; <span class="comment">// end std::unique_lock&lt;std::mutex&gt; lock(taskQueMtx_);</span></span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ++idleThreadSize_;</span><br><span class="line">        <span class="comment">/* 线程执行完任务后更新lastTime */</span></span><br><span class="line">        lastTime = std::chrono::<span class="built_in">high_resolution_clock</span>().<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>测试</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">setMode</span>(PoolMode::MODE_CACHED);</span><br><span class="line">    pool.<span class="built_in">start</span>(<span class="number">2</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res1 = pool.<span class="built_in">submitTask</span>(sum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res2 = pool.<span class="built_in">submitTask</span>([](<span class="type">int</span> begin, <span class="type">int</span> end) -&gt; <span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res3 = pool.<span class="built_in">submitTask</span>(sum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    future&lt;<span class="type">int</span>&gt; res4 = pool.<span class="built_in">submitTask</span>(sum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res<span class="number">4.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E9%A1%B9%E7%9B%AE/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B/">半同步半异步线程池模型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-03-30</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-09-16</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/%E9%A1%B9%E7%9B%AE/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B/" data-flag-title="半同步半异步线程池模型"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="内容"   >
          <a href="#内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内容"></a> 内容</h1>
      
<ol>
<li>半同步半异步线程池介绍</li>
</ol>

        <h1 id="线程池介绍"   >
          <a href="#线程池介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池介绍"></a> 线程池介绍</h1>
      
<p>在处理大量并发任务的时候，如果按照传统的方式：来一个任务请求，对应一个线程来处理请求任务。那么大量的线程创建和销毁将消耗过多的系统资源，还增加了线程上下文（运行环境）切换的开销，而通过线程池技术就可以很好地解决这些问题。</p>
<p>线程池技术通过在系统中预先创建一定数量的线程，当任务请求到来时从线程池中分配一个<strong>预先创建的线程</strong>去处理任务，线程在处理完任务之后还可以重用，<strong>不会销毁</strong>，而是等待下次任务的到来。这样，通过线程池能<strong>避免大量的线程创建和销毁动作，从而节省系统资源</strong>。</p>
<p>这样做的一个好处是，对于多核处理器，由于线程会被分配到多个CPU，会<strong>提高并行处理的效率</strong>；另一个好处是<strong>每个线程独立阻塞</strong>，可以防止主线程被阻塞而使主流程被阻塞，导致其他的请求得不到响应的问题。</p>
<p>线程池分为半同步半异步线程池和领导者追随者线程池，本文将主要介绍半同步半异步线程池，这种线程池在实现上更简单，使用得比较多。</p>

        <h1 id="半同步半异步线程池结构"   >
          <a href="#半同步半异步线程池结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#半同步半异步线程池结构"></a> 半同步半异步线程池结构</h1>
      
<p>半同步半异步线程池分成三层，如图所示。</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220330153004372.png" alt="image-20220330153004372" /></p>
<p>第一层是同步服务层，它处理来自上层的任务请求，上层的请求可能是并发的，这些请求不是马上就会被处理，而是将这些任务放到一个同步排队层中，等待处理。</p>
<p>第二层是同步排队层，来自上层的任务请求都会加到排队层中等待处理。</p>
<p>第三层是异步服务层，这一层中会有多个线程同时处理排队层中的任务，异步服务层从同步排队层中取出任务并行的处理。</p>
<p>这种三层的结构可以最大程度处理上层的并发请求。对于上层来说只要将任务丢到同步队列中就行了，至于谁去处理，什么时候处理都不用关心，主线程也不会阻塞，还能继续发起新的请求。至于任务具体怎么处理，这些细节都是靠异步服务层的多线程异步并行来完成的，这些线程是一开始就创建的，不会因为大量的任务到来而创建新的线程，避免了频繁创建和销毁线程导致的系统开销，而且通过多核处理能大幅提高处理效率。</p>

        <h1 id="关键技术分析"   >
          <a href="#关键技术分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关键技术分析"></a> 关键技术分析</h1>
      
<p>同步排队层居于核心地位，因为上层会将任务加到排队层中，异步服务层同时也会取出任务，这里有一个同步的过程。</p>
<p>在实现时，排队层就是一个同步队列，允许多个线程同时添加或取出任务，并且要保证操作过程是安全的。</p>
<p>线程池有两个活动过程，一个是往同步队列中添加任务，另一个是从同步队列中取任务。活动图如图所示。</p>
<p><img src="../../images/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220330154305073.png" alt="image-20220330154305073" /></p>
<p>从活动图中可以看到线程池的活动过程，一开始线程池会启动一定数量的线程，这些线程属于异步层，主要用来并行处理排队层中的任务。</p>
<p>如果排队层中的任务数为空，则这些线程等待任务的到来，如果发现排队层中有任务了，线程池则会从等待的这些线程中唤醒一个来处理新任务。同步服务层则会不断地将新的任务添加到同步排队层中这里有个问题值得注意，有可能上层的任务非常多，而任务又是非常耗时的，这时，异步层中的线程处理不过来，则同步排队层中的任务会不断增加，如果同步排队层不加上限控制，则可能会导致排队层中的任务过多、内存暴涨的问题。因此，排队层需要加上限的控制，当排队层中的任务数达到上限时，就不让上层的任务添加进来，起到限制和保护的作用。</p>

        <h1 id="同步队列"   >
          <a href="#同步队列" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#同步队列"></a> 同步队列</h1>
      
<p>同步队列即为线程中三层结构中的中间那一层，它的主要作用是保证队列中共享数据线程安全，还为上一层同步服务层提供添加新任务的接口，以及为下一层异步服务层提供取任务的接口。同时，还要限制任务数的上限，避免任务过多导致内存暴涨的问题。</p>
<p>同步队列的实现比较简单，我们会用到C++11的锁、条件变量、右值引用、std::move以及std::forward。move是为了实现移动语义，forward是为了实现完美转发。</p>
<p>同步队列的锁是用来线程同步的。</p>
<p>条件变量是用来实现线程通信的，即线程池空了就要等待，不为空就通知一个线程去处理；线程池满了就等待，直到没有满的时候才通知上层添加新任务。</p>
<p>同步队列的具体实现如下。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize), <span class="built_in">m_needStop</span>(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Add</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(T &amp;&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Add</span>(std::forward&lt;T&gt;(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Take</span><span class="params">(std::list&lt;T&gt;&amp; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">//如果队列没有停止运行，则继续看任务队列是否空，如果空则阻塞，不空则继续</span></span><br><span class="line">        m_notEmpty.<span class="built_in">wait</span>(locker,</span><br><span class="line">                       [<span class="keyword">this</span>]()-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> m_needStop || <span class="built_in">NotEmpty</span>();&#125;);</span><br><span class="line">        <span class="keyword">if</span>(m_needStop)<span class="keyword">return</span>;</span><br><span class="line">        list = std::<span class="built_in">move</span>(m_queue);	<span class="comment">//move对于list来说只移动容器内部对象</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Take</span><span class="params">(T &amp; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">//如果队列没有停止运行，则继续看任务队列是否空，如果空则阻塞，不空则继续</span></span><br><span class="line">        m_notEmpty.<span class="built_in">wait</span>(locker,</span><br><span class="line">                       [<span class="keyword">this</span>]()-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> m_needStop || <span class="built_in">NotEmpty</span>();&#125;);</span><br><span class="line">        <span class="keyword">if</span>(m_needStop)<span class="keyword">return</span>;</span><br><span class="line">        t = m_queue.<span class="built_in">front</span>();	<span class="comment">//赋值拷贝</span></span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; m_queue;	<span class="comment">//任务</span></span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    std::condition_variable m_notEmpty;	<span class="comment">//异步任务层</span></span><br><span class="line">    std::condition_variable m_notFull;	<span class="comment">//同步任务层</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;</span><br><span class="line">    <span class="type">bool</span> m_needStop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>其中Take函数取的方法是“钓鱼”的方式。</p>
<blockquote>
<p>如果想通过函数的return直接返回_Ty是不现实的，因为如果栈空的话会产生返回值混淆。</p>
<p>所以在外部先定义一个对象名，通过传入引用去接收对象值（通过赋值拷贝）。</p>
</blockquote>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Ty <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">_Ty <span class="title">GetTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*  if(Empty())return -1; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetPop</span><span class="params">(_Ty &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Empty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    v = data[top];</span><br><span class="line">    top -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="stop"   >
          <a href="#stop" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#stop"></a> Stop</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">	        m_needStop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要唤醒所有阻塞的线程，让他们尽快退出业务操作。</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_all</span>();</span><br><span class="line">        m_notEmpty.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span><span class="comment">/* 此方法需要修改成员锁的属性，不能设置为const方法 */</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">NotFull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> full = m_queue.<span class="built_in">size</span>() &gt;= m_maxSize;</span><br><span class="line">        <span class="keyword">if</span>(full)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;m_queue 满了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !full;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">NotEmpty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> empty = m_queue.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="keyword">if</span>(empty)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;m_queue 空了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h3 id="add"   >
          <a href="#add" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#add"></a> Add</h3>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">Add</span><span class="params">(F&amp;&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_notFull.<span class="built_in">wait</span>(locker,</span><br><span class="line">                      [<span class="keyword">this</span>]()-&gt;<span class="type">bool</span> &#123;<span class="keyword">return</span> m_needStop||<span class="built_in">NotFull</span>();&#125;);</span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(std::forward&lt;F&gt;(x));</span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="线程池"   >
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxTaskCount = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> numThreads = std::thread::hardware_concurrency)</span><br><span class="line">        : <span class="built_in">m_queue</span>(MaxTaskCount) <span class="comment">/* 设置m_queue的最大容纳任务量 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Start</span>(numThreads);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;std::shared_ptr&lt;std::thread&gt; &gt; m_threadgroup;</span><br><span class="line">    SyncQueue&lt;Task&gt; m_queue;</span><br><span class="line">    atomic_bool m_running;	<span class="comment">//初始化为假</span></span><br><span class="line">    std::once_flag m_flag;	<span class="comment">//确保函数执行一次的标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>Start、RunInThread、StopThread</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(m_flag, [<span class="keyword">this</span>]() &#123;<span class="built_in">StopThreadGroup</span>();&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">(<span class="type">int</span> numThreads)</span>	<span class="comment">//创建若干线程，放到线程组</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_running = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注意，RunInThread是类成员函数，需要指明其是哪个类中的，而且要在前面加&amp;</span></span><br><span class="line">            m_threadgroup.<span class="built_in">push_back</span>(</span><br><span class="line">                <span class="built_in">make_shared</span>&lt;thread&gt;(&amp;ThreadPool::RunInThread, <span class="keyword">this</span>)</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RunInThread</span><span class="params">()</span>		<span class="comment">//主线程对应的函数，属于类成员函数，需传入this</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m_running)	<span class="comment">//Start后running为true</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::list&lt;Task&gt; list;</span><br><span class="line">            m_queue.<span class="built_in">Take</span>(list);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; task : list)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!m_running)<span class="keyword">return</span>;</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StopThreadGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_queue.<span class="built_in">Stop</span>();</span><br><span class="line">        m_running = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; th : m_threadgroup)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(th)</span><br><span class="line">            &#123;</span><br><span class="line">                th-&gt;<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m_threadgroup.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>AddTask</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(Task &amp;&amp; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_queue.<span class="built_in">Put</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(<span class="type">const</span> Task &amp; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_queue.<span class="built_in">Put</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="测试"   >
          <a href="#测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">funa</span><span class="params">(ThreadPool &amp;pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> thdid = this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">        pool.<span class="built_in">AddTask</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestThPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    <span class="function">std::thread <span class="title">tha</span><span class="params">(fun, <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestThPool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="下去思考的问题"   >
          <a href="#下去思考的问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#下去思考的问题"></a> 下去思考的问题</h1>
      
<ol>
<li>还有一个概念是协程。是在用户态的模拟并发，因而比线程速度更快，但是协程本质上不是并行、高并发，因为实际上它相对于CPU来说是处于串行的状态。</li>
<li>下去思考线程池如何与对象池连接，对象中可以连接MySQL数据库，如何使用线程池调用对象的查询、更新数据方法。</li>
<li>创建一个线程对象与某个线程挂接后，能不能在中间暂停？暂停时改变线程的属性，然后再继续跑动？</li>
<li>能不能精准地创建一个线程，准确地挂在某个核上？</li>
<li>下去看看谷歌的线程池</li>
<li>下去看看protobuf</li>
</ol>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/103/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/103/">103</a><span class="page-number current">104</span><a class="page-number" href="/page/105/">105</a><span class="space">&hellip;</span><a class="page-number" href="/page/153/">153</a><a class="extend next" rel="next" href="/page/105/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">305</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>