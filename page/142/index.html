<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="罐头先生的博客">
<meta property="og:url" content="https://xing-cg.github.io/page/142/index.html">
<meta property="og:site_name" content="罐头先生的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Can">
<meta name="twitter:card" content="summary"><title>罐头先生的博客</title><link ref="canonical" href="https://xing-cg.github.io/page/142/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罐头先生的博客</div><div class="header-banner-info__subtitle">Mr.Can</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/C/C%E8%AF%AD%E8%A8%80_%E6%96%87%E4%BB%B6%E5%85%A5%E9%97%A8/">C语言_文件入门</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-08-13</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/C/C%E8%AF%AD%E8%A8%80_%E6%96%87%E4%BB%B6%E5%85%A5%E9%97%A8/" data-flag-title="C语言_文件入门"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="本章内容"   >
          <a href="#本章内容" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#本章内容"></a> 本章内容</h1>
      
<ol>
<li>C 语言中的文件是什么？</li>
<li>流的概念及分类</li>
<li>文本文件和二进制文件到底有什么区别</li>
<li>C 语言与文件读写</li>
<li>缓冲和非缓冲文件系统</li>
<li>文件的顺序读写</li>
<li>文件的随机读写</li>
</ol>
<p>重点掌握：第一，FILE，即文件结构体。第二，文件位置指针。</p>

        <h1 id="c-语言中的文件是什么"   >
          <a href="#c-语言中的文件是什么" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c-语言中的文件是什么"></a> C 语言中的文件是什么？</h1>
      
<p>所谓文件（file）一般指存储在外部介质上数据的集合，比如我们经常使用的txt、bmp、jpg、exe、rmvb 等等。这些文件各有各的用途，我们通常将它们存放在磁盘或者可移动盘等介质中。<br />
　　文件无非就是一段数据的集合，这些数据可以是有规则的集合，也可以是无序的集合。操作系统也就是以文件为单位对数据进行管理的。也就是说，要访问外部介质上的数据，必须先按照文件名进行查找，然后从该文件中读取数据。要想写数据到外部介质，必须得建立一个文件，然后再写入。因此，你眼前的文件只是数据的集合。</p>

        <h2 id="三要素文件路径-文件名-后缀"   >
          <a href="#三要素文件路径-文件名-后缀" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#三要素文件路径-文件名-后缀"></a> 三要素：文件路径、文件名、后缀</h2>
      
<p>由于在 C 语言中’\‘一般是转义字符的起始标志，故在路径中需要用两个’\'表示路径中目录层次的间隔，也可以使用 ‘/’ 作为路径中的分隔符。</p>
<p>例如: “D:\\tulun\\test.c&quot;或者&quot;D:/tulun/test.c”，表示文件 test.c 保存在 D 盘tulun 目录下；“tu.txt” 表示当前目录下的文件 tu.txt。</p>

        <h3 id="文件路径"   >
          <a href="#文件路径" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件路径"></a> 文件路径</h3>
      
<ul>
<li><strong>以盘符开头的</strong>，可以显式指出其绝对路径，如上面的”D:\\”或者”D:/”等。</li>
<li>如果没有显式指出其路径，默认为当前路径。也就是相对路径。</li>
</ul>
<p>**数据的输入和输出几乎伴随着每个 C 语言程序，所谓输入就是从“源端”获取数据，所谓输出可以理解为向“终端”写入数据。**这里的源端可以是键盘、鼠标、硬盘、光盘、扫描仪等输入设备，终端可以是显示器、硬盘、打印机等输出设备。在 C 语言中，把这些输入和输出设备也看作“文件”。<strong>要注意，我们所站的角度是执行程序的角度，以执行程序为主讨论输入输出</strong>。</p>

        <h2 id="c-语言文件系统中的类型"   >
          <a href="#c-语言文件系统中的类型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c-语言文件系统中的类型"></a> C 语言文件系统中的类型</h2>
      
<ul>
<li>FILE：对象类型，足以保有控制 C I/O 流所需的全部信息</li>
<li>fpos_t：非数组完整对象类型，足以唯一指定文件的位置和多字节剖析状态</li>
</ul>
<p>每个 FILE 对象直接或间接保有下列信息：</p>
<ol>
<li>(C95)字符宽度：未设置、窄或宽。</li>
<li>(C95)多字节与宽字符间转换的分析状态（ mbstate_t 类型对象）</li>
<li>缓冲状态：无缓冲、行缓冲、全缓冲。</li>
<li>缓冲区，可为外部的用户提供缓冲区所替换。</li>
<li>I/O 模式：输入、输出或更新（兼具输入与输出）。</li>
<li>二进制/文本模式指示器。</li>
<li>文件尾指示器。</li>
<li>错误状态指示器。</li>
<li>文件位置指示器，可作为 fpos_t 类型对象访问，对于宽流包含剖析状态。</li>
<li>(C11)在多个线程读、写、寻位或查询流时避免数据竞争的再入锁。</li>
</ol>

        <h2 id="预定义标准流"   >
          <a href="#预定义标准流" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#预定义标准流"></a> 预定义标准流</h2>
      
<ol>
<li>stdin 与标准输入流关联的 FILE* 类型表达式</li>
<li>stdout 与标准输出流关联的 FILE* 类型表达式（有缓冲区）</li>
<li>stderr 与标准错误输出流关联的 FILE* 类型表达式（实际上和stdout一样，只不过无缓冲区）</li>
</ol>

        <h2 id="宏常量"   >
          <a href="#宏常量" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#宏常量"></a> 宏常量</h2>
      
<div class="table-container"><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>EOF</td>
<td>int 类型的负值整数常量表达式</td>
<td>#define EOF (-1)</td>
</tr>
<tr>
<td>FOPEN_MAX</td>
<td>能同时打开的文件数</td>
<td>#define FOPEN_MAX 20</td>
</tr>
<tr>
<td>FILENAME_MAX</td>
<td>保有最长受支持文件名所需的 char 数组大小</td>
<td>define FILENAME_MAX 260</td>
</tr>
<tr>
<td>BUFSIZ</td>
<td>setbuf() 所用的缓冲区大小</td>
<td>#define BUFSIZ 512</td>
</tr>
<tr>
<td>_IOFBF</td>
<td>指示全缓冲 I/O 的 setvbuf() 参数</td>
<td>#define _IOFBF 0x0000</td>
</tr>
<tr>
<td>_IOLBF</td>
<td>指示行缓冲 I/O 的 setvbuf() 参数</td>
<td>#define _IOLBF 0x0040</td>
</tr>
<tr>
<td>_IONBF</td>
<td>指示无缓冲 I/O 的 setvbuf() 参数</td>
<td>#define _IONBF 0x0004</td>
</tr>
<tr>
<td>SEEK_SET</td>
<td>指示从文件首开始寻位的 fseek() 参数</td>
<td>#define SEEK_SET 0</td>
</tr>
<tr>
<td>SEEK_CUR</td>
<td>指示从文件当前位置开始寻位的 fseek() 参数</td>
<td>#define SEEK_CUR 1</td>
</tr>
<tr>
<td>SEEK_END</td>
<td>指示从文件尾开始寻位的 fseek() 参数</td>
<td>#define SEEK_END 2</td>
</tr>
<tr>
<td>TMP_MAX</td>
<td>tmpnam 所能生成的最大独有文件数</td>
<td>#define TMP_MAX 32767</td>
</tr>
<tr>
<td>TMP_MAX_S</td>
<td>tmpnam_s 所能生成的最大独有文件数</td>
<td></td>
</tr>
<tr>
<td>L_tmpnam</td>
<td>保有 tmpnam 结果所需的 char 数组大小</td>
<td></td>
</tr>
<tr>
<td>L_tmpnam_s</td>
<td>保有 tmpnam_s 结果所需的 char 数组大小</td>
<td></td>
</tr>
</tbody>
</table></div>

        <h1 id="流的概念及分类"   >
          <a href="#流的概念及分类" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#流的概念及分类"></a> 流的概念及分类</h1>
      
<p>I/O 设备的多样性及复杂性，给程序设计者访问这些设备带来了很大的难度和不便。为此，ANSIC 的 I/O 系统即标准 I/O 系统（即“流”），把任意输入的源端或任意输出的终端，都抽象转换成了概念上的“标准 I/O 设备”或称“标准逻辑设备”。</p>
<p>流是一种抽象的概念，负责在数据的产生者和数据的使用者之间建立联系，并管理数据的流动。</p>
<p>**为什么如此设计：因为程序写出到的外部设备的种类很多，只需要一个统一的接口，使程序绕过具体设备，直接与该“标准逻辑设备”进行交互。**这样就为程序设计者提供了一个不依赖于任何具体 I/O 设备的统一的操作接口，通常把抽象出来的“标准逻辑设备”或“标准文件”称作“流”。<strong>思想：适配器设计方案。</strong><br />
　　把任意 I/O 设备，转换成逻辑意义上的标准 I/O 设备或标准文件的过程，并不需要程序设计者感知和处理，是由标准 I/O 系统自动转换完成的。故从这个意义上，可以认为任意输入的源端和任意输出的终端均对应一个“流”。</p>
<ul>
<li>流按<strong>方向</strong>分为：输入流和输出流。从文件获取数据的流称为输入流，向文件输出数据称为输出流。</li>
<li>流按<strong>数据形式</strong>分为：文本流和二进制流。文本流是 ASCII 码字符（0 000 0000~0  111 1111即0~127）序列，而二进制流是字节序列。从某种意义上来说，文本流是一种特殊的二进制流。</li>
</ul>
<p>图示：</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819010628605.png" alt="image-20210819010628605" /></p>

        <h1 id="文本文件和二进制文件到底有什么区别"   >
          <a href="#文本文件和二进制文件到底有什么区别" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文本文件和二进制文件到底有什么区别"></a> 文本文件和二进制文件到底有什么区别</h1>
      
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/19971994/answer/17256634" >https://www.zhihu.com/question/19971994/answer/17256634</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/24662572/answer/28541822" >https://www.zhihu.com/question/24662572/answer/28541822</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/51828216" >https://zhuanlan.zhihu.com/p/51828216</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>根据文件中数据的组织形式的不同，可以把文件分为：文本文件和二进制文件。</p>
<ul>
<li>文本文件：把要存储的数据当成一系列字符组成，把每个字符的 ASCII 码值存入文件中。每个 ASCII 码值占一个字节，每个字节表示一个字符。故文本文件也称作字符文件或 ASCII 文件，是字符序列文件。</li>
<li>二进制文件：把数据对应的二进制形式存储到文件中，是字节序列文件。</li>
</ul>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819010658360.png" alt="image-20210819010658360" /></p>

        <h2 id="关于字符集的个人总结"   >
          <a href="#关于字符集的个人总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关于字符集的个人总结"></a> 关于字符集的个人总结</h2>
      
<p>理论上，文本文件可以看作特殊的二进制文件。</p>
<p>你比如说，图片和视频都是二进制文件，他们的区别就在于编码与解码的格式不同，比如某种图片以jpg格式打开，某种视频以mp4格式打开。</p>
<p>而文本文件同样可以类比，文本文件实际上就是二进制文件，只不过有好几种文本文件，有不同的编码和解码方式。比如汉字“我”在ASCII码中没有规定，而在GBK字符集的编码为：(CE D2)16，Unicode字符集的UTF-8方式编码为：(62 11)16。所以，不同格式的文本文件用不同的解码方式转换出来的文本就不一样。很容易就导致乱码现象的产生。而Unicode字符集规范了世界上所有地区的语言。</p>
<p>UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII/309296" >ASCII</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。</p>

        <h1 id="c-语言与文件读写文件库函数stdioh"   >
          <a href="#c-语言与文件读写文件库函数stdioh" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#c-语言与文件读写文件库函数stdioh"></a> C 语言与文件读写，文件库函数stdio.h</h1>
      
<p>链接： <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/cstdio/" >http://www.cplusplus.com/reference/cstdio/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>C 语言操作文件分为三步</p>
<ol>
<li>打开文件</li>
<li>读写文件</li>
<li>关闭文件</li>
</ol>

        <h2 id="打开文件fopen"   >
          <a href="#打开文件fopen" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#打开文件fopen"></a> 打开文件fopen</h2>
      
<p>FILE * fopen ( const char * filename, const char * mode );</p>

        <h3 id="函数参数"   >
          <a href="#函数参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>文件名，包括路径，如果不显式含有路径，则表示当前路径。例如，“D:\text.txt”表示 D 盘根目录下的文件 text.txt 文件。“tulun.txt”表示当前目录下的文件 tulun.txt</td>
</tr>
<tr>
<td>mode</td>
<td>文件打开模式，指出对该文件可进行的操作。常见的打开模式如 “r” 表示只读，“w” 表示只写，“rw” 表示读写，“a” 表示追加写入。<strong>注意，&quot; &quot;代表一个字符串，不是字符。</strong></td>
</tr>
</tbody>
</table></div>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819010757148.png" alt="image-20210819010757148" /></p>
<p>虽然fopen以写方式打开文件时，若文件不存在可以创建新文件后写入，但只是针对存在的目录而言的，如果前面的目录位置不存在，是不会给你创建文件夹的。比如fopen(“D:/yhp.txt”,“w”);是可以的。而fopen(“D:/yhp/yhp.txt”,“w”);在D:/yhp目录不存在时将无法创建yhp.txt，并且返回空指针。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824212604457.png" alt="image-20210824212604457" /></p>

        <h3 id="返回值"   >
          <a href="#返回值" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>状态</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开成功</td>
<td>返回该文件对应的 FILE 类型的指针</td>
</tr>
<tr>
<td>打开失败</td>
<td>返回 NULL</td>
</tr>
</tbody>
</table></div>
<p>根据返回值表，需定义 FILE 类型的指针变量，保存该函数的返回值。可根据该函数的返回值判断文件打开是否成功。</p>

        <h3 id="写入文件-代码案例"   >
          <a href="#写入文件-代码案例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#写入文件-代码案例"></a> 写入文件-代码案例</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一部分代码-打开文件</span></span><br><span class="line">    FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;yhping&quot;</span>,<span class="string">&quot;w&quot;</span>); <span class="comment">//与malloc类似，要从系统里申请文件资源。如果没有申请到，则返回空。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二部分代码-定义数据</span></span><br><span class="line">    <span class="type">int</span> ar[<span class="number">10</span>]=&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(ar)/<span class="keyword">sizeof</span>(ar[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三部分代码-写数据到文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;,ar[i]);		//默认写到stdout，等效于fprintf(stdout, &quot;%d &quot;, ar[i]);</span></span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d &quot;</span>, ar[i]);	<span class="comment">//写到fp中，但是只是写到了缓冲区，还没写到磁盘中。内部还要调用itoa函数，把整型转换为字符串（ASCII码串）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第四部分代码-善后处理</span></span><br><span class="line">    fclose(fp);<span class="comment">//不仅把文件流对象资源归还系统，还把缓冲区的数据输出到文件中。之后，fp指针就失效了，记得free</span></span><br><span class="line">    <span class="built_in">free</span>(fp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>注意观察FILE结构体的cnt信息，写了第一个数加一个空格后，cnt由4096减去了3。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824203452627.png" alt="image-20210824203452627" /></p>
<p>两种缓冲区：</p>
<ol>
<li>全缓冲区——缓冲区满后写到磁盘。</li>
<li>行缓冲区——遇到\n写到磁盘。</li>
<li>无缓冲区——不经过缓冲区，直接把文件流写入到磁盘中。</li>
</ol>

        <h3 id="读出文件-代码案例"   >
          <a href="#读出文件-代码案例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#读出文件-代码案例"></a> 读出文件-代码案例</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;yhp.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">int</span> ar[<span class="number">10</span>]=&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;ar[i]);<span class="comment">//内部调用atoi(),把字符串转换为整型数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>注意观察FILE结构体cnt的信息，原本&quot;12 23 34 45 56 67 78 89 90 100 &quot;十个数据加上十个空格，不包括’\0’的长度为9*2+3+10=31。当我们读出了1个数据后，（没读空格），31减去了2变为了29。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824213744839.png" alt="image-20210824213744839" /></p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824214430960.png" alt="image-20210824214430960" /></p>

        <h4 id="回忆知识"   >
          <a href="#回忆知识" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#回忆知识"></a> 回忆知识</h4>
      
<p>三种scanf：</p>
<ol>
<li>scanf是从标准输入设备读出</li>
<li>sscanf是从输入缓冲区（buff字符串）中读出</li>
<li>fscanf是从指定文件中读出</li>
</ol>

        <h2 id="关闭函数fclose"   >
          <a href="#关闭函数fclose" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关闭函数fclose"></a> 关闭函数fclose</h2>
      
<p>int fclose (FILE * stream);</p>

        <h3 id="函数参数-2"   >
          <a href="#函数参数-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数参数-2"></a> 函数参数</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>strem</td>
<td>指向要关闭流对象的指针</td>
</tr>
</tbody>
</table></div>

        <h3 id="返回值-2"   >
          <a href="#返回值-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-2"></a> 返回值</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>状态</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>流被成功关闭</td>
<td>返回0 值</td>
</tr>
<tr>
<td>失败</td>
<td>返回EOF(-1)</td>
</tr>
</tbody>
</table></div>
<p>即使调用失败，作为参数传递的流将不再与文件或其缓冲区关联。</p>

        <h2 id="字符串格式化函数sprintf"   >
          <a href="#字符串格式化函数sprintf" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#字符串格式化函数sprintf"></a> 字符串格式化函数sprintf</h2>
      
<p>int sprintf (char * str, const char * format, … );</p>

        <h3 id="函数参数-3"   >
          <a href="#函数参数-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数参数-3"></a> 函数参数</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>str</td>
<td>指向缓冲区指针，缓冲区足够大</td>
</tr>
<tr>
<td>format</td>
<td>格式化字符串，该字符串遵循与printf 中的格式相同的规范</td>
</tr>
<tr>
<td>…</td>
<td>附加可变参数。 根据格式化字符串的不同，函数可能需要一系列附加参数，每个参数都包含一个值，用于替换格式字符串中的格式说明符。</td>
</tr>
</tbody>
</table></div>

        <h3 id="返回值-3"   >
          <a href="#返回值-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-3"></a> 返回值</h3>
      
<p>如果成功，将返回写入的字符总数。此计数不包括自动附加在字符串末尾的额外空字符。失败返回负数。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819010851930.png" alt="image-20210819010851930" /></p>
<p>注意： Windows OS 上的 C 流在输出时将 ‘\n’ 转换为 ‘\r\n’ ，输入时将 ‘\r\n’ 转换为 ‘\n’ 。</p>

        <h2 id="格式化写入函数"   >
          <a href="#格式化写入函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#格式化写入函数"></a> 格式化写入函数</h2>
      
<p>int fprintf ( FILE * stream, const char * format, … )；</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819010921972.png" alt="image-20210819010921972" /></p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819010941058.png" alt="image-20210819010941058" /></p>

        <h2 id="从流中读取格式化数据函数"   >
          <a href="#从流中读取格式化数据函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#从流中读取格式化数据函数"></a> 从流中读取格式化数据函数</h2>
      
<p>int fscanf ( FILE * stream, const char * format, … );</p>

        <h3 id="函数参数-4"   >
          <a href="#函数参数-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数参数-4"></a> 函数参数</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>参数名</th>
<th>参数描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>stream</td>
<td>指向文件对象的指针，该对象标识要从中读取数据的输入流。</td>
</tr>
<tr>
<td>format</td>
<td>格式化字符串，该字符串遵循与scanf 中的格式相同的规范。</td>
</tr>
</tbody>
</table></div>

        <h3 id="返回值-4"   >
          <a href="#返回值-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-4"></a> 返回值</h3>
      
<div class="table-container"><table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>receiving arguments successfully assigned. 传入的参数输入成功，匹配成功。</td>
<td>Number of receiving arguments successfully assigned. 成功赋值的接收参数的数量</td>
</tr>
<tr>
<td>in case a matching failure occurred before the first receiving argument was assigned. 输入成功，但传入的参数第一次就匹配失败了</td>
<td>0</td>
</tr>
<tr>
<td>if input failure occurs before the first receiving argument was assigned</td>
<td>EOF（-1）</td>
</tr>
<tr>
<td><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819011017608.png" alt="image-20210819011017608" /></td>
<td></td>
</tr>
</tbody>
</table></div>

        <h2 id="二进制文件的读写"   >
          <a href="#二进制文件的读写" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二进制文件的读写"></a> 二进制文件的读写</h2>
      

        <h3 id="字节块数据写入函数"   >
          <a href="#字节块数据写入函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#字节块数据写入函数"></a> （字节）块数据写入函数</h3>
      
<p><code>size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );</code></p>
<p>将内存中数组的内容写到文件中。功能类似于<code>fprintf</code></p>

        <h4 id="函数参数-5"   >
          <a href="#函数参数-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数参数-5"></a> 函数参数</h4>
      
<div class="table-container"><table>
<thead>
<tr>
<th>参数名</th>
<th>参数描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>指向将要<strong>被写出</strong>到文件里的元素数组的指针</td>
</tr>
<tr>
<td>size</td>
<td>这是要<strong>被写出到文件里</strong>的每个元素的大小，以字节为单位。</td>
</tr>
<tr>
<td>count</td>
<td>这是<strong>要写的</strong>总共的元素个数，每个元素的大小为 size 字节。</td>
</tr>
<tr>
<td>stream</td>
<td>这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流（相对内存而言，输出到文件的流）。</td>
</tr>
</tbody>
</table></div>

        <h4 id="返回值-5"   >
          <a href="#返回值-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-5"></a> 返回值</h4>
      
<p>返回成功地被写出的元素的个数，如果出现错误，可能比count小。<br />
如果传入的参数size 或count 为零，fwrite返回0且不做任何动作。</p>

        <h3 id="块数据读出函数"   >
          <a href="#块数据读出函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#块数据读出函数"></a> 块数据读出函数</h3>
      
<p><code>size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );</code></p>

        <h4 id="函数参数-6"   >
          <a href="#函数参数-6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数参数-6"></a> 函数参数</h4>
      
<div class="table-container"><table>
<thead>
<tr>
<th>参数名</th>
<th>参数描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>指向大小至少为（size*count）字节的内存块的指针，从流中读出的数据存储到buffer指向的内存。</td>
</tr>
<tr>
<td>size</td>
<td>读取元素的大小，unsigned int。</td>
</tr>
<tr>
<td>count</td>
<td>被读取元素的个数</td>
</tr>
<tr>
<td>stream</td>
<td>是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流（相对内存而言的，从外部的文件输入到内存中）。</td>
</tr>
</tbody>
</table></div>

        <h4 id="返回值-6"   >
          <a href="#返回值-6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-6"></a> 返回值</h4>
      
<p>返回成功被读取的元素个数count，若出现错误或到达文件末尾，则可能小于count。<br />
如果传入的参数size 或count 为零，fread返回0且不做任何动作。<br />
fread 不区分文件尾和错误，因此调用者必须用feof 和ferror 才能判断发生了什么。</p>

        <h3 id="二进制方式-代码案例"   >
          <a href="#二进制方式-代码案例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二进制方式-代码案例"></a> 二进制方式-代码案例</h3>
      
<p>注意，不仅要打开时按照wb打开，还要把读写函数改为fwrite和fread</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ar[<span class="number">10</span>]=&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(ar)/<span class="keyword">sizeof</span>(ar[<span class="number">0</span>]);</span><br><span class="line">    FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">    fp = fopen(<span class="string">&quot;yhpBin.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>); <span class="comment">//与malloc类似，要从系统里申请文件资源。如果没有申请到，则返回空。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fwrite(ar,<span class="keyword">sizeof</span>(<span class="type">int</span>),n,fp);	<span class="comment">//专门写入二进制文件</span></span><br><span class="line">    </span><br><span class="line">    fclose(fp);<span class="comment">//不仅把文件流对象资源归还系统，还把缓冲区的数据输出到文件中。之后，fp指针就失效了，记得free</span></span><br><span class="line">    <span class="built_in">free</span>(fp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过记事本打开文件，发现显示的是：□ □ - 8 C N Y Z d 。通过观察，发现正好对应于各自的ASCII码值&quot;\12 \23 \34 \45 \56 \67 \78 \89 \90 \100 &quot;</span></span><br></pre></td></tr></table></div></figure>
<p>因为我们是用记事本打开的（系统自动解析为UTF-8编码），<strong>系统对这些数据的处理是按照ASCII码处理的</strong>。所以出现了以下的情况！</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824221223042.png" alt="image-20210824221223042" /></p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824221905601.png" alt="image-20210824221905601" /></p>
<p>每个int型数据占据了4字节。我们输入的数据都没有用到第二个字节，则正好限制在了0~127这个ASCII码区间内，12和23表示控制符，显示不出来，故显示为□。剩下的00通过文本格式解码变成了空格。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824221601975.png" alt="image-20210824221601975" /></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ar[<span class="number">10</span>]=&#123;&#125;;</span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;yhpBin.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==fp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fread(ar,<span class="keyword">sizeof</span>(<span class="type">int</span>),n,fp);<span class="comment">//从fp读出数据到ar数组中</span></span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
      
<p>二进制读写（fwrite和fread）是按着把数据“本该在内存中的样子”原封不动地存入到文件中。</p>

        <h1 id="缓冲和非缓冲文件系统"   >
          <a href="#缓冲和非缓冲文件系统" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#缓冲和非缓冲文件系统"></a> 缓冲和非缓冲文件系统</h1>
      
<p>在ANSI C 标准中，使用的是“缓冲文件系统”。</p>
<p>所谓缓冲文件系统指系统自动地在内存为每一个正在使用的文件名开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存中的缓冲区，装满后再一起送到磁盘去。反向也是如此。</p>

        <h2 id="vs2012中的file-结构体"   >
          <a href="#vs2012中的file-结构体" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#vs2012中的file-结构体"></a> vs2012中的FILE 结构体</h2>
      
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819011136329.png" alt="image-20210819011136329" /></p>

        <h2 id="写数据"   >
          <a href="#写数据" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#写数据"></a> 写数据</h2>
      
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819011222800.png" alt="image-20210819011222800" /></p>

        <h2 id="读数据"   >
          <a href="#读数据" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#读数据"></a> 读数据</h2>
      
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210819011232955.png" alt="image-20210819011232955" /></p>

        <h2 id="fflush"   >
          <a href="#fflush" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#fflush"></a> fflush</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span><span class="params">( FILE *stream)</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="功能"   >
          <a href="#功能" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3>
      
<p>清除读写缓冲区，在需要立即把输出缓冲区的数据进行物理写入时。</p>

        <h3 id="函数说明"   >
          <a href="#函数说明" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h3>
      
<p>如果指针指向一个输出流或者是一个最近的一次操作不是输入的更新流，输出刷新将会创造任意未写入的数据给将要被写入文件的流和最近的数据被修改流，并且最后的文件状态改变应该被标记为更新的基础文件的时间戳。<br />
对于打开以使用基础文件描述进行读取的流，如果文件尚未处于EOF，并且该文件是能够搜索的文件，则基础打开文件描述的文件偏移量应设置为流的文件位置，并且任何未被从流中读取的<code>ungetc（）</code>或<code>ungetwc（）</code>推回到流上的字符都将被丢弃（不再进一步改变文件偏移量）。<br />
如果stream 是空指针，则fflush()将对上面定义了行为的所有流执行此刷新操作。</p>

        <h3 id="返回值-7"   >
          <a href="#返回值-7" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-7"></a> 返回值</h3>
      
<p>如果成功刷新，fflush 返回0。指定的流没有缓冲区或者只读打开时也返回0 值。返回EOF 指出一个错误。</p>

        <h3 id="注意"   >
          <a href="#注意" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
      
<p>如果fflush 返回EOF,数据可能由于写错误已经丢失。当设置一个重要错误处理器时,最安全的是用setvbuf函数关闭缓冲或者使用低级IO例程,如open、close 和write 来代替流I/O 函数。</p>

        <h3 id="其他用法"   >
          <a href="#其他用法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#其他用法"></a> 其他用法</h3>
      
<p><code>fflush(stdin)</code>刷新标准输入缓冲区，把输入缓冲区里的东西丢弃[非标准]<br />
<code>fflush(stdout)</code>刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上</p>

        <h3 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
      
<p>C 和<code>C++</code>的标准里从来没有定义过<code>fflush(stdin)</code>。也许有人会说：“可是我用<code>flush(stdin)</code>解决了这个问题，你怎么能说是错的呢？”的确，某些编译器（如VC6）支持用 <code>fflush(stdin)</code>来清空输入缓冲，但是并非所有编译器都支持这个功能（linux 下的gcc 就不支持），因为标准中根本没有定义<code>fflush(stdin)</code>。MSDN 文档里也清楚地写着：fflush on input stream is an extension to the C standard （fflush 操作输入流是对C 标准的扩充）。<br />
以下是 C99 对 fflush 函数的定义：<br />
<code>int fflush(FILE *stream);</code><br />
如果stream 指向输出流或者更新流（update stream），并且这个更新流最近执行的操作不是输入，那么fflush函数将把任何未被写入的数据写入stream 指向的文件（如标准输出文件stdout）。否则，fflush 函数的行为是不确定的。<code>fflush（NULL）</code>清空所有输出流和上面提到的更新流。如果发生写错误，flush 函数会给那些流打上错误标记，并且返回EOF，否则返回0。<br />
由此可知，如果 stream 指向输入流（如 stdin），那么 fflush 函数的行为是不确定的。故而使用<code>fflush(stdin)</code>是不正确的。</p>

        <h2 id="setbuf"   >
          <a href="#setbuf" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#setbuf"></a> setbuf</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbuf</span><span class="params">( FILE *stream, <span class="type">char</span> *buffer )</span></span>;</span><br></pre></td></tr></table></div></figure>

        <h3 id="功能-2"   >
          <a href="#功能-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#功能-2"></a> 功能</h3>
      
<p>设置用于流操作的内部缓冲区。其长度至少应该为 BUFSIZ 个字符。<br />
若 buffer 非空，则等价于<code>setvbuf(stream, buffer, _IOFBF, BUFSIZ)</code><br />
若 buffer 为空，则等价于<code>setvbuf(stream, NULL, _IONBF, 0)</code>，这会关闭缓冲。</p>

        <h3 id="参数"   >
          <a href="#参数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数"></a> 参数</h3>
      
<p>stream :要设置缓冲区的文件流<br />
buffer:指向文件流所用的缓冲区的指针。若提供空指针，则关闭缓冲。</p>

        <h3 id="返回值-8"   >
          <a href="#返回值-8" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-8"></a> 返回值</h3>
      
<p>无</p>

        <h3 id="注解"   >
          <a href="#注解" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注解"></a> 注解</h3>
      
<p>若 BUFSIZ 不是适合的缓冲区大小，则能用 setvbuf 更改它。<br />
setvbuf 亦应当用于检测错误，因为 setbuf 不指示成功或失败。<br />
此函数仅可在已将 stream 关联到打开的文件后，但要在任何其他操作（除了对 setbuf/setvbuf 的失败调用）前使用。</p>
<p>一个常见错误是设置 stdin 或 stdout 的缓冲区为生存期在程序终止前结束的数组：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">&#125; <span class="comment">// buf 的生存期结束，未定义行为</span></span><br></pre></td></tr></table></div></figure>
<p>示例</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	FILE *pf = fopen(<span class="string">&quot;yhp.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	setbuf(pf,buff);</span><br><span class="line">	<span class="built_in">fprintf</span>(pf,<span class="string">&quot;a = %d b = %d \n&quot;</span>,a,b);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="setvbuf"   >
          <a href="#setvbuf" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#setvbuf"></a> setvbuf</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setvbuf</span><span class="params">( FILE * stream, <span class="type">char</span> * buffer, <span class="type">int</span> mode, <span class="type">size_t</span> size )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>以 mode 所指示值更改给定文件流 stream 的缓冲模式。另外，<br />
▪ 若 buffer 为空指针，则重设内部缓冲区大小为 size 。<br />
▪ 若 buffer 不是空指针，则指示流使用始于 buffer 而大小为 size 的用户提供缓冲区。必须在 buffer 所指向的数组的生存期结束前（用 fclose ）关闭流。成功调用 setvbuf 后，数组内容不确定，而任何使用它的尝试是未定义行为。</p>

        <h3 id="参数-2"   >
          <a href="#参数-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-2"></a> 参数</h3>
      
<p>stream：要设置缓冲的文件流<br />
buffer：指向要使用的流缓冲区的指针，或若仅更改大小和模式则为空指针<br />
mode：使用的缓冲模式。它能是下列值之一：</p>
<ol>
<li>_IOFBF: 全缓冲，当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数据。</li>
<li>_IOLBF: 行缓冲，每次从流中读入一行数据或向流中写入一行数据。</li>
<li>_IONBF: 无缓冲，直接从流中读入数据或直接向流中写入数据，缓冲设置无效。</li>
</ol>
<p>size：缓冲区的大小</p>

        <h3 id="返回值-9"   >
          <a href="#返回值-9" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-9"></a> 返回值</h3>
      
<p>成功时为0，失败时为非零。</p>

        <h3 id="注意-2"   >
          <a href="#注意-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h3>
      
<p>此函数仅可在已将 stream 关联到打开的文件后，但要在任何其他操作（除了对 setbuf/setvbuf 的失败调用）前使用。不是所有 size 字节都需要用于缓冲：实际缓冲区大小通常向下取整到 2 的倍数、页面大小的倍数等。<br />
多数实现上，行缓冲仅对终端输入流可用。<br />
一个常见错误是设置 stdin 或 stdout 的缓冲区为生存期在程序终止前结束的数组：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">&#125; <span class="comment">// buf 的生存期结束，未定义行为</span></span><br></pre></td></tr></table></div></figure>
<p>期待默认缓冲区大小 BUFSIZ 为实现上文件 I/O 的最高效缓冲区大小，但 POSIX fstat 经常提供更好的估计。</p>

        <h1 id="文件位置"   >
          <a href="#文件位置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件位置"></a> 文件位置</h1>
      
<div class="table-container"><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ftell</td>
<td>返回当前的文件位置指示值</td>
</tr>
<tr>
<td>fgetpos</td>
<td>获取文件位置指示器</td>
</tr>
<tr>
<td>fseek</td>
<td>将文件位置指示符移动到文件中的指定位置</td>
</tr>
<tr>
<td>fsetpos</td>
<td>将文件位置指示器移动到文件中的指定位置</td>
</tr>
<tr>
<td>rewind</td>
<td>将文件位置指示器移动到文件首</td>
</tr>
</tbody>
</table></div>

        <h2 id="当前的文件位置"   >
          <a href="#当前的文件位置" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#当前的文件位置"></a> 当前的文件位置</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>注：long占四个字节，范围为<code>-2^31~2^31-1</code>。实际上和int一样。因为int当年有时是占两个字节，所以出现了long。而后来int也变为4了，long没变。</p>
<p>返回stream的<strong>文件位置指示值</strong>。<br />
若流以二进制模式打开，则由此函数获得的值是从文件开始的字节数。<br />
若流以文本模式打开，则由此函数返回的值未指定，且仅作为 <code>fseek()</code> 的输入才有意义。</p>

        <h3 id="参数-3"   >
          <a href="#参数-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-3"></a> 参数</h3>
      
<p>stream：要检验的文件流</p>

        <h3 id="返回值-10"   >
          <a href="#返回值-10" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-10"></a> 返回值</h3>
      
<p>成功时为文件位置指示器，若失败发生则为 <code>-1L</code> 。失败时，设 errno 对象为实现定义的正值。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ar[]=&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(ar)/<span class="keyword">sizeof</span>(ar[<span class="number">0</span>]);</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//pfa = fopen(&quot;yhp.txt&quot;,&quot;w&quot;);//VS2019中不能运行</span></span><br><span class="line">    <span class="type">erron_t</span> tag = fopen_s(&amp;pf,<span class="string">&quot;yhp.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//此时pfa指针就指向了系统产生的一个文件流对象。那么对文件流对象的操作就可以间接操作磁盘中的数据。文件流对象内部包含缓冲区。//&quot;a&quot;代表追加写入，并且找不到文件时主动创建。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pfa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file error: %d\n&quot;</span>,tag);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = ftell(pf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pos);</span><br><span class="line">        <span class="built_in">fprintf</span>(pf,<span class="string">&quot;%5d&quot;</span>,ar[i]);</span><br><span class="line">        <span class="comment">//pos从0开始，每次调用一次fprintf后pos都会加5</span></span><br><span class="line">        <span class="comment">//即屏幕输出0 5 10 15 20 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pfa = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="fgetpos"   >
          <a href="#fgetpos" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#fgetpos"></a> fgetpos</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetpos</span><span class="params">(FILE * stream, <span class="type">fpos_t</span> * pos )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>注：<code>fpos_t</code>是<code>__int</code>类型，即64位整型。在32位机中，用这种表示64位整型数据，而在C99后新增了long long类型，实际上和<code>__int</code>一样。只是不同编译器环境下效果不同。<br />
关于C语言中long long与<code>__int64</code>的区别：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/2975.html" >http://c.biancheng.net/cpp/html/2975.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>获得文件流 stream 的文件位置指示器和当前分析状态（若存在），并将它们存储于 pos 所指向的对象。存储的值仅在作为 fsetpos 的输入的情况有意义。</p>

        <h3 id="参数-4"   >
          <a href="#参数-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-4"></a> 参数</h3>
      
<p>stream 要检验的文件流<br />
pos 指向要存储文件位置指示器到的 fpos_t 对象的指针</p>

        <h3 id="返回值-11"   >
          <a href="#返回值-11" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-11"></a> 返回值</h3>
      
<p>成功时为0，否则非零值。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ar[]=&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(ar)/<span class="keyword">sizeof</span>(ar[<span class="number">0</span>]);</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//pfa = fopen(&quot;yhp.txt&quot;,&quot;w&quot;);//VS2019中不能运行</span></span><br><span class="line">    <span class="type">erron_t</span> tag = fopen_s(&amp;pf,<span class="string">&quot;yhp.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);<span class="comment">//此时pfa指针就指向了系统产生的一个文件流对象。那么对文件流对象的操作就可以间接操作磁盘中的数据。文件流对象内部包含缓冲区。//&quot;a&quot;代表追加写入，并且找不到文件时主动创建。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file error: %d\n&quot;</span>,tag);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">fpos_t</span> pos; <span class="comment">//64位整型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = ftell(pf);</span><br><span class="line">        fgetpos(pf,&amp;pos)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,pos);</span><br><span class="line">        <span class="built_in">fprintf</span>(pf,<span class="string">&quot;%d &quot;</span>,ar[i]);</span><br><span class="line">        <span class="comment">//pos从0开始，每次pos都会加若干值</span></span><br><span class="line">        <span class="comment">//即屏幕输出0 5 10 15 20 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pfa = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="文件位置指针移动fseek"   >
          <a href="#文件位置指针移动fseek" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件位置指针移动fseek"></a> ⭐文件位置指针移动fseek</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> origin)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>设置文件流 stream 的文件位置指示器为 offset 所指向的值。</p>
<ol>
<li>若 stream 以二进制模式打开，则新位置准确地是文件起始后（若 origin 为 <code>SEEK_SET</code> ）或当前文件位置后（若 origin 为 <code>SEEK_CUR</code> ），或文件结尾后（若 origin 为 <code>SEEK_END</code> ）的 offset 字节。不要求二进制流支持 <code>SEEK_END</code> ，尤其是是否输出附加的空字节。</li>
<li>若 stream 以文本模式打开，则仅有的受支持 offset 值为零（可用于任何 origin ）和先前在关联到同一个文件的流上对 ftell 的调用的返回值（仅可用于 SEEK_SET 的 origin ）。</li>
<li>若 stream 为宽面向，则一同应用对文本和二进制流的限制（允许 ftell 的结果与 <code>SEEK_SET</code> 一同使用，并允许零 offset 以 <code>SEEK_SET</code> 和 <code>SEEK_CUR</code> 但非 <code>SEEK_END</code> 为基准）。除了更改文件位置指示器， fseek 还撤销 ungetc 的效果并清除文件尾状态，若可应用。<br />
若发生读或写错误，则设置流的错误指示器（ ferror ）而不影响文件位置。</li>
</ol>

        <h3 id="参数-5"   >
          <a href="#参数-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-5"></a> 参数</h3>
      
<p>stream：要修改的文件流<br />
offset：相对 origin 迁移的字符数<br />
origin：offset 所加上的位置。它能拥有下列值之一： <code>SEEK_SET</code>（从起始位置开始移动）、 <code>SEEK_CUR</code>（当前位置）、 <code>SEEK_END</code>（末尾位置）</p>

        <h3 id="返回值-12"   >
          <a href="#返回值-12" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-12"></a> 返回值</h3>
      
<p>成功时为 0 ，否则为非零。</p>

        <h3 id="举例"   >
          <a href="#举例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
      
<p>比如我们调用了<code>fseek(pf, 2, SEEK_CUR);</code>那么，文件位置指针将会从当前位置（<code>SEEK_CUR</code>）向后偏移2字节。假如调用前文件位置指针指向4位置，那么调用后文件位置指针将指向6。</p>
<p>相应地，<code>SEEK_SET</code>是从0位置开始移动的。<code>SEEK_END</code>是从文件末尾开始移动的。如果我们调用<code>fseek(pf, 0, SEEK_END);</code>，那么我们将使文件位置指针指向文件末尾。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210825205704520.png" alt="image-20210825205704520" /></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf, <span class="string">&quot;Test8_25.cpp&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file open error: %d\n&quot;</span>, tag);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(pf, <span class="number">0</span>, SEEK_END);<span class="comment">//为了可以获取文件的长度，我们要调用fseek实现了文件位置指针指向文件末尾</span></span><br><span class="line">    <span class="comment">//fseek(pfs, 1, SET_END);//文件位置指针指向了文件末尾前一个，不是后一个</span></span><br><span class="line">    <span class="type">int</span> len = ftell(pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    fseek(pf, <span class="number">0</span>, SEEK_SET);<span class="comment">//现在为了要从头输出文件内容，我们需要将文件位置指针指向文件开头。</span></span><br><span class="line">    <span class="comment">//也可以使用rewind(pf);</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fscanf_s(pf,<span class="string">&quot;%c&quot;</span>, &amp;ch,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="棘手的问题"   >
          <a href="#棘手的问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#棘手的问题"></a> 棘手的问题</h3>
      
<p>如果我们执行上述程序。会发现，打印出来的最后一个字符会重复多次打印。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210825213347468.png" alt="image-20210825213347468" /></p>
<p>我们在scanf语句执行一次后进行对变量的监视，发现文件结构体中的成员的信息有所端倪：</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210825214922278.png" alt="image-20210825214922278" /></p>
<p>我们计算求得的len值是760。此处的<code>_cnt</code>表示还未读入的剩余字节数，为731个左右。也就是说，他实际最多可读的有效数据是731左右个字节，但我们却输出了760个字节。这显然会出错的。</p>
<p>那么，<code>_cnt</code>和<code>len</code>为何有差异？</p>
<p>此时就要谈论到二进制打开和文本格式打开的差异了！</p>
<p>我们这里的文件在VS2019中的编辑器编写的，右下角的编辑方式默认为“CRLF”，即我们按下键盘的“enter”键时，相当于在文件中存放了0D 0A两个控制符，即回车+换行。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210825222544799.png" alt="image-20210825222544799" /></p>
<p>分析了实际保存的内容后。再分析：我们上面的程序是r方式打开的，即文本方式打开。文本方式打开，对于fscanf函数来说，“0D 0A”只识别“0A”即换行符，忽略“0D”即回车符。这是文本文件的特殊之处。但！虽然是文本格式打开的，而对于fseek函数和ftell而言一视同仁，都看作是二进制文件，把0D也算了进去。所以，len比<code>_cnt</code>多了29个字节（刚刚好和程序代码的行数一样，所以这不是巧合）。</p>
<p><strong>所以，文本文件是一种特殊的二进制文件，在有些环境下，如果以文本方式打开文件，解码器将会自动处理其中的某些数据，比如把0D0A中的0D去掉！</strong></p>
<p>经过调试，fscanf读取了731个字节之后，fscanf就不会再读入有效数据给ch了，因此ch的值不会改变，将会定格在文件的最后一个字符。操蛋的地方就在于<code>fscanf_s</code>函数也没给我们报错，偷偷地将其结构体中成员<code>_ptr</code>指向了文件的开头，即<code>_base</code>的值。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210825222217114.png" alt="image-20210825222217114" /></p>
<p>分析至此，因为ch的值没有变化，依旧是<code>&#125;</code>，而循环仍在继续，所以打印了文本文件的行数的个数的<code>&#125;</code>！</p>
<p>因此，经过上述分析后，我们解决方案有两个。</p>
<p>一是以“rb”方式打开文本文件。</p>
<p>二是用pf结构体中的实际剩余读入数目值来代替len。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf, <span class="string">&quot;Test8_25.cpp&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file open error: %d\n&quot;</span>, tag);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(pf, <span class="number">0</span>, SEEK_END);<span class="comment">//为了可以获取文件的长度，我们要调用fseek实现了文件位置指针指向文件末尾</span></span><br><span class="line">    <span class="comment">//fseek(pfs, 1, SET_END);//文件位置指针指向了文件末尾前一个，不是后一个</span></span><br><span class="line">    fseek(pf, <span class="number">0</span>, SEEK_SET);<span class="comment">//现在为了要从头输出文件内容，我们需要将文件位置指针指向文件开头。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    fscanf_s(pf,<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="type">int</span> len = pf-&gt;_cnt;	<span class="comment">//改为实际的剩余要读的数目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fscanf_s(pf,<span class="string">&quot;%c&quot;</span>, &amp;ch,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二进制文件的案例"   >
          <a href="#二进制文件的案例" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二进制文件的案例"></a> 二进制文件的案例</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> ar[n] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf,<span class="string">&quot;TestBin.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(ar,<span class="keyword">sizeof</span>(<span class="type">int</span>),n,pf);</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf=nullptr;</span><br><span class="line">    <span class="comment">////////////////</span></span><br><span class="line">    tag = fopen_s(&amp;pf,<span class="string">&quot;TestBin.txt&quot;</span>.<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>=pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;pos);</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        fseek(pf,pos,SEEK_SET);<span class="comment">//偏移pos个字节</span></span><br><span class="line">        fread(&amp;val,<span class="keyword">sizeof</span>(<span class="type">int</span>),<span class="number">1</span>,pf);<span class="comment">//参数意义：读出到哪个变量，一次读多少字节，一次读几个，从哪个文件读</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf=nullptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>故意留坑</strong>：这个程序原本的意思想要达到“文件中存储了数据<code>‘0 1 2 3 4 5 6 7 8 9’</code>，我们输入<code>0</code>，就输出文件中偏移0位置的整型值0；输入1，本应该输出文件中偏移1位置的整型值1”。但是，运行测试发现输入1程序输出的是16777216。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210825225705167.png" alt="image-20210825225705167" /></p>
<p>通过对这个数的观察，转为16进制我们发现他是“0100 0000”。</p>
<p>已经有些端倪了，那就是“<code>fseek(pf,pos,SEEK_SET);//偏移pos个字节</code>”这里出错了。正确的写法应该是<code>fseek(pf,pos*(sizeof(int) )  ),SEEK_SET);//偏移4*pos个字节</code>，因为int型占4字节。</p>
<p>那么我们分析一下，为何只偏移1个字节时会打印16777216?</p>
<p>因为前四个字节存的是“00 00 00 00”，之后是“01 00 00 00”。我们只偏移了一个字节，读取的是“00 00 00 01”！然而！我们还要清醒的是！我们在内存中默认下的状态是小端存放数据，因此01是高位！人类的读数据顺序应该是“01 00 00 00”，因此算下来是16777216！到此，我只有一句感慨，那就是计算机中处处都是坑啊！都是基础知识点的体现！</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210825230416632.png" alt="image-20210825230416632" /></p>
<p>因此，改正以下语句。程序才能达到预期的效果。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(pf,pos*<span class="keyword">sizeof</span>(<span class="type">int</span>),SEEK_SET);<span class="comment">//偏移(pos*int大小)个字节</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
      
<p>文件定位指针函数如fseek、ftell对二进制文件是最合适的。</p>
<p>scanf对文本文件操作更合适。</p>
<p>因此，不要拿scanf去读取fseek、ftell操作过的文件。</p>

        <h2 id="fsetpos"   >
          <a href="#fsetpos" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#fsetpos"></a> fsetpos</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsetpos</span><span class="params">( FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>按照 pos 所指向的值，设置文件流 stream 的文件位置指示器和多字节分析状态（若存在）。<br />
除了建立新的分析状态和位置，调用此函数还会撤销 ungetc 的效果，并若设置了文件尾状态则清除之。<br />
若读或写出现错误，则设置流的错误指示器（ ferror ）。<br />
参数<br />
stream 要修改的文件流<br />
pos 指向 fpos_t 对象的指针，用作文件位置指示器的新值<br />
返回值<br />
成功时为 0 ，否则为非零值。</p>

        <h2 id="rewind"   >
          <a href="#rewind" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rewind"></a> rewind</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewind</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>移动文件位置指示器到给定文件流的起始。函数等价于 fseek(stream, 0, SEEK_SET); ，除了它清除文件尾和错误<br />
指示器。<br />
此函数丢弃任何来自先前对 ungetc 调用的效果。<br />
参数<br />
stream 要修改的文件流<br />
返回值（无）</p>

        <h1 id="错误处理"   >
          <a href="#错误处理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h1>
      
<div class="table-container"><table>
<thead>
<tr>
<th>函数名</th>
<th>函数功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>clearerr</td>
<td>清楚错误</td>
</tr>
<tr>
<td>feof</td>
<td>检查文件结尾</td>
</tr>
<tr>
<td>ferror</td>
<td>检查文件错误</td>
</tr>
<tr>
<td>perror</td>
<td>显示对应当前错误的字符串到stderr</td>
</tr>
</tbody>
</table></div>

        <h2 id="clearerr"   >
          <a href="#clearerr" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#clearerr"></a> clearerr</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearerr</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>重置给定文件流的错误标志和 EOF 指示器。</p>

        <h3 id="参数-6"   >
          <a href="#参数-6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-6"></a> 参数</h3>
      
<p>stream： 要重置错误标志的文件流</p>

        <h3 id="返回值-13"   >
          <a href="#返回值-13" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-13"></a> 返回值</h3>
      
<p>无</p>

        <h2 id="feof"   >
          <a href="#feof" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#feof"></a> ⭐feof</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">( FILE *stream )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>检查是否已抵达给定文件流的结尾。</p>

        <h3 id="参数-7"   >
          <a href="#参数-7" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-7"></a> 参数</h3>
      
<p>stream 要检验的文件流</p>

        <h3 id="返回值-14"   >
          <a href="#返回值-14" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-14"></a> 返回值</h3>
      
<p>若已抵达流尾则为非零值，否则（未抵达）为 0</p>

        <h3 id="注意-3"   >
          <a href="#注意-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-3"></a> 注意</h3>
      
<p>此函数仅报告最近一次 I/O 操作所报告的流状态，而不检验关联的数据源。例如，若最近一次 I/O 是抵达文件最<br />
后字节的 fgetc ，则 feof 返回零。下个 fgetc 失败并更改流状态为文件尾。然后 feof 才返回非零。<br />
典型用法中，输入流处理在任何错误时停止；而 feof 和 ferror 用于区别不同错误条件。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本文件名为FileTest.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    FILE* pf = nullptr;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf,<span class="string">&quot;FileTest.cpp&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(nullptr==pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!feof(pf))<span class="comment">//未抵达末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        ch = fgetc(pf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = nullptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>怎么达到模拟缓慢打字的效果</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    FILE* pf = nullptr;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf, <span class="string">&quot;Test8_25.cpp&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nullptr == pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!feof(pf))<span class="comment">//未抵达末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        ch = fgetc(pf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">        Sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = nullptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如果想让这个速度更快一些，我们可以采取“缓存区”思想，每次存20个，打印20个。 可以提高打印效率</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//char ch;</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">    FILE* pf = nullptr;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf, <span class="string">&quot;Test8_25.cpp&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nullptr == pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!feof(pf))<span class="comment">//未抵达末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        fgets(str,<span class="number">20</span>,pf);</span><br><span class="line">        <span class="comment">//puts(str);//printf(&quot;%s\n&quot;,str);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = nullptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="ferror"   >
          <a href="#ferror" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ferror"></a> ferror</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ferror</span><span class="params">( FILE *stream )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>检查给定文件流的错误。</p>

        <h3 id="参数-8"   >
          <a href="#参数-8" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-8"></a> 参数</h3>
      
<p>stream 要检查的文件流</p>

        <h3 id="返回值-15"   >
          <a href="#返回值-15" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-15"></a> 返回值</h3>
      
<p>若文件流已出现错误则为非零值，否则为 0</p>

        <h2 id="perror"   >
          <a href="#perror" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#perror"></a> perror</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">perror</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>打印当前存储于系统变量 errno 的错误码到 stderr 。</p>
<p>通过连接下列组分构成描述：</p>
<ul>
<li>s 所指向的空终止字节字符串的内容后随 &quot;: &quot; （除非 s 为空指针或 s 所指向字符为空字符）实现定义的，描述存储于 errno 的错误码的错误消息字符串后随<code>'\n'</code>。</li>
<li>错误消息字符串等同于 <code>strerror(errno)</code> 的结果。</li>
</ul>

        <h3 id="参数-9"   >
          <a href="#参数-9" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-9"></a> 参数</h3>
      
<p>s 指向带解释消息的空终止字符串的指针</p>

        <h3 id="返回值-16"   >
          <a href="#返回值-16" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-16"></a> 返回值</h3>
      
<p>无</p>

        <h1 id="文件操作"   >
          <a href="#文件操作" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h1>
      
<div class="table-container"><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove</td>
<td>删除文件</td>
</tr>
<tr>
<td>rename</td>
<td>重命名文件</td>
</tr>
<tr>
<td>tmpfile</td>
<td>返回指向临时文件的指针</td>
</tr>
<tr>
<td>tmpfile_s</td>
<td>（c11）</td>
</tr>
</tbody>
</table></div>

        <h2 id="remove"   >
          <a href="#remove" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#remove"></a> remove</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *fname )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>删除 fname 所指向的字符串所标识的文件。若文件为当前进程或另一进程打开，则此函数行为是实现定义的。具体而言， POSIX 系统解链接文件名，到最后一个运行的进程关闭该文件为止，即使这是最后一个到文件的硬链接也不回收文件系统空间。 Windows 不允许删除该文件。</p>

        <h3 id="参数-10"   >
          <a href="#参数-10" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-10"></a> 参数</h3>
      
<p>fname 指向空终止字符串的指针，字符串含标识待删除文件的路径</p>

        <h3 id="返回值-17"   >
          <a href="#返回值-17" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-17"></a> 返回值</h3>
      
<p>成功时为0，错误时为非零值。</p>

        <h3 id="注意-4"   >
          <a href="#注意-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-4"></a> 注意</h3>
      
<p>POSIX 指定此函数行为的许多额外细节。</p>

        <h2 id="rename"   >
          <a href="#rename" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rename"></a> rename</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rename</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *old_filename, <span class="type">const</span> <span class="type">char</span> *new_filename )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>更改文件的文件名。该文件以 old_filename 所指向的字符串标识。新文件名以 <code>new_filename</code> 所指向的字符串标识。若 <code>new_filename</code> 存在，则行为是实现定义的。</p>

        <h3 id="参数-11"   >
          <a href="#参数-11" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-11"></a> 参数</h3>
      
<p><code>old_filename</code> 指向包含标识要重命名的文件的路径的空终止字符串的指针<br />
<code>new_filename</code> 指向包含文件新路径的空终止字符串的指针</p>

        <h3 id="返回值-18"   >
          <a href="#返回值-18" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-18"></a> 返回值</h3>
      
<p>成功时为0，失败时为非零值。</p>

        <h1 id="无格式输入输出"   >
          <a href="#无格式输入输出" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#无格式输入输出"></a> 无格式输入/输出</h1>
      
<p>这里的无格式的意思是，对二进制文件和文本文件都通用。无论是什么文件，都会一个字节一个字节地读出。</p>
<p>就比如putchar函数，当我们输入了一个“烫”时，getchar却被调用了两次。而且在第一个putchar断点时，输不出烫，运行完第二个putchar时，才出现“烫”。证明此类<code>get/put</code>读写函数是针对字节而言的，而不是官方文档中针对“字符”操作。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* pch = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pch[i] = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();<span class="comment">//消除回车</span></span><br><span class="line">	<span class="built_in">putchar</span>(pch[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">putchar</span>(pch[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>比如<code>getchar()</code>，通过调试，我们发现：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> test = getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,test);</span><br><span class="line">    test = getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>程序让你输入时，你按住Alt键+小键盘的10，意思是将10转换为一个ASCII码字符，10表示换行，这时控制台的输入指示标志挪到了下一行，但是屏幕上没有输出“10”。说明getchar对ASCII码为10对应的换行符不敏感。</p>
<p>重新进入程序，第一次输入，按住Alt键+小键盘的13（仅仅进行此操作，没有另外按enter键），意思是将13转换为一个ASCII码字符，13表示回车，这时控制台立马在下一行显示了“10”字样。这说明，我们在控制台输入一个“ASCII码为13对应的回车符”时，getchar对回车符敏感，仿佛是把回车符变成了换行符。这时，我们可以猜测，系统对标准输入设备的回车操作视为某一阶段的输入完成，可以开始推流，并且最后加了一个换行符。<strong>以前我们以为换行符才是控制输入结束的标志，现在看来，回车符才是！</strong></p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826175900462.png" alt="image-20210826175900462" /></p>
<p>接着测试，重新进入程序。我们第一次输入，按住ALT键+10，控制台的输入标志切到了下一行，没有输出数据。第二次输入，按住ALT键+13，按完后，没有其他操作，控制台输出了两行10。进一步证明了换行符10不是控制输入结束的标志，而是回车符13。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826180447679.png" alt="image-20210826180447679" /></p>
<p>然后，我们在VS2019编辑器中创建了一个txt文件，以文本格式编辑时，右下角有<code>CRLF/LF/CR</code>三种模式可以切换，当你选择了其中的一种模式，那么你键盘上的enter键就对应着什么意思。比如，若我们选择了LF模式（enter为换行），那么按一下enter键就意味着给文件输入了一个“0A”；若我们选择了CR模式（enter为回车），那么按一下enter键就意味着给文件输入了一个“0D”；若我们选择了CRLF模式（enter为回车+换行），那么按一下enter键就意味着给文件输入了一个“0D 0A”；</p>
<p>那么，我们可以推断，为什么我们在输入时，打一个回车会结束输入呢？关键在于控制台收到了“阶段结束标志”，这个标志很有可能是回车符0D，因为我们的程序经验表明，按下enter键时，不但结束了输入，而且缓冲区中多了换行符，因此给很多输入的控制带来了干扰，比如菜单选择的程序中，如果不注意消除缓冲区的换行符，那么用户在没有输入下一个字符时，缓冲区中的换行符就偷偷地替代了用户的输入工作，造成输入干扰。这意味着我们的控制台把换行符0A看作是一个可以实际输入的字符，而不是当作一个结束输入的标志。由此可以推断，我们在Windows控制台的enter键实际上默认是CRLF模式。即：既告诉控制台我们结束了输入，又给你打了个换行符。</p>
<p>最后，对于以下程序，我们再归纳一下0D0A的坑：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本文件名为Test8_25.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf, <span class="string">&quot;Test8_25.cpp&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file open error: %d\n&quot;</span>, tag);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(pf, <span class="number">0</span>, SEEK_END);<span class="comment">//为了可以获取文件的长度，我们要调用fseek实现了文件位置指针指向文件末尾</span></span><br><span class="line">    <span class="comment">//fseek(pfs, 1, SET_END);//文件位置指针指向了文件末尾前一个，不是后一个</span></span><br><span class="line">    <span class="type">int</span> len = ftell(pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    fseek(pf, <span class="number">0</span>, SEEK_SET);<span class="comment">//现在为了要从头输出文件内容，我们需要将文件位置指针指向文件开头。</span></span><br><span class="line">    <span class="comment">//也可以使用rewind(pf);</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fscanf_s(pf,<span class="string">&quot;%c&quot;</span>, &amp;ch,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>rb打开文本文件时，对于0D0A的处理等同于用户原先在编辑此文本文件选择的enter模式。</li>
<li>fread读取rb打开的文本文件时，对于0D0A的处理等同于用户原先在编辑此文本文件选择的enter模式。</li>
<li>scanf读取r模式打开的文本文件时，对于0D0A的处理只读取了0A，把0D去除了。这说明r模式下的enter模式很有可能是LF模式；scanf读取rb模式打开的文本文件时，对于0D0A的处理等同于用户原先在编辑此文本文件选择的enter模式，也就是说，如果用户是CRLF编辑的，那么读入的数据0D0A都包含。</li>
<li><strong>综上三个现象，说明：对于0D0A的处理方式，取决于你打开文件的方式。最好以rb方式打开，原样呈现。不建议以r打开（即文本模式），因为会使源文件的真实数据丢失，比如原本的0D0A，抛弃了0D。</strong></li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>fgetc/getc</td>
<td>从文件流获取一个字节</td>
</tr>
<tr>
<td>fgets</td>
<td>从文件流获取一个字节串</td>
</tr>
<tr>
<td>fputc/putc</td>
<td>将一个字节写入文件流</td>
</tr>
<tr>
<td>fputs</td>
<td>将一个字节串写入文件流</td>
</tr>
<tr>
<td>getchar</td>
<td>从 stdin 读取一个字节</td>
</tr>
<tr>
<td>gets</td>
<td>(C11 中移除)</td>
</tr>
<tr>
<td>gets_s</td>
<td>从 stdin 读取一个字节串</td>
</tr>
<tr>
<td>putchar</td>
<td>将一个字节写入 stdout</td>
</tr>
<tr>
<td>puts</td>
<td>将一个字节串写入 stdout</td>
</tr>
<tr>
<td>ungetc</td>
<td>将一个字节送回文件流</td>
</tr>
</tbody>
</table></div>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line">    scanf_s(<span class="string">&quot;%s&quot;</span>,buff,<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,buff);</span><br><span class="line">    gets_s(<span class="string">&quot;%s&quot;</span>,buff,<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//如果我们只输入一次&quot;123 345 567 789&quot;并回车，那么我们的屏幕上将会打印：</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"> <span class="number">345</span> <span class="number">567</span> <span class="number">789</span></span><br><span class="line"><span class="comment">/*原因：</span></span><br><span class="line"><span class="comment">scanf(&quot;%s&quot;,...);我们是给了格式控制的，遇到空格就结束了。</span></span><br><span class="line"><span class="comment">gets();是遇到回车就结束。注意，上面已经讨论过了，是遇到“回车符”结束，遇到“换行符”不会控制输入结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> select;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;**********\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 1.       \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 2.       \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 3.       \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 4.       \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;select:\n&quot;</span>);</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;select);</span><br><span class="line">        <span class="keyword">switch</span>(select)</span><br><span class="line">    	&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是否继续(y/n):&quot;</span>);</span><br><span class="line">        getchar();<span class="comment">//消除回车的影响。</span></span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;<span class="keyword">while</span>(ch==<span class="string">&#x27;y&#x27;</span>||ch==<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main end \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="getcfgetc"   >
          <a href="#getcfgetc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#getcfgetc"></a> getc/fgetc</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">( FILE * stream )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc</span><span class="params">( FILE * stream )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>从给定的输入流读取下一个字符。 <code>getc()</code> 可以实现为宏。</p>

        <h3 id="参数-12"   >
          <a href="#参数-12" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-12"></a> 参数</h3>
      
<p>stream 读取字符的来源</p>

        <h3 id="返回值-19"   >
          <a href="#返回值-19" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-19"></a> 返回值</h3>
      
<p>成功时为获得的字符，失败时为 EOF 。<br />
若文件尾条件导致失败，则另外设置 stream 上的文件尾指示器（见 <code>feof()</code> ）。若某些其他错误导致失败，则设<br />
置 stream 上的错误指示器（见 <code>ferror()</code> ）。</p>

        <h2 id="fgets"   >
          <a href="#fgets" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#fgets"></a> fgets</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">fgets</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> count, FILE * stream )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>从给定文件流读取最多 <code>count - 1</code> 个字符并将它们存储于 str 所指向的字符数组。若文件尾出现或发现换行符则终<br />
止分析，后一情况下 str 将包含一个换行符。若读入字节且无错误发生，则紧随写入到 str 的最后一个字符后写入空字<br />
符。</p>

        <h3 id="参数-13"   >
          <a href="#参数-13" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-13"></a> 参数</h3>
      
<p>str 指向 char 数组元素的指针<br />
count 写入的最大字符数（典型的为 str 的长度）<br />
stream 读取数据来源的文件流</p>

        <h3 id="返回值-20"   >
          <a href="#返回值-20" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-20"></a> 返回值</h3>
      
<p>成功时为 str ，失败时为空指针。<br />
若遇到文件尾条件导致了失败，则设置 stream 上的文件尾指示器（见 feof() ）。这仅若它导致未读取字符才是失<br />
败，该情况下返回空指针且不改变 str 所指向数组的内容（即不以空字符覆写首字节）。<br />
若某些其他错误导致了失败，则设置 stream 上的错误指示器（见 ferror() ）。 str 所指向的数组内容是不确定的<br />
（甚至可以不是空终止）。</p>

        <h3 id="注解-2"   >
          <a href="#注解-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注解-2"></a> 注解</h3>
      
<p>POSIX 额外要求若 fgets 遇到异于文件尾条件的失败则设置 errno 。<br />
尽管标准规范在 count&lt;=1 的情况下不明，常见的实现</p>
<ul>
<li>若 count &lt; 1 则不做任何事并报告错误</li>
<li>若 count == 1 ，则某些实现不做任何事并报告错误，其他实现不读内容，存储零于 str[0] 并报告成功</li>
</ul>

        <h2 id="putcfputc"   >
          <a href="#putcfputc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#putcfputc"></a> putc/fputc</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *stream )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putc</span><span class="params">( <span class="type">int</span> ch, FILE *stream )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>写入字符 ch 到给定输出流 stream 。 putc() 可以实现为宏并对 stream 求值超过一次，故对应的参数决不应是有副<br />
效应的表达式。在内部，在写入前将字符转换为 unsigned char 。</p>

        <h3 id="参数-14"   >
          <a href="#参数-14" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-14"></a> 参数</h3>
      
<p>ch 要被写入的字符<br />
stream 输出流</p>

        <h3 id="返回值-21"   >
          <a href="#返回值-21" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-21"></a> 返回值</h3>
      
<p>成功时，返回被写入字符。<br />
失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror() ）。</p>

        <h2 id="fputs"   >
          <a href="#fputs" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#fputs"></a> fputs</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> \* str, FILE \* stream )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> \* restrict str, FILE \* restrict stream )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>将以NULL 结尾的字符串 str 的每个字符写入到输出流 stream ，如同通过重复执行 fputc 。<br />
不将 str 的空字符写入。</p>

        <h3 id="参数-15"   >
          <a href="#参数-15" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-15"></a> 参数</h3>
      
<p>str 要写入的空终止字符串<br />
stream 输出流</p>

        <h3 id="返回值-22"   >
          <a href="#返回值-22" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-22"></a> 返回值</h3>
      
<p>成功时，返回非负值。<br />
失败时，返回 EOF 并设置 stream 上的错误指示器（见 ferror ）。</p>

        <h3 id="注意-5"   >
          <a href="#注意-5" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-5"></a> 注意</h3>
      
<p>相关函数 puts 后附新换行符到输出，而 fputs 写入不修改的字符串。不同的实现返回不同的非负数：一些返回最后写入的字符，一些返回写入的字符数（或若字符串长于 INT_MAX 则为该值），一些简单地非负常量，例如零。</p>

        <h2 id="getchar"   >
          <a href="#getchar" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#getchar"></a> getchar</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getchar</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>从 stdin 读取下一个字符。等价于 <code>getc(stdin)</code>。</p>

        <h3 id="参数-16"   >
          <a href="#参数-16" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-16"></a> 参数</h3>
      
<p>无</p>

        <h3 id="返回值-23"   >
          <a href="#返回值-23" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-23"></a> 返回值</h3>
      
<p>成功时为获得的字符，失败时为 EOF 。<br />
若失败由文件尾条件产生，则另外设置 stdin 上的文件尾指示器（见 feof() ）。若失败由某些其他错误产生，则设<br />
置 stdin 上的错误指示器（见 ferror() ）。</p>

        <h2 id="getsgets_s"   >
          <a href="#getsgets_s" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#getsgets_s"></a> gets/gets_s</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">gets</span><span class="params">(<span class="type">char</span> * str)</span></span>; <span class="comment">//C11 中移除</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">gets_s</span><span class="params">(<span class="type">char</span> * str, <span class="type">rsize_t</span> n)</span></span>; <span class="comment">//C11 起</span></span><br></pre></td></tr></table></div></figure>
<ol>
<li>从 stdin 读入 str 所指向的字符数组，直到发现换行符或出现文件尾。在读入数组的最后一个字符后立即写入空字符。换行符被舍弃，但不会存储于缓冲区中。</li>
<li>从 stdin 读取字符直到发现换行符或出现文件尾。至多写入 n-1 个字符到 str 所指向的数组，并始终写入空终止字符（除非 str 是空指针）。若发现换行符，则忽略它并且不将它计入写入缓冲区的字符数。</li>
</ol>
<p>在运行时检测下列错误并调用当前安装的制约处理函数：</p>
<ul>
<li>n 为零</li>
<li>n 大于 RSIZE_MAX</li>
<li>str 是空指针</li>
<li>在存储 n-1 个字符到缓冲区后没有遇到换行符或文件尾。</li>
</ul>
<p>任何情况下，<code>gets_s</code> 首先结束读取并忽略来自 stdin 的字符，直到换行符、文件尾条件，或在调用制约处理前的<br />
读取错误。<br />
同所有边界检查函数， <code>gets_s</code> 仅若实现定义 <code>__STDC_LIB_EXT1__</code>且用户在包含 <code>stdio.h</code> 前定<br />
义<code>__STDC_WANT_LIB_EXT1__</code>为整数常量 1 才保证可用。</p>

        <h3 id="参数-17"   >
          <a href="#参数-17" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-17"></a> 参数</h3>
      
<p>str 要被写入的字符串<br />
n char 数组的最大长度</p>

        <h3 id="返回值-24"   >
          <a href="#返回值-24" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-24"></a> 返回值</h3>
      
<p>成功时为 str ，失败时为空指针。<br />
若文件尾条件导致了失败，则附加设置 stdin 的文件尾指示器（见 feof() ）。若其他某些原因导致了失败，则设<br />
置 stdin 的错误指示器（见 ferror() ）。</p>

        <h3 id="注解-3"   >
          <a href="#注解-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注解-3"></a> 注解</h3>
      
<p>gets() 函数不进行边界检查，从而此函数对缓冲区溢出攻击极度脆弱。无法安全使用它（除非程序运行的环境限定<br />
能出现在 stdin 上的内容）。因此，此函数在 C99 的第三次勘误中被弃用，而在 C11 标准发布时被移除。推荐的替代<br />
品是 fgets() 和 <code>gets_s()</code> 。绝对不要用 gets() 。</p>

        <h2 id="putchar"   >
          <a href="#putchar" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#putchar"></a> putchar</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">putchar</span><span class="params">( <span class="type">int</span> ch )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>写字符 ch 到 stdout 。在内部，字符于写入前被转换到 unsigned char 。<br />
等价于 <code>putc(ch, stdout)</code>。</p>

        <h3 id="参数-18"   >
          <a href="#参数-18" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-18"></a> 参数</h3>
      
<p>ch 要被写入的字符</p>

        <h3 id="返回值-25"   >
          <a href="#返回值-25" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-25"></a> 返回值</h3>
      
<p>成功时返回写入的字符。<br />
失败时返回 EOF 并设置 stdout 上的错误指示器（见 ferror() ）</p>
<p>示例：putchar 带错误检查</p>

        <h2 id="puts"   >
          <a href="#puts" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#puts"></a> puts</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">puts</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str )</span></span>;</span><br></pre></td></tr></table></div></figure>
<p>写入每个来自空终止字符串 str 的字符及附加换行符<code>'\n'</code>到输出流 stdout ，如同以重复执行 putc 写入。<br />
不写入来自 str 的空终止字符。</p>

        <h3 id="参数-19"   >
          <a href="#参数-19" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-19"></a> 参数</h3>
      
<p>str 要写入的字符串</p>

        <h3 id="返回值-26"   >
          <a href="#返回值-26" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-26"></a> 返回值</h3>
      
<p>成功时返回非负值<br />
失败时，返回 EOF 并设置 stdout 的错误指示器（见 ferror() ）。</p>

        <h3 id="注意-6"   >
          <a href="#注意-6" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-6"></a> 注意</h3>
      
<p>puts 函数后附一个换行字符到输出，而 fputs 不这么做。<br />
不同的实现返回不同的非负数：一些返回最后写入的字符，一些返回写入的字符数（或若字符串长于<code>INT_MAX</code>则返回<br />
它），一些简单地返回非负常量。<br />
在重定向 stdout 到文件时，导致 puts 失败的典型原因是用尽了文件系统的空间。</p>

        <h2 id="ungetc"   >
          <a href="#ungetc" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#ungetc"></a> ungetc</h2>
      
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ungetc</span><span class="params">( <span class="type">int</span> ch, FILE *stream )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>若 ch 不等于 EOF ，则推入字符 ch （转译为 unsigned char ）到与流 stream 关联的输入缓冲区，方式满足从 stream 的后继读取操作将取得该字符。不修改与流关联的外部设备。<br />
流重寻位操作 fseek 、 fsetpos 和 rewind 弃去 ungetc 的效果。<br />
若调用 ungetc 多于一次，而无中间读取或重寻位，则可能失败（换言之，保证大小为 1 的回放缓冲区，但任何更大的缓冲区是实现定义的）。若成功进行多次 ungetc ，则读取操作以 ungetc 的逆序取得回放的字符。<br />
若 ch 等于 EOF ，则操作失败而不影响流。<br />
对 ungetc 的成功调用清除文件尾状态标志 feof 。<br />
在二进制流上对 ungetc 的成功调用将流位置指示器减少一（若流位置指示器为零，则行为不确定）。<br />
在文本流上对 ungetc 的成功调用以未指定方式修改流位置指示器，但保证在以读取操作取得所有回放字符后，流位置指示器等于其在 ungetc 之前的值。</p>

        <h3 id="参数-20"   >
          <a href="#参数-20" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参数-20"></a> 参数</h3>
      
<p>ch 要推入输入流缓冲区的字符<br />
stream 要回放字符到的文件流</p>

        <h3 id="返回值-27"   >
          <a href="#返回值-27" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#返回值-27"></a> 返回值</h3>
      
<p>成功时返回 ch 。<br />
失败时返回 EOF ，而给定的流保持不变。</p>

        <h3 id="注意-7"   >
          <a href="#注意-7" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#注意-7"></a> 注意</h3>
      
<p>实践中，回放缓冲区的大小会在 4k （ Linux 、 MacOS ）和 4 （ Solaris ）或保证的最小值 1 （ HPUX 、AIX ）间变化。<br />
若回放的字符等于存在于外部字符序列中该位置的字符，则回放缓冲区的表观大小可以更大（实现可以简单地自减读取的文件位置指示器，并避免维护回放缓冲区）。</p>

        <h1 id="附录c11-标准"   >
          <a href="#附录c11-标准" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#附录c11-标准"></a> 附录：C11 标准</h1>
      
<p>fopen变换了，要用<code>fopen_s</code>。里面的pf指针要取其地址写成<code>&amp;pf</code>。要返回一个<code>errno_t</code>值。可以返回错误标识值。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> ar[]=&#123;<span class="number">1.2</span>,<span class="number">2.3</span>,<span class="number">3.4</span>,<span class="number">4.5</span>,<span class="number">5.6</span>,<span class="number">6.7</span>,<span class="number">7.8</span>,<span class="number">8.9</span>,<span class="number">9.0</span>,<span class="number">1.00</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(ar)/<span class="keyword">sizeof</span>(ar[<span class="number">0</span>]);</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//pfa = fopen(&quot;yhp.txt&quot;,&quot;w&quot;);//VS2019中不能运行</span></span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf,<span class="string">&quot;yhp.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);<span class="comment">//此时pf指针就指向了系统产生的一个文件流对象。那么对文件流对象的操作就可以间接对磁盘中的文件进行操作。文件流对象内部包含缓冲区。//&quot;a&quot;代表追加写入，并且找不到文件时主动创建。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==pf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file error: %d\n&quot;</span>,tag);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(pf,<span class="string">&quot;%f &quot;</span>,ar[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210824211918339.png" alt="image-20210824211918339" /></p>

        <h1 id="关于回车和换行在文件中的表现方式"   >
          <a href="#关于回车和换行在文件中的表现方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#关于回车和换行在文件中的表现方式"></a> 关于回车和换行在文件中的表现方式</h1>
      

        <h1 id="主函数带参"   >
          <a href="#主函数带参" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#主函数带参"></a> 主函数带参</h1>
      

        <h2 id="这是不带参的"   >
          <a href="#这是不带参的" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#这是不带参的"></a> 这是不带参的</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="这是两个参数的"   >
          <a href="#这是两个参数的" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#这是两个参数的"></a> 这是两个参数的</h2>
      
<p>以下程序可以输出目前argv数组的元素个数和内容，但是直接运行的话只会输出1。<br />
我们在cmd.exe中运行此程序时，可以在后面加字符串，比如<code>tulun219.exe yhp hello newdata print</code><br />
会输出5（字符串个数），以及各字符串的内容。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>,argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;argc;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826214859920.png" alt="image-20210826214859920" /></p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826215126981.png" alt="image-20210826215126981" /></p>
<p>此处的应用价值有很多，比如我们操作控制台的时候，dir表示查看目录信息的<strong>命令程序</strong>，后面跟的/D就是其参数。很好地类比了“程序名 str1 str2”的命令控制格式。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826215343314.png" alt="image-20210826215343314" /></p>

        <h3 id="实现cmd下依靠程序进行文件的复制"   >
          <a href="#实现cmd下依靠程序进行文件的复制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#实现cmd下依靠程序进行文件的复制"></a> 实现cmd下依靠程序进行文件的复制</h3>
      
<p><code>tulun219.exe Test.cpp yhp.cpp</code></p>
<p>输入以上信息可以达到一个传参的效果。通过fopen把Test.cpp打开，通过fopen，创建yhp.cpp。然后读取数据写入到yhp.cpp中。就可以实现文件的复制。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span><span class="comment">//tulun219.exe Test.cpp yhp.cpp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    FILE* fpr = nullptr;FILE* fpw = nullptr;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;fpr,argv[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(nullptr==fpr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;src file open error:%d\n&quot;</span>,tag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tag = fopen_s(&amp;fpw,argv[<span class="number">2</span>],<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(nullptr==fpw)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;des file open error:%d\n&quot;</span>,tag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(pfr,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="type">int</span> len = ftell(pf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len:%d \n&quot;</span>,len);</span><br><span class="line">    rewind(pfr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* str = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*len);</span><br><span class="line">    fread(str,<span class="keyword">sizeof</span>(<span class="type">char</span>),len,fpr);</span><br><span class="line">    fwrite(str,<span class="keyword">sizeof</span>(<span class="type">char</span>),len,fpw);</span><br><span class="line">    fclose(fpr);</span><br><span class="line">    fclose(fpw);</span><br><span class="line">    fpr = fpw = nullptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="问题argv里的字符串存放在哪个区域"   >
          <a href="#问题argv里的字符串存放在哪个区域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#问题argv里的字符串存放在哪个区域"></a> 问题：argv里的字符串存放在哪个区域？</h4>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>上面这个程序会打印：</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826222047730.png" alt="image-20210826222047730" /></p>
<p>那么就像这样的字符串是在哪呢？代码区不可能，因为传参的时候代码早已经加载完了。堆区也不可能，因为堆区的数据都是malloc产生的。目前剩下数据区和栈区。我们仔细观察，思考，既然我们给的参数字符串可以修改，而且char * argv[]前面没有const修饰，所以肯定不是在数据区的。那么，结论就是字符串指针数组和字符串均在主函数的栈帧之下。</p>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826223218635.png" alt="image-20210826223218635" /></p>

        <h2 id="这是三个参数的"   >
          <a href="#这是三个参数的" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#这是三个参数的"></a> 这是三个参数的</h2>
      
<p>三个参数的main函数，前两个参数是配合使用的。第三个参数engv可以读取系统的环境变量。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* engv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;engv[i]!=<span class="literal">NULL</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,engv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210826223348266.png" alt="image-20210826223348266" /></p>

        <h1 id="序列化-反序列化"   >
          <a href="#序列化-反序列化" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#序列化-反序列化"></a> 序列化-反序列化</h1>
      
<p>把链表变成一组数据。</p>
<p>要求可以根据这组数据在另一个机子上构建出来链表。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本文件名为MyLinkList.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYLINKLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLINKLIST_H</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ListNode* head;</span><br><span class="line">	<span class="type">int</span> cursize;</span><br><span class="line">&#125;LinkList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLink</span><span class="params">(LinkList* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearLink</span><span class="params">(LinkList* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyLink</span><span class="params">(LinkList* plist)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetSize</span><span class="params">(<span class="type">const</span> LinkList* plist)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(<span class="type">const</span> LinkList* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert_Next</span><span class="params">(LinkList* plist, ListNode* ptr, ElemType val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Push_Front</span><span class="params">(LinkList* plist, ElemType val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Push_Back</span><span class="params">(LinkList* plist, ElemType val)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Erase_Next</span><span class="params">(LinkList* plist, ListNode* ptr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop_Front</span><span class="params">(LinkList* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop_Back</span><span class="params">(LinkList* plist)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Remove</span><span class="params">(LinkList* plist, ElemType val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Remove_All</span><span class="params">(LinkList* plist, ElemType val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintLink</span><span class="params">(<span class="type">const</span> LinkList* plist)</span>;</span><br><span class="line">ListNode* <span class="title function_">FindValue_pre</span><span class="params">(<span class="type">const</span> LinkList* plist, ElemType val)</span>;</span><br><span class="line">ListNode* <span class="title function_">FindValue</span><span class="params">(<span class="type">const</span> LinkList* plist, ElemType val)</span>;</span><br><span class="line">ListNode* <span class="title function_">FindPos_pre</span><span class="params">(<span class="type">const</span> LinkList* plist, <span class="type">int</span> pos)</span>;</span><br><span class="line">ListNode* <span class="title function_">FindPos</span><span class="params">(<span class="type">const</span> LinkList* plist, <span class="type">int</span> pos)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>
<p>现要求写两个函数：</p>
<ol>
<li><code>void ListSave(LinkList* plist);</code>把链表的数据保存到本计算机的磁盘中。通过写入到文件实现。序列化。</li>
<li><code>void ListLoad(LinkList* plist);</code>加载收到的文件中的数据，在内存中构建一个链表，重载数据。反序列化。</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyLinkList.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MyLinkList.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListSave</span><span class="params">(LinkList* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(plist!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(plist))<span class="keyword">return</span>;</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf,<span class="string">&quot;List.dat&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;file open error:%d\n&quot;</span>,tag);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(pf,<span class="string">&quot;%d\n&quot;</span>,plist-&gt;cursize);</span><br><span class="line">    ListNode* pnode = plist-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(pnode!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(pf,<span class="string">&quot;%d\n&quot;</span>,pnode-&gt;data);</span><br><span class="line">        pnode=pnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ListLoad</span><span class="params">(LinkList* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(plist!=<span class="literal">NULL</span>);</span><br><span class="line">    FILE* pf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">errno_t</span> tag = fopen_s(&amp;pf,<span class="string">&quot;List.dat&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file open error:%d\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    fscanf_s(pf,<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">        fscanf_s(pf,<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">        Push_Back(plist,val);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    pf=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkList mylist;</span><br><span class="line">    InitLink(&amp;mylist);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">while</span>(scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;val),val!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_Front(&amp;mylist,val);</span><br><span class="line">    &#125;</span><br><span class="line">    PrintLink(&amp;mylist);</span><br><span class="line">    <span class="comment">//以上程序运行时，输入12 23 34 45 56 67 78 89 90 100 -1</span></span><br><span class="line">    <span class="comment">//输入100 90 89 78 67 56 45 34 23 12 （因为是头插）</span></span><br><span class="line">    ListSave(&amp;mylist);</span><br><span class="line">    </span><br><span class="line">    LinkList newlist;</span><br><span class="line">    InitLink(&amp;newlist);</span><br><span class="line">    ListLoad(&amp;newlist);</span><br><span class="line">    PrintLink(&amp;newlist);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    DestoryLink(&amp;mylist);</span><br><span class="line">    DestoryLink(&amp;newlist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="json专题"   >
          <a href="#json专题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#json专题"></a> json专题</h1>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//json对象结构：</span></span><br><span class="line"><span class="comment">/* The cJSON structure: */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>,*<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">int</span> type;</span><br><span class="line">	<span class="type">char</span> *valuestring;</span><br><span class="line">	<span class="type">int</span> valueint;</span><br><span class="line">	<span class="type">double</span> valuedouble;</span><br><span class="line">	<span class="type">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125;cJSON;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//yhp.json文件</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;杨和平&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">17</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;LOVE&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;Study&quot;</span><span class="punctuation">,</span><span class="string">&quot;Programming&quot;</span><span class="punctuation">,</span><span class="string">&quot;Go shopping&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">145</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="string">&quot;shanxi&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/C_%E6%96%87%E4%BB%B6/image-20210827202745517.png" alt="image-20210827202745517" /></p>

        <h2 id="有价值的问题"   >
          <a href="#有价值的问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#有价值的问题"></a> 有价值的问题</h2>
      
<p>如何把数据通过json把数据写到文件，</p>
<p>如何通过文件写到程序中。</p>

        <h2 id="cjson_inithooks"   >
          <a href="#cjson_inithooks" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cjson_inithooks"></a> <code>cJSON_InitHooks</code></h2>
      
<p><code>extern void cJSON_InitHooks(cJSON_Hooks* hooks);</code></p>
<p>向cJSON 提供malloc 和free 函数：挂接内存池</p>

        <h2 id="cjson_parse"   >
          <a href="#cjson_parse" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cjson_parse"></a> <code>cJSON_Parse</code></h2>
      
<p><code>extern cJSON* cJSON_Parse(const char *value);</code></p>
<p>提供一个JSON 块，然后返回一个可以查询的cJSON 对象。完成后不要忘了调用<code>cJSON_Delete</code>。</p>

        <h2 id="cjson_print"   >
          <a href="#cjson_print" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#cjson_print"></a> <code>cJSON_Print</code></h2>
      
<p><code>extern char* cJSON_Print(cJSON\* item);</code></p>
<p>将cJSON 实体呈现为用于传输/存储的文本。完成后释放char*。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>  <span class="comment">// malloc free  exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> s_id[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> s_name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> s_sex[<span class="number">8</span>];</span><br><span class="line">    <span class="type">int</span> s_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">pstud</span>;</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *buff = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;Student.json&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    len = ftell(fp);  <span class="comment">// file size </span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    </span><br><span class="line">    buff = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>),len+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//fgets(buff,len+1,fp); // </span></span><br><span class="line">    fread(buff,<span class="keyword">sizeof</span>(<span class="type">char</span>),len+<span class="number">1</span>,fp);</span><br><span class="line">    fclose(fp); </span><br><span class="line">    fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buff);</span><br><span class="line">    cJSON *json = cJSON_Parse(buff);</span><br><span class="line">    <span class="built_in">free</span>(buff); buff = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *<span class="built_in">array</span> = cJSON_GetObjectItem(json,<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    n = cJSON_GetArraySize(<span class="built_in">array</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n : %d \n&quot;</span>,n);</span><br><span class="line">    </span><br><span class="line">    pstud = (<span class="keyword">struct</span> Student*)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student),n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON *obj = cJSON_GetArrayItem(<span class="built_in">array</span>,i);</span><br><span class="line">        cJSON *id = cJSON_GetObjectItem(obj,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        cJSON *name = cJSON_GetObjectItem(obj,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        cJSON *sex = cJSON_GetObjectItem(obj,<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">        cJSON *age = cJSON_GetObjectItem(obj,<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(pstud[i].s_id,id-&gt;valuestring);</span><br><span class="line">        <span class="built_in">strcpy</span>(pstud[i].s_name,name-&gt;valuestring);</span><br><span class="line">        <span class="built_in">strcpy</span>(pstud[i].s_sex,sex-&gt;valuestring);</span><br><span class="line">        pstud[i].s_age=age-&gt;valueint;</span><br><span class="line">        <span class="type">char</span> *s = cJSON_Print(obj);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,s);</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id: %s,name: %s,sex: %s,age: %d\n&quot;</span>,pstud[i].s_id,pstud[i].s_name,pstud[i].s_sex,pstud[i].s_age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stud</span>[]=</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;09001&quot;</span>,<span class="string">&quot;yhping&quot;</span>,<span class="string">&quot;man&quot;</span>,<span class="number">23</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;09002&quot;</span>,<span class="string">&quot;lijianli&quot;</span>,<span class="string">&quot;man&quot;</span>,<span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;09003&quot;</span>,<span class="string">&quot;tianjia&quot;</span>,<span class="string">&quot;man&quot;</span>,<span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;09004&quot;</span>,<span class="string">&quot;liulu&quot;</span>,<span class="string">&quot;woman&quot;</span>,<span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;09005&quot;</span>,<span class="string">&quot;baihen&quot;</span>,<span class="string">&quot;man&quot;</span>,<span class="number">17</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(stud)/<span class="keyword">sizeof</span>(stud[<span class="number">0</span>]); </span><br><span class="line">    cJSON *json = cJSON_CreateObject();</span><br><span class="line">    cJSON *<span class="built_in">array</span> = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddItemToObject(json,<span class="string">&quot;Student&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123; <span class="comment">// 11:53</span></span><br><span class="line">        cJSON *obj = cJSON_CreateObject();</span><br><span class="line">        cJSON_AddItemToArray(<span class="built_in">array</span>,obj);</span><br><span class="line">        <span class="comment">//cJSON_AddItemToObject(obj,&quot;id&quot;,cJSON_CreateString(stud[i].s_id));</span></span><br><span class="line">        cJSON_AddStringToObject(obj,<span class="string">&quot;id&quot;</span>,stud[i].s_id);</span><br><span class="line">        cJSON_AddStringToObject(obj,<span class="string">&quot;name&quot;</span>,stud[i].s_name);</span><br><span class="line">        cJSON_AddStringToObject(obj,<span class="string">&quot;sex&quot;</span>,stud[i].s_sex);</span><br><span class="line">        cJSON_AddNumberToObject(obj,<span class="string">&quot;age&quot;</span>,stud[i].s_age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *s = cJSON_Print(json);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,s);</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;Student.json&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    fwrite(s,<span class="keyword">sizeof</span>(<span class="type">char</span>),<span class="built_in">strlen</span>(s),fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    s = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON_Delete(json);</span><br><span class="line">    json = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *json = cJSON_CreateObject();</span><br><span class="line">    <span class="comment">// &quot;&#123;&#125;&quot;</span></span><br><span class="line">    cJSON_AddItemToObject(json,<span class="string">&quot;name&quot;</span>,cJSON_CreateString(<span class="string">&quot;yhping&quot;</span>));</span><br><span class="line">    <span class="comment">//&quot; &#123;\&quot;name\&quot;:\&quot;yhping\&quot;&#125; &quot;</span></span><br><span class="line">    cJSON_AddItemToObject(json,<span class="string">&quot;sex&quot;</span>,cJSON_CreateString(<span class="string">&quot;man&quot;</span>));<span class="comment">// object =&gt;key:value</span></span><br><span class="line">    <span class="comment">//cJSON *sex = cJSON_CreateString(&quot;man&quot;);</span></span><br><span class="line">    <span class="comment">//cJSON_AddItemToObject(json,&quot;sex&quot;,sex);</span></span><br><span class="line">    <span class="comment">//&quot;  &#123;\&quot;name\&quot;:\&quot;yhping\&quot; , \&quot;sex\&quot;:\&quot;man\&quot;&#125; &quot;</span></span><br><span class="line">    cJSON_AddItemToObject(json,<span class="string">&quot;age&quot;</span>,cJSON_CreateNumber(<span class="number">23</span>));</span><br><span class="line">    <span class="comment">//&quot;  &#123;\&quot;name\&quot;:\&quot;yhping\&quot; , \&quot;sex\&quot;:\&quot;man\&quot;, \&quot;age\&quot;:23&#125; &quot;</span></span><br><span class="line">    </span><br><span class="line">    cJSON *<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON_AddItemToObject(json,<span class="string">&quot;LOVE&quot;</span>,<span class="built_in">array</span> = cJSON_CreateArray());</span><br><span class="line">    <span class="comment">// &quot;  &#123;\&quot;name\&quot;:\&quot;yhping\&quot; , \&quot;sex\&quot;:\&quot;man\&quot;, \&quot;age\&quot;:23,&quot;LOVE&quot;:[]&#125; &quot;</span></span><br><span class="line">    cJSON_AddItemToArray(<span class="built_in">array</span>,cJSON_CreateString(<span class="string">&quot;Study&quot;</span>));</span><br><span class="line">    <span class="comment">// &quot;  &#123;\&quot;name\&quot;:\&quot;yhping\&quot; , \&quot;sex\&quot;:\&quot;man\&quot;, \&quot;age\&quot;:23,&quot;LOVE&quot;:[&quot;Study&quot;]&#125; &quot;</span></span><br><span class="line">    cJSON_AddItemToArray(<span class="built_in">array</span>,cJSON_CreateString(<span class="string">&quot;Programming&quot;</span>));</span><br><span class="line">    cJSON_AddItemToArray(<span class="built_in">array</span>,cJSON_CreateString(<span class="string">&quot;Go shopping&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    cJSON_AddItemToObject(json,<span class="string">&quot;score&quot;</span>,cJSON_CreateNumber(<span class="number">145</span>));</span><br><span class="line">    <span class="comment">//cJSON_AddNumberToObject(json,&quot;score&quot;,145);</span></span><br><span class="line">    </span><br><span class="line">    cJSON_AddItemToObject(json,<span class="string">&quot;address&quot;</span>,cJSON_CreateString(<span class="string">&quot;shanxi&quot;</span>));</span><br><span class="line">    <span class="comment">//cJSON_AddStringToObject(json,&quot;addree&quot;,&quot;shanxi&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *str = cJSON_Print(json);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    str = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON_Delete(json);</span><br><span class="line">    json = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buff = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;Testcjson.json&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    len = ftell(fp);  <span class="comment">// file size </span></span><br><span class="line">    rewind(fp);</span><br><span class="line">    </span><br><span class="line">    buff = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>),len+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//fgets(buff,len+1,fp); // </span></span><br><span class="line">    fread(buff,<span class="keyword">sizeof</span>(<span class="type">char</span>),len+<span class="number">1</span>,fp);</span><br><span class="line">    </span><br><span class="line">    cJSON *json = cJSON_Parse(buff);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = cJSON_GetArraySize(json);</span><br><span class="line">    </span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(buff);</span><br><span class="line">    buff = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[]=<span class="string">&quot;&#123; \&quot;name\&quot;:\&quot;yhping\&quot; ,\&quot;sex\&quot;:\&quot;man\&quot;,\&quot;age\&quot;:23 &#125;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> stra[]=<span class="string">&quot;&#123;name: yhping,sex:man,age:23&#125;&quot;</span>;</span><br><span class="line">    cJSON *json = cJSON_Parse(str);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *s = cJSON_Print(json);</span><br><span class="line">    <span class="type">char</span> *p = cJSON_PrintUnformatted(json);</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;Testcjson.json&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,p);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    s = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>
<p>改进</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span>* <span class="title">next</span>,*<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span>* <span class="title">child</span>;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">char</span>* valuestring;</span><br><span class="line">        <span class="type">int</span> valueint;</span><br><span class="line">        <span class="type">double</span> valuedouble;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="总结-3"   >
          <a href="#总结-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h1>
      
<p>w/a可以主动创建文件，r不能创建文件。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/C/C%E8%AF%AD%E8%A8%80_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B5%AE%E7%82%B9%E5%9E%8B/">C语言_数据类型_浮点型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-08-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-07-30</span></span><span class="post-meta-item post-meta-item--visitors leancloud_visitors" id="/C/C%E8%AF%AD%E8%A8%80_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E6%B5%AE%E7%82%B9%E5%9E%8B/" data-flag-title="C语言_数据类型_浮点型"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value leancloud-visitors-count"></span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="课件"   >
          <a href="#课件" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#课件"></a> 课件</h1>
      
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818232054410.png" alt="image-20210818232054410" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818232259910.png" alt="image-20210818232259910" /><br />
<img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818232907404.png" alt="image-20210818232907404" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231225754.png" alt="image-20210818231225754" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231301755.png" alt="image-20210818231301755" /><br />
<img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231320838.png" alt="image-20210818231320838" /><br />
<img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231341094.png" alt="image-20210818231341094" /><br />
<img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231554889.png" alt="image-20210818231554889" /><br />
<img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231457059.png" alt="image-20210818231457059" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818231917144.png" alt="image-20210818231917144" /></p>

        <h1 id="二进制"   >
          <a href="#二进制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#二进制"></a> 二进制</h1>
      
<p>二进制怎么转换为十进制？<code>0101  -&gt;  5</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">次数：  3  2  1  0</span><br><span class="line">权值：  0  1  0  1</span><br><span class="line">  0 + 1 * 2^2 + 0 + 1 * 2^0</span><br><span class="line">= 0 +   4     + 0 +    1</span><br><span class="line">= 5</span><br></pre></td></tr></table></div></figure>
<p>十进制怎么转换为二进制？<code>5   -&gt;  101</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2  | 5                     </span><br><span class="line">   ---------               _</span><br><span class="line">  2  | 2   ......     1   /|\    后3位</span><br><span class="line">     ---------             |</span><br><span class="line">    2  | 1   .....    0    |     后2位</span><br><span class="line">        -------            |</span><br><span class="line">          0   ......  1    |     后1位</span><br></pre></td></tr></table></div></figure>

        <h2 id="负数怎么表示"   >
          <a href="#负数怎么表示" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#负数怎么表示"></a> 负数怎么表示</h2>
      
<p>以下均是在4位机下讨论</p>
<p>负5？</p>
<p><code>5 + x = 0 -&gt; 0101 + x = 0 -&gt; 0101 + 1010 = 1111, 1111 + 1 = 0, x = 1010 + 1 = 1011</code></p>
<p>负数用补码表示，是原码的反码加1。</p>
<p>负8？</p>
<p>先求8的原码的反码，再加1：<code>8: 1000 -&gt; 0111 + 1 -&gt; 1000</code></p>
<p>负8的补码居然是它自己？</p>
<p>搞了半天发现，我们一开始就说明了，在4位机下讨论，那么有符号数的范围只有<code>-8 ~ 7</code>，根本就不存在8一说。所以，无法求得8的原码，也因此无法求8的补码。（为什么1000不能代表8的原码？因为有符号数中第一位代表符号位！）</p>

        <h2 id="16进制"   >
          <a href="#16进制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#16进制"></a> 16进制</h2>
      
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 0101 1100</span><br><span class="line">  5    C</span><br><span class="line">=&gt; 0x5C</span><br></pre></td></tr></table></div></figure>
<p>数字字面常量的规则：只要第一位是数字，那么代表这是个数字。而0开头的数字，不带x的是8进制（<code>0___</code>），带x的是16进制（<code>0x___</code>），带b的是2进制（<code>0b___</code>）。</p>
<p>16进制的格式化输出的描述符为<code>%x</code>，代表<code>unsigned hexadecimal integer</code>，是无符号十六进制整型。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucVal = <span class="number">0x5c</span>u;<span class="comment">//0x5c是数字，u是无符号指示</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hhu\n&quot;</span>, ucVal);    <span class="comment">//92</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hhx\n&quot;</span>, ucVal);    <span class="comment">//5c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="8进制"   >
          <a href="#8进制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#8进制"></a> 8进制</h3>
      
<p>8进制的格式化输出的描述符为<code>%o</code>，代表<code>unsigned octal</code>，是无符号8进制数。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 01 011 100</span><br><span class="line">  1   3   4</span><br><span class="line">=&gt; 0134</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucVal = <span class="number">0134u</span>;<span class="comment">//0134是数字，u是无符号指示</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hhu\n&quot;</span>, ucVal);    <span class="comment">//92</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hho\n&quot;</span>, ucVal);    <span class="comment">//134</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="2进制"   >
          <a href="#2进制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#2进制"></a> 2进制</h3>
      
<p>输出2进制：需要把C语言设置为17标准。</p>
<p>2进制没有格式化输出的描述符。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      0101 1100</span><br><span class="line">=&gt; 0b 0101 1100</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucVal = <span class="number">0b0101&#x27;1100</span>u; <span class="comment">// &#x27;为分割符号，便于人性化输入，可有可无</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hhu\n&quot;</span>, ucVal);    <span class="comment">//92</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hho\n&quot;</span>, ucVal);    <span class="comment">//134</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="integer"   >
          <a href="#integer" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#integer"></a> integer</h1>
      
<p>32 bits, 4 Bytes</p>
<ol>
<li>区分有符号、无符号，其中有符号的<code>signed</code>可以省略；无符号带int的整型的int可以省略，其他无符号整型不能省；long int中的int可以省略</li>
<li>字面常量（8、8u）也是有类型的，不带后缀默认是有符号数，带u是无符号数。</li>
</ol>

        <h2 id="long-int"   >
          <a href="#long-int" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#long-int"></a> long int</h2>
      
<p>ISO标准中提到，long int的大小不得小于int。目前微软long int的大小为32bits、4字节；而在Linux下为64bits、8字节。</p>
<p>long指示类型的长度，涉及到长度，格式化输出时，需要注意加上length specifiers，即长度描述符。</p>

        <h2 id="long-long-int"   >
          <a href="#long-long-int" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#long-long-int"></a> long long int</h2>
      
<p>64bits、8字节</p>

        <h2 id="short-int"   >
          <a href="#short-int" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#short-int"></a> short int</h2>
      
<p>16bits、2字节</p>
<p>针对于整型字面常量的长度描述符没有专门用于short的，因为C语言字面常量最小为32位。如果比32位小的，一律向下兼容。归根结底是因为数据总线最少一次传32位。</p>
<p>但是，针对于printf中的格式化输出，还是要区分长度的，对应short的长度描述符为h。</p>

        <h2 id="char"   >
          <a href="#char" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#char"></a> char</h2>
      
<p>如果要打印十进制整数，那么对应char的长度描述符为<code>hh</code>。格式描述符为<code>i</code>或<code>u</code>。</p>
<p>而如果要打印字符，那么对应的格式描述符为<code>c</code>。</p>
<p>ASCII码：形式上是字符图形，但本质上是整数，如<code>'a'</code>是97。</p>

        <h2 id="整型类测试"   >
          <a href="#整型类测试" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#整型类测试"></a> 整型类测试</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* integer: 32bits */</span></span><br><span class="line">    <span class="comment">/*signed*/</span> <span class="type">int</span> iVal = <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="comment">/*int*/</span> uVal = <span class="number">8u</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, iVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, uVal);</span><br><span class="line">    <span class="comment">/* long int: 32bits */</span></span><br><span class="line">    <span class="comment">/*signed*/</span> <span class="type">long</span> <span class="comment">/*int*/</span> lVal = <span class="number">9l</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="comment">/*int*/</span> ulVal = <span class="number">9ul</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%li\n&quot;</span>, lVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, ulVal);</span><br><span class="line">    <span class="comment">/* long long int: 64bits */</span></span><br><span class="line">    <span class="comment">/*signed*/</span> <span class="type">long</span> <span class="type">long</span> <span class="comment">/*int*/</span> llVal = <span class="number">9ll</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="comment">/*int*/</span> ullVal = <span class="number">9ull</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lli\n&quot;</span>, llVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, ullVal);</span><br><span class="line">    <span class="comment">/* short int: 16bits */</span></span><br><span class="line">    <span class="comment">/*signed*/</span> <span class="type">short</span> <span class="comment">/*int*/</span> sVal = <span class="number">9</span>; <span class="comment">//9后面没有专门用于short的长度指示符</span></span><br><span class="line">    <span class="comment">/*unsigned*/</span> <span class="type">short</span> <span class="comment">/*int*/</span> usVal = <span class="number">9u</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hi\n&quot;</span>, sVal);             <span class="comment">//但是格式化输出有，要加上h</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hu\n&quot;</span>, usVal);</span><br><span class="line">    <span class="comment">/* char: 8bits */</span></span><br><span class="line">    <span class="comment">/*signed*/</span> <span class="type">char</span> cVal = <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucVal = <span class="number">9u</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hhi\n&quot;</span>, cVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%hhu\n&quot;</span>, ucVal);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucVal2 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ucVal2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="浮点型"   >
          <a href="#浮点型" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h1>
      
<p>计算机中整型和浮点型的计算是在不同的处理器下完成的。整型处理器是由x86部分完成的，浮点型处理器是由x87部分完成的。因为整型和浮点型的格式是不一样的。</p>
<blockquote>
<p>小数默认都是有符号数。</p>
</blockquote>
<p>1010.1101二进制小数化为十进制小数。依然按照每一位的权重展开计算：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align at position 7: \begin{̲a̲l̲i̲g̲n̲}̲
&amp; 1\times2^3+0…'>\begin{align}
&amp; 1\times2^3+0\times2^2+1\times2^1+0\times2^0+1\times2^{-1}+1\times2^{-2}+0\times2^{-3}+1\times2^{-4}\\
&amp; =8+2+\frac{1}{2}+\frac{1}{4}+\frac{1}{16}\\
&amp; =10.8125
\end{align}
</p>
<p>10.8125十进制小数如何化为二进制小数？整数部分是一直进行余2运算，而小数部分如何化？即0.1101。</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align at position 7: \begin{̲a̲l̲i̲g̲n̲}̲
0.8125\times2&amp;…'>\begin{align}
0.8125\times2&amp;=1.625\cdots1\\
0.625\times2&amp;=1.250\cdots1\\
0.25\times2&amp;=0.500\cdots0\\
0.5\times2&amp;=1.000\cdots1\\
&amp;end
\end{align}
</p>
<p>与求整数的二进制不同，求余之后，整数二进制的结果从下往上顺位。而小数二进制是从上往下顺位。</p>
<p>0.13化为二进制小数时会遇到无限循环的现象：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align at position 7: \begin{̲a̲l̲i̲g̲n̲}̲
0.13\times2&amp;=0…'>\begin{align}
0.13\times2&amp;=0.26\cdots0\\
0.26\times2&amp;=0.52\cdots0\\
0.52\times2&amp;=1.04\cdots1\\
0.04\times2&amp;=0.08\cdots0 -- cycle\\
0.08\times2&amp;=0.16\cdots0\\
0.16\times2&amp;=0.32\cdots0\\
0.32\times2&amp;=0.64\cdots0\\
0.64\times2&amp;=1.28\cdots1\\
0.28\times2&amp;=0.56\cdots0\\
0.56\times2&amp;=1.02\cdots1\\
0.02\times2&amp;=0.04\cdots0\\
0.04\times2&amp;=0.08\cdots0 -- cycle\\
&amp;\cdots
\end{align}
</p>

        <h2 id="float单精度"   >
          <a href="#float单精度" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#float单精度"></a> float（单精度）</h2>
      
<p>全称：single point float，单精度浮点数。32 bits, 4 Bytes</p>
<p>格式描述符用<code>f</code>。代表十进制浮点数（Decimal floating point）</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> fVal = <span class="number">5.0f</span>;   <span class="comment">//加f后缀指示其为float类型字面常量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, fVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="double双精度"   >
          <a href="#double双精度" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#double双精度"></a> double（双精度）</h2>
      
<p>全称：double point float，双精度浮点数。64 bits, 8 Bytes</p>
<p>格式描述符也是用<code>f</code>。代表十进制浮点数（Decimal floating point）</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dVal = <span class="number">5.0</span>;  <span class="comment">//字面小数常量不加后缀，默认为double类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, dVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="long-double"   >
          <a href="#long-double" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#long-double"></a> long double</h2>
      
<p>Modern Cpp和新的C标准才有的。标准指出long double长度不得小于double。在微软编译器下等于double长度，有些编译器是大于double长度的。为什么微软如此保守呢？因为CPU的字长一般还是64位。如果大小设计超过64位的话，就需要两个时钟周期来完成数据的传输。</p>
<p>需要注意，long double的格式描述符依旧为<code>f</code>，<code>%</code>后面的长度描述符不再是<code>l</code>而是大写的<code>L</code>。而字面常量的后缀还是小写的<code>l</code>。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> ldVal = <span class="number">5.0l</span>; <span class="comment">// 加l后缀</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%Lf\n&quot;</span>, ldVal);   <span class="comment">// 加L前缀，格式描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="科学计数法"   >
          <a href="#科学计数法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#科学计数法"></a> 科学计数法</h2>
      
<p>651.32怎么表示（字面常量）？</p>
<ol>
<li><code>651.32</code></li>
<li><code>6.52132e+2</code>，其中<code>+</code>可以省略</li>
</ol>
<p>科学计数法的格式描述符为<code>e</code>或<code>E</code>。表示：Scientific notation (mantissa/exponent), lowercase/uppercase</p>
<p>0.065132呢？<code>6.5132e-2</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dVal = <span class="number">6.52132e+2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, dVal); <span class="comment">// 652.132000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%e\n&quot;</span>, dVal); <span class="comment">// 6.521320e+02</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%E\n&quot;</span>, dVal); <span class="comment">// 6.521320E+02</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="float内存结构ieee754标准"   >
          <a href="#float内存结构ieee754标准" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#float内存结构ieee754标准"></a> float内存结构（IEEE754标准）</h2>
      
<p>IEEE754标准。所有处理器，无论手机上的ARM架构还是服务器处理器都是遵循这个标准。</p>
<p>三部分：sign（符号位）、exponent（指数）、mantissa（底数）</p>

        <h3 id="sign符号位"   >
          <a href="#sign符号位" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sign符号位"></a> sign（符号位）</h3>
      
<p>sign（符号位） - 1 bit - 1代表负，0代表正</p>

        <h3 id="exponent指数"   >
          <a href="#exponent指数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#exponent指数"></a> exponent（指数）</h3>
      
<p>首先，指数是一个有符号数。<br />
负数，是补码表达的。八位二进制来说，0000 0000表示0，则 1111 1111表示-1，1000 0000表示-128，0111 1111表示127，这是有符号正数的最大值，再加1就溢出了。本来的范围是：<code>-128 ~ 127</code><br />
但是，浮点数中指数位置存储的是偏移值，如果是float，存储的值是加了127的。因此，指数为1时，应该存储<code>1 + 127 = 128</code>，存储<code>1000 0000</code>；指数为2时，应该存储<code>2 + 127 = 129</code>，存储<code>1000 0001</code>。因此，加127后，范围就变成了：<code>-1 ~ 254</code>。<br />
而指数全0、全1，在浮点数中有特殊含义。所以，范围就变成了：<code>1 ~ 254</code>。减去127之后，实际的范围就变成了：<code>-126 ~ 127</code>。</p>
<p>举一个例子：<code>7.25</code>怎么表示？先转化为二进制：<code>0111.01</code>，带权的形式则是：<code>1.1101 * 2^2</code>，即右移2位，指数为2。<br />
实际存储的二进制形式：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0     1000 0001            (1)110 1000 0000 0000 0000 0000`</span><br><span class="line">符   指数位（2+127=129）    底数位（23位）前面有个隐藏的1，不在这23位中</span><br></pre></td></tr></table></div></figure>
<p>exponent（指数） - 8 bits - 标准里规定：</p>
<p>在exp位模式（the bit pattern of exp）既不全为0，也不全为1时，浮点数值为<strong>规格化的值</strong>。<br />
阶码字段在这种情况下，被解释为以偏置（biased）形式表示的<strong>有符号整数</strong>（原文：the exponent field is interpreted as representing a signed integer in <em>biased</em> form）。<br />
那么，阶码字段的值为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mi>e</mi><mo>−</mo><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">E = e - Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>。<br />
其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>是无符号数，即直接通过exp位模式计算得出。<br />
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>是一个固定值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mtext>的位数</mtext><mo separator="true">,</mo><mtext>单精度下是</mtext><mn>8</mn><mtext>位</mtext><mo separator="true">,</mo><mtext>双精度下是</mtext><mn>11</mn><mtext>位</mtext></mrow><annotation encoding="application/x-tex">2^{k-1}-1, k = exp的位数, 单精度下是8位, 双精度下是11位</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">数</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">精</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">是</span><span class="mord">8</span><span class="mord cjk_fallback">位</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">精</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">是</span><span class="mord">1</span><span class="mord">1</span><span class="mord cjk_fallback">位</span></span></span></span>。比如，float，指数二进制位数为8位时，Bias就是128-1=127。<br />
单精度下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi><mo>=</mo><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">Bias=2^7-1=127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span>。<br />
因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>127</mn><mo stretchy="false">)</mo><mo>∼</mo><mo stretchy="false">(</mo><mn>254</mn><mo>−</mo><mn>127</mn><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mn>126</mn><mo>∼</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">(1-127)\sim(254-127)=-126\sim127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span>，表示在2进制下可以右移127位、左移126位。<br />
e和最终的移位值之间的对应关系：<code>1 = -126</code>、<code>2 = -125</code>，…，<code>253 = 126</code>、<code>254 = 127</code>。</p>
<blockquote>
<p>由此，看出，不能简单地把exp位模式看做有符号数直接计算得到移位数值，如果直接当做有符号数计算的话，范围变成了：<code>1000'0000 ~ 0111'1111 = -128 ~ 127</code>。和标准规定的对应不上！</p>
</blockquote>
<p>为什么要预留出来exp位模式全0或全1的情况？</p>
<ol>
<li><strong>全0是为了能让浮点数可以表示0或者表示非常接近于0.0的数</strong>。此情况在标准中称为：“<strong>非规格化</strong>的值”。这种情况下，阶码值（移位值）规定为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>=</mo><mn>1</mn><mo>−</mo><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">E=1-Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>。并且要特别注意：底数的值是位模式直接计算出来的，也就是小数字段的值，不包含隐含的开头的1。即：<code>0.XXXX</code>，不再是<code>1.XXXX</code>！</li>
</ol>
<blockquote>
<p>使阶码值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1-Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>而不是简单的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">-Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>​似乎是违反直觉的。但是这种方式提供了一种从非规格化值平滑转换到规格化值的方法。</p>
</blockquote>
<ol start="2">
<li>非规格化数有两个用途。首先，它们提供了一种表示数值0的方法，因为使用规格化数，我们必须总是使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此就不能表示0。实际上，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>0.0</mn></mrow><annotation encoding="application/x-tex">+0.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span></span>的浮点表示的位模式为全0：符号位是0，阶码字段全为0（表明是一个非规格化值），而小数域也全为0，这就得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M=f=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。令人奇怪的是，当符号位为1，而其他域全为0时，我们得到值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0.0</mn></mrow><annotation encoding="application/x-tex">-0.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span></span>。根据IEE的浮点格式，值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>0.0</mn></mrow><annotation encoding="application/x-tex">+0.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>0.0</mn></mrow><annotation encoding="application/x-tex">-0.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span></span>在某些方面被认为是不同的，而在其他方面是相同的。</li>
<li>非规格化数的另外一个功能是表示那些非常接近于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.0</mn></mrow><annotation encoding="application/x-tex">0.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span></span>的数。这提供了一种属性，称为逐渐溢出（gradual underflow），其中，可能的数值分布均匀地接近于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.0</mn></mrow><annotation encoding="application/x-tex">0.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span></span>。而刚才提到的使阶码值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1-Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>而不是简单的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>B</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">-Bias</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span></span></span></span>，就是为这个做铺垫的！<strong>详看CSAPP-3rd P80</strong>。</li>
<li>全1是为了能让浮点数表示
<ol>
<li>无穷大 - 底数全0时</li>
<li>NaN - 底数非0时</li>
</ol>
</li>
</ol>

        <h3 id="mantissa底数"   >
          <a href="#mantissa底数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#mantissa底数"></a> mantissa（底数）</h3>
      
<ol start="4">
<li>mantissa（底数） - 23 bits - 范围、<strong>精度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lg</mi><mo>⁡</mo><msup><mn>2</mn><mn>24</mn></msup><mo>≈</mo><mn>7.2247</mn></mrow><annotation encoding="application/x-tex">\lg 2^{24} \approx 7.2247</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">.</span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord">7</span></span></span></span>，即可以表示7位十进制数。
<ol>
<li>因为要用科学计数法，底数第一位必须是1，因此可以省略第一位。因此此处的23位可以表达24位二进制数。</li>
</ol>
</li>
</ol>
<p>7.25的IEEE754表示：</p>
<p><code>0 1000'0001 110'1000'0000'0000'0000'0000</code></p>

        <h2 id="浮点数的好处"   >
          <a href="#浮点数的好处" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#浮点数的好处"></a> 浮点数的好处</h2>
      
<ol>
<li>虽然精度小，但是可表示的范围大（指数的作用）。</li>
<li>能表达实数（除了小数，也能表示整数、0）</li>
<li>能表达NaN（Not A Number），0除以0的结果就是NaN。
<ol>
<li><code>0 1111'1111 100'0000'0000'0000'0000'0000</code></li>
</ol>
</li>
<li>能表达正负inf（无穷大），比如1除以0。
<ol>
<li>正无穷：<code>0 1111'1111 000'0000'0000'0000'0000'0000</code></li>
<li>负无穷：<code>1 1111'1111 000'0000'0000'0000'0000'0000</code></li>
</ol>
</li>
</ol>

        <h2 id="怎么比较浮点数"   >
          <a href="#怎么比较浮点数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#怎么比较浮点数"></a> 怎么比较浮点数</h2>
      

        <h3 id="首先是不带等号的大小判断"   >
          <a href="#首先是不带等号的大小判断" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#首先是不带等号的大小判断"></a> 首先是不带等号的大小判断（&lt;、&gt;）</h3>
      
<ul>
<li>对于 <code>a &lt; b</code>、<code>a &gt; b</code> 这种​<strong>​大小关系比较​</strong>​，通常可以​<strong>​安全地直接使用运算符​</strong>​。</li>
<li>因为即使存在微小的舍入误差，只要这个误差不足以改变大小关系的本质（即误差远小于 <code>a</code> 和 <code>b</code> 本身的差值），结果就是正确的。</li>
<li>判断 <code>a</code> 是否严格大于 <code>b</code> 时，应该使用 <code>a &gt; b</code>，而不是 <code>!(a &lt;= b)</code>（后者涉及相等判断，不精确）。</li>
</ul>

        <h3 id="特殊值的比较"   >
          <a href="#特殊值的比较" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#特殊值的比较"></a> 特殊值的比较</h3>
      
<ul>
<li>特殊值如 <code>NaN</code> (Not a Number) 与任何值（包括自己）比较，<code>==</code> 都返回 <code>false</code>，<code>!=</code> 都返回 <code>true</code>。必须用专门的函数检查：
<ul>
<li>Python: <code>math.isnan(x)</code></li>
<li>C/C++: <code>isnan(x)</code> (来自 <code>math.h</code> 或 <code>cmath</code>)</li>
<li>Java: <code>Double.isNaN(x)</code> / <code>Float.isNaN(x)</code></li>
</ul>
</li>
<li>检查无穷大：
<ul>
<li>Python: <code>math.isinf(x)</code></li>
<li>C/C++: <code>isinf(x)</code></li>
<li>Java: <code>Double.isInfinite(x)</code> / <code>Float.isInfinite(x)</code></li>
</ul>
</li>
</ul>

        <h3 id="涉及到两个浮点数是否相等时"   >
          <a href="#涉及到两个浮点数是否相等时" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#涉及到两个浮点数是否相等时"></a> 涉及到两个浮点数是否相等时</h3>
      
<p><strong>绝对不能直接用 <code>==</code> 或 <code>!=</code> 来判断两个浮点数是否“相等”！​</strong>​<br />
因为浮点数在计算机内部使用 IEEE 754 标准以二进制存储小数，很多十进制小数无法精确表示（例如 <code>0.1</code>），计算过程中也会积累微小的舍入误差。<br />
正确的比较方法是​<strong>​允许一定的误差范围（容差 epsilon）​</strong>​：</p>
<ol>
<li>​<strong>​检查近似相等 (Approximate Equality)：​</strong>​
<ul>
<li>计算两个浮点数 <code>a</code> 和 <code>b</code> 的绝对差值：<code>diff = abs(a - b)</code></li>
<li>定义一个非常小的正数作为容忍度 <code>epsilon</code>（例如 <code>1e-9</code>, <code>1e-12</code>, 具体值取决于你的精度要求）。</li>
<li>如果 <code>diff &lt;= epsilon</code>，则认为 <code>a</code> 和 <code>b</code> 在 <code>epsilon</code> 的误差范围内是“相等”的。</li>
<li>但是这个容差是绝对容差，有缺陷，见下：</li>
</ul>
</li>
</ol>
<ul>
<li><strong>检查相对相等 (Relative Equality - 更稳健)：​</strong>​
<ul>
<li>当数值大小差异巨大时，固定绝对容差可能不合适（比如比较 1e9 和 1e9+1e-9 时差值很小，但比较 1e-9 和 2e-9 时用绝对容差 1e-9 会认为相等）。相对容差考虑数值的大小。</li>
<li><code>rel_tol</code>: 相对容差（如 1e-5, 1e-9）</li>
<li><code>abs_tol</code>: 绝对容差下限（保证接近零的数也能比较，例如设为 <code>1e-12</code>）</li>
</ul>
</li>
</ul>
<p>下面主要论述，为什么需要相对相等（使用相对容差）</p>
<p>直接使用绝对相等的容差（比如 <code>abs(a - b) &lt;= 1e-9</code>）在大多数情况下是有效的。但是，它有一个显著的缺点：当比较的数值本身非常大或者非常小（靠近零）时，这个固定大小的绝对容差就显得不合理了。</p>
<ol>
<li>
<p>​<strong>​问题场景一：数值巨大​</strong>​</p>
<ul>
<li>例子：比较 <code>a = 1, 000, 000, 000 (1e9)</code> 和 <code>b = 1, 000, 000, 001 (1e9 + 1)</code></li>
<li>它们的绝对差是 <code>|a - b| = 1</code>。</li>
<li>如果你设定的绝对容差 <code>epsilon = 1e-9</code>（即 0.000000001），那么 <code>1 &gt; 1e-9</code>，程序会判断它们​<strong>​不相等​</strong>​。</li>
<li>但直觉上，10亿和10亿零1之间的_相对误差_非常小（大约是 <code>1 / 1e9 = 1e-9</code>）。在很多科学计算或工程领域，这个精度已经足够了，我们可能希望认为它们_相对相等_。</li>
<li>​<strong>​结论：​</strong>​ 当数值本身很大时，一个固定的小绝对容差过于严格，忽略了数值的量级。</li>
</ul>
</li>
<li>
<p>​<strong>​问题场景二：数值极小（接近零）​</strong>​</p>
<ul>
<li>例子：比较 <code>a = 0.000001 (1e-6)</code> 和 <code>b = 0.000002 (2e-6)</code></li>
<li>它们的绝对差是 <code>|a - b| = 0.000001 (1e-6)</code>。</li>
<li>如果你设定的绝对容差 <code>epsilon = 1e-9</code>（即 0.000000001），那么 <code>1e-6 &gt; 1e-9</code>，程序会判断它们​<strong>​不相等​</strong>​。</li>
<li>但是，它们的相对差非常大（一个是另一个的两倍，相对误差高达 <code>1e-6 / 1e-6 = 1</code> 或 100%）。实际上，它们_不应_被看作是近似相等的。</li>
<li>​<strong>​结论：​</strong>​ 当数值本身很小时，一个固定的小绝对容差又过于宽松，可能把差别很大的两个数判断为相等。</li>
<li>​<strong>​更麻烦的问题：比较接近零的数​</strong>​
<ul>
<li>例子：比较 <code>a = 0.000000001 (1e-9)</code> 和 <code>b = 0.000000002 (2e-9)</code></li>
<li>绝对差 <code>|a - b| = 1e-9</code>，如果我们设定的绝对容差也是 <code>1e-9</code>，那么程序会认为它们相等。</li>
<li>例子：比较 <code>a = 1e-20</code> 和 <code>b = 2e-20</code></li>
<li>绝对差 <code>|a - b| = 1e-20</code>。一个合理的绝对容差（比如 <code>1e-9</code>）远远大于这个差值（<code>1e-9 &gt; 1e-20</code>），所以程序也会认为它们相等。但从相对角度看，<code>b</code> 是 <code>a</code> 的两倍！</li>
<li>​<strong>​总结：​</strong>​ 对于非常接近零的数，即使设置了一个看似很小的绝对容差，也可能过于宽松，无法反映数值之间的真实相对误差。这时甚至需要一个更小的、不切实际的绝对容差才能区分它们，而相对相等可以自然地处理这种情况（此时相对误差会很大）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>​<strong>​相对相等的解决方案：引入相对容差​</strong>​</p>
<p>相对相等的核心思想是：​<strong>​判断两个数是否近似相等的标准，应该与它们自身的_大小_有关。​</strong>​</p>
<ol>
<li>
<p>​<strong>​核心公式：​</strong>​</p>
<p><code>abs(a - b) &lt;= max(rel_tol * max(|a|, |b|), abs_tol)</code></p>
<ul>
<li><code>rel_tol</code>: ​<strong>​相对容差（relative tolerance）​</strong>​。这是一个很小的正数，表示你能接受的_最大相对误差_（例如 <code>0.01</code> 表示 1% 的相对误差，<code>1e-5</code> 表示 0.001% 的相对误差，<code>1e-9</code> 表示极小的相对误差）。这个值需要根据你的具体应用场景（你对精度的要求）来设定。</li>
<li><code>abs_tol</code>: ​<strong>​绝对容差下限（absolute tolerance）​</strong>​。这也是一个很小的正数（例如 <code>1e-12</code>）。它的作用是确保当 <code>a</code> 和 <code>b</code> 都_非常非常接近零_时，公式仍然有效。</li>
</ul>
</li>
<li>
<p>​<strong>​公式解读：​</strong>​</p>
<ul>
<li><code>max(|a|, |b|)</code>: 取 <code>a</code> 和 <code>b</code> 的绝对值中较大的那个。这代表了参与比较的两个数在数值上的大致_量级（Scale）_。</li>
<li><code>rel_tol * max(|a|, |b|)</code>: ​<strong>​动态计算的相对容差​</strong>​。这个容差会根据 <code>a</code> 和 <code>b</code> 的当前量级自动调整：
<ul>
<li>当 <code>a</code> 和 <code>b</code> 很大时，这个值会变大，可以容忍较大的绝对差值（只要相对误差小）。</li>
<li>当 <code>a</code> 和 <code>b</code> 很小时（但还没有小到必须依赖 <code>abs_tol</code>），这个值会变小，要求更小的绝对差值才能被视为相等。</li>
</ul>
</li>
<li><code>max( ..., abs_tol)</code>: 取 <code>动态计算的相对容差</code> 和 <code>abs_tol</code> 中​<strong>​较大的那个​</strong>​作为最终的容差阈值。
<ul>
<li>当 <code>a</code> 和 <code>b</code> 远离零时，<code>动态计算的相对容差</code> 通常会远大于 <code>abs_tol</code>，所以<code>max</code> 的结果就是相对容差。</li>
<li>当 <code>a</code> 和 <code>b</code> 非常接近零（或者其中一个为零）时，<code>动态计算的相对容差</code> (<code>rel_tol * max(|a|, |b|)</code>) 会变得非常小（接近于零）。如果此时没有 <code>abs_tol</code>，即使两个非常接近零但彼此不同的数（比如 <code>1e-20</code> 和 <code>2e-20</code>，差值 <code>1e-20</code>），也会因为 <code>1e-20</code> &gt; <code>某个几乎为零的动态相对容差</code> (比如 <code>1e-9 * 2e-20 = 2e-29</code>) 而被错误地认为_不相等_（而实际上根据相对误差，它们差异很大）。更极端的是比较 <code>0</code> 和一个很小的数（比如 <code>1e-30</code>），<code>动态计算的相对容差</code> 会变成 <code>0</code>，没有 <code>abs_tol</code> 就无法进行有效比较。加入 <code>abs_tol</code> 提供了这个绝对下限。</li>
<li><code>abs_tol</code> 就是为了确保在这种情况下，公式不会因为 <code>动态计算的相对容差</code> 太小而失效。它会提供一个最低限度的绝对容差保证（比如 <code>1e-12</code>）。如果 <code>|a - b| &lt;= abs_tol</code>，即使 <code>a</code> 和 <code>b</code> 本身很小（导致 <code>rel_tol * max(|a|, |b|)</code> 更小），也能认为它们在绝对意义上足够接近零。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>​<strong>​举例说明：​</strong>​</p>
<ul>
<li>​<strong>​情况一：大数值（相对容差主导）​</strong>​
<ul>
<li><code>a = 1e9</code>, <code>b = 1e9 + 1000</code> (<code>|a-b|=1000</code>)</li>
<li>设 <code>rel_tol=1e-6</code>, <code>abs_tol=1e-9</code></li>
<li><code>max(|a|,|b|) ≈ 1e9</code></li>
<li><code>动态相对容差 = 1e-6 * 1e9 = 1000</code></li>
<li><code>max(1000, 1e-9) = 1000</code></li>
<li><code>1000 (|a-b|) &lt;= 1000 (阈值)</code> → ​<strong>​相对相等（成立）​</strong>​</li>
</ul>
</li>
<li>​<strong>​情况二：中等数值（相对容差主导）​</strong>​
<ul>
<li><code>a = 3.141592</code>, <code>b = 3.141593</code> (<code>|a-b|=0.000001</code>)</li>
<li>设 <code>rel_tol=1e-6</code>, <code>abs_tol=1e-9</code></li>
<li><code>max(|a|,|b|) ≈ 3.1416</code></li>
<li><code>动态相对容差 ≈ 1e-6 * 3.1416 ≈ 3.1416e-6</code></li>
<li><code>max(3.1416e-6, 1e-9) ≈ 3.1416e-6</code></li>
<li><code>0.000001 (1e-6) ≈ 1e-6 &lt; 3.1416e-6 (阈值)</code> → ​<strong>​相对相等（成立）​</strong>​</li>
<li>注意：如果只用 <code>abs_tol=1e-9</code>，<code>1e-6 &gt; 1e-9</code>，会被判为不相等。相对容差（<code>≈ 3e-6</code>）更合理。</li>
</ul>
</li>
<li>​<strong>​情况三：小数值（绝对容差主导）​</strong>​
<ul>
<li><code>a = 1e-10</code>, <code>b = 2e-10</code> (<code>|a-b|=1e-10</code>)</li>
<li>设 <code>rel_tol=1e-6</code>, <code>abs_tol=1e-12</code></li>
<li><code>max(|a|,|b|) = 2e-10</code></li>
<li><code>动态相对容差 = 1e-6 * 2e-10 = 2e-16</code> (非常小！)</li>
<li><code>max(2e-16, 1e-12) = 1e-12</code> (因为 <code>1e-12</code> 远大于 <code>2e-16</code>)</li>
<li><code>1e-10 (|a-b|) &lt;= 1e-12</code>? ​<strong>​1e-10 &gt; 1e-12​</strong>​ → ​<strong>​不相等（成立）​</strong>​
<ul>
<li><em>解释：</em> 虽然它们很小（都在 <code>1e-10</code> 量级），但<code>b</code>是<code>a</code>的2倍！相对误差极大。绝对容差 <code>1e-12</code> 无法容忍 <code>1e-10</code> 这么大的差，所以正确判定不相等。动态相对容差 <code>2e-16</code> 在这里太小而没起作用，<code>abs_tol</code> <code>1e-12</code> 提供了合适的判断依据。</li>
</ul>
</li>
</ul>
</li>
<li>​<strong>​情况四：非常接近零（绝对容差主导）​</strong>​
<ul>
<li><code>a = 0</code>, <code>b = 1.5e-12</code></li>
<li>设 <code>rel_tol=1e-6</code>, <code>abs_tol=1e-12</code></li>
<li><code>max(|a|,|b|) = 1.5e-12</code></li>
<li><code>动态相对容差 = 1e-6 * 1.5e-12 = 1.5e-18</code> (极其小！)</li>
<li><code>max(1.5e-18, 1e-12) = 1e-12</code></li>
<li><code>1.5e-12 (|a-b|) &lt;= 1e-12</code>? ​<strong>​1.5e-12 &gt; 1e-12​</strong>​ → ​<strong>​不相等（成立）​</strong>​</li>
<li><em>想让它被判定为接近零（相等）：</em>
<ul>
<li>可以设置更大的 <code>abs_tol</code>，比如 <code>abs_tol=1.6e-12</code></li>
<li><code>1.5e-12 &lt;= 1.6e-12</code> → ​<strong>​相对相等（成立）​</strong>​</li>
</ul>
</li>
</ul>
</li>
<li>​<strong>​情况五：相对容差和绝对容差都参与（通常发生在中等或较小数值）​</strong>​
<ul>
<li>公式选取两者中较大的作为最终容差，确保在两种标准中满足其一即可视为相等。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>在代码中使用：​</strong>​</p>
<p>在 Python 中，推荐使用标准库 <code>math.isclose</code>：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> math.isclose(a, b, rel_tol=<span class="number">1e-9</span>, abs_tol=<span class="number">1e-12</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a and b are considered close&quot;</span>)</span><br></pre></td></tr></table></div></figure>
<ul>
<li><code>rel_tol</code>：相对容差，通常 <code>1e-9</code> 是一个较高的精度要求，<code>1e-6</code> 或 <code>1e-3</code> 可能用于精度要求较低的领域。根据你的需求设定。</li>
<li><code>abs_tol</code>：绝对容差下限，通常设置为一个非常小的数（如 <code>0.0</code>， <code>1e-12</code>, <code>1e-15</code>），或者当你知道要处理接近零的数时，设置成一个合适的、比“显著差异”要小的值（例如，如果你的数据精度极限是 <code>1e-10</code>，<code>abs_tol=1e-12</code> 可能就太小了，需要设成 <code>1e-9</code> 或更大，但这时最好通过相对容差来覆盖非零区域）。 <code>abs_tol</code> 最主要的作用是确保 <code>a</code> 和 <code>b</code> 都接近零时比较逻辑仍然工作。</li>
</ul>
<p>​<strong>​总结：​</strong>​</p>
<p>相对相等 (<code>abs(a - b) &lt;= max(rel_tol * max(|a|, |b|), abs_tol)</code>) 是一种更​<strong>​稳健（Robust）​</strong>​的浮点数近似相等判断方法。它通过结合​<strong>​相对容差​</strong>​（<code>rel_tol</code>）来解决大数值比较的问题，以及​<strong>​绝对容差下限​</strong>​（<code>abs_tol</code>）来解决非常接近零的数值比较的问题，从而在各种不同的数值量级上提供更合理、更一致的比较结果。在复杂应用中，优先考虑使用相对相等而不是简单的绝对容差相等。</p>

        <h2 id="练习题"   >
          <a href="#练习题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#练习题"></a> 练习题</h2>
      

        <h3 id="csapp-3rd-p93-284"   >
          <a href="#csapp-3rd-p93-284" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#csapp-3rd-p93-284"></a> CSAPP-3rd P93 2.84</h3>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数f2u返回一个无符号<span class="number">32</span>位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是NaN。两种<span class="number">0</span>，+<span class="number">0</span>和一<span class="number">0</span>被认为是相等的。</span><br><span class="line"><span class="type">int</span> <span class="title function_">float_1e</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> ux=f2u(x);</span><br><span class="line"><span class="type">unsigned</span> uy=f2u(y);</span><br><span class="line"><span class="comment">/*Get the sign bits*/</span></span><br><span class="line"><span class="type">unsigned</span> sx=ux &gt;&gt;<span class="number">31</span>;</span><br><span class="line"><span class="type">unsigned</span> sy=uy &gt;&gt;<span class="number">31</span>;</span><br><span class="line"><span class="comment">/*Give an expression using only ux，uy，sx，and sy*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">如果使用判断就比较简单，下面是不使用判断.</span><br><span class="line">第一个参数是否小于等于第二个参数，将可能满足的情况（即会返回<span class="number">1</span>的情况）进行分类处理。</span><br><span class="line">情况一：两个参数相等且为<span class="number">0</span>， 根据IEEE规则，<span class="number">0</span>用Denormalized表示，且有+<span class="number">0</span>(<span class="number">0x0</span>)和<span class="number">-0</span>(<span class="number">0x80000000</span>)两种表示 所以通过左移一位来比较</span><br><span class="line">==&gt;ux &lt;&lt; <span class="number">1</span> == <span class="number">0</span> &amp;&amp; uy &lt;&lt; <span class="number">1</span> == <span class="number">0</span></span><br><span class="line">情况二：第一个参数为负(此时ux&gt;&gt;<span class="number">31</span>为sx=<span class="number">0x1</span>得到!sx=<span class="number">0</span>) ，第二个参数为<span class="number">0</span>或者正数(此时uy&gt;&gt;<span class="number">31</span>为sy=<span class="number">0x0</span> !sy=<span class="number">1</span>)</span><br><span class="line">==&gt;(sx &amp;&amp; !sy)</span><br><span class="line">反之，若第一个参数为正或者<span class="number">0</span>， 第二个参数为负，这种情况肯定返回<span class="number">0</span>，就不需要特殊处理。</span><br><span class="line">情况三：两个参数都为正</span><br><span class="line">==&gt;(!sx &amp;&amp; !sy &amp;&amp; ux &lt;= uy)</span><br><span class="line">情况四：两个参数都为负，此时根据IEEE的定义 正数可以用无符号整数的升序进行排列（正数越大 无符号数越大） 负数可以用无符号整数的升序进行排列（负数越小，无符号数越大）</span><br><span class="line">==&gt;(sx &amp;&amp; sy &amp;&amp; ux &gt;= uy)</span><br><span class="line">四种情况或运算,满足一种就返回<span class="number">1</span>。</span><br></pre></td></tr></table></div></figure>

        <h3 id="讨论题"   >
          <a href="#讨论题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#讨论题"></a> 讨论题</h3>
      
<p>下列哪些浮点数是符合标准的？<code>1.e0</code>、<code>1.2e0</code>、<code>.2e0</code>、<code>123</code>、<code>1e0</code>、<code>2e4.2</code>、<code>1.2</code>、<code>.e5</code><br />
​​<code>2e4.2</code>：不符合​。指数部分 (<code>e4.2</code>) 包含了小数点 <code>.</code>。指数必须是一个​<strong>​整数​</strong>​（可正可负，如 <code>4</code>, <code>-2</code>, <code>+10</code>）。<br />
<code>.e5</code>：​​不符合​。尾数部分 <code>.e5</code> 缺少有效的数字。前面只有小数点 <code>.</code> 而没有跟随任何数字。必须在小数点前后至少有一方包含数字（如 <code>.1</code>, <code>1.</code>, <code>1.2</code>, <code>1e5</code>）。</p>

        <h1 id="两道诡异的题目"   >
          <a href="#两道诡异的题目" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#两道诡异的题目"></a> 两道诡异的题目</h1>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">char</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, c, a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为44 44</span></span><br></pre></td></tr></table></div></figure>
<p>a和b同为8位有符号整型类数据。直接加和，a+b等于300。a和b都是char型，最后得出的结果也是char型：因为溢出了8位的最大范围（0~255），所以需要模256，最终300转换后的结果等效于44。</p>
<p>44是存储在内存中的数据，最终显示给人类的还是44，因为44没有超过127，也就不用涉及到补码来表示负数。（反之的情况，如果模后的结果是128，则表示人类所看到的负数-128；如果模后的结果是255，则表示-1）</p>
<p>既然a和b都是char型，最后得出的结果也是char型，所以&quot;c&quot;和&quot;a+b&quot;两者代表的意义是一样的，最终都是char型下的44。于是输出结果为44。</p>
<p>上面的题目只是乐呵一下，下面的题目才诡异莫测，如果对计算机的底层运算法则、流程不详，那么是无法领会的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">char</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, c, a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为44 300</span></span><br></pre></td></tr></table></div></figure>
<p>我们默认我们在x86体系架构下的、字长为32位的环境下运行。根据微机原理x86的描述，我们的通用寄存器有<code>eax/ebx/ecx/edx</code>。其中低16位叫做<code>ax/bx/cx/dx</code>。再分，低16位中的高8位叫做<code>ah/bh/ch/dh</code>、低8位叫做<code>al/bl/cl/dl</code>。</p>
<p>经过测试，在VS2019编译器下，反汇编代码得出：<code>a+b</code>这个语句的运算首先要把a和b的值分别存放到寄存器<code>eax/ecx</code>中。注意：eax和ecx都是32位寄存器，<strong>如果把a和b的值分别存放到寄存器eax/ecx中，意味着存放了原来的8位有效数据外，前面的24位都需要补位</strong>，而无符号整型数据补前位时用0补位。<br />
存数据之后，对两数的加操作是：<code>add eax,ecx</code>。<strong>即加操作是在寄存器内累加的</strong>。那么即使300超过了255，本应溢出的数据仍然能有效保存在寄存器eax中（即关键的第9位——“1”）。</p>
<p>接下来：</p>
<p><strong>对于<code>char c = a + b</code>;</strong>，对c的赋值是通过eax赋值的，因为声明了c是有符号char型，赋值时存在隐形类型转换，即要进行隐式的切片操作，将切除前24位，留下后8位。所以：这里编译器只把低八位即AL赋给了c。因此，上述的eax寄存器中关键的第9位——&quot;1&quot;失效了，只保留了后八位，最终打印c的结果是44。</p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818214251517.png" alt="image-20210818214251517" /></p>
<p><strong>对于<code>a + b</code>;</strong>，a和b在eax寄存器中直接加和的结果是300，即使超过了255，本应溢出的数据仍然能有效保存在寄存器eax中（即关键的第9位——“1”）。而我们格式化控制的输出是<code>%d</code>，即我们要拿4个字节即<strong>32位有符号整型</strong>来识别内存的数据，<strong>并在最后转为十进制数</strong>，所以打印出来是300。（其实如果拿<code>%u</code>来打印更合适，即<strong>32位无符号整型</strong>来识别内存的数据，<strong>并在最后转为十进制数</strong>，最后打印出来也是300）</p>

        <h2 id="习题"   >
          <a href="#习题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc = <span class="number">128</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> us = <span class="number">0</span>;</span><br><span class="line">    us = c + uc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>,us);<span class="comment">//0</span></span><br><span class="line">    </span><br><span class="line">    us = (<span class="type">unsigned</span> <span class="type">char</span>)c+uc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>,us);<span class="comment">//16:100-&gt;10:256</span></span><br><span class="line">    </span><br><span class="line">    us = c+(<span class="type">char</span>)uc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>,us);<span class="comment">//2:1111 1111 1000 0000+1111 1111 1000 0000=&gt;(1) 1111 1111 0000 0000 -&gt; 16:ff00</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同us = c + uc;原理一样，都是相当于把c存放到16位ax寄存器中，自然需要补位，而c原本是有符号数，则补符号位&quot;1&quot;。</span></span><br><span class="line">	<span class="comment">//强转为(unsigned short)就表示存放到16位ax寄存器中。其实我们不用人为地显式写出&quot;(unsigned short)&quot;，因为c+uc肯定需要达到统一类型，自然要把char c隐式转为unsigned short，即无符号16位数据。</span></span><br><span class="line">    us = (<span class="type">unsigned</span> <span class="type">short</span>)c+uc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>,us);<span class="comment">//1111 1111 1000 0000+0000 0000 1000 0000=&gt;(1) 0000 0000 0000 0000 =&gt;0 -&gt; 16:0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//0 100 ff00 0</span></span><br></pre></td></tr></table></div></figure>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224646093.png" alt="image-20210818224646093" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224658042.png" alt="image-20210818224658042" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224711482.png" alt="image-20210818224711482" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224728892.png" alt="image-20210818224728892" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210818224743542.png" alt="image-20210818224743542" /></p>

        <h1 id="高超的技艺"   >
          <a href="#高超的技艺" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#高超的技艺"></a> 高超的技艺</h1>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最拉跨的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get1Bit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">0x01</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//面试宝典中</span></span><br><span class="line"><span class="comment">//老师不讲，学生永远不知道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get1Bit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x &amp;(x<span class="number">-1</span>);</span><br><span class="line">        sum+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查表方案</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get1Bit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ar[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(x)*<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + ar[x &amp; <span class="number">0x0f</span>];</span><br><span class="line">        x = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这个减1就与原数按位与，每次都会少个1。</p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823024356781.png" alt="image-20210823024356781" /></p>
<p>计算一个4字节整型的二进制格式中1的个数。</p>
<p>有一位图论的学生，面试时通过此题进入了腾讯。</p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823021837556.png" alt="image-20210823021837556" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823021900711.png" alt="image-20210823021900711" /></p>
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210823021915500.png" alt="image-20210823021915500" /></p>

        <h1 id="断位"   >
          <a href="#断位" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#断位"></a> 断位</h1>
      
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b:<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c:<span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">x</span>=</span>&#123;&#125;;</span><br><span class="line">    x.a = <span class="number">4</span>;</span><br><span class="line">    x.b = <span class="number">2</span>;</span><br><span class="line">    x.c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h1 id="刷题"   >
          <a href="#刷题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#刷题"></a> 刷题</h1>
      
<p><img src="../../images/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20210921200013444.png" alt="image-20210921200013444" /></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getDecimalValue</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res &lt;&lt; <span class="number">1</span> | p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/141/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/141/">141</a><span class="page-number current">142</span><a class="page-number" href="/page/143/">143</a><span class="space">&hellip;</span><a class="page-number" href="/page/150/">150</a><a class="extend next" rel="next" href="/page/143/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/touxiang.png" alt="avatar"></div><p class="sidebar-ov-author__text">无论哪里，生活继续。</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/xing-cg" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://gitee.com/mrcan" target="_blank" rel="noopener" data-popover="social.gitee" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">Gitee</span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/people/mrcan666" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-zhihu"></i></span></a><a class="sidebar-ov-social-item" href="tencent://message?uin=1933966629" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="mailto:xing-cg@qq.com" target="_blank" rel="noopener" data-popover="social.QQmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a><a class="sidebar-ov-social-item" href="https://blog.csdn.net/mrcan666" target="_blank" rel="noopener" data-popover="csdn" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">300</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Mr.Can All Rights Reserved</span><span class="footer__devider">|</span><span><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备2025135168号</a></span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.3.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function loadValine () {
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var guest_info = 'nick,mail,link';

  guest_info = guest_info.split(',').filter(function(item) {
    return GUEST_INFO.indexOf(item) > -1;
  });
  new Valine({
    el: '#valine-container',
    appId: 'QTXELGPwB2iKLovJroJUqbVP-gzGzoHsz',
    appKey: 'DDfRbL0aLE3KEHXtbNXHrlEQ',
    notify: true,
    verify: true,
    placeholder: '欢迎写下你的评论，同时欢迎留下你的昵称和邮箱！',
    avatar: 'mp',
    meta: guest_info,
    pageSize: '10' || 10,
    visitor: true,
    recordIP: true,
    lang: 'zh-cn' || 'zh-cn',
    path: window.location.pathname
  });
}

if (false) {
  loadValine();
} else {
  window.addEventListener('DOMContentLoaded', loadValine, false);
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>