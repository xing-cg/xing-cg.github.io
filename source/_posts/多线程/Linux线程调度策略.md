---
title: Linux线程调度策略
categories:
  - - Linux
  - - 操作系统
    - 多线程
tags: 
date: 2022/5/26
updated: 
comments: 
published:
---
# 内容

1. 先来先服务（FIFO）调度策略
2. 时间片轮转调度策略
3. 分时调度策略
# Linux内核线程的三种调度策略

函数`pthread_attr_setschedpolicy`和`pthread_attr_getschedpolicy`分别用来设置、获取线程的调度策略。

```c
int pthread_attr_setschedpolicy(pthread_attr_t *, int policy);
int pthread_attr_getschedpolicy(const pthread_attr_t *, int policy);
参数：
    attr 	- 线程属性变量
    policy	- 调度策略
返回值
    成功返回0，失败返回-1
```

1. `SCHED_OTHER`：分时调度策略，非实时。不支持优先级。
2. `SCHED_FIFO`：先到先服务，实时。一旦占用cpu则一直运行。直到有更高优先级任务或主动放弃cpu。
3. `SCHED_RR`：时间片轮转，实时。当进程的时间片用完，重新分配时间片长度，置于就绪队列尾。可以看作是FIFO的延伸。

# 先到先服务策略

1. 创建进程时指定采用FIFO，并设置**实时优先级**`rt_priority`(1-99)。
2. 如果没有等待资源，则将该任务加入到就绪队列中。
3. 调度程序遍历就绪队列，根据**实时优先级**计算调度权值(`1000+rt_priority`)，选择权值最高的任务使用cpu，**该FIFO任务将一直占有cpu直到有优先级更高的任务就绪**(即使优先级相同也不行)**或者主动放弃(等待资源)**。
4. 调度程序发现有优先级更高的任务到达(高优先级任务可能被中断或定时器任务唤醒，再或被当前运行的任务唤醒等等)，则调度程序立即在当前任务堆栈中保存当前cpu寄存器的所有数据，重新从高优先级任务的堆栈中加载寄存器数据到cpu，此时高优先级的任务开始运行。重复第3步。
5. 如果当前任务因等待资源而主动放弃cpu使用权，则该任务将从就绪队列中删除，加入等待队列，此时重复第3步。

# 时间片轮转策略

所有任务都采用RR调度策略时：

1. 创建任务时指定调度参数为RR，并设置任务的**实时优先级**和**nice值**(nice值将会转换为该任务的时间片的长度)。

   > 可见，相比于FIFO，时间片轮转法多了一个nice值，用于计算时间片长度。

2. 如果没有等待资源，则将该任务加入到就绪队列中。

3. 调度程序遍历就绪队列，根据**实时优先级**计算调度权值(`1000+rt_priority`)，**选择权值最高**的任务使用cpu。

   > 相比于FIFO，FIFO会一直占用CPU，直到更高优先级线程到达。

4. 如果就绪队列中的RR任务**时间片为0，则会根据nice值设置该任务的时间片，同时将该任务放入就绪队列的末尾**。重复步骤3。

5. 当前任务由于等待资源而主动退出cpu，则其加入等待队列中。重复步骤3。

# 分时调度策略

所有任务都采用Linux分时调度策略时：

1. 创建任务指定采用分时调度策略，并指定nice值(`-20~19`, 可以认为值越小优先级越高)。

   > 相比于FIFO，没有**实时优先级**数值属性(1~99)

2. 将**根据每个任务的nice值确定在cpu上的执行时间**(counter)。

3. 如果没有等待资源，则将该任务**加入到就绪队列**中。

4. 调度程序**遍历就绪队列**中的任务，通过对每个任务动态优先级的计算权值(`counter+20-nice`)结果，选择计算结果最大的一个去运行，当这个时间片用完后(`counter减至0`)或者主动放弃cpu时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃cpu)中。

5. 此时调度程序重复上面计算过程，转到第4步。

6. 当调度程序发现所有就绪任务计算所得的权值都`不大于0时`，重复第2步。

# 区别

系统中既有分时调度，又有时间片轮转调度和先进先出调度：

1. RR调度和FIFO调度的进程属于实时进程，以分时调度的进程是非实时进程。
2. 当实时进程准备就绪后，如果当前cpu正在运行非实时进程，则实时进程立即抢占非实时进程。
3. RR进程和FIFO进程**都采用实时优先级**做为调度的**权值标准**，RR是FIFO的一个延伸。
4. FIFO时，如果两个进程的优先级一样，则这两个优先级一样的进程具体执行哪一个是由其在队列中的未知决定的，这样导致一些不公正性（优先级是一样的，为什么要让你一直运行？），如果将两个优先级一样的任务的调度策略都设为RR，则保证了这两个任务可以循环执行，保证了公平。