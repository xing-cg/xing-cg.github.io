---
title: 高级数据结构_B树家庭
categories:
  - - 高级数据结构
    - 树
tags: 
date: 2025/3/4
update: 
comments: 
published:
---
# B
B树是由Rudolf Bayer和Edward M. McCreight在波音研究实验室工作时发明的，目的是有效地**管理大型随机访问文件的索引页面**。基本假设是索引会非常庞大，以至于只有树的小块可以放入主内存中。

Bayer和McCreight从未解释过"B"代表什么, 如果可能的话, 可能会是：Boeing、balanced、broad、busy和Bayer。McCreight曾说过“你对B树中的'B'的含义思考得越多，你对B树的理解就越好。”

不管"B"代表的什么含义, 总之肯定不是"Binary", 因为B树不是二叉树; 那么, 我们暂且就把B Tree中的"B"当做是"Balanced"吧!
# m阶平衡树

m阶, 这个"阶"对于树来说怎么解释?

拿例子说话吧!

AVL树, 就是一个2阶平衡树, 所谓2阶, 指的是, 1个节点有2个指针域指向2个孩子, 和1个数据域;

那么, m阶的意思就是: $1$个节点最多有$m$个指针域指向$m$个孩子, 和最多有$m-1$个数据域;

B树的特点是和AVL如出一辙的, 甚至比AVL还要道高一尺, AVL只能保证左右子树高度差不超过1, 而B树的性质保证了所有叶节点同时在同一层, 由此可以看出, B树是比AVL更平衡的树; 

由此可见, B树只不过是一个2阶平衡树(AVL)的一个横向变种罢了! 本质上还是AVL的灵魂; 

> 形式上都是平衡的, 但, 与AVL最大的不同是, B树没有节点的旋转操作, 而是涉及到分裂/合并;
# B树的性质

根据Knuth的定义，$m$阶B树是满足以下性质的树：

1. 每个节点最多有$m$个子节点。
2. 每个内部节点至少有$\lceil m/2 \rceil$个子节点。
3. 每个非叶节点至少有2个孩子。
4. 所有叶子都出现在同一层次上并且不携带任何信息。
5. 具有$k$个子节点的非叶节点包含$k-1$个键。

每个内部节点的键充当分割其子树的分隔值。例如，如果一个内部节点有3个子节点（或子树），那么它必须有2个键：$a_1$和$a_2$。 最左子树中的所有值都小于$a_1$，中间子树中的所有值都在$a_1$和$a_2$之间，最右子树中的所有值都大于$a_2$。
# B树、AVL、红黑树、BST这些搜索树的对比
B树即平衡树，m阶平衡树。符合搜索树的性质（中序遍历有序）。

4阶平衡树即2-3-4树，指树的节点最多有3个关键码，4个分支。2-3-4树实际上就是4阶B树。即: 每个节点, 最多有三个数据, 4个孩子节点

2阶平衡树即AVL树。一个节点有2个分支。

但BST不是2阶平衡树，因为BST中的B指的不是Balanced，而是Binary，因此BST没有平衡性质。

AVL树节点的左右子树高度差不超过1。

B树相比AVL更平衡，因为所有叶子节点都在同一层。适用于文件索引系统。

B树、AVL树、红黑树、BST本质上都是一棵搜索树，只不过B树是m阶的。AVL、红黑树、BST是2阶的。B树完全平衡，AVL树高度平衡，红黑树近乎平衡，BST不平衡。
# B树的行为
## 插入
特点是，如果节点内的关键码达到了m个，将会分裂。把m个关键码中的中间值往上推一层。被上移的节点左右指向剩下的两半。
## 删除
有两种常用的删除策略：
1. 定位并删除元素，然后调整树使它满足约束条件。
2. 从上到下处理这棵树，在进入一个节点之前，调整树使得之后一旦遇到了要删除的元素，它可以被直接删除而不需要再进行调整。
    1. 这种策略就类似于，红黑树的删除操作前，先让所有的2-型节点扩张为3-型或4-型节点，再去直接删除。见“C语言_树”

以下讨论的是第1种策略。

1. 有没有孩子
    1. 如果删除的关键码没有孩子，可以直接删除。
    2. 如果删除的关键码有孩子，需要从左孩子节点中找最右值或右孩子找最左值，将其上移补位。等于是把孩子中的一个关键码删去了。
2. 删除后
    1. 如果删除后，节点的关键码数小于$(m/2)(上取整)-1$。（比如，5阶B树，删除后节点关键码数目小于2（即1个）；4阶B树（2-3-4树）中删除后节点关键码数目小于1（即0个））。这叫做“**不丰满**”。
    2. 如果节点的关键码数大于$(m/2)(上取整)-1$，叫做“**丰满**”。
    3. 若等于，则类似于“**刚刚脱贫**”。此时如果删去一个元素，就会“不丰满”。
    4. 兄弟丰满，**借**：如果删除后“不丰满”，则把父节点元素下移补充，而父节点需要向该删除后的节点相邻的丰满的兄弟节点中借一个元素。
    5. 兄弟太穷，**并**：如果相邻的兄弟节点都是“刚刚脱贫”的，就要靠父节点下移一个元素，补充到这个删除的位置，然后与相邻的一个兄弟节点进行“合并”成为一个节点。

5阶B树为例，删除：
![](../../images/高级数据结构_B树家庭/b-tree-2.svg)
如图所示，接下来要依次删除 8，20，18，5。

首先要删除元素 8。先查找到元素 8 在叶子节点中，删除 8 后叶子节点的元素个数为 2，符合 B 树的规则。然后需要把元素 11 和 12 都向前移动一位。完成后如图所示。
![](../../images/高级数据结构_B树家庭/b-tree-3.svg)
下一步，删除 20，因为 20 没有在叶子节点中，而是在中间节点中找到，可以发现 20 的继承者是 23（字母升序的下个元素），然后需要将 23 上移到 20 的位置，之后将孩子节点中的 23 进行删除。

删除后检查一下，该孩子节点中元素个数大于 2，无需进行合并操作。

所以这一步之后，B 树如下图所示。
![](../../images/高级数据结构_B树家庭/b-tree-4.svg)
下一步删除 18，18 在叶子节点中，但是该节点中元素数目为 2，删除导致只有 1 个元素，已经小于最小元素数目 2。

而由前面已经知道：如果其某个相邻兄弟节点中比较丰满（元素个数大于 $\lceil \dfrac{5}{2} \rceil - 1$），则可以向父节点借一个元素，然后将最丰满的相邻兄弟节点中上移最后或最前一个元素到父节点中。

在这个实例中，右相邻兄弟节点中比较丰满（3 个元素大于 2），所以先向父节点借一个元素 23 下移到该叶子节点中，代替原来 19 的位置。19 前移。

然后 24 在相邻右兄弟节点中，需要上移到父节点中。最后在相邻右兄弟节点中删除 24，后面的元素前移。

这一步之后，B 树如下图所示。
![](../../images/高级数据结构_B树家庭/b-tree-5.svg)
最后一步需要删除元素 5，但是删除后会导致很多问题。因为 5 所在的节点数目刚好达标也就是刚好满足最小元素个数 2。

而相邻的兄弟节点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点先借父节点一个元素，再与某相邻兄弟节点进行合并操作；首先移动父节点中的元素（该元素在两个需要合并的两个节点元素之间）下移到其子节点中。

然后将这两个节点进行合并成一个节点。所以在该实例中，首先将父节点中的元素 4 下移到已经删除 5 而只有 6 的节点中，然后将含有 4 和 6 的节点和含有 1，3 的相邻兄弟节点进行合并成一个节点。

这一步之后，B 树如下图所示。
![](../../images/高级数据结构_B树家庭/b-tree-6.svg)
但是这里观察到父节点只包含了一个元素 7，这就没有达标（因为非根节点包括叶子节点的元素数量 ![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "K") 必须满足于 $2\le K\le 4$)，而此处的 $K=1$）。

如果这个问题节点的相邻兄弟比较丰满，则可以向父节点借一个元素。而此时兄弟节点元素刚好为 2，刚刚满足，只能进行合并，而根节点中的唯一元素 13 下移到子节点。这样，树的高度减少一层。

所以最终的效果如下图。
![](../../images/高级数据结构_B树家庭/b-tree-7.svg)
# B树的应用场景 - 文件索引(数据库索引)
B树本质上还是一棵搜索树，只不过是m阶的。

如果系统所管理的数据量很大，需要用磁盘、硬盘、外存存储，那么为了提高效率，会给数据创建索引。为了索引查询的高效，需要给索引排序。
## 总结
文件索引管理最主要的 2 个问题：
1. 更快的搜索算法（索引的关键码）
    1. 对于搜索算法倒是没什么差异，AVL树和B树同样都是二分查找的分治策略, 时间复杂度都为$O(\log n)$。
2. 更少的磁盘IO、更低的内存缺页率
    1. 对于树的层数来说，AVL树和B树是有很大差异的。
    2. **若索引太庞大，必须每次从磁盘中读取**：**树的层高**，会直接影响到在最差情况下的**磁盘I/O次数**。
        1. 因为每次访问一个节点时，都需要将磁盘块（Block）加载到内存中。
        2. 300阶B树刚好把一个最大节点的大小接近4KB即页大小。一个节点对应着1页，若索引相邻，则利用局部性原理提效。
    3. **若索引可以从磁盘一次性加载到内存中**：
        1. 一个节点能容纳的索引数量，决定了索引在内存中的分散度。如果节点内存地址太分散（像红黑树，只能存3个索引），可能会面临更高的内存缺页中断率。**间接影响了磁盘I/O次数**。
3. 总之，无论索引能不能一次性载入内存，B树都占有优势，集合了层低、节点容量大的优势。
## 操作系统原理
操作系统中
1. 内存，按页面(page)为最小单位分配、管理，默认每一页4K。
    1. 所以代码上看似我们只占用了几字节，但是实际上可能占用了1页。
    2. 某些场景会使用大页（Huge Pages，如 2MB 或 1GB）以优化性能，但这需要显式配置，并非默认行为。
2. 磁盘，按块(block)为最小单位分配、管理。大多数文件系统（如 ext4、NTFS）默认使用 ​4KB 的块大小，与内存页对齐以提高效率。
    1. 所以操作系统在读取文件时，并不是只读取了几个字节，而是整个块大小。
    2. **可配置性**：块大小可以按需调整（如 1KB、8KB、16KB 等），通常用于特定场景（如处理超大文件或数据库优化）。
    3. **物理扇区与逻辑块**：磁盘的物理扇区大小可能为 512B 或 4KB，但文件系统的逻辑块（Block）会组合多个扇区，形成更大的逻辑单元，16KB 的块就是由 32 个 512B 扇区组成的。
### B树的设计目标：优化磁盘I/O
- ​树高更低，减少I/O次数：B树通过多路分支显著降低树的高度。
    - 301阶B树存储1千万索引，仅需3层（根节点→中间节点→叶子节点）。
    - 而AVL树需要24层，红黑树更高。  
    - 树高直接决定最坏情况下的磁盘I/O次数，尤其是在索引部分存储在磁盘时，B树的优势更明显。

- 节点大小匹配磁盘块
    - B树的每个节点可以存储 ​**多个键值**​（例如，301阶B树的节点可存300个键），其节点大小通常设计为接近 ​**磁盘块大小**​（如4KB）。这使得每次磁盘I/O能读取更多有效数据，**充分利用磁盘块的空间**。
    - 反观红黑树或AVL树：作为二叉平衡树，每个节点仅存1个键，导致树的高度极高（例如，1千万索引的AVL树高达24层）。即使索引部分在内存中，若树节点分散存储，可能会因为内存缺页中断，仍需多次磁盘I/O。
### 局部性原理与顺序访问优化（范围查询的优势）
- ​顺序访问的高效性
    - 对比红黑树/AVL树：范围查询需要多次中序遍历，产生大量随机I/O。
- ​磁盘预读机制的利用
    - 磁盘每次读取数据时会预读相邻块（局部性原理）。B树的节点内键值有序且密集存储，**顺序扫描时能充分利用预读数据**；而二叉树的分散存储导致随机I/O，无法利用预读。
### 分析和方案
如果我们有1千万份简历文件，每份简历文件为10M，则粗略计算其有9000G。
如何对所有简历文件的内容进行查询？
我们的内存是有限的，按照数组的方式进行查询，一次只能加载一部分。如果可用的内存大小只有1G，有可能需要加载9000次，太慢了。

如果简历以身份证号为关键码，我们只需要在内存中加载它们的身份证号和其简历对应的文件指针即可。这就是文件索引。

再结合搜索算法，如果要高效地搜索，如二分查找，则需要对关键码进行排序。

文件在磁盘中可以不按身份证号排序。

如果想要创建新的简历，那么关键码需要插入已有的关键码中。
这时候关键码的数据结构就会影响到效率。
如果是用数组存储，虽然读取上很搞效，但插入、删除时间复杂度为O(n)。
如果是用链表存储，虽然插入、删除很高效，但读取上就很慢。
这种静态的存储方式不行。
如果是树形存储，如红黑树存储，虽然可以较好地平衡查询、修改的时间复杂度，但是每一个节点都是malloc申请的堆上内存，根据计算机的存储体系结构，会导致其节点地址在内存结构中呈碎片化，不利于缓存的命中，效率依然不够高。**节点在内存中碎片化的影响是会触发内存的缺页中断，需要换页，换页会触发读取磁盘IO，消耗时间**。

可以考虑两种方案：
1. 哈希表。
2. 300阶B树。红黑树本质上是一个4阶B树，其每一个节点最多存储3个索引。而300阶B树则可以让节点存储更多连续的数据。尽量让这个数据块的大小正好是内存的页大小（4KB）。提高了内存、缓存命中率。
## AVL树和B树存储索引的对比
假如, 目前有1千万个索引要从磁盘中进行读取并且进行搜索。
对于AVL树，每一个节点只能对应 1 个索引元素（关键码）。
对于B树，每一个节点可以容纳$m-1$个索引元素（关键码）。

| 参数                               | AVL的高度                      | 300阶B树的高度                      |
| -------------------------------- | --------------------------- | ------------------------------ |
| 10,000,000个索引元素($n=1\times10^7$) | $\lceil\log_2 n\rceil = 24$ | $\lceil\log_{300} n\rceil = 3$ |
对于读取操作，无所谓。
但是对于修改操作，那么如果插入、删除一条数据记录，就会让树结构进行调整。
### 如果索引全部加载到内存中
1. ​**索引的搜索过程在内存中完成**：  
    无论是AVL树还是B树，查找目标索引的路径（从根节点到叶子节点）全部在内存中进行，**不涉及磁盘IO**。只有最后根据文件指针读取实际文件时才会触发磁盘IO。
2. ​**文件读取的磁盘IO次数**：  
    找到目标索引后，需通过文件指针从磁盘读取对应的实际文件。无论索引结构层数多少，**仅需1次磁盘IO**​（读取目标文件）。
### 实际数据库中，索引可能远大于内存容量
- ​大规模数据索引无法完全放入内存
    - 实际数据库中，索引可能远大于内存容量。B树通过多级节点将热点数据保留在内存（如根节点常驻内存），冷数据存储在磁盘，**减少内存压力**。 
    - 红黑树/AVL树：若索引无法全放入内存，每次访问深层节点都可能触发磁盘I/O，性能急剧下降。
- ​写操作的磁盘友好性​
    - B树的节点分裂/合并操作是 ​**局部性修改**​（仅影响相邻节点），适合批量写入磁盘；
    - 而红黑树/AVL树的旋转操作可能导致 ​**全局结构调整**，产生更多随机I/O。
# B+树，B树的改进
B+树可以看作是B树的优化，比 B 树更适合实际应用中的索引。目前现代关系型数据库最广泛的支持索引结构就是 B+ 树。

总之：B+树明确分出leaf/internal节点, 让internal 只存key，只有leaf存全部的索引信息 （ `B∗`树则是节点满的时候先不拆分而是尽可能合并到邻居节点）

![](../../images/高级数据结构_B树家庭/image-20250305071843256.png)

B+树与B树差异的点，主要是以下这几点：
1. 非叶子节点只会存放关键码，不存储实际数据。
2. 叶子节点才会存放实际数据。
3. 全部的信息都会在叶子节点出现。
4. 非叶子节点存储的关键码是每个子节点中的最小值。
5. 叶子节点之间构成一个有序链表。

## 相比B树的优势
1. 数据量相同的情况下，B+树的非叶子节点数据密度更大，存储效率高。B+树的非叶子节点可以存放更多的关键码，因此B+树可以比B树更「矮胖」，查询底层节点的磁盘IO次数会更少。
2. 查询更稳定，由于非叶结点并不是最终指向文件内容的结点，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3. B+树的叶子节点通过指针形成有序链表，**范围查询（如`WHERE id BETWEEN 100 AND 200`）只需遍历叶子节点**，避免了回溯到上层节点。 

例子：假设磁盘中的一个盘块可容纳 16 B，而一个关键字大小 2 B。一个关键字具体信息指针大小 2 B。
一棵9阶B树（一个结点最多 8 个关键字）的内部结点需要 2 个盘块。而B+树内部结点只需要 1 个盘块。当需要把内部结点读入内存中的时候，B树就比B+树多一次盘块查找时间（在磁盘中就是盘片旋转的时间）。