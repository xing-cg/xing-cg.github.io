---
typora-root-url: ../..
title: C语言_volatile&const
categories:
  - [C]
tags:
  - null 
date: 2021/9/26
updated:
comments:
published:
---

# 演示

```c
int main()
{
	volatile const int a = 0;
	int b = a;
	int* p = (int*)&a;
	*p = 10;
}
```

![image-20210926094934967](../../images/C%E8%AF%AD%E8%A8%80_volatile&const/image-20210926094934967.png)

```c
int main()
{
	const int a = 0;
	int b = a;
	int* p = (int*)&a;
	*p = 10;
}
```

![image-20210926095031711](../../images/C%E8%AF%AD%E8%A8%80_volatile&const/image-20210926095031711.png)

如果变量被volatile修饰，则是在给编译器说明：该变量可能随时被改写。所以编译器就不会轻易地去优化代码结构。

const：本程序段中不能对此变量作修改，任何修改都是不通过的，或者至少是粗心，编译器应该报错，防止这种粗心。但const修饰的变量不允许这里修改不代表不允许别处修改，比如：

```c
   
int i = 5;
const int* p = &i;
*p = 6; // 不可以；
i = 7; // 完全可以，而且那个“const”的“*p”也跟着变成了7。
```

**const和volatile放在一起的意义在于：**

（1）本程序段中不能对a作修改，任何修改都是不通过的，或者至少是粗心，编译器应该报错，防止这种粗心；

（2）另一个程序段则完全有可能修改，因此编译器最好不要做太激进的优化。

**“const”**含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”。
**“volatile”**的含义是“请不要做没谱的优化，这个值可能变掉的”，而并非“你可以修改这个值”。
因此，它们本来就不是矛盾的。

const volatile int i=10;这行代码有没有问题?如果没有，那 i 到底是什么属性?

回答一：没有问题，例如只读的状态寄存器。它是volatile，因为它可能被意想不到地改变;它是const，因为程序不应该试图去修改它。volatile和const并不矛盾，只是控制的范围不一样，一个在程序本身之外，另一个是程序本身。

回答二：没问题，const和volatile这两个类型限定符不矛盾。const表示(运行时)常量语义：被const修饰的对象在所在的作用域无法进行修改操作，编译器对于试图直接修改const对象的表达式会产生编译错误。volatile表示“易变的”，即在运行期对象可能在当前程序上下文的控制流以外被修改(例如多线程中被其它线程修改;对象所在的存储器可能被多个硬件设备随机修改等情况)：被volatile修饰的对象，编译器不会对这个对象的操作进行优化。一个对象可以同时被const和volatile修饰，表明这个对象体现常量语义，但同时可能被当前对象所在程序上下文意外的情况修改。另外，LS错误，const可以修饰左值，修饰的对象本身也可以作为左值(例如数组)。