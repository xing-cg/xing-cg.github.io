---
title: Cpp_Google代码规范
categories:
  - - Cpp
tags: 
date: 2025/9/10
updated: 2025/9/10
comments: 
published:
---
文章：https://google.github.io/styleguide/cppguide.html
源码：https://github.com/google/styleguide/blob/gh-pages/cppguide.html
# `#define`守卫
符号名称的格式应是`<PROJECT>_<PATH>_<FILE>_H_`。
为了保证唯一性，应该基于项目源代码树中的完整路径。例如，项目`foo`中的文件`foo/src/bar/baz.h`，应该这么写：
```cpp
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```
# 不要依赖传递`#include`
bar.h
```cpp
// bar.h
#ifndef BAR_H
#define BAR_H
class Bar {
    // ... Bar 的成员 ...
};
#endif // BAR_H
```
foo.h
```cpp
// foo.h
#ifndef FOO_H
#define FOO_H

#include "bar.h" // 当前 foo.h 需要 Bar 来声明 useBar 的参数

void useBar(const Bar& b); // 声明使用 Bar

#endif // FOO_H
```
foo.cc
```cpp
// foo.cc (错误写法：依赖 foo.h 包含 bar.h)
#include "foo.h" // 指望 foo.h 已经包含了 bar.h

void useBar(const Bar& b) {
    // ... 使用 b (Bar 对象) ...
}
```
导致的问题：如果将来`foo.h`中删除了`#include "bar.h"`，那么还需要在`foo.cc`添加`#include "bar.h"`，导致牵一发动全身。

正确写法：
```cpp
// foo.cc (正确写法：显式包含 bar.h)
#include "foo.h"
#include "bar.h" // 显式包含，因为直接使用了 Bar

void useBar(const Bar& b) {
    // ... 使用 b (Bar 对象) ...
}
```
这保证了 `foo.h`的修改（清理不必要的 `#include`）不会意外破坏 `foo.cc`的编译。每个文件都清晰地声明了自己的直接依赖。
# 前置声明
避免使用前置声明，而是 include 需要的头文件。

​**​核心观点：尽量避免使用前置声明，优先使用 `#include` 包含所需的头文件。​**​

​**​什么是前置声明 (Forward Declaration)?​**​
- ​**​定义：​**​ 前置声明是指在代码中​**​声明​**​某个实体（如类、函数、变量、模板等）的存在，但​**​不提供其完整定义​**​。
- ​**​目的：​**​ 告诉编译器这个符号的名字和类型（对于函数和变量），但不需要知道其内部细节（如类的成员、函数的实现、变量的值等）。
- ​**​示例：​**​
    
    ```cpp
    class MyClass;      // 类的前置声明 (告诉编译器 MyClass 是一个类)
    void myFunction();  // 函数的前置声明
    extern int myVar;    // 变量的前置声明 (通常用于全局变量)
    ```
    

## ​Pros (优点/好处 - 为什么有人想用前置声明)​​
规范列举了使用前置声明可能带来的好处，但请注意，规范的整体立场是​**​不推荐​**​使用，所以这些优点更像是解释为什么开发者有时会倾向于使用它：
1. ​**​节省编译时间：​**​ `#include` 会让编译器打开并处理被包含文件的所有内容（可能又包含更多文件）。使用前置声明可以避免这些开销，特别是当包含的头文件很大或嵌套很深时。
2. ​**​减少不必要的重新编译：​**​ 如果一个头文件被修改了，所有直接或间接包含它的源文件都需要重新编译。如果一个头文件 `A.h` 包含了 `B.h`，那么修改 `B.h` 会导致包含 `A.h` 的所有文件都重编。如果 `A.h` 只用了 `B.h` 中的某个类指针或引用，并且改用前置声明 `class B;` 而不是 `#include "B.h"`，那么修改 `B.h` 的某些细节（比如 `B` 类的私有成员）可能​**​不会​**​触发 `A.h` 及其包含者的重编译。这可以加快增量编译速度。
## ​Cons (缺点/坏处 - 为什么 Google 规范不推荐使用)​

规范详细列举了前置声明的诸多弊端，这也是其建议避免使用的主要原因：
1. ​**​隐藏依赖关系：​**​ 这是最核心的问题。前置声明使得代码的依赖关系变得不清晰。源文件 `foo.cc` 使用了 `class Bar`，但只通过前置声明 `class Bar;` 引入，而没有 `#include "bar.h"`。当 `bar.h` 发生改变（比如 `Bar` 类的大小、成员函数签名变化）时，编译器可能​**​无法意识到​**​ `foo.cc` 需要重新编译，导致链接错误或更糟糕的运行时错误。这破坏了构建系统的可靠性。
2. ​**​阻碍自动化工具：​**​ 代码分析工具、重构工具、IDE 的智能提示等，需要知道符号的完整定义才能正常工作。前置声明使得这些工具难以确定符号的实际定义位置。
3. ​**​限制 API 的兼容性变更：​**​ 库的维护者如果想做一些理论上兼容的修改，可能会因为用户代码使用了前置声明而受阻。例如：
    - 加宽函数参数类型（如 `int` -> `long`）。
    - 给模板添加一个有默认值的模板参数。
    - 将符号移动到新的命名空间。  
        这些修改对于包含完整头文件的用户代码是兼容的，但对于仅使用前置声明的用户代码，可能导致编译失败或行为改变，因为前置声明没有捕捉到这些变化。
4. ​**​`std::` 命名空间的前置声明导致未定义行为：​**​ C++ 标准明确规定，不允许用户代码前置声明标准库 (`std::`) 中的模板或其他实体。这样做会导致​**​未定义行为 (Undefined Behavior)​**​，程序可能编译失败、运行崩溃或产生不可预测的结果。必须 `#include` 相应的标准库头文件（如 `<vector>`, `<string>`）。
5. ​**​可能静默改变代码含义：​**​ 这是一个非常微妙且危险的陷阱。规范中的代码示例清晰地展示了这一点：
    - 在包含完整头文件 `b.h` 的情况下，`test(D*)` 调用 `f(B*)`，因为 `D*` 可以隐式转换为 `B*`。
    - 如果 `good_user.cc` 把 `#include "b.h"` 换成 `class B; class D;`（前置声明），那么 `test(D*)` 会调用 `f(void*)`！因为编译器只知道 `B` 和 `D` 是类类型，但不知道它们之间的继承关系，所以 `D*` 无法隐式转换为 `B*`，只能匹配 `f(void*)`。这种行为的改变是静默发生的，很难调试。
6. ​**​语法冗长：​**​ 如果需要前置声明一个头文件中的多个符号，写一堆 `class X; void Y();` 可能比直接写一个 `#include "that_header.h"` 更冗长。
7. ​**​可能导致次优设计：​**​ 为了能够使用前置声明（例如，在头文件中只使用类指针或引用，避免使用对象成员），开发者可能会被迫采用特定的代码结构（如多用指针、使用 Pimpl 惯用法）。这些结构有时会使代码运行速度变慢（额外的间接访问、堆分配）或增加代码的复杂性（需要管理指针生命周期、实现 Pimpl）。
## ​Decision (决策/结论)​​
- ​**​核心原则：​**​ ​**​尽可能避免使用前置声明。​**​ 优先使用 `#include` 来包含定义了你所需符号的头文件。
- ​**​关键限制：​**​ ​**​尤其要避免对另一个项目中定义的实体使用前置声明。​**​ 这里的“项目”可以理解为不同的库、模块或代码仓库。跨项目的前置声明极大地加剧了上述缺点（特别是隐藏依赖和限制 API 变更），因为项目间的协调和同步更困难。
- ​**​隐含建议：​**​ 在同一个项目内部，如果经过仔细权衡（比如某个头文件改动极其频繁且影响巨大），并且能严格确保依赖清晰、不会引入第 3 点和第 5 点的问题，或许可以​**​极其谨慎地​**​在源文件（`.cc`）中使用前置声明来减少编译依赖。但这需要非常高的警惕性。规范的整体倾向仍然是 `#include` 更安全、更推荐。
## ​总结​
Google C++ 规范认为，虽然前置声明在理论上可以带来编译速度的提升，但其带来的风险（隐藏依赖、破坏构建可靠性、阻碍工具、限制库演化、潜在未定义行为、静默语义改变）远大于收益。因此，规范强烈建议开发者优先使用 `#include` 来明确表达依赖关系，保证代码的健壮性、可维护性和工具友好性，尤其是在跨项目协作时。
# 在头文件中定义函数
​**​核心观点：​**​ 尽量避免在头文件的 ​**​公共 API 声明部分​**​ 直接定义函数体。如果函数定义​**​必须​**​放在头文件中（例如短小的访问器、模板函数、`constexpr` 函数），应将其放在头文件的​**​内部实现部分​**​（如私有区、特定命名空间或注释标记之后），并确保其 ​**​ODR-safe​**​（通常通过 `inline` 关键字、模板或类内定义实现）。
## ​关键概念解释​
1. ​**​文本内联 (Textually inline)：​**​ 指函数的定义（实现代码）直接写在它的声明处。
2. ​**​内联展开 (Inline expansion)：​**​ 编译器优化技术，将函数调用处直接替换为函数体代码，避免函数调用的开销（压栈、跳转、返回）。这通常发生在函数体简单且被频繁调用时。
3. ​**​ODR (One Definition Rule - 单一定义规则)：​**​ C++ 核心规则，要求在整个程序中，任何变量、函数、类类型、枚举类型或模板，​**​最多只能有一个定义​**​（某些情况如 `inline` 函数/变量、模板、类类型定义等允许在多个翻译单元中存在定义，但必须完全相同）。
4. ​**​ODR-safe：​**​ 指在头文件中定义的实体（如函数、变量），通过使用 `inline` 关键字（或符合隐式 `inline` 的条件），使其在多个 `.cpp` 文件包含该头文件时，链接器不会因违反 ODR（出现多个相同定义）而报错。
## ​​Pros (优点/好处 - 为什么有时需要在头文件中定义函数)​​
规范承认在特定情况下，在头文件中定义函数有其合理性和优势：
1. ​**​减少样板代码 (Reduce boilerplate)：​**​ 对于非常简单的函数（如类的 `getter/setter`），直接在类声明中定义比在头文件声明、再到 `.cc` 文件定义要简洁得多。
2. ​**​潜在的优化机会 (Potential optimization)：​**​ 编译器更容易对在头文件中定义的小函数进行内联展开优化，可能生成更高效的代码（省去函数调用开销）。
3. ​**​技术必要性 (Technical necessity)：​**​ ​**​函数模板​**​和 ​**​`constexpr` 函数​**​ 通常​**​必须​**​在声明它们的头文件中定义（或者至少在同一个翻译单元中可见）。因为编译器在实例化模板或计算 `constexpr` 时需要看到完整的定义。这是语言特性决定的。
## ​​Cons (缺点/坏处 - 为什么规范限制在公共部分定义函数)​​
规范强调了在公共 API 部分（即用户一眼就能看到的地方）定义函数的弊端：
1. ​**​降低 API 可读性 (Reduced API readability)：​**​ API 头文件的主要目的是清晰地展示接口（有哪些函数、参数、返回值）。将函数实现细节混杂其中，会增加阅读和理解 API 的难度和认知负担。函数越复杂，这种干扰越大。
2. ​**​暴露实现细节 (Exposes implementation details)：​**​ 将函数体放在公共头文件中，相当于把内部实现逻辑公开了。这些细节通常对 API 使用者来说是无关紧要的（“无害但多余”），甚至可能暴露你不想让用户依赖的内部机制。
## ​​Decision (决策/规则)​​
基于优缺点分析，规范制定了明确的规则：
1. ​**​长度限制 (Length restriction)：​**​
    - 只有​**​非常短​**​的函数（规范建议大约 ​**​10 行或更少​**​），才允许直接在它的​**​公共声明点​**​（如在类定义的 `public:` 部分）定义。
    - ​**​长函数体​**​应该放在 `.cc` 文件中定义，除非有​**​性能原因​**​（编译器内联优化至关重要）或​**​技术原因​**​（如模板、`constexpr`）。
2. ​**​位置隔离 (Location isolation)：​**​
    - 即使函数定义​**​必须​**​放在头文件中（例如，它是一个模板成员函数），也​**​不应该​**​放在公共 API 部分（如 `public:` 或文件顶部）。
    - 应该将定义放在头文件的​**​内部实现区域​**​：
        - 类的 `private:` 部分（即使函数本身是 `public` 的）。
        - 一个包含 `internal` 字样的命名空间内（例如 `namespace myproject_internal { ... }`）。
        - 在明确的注释标记之后（例如 `// Implementation details follow` 或 `// Implementation details only below here`）。
    - ​**​目的：​**​ 将实现细节与公共接口​**​物理分离​**​，提高公共头文件的可读性和整洁度。
3. ​**​ODR 安全 (ODR safety)：​**​
    - 任何在头文件中定义的函数（或变量），​**​必须​**​确保它是 ​**​ODR-safe​**​ 的。这意味着当多个 `.cpp` 文件包含该头文件时，链接器不会报“多重定义”错误。
    - 实现 ODR-safe 的常用方法：
        - 显式使用 `inline` 关键字修饰函数/变量定义。
        - 函数是​**​函数模板​**​。
        - 函数是​**​类成员函数​**​，并且是​**​在类定义内部直接定义的​**​（这是隐式 `inline` 的）。
        - 函数是 `constexpr` (C++11 起，`constexpr` 函数在头文件中定义默认是 `inline` 的)。
        - 变量是 `inline` 变量 (C++17 起) 或 `constexpr` 变量。
## ​代码示例解析
```cpp
template <typename T>
class Foo {
 public:
  // 短函数 (getter)，直接在公共声明点定义 -> 允许 (短 + 隐式 inline)
  int bar() { return bar_; }

  // 长函数声明。定义不能放在这里污染公共接口。
  void MethodWithHugeBody();

 private:
  int bar_;
};

// Implementation details only below here
// **************** 内部实现区域分隔线 ****************

// 长函数定义放在这里 (头文件内部实现区域)
template <typename T>
void Foo<T>::MethodWithHugeBody() {
  ... // 可能很长的实现代码
}
```
- `bar()`：是一个简单的 `getter` 函数，非常短（一行）。它直接在类定义的 `public:` 部分定义。这是允许的，因为它短小，并且作为类内定义的成员函数，它是​**​隐式 `inline`​**​ 的（满足 ODR-safe）。
- `MethodWithHugeBody()`：声明在 `public:` 部分（它是公共接口）。但它的​**​定义​**​被移到了类定义之后、用注释明确标记的​**​内部实现区域​**​。这样保证了公共接口的清晰。因为它是一个​**​模板成员函数​**​，所以它的定义​**​必须​**​在头文件中（技术必要性），并且模板本身保证了 ODR-safe。
## ​​总结​
Google C++ 规范主张保持头文件（尤其是公共 API 部分）的​**​简洁和声明性​**​。函数实现细节应尽量放在 `.cc` 文件中。如果必须在头文件中定义函数（短函数、模板、`constexpr`），应将其放在专门的内部区域，并确保其 ODR-safe。这样做的主要目的是​**​提高代码的可读性、可维护性，并清晰地分离接口与实现​**​。

